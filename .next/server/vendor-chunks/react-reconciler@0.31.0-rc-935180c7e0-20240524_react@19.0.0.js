"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0";
exports.ids = ["vendor-chunks/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0/node_modules/react-reconciler/cjs/react-reconciler-constants.development.js":
/*!********************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0/node_modules/react-reconciler/cjs/react-reconciler-constants.development.js ***!
  \********************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * react-reconciler-constants.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar NoLane =\n/*                          */\n0;\nvar SyncLane =\n/*                        */\n2;\nvar InputContinuousLane =\n/*             */\n8;\nvar DefaultLane =\n/*                     */\n32;\nvar IdleLane =\n/*                        */\n268435456;\n\nvar NoEventPriority = NoLane;\nvar DiscreteEventPriority = SyncLane;\nvar ContinuousEventPriority = InputContinuousLane;\nvar DefaultEventPriority = DefaultLane;\nvar IdleEventPriority = IdleLane;\n\nvar LegacyRoot = 0;\nvar ConcurrentRoot = 1;\n\nexports.ConcurrentRoot = ConcurrentRoot;\nexports.ContinuousEventPriority = ContinuousEventPriority;\nexports.DefaultEventPriority = DefaultEventPriority;\nexports.DiscreteEventPriority = DiscreteEventPriority;\nexports.IdleEventPriority = IdleEventPriority;\nexports.LegacyRoot = LegacyRoot;\nexports.NoEventPriority = NoEventPriority;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtcmVjb25jaWxlckAwLjMxLjAtcmMtOTM1MTgwYzdlMC0yMDI0MDUyNF9yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL3JlYWN0LXJlY29uY2lsZXIvY2pzL3JlYWN0LXJlY29uY2lsZXItY29uc3RhbnRzLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEIsK0JBQStCO0FBQy9CLDRCQUE0QjtBQUM1Qiw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCLGtCQUFrQjtBQUNsQix1QkFBdUI7QUFDdkIsR0FBRztBQUNIIiwic291cmNlcyI6WyIvVXNlcnMvbWhtZC9Eb2N1bWVudHMvR2l0SHViL0FXTS1MYWJlZWItQWkvbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LXJlY29uY2lsZXJAMC4zMS4wLXJjLTkzNTE4MGM3ZTAtMjAyNDA1MjRfcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9yZWFjdC1yZWNvbmNpbGVyL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLWNvbnN0YW50cy5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1yZWNvbmNpbGVyLWNvbnN0YW50cy5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgTWV0YSBQbGF0Zm9ybXMsIEluYy4gYW5kIGFmZmlsaWF0ZXMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gIChmdW5jdGlvbigpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIE5vTGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjA7XG52YXIgU3luY0xhbmUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMjtcbnZhciBJbnB1dENvbnRpbnVvdXNMYW5lID1cbi8qICAgICAgICAgICAgICovXG44O1xudmFyIERlZmF1bHRMYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICAgKi9cbjMyO1xudmFyIElkbGVMYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjI2ODQzNTQ1NjtcblxudmFyIE5vRXZlbnRQcmlvcml0eSA9IE5vTGFuZTtcbnZhciBEaXNjcmV0ZUV2ZW50UHJpb3JpdHkgPSBTeW5jTGFuZTtcbnZhciBDb250aW51b3VzRXZlbnRQcmlvcml0eSA9IElucHV0Q29udGludW91c0xhbmU7XG52YXIgRGVmYXVsdEV2ZW50UHJpb3JpdHkgPSBEZWZhdWx0TGFuZTtcbnZhciBJZGxlRXZlbnRQcmlvcml0eSA9IElkbGVMYW5lO1xuXG52YXIgTGVnYWN5Um9vdCA9IDA7XG52YXIgQ29uY3VycmVudFJvb3QgPSAxO1xuXG5leHBvcnRzLkNvbmN1cnJlbnRSb290ID0gQ29uY3VycmVudFJvb3Q7XG5leHBvcnRzLkNvbnRpbnVvdXNFdmVudFByaW9yaXR5ID0gQ29udGludW91c0V2ZW50UHJpb3JpdHk7XG5leHBvcnRzLkRlZmF1bHRFdmVudFByaW9yaXR5ID0gRGVmYXVsdEV2ZW50UHJpb3JpdHk7XG5leHBvcnRzLkRpc2NyZXRlRXZlbnRQcmlvcml0eSA9IERpc2NyZXRlRXZlbnRQcmlvcml0eTtcbmV4cG9ydHMuSWRsZUV2ZW50UHJpb3JpdHkgPSBJZGxlRXZlbnRQcmlvcml0eTtcbmV4cG9ydHMuTGVnYWN5Um9vdCA9IExlZ2FjeVJvb3Q7XG5leHBvcnRzLk5vRXZlbnRQcmlvcml0eSA9IE5vRXZlbnRQcmlvcml0eTtcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0/node_modules/react-reconciler/cjs/react-reconciler-constants.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0/node_modules/react-reconciler/cjs/react-reconciler.development.js":
/*!**********************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0/node_modules/react-reconciler/cjs/react-reconciler.development.js ***!
  \**********************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @license React\n * react-reconciler.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    module.exports = function $$$reconciler($$$config) {\n        var exports = {};\n        'use strict';\n        var React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@15.1.7_react-dom@19.0.0_react@19.0.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n        var Scheduler = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/.pnpm/scheduler@0.25.0-rc-935180c7e0-20240524/node_modules/scheduler/index.js\");\n        var ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\n        var suppressWarning = false;\n        function setSuppressWarning(newSuppressWarning) {\n            {\n                suppressWarning = newSuppressWarning;\n            }\n        } // In DEV, calls to console.warn and console.error get replaced\n        // by calls to these methods by a Babel plugin.\n        //\n        // In PROD (or in packages without access to React internals),\n        // they are left as they are instead.\n        function warn(format) {\n            {\n                if (!suppressWarning) {\n                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    printWarning('warn', format, args);\n                }\n            }\n        }\n        function error(format) {\n            {\n                if (!suppressWarning) {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning('error', format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var isErrorLogger = format === '%s\\n\\n%s\\n' || format === '%o\\n\\n%s\\n\\n%s\\n';\n                if (ReactSharedInternals.getCurrentStack) {\n                    var stack = ReactSharedInternals.getCurrentStack();\n                    if (stack !== '') {\n                        format += '%s';\n                        args = args.concat([\n                            stack\n                        ]);\n                    }\n                }\n                if (isErrorLogger) {\n                    // Don't prefix our default logging formatting in ReactFiberErrorLoggger.\n                    // Don't toString the arguments.\n                    args.unshift(format);\n                } else {\n                    // TODO: Remove this prefix and stop toStringing in the wrapper and\n                    // instead do it at each callsite as needed.\n                    // Careful: RN currently depends on this prefix\n                    // eslint-disable-next-line react-internal/safe-string-coercion\n                    args = args.map(function(item) {\n                        return String(item);\n                    });\n                    args.unshift('Warning: ' + format);\n                } // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, args);\n            }\n        }\n        var assign = Object.assign;\n        var LegacyRoot = 0;\n        var ConcurrentRoot = 1;\n        /**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */ function get(key) {\n            return key._reactInternals;\n        }\n        function set(key, value) {\n            key._reactInternals = value;\n        }\n        // -----------------------------------------------------------------------------\n        // Killswitch\n        //\n        // Flags that exist solely to turn off a change in case it causes a regression\n        // when it rolls out to prod. We should remove these as soon as possible.\n        // -----------------------------------------------------------------------------\n        // -----------------------------------------------------------------------------\n        // Land or remove (moderate effort)\n        //\n        // Flags that can be probably deleted or landed, but might require extra effort\n        // like migrating internal callers or performance testing.\n        // -----------------------------------------------------------------------------\n        // TODO: Finish rolling out in www\n        var favorSafetyOverHydrationPerf = true;\n        var enableAsyncActions = true; // Need to remove didTimeout argument from Scheduler before landing\n        var disableDefaultPropsExceptForClasses = true; // -----------------------------------------------------------------------------\n        // Slated for removal in the future (significant effort)\n        //\n        // These are experiments that didn't work out, and never shipped, but we can't\n        // delete from the codebase until we migrate internal callers.\n        // -----------------------------------------------------------------------------\n        // Add a callback property to suspense to notify which promises are currently\n        // in the update queue. This allows reporting and tracing of what is causing\n        // the user to see a loading state.\n        //\n        // Also allows hydration callbacks to fire when a dehydrated boundary gets\n        // hydrated or deleted.\n        //\n        // This will eventually be replaced by the Transition Tracing proposal.\n        var enableSuspenseCallback = false; // Experimental Scope support.\n        var enableAsyncIterableChildren = false;\n        var enableLazyContextPropagation = false; // FB-only usage. The new API has different semantics.\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        var alwaysThrottleRetries = true;\n        var passChildrenWhenCloningPersistedNodes = false;\n        var syncLaneExpirationMs = 250;\n        var transitionLaneExpirationMs = 5000; // -----------------------------------------------------------------------------\n        // This allows us to land breaking changes to remove legacy mode APIs in experimental builds\n        // before removing them in stable in the next Major\n        var disableLegacyMode = true;\n        // Debugging and DevTools\n        // -----------------------------------------------------------------------------\n        // Adds user timing marks for e.g. state updates, suspense, and work loop stuff,\n        // for an experimental timeline tool.\n        var enableSchedulingProfiler = true; // Helps identify side effects in render-phase lifecycle hooks and setState\n        var enableProfilerTimer = true; // Record durations for commit and passive effects phases.\n        var enableProfilerCommitHooks = true; // Phase param passed to onRender callback differentiates between an \"update\" and a \"cascading-update\".\n        var enableProfilerNestedUpdatePhase = true; // Adds verbose console logging for e.g. state updates, suspense, and work loop\n        var FunctionComponent = 0;\n        var ClassComponent = 1;\n        var HostRoot = 3; // Root of a host tree. Could be nested inside another node.\n        var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\n        var HostComponent = 5;\n        var HostText = 6;\n        var Fragment = 7;\n        var Mode = 8;\n        var ContextConsumer = 9;\n        var ContextProvider = 10;\n        var ForwardRef = 11;\n        var Profiler = 12;\n        var SuspenseComponent = 13;\n        var MemoComponent = 14;\n        var SimpleMemoComponent = 15;\n        var LazyComponent = 16;\n        var IncompleteClassComponent = 17;\n        var DehydratedFragment = 18;\n        var SuspenseListComponent = 19;\n        var ScopeComponent = 21;\n        var OffscreenComponent = 22;\n        var LegacyHiddenComponent = 23;\n        var CacheComponent = 24;\n        var TracingMarkerComponent = 25;\n        var HostHoistable = 26;\n        var HostSingleton = 27;\n        var IncompleteFunctionComponent = 28;\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_LEGACY_ELEMENT_TYPE = Symbol.for('react.element');\n        var REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element');\n        var REACT_PORTAL_TYPE = Symbol.for('react.portal');\n        var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\n        var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\n        var REACT_PROFILER_TYPE = Symbol.for('react.profiler');\n        var REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n        var REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\n        var REACT_CONTEXT_TYPE = Symbol.for('react.context');\n        var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\n        var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\n        var REACT_MEMO_TYPE = Symbol.for('react.memo');\n        var REACT_LAZY_TYPE = Symbol.for('react.lazy');\n        var REACT_SCOPE_TYPE = Symbol.for('react.scope');\n        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for('react.debug_trace_mode');\n        var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\n        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for('react.legacy_hidden');\n        var REACT_TRACING_MARKER_TYPE = Symbol.for('react.tracing_marker');\n        var REACT_MEMO_CACHE_SENTINEL = Symbol.for('react.memo_cache_sentinel');\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = '@@iterator';\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== 'object') {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === 'function') {\n                return maybeIterator;\n            }\n            return null;\n        }\n        function getWrappedName$1(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || '';\n            return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName$1(type) {\n            return type.displayName || 'Context';\n        }\n        var REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            if (typeof type === 'function') {\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    // TODO: Create a convention for naming client references with debug info.\n                    return null;\n                }\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === 'string') {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return 'Fragment';\n                case REACT_PORTAL_TYPE:\n                    return 'Portal';\n                case REACT_PROFILER_TYPE:\n                    return 'Profiler';\n                case REACT_STRICT_MODE_TYPE:\n                    return 'StrictMode';\n                case REACT_SUSPENSE_TYPE:\n                    return 'Suspense';\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return 'SuspenseList';\n            }\n            if (typeof type === 'object') {\n                {\n                    if (typeof type.tag === 'number') {\n                        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n                    }\n                }\n                switch(type.$$typeof){\n                    case REACT_PROVIDER_TYPE:\n                        {\n                            return null;\n                        }\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        {\n                            return getContextName$1(context) + '.Provider';\n                        }\n                    case REACT_CONSUMER_TYPE:\n                        {\n                            var consumer = type;\n                            return getContextName$1(consumer._context) + '.Consumer';\n                        }\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName$1(type, type.render, 'ForwardRef');\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || 'Memo';\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var functionName = innerType.displayName || innerType.name || '';\n            return outerType.displayName || (functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\n        } // Keep in sync with shared/getComponentNameFromType\n        function getContextName(type) {\n            return type.displayName || 'Context';\n        }\n        function getComponentNameFromOwner(owner) {\n            if (typeof owner.tag === 'number') {\n                return getComponentNameFromFiber(owner);\n            }\n            if (typeof owner.name === 'string') {\n                return owner.name;\n            }\n            return null;\n        }\n        function getComponentNameFromFiber(fiber) {\n            var tag = fiber.tag, type = fiber.type;\n            switch(tag){\n                case CacheComponent:\n                    return 'Cache';\n                case ContextConsumer:\n                    {\n                        var consumer = type;\n                        return getContextName(consumer._context) + '.Consumer';\n                    }\n                case ContextProvider:\n                    {\n                        var _context = type;\n                        return getContextName(_context) + '.Provider';\n                    }\n                case DehydratedFragment:\n                    return 'DehydratedFragment';\n                case ForwardRef:\n                    return getWrappedName(type, type.render, 'ForwardRef');\n                case Fragment:\n                    return 'Fragment';\n                case HostHoistable:\n                case HostSingleton:\n                case HostComponent:\n                    // Host component type is the display name (e.g. \"div\", \"View\")\n                    return type;\n                case HostPortal:\n                    return 'Portal';\n                case HostRoot:\n                    return 'Root';\n                case HostText:\n                    return 'Text';\n                case LazyComponent:\n                    // Name comes from the type in this case; we don't have a tag.\n                    return getComponentNameFromType(type);\n                case Mode:\n                    if (type === REACT_STRICT_MODE_TYPE) {\n                        // Don't be less specific than shared/getComponentNameFromType\n                        return 'StrictMode';\n                    }\n                    return 'Mode';\n                case OffscreenComponent:\n                    return 'Offscreen';\n                case Profiler:\n                    return 'Profiler';\n                case ScopeComponent:\n                    return 'Scope';\n                case SuspenseComponent:\n                    return 'Suspense';\n                case SuspenseListComponent:\n                    return 'SuspenseList';\n                case TracingMarkerComponent:\n                    return 'TracingMarker';\n                // The display name for these tags come from the user-provided type:\n                case IncompleteClassComponent:\n                case IncompleteFunctionComponent:\n                    {\n                        break;\n                    }\n                // Fallthrough\n                case ClassComponent:\n                case FunctionComponent:\n                case MemoComponent:\n                case SimpleMemoComponent:\n                    if (typeof type === 'function') {\n                        return type.displayName || type.name || null;\n                    }\n                    if (typeof type === 'string') {\n                        return type;\n                    }\n                    break;\n            }\n            return null;\n        }\n        var NoFlags$1 = /*                      */ 0;\n        var PerformedWork = /*                */ 1;\n        var Placement = /*                    */ 2;\n        var DidCapture = /*                   */ 128;\n        var Hydrating = /*                    */ 4096; // You can change the rest (and add more).\n        var Update = /*                       */ 4;\n        /* Skipped value:                                 0b0000000000000000000000001000; */ var ChildDeletion = /*                */ 16;\n        var ContentReset = /*                 */ 32;\n        var Callback = /*                     */ 64;\n        /* Used by DidCapture:                            0b0000000000000000000010000000; */ var ForceClientRender = /*            */ 256;\n        var Ref = /*                          */ 512;\n        var Snapshot = /*                     */ 1024;\n        var Passive$1 = /*                      */ 2048;\n        /* Used by Hydrating:                             0b0000000000000001000000000000; */ var Visibility = /*                   */ 8192;\n        var StoreConsistency = /*             */ 16384; // It's OK to reuse these bits because these flags are mutually exclusive for\n        // different fiber types. We should really be doing this for as many flags as\n        // possible, because we're about to run out of bits.\n        var ScheduleRetry = StoreConsistency;\n        var ShouldSuspendCommit = Visibility;\n        var DidDefer = ContentReset;\n        var FormReset = Snapshot;\n        var HostEffectMask = /*               */ 32767; // These are not really side effects, but we still reuse this field.\n        var Incomplete = /*                   */ 32768;\n        var ShouldCapture = /*                */ 65536;\n        var ForceUpdateForLegacySuspense = /* */ 131072;\n        var Forked = /*                       */ 1048576; // Static tags describe aspects of a fiber that are not specific to a render,\n        // e.g. a fiber uses a passive effect (even if there are no updates on this particular render).\n        // This enables us to defer more work in the unmount case,\n        // since we can defer traversing the tree during layout to look for Passive effects,\n        // and instead rely on the static flag as a signal that there may be cleanup work.\n        var RefStatic = /*                    */ 2097152;\n        var LayoutStatic = /*                 */ 4194304;\n        var PassiveStatic = /*                */ 8388608;\n        var MaySuspendCommit = /*             */ 16777216; // Flag used to identify newly inserted fibers. It isn't reset after commit unlike `Placement`.\n        var PlacementDEV = /*                 */ 33554432;\n        var MountLayoutDev = /*               */ 67108864;\n        var MountPassiveDev = /*              */ 134217728; // Groups of flags that are used in the commit phase to skip over trees that\n        // don't contain effects, by checking subtreeFlags.\n        var BeforeMutationMask = // flag logic (see #20043)\n        Update | Snapshot | 0;\n        var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility | FormReset;\n        var LayoutMask = Update | Callback | Ref | Visibility; // TODO: Split into PassiveMountMask and PassiveUnmountMask\n        var PassiveMask = Passive$1 | Visibility | ChildDeletion; // Union of tags that don't get reset on clones.\n        // This allows certain concepts to persist without recalculating them,\n        // e.g. whether a subtree contains passive effects or portals.\n        var StaticMask = LayoutStatic | PassiveStatic | RefStatic | MaySuspendCommit;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n                }\n            }\n        }\n        var prefix;\n        function describeBuiltInComponentFrame(name) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || '';\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return '\\n' + prefix + name;\n            }\n        }\n        function describeDebugInfoFrame(name, env) {\n            return describeBuiltInComponentFrame(name + (env ? ' (' + env + ')' : ''));\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap$1 = typeof WeakMap === 'function' ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap$1();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return '';\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher = null;\n            {\n                previousDispatcher = ReactSharedInternals.H; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactSharedInternals.H = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, 'props', {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === 'object' && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === 'function') {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === 'string') {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                'name', {\n                    value: 'DetermineComponentFrameRoot'\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split('\\n');\n                    var controlLines = controlStack.split('\\n');\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes('<anonymous>')) {\n                                            _frame = _frame.replace('<anonymous>', fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === 'function') {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactSharedInternals.H = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : '';\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n            {\n                if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeClassComponentFrame(ctor) {\n            {\n                return describeNativeComponentFrame(ctor, true);\n            }\n        }\n        function describeFunctionComponentFrame(fn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function describeFiber(fiber) {\n            switch(fiber.tag){\n                case HostHoistable:\n                case HostSingleton:\n                case HostComponent:\n                    return describeBuiltInComponentFrame(fiber.type);\n                case LazyComponent:\n                    return describeBuiltInComponentFrame('Lazy');\n                case SuspenseComponent:\n                    return describeBuiltInComponentFrame('Suspense');\n                case SuspenseListComponent:\n                    return describeBuiltInComponentFrame('SuspenseList');\n                case FunctionComponent:\n                case SimpleMemoComponent:\n                    return describeFunctionComponentFrame(fiber.type);\n                case ForwardRef:\n                    return describeFunctionComponentFrame(fiber.type.render);\n                case ClassComponent:\n                    return describeClassComponentFrame(fiber.type);\n                default:\n                    return '';\n            }\n        }\n        function getStackByFiberInDevAndProd(workInProgress) {\n            try {\n                var info = '';\n                var node = workInProgress;\n                do {\n                    info += describeFiber(node);\n                    if (true) {\n                        // Add any Server Component stack frames in reverse order.\n                        var debugInfo = node._debugInfo;\n                        if (debugInfo) {\n                            for(var i = debugInfo.length - 1; i >= 0; i--){\n                                var entry = debugInfo[i];\n                                if (typeof entry.name === 'string') {\n                                    info += describeDebugInfoFrame(entry.name, entry.env);\n                                }\n                            }\n                        }\n                    } // $FlowFixMe[incompatible-type] we bail out when we get a null\n                    node = node.return;\n                }while (node);\n                return info;\n            } catch (x) {\n                return '\\nError generating stack: ' + x.message + '\\n' + x.stack;\n            }\n        }\n        var current = null;\n        var isRendering = false;\n        function getCurrentFiberStackInDev() {\n            {\n                if (current === null) {\n                    return '';\n                } // Safe because if current fiber exists, we are reconciling,\n                // and it is guaranteed to be the work-in-progress version.\n                return getStackByFiberInDevAndProd(current);\n            }\n        }\n        function resetCurrentDebugFiberInDEV() {\n            {\n                resetCurrentFiber();\n            }\n        }\n        function setCurrentDebugFiberInDEV(fiber) {\n            {\n                setCurrentFiber(fiber);\n            }\n        }\n        function resetCurrentFiber() {\n            {\n                ReactSharedInternals.getCurrentStack = null;\n                isRendering = false;\n            }\n            current = null;\n        }\n        function setCurrentFiber(fiber) {\n            {\n                ReactSharedInternals.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;\n                isRendering = false;\n            }\n            current = fiber;\n        }\n        function getCurrentFiber() {\n            {\n                return current;\n            }\n        }\n        function setIsRendering(rendering) {\n            {\n                isRendering = rendering;\n            }\n        }\n        function getNearestMountedFiber(fiber) {\n            var node = fiber;\n            var nearestMounted = fiber;\n            if (!fiber.alternate) {\n                // If there is no alternate, this might be a new tree that isn't inserted\n                // yet. If it is, then it will have a pending insertion effect on it.\n                var nextNode = node;\n                do {\n                    node = nextNode;\n                    if ((node.flags & (Placement | Hydrating)) !== NoFlags$1) {\n                        // This is an insertion or in-progress hydration. The nearest possible\n                        // mounted fiber is the parent but we need to continue to figure out\n                        // if that one is still mounted.\n                        nearestMounted = node.return;\n                    } // $FlowFixMe[incompatible-type] we bail out when we get a null\n                    nextNode = node.return;\n                }while (nextNode);\n            } else {\n                while(node.return){\n                    node = node.return;\n                }\n            }\n            if (node.tag === HostRoot) {\n                // TODO: Check if this was a nested HostRoot when used with\n                // renderContainerIntoSubtree.\n                return nearestMounted;\n            } // If we didn't hit the root, that means that we're in an disconnected tree\n            // that has been unmounted.\n            return null;\n        }\n        function isMounted(component) {\n            {\n                var owner = current;\n                if (owner !== null && isRendering && owner.tag === ClassComponent) {\n                    var ownerFiber = owner;\n                    var instance = ownerFiber.stateNode;\n                    if (!instance._warnedAboutRefsInRender) {\n                        error('%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentNameFromFiber(ownerFiber) || 'A component');\n                    }\n                    instance._warnedAboutRefsInRender = true;\n                }\n            }\n            var fiber = get(component);\n            if (!fiber) {\n                return false;\n            }\n            return getNearestMountedFiber(fiber) === fiber;\n        }\n        function assertIsMounted(fiber) {\n            if (getNearestMountedFiber(fiber) !== fiber) {\n                throw new Error('Unable to find node on an unmounted component.');\n            }\n        }\n        function findCurrentFiberUsingSlowPath(fiber) {\n            var alternate = fiber.alternate;\n            if (!alternate) {\n                // If there is no alternate, then we only need to check if it is mounted.\n                var nearestMounted = getNearestMountedFiber(fiber);\n                if (nearestMounted === null) {\n                    throw new Error('Unable to find node on an unmounted component.');\n                }\n                if (nearestMounted !== fiber) {\n                    return null;\n                }\n                return fiber;\n            } // If we have two possible branches, we'll walk backwards up to the root\n            // to see what path the root points to. On the way we may hit one of the\n            // special cases and we'll deal with them.\n            var a = fiber;\n            var b = alternate;\n            while(true){\n                var parentA = a.return;\n                if (parentA === null) {\n                    break;\n                }\n                var parentB = parentA.alternate;\n                if (parentB === null) {\n                    // There is no alternate. This is an unusual case. Currently, it only\n                    // happens when a Suspense component is hidden. An extra fragment fiber\n                    // is inserted in between the Suspense fiber and its children. Skip\n                    // over this extra fragment fiber and proceed to the next parent.\n                    var nextParent = parentA.return;\n                    if (nextParent !== null) {\n                        a = b = nextParent;\n                        continue;\n                    } // If there's no parent, we're at the root.\n                    break;\n                } // If both copies of the parent fiber point to the same child, we can\n                // assume that the child is current. This happens when we bailout on low\n                // priority: the bailed out fiber's child reuses the current child.\n                if (parentA.child === parentB.child) {\n                    var child = parentA.child;\n                    while(child){\n                        if (child === a) {\n                            // We've determined that A is the current branch.\n                            assertIsMounted(parentA);\n                            return fiber;\n                        }\n                        if (child === b) {\n                            // We've determined that B is the current branch.\n                            assertIsMounted(parentA);\n                            return alternate;\n                        }\n                        child = child.sibling;\n                    } // We should never have an alternate for any mounting node. So the only\n                    // way this could possibly happen is if this was unmounted, if at all.\n                    throw new Error('Unable to find node on an unmounted component.');\n                }\n                if (a.return !== b.return) {\n                    // The return pointer of A and the return pointer of B point to different\n                    // fibers. We assume that return pointers never criss-cross, so A must\n                    // belong to the child set of A.return, and B must belong to the child\n                    // set of B.return.\n                    a = parentA;\n                    b = parentB;\n                } else {\n                    // The return pointers point to the same fiber. We'll have to use the\n                    // default, slow path: scan the child sets of each parent alternate to see\n                    // which child belongs to which set.\n                    //\n                    // Search parent A's child set\n                    var didFindChild = false;\n                    var _child = parentA.child;\n                    while(_child){\n                        if (_child === a) {\n                            didFindChild = true;\n                            a = parentA;\n                            b = parentB;\n                            break;\n                        }\n                        if (_child === b) {\n                            didFindChild = true;\n                            b = parentA;\n                            a = parentB;\n                            break;\n                        }\n                        _child = _child.sibling;\n                    }\n                    if (!didFindChild) {\n                        // Search parent B's child set\n                        _child = parentB.child;\n                        while(_child){\n                            if (_child === a) {\n                                didFindChild = true;\n                                a = parentB;\n                                b = parentA;\n                                break;\n                            }\n                            if (_child === b) {\n                                didFindChild = true;\n                                b = parentB;\n                                a = parentA;\n                                break;\n                            }\n                            _child = _child.sibling;\n                        }\n                        if (!didFindChild) {\n                            throw new Error('Child was not found in either parent set. This indicates a bug ' + 'in React related to the return pointer. Please file an issue.');\n                        }\n                    }\n                }\n                if (a.alternate !== b) {\n                    throw new Error(\"Return fibers should always be each others' alternates. \" + 'This error is likely caused by a bug in React. Please file an issue.');\n                }\n            } // If the root is not a host container, we're in a disconnected tree. I.e.\n            // unmounted.\n            if (a.tag !== HostRoot) {\n                throw new Error('Unable to find node on an unmounted component.');\n            }\n            if (a.stateNode.current === a) {\n                // We've determined that A is the current branch.\n                return fiber;\n            } // Otherwise B has to be current branch.\n            return alternate;\n        }\n        function findCurrentHostFiber(parent) {\n            var currentParent = findCurrentFiberUsingSlowPath(parent);\n            return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;\n        }\n        function findCurrentHostFiberImpl(node) {\n            // Next we'll drill down this component to find the first HostComponent/Text.\n            var tag = node.tag;\n            if (tag === HostComponent || tag === HostHoistable || tag === HostSingleton || tag === HostText) {\n                return node;\n            }\n            var child = node.child;\n            while(child !== null){\n                var match = findCurrentHostFiberImpl(child);\n                if (match !== null) {\n                    return match;\n                }\n                child = child.sibling;\n            }\n            return null;\n        }\n        function findCurrentHostFiberWithNoPortals(parent) {\n            var currentParent = findCurrentFiberUsingSlowPath(parent);\n            return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;\n        }\n        function findCurrentHostFiberWithNoPortalsImpl(node) {\n            // Next we'll drill down this component to find the first HostComponent/Text.\n            var tag = node.tag;\n            if (tag === HostComponent || tag === HostHoistable || tag === HostSingleton || tag === HostText) {\n                return node;\n            }\n            var child = node.child;\n            while(child !== null){\n                if (child.tag !== HostPortal) {\n                    var match = findCurrentHostFiberWithNoPortalsImpl(child);\n                    if (match !== null) {\n                        return match;\n                    }\n                }\n                child = child.sibling;\n            }\n            return null;\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        // This is a host config that's used for the `react-reconciler` package on npm.\n        // It is only used by third-party renderers.\n        //\n        // Its API lets you pass the host config as an argument.\n        // However, inside the `react-reconciler` we treat host config as a module.\n        // This file is a shim between two worlds.\n        //\n        // It works because the `react-reconciler` bundle is wrapped in something like:\n        //\n        // module.exports = function ($$$config) {\n        //   /* reconciler code */\n        // }\n        //\n        // So `$$$config` looks like a global variable, but it's\n        // really an argument to a top-level wrapping function.\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        var getPublicInstance = $$$config.getPublicInstance;\n        var getRootHostContext = $$$config.getRootHostContext;\n        var getChildHostContext = $$$config.getChildHostContext;\n        var prepareForCommit = $$$config.prepareForCommit;\n        var resetAfterCommit = $$$config.resetAfterCommit;\n        var createInstance = $$$config.createInstance;\n        var appendInitialChild = $$$config.appendInitialChild;\n        var finalizeInitialChildren = $$$config.finalizeInitialChildren;\n        var shouldSetTextContent = $$$config.shouldSetTextContent;\n        var createTextInstance = $$$config.createTextInstance;\n        var scheduleTimeout = $$$config.scheduleTimeout;\n        var cancelTimeout = $$$config.cancelTimeout;\n        var noTimeout = $$$config.noTimeout;\n        var isPrimaryRenderer = $$$config.isPrimaryRenderer;\n        $$$config.warnsIfNotActing;\n        var supportsMutation = $$$config.supportsMutation;\n        var supportsPersistence = $$$config.supportsPersistence;\n        var supportsHydration = $$$config.supportsHydration;\n        var getInstanceFromNode = $$$config.getInstanceFromNode;\n        $$$config.beforeActiveInstanceBlur;\n        $$$config.afterActiveInstanceBlur;\n        var preparePortalMount = $$$config.preparePortalMount;\n        $$$config.prepareScopeUpdate;\n        $$$config.getInstanceFromScope;\n        var setCurrentUpdatePriority = $$$config.setCurrentUpdatePriority;\n        var getCurrentUpdatePriority = $$$config.getCurrentUpdatePriority;\n        var resolveUpdatePriority = $$$config.resolveUpdatePriority;\n        var shouldAttemptEagerTransition = $$$config.shouldAttemptEagerTransition;\n        var detachDeletedInstance = $$$config.detachDeletedInstance;\n        $$$config.requestPostPaintCallback;\n        var maySuspendCommit = $$$config.maySuspendCommit;\n        var preloadInstance = $$$config.preloadInstance;\n        var startSuspendingCommit = $$$config.startSuspendingCommit;\n        var suspendInstance = $$$config.suspendInstance;\n        var waitForCommitToBeReady = $$$config.waitForCommitToBeReady;\n        var NotPendingTransition = $$$config.NotPendingTransition;\n        var resetFormInstance = $$$config.resetFormInstance; // -------------------\n        //      Microtasks\n        //     (optional)\n        // -------------------\n        var supportsMicrotasks = $$$config.supportsMicrotasks;\n        var scheduleMicrotask = $$$config.scheduleMicrotask; // -------------------\n        //      Test selectors\n        //     (optional)\n        // -------------------\n        var supportsTestSelectors = $$$config.supportsTestSelectors;\n        var findFiberRoot = $$$config.findFiberRoot;\n        var getBoundingRect = $$$config.getBoundingRect;\n        var getTextContent = $$$config.getTextContent;\n        var isHiddenSubtree = $$$config.isHiddenSubtree;\n        var matchAccessibilityRole = $$$config.matchAccessibilityRole;\n        var setFocusIfFocusable = $$$config.setFocusIfFocusable;\n        var setupIntersectionObserver = $$$config.setupIntersectionObserver; // -------------------\n        //      Mutation\n        //     (optional)\n        // -------------------\n        var appendChild = $$$config.appendChild;\n        var appendChildToContainer = $$$config.appendChildToContainer;\n        var commitTextUpdate = $$$config.commitTextUpdate;\n        var commitMount = $$$config.commitMount;\n        var commitUpdate = $$$config.commitUpdate;\n        var insertBefore = $$$config.insertBefore;\n        var insertInContainerBefore = $$$config.insertInContainerBefore;\n        var removeChild = $$$config.removeChild;\n        var removeChildFromContainer = $$$config.removeChildFromContainer;\n        var resetTextContent = $$$config.resetTextContent;\n        var hideInstance = $$$config.hideInstance;\n        var hideTextInstance = $$$config.hideTextInstance;\n        var unhideInstance = $$$config.unhideInstance;\n        var unhideTextInstance = $$$config.unhideTextInstance;\n        var clearContainer = $$$config.clearContainer; // -------------------\n        //     Persistence\n        //     (optional)\n        // -------------------\n        var cloneInstance = $$$config.cloneInstance;\n        var createContainerChildSet = $$$config.createContainerChildSet;\n        var appendChildToContainerChildSet = $$$config.appendChildToContainerChildSet;\n        var finalizeContainerChildren = $$$config.finalizeContainerChildren;\n        var replaceContainerChildren = $$$config.replaceContainerChildren;\n        var cloneHiddenInstance = $$$config.cloneHiddenInstance;\n        var cloneHiddenTextInstance = $$$config.cloneHiddenTextInstance; // -------------------\n        //     Hydration\n        //     (optional)\n        // -------------------\n        var isSuspenseInstancePending = $$$config.isSuspenseInstancePending;\n        var isSuspenseInstanceFallback = $$$config.isSuspenseInstanceFallback;\n        var getSuspenseInstanceFallbackErrorDetails = $$$config.getSuspenseInstanceFallbackErrorDetails;\n        var registerSuspenseInstanceRetry = $$$config.registerSuspenseInstanceRetry;\n        var canHydrateFormStateMarker = $$$config.canHydrateFormStateMarker;\n        var isFormStateMarkerMatching = $$$config.isFormStateMarkerMatching;\n        var getNextHydratableSibling = $$$config.getNextHydratableSibling;\n        var getFirstHydratableChild = $$$config.getFirstHydratableChild;\n        var getFirstHydratableChildWithinContainer = $$$config.getFirstHydratableChildWithinContainer;\n        var getFirstHydratableChildWithinSuspenseInstance = $$$config.getFirstHydratableChildWithinSuspenseInstance;\n        var canHydrateInstance = $$$config.canHydrateInstance;\n        var canHydrateTextInstance = $$$config.canHydrateTextInstance;\n        var canHydrateSuspenseInstance = $$$config.canHydrateSuspenseInstance;\n        var hydrateInstance = $$$config.hydrateInstance;\n        var hydrateTextInstance = $$$config.hydrateTextInstance;\n        var hydrateSuspenseInstance = $$$config.hydrateSuspenseInstance;\n        var getNextHydratableInstanceAfterSuspenseInstance = $$$config.getNextHydratableInstanceAfterSuspenseInstance;\n        var commitHydratedContainer = $$$config.commitHydratedContainer;\n        var commitHydratedSuspenseInstance = $$$config.commitHydratedSuspenseInstance;\n        var clearSuspenseBoundary = $$$config.clearSuspenseBoundary;\n        var clearSuspenseBoundaryFromContainer = $$$config.clearSuspenseBoundaryFromContainer;\n        var shouldDeleteUnhydratedTailInstances = $$$config.shouldDeleteUnhydratedTailInstances;\n        var diffHydratedPropsForDevWarnings = $$$config.diffHydratedPropsForDevWarnings;\n        var diffHydratedTextForDevWarnings = $$$config.diffHydratedTextForDevWarnings;\n        var describeHydratableInstanceForDevWarnings = $$$config.describeHydratableInstanceForDevWarnings;\n        var validateHydratableInstance = $$$config.validateHydratableInstance;\n        var validateHydratableTextInstance = $$$config.validateHydratableTextInstance; // -------------------\n        //     Resources\n        //     (optional)\n        // -------------------\n        // eslint-disable-line no-undef\n        var supportsResources = $$$config.supportsResources;\n        var isHostHoistableType = $$$config.isHostHoistableType;\n        var getHoistableRoot = $$$config.getHoistableRoot;\n        var getResource = $$$config.getResource;\n        var acquireResource = $$$config.acquireResource;\n        var releaseResource = $$$config.releaseResource;\n        var hydrateHoistable = $$$config.hydrateHoistable;\n        var mountHoistable = $$$config.mountHoistable;\n        var unmountHoistable = $$$config.unmountHoistable;\n        var createHoistableInstance = $$$config.createHoistableInstance;\n        var prepareToCommitHoistables = $$$config.prepareToCommitHoistables;\n        var mayResourceSuspendCommit = $$$config.mayResourceSuspendCommit;\n        var preloadResource = $$$config.preloadResource;\n        var suspendResource = $$$config.suspendResource; // -------------------\n        //     Singletons\n        //     (optional)\n        // -------------------\n        var supportsSingletons = $$$config.supportsSingletons;\n        var resolveSingletonInstance = $$$config.resolveSingletonInstance;\n        var clearSingleton = $$$config.clearSingleton;\n        var acquireSingletonInstance = $$$config.acquireSingletonInstance;\n        var releaseSingletonInstance = $$$config.releaseSingletonInstance;\n        var isHostSingletonType = $$$config.isHostSingletonType;\n        var valueStack = [];\n        var fiberStack;\n        {\n            fiberStack = [];\n        }\n        var index = -1;\n        function createCursor(defaultValue) {\n            return {\n                current: defaultValue\n            };\n        }\n        function pop(cursor, fiber) {\n            if (index < 0) {\n                {\n                    error('Unexpected pop.');\n                }\n                return;\n            }\n            {\n                if (fiber !== fiberStack[index]) {\n                    error('Unexpected Fiber popped.');\n                }\n            }\n            cursor.current = valueStack[index];\n            valueStack[index] = null;\n            {\n                fiberStack[index] = null;\n            }\n            index--;\n        }\n        function push(cursor, value, fiber) {\n            index++;\n            valueStack[index] = cursor.current;\n            {\n                fiberStack[index] = fiber;\n            }\n            cursor.current = value;\n        }\n        var emptyContextObject = {};\n        {\n            Object.freeze(emptyContextObject);\n        }\n        function hasContextChanged() {\n            {\n                return false;\n            }\n        }\n        function isContextProvider(type) {\n            {\n                return false;\n            }\n        }\n        function processChildContext(fiber, type, parentContext) {\n            {\n                return parentContext;\n            }\n        }\n        function findCurrentUnmaskedContext(fiber) {\n            {\n                return emptyContextObject;\n            }\n        }\n        // We use the existence of the state object as an indicator that the component\n        // is hidden.\n        var OffscreenVisible = /*                     */ 1;\n        var OffscreenDetached = /*                    */ 2;\n        var OffscreenPassiveEffectsConnected = /*     */ 4;\n        function isOffscreenManual(offscreenFiber) {\n            return offscreenFiber.memoizedProps !== null && offscreenFiber.memoizedProps.mode === 'manual';\n        }\n        var NoMode = /*                         */ 0; // TODO: Remove ConcurrentMode by reading from the root tag instead\n        var ConcurrentMode = /*                 */ 1;\n        var ProfileMode = /*                    */ 2;\n        var StrictLegacyMode = /*               */ 8;\n        var StrictEffectsMode = /*              */ 16;\n        var NoStrictPassiveEffectsMode = /*     */ 64;\n        // TODO: This is pretty well supported by browsers. Maybe we can drop it.\n        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros.\n        // Based on:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n        var log$1 = Math.log;\n        var LN2 = Math.LN2;\n        function clz32Fallback(x) {\n            var asUint = x >>> 0;\n            if (asUint === 0) {\n                return 32;\n            }\n            return 31 - (log$1(asUint) / LN2 | 0) | 0;\n        }\n        // If those values are changed that package should be rebuilt and redeployed.\n        var TotalLanes = 31;\n        var NoLanes = /*                        */ 0;\n        var NoLane = /*                          */ 0;\n        var SyncHydrationLane = /*               */ 1;\n        var SyncLane = /*                        */ 2;\n        var SyncLaneIndex = 1;\n        var InputContinuousHydrationLane = /*    */ 4;\n        var InputContinuousLane = /*             */ 8;\n        var DefaultHydrationLane = /*            */ 16;\n        var DefaultLane = /*                     */ 32;\n        var SyncUpdateLanes = SyncLane | InputContinuousLane | DefaultLane;\n        var TransitionHydrationLane = /*                */ 64;\n        var TransitionLanes = /*                       */ 4194176;\n        var TransitionLane1 = /*                        */ 128;\n        var TransitionLane2 = /*                        */ 256;\n        var TransitionLane3 = /*                        */ 512;\n        var TransitionLane4 = /*                        */ 1024;\n        var TransitionLane5 = /*                        */ 2048;\n        var TransitionLane6 = /*                        */ 4096;\n        var TransitionLane7 = /*                        */ 8192;\n        var TransitionLane8 = /*                        */ 16384;\n        var TransitionLane9 = /*                        */ 32768;\n        var TransitionLane10 = /*                       */ 65536;\n        var TransitionLane11 = /*                       */ 131072;\n        var TransitionLane12 = /*                       */ 262144;\n        var TransitionLane13 = /*                       */ 524288;\n        var TransitionLane14 = /*                       */ 1048576;\n        var TransitionLane15 = /*                       */ 2097152;\n        var RetryLanes = /*                            */ 62914560;\n        var RetryLane1 = /*                             */ 4194304;\n        var RetryLane2 = /*                             */ 8388608;\n        var RetryLane3 = /*                             */ 16777216;\n        var RetryLane4 = /*                             */ 33554432;\n        var SomeRetryLane = RetryLane1;\n        var SelectiveHydrationLane = /*          */ 67108864;\n        var NonIdleLanes = /*                          */ 134217727;\n        var IdleHydrationLane = /*               */ 134217728;\n        var IdleLane = /*                        */ 268435456;\n        var OffscreenLane = /*                   */ 536870912;\n        var DeferredLane = /*                    */ 1073741824; // Any lane that might schedule an update. This is used to detect infinite\n        // update loops, so it doesn't include hydration lanes or retries.\n        var UpdateLanes = SyncLane | InputContinuousLane | DefaultLane | TransitionLanes; // This function is used for the experimental timeline (react-devtools-timeline)\n        // It should be kept in sync with the Lanes values above.\n        function getLabelForLane(lane) {\n            {\n                if (lane & SyncHydrationLane) {\n                    return 'SyncHydrationLane';\n                }\n                if (lane & SyncLane) {\n                    return 'Sync';\n                }\n                if (lane & InputContinuousHydrationLane) {\n                    return 'InputContinuousHydration';\n                }\n                if (lane & InputContinuousLane) {\n                    return 'InputContinuous';\n                }\n                if (lane & DefaultHydrationLane) {\n                    return 'DefaultHydration';\n                }\n                if (lane & DefaultLane) {\n                    return 'Default';\n                }\n                if (lane & TransitionHydrationLane) {\n                    return 'TransitionHydration';\n                }\n                if (lane & TransitionLanes) {\n                    return 'Transition';\n                }\n                if (lane & RetryLanes) {\n                    return 'Retry';\n                }\n                if (lane & SelectiveHydrationLane) {\n                    return 'SelectiveHydration';\n                }\n                if (lane & IdleHydrationLane) {\n                    return 'IdleHydration';\n                }\n                if (lane & IdleLane) {\n                    return 'Idle';\n                }\n                if (lane & OffscreenLane) {\n                    return 'Offscreen';\n                }\n                if (lane & DeferredLane) {\n                    return 'Deferred';\n                }\n            }\n        }\n        var NoTimestamp = -1;\n        var nextTransitionLane = TransitionLane1;\n        var nextRetryLane = RetryLane1;\n        function getHighestPriorityLanes(lanes) {\n            {\n                var pendingSyncLanes = lanes & SyncUpdateLanes;\n                if (pendingSyncLanes !== 0) {\n                    return pendingSyncLanes;\n                }\n            }\n            switch(getHighestPriorityLane(lanes)){\n                case SyncHydrationLane:\n                    return SyncHydrationLane;\n                case SyncLane:\n                    return SyncLane;\n                case InputContinuousHydrationLane:\n                    return InputContinuousHydrationLane;\n                case InputContinuousLane:\n                    return InputContinuousLane;\n                case DefaultHydrationLane:\n                    return DefaultHydrationLane;\n                case DefaultLane:\n                    return DefaultLane;\n                case TransitionHydrationLane:\n                    return TransitionHydrationLane;\n                case TransitionLane1:\n                case TransitionLane2:\n                case TransitionLane3:\n                case TransitionLane4:\n                case TransitionLane5:\n                case TransitionLane6:\n                case TransitionLane7:\n                case TransitionLane8:\n                case TransitionLane9:\n                case TransitionLane10:\n                case TransitionLane11:\n                case TransitionLane12:\n                case TransitionLane13:\n                case TransitionLane14:\n                case TransitionLane15:\n                    return lanes & TransitionLanes;\n                case RetryLane1:\n                case RetryLane2:\n                case RetryLane3:\n                case RetryLane4:\n                    return lanes & RetryLanes;\n                case SelectiveHydrationLane:\n                    return SelectiveHydrationLane;\n                case IdleHydrationLane:\n                    return IdleHydrationLane;\n                case IdleLane:\n                    return IdleLane;\n                case OffscreenLane:\n                    return OffscreenLane;\n                case DeferredLane:\n                    // This shouldn't be reachable because deferred work is always entangled\n                    // with something else.\n                    return NoLanes;\n                default:\n                    {\n                        error('Should have found matching lanes. This is a bug in React.');\n                    }\n                    return lanes;\n            }\n        }\n        function getNextLanes(root, wipLanes) {\n            // Early bailout if there's no pending work left.\n            var pendingLanes = root.pendingLanes;\n            if (pendingLanes === NoLanes) {\n                return NoLanes;\n            }\n            var nextLanes = NoLanes;\n            var suspendedLanes = root.suspendedLanes;\n            var pingedLanes = root.pingedLanes; // Do not work on any idle work until all the non-idle work has finished,\n            // even if the work is suspended.\n            var nonIdlePendingLanes = pendingLanes & NonIdleLanes;\n            if (nonIdlePendingLanes !== NoLanes) {\n                var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;\n                if (nonIdleUnblockedLanes !== NoLanes) {\n                    nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);\n                } else {\n                    var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;\n                    if (nonIdlePingedLanes !== NoLanes) {\n                        nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);\n                    }\n                }\n            } else {\n                // The only remaining work is Idle.\n                var unblockedLanes = pendingLanes & ~suspendedLanes;\n                if (unblockedLanes !== NoLanes) {\n                    nextLanes = getHighestPriorityLanes(unblockedLanes);\n                } else {\n                    if (pingedLanes !== NoLanes) {\n                        nextLanes = getHighestPriorityLanes(pingedLanes);\n                    }\n                }\n            }\n            if (nextLanes === NoLanes) {\n                // This should only be reachable if we're suspended\n                // TODO: Consider warning in this path if a fallback timer is not scheduled.\n                return NoLanes;\n            } // If we're already in the middle of a render, switching lanes will interrupt\n            // it and we'll lose our progress. We should only do this if the new lanes are\n            // higher priority.\n            if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't\n            // bother waiting until the root is complete.\n            (wipLanes & suspendedLanes) === NoLanes) {\n                var nextLane = getHighestPriorityLane(nextLanes);\n                var wipLane = getHighestPriorityLane(wipLanes);\n                if (// one. This works because the bits decrease in priority as you go left.\n                nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The\n                // only difference between default updates and transition updates is that\n                // default updates do not support refresh transitions.\n                nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes) {\n                    // Keep working on the existing in-progress tree. Do not interrupt.\n                    return wipLanes;\n                }\n            }\n            return nextLanes;\n        }\n        function getEntangledLanes(root, renderLanes) {\n            var entangledLanes = renderLanes;\n            if ((entangledLanes & InputContinuousLane) !== NoLanes) {\n                // When updates are sync by default, we entangle continuous priority updates\n                // and default updates, so they render in the same batch. The only reason\n                // they use separate lanes is because continuous updates should interrupt\n                // transitions, but default updates should not.\n                entangledLanes |= entangledLanes & DefaultLane;\n            } // Check for entangled lanes and add them to the batch.\n            //\n            // A lane is said to be entangled with another when it's not allowed to render\n            // in a batch that does not also include the other lane. Typically we do this\n            // when multiple updates have the same source, and we only want to respond to\n            // the most recent event from that source.\n            //\n            // Note that we apply entanglements *after* checking for partial work above.\n            // This means that if a lane is entangled during an interleaved event while\n            // it's already rendering, we won't interrupt it. This is intentional, since\n            // entanglement is usually \"best effort\": we'll try our best to render the\n            // lanes in the same batch, but it's not worth throwing out partially\n            // completed work in order to do it.\n            // TODO: Reconsider this. The counter-argument is that the partial work\n            // represents an intermediate state, which we don't want to show to the user.\n            // And by spending extra time finishing it, we're increasing the amount of\n            // time it takes to show the final state, which is what they are actually\n            // waiting for.\n            //\n            // For those exceptions where entanglement is semantically important,\n            // we should ensure that there is no partial work at the\n            // time we apply the entanglement.\n            var allEntangledLanes = root.entangledLanes;\n            if (allEntangledLanes !== NoLanes) {\n                var entanglements = root.entanglements;\n                var lanes = entangledLanes & allEntangledLanes;\n                while(lanes > 0){\n                    var index = pickArbitraryLaneIndex(lanes);\n                    var lane = 1 << index;\n                    entangledLanes |= entanglements[index];\n                    lanes &= ~lane;\n                }\n            }\n            return entangledLanes;\n        }\n        function computeExpirationTime(lane, currentTime) {\n            switch(lane){\n                case SyncHydrationLane:\n                case SyncLane:\n                case InputContinuousHydrationLane:\n                case InputContinuousLane:\n                    // User interactions should expire slightly more quickly.\n                    //\n                    // NOTE: This is set to the corresponding constant as in Scheduler.js.\n                    // When we made it larger, a product metric in www regressed, suggesting\n                    // there's a user interaction that's being starved by a series of\n                    // synchronous updates. If that theory is correct, the proper solution is\n                    // to fix the starvation. However, this scenario supports the idea that\n                    // expiration times are an important safeguard when starvation\n                    // does happen.\n                    return currentTime + syncLaneExpirationMs;\n                case DefaultHydrationLane:\n                case DefaultLane:\n                case TransitionHydrationLane:\n                case TransitionLane1:\n                case TransitionLane2:\n                case TransitionLane3:\n                case TransitionLane4:\n                case TransitionLane5:\n                case TransitionLane6:\n                case TransitionLane7:\n                case TransitionLane8:\n                case TransitionLane9:\n                case TransitionLane10:\n                case TransitionLane11:\n                case TransitionLane12:\n                case TransitionLane13:\n                case TransitionLane14:\n                case TransitionLane15:\n                    return currentTime + transitionLaneExpirationMs;\n                case RetryLane1:\n                case RetryLane2:\n                case RetryLane3:\n                case RetryLane4:\n                    // TODO: Retries should be allowed to expire if they are CPU bound for\n                    // too long, but when I made this change it caused a spike in browser\n                    // crashes. There must be some other underlying bug; not super urgent but\n                    // ideally should figure out why and fix it. Unfortunately we don't have\n                    // a repro for the crashes, only detected via production metrics.\n                    return NoTimestamp;\n                case SelectiveHydrationLane:\n                case IdleHydrationLane:\n                case IdleLane:\n                case OffscreenLane:\n                case DeferredLane:\n                    // Anything idle priority or lower should never expire.\n                    return NoTimestamp;\n                default:\n                    {\n                        error('Should have found matching lanes. This is a bug in React.');\n                    }\n                    return NoTimestamp;\n            }\n        }\n        function markStarvedLanesAsExpired(root, currentTime) {\n            // TODO: This gets called every time we yield. We can optimize by storing\n            // the earliest expiration time on the root. Then use that to quickly bail out\n            // of this function.\n            var pendingLanes = root.pendingLanes;\n            var suspendedLanes = root.suspendedLanes;\n            var pingedLanes = root.pingedLanes;\n            var expirationTimes = root.expirationTimes; // Iterate through the pending lanes and check if we've reached their\n            // expiration time. If so, we'll assume the update is being starved and mark\n            // it as expired to force it to finish.\n            // TODO: We should be able to replace this with upgradePendingLanesToSync\n            //\n            // We exclude retry lanes because those must always be time sliced, in order\n            // to unwrap uncached promises.\n            // TODO: Write a test for this\n            var lanes = pendingLanes & ~RetryLanes;\n            while(lanes > 0){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                var expirationTime = expirationTimes[index];\n                if (expirationTime === NoTimestamp) {\n                    // Found a pending lane with no expiration time. If it's not suspended, or\n                    // if it's pinged, assume it's CPU-bound. Compute a new expiration time\n                    // using the current time.\n                    if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {\n                        // Assumes timestamps are monotonically increasing.\n                        expirationTimes[index] = computeExpirationTime(lane, currentTime);\n                    }\n                } else if (expirationTime <= currentTime) {\n                    // This lane expired\n                    root.expiredLanes |= lane;\n                }\n                lanes &= ~lane;\n            }\n        } // This returns the highest priority pending lanes regardless of whether they\n        // are suspended.\n        function getHighestPriorityPendingLanes(root) {\n            return getHighestPriorityLanes(root.pendingLanes);\n        }\n        function getLanesToRetrySynchronouslyOnError(root, originallyAttemptedLanes) {\n            if (root.errorRecoveryDisabledLanes & originallyAttemptedLanes) {\n                // The error recovery mechanism is disabled until these lanes are cleared.\n                return NoLanes;\n            }\n            var everythingButOffscreen = root.pendingLanes & ~OffscreenLane;\n            if (everythingButOffscreen !== NoLanes) {\n                return everythingButOffscreen;\n            }\n            if (everythingButOffscreen & OffscreenLane) {\n                return OffscreenLane;\n            }\n            return NoLanes;\n        }\n        function includesSyncLane(lanes) {\n            return (lanes & (SyncLane | SyncHydrationLane)) !== NoLanes;\n        }\n        function includesNonIdleWork(lanes) {\n            return (lanes & NonIdleLanes) !== NoLanes;\n        }\n        function includesOnlyRetries(lanes) {\n            return (lanes & RetryLanes) === lanes;\n        }\n        function includesOnlyNonUrgentLanes(lanes) {\n            // TODO: Should hydration lanes be included here? This function is only\n            // used in `updateDeferredValueImpl`.\n            var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;\n            return (lanes & UrgentLanes) === NoLanes;\n        }\n        function includesOnlyTransitions(lanes) {\n            return (lanes & TransitionLanes) === lanes;\n        }\n        function includesBlockingLane(root, lanes) {\n            var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;\n            return (lanes & SyncDefaultLanes) !== NoLanes;\n        }\n        function includesExpiredLane(root, lanes) {\n            // This is a separate check from includesBlockingLane because a lane can\n            // expire after a render has already started.\n            return (lanes & root.expiredLanes) !== NoLanes;\n        }\n        function isTransitionLane(lane) {\n            return (lane & TransitionLanes) !== NoLanes;\n        }\n        function claimNextTransitionLane() {\n            // Cycle through the lanes, assigning each new transition to the next lane.\n            // In most cases, this means every transition gets its own lane, until we\n            // run out of lanes and cycle back to the beginning.\n            var lane = nextTransitionLane;\n            nextTransitionLane <<= 1;\n            if ((nextTransitionLane & TransitionLanes) === NoLanes) {\n                nextTransitionLane = TransitionLane1;\n            }\n            return lane;\n        }\n        function claimNextRetryLane() {\n            var lane = nextRetryLane;\n            nextRetryLane <<= 1;\n            if ((nextRetryLane & RetryLanes) === NoLanes) {\n                nextRetryLane = RetryLane1;\n            }\n            return lane;\n        }\n        function getHighestPriorityLane(lanes) {\n            return lanes & -lanes;\n        }\n        function pickArbitraryLane(lanes) {\n            // This wrapper function gets inlined. Only exists so to communicate that it\n            // doesn't matter which bit is selected; you can pick any bit without\n            // affecting the algorithms where its used. Here I'm using\n            // getHighestPriorityLane because it requires the fewest operations.\n            return getHighestPriorityLane(lanes);\n        }\n        function pickArbitraryLaneIndex(lanes) {\n            return 31 - clz32(lanes);\n        }\n        function laneToIndex(lane) {\n            return pickArbitraryLaneIndex(lane);\n        }\n        function includesSomeLane(a, b) {\n            return (a & b) !== NoLanes;\n        }\n        function isSubsetOfLanes(set, subset) {\n            return (set & subset) === subset;\n        }\n        function mergeLanes(a, b) {\n            return a | b;\n        }\n        function removeLanes(set, subset) {\n            return set & ~subset;\n        }\n        function intersectLanes(a, b) {\n            return a & b;\n        } // Seems redundant, but it changes the type from a single lane (used for\n        // updates) to a group of lanes (used for flushing work).\n        function laneToLanes(lane) {\n            return lane;\n        }\n        function higherPriorityLane(a, b) {\n            // This works because the bit ranges decrease in priority as you go left.\n            return a !== NoLane && a < b ? a : b;\n        }\n        function createLaneMap(initial) {\n            // Intentionally pushing one by one.\n            // https://v8.dev/blog/elements-kinds#avoid-creating-holes\n            var laneMap = [];\n            for(var i = 0; i < TotalLanes; i++){\n                laneMap.push(initial);\n            }\n            return laneMap;\n        }\n        function markRootUpdated$1(root, updateLane) {\n            root.pendingLanes |= updateLane; // If there are any suspended transitions, it's possible this new update\n            // could unblock them. Clear the suspended lanes so that we can try rendering\n            // them again.\n            //\n            // TODO: We really only need to unsuspend only lanes that are in the\n            // `subtreeLanes` of the updated fiber, or the update lanes of the return\n            // path. This would exclude suspended updates in an unrelated sibling tree,\n            // since there's no way for this update to unblock it.\n            //\n            // We don't do this if the incoming update is idle, because we never process\n            // idle updates until after all the regular updates have finished; there's no\n            // way it could unblock a transition.\n            if (updateLane !== IdleLane) {\n                root.suspendedLanes = NoLanes;\n                root.pingedLanes = NoLanes;\n            }\n        }\n        function markRootSuspended$1(root, suspendedLanes, spawnedLane) {\n            root.suspendedLanes |= suspendedLanes;\n            root.pingedLanes &= ~suspendedLanes; // The suspended lanes are no longer CPU-bound. Clear their expiration times.\n            var expirationTimes = root.expirationTimes;\n            var lanes = suspendedLanes;\n            while(lanes > 0){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                expirationTimes[index] = NoTimestamp;\n                lanes &= ~lane;\n            }\n            if (spawnedLane !== NoLane) {\n                markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);\n            }\n        }\n        function markRootPinged$1(root, pingedLanes) {\n            root.pingedLanes |= root.suspendedLanes & pingedLanes;\n        }\n        function markRootFinished(root, remainingLanes, spawnedLane) {\n            var noLongerPendingLanes = root.pendingLanes & ~remainingLanes;\n            root.pendingLanes = remainingLanes; // Let's try everything again\n            root.suspendedLanes = NoLanes;\n            root.pingedLanes = NoLanes;\n            root.expiredLanes &= remainingLanes;\n            root.entangledLanes &= remainingLanes;\n            root.errorRecoveryDisabledLanes &= remainingLanes;\n            root.shellSuspendCounter = 0;\n            var entanglements = root.entanglements;\n            var expirationTimes = root.expirationTimes;\n            var hiddenUpdates = root.hiddenUpdates; // Clear the lanes that no longer have pending work\n            var lanes = noLongerPendingLanes;\n            while(lanes > 0){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                entanglements[index] = NoLanes;\n                expirationTimes[index] = NoTimestamp;\n                var hiddenUpdatesForLane = hiddenUpdates[index];\n                if (hiddenUpdatesForLane !== null) {\n                    hiddenUpdates[index] = null; // \"Hidden\" updates are updates that were made to a hidden component. They\n                    // have special logic associated with them because they may be entangled\n                    // with updates that occur outside that tree. But once the outer tree\n                    // commits, they behave like regular updates.\n                    for(var i = 0; i < hiddenUpdatesForLane.length; i++){\n                        var update = hiddenUpdatesForLane[i];\n                        if (update !== null) {\n                            update.lane &= ~OffscreenLane;\n                        }\n                    }\n                }\n                lanes &= ~lane;\n            }\n            if (spawnedLane !== NoLane) {\n                markSpawnedDeferredLane(root, spawnedLane, // to entangle the spawned task with the parent task.\n                NoLanes);\n            }\n        }\n        function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {\n            // This render spawned a deferred task. Mark it as pending.\n            root.pendingLanes |= spawnedLane;\n            root.suspendedLanes &= ~spawnedLane; // Entangle the spawned lane with the DeferredLane bit so that we know it\n            // was the result of another render. This lets us avoid a useDeferredValue\n            // waterfall — only the first level will defer.\n            var spawnedLaneIndex = laneToIndex(spawnedLane);\n            root.entangledLanes |= spawnedLane;\n            root.entanglements[spawnedLaneIndex] |= DeferredLane | // If the parent render task suspended, we must also entangle those lanes\n            // with the spawned task, so that the deferred task includes all the same\n            // updates that the parent task did. We can exclude any lane that is not\n            // used for updates (e.g. Offscreen).\n            entangledLanes & UpdateLanes;\n        }\n        function markRootEntangled(root, entangledLanes) {\n            // In addition to entangling each of the given lanes with each other, we also\n            // have to consider _transitive_ entanglements. For each lane that is already\n            // entangled with *any* of the given lanes, that lane is now transitively\n            // entangled with *all* the given lanes.\n            //\n            // Translated: If C is entangled with A, then entangling A with B also\n            // entangles C with B.\n            //\n            // If this is hard to grasp, it might help to intentionally break this\n            // function and look at the tests that fail in ReactTransition-test.js. Try\n            // commenting out one of the conditions below.\n            var rootEntangledLanes = root.entangledLanes |= entangledLanes;\n            var entanglements = root.entanglements;\n            var lanes = rootEntangledLanes;\n            while(lanes){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                if (lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?\n                entanglements[index] & entangledLanes) {\n                    entanglements[index] |= entangledLanes;\n                }\n                lanes &= ~lane;\n            }\n        }\n        function upgradePendingLaneToSync(root, lane) {\n            // Since we're upgrading the priority of the given lane, there is now pending\n            // sync work.\n            root.pendingLanes |= SyncLane; // Entangle the sync lane with the lane we're upgrading. This means SyncLane\n            // will not be allowed to finish without also finishing the given lane.\n            root.entangledLanes |= SyncLane;\n            root.entanglements[SyncLaneIndex] |= lane;\n        }\n        function upgradePendingLanesToSync(root, lanesToUpgrade) {\n            // Same as upgradePendingLaneToSync but accepts multiple lanes, so it's a\n            // bit slower.\n            root.pendingLanes |= SyncLane;\n            root.entangledLanes |= SyncLane;\n            var lanes = lanesToUpgrade;\n            while(lanes){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                root.entanglements[SyncLaneIndex] |= lane;\n                lanes &= ~lane;\n            }\n        }\n        function markHiddenUpdate(root, update, lane) {\n            var index = laneToIndex(lane);\n            var hiddenUpdates = root.hiddenUpdates;\n            var hiddenUpdatesForLane = hiddenUpdates[index];\n            if (hiddenUpdatesForLane === null) {\n                hiddenUpdates[index] = [\n                    update\n                ];\n            } else {\n                hiddenUpdatesForLane.push(update);\n            }\n            update.lane = lane | OffscreenLane;\n        }\n        function getBumpedLaneForHydration(root, renderLanes) {\n            var renderLane = getHighestPriorityLane(renderLanes);\n            var lane;\n            if ((renderLane & SyncUpdateLanes) !== NoLane) {\n                lane = SyncHydrationLane;\n            } else {\n                switch(renderLane){\n                    case SyncLane:\n                        lane = SyncHydrationLane;\n                        break;\n                    case InputContinuousLane:\n                        lane = InputContinuousHydrationLane;\n                        break;\n                    case DefaultLane:\n                        lane = DefaultHydrationLane;\n                        break;\n                    case TransitionLane1:\n                    case TransitionLane2:\n                    case TransitionLane3:\n                    case TransitionLane4:\n                    case TransitionLane5:\n                    case TransitionLane6:\n                    case TransitionLane7:\n                    case TransitionLane8:\n                    case TransitionLane9:\n                    case TransitionLane10:\n                    case TransitionLane11:\n                    case TransitionLane12:\n                    case TransitionLane13:\n                    case TransitionLane14:\n                    case TransitionLane15:\n                    case RetryLane1:\n                    case RetryLane2:\n                    case RetryLane3:\n                    case RetryLane4:\n                        lane = TransitionHydrationLane;\n                        break;\n                    case IdleLane:\n                        lane = IdleHydrationLane;\n                        break;\n                    default:\n                        // Everything else is already either a hydration lane, or shouldn't\n                        // be retried at a hydration lane.\n                        lane = NoLane;\n                        break;\n                }\n            } // Check if the lane we chose is suspended. If so, that indicates that we\n            // already attempted and failed to hydrate at that level. Also check if we're\n            // already rendering that lane, which is rare but could happen.\n            if ((lane & (root.suspendedLanes | renderLanes)) !== NoLane) {\n                // Give up trying to hydrate and fall back to client render.\n                return NoLane;\n            }\n            return lane;\n        }\n        function addFiberToLanesMap(root, fiber, lanes) {\n            if (!isDevToolsPresent) {\n                return;\n            }\n            var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n            while(lanes > 0){\n                var index = laneToIndex(lanes);\n                var lane = 1 << index;\n                var updaters = pendingUpdatersLaneMap[index];\n                updaters.add(fiber);\n                lanes &= ~lane;\n            }\n        }\n        function movePendingFibersToMemoized(root, lanes) {\n            if (!isDevToolsPresent) {\n                return;\n            }\n            var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n            var memoizedUpdaters = root.memoizedUpdaters;\n            while(lanes > 0){\n                var index = laneToIndex(lanes);\n                var lane = 1 << index;\n                var updaters = pendingUpdatersLaneMap[index];\n                if (updaters.size > 0) {\n                    updaters.forEach(function(fiber) {\n                        var alternate = fiber.alternate;\n                        if (alternate === null || !memoizedUpdaters.has(alternate)) {\n                            memoizedUpdaters.add(fiber);\n                        }\n                    });\n                    updaters.clear();\n                }\n                lanes &= ~lane;\n            }\n        }\n        function getTransitionsForLanes(root, lanes) {\n            {\n                return null;\n            }\n        }\n        var DiscreteEventPriority = SyncLane;\n        var ContinuousEventPriority = InputContinuousLane;\n        var DefaultEventPriority = DefaultLane;\n        var IdleEventPriority = IdleLane;\n        function higherEventPriority(a, b) {\n            return a !== 0 && a < b ? a : b;\n        }\n        function lowerEventPriority(a, b) {\n            return a === 0 || a > b ? a : b;\n        }\n        function isHigherEventPriority(a, b) {\n            return a !== 0 && a < b;\n        }\n        function eventPriorityToLane(updatePriority) {\n            return updatePriority;\n        }\n        function lanesToEventPriority(lanes) {\n            var lane = getHighestPriorityLane(lanes);\n            if (!isHigherEventPriority(DiscreteEventPriority, lane)) {\n                return DiscreteEventPriority;\n            }\n            if (!isHigherEventPriority(ContinuousEventPriority, lane)) {\n                return ContinuousEventPriority;\n            }\n            if (includesNonIdleWork(lane)) {\n                return DefaultEventPriority;\n            }\n            return IdleEventPriority;\n        }\n        // This module only exists as an ESM wrapper around the external CommonJS\n        var scheduleCallback$3 = Scheduler.unstable_scheduleCallback;\n        var cancelCallback$1 = Scheduler.unstable_cancelCallback;\n        var shouldYield = Scheduler.unstable_shouldYield;\n        var requestPaint = Scheduler.unstable_requestPaint;\n        var now$1 = Scheduler.unstable_now;\n        var ImmediatePriority = Scheduler.unstable_ImmediatePriority;\n        var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;\n        var NormalPriority$1 = Scheduler.unstable_NormalPriority;\n        var IdlePriority = Scheduler.unstable_IdlePriority; // this doesn't actually exist on the scheduler, but it *does*\n        // on scheduler/unstable_mock, which we'll need for internal testing\n        var log = Scheduler.log;\n        var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;\n        var rendererID = null;\n        var injectedHook = null;\n        var injectedProfilingHooks = null;\n        var hasLoggedError = false;\n        var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined';\n        function injectInternals(internals) {\n            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {\n                // No DevTools\n                return false;\n            }\n            var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n            if (hook.isDisabled) {\n                // This isn't a real property on the hook, but it can be set to opt out\n                // of DevTools integration and associated warnings and logs.\n                // https://github.com/facebook/react/issues/3877\n                return true;\n            }\n            if (!hook.supportsFiber) {\n                {\n                    error('The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://react.dev/link/react-devtools');\n                }\n                return true;\n            }\n            try {\n                if (enableSchedulingProfiler) {\n                    // Conditionally inject these hooks only if Timeline profiler is supported by this build.\n                    // This gives DevTools a way to feature detect that isn't tied to version number\n                    // (since profiling and timeline are controlled by different feature flags).\n                    internals = assign({}, internals, {\n                        getLaneLabelMap: getLaneLabelMap,\n                        injectProfilingHooks: injectProfilingHooks\n                    });\n                }\n                rendererID = hook.inject(internals); // We have successfully injected, so now it is safe to set up hooks.\n                injectedHook = hook;\n            } catch (err) {\n                // Catch all errors because it is unsafe to throw during initialization.\n                {\n                    error('React instrumentation encountered an error: %s.', err);\n                }\n            }\n            if (hook.checkDCE) {\n                // This is the real DevTools.\n                return true;\n            } else {\n                // This is likely a hook installed by Fast Refresh runtime.\n                return false;\n            }\n        }\n        function onScheduleRoot(root, children) {\n            {\n                if (injectedHook && typeof injectedHook.onScheduleFiberRoot === 'function') {\n                    try {\n                        injectedHook.onScheduleFiberRoot(rendererID, root, children);\n                    } catch (err) {\n                        if (!hasLoggedError) {\n                            hasLoggedError = true;\n                            error('React instrumentation encountered an error: %s', err);\n                        }\n                    }\n                }\n            }\n        }\n        function onCommitRoot$1(root, eventPriority) {\n            if (injectedHook && typeof injectedHook.onCommitFiberRoot === 'function') {\n                try {\n                    var didError = (root.current.flags & DidCapture) === DidCapture;\n                    if (enableProfilerTimer) {\n                        var schedulerPriority;\n                        switch(eventPriority){\n                            case DiscreteEventPriority:\n                                schedulerPriority = ImmediatePriority;\n                                break;\n                            case ContinuousEventPriority:\n                                schedulerPriority = UserBlockingPriority;\n                                break;\n                            case DefaultEventPriority:\n                                schedulerPriority = NormalPriority$1;\n                                break;\n                            case IdleEventPriority:\n                                schedulerPriority = IdlePriority;\n                                break;\n                            default:\n                                schedulerPriority = NormalPriority$1;\n                                break;\n                        }\n                        injectedHook.onCommitFiberRoot(rendererID, root, schedulerPriority, didError);\n                    }\n                } catch (err) {\n                    {\n                        if (!hasLoggedError) {\n                            hasLoggedError = true;\n                            error('React instrumentation encountered an error: %s', err);\n                        }\n                    }\n                }\n            }\n        }\n        function onPostCommitRoot(root) {\n            if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === 'function') {\n                try {\n                    injectedHook.onPostCommitFiberRoot(rendererID, root);\n                } catch (err) {\n                    {\n                        if (!hasLoggedError) {\n                            hasLoggedError = true;\n                            error('React instrumentation encountered an error: %s', err);\n                        }\n                    }\n                }\n            }\n        }\n        function onCommitUnmount(fiber) {\n            if (injectedHook && typeof injectedHook.onCommitFiberUnmount === 'function') {\n                try {\n                    injectedHook.onCommitFiberUnmount(rendererID, fiber);\n                } catch (err) {\n                    {\n                        if (!hasLoggedError) {\n                            hasLoggedError = true;\n                            error('React instrumentation encountered an error: %s', err);\n                        }\n                    }\n                }\n            }\n        }\n        function setIsStrictModeForDevtools(newIsStrictMode) {\n            {\n                if (typeof log === 'function') {\n                    // We're in a test because Scheduler.log only exists\n                    // in SchedulerMock. To reduce the noise in strict mode tests,\n                    // suppress warnings and disable scheduler yielding during the double render\n                    unstable_setDisableYieldValue(newIsStrictMode);\n                    setSuppressWarning(newIsStrictMode);\n                }\n                if (injectedHook && typeof injectedHook.setStrictMode === 'function') {\n                    try {\n                        injectedHook.setStrictMode(rendererID, newIsStrictMode);\n                    } catch (err) {\n                        {\n                            if (!hasLoggedError) {\n                                hasLoggedError = true;\n                                error('React instrumentation encountered an error: %s', err);\n                            }\n                        }\n                    }\n                }\n            }\n        } // Profiler API hooks\n        function injectProfilingHooks(profilingHooks) {\n            injectedProfilingHooks = profilingHooks;\n        }\n        function getLaneLabelMap() {\n            {\n                var map = new Map();\n                var lane = 1;\n                for(var index = 0; index < TotalLanes; index++){\n                    var label = getLabelForLane(lane);\n                    map.set(lane, label);\n                    lane *= 2;\n                }\n                return map;\n            }\n        }\n        function markCommitStarted(lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === 'function') {\n                    injectedProfilingHooks.markCommitStarted(lanes);\n                }\n            }\n        }\n        function markCommitStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === 'function') {\n                    injectedProfilingHooks.markCommitStopped();\n                }\n            }\n        }\n        function markComponentRenderStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === 'function') {\n                    injectedProfilingHooks.markComponentRenderStarted(fiber);\n                }\n            }\n        }\n        function markComponentRenderStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === 'function') {\n                    injectedProfilingHooks.markComponentRenderStopped();\n                }\n            }\n        }\n        function markComponentPassiveEffectMountStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === 'function') {\n                    injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);\n                }\n            }\n        }\n        function markComponentPassiveEffectMountStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === 'function') {\n                    injectedProfilingHooks.markComponentPassiveEffectMountStopped();\n                }\n            }\n        }\n        function markComponentPassiveEffectUnmountStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === 'function') {\n                    injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);\n                }\n            }\n        }\n        function markComponentPassiveEffectUnmountStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === 'function') {\n                    injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();\n                }\n            }\n        }\n        function markComponentLayoutEffectMountStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === 'function') {\n                    injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);\n                }\n            }\n        }\n        function markComponentLayoutEffectMountStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === 'function') {\n                    injectedProfilingHooks.markComponentLayoutEffectMountStopped();\n                }\n            }\n        }\n        function markComponentLayoutEffectUnmountStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === 'function') {\n                    injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);\n                }\n            }\n        }\n        function markComponentLayoutEffectUnmountStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === 'function') {\n                    injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();\n                }\n            }\n        }\n        function markComponentErrored(fiber, thrownValue, lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === 'function') {\n                    injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);\n                }\n            }\n        }\n        function markComponentSuspended(fiber, wakeable, lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === 'function') {\n                    injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);\n                }\n            }\n        }\n        function markLayoutEffectsStarted(lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === 'function') {\n                    injectedProfilingHooks.markLayoutEffectsStarted(lanes);\n                }\n            }\n        }\n        function markLayoutEffectsStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === 'function') {\n                    injectedProfilingHooks.markLayoutEffectsStopped();\n                }\n            }\n        }\n        function markPassiveEffectsStarted(lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === 'function') {\n                    injectedProfilingHooks.markPassiveEffectsStarted(lanes);\n                }\n            }\n        }\n        function markPassiveEffectsStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === 'function') {\n                    injectedProfilingHooks.markPassiveEffectsStopped();\n                }\n            }\n        }\n        function markRenderStarted(lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === 'function') {\n                    injectedProfilingHooks.markRenderStarted(lanes);\n                }\n            }\n        }\n        function markRenderYielded() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === 'function') {\n                    injectedProfilingHooks.markRenderYielded();\n                }\n            }\n        }\n        function markRenderStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === 'function') {\n                    injectedProfilingHooks.markRenderStopped();\n                }\n            }\n        }\n        function markRenderScheduled(lane) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === 'function') {\n                    injectedProfilingHooks.markRenderScheduled(lane);\n                }\n            }\n        }\n        function markForceUpdateScheduled(fiber, lane) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === 'function') {\n                    injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);\n                }\n            }\n        }\n        function markStateUpdateScheduled(fiber, lane) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === 'function') {\n                    injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);\n                }\n            }\n        }\n        /**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */ function is(x, y) {\n            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n            ;\n        }\n        var objectIs = typeof Object.is === 'function' ? Object.is : is;\n        // This is imported by the event replaying implementation in React DOM. It's\n        // in a separate file to break a circular dependency between the renderer and\n        // the reconciler.\n        function isRootDehydrated(root) {\n            var currentState = root.current.memoizedState;\n            return currentState.isDehydrated;\n        }\n        var CapturedStacks = new WeakMap();\n        function createCapturedValueAtFiber(value, source) {\n            // If the value is an error, call this function immediately after it is thrown\n            // so the stack is accurate.\n            var stack;\n            if (typeof value === 'object' && value !== null) {\n                var capturedStack = CapturedStacks.get(value);\n                if (typeof capturedStack === 'string') {\n                    stack = capturedStack;\n                } else {\n                    stack = getStackByFiberInDevAndProd(source);\n                    CapturedStacks.set(value, stack);\n                }\n            } else {\n                stack = getStackByFiberInDevAndProd(source);\n            }\n            return {\n                value: value,\n                source: source,\n                stack: stack\n            };\n        }\n        function createCapturedValueFromError(value, stack) {\n            if (typeof stack === 'string') {\n                CapturedStacks.set(value, stack);\n            }\n            return {\n                value: value,\n                source: null,\n                stack: stack\n            };\n        }\n        // Intentionally not using it yet to derisk the initial implementation, because\n        // the way we push/pop these values is a bit unusual. If there's a mistake, I'd\n        // rather the ids be wrong than crash the whole reconciler.\n        var forkStack = [];\n        var forkStackIndex = 0;\n        var treeForkProvider = null;\n        var treeForkCount = 0;\n        var idStack = [];\n        var idStackIndex = 0;\n        var treeContextProvider = null;\n        var treeContextId = 1;\n        var treeContextOverflow = '';\n        function isForkedChild(workInProgress) {\n            warnIfNotHydrating();\n            return (workInProgress.flags & Forked) !== NoFlags$1;\n        }\n        function getForksAtLevel(workInProgress) {\n            warnIfNotHydrating();\n            return treeForkCount;\n        }\n        function getTreeId() {\n            var overflow = treeContextOverflow;\n            var idWithLeadingBit = treeContextId;\n            var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);\n            return id.toString(32) + overflow;\n        }\n        function pushTreeFork(workInProgress, totalChildren) {\n            // This is called right after we reconcile an array (or iterator) of child\n            // fibers, because that's the only place where we know how many children in\n            // the whole set without doing extra work later, or storing addtional\n            // information on the fiber.\n            //\n            // That's why this function is separate from pushTreeId — it's called during\n            // the render phase of the fork parent, not the child, which is where we push\n            // the other context values.\n            //\n            // In the Fizz implementation this is much simpler because the child is\n            // rendered in the same callstack as the parent.\n            //\n            // It might be better to just add a `forks` field to the Fiber type. It would\n            // make this module simpler.\n            warnIfNotHydrating();\n            forkStack[forkStackIndex++] = treeForkCount;\n            forkStack[forkStackIndex++] = treeForkProvider;\n            treeForkProvider = workInProgress;\n            treeForkCount = totalChildren;\n        }\n        function pushTreeId(workInProgress, totalChildren, index) {\n            warnIfNotHydrating();\n            idStack[idStackIndex++] = treeContextId;\n            idStack[idStackIndex++] = treeContextOverflow;\n            idStack[idStackIndex++] = treeContextProvider;\n            treeContextProvider = workInProgress;\n            var baseIdWithLeadingBit = treeContextId;\n            var baseOverflow = treeContextOverflow; // The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n            // of the id; we use it to account for leading 0s.\n            var baseLength = getBitLength(baseIdWithLeadingBit) - 1;\n            var baseId = baseIdWithLeadingBit & ~(1 << baseLength);\n            var slot = index + 1;\n            var length = getBitLength(totalChildren) + baseLength; // 30 is the max length we can store without overflowing, taking into\n            // consideration the leading 1 we use to mark the end of the sequence.\n            if (length > 30) {\n                // We overflowed the bitwise-safe range. Fall back to slower algorithm.\n                // This branch assumes the length of the base id is greater than 5; it won't\n                // work for smaller ids, because you need 5 bits per character.\n                //\n                // We encode the id in multiple steps: first the base id, then the\n                // remaining digits.\n                //\n                // Each 5 bit sequence corresponds to a single base 32 character. So for\n                // example, if the current id is 23 bits long, we can convert 20 of those\n                // bits into a string of 4 characters, with 3 bits left over.\n                //\n                // First calculate how many bits in the base id represent a complete\n                // sequence of characters.\n                var numberOfOverflowBits = baseLength - baseLength % 5; // Then create a bitmask that selects only those bits.\n                var newOverflowBits = (1 << numberOfOverflowBits) - 1; // Select the bits, and convert them to a base 32 string.\n                var newOverflow = (baseId & newOverflowBits).toString(32); // Now we can remove those bits from the base id.\n                var restOfBaseId = baseId >> numberOfOverflowBits;\n                var restOfBaseLength = baseLength - numberOfOverflowBits; // Finally, encode the rest of the bits using the normal algorithm. Because\n                // we made more room, this time it won't overflow.\n                var restOfLength = getBitLength(totalChildren) + restOfBaseLength;\n                var restOfNewBits = slot << restOfBaseLength;\n                var id = restOfNewBits | restOfBaseId;\n                var overflow = newOverflow + baseOverflow;\n                treeContextId = 1 << restOfLength | id;\n                treeContextOverflow = overflow;\n            } else {\n                // Normal path\n                var newBits = slot << baseLength;\n                var _id = newBits | baseId;\n                var _overflow = baseOverflow;\n                treeContextId = 1 << length | _id;\n                treeContextOverflow = _overflow;\n            }\n        }\n        function pushMaterializedTreeId(workInProgress) {\n            warnIfNotHydrating(); // This component materialized an id. This will affect any ids that appear\n            // in its children.\n            var returnFiber = workInProgress.return;\n            if (returnFiber !== null) {\n                var numberOfForks = 1;\n                var slotIndex = 0;\n                pushTreeFork(workInProgress, numberOfForks);\n                pushTreeId(workInProgress, numberOfForks, slotIndex);\n            }\n        }\n        function getBitLength(number) {\n            return 32 - clz32(number);\n        }\n        function getLeadingBit(id) {\n            return 1 << getBitLength(id) - 1;\n        }\n        function popTreeContext(workInProgress) {\n            // Restore the previous values.\n            // This is a bit more complicated than other context-like modules in Fiber\n            // because the same Fiber may appear on the stack multiple times and for\n            // different reasons. We have to keep popping until the work-in-progress is\n            // no longer at the top of the stack.\n            while(workInProgress === treeForkProvider){\n                treeForkProvider = forkStack[--forkStackIndex];\n                forkStack[forkStackIndex] = null;\n                treeForkCount = forkStack[--forkStackIndex];\n                forkStack[forkStackIndex] = null;\n            }\n            while(workInProgress === treeContextProvider){\n                treeContextProvider = idStack[--idStackIndex];\n                idStack[idStackIndex] = null;\n                treeContextOverflow = idStack[--idStackIndex];\n                idStack[idStackIndex] = null;\n                treeContextId = idStack[--idStackIndex];\n                idStack[idStackIndex] = null;\n            }\n        }\n        function getSuspendedTreeContext() {\n            warnIfNotHydrating();\n            if (treeContextProvider !== null) {\n                return {\n                    id: treeContextId,\n                    overflow: treeContextOverflow\n                };\n            } else {\n                return null;\n            }\n        }\n        function restoreSuspendedTreeContext(workInProgress, suspendedContext) {\n            warnIfNotHydrating();\n            idStack[idStackIndex++] = treeContextId;\n            idStack[idStackIndex++] = treeContextOverflow;\n            idStack[idStackIndex++] = treeContextProvider;\n            treeContextId = suspendedContext.id;\n            treeContextOverflow = suspendedContext.overflow;\n            treeContextProvider = workInProgress;\n        }\n        function warnIfNotHydrating() {\n            {\n                if (!getIsHydrating()) {\n                    error('Expected to be hydrating. This is a bug in React. Please file ' + 'an issue.');\n                }\n            }\n        }\n        var contextStackCursor = createCursor(null);\n        var contextFiberStackCursor = createCursor(null);\n        var rootInstanceStackCursor = createCursor(null); // Represents the nearest host transition provider (in React DOM, a <form />)\n        // NOTE: Since forms cannot be nested, and this feature is only implemented by\n        // React DOM, we don't technically need this to be a stack. It could be a single\n        // module variable instead.\n        var hostTransitionProviderCursor = createCursor(null); // TODO: This should initialize to NotPendingTransition, a constant\n        // imported from the fiber config. However, because of a cycle in the module\n        // graph, that value isn't defined during this module's initialization. I can't\n        // think of a way to work around this without moving that value out of the\n        // fiber config. For now, the \"no provider\" case is handled when reading,\n        // inside useHostTransitionStatus.\n        var HostTransitionContext = {\n            $$typeof: REACT_CONTEXT_TYPE,\n            Provider: null,\n            Consumer: null,\n            _currentValue: null,\n            _currentValue2: null,\n            _threadCount: 0\n        };\n        function requiredContext(c) {\n            {\n                if (c === null) {\n                    error('Expected host context to exist. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n                }\n            }\n            return c;\n        }\n        function getRootHostContainer() {\n            var rootInstance = requiredContext(rootInstanceStackCursor.current);\n            return rootInstance;\n        }\n        function pushHostContainer(fiber, nextRootInstance) {\n            // Push current root instance onto the stack;\n            // This allows us to reset root when portals are popped.\n            push(rootInstanceStackCursor, nextRootInstance, fiber); // Track the context and the Fiber that provided it.\n            // This enables us to pop only Fibers that provide unique contexts.\n            push(contextFiberStackCursor, fiber, fiber); // Finally, we need to push the host context to the stack.\n            // However, we can't just call getRootHostContext() and push it because\n            // we'd have a different number of entries on the stack depending on\n            // whether getRootHostContext() throws somewhere in renderer code or not.\n            // So we push an empty value first. This lets us safely unwind on errors.\n            push(contextStackCursor, null, fiber);\n            var nextRootContext = getRootHostContext(nextRootInstance); // Now that we know this function doesn't throw, replace it.\n            pop(contextStackCursor, fiber);\n            push(contextStackCursor, nextRootContext, fiber);\n        }\n        function popHostContainer(fiber) {\n            pop(contextStackCursor, fiber);\n            pop(contextFiberStackCursor, fiber);\n            pop(rootInstanceStackCursor, fiber);\n        }\n        function getHostContext() {\n            var context = requiredContext(contextStackCursor.current);\n            return context;\n        }\n        function pushHostContext(fiber) {\n            {\n                var stateHook = fiber.memoizedState;\n                if (stateHook !== null) {\n                    // Only provide context if this fiber has been upgraded by a host\n                    // transition. We use the same optimization for regular host context below.\n                    push(hostTransitionProviderCursor, fiber, fiber);\n                }\n            }\n            var context = requiredContext(contextStackCursor.current);\n            var nextContext = getChildHostContext(context, fiber.type); // Don't push this Fiber's context unless it's unique.\n            if (context !== nextContext) {\n                // Track the context and the Fiber that provided it.\n                // This enables us to pop only Fibers that provide unique contexts.\n                push(contextFiberStackCursor, fiber, fiber);\n                push(contextStackCursor, nextContext, fiber);\n            }\n        }\n        function popHostContext(fiber) {\n            if (contextFiberStackCursor.current === fiber) {\n                // Do not pop unless this Fiber provided the current context.\n                // pushHostContext() only pushes Fibers that provide unique contexts.\n                pop(contextStackCursor, fiber);\n                pop(contextFiberStackCursor, fiber);\n            }\n            {\n                if (hostTransitionProviderCursor.current === fiber) {\n                    // Do not pop unless this Fiber provided the current context. This is mostly\n                    // a performance optimization, but conveniently it also prevents a potential\n                    // data race where a host provider is upgraded (i.e. memoizedState becomes\n                    // non-null) during a concurrent event. This is a bit of a flaw in the way\n                    // we upgrade host components, but because we're accounting for it here, it\n                    // should be fine.\n                    pop(hostTransitionProviderCursor, fiber); // When popping the transition provider, we reset the context value back\n                    // to `null`. We can do this because you're not allowd to nest forms. If\n                    // we allowed for multiple nested host transition providers, then we'd\n                    // need to reset this to the parent provider's status.\n                    if (isPrimaryRenderer) {\n                        HostTransitionContext._currentValue = null;\n                    } else {\n                        HostTransitionContext._currentValue2 = null;\n                    }\n                }\n            }\n        }\n        var maxRowLength = 120;\n        var idealDepth = 15;\n        function findNotableNode(node, indent) {\n            if (node.serverProps === undefined && node.serverTail.length === 0 && node.children.length === 1 && node.distanceFromLeaf > 3 && node.distanceFromLeaf > idealDepth - indent) {\n                // This is not an interesting node for contextual purposes so we can skip it.\n                var child = node.children[0];\n                return findNotableNode(child, indent);\n            }\n            return node;\n        }\n        function indentation(indent) {\n            return '  ' + '  '.repeat(indent);\n        }\n        function added(indent) {\n            return '+ ' + '  '.repeat(indent);\n        }\n        function removed(indent) {\n            return '- ' + '  '.repeat(indent);\n        }\n        function describeFiberType(fiber) {\n            switch(fiber.tag){\n                case HostHoistable:\n                case HostSingleton:\n                case HostComponent:\n                    return fiber.type;\n                case LazyComponent:\n                    return 'Lazy';\n                case SuspenseComponent:\n                    return 'Suspense';\n                case SuspenseListComponent:\n                    return 'SuspenseList';\n                case FunctionComponent:\n                case SimpleMemoComponent:\n                    var fn = fiber.type;\n                    return fn.displayName || fn.name || null;\n                case ForwardRef:\n                    var render = fiber.type.render;\n                    return render.displayName || render.name || null;\n                case ClassComponent:\n                    var ctr = fiber.type;\n                    return ctr.displayName || ctr.name || null;\n                default:\n                    // Skip\n                    return null;\n            }\n        }\n        var needsEscaping = /[\"'&<>\\n\\t]/;\n        function describeTextNode(content, maxLength) {\n            if (needsEscaping.test(content)) {\n                var encoded = JSON.stringify(content);\n                if (encoded.length > maxLength - 2) {\n                    if (maxLength < 8) {\n                        return '{\"...\"}';\n                    }\n                    return '{' + encoded.slice(0, maxLength - 7) + '...\"}';\n                }\n                return '{' + encoded + '}';\n            } else {\n                if (content.length > maxLength) {\n                    if (maxLength < 5) {\n                        return '{\"...\"}';\n                    }\n                    return content.slice(0, maxLength - 3) + '...';\n                }\n                return content;\n            }\n        }\n        function describeTextDiff(clientText, serverProps, indent) {\n            var maxLength = maxRowLength - indent * 2;\n            if (serverProps === null) {\n                return added(indent) + describeTextNode(clientText, maxLength) + '\\n';\n            } else if (typeof serverProps === 'string') {\n                var serverText = serverProps;\n                var firstDiff = 0;\n                for(; firstDiff < serverText.length && firstDiff < clientText.length; firstDiff++){\n                    if (serverText.charCodeAt(firstDiff) !== clientText.charCodeAt(firstDiff)) {\n                        break;\n                    }\n                }\n                if (firstDiff > maxLength - 8 && firstDiff > 10) {\n                    // The first difference between the two strings would be cut off, so cut off in\n                    // the beginning instead.\n                    clientText = '...' + clientText.slice(firstDiff - 8);\n                    serverText = '...' + serverText.slice(firstDiff - 8);\n                }\n                return added(indent) + describeTextNode(clientText, maxLength) + '\\n' + removed(indent) + describeTextNode(serverText, maxLength) + '\\n';\n            } else {\n                return indentation(indent) + describeTextNode(clientText, maxLength) + '\\n';\n            }\n        }\n        function objectName(object) {\n            // $FlowFixMe[method-unbinding]\n            var name = Object.prototype.toString.call(object);\n            return name.replace(/^\\[object (.*)\\]$/, function(m, p0) {\n                return p0;\n            });\n        }\n        function describeValue(value, maxLength) {\n            switch(typeof value){\n                case 'string':\n                    {\n                        var encoded = JSON.stringify(value);\n                        if (encoded.length > maxLength) {\n                            if (maxLength < 5) {\n                                return '\"...\"';\n                            }\n                            return encoded.slice(0, maxLength - 4) + '...\"';\n                        }\n                        return encoded;\n                    }\n                case 'object':\n                    {\n                        if (value === null) {\n                            return 'null';\n                        }\n                        if (isArray(value)) {\n                            return '[...]';\n                        }\n                        if (value.$$typeof === REACT_ELEMENT_TYPE) {\n                            var type = getComponentNameFromType(value.type);\n                            return type ? '<' + type + '>' : '<...>';\n                        }\n                        var name = objectName(value);\n                        if (name === 'Object') {\n                            var properties = '';\n                            maxLength -= 2;\n                            for(var propName in value){\n                                if (!value.hasOwnProperty(propName)) {\n                                    continue;\n                                }\n                                var jsonPropName = JSON.stringify(propName);\n                                if (jsonPropName !== '\"' + propName + '\"') {\n                                    propName = jsonPropName;\n                                }\n                                maxLength -= propName.length - 2;\n                                var propValue = describeValue(value[propName], maxLength < 15 ? maxLength : 15);\n                                maxLength -= propValue.length;\n                                if (maxLength < 0) {\n                                    properties += properties === '' ? '...' : ', ...';\n                                    break;\n                                }\n                                properties += (properties === '' ? '' : ',') + propName + ':' + propValue;\n                            }\n                            return '{' + properties + '}';\n                        }\n                        return name;\n                    }\n                case 'function':\n                    {\n                        var _name = value.displayName || value.name;\n                        return _name ? 'function ' + _name : 'function';\n                    }\n                default:\n                    // eslint-disable-next-line react-internal/safe-string-coercion\n                    return String(value);\n            }\n        }\n        function describePropValue(value, maxLength) {\n            if (typeof value === 'string' && !needsEscaping.test(value)) {\n                if (value.length > maxLength - 2) {\n                    if (maxLength < 5) {\n                        return '\"...\"';\n                    }\n                    return '\"' + value.slice(0, maxLength - 5) + '...\"';\n                }\n                return '\"' + value + '\"';\n            }\n            return '{' + describeValue(value, maxLength - 2) + '}';\n        }\n        function describeCollapsedElement(type, props, indent) {\n            // This function tries to fit the props into a single line for non-essential elements.\n            // We also ignore children because we're not going deeper.\n            var maxLength = maxRowLength - indent * 2 - type.length - 2;\n            var content = '';\n            for(var propName in props){\n                if (!props.hasOwnProperty(propName)) {\n                    continue;\n                }\n                if (propName === 'children') {\n                    continue;\n                }\n                var propValue = describePropValue(props[propName], 15);\n                maxLength -= propName.length + propValue.length + 2;\n                if (maxLength < 0) {\n                    content += ' ...';\n                    break;\n                }\n                content += ' ' + propName + '=' + propValue;\n            }\n            return indentation(indent) + '<' + type + content + '>\\n';\n        }\n        function describeExpandedElement(type, props, rowPrefix) {\n            // This function tries to fit the props into a single line for non-essential elements.\n            // We also ignore children because we're not going deeper.\n            var remainingRowLength = maxRowLength - rowPrefix.length - type.length; // We add the properties to a set so we can choose later whether we'll put it on one\n            // line or multiple lines.\n            var properties = [];\n            for(var propName in props){\n                if (!props.hasOwnProperty(propName)) {\n                    continue;\n                }\n                if (propName === 'children') {\n                    continue;\n                }\n                var maxLength = maxRowLength - rowPrefix.length - propName.length - 1;\n                var propValue = describePropValue(props[propName], maxLength);\n                remainingRowLength -= propName.length + propValue.length + 2;\n                properties.push(propName + '=' + propValue);\n            }\n            if (properties.length === 0) {\n                return rowPrefix + '<' + type + '>\\n';\n            } else if (remainingRowLength > 0) {\n                // We can fit all on one row.\n                return rowPrefix + '<' + type + ' ' + properties.join(' ') + '>\\n';\n            } else {\n                // Split into one row per property:\n                return rowPrefix + '<' + type + '\\n' + rowPrefix + '  ' + properties.join('\\n' + rowPrefix + '  ') + '\\n' + rowPrefix + '>\\n';\n            }\n        }\n        function describePropertiesDiff(clientObject, serverObject, indent) {\n            var properties = '';\n            var remainingServerProperties = assign({}, serverObject);\n            for(var propName in clientObject){\n                if (!clientObject.hasOwnProperty(propName)) {\n                    continue;\n                }\n                delete remainingServerProperties[propName];\n                var maxLength = maxRowLength - indent * 2 - propName.length - 2;\n                var clientValue = clientObject[propName];\n                var clientPropValue = describeValue(clientValue, maxLength);\n                if (serverObject.hasOwnProperty(propName)) {\n                    var serverValue = serverObject[propName];\n                    var serverPropValue = describeValue(serverValue, maxLength);\n                    properties += added(indent) + propName + ': ' + clientPropValue + '\\n';\n                    properties += removed(indent) + propName + ': ' + serverPropValue + '\\n';\n                } else {\n                    properties += added(indent) + propName + ': ' + clientPropValue + '\\n';\n                }\n            }\n            for(var _propName in remainingServerProperties){\n                if (!remainingServerProperties.hasOwnProperty(_propName)) {\n                    continue;\n                }\n                var _maxLength = maxRowLength - indent * 2 - _propName.length - 2;\n                var _serverValue = remainingServerProperties[_propName];\n                var _serverPropValue = describeValue(_serverValue, _maxLength);\n                properties += removed(indent) + _propName + ': ' + _serverPropValue + '\\n';\n            }\n            return properties;\n        }\n        function describeElementDiff(type, clientProps, serverProps, indent) {\n            var content = ''; // Maps any previously unmatched lower case server prop name to its full prop name\n            var serverPropNames = new Map();\n            for(var propName in serverProps){\n                if (!serverProps.hasOwnProperty(propName)) {\n                    continue;\n                }\n                serverPropNames.set(propName.toLowerCase(), propName);\n            }\n            if (serverPropNames.size === 1 && serverPropNames.has('children')) {\n                content += describeExpandedElement(type, clientProps, indentation(indent));\n            } else {\n                for(var _propName2 in clientProps){\n                    if (!clientProps.hasOwnProperty(_propName2)) {\n                        continue;\n                    }\n                    if (_propName2 === 'children') {\n                        continue;\n                    }\n                    var maxLength = maxRowLength - (indent + 1) * 2 - _propName2.length - 1;\n                    var serverPropName = serverPropNames.get(_propName2.toLowerCase());\n                    if (serverPropName !== undefined) {\n                        serverPropNames.delete(_propName2.toLowerCase()); // There's a diff here.\n                        var clientValue = clientProps[_propName2];\n                        var serverValue = serverProps[serverPropName];\n                        var clientPropValue = describePropValue(clientValue, maxLength);\n                        var serverPropValue = describePropValue(serverValue, maxLength);\n                        if (typeof clientValue === 'object' && clientValue !== null && typeof serverValue === 'object' && serverValue !== null && objectName(clientValue) === 'Object' && objectName(serverValue) === 'Object' && (Object.keys(clientValue).length > 2 || Object.keys(serverValue).length > 2 || clientPropValue.indexOf('...') > -1 || serverPropValue.indexOf('...') > -1)) {\n                            // We're comparing two plain objects. We can diff the nested objects instead.\n                            content += indentation(indent + 1) + _propName2 + '={{\\n' + describePropertiesDiff(clientValue, serverValue, indent + 2) + indentation(indent + 1) + '}}\\n';\n                        } else {\n                            content += added(indent + 1) + _propName2 + '=' + clientPropValue + '\\n';\n                            content += removed(indent + 1) + _propName2 + '=' + serverPropValue + '\\n';\n                        }\n                    } else {\n                        // Considered equal.\n                        content += indentation(indent + 1) + _propName2 + '=' + describePropValue(clientProps[_propName2], maxLength) + '\\n';\n                    }\n                }\n                serverPropNames.forEach(function(propName) {\n                    if (propName === 'children') {\n                        // Handled below.\n                        return;\n                    }\n                    var maxLength = maxRowLength - (indent + 1) * 2 - propName.length - 1;\n                    content += removed(indent + 1) + propName + '=' + describePropValue(serverProps[propName], maxLength) + '\\n';\n                });\n                if (content === '') {\n                    // No properties\n                    content = indentation(indent) + '<' + type + '>\\n';\n                } else {\n                    // Had properties\n                    content = indentation(indent) + '<' + type + '\\n' + content + indentation(indent) + '>\\n';\n                }\n            }\n            var serverChildren = serverProps.children;\n            var clientChildren = clientProps.children;\n            if (typeof serverChildren === 'string' || typeof serverChildren === 'number' || typeof serverChildren === 'bigint') {\n                // There's a diff of the children.\n                // $FlowFixMe[unsafe-addition]\n                var serverText = '' + serverChildren;\n                var clientText = '';\n                if (typeof clientChildren === 'string' || typeof clientChildren === 'number' || typeof clientChildren === 'bigint') {\n                    // $FlowFixMe[unsafe-addition]\n                    clientText = '' + clientChildren;\n                }\n                content += describeTextDiff(clientText, serverText, indent + 1);\n            } else if (typeof clientChildren === 'string' || typeof clientChildren === 'number' || typeof clientChildren === 'bigint') {\n                // The client has children but it's not considered a difference from the server.\n                // $FlowFixMe[unsafe-addition]\n                content += describeTextDiff('' + clientChildren, undefined, indent + 1);\n            }\n            return content;\n        }\n        function describeSiblingFiber(fiber, indent) {\n            var type = describeFiberType(fiber);\n            if (type === null) {\n                // Skip this type of fiber. We currently treat this as a fragment\n                // so it's just part of the parent's children.\n                var flatContent = '';\n                var childFiber = fiber.child;\n                while(childFiber){\n                    flatContent += describeSiblingFiber(childFiber, indent);\n                    childFiber = childFiber.sibling;\n                }\n                return flatContent;\n            }\n            return indentation(indent) + '<' + type + '>' + '\\n';\n        }\n        function describeNode(node, indent) {\n            var skipToNode = findNotableNode(node, indent);\n            if (skipToNode !== node && (node.children.length !== 1 || node.children[0] !== skipToNode)) {\n                return indentation(indent) + '...\\n' + describeNode(skipToNode, indent + 1);\n            } // Prefix with any server components for context\n            var parentContent = '';\n            var debugInfo = node.fiber._debugInfo;\n            if (debugInfo) {\n                for(var i = 0; i < debugInfo.length; i++){\n                    var serverComponentName = debugInfo[i].name;\n                    if (typeof serverComponentName === 'string') {\n                        parentContent += indentation(indent) + '<' + serverComponentName + '>' + '\\n';\n                        indent++;\n                    }\n                }\n            } // Self\n            var selfContent = ''; // We use the pending props since we might be generating a diff before the complete phase\n            // when something throws.\n            var clientProps = node.fiber.pendingProps;\n            if (node.fiber.tag === HostText) {\n                // Text Node\n                selfContent = describeTextDiff(clientProps, node.serverProps, indent);\n            } else {\n                var type = describeFiberType(node.fiber);\n                if (type !== null) {\n                    // Element Node\n                    if (node.serverProps === undefined) {\n                        // Just a reference node for context.\n                        selfContent = describeCollapsedElement(type, clientProps, indent);\n                        indent++;\n                    } else if (node.serverProps === null) {\n                        selfContent = describeExpandedElement(type, clientProps, added(indent)); // If this was an insertion we won't step down further. Any tail\n                    // are considered siblings so we don't indent.\n                    // TODO: Model this a little better.\n                    } else if (typeof node.serverProps === 'string') {\n                        {\n                            error('Should not have matched a non HostText fiber to a Text node. This is a bug in React.');\n                        }\n                    } else {\n                        selfContent = describeElementDiff(type, clientProps, node.serverProps, indent);\n                        indent++;\n                    }\n                }\n            } // Compute children\n            var childContent = '';\n            var childFiber = node.fiber.child;\n            var diffIdx = 0;\n            while(childFiber && diffIdx < node.children.length){\n                var childNode = node.children[diffIdx];\n                if (childNode.fiber === childFiber) {\n                    // This was a match in the diff.\n                    childContent += describeNode(childNode, indent);\n                    diffIdx++;\n                } else {\n                    // This is an unrelated previous sibling.\n                    childContent += describeSiblingFiber(childFiber, indent);\n                }\n                childFiber = childFiber.sibling;\n            }\n            if (childFiber && node.children.length > 0) {\n                // If we had any further siblings after the last mismatch, we can't be sure if it's\n                // actually a valid match since it might not have found a match. So we exclude next\n                // siblings to avoid confusion.\n                childContent += indentation(indent) + '...' + '\\n';\n            } // Deleted tail nodes\n            var serverTail = node.serverTail;\n            for(var _i = 0; _i < serverTail.length; _i++){\n                var tailNode = serverTail[_i];\n                if (typeof tailNode === 'string') {\n                    // Removed text node\n                    childContent += removed(indent) + describeTextNode(tailNode, maxRowLength - indent * 2) + '\\n';\n                } else {\n                    // Removed element\n                    childContent += describeExpandedElement(tailNode.type, tailNode.props, removed(indent));\n                }\n            }\n            return parentContent + selfContent + childContent;\n        }\n        function describeDiff(rootNode) {\n            try {\n                return '\\n\\n' + describeNode(rootNode, 0);\n            } catch (x) {\n                return '';\n            }\n        }\n        // This may have been an insertion or a hydration.\n        var hydrationParentFiber = null;\n        var nextHydratableInstance = null;\n        var isHydrating = false; // This flag allows for warning supression when we expect there to be mismatches\n        // due to earlier mismatches or a suspended fiber.\n        var didSuspendOrErrorDEV = false; // Hydration differences found that haven't yet been logged.\n        var hydrationDiffRootDEV = null; // Hydration errors that were thrown inside this boundary\n        var hydrationErrors = null;\n        var rootOrSingletonContext = false; // Builds a common ancestor tree from the root down for collecting diffs.\n        function buildHydrationDiffNode(fiber, distanceFromLeaf) {\n            if (fiber.return === null) {\n                // We're at the root.\n                if (hydrationDiffRootDEV === null) {\n                    hydrationDiffRootDEV = {\n                        fiber: fiber,\n                        children: [],\n                        serverProps: undefined,\n                        serverTail: [],\n                        distanceFromLeaf: distanceFromLeaf\n                    };\n                } else if (hydrationDiffRootDEV.fiber !== fiber) {\n                    throw new Error('Saw multiple hydration diff roots in a pass. This is a bug in React.');\n                } else if (hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf) {\n                    hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf;\n                }\n                return hydrationDiffRootDEV;\n            }\n            var siblings = buildHydrationDiffNode(fiber.return, distanceFromLeaf + 1).children; // The same node may already exist in the parent. Since we currently always render depth first\n            // and rerender if we suspend or terminate early, if a shared ancestor was added we should still\n            // be inside of that shared ancestor which means it was the last one to be added. If this changes\n            // we may have to scan the whole set.\n            if (siblings.length > 0 && siblings[siblings.length - 1].fiber === fiber) {\n                var existing = siblings[siblings.length - 1];\n                if (existing.distanceFromLeaf > distanceFromLeaf) {\n                    existing.distanceFromLeaf = distanceFromLeaf;\n                }\n                return existing;\n            }\n            var newNode = {\n                fiber: fiber,\n                children: [],\n                serverProps: undefined,\n                serverTail: [],\n                distanceFromLeaf: distanceFromLeaf\n            };\n            siblings.push(newNode);\n            return newNode;\n        }\n        function warnIfHydrating() {\n            {\n                if (isHydrating) {\n                    error('We should not be hydrating here. This is a bug in React. Please file a bug.');\n                }\n            }\n        }\n        function markDidThrowWhileHydratingDEV() {\n            {\n                didSuspendOrErrorDEV = true;\n            }\n        }\n        function enterHydrationState(fiber) {\n            if (!supportsHydration) {\n                return false;\n            }\n            var parentInstance = fiber.stateNode.containerInfo;\n            nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);\n            hydrationParentFiber = fiber;\n            isHydrating = true;\n            hydrationErrors = null;\n            didSuspendOrErrorDEV = false;\n            hydrationDiffRootDEV = null;\n            rootOrSingletonContext = true;\n            return true;\n        }\n        function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {\n            if (!supportsHydration) {\n                return false;\n            }\n            nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);\n            hydrationParentFiber = fiber;\n            isHydrating = true;\n            hydrationErrors = null;\n            didSuspendOrErrorDEV = false;\n            hydrationDiffRootDEV = null;\n            rootOrSingletonContext = false;\n            if (treeContext !== null) {\n                restoreSuspendedTreeContext(fiber, treeContext);\n            }\n            return true;\n        }\n        function warnNonHydratedInstance(fiber, rejectedCandidate) {\n            {\n                if (didSuspendOrErrorDEV) {\n                    // Inside a boundary that already suspended. We're currently rendering the\n                    // siblings of a suspended node. The mismatch may be due to the missing\n                    // data, so it's probably a false positive.\n                    return;\n                } // Add this fiber to the diff tree.\n                var diffNode = buildHydrationDiffNode(fiber, 0); // We use null as a signal that there was no node to match.\n                diffNode.serverProps = null;\n                if (rejectedCandidate !== null) {\n                    var description = describeHydratableInstanceForDevWarnings(rejectedCandidate);\n                    diffNode.serverTail.push(description);\n                }\n            }\n        }\n        function tryHydrateInstance(fiber, nextInstance, hostContext) {\n            // fiber is a HostComponent Fiber\n            var instance = canHydrateInstance(nextInstance, fiber.type, fiber.pendingProps, rootOrSingletonContext);\n            if (instance !== null) {\n                fiber.stateNode = instance;\n                {\n                    if (!didSuspendOrErrorDEV) {\n                        var differences = diffHydratedPropsForDevWarnings(instance, fiber.type, fiber.pendingProps, hostContext);\n                        if (differences !== null) {\n                            var diffNode = buildHydrationDiffNode(fiber, 0);\n                            diffNode.serverProps = differences;\n                        }\n                    }\n                }\n                hydrationParentFiber = fiber;\n                nextHydratableInstance = getFirstHydratableChild(instance);\n                rootOrSingletonContext = false;\n                return true;\n            }\n            return false;\n        }\n        function tryHydrateText(fiber, nextInstance) {\n            // fiber is a HostText Fiber\n            var text = fiber.pendingProps;\n            var textInstance = canHydrateTextInstance(nextInstance, text, rootOrSingletonContext);\n            if (textInstance !== null) {\n                fiber.stateNode = textInstance;\n                hydrationParentFiber = fiber; // Text Instances don't have children so there's nothing to hydrate.\n                nextHydratableInstance = null;\n                return true;\n            }\n            return false;\n        }\n        function tryHydrateSuspense(fiber, nextInstance) {\n            // fiber is a SuspenseComponent Fiber\n            var suspenseInstance = canHydrateSuspenseInstance(nextInstance, rootOrSingletonContext);\n            if (suspenseInstance !== null) {\n                var suspenseState = {\n                    dehydrated: suspenseInstance,\n                    treeContext: getSuspendedTreeContext(),\n                    retryLane: OffscreenLane\n                };\n                fiber.memoizedState = suspenseState; // Store the dehydrated fragment as a child fiber.\n                // This simplifies the code for getHostSibling and deleting nodes,\n                // since it doesn't have to consider all Suspense boundaries and\n                // check if they're dehydrated ones or not.\n                var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);\n                dehydratedFragment.return = fiber;\n                fiber.child = dehydratedFragment;\n                hydrationParentFiber = fiber; // While a Suspense Instance does have children, we won't step into\n                // it during the first pass. Instead, we'll reenter it later.\n                nextHydratableInstance = null;\n                return true;\n            }\n            return false;\n        }\n        var HydrationMismatchException = new Error('Hydration Mismatch Exception: This is not a real error, and should not leak into ' + \"userspace. If you're seeing this, it's likely a bug in React.\");\n        function throwOnHydrationMismatch(fiber) {\n            var diff = '';\n            {\n                // Consume the diff root for this mismatch.\n                // Any other errors will get their own diffs.\n                var diffRoot = hydrationDiffRootDEV;\n                if (diffRoot !== null) {\n                    hydrationDiffRootDEV = null;\n                    diff = describeDiff(diffRoot);\n                }\n            }\n            var error = new Error(\"Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\\n\" + '\\n' + \"- A server/client branch `if (typeof window !== 'undefined')`.\\n\" + \"- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\\n\" + \"- Date formatting in a user's locale which doesn't match the server.\\n\" + '- External changing data without sending a snapshot of it along with the HTML.\\n' + '- Invalid HTML tag nesting.\\n' + '\\n' + 'It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\\n' + '\\n' + 'https://react.dev/link/hydration-mismatch' + diff);\n            queueHydrationError(createCapturedValueAtFiber(error, fiber));\n            throw HydrationMismatchException;\n        }\n        function claimHydratableSingleton(fiber) {\n            if (supportsSingletons) {\n                if (!isHydrating) {\n                    return;\n                }\n                var currentRootContainer = getRootHostContainer();\n                var currentHostContext = getHostContext();\n                var instance = fiber.stateNode = resolveSingletonInstance(fiber.type, fiber.pendingProps, currentRootContainer, currentHostContext, false);\n                {\n                    if (!didSuspendOrErrorDEV) {\n                        var differences = diffHydratedPropsForDevWarnings(instance, fiber.type, fiber.pendingProps, currentHostContext);\n                        if (differences !== null) {\n                            var diffNode = buildHydrationDiffNode(fiber, 0);\n                            diffNode.serverProps = differences;\n                        }\n                    }\n                }\n                hydrationParentFiber = fiber;\n                rootOrSingletonContext = true;\n                nextHydratableInstance = getFirstHydratableChild(instance);\n            }\n        }\n        function tryToClaimNextHydratableInstance(fiber) {\n            if (!isHydrating) {\n                return;\n            } // Validate that this is ok to render here before any mismatches.\n            var currentHostContext = getHostContext();\n            var shouldKeepWarning = validateHydratableInstance(fiber.type, fiber.pendingProps, currentHostContext);\n            var nextInstance = nextHydratableInstance;\n            if (!nextInstance || !tryHydrateInstance(fiber, nextInstance, currentHostContext)) {\n                if (shouldKeepWarning) {\n                    warnNonHydratedInstance(fiber, nextInstance);\n                }\n                throwOnHydrationMismatch(fiber);\n            }\n        }\n        function tryToClaimNextHydratableTextInstance(fiber) {\n            if (!isHydrating) {\n                return;\n            }\n            var text = fiber.pendingProps;\n            var shouldKeepWarning = true; // Validate that this is ok to render here before any mismatches.\n            var currentHostContext = getHostContext();\n            shouldKeepWarning = validateHydratableTextInstance(text, currentHostContext);\n            var nextInstance = nextHydratableInstance;\n            if (!nextInstance || !tryHydrateText(fiber, nextInstance)) {\n                if (shouldKeepWarning) {\n                    warnNonHydratedInstance(fiber, nextInstance);\n                }\n                throwOnHydrationMismatch(fiber);\n            }\n        }\n        function tryToClaimNextHydratableSuspenseInstance(fiber) {\n            if (!isHydrating) {\n                return;\n            }\n            var nextInstance = nextHydratableInstance;\n            if (!nextInstance || !tryHydrateSuspense(fiber, nextInstance)) {\n                warnNonHydratedInstance(fiber, nextInstance);\n                throwOnHydrationMismatch(fiber);\n            }\n        }\n        function tryToClaimNextHydratableFormMarkerInstance(fiber) {\n            if (!isHydrating) {\n                return false;\n            }\n            if (nextHydratableInstance) {\n                var markerInstance = canHydrateFormStateMarker(nextHydratableInstance, rootOrSingletonContext);\n                if (markerInstance) {\n                    // Found the marker instance.\n                    nextHydratableInstance = getNextHydratableSibling(markerInstance); // Return true if this marker instance should use the state passed\n                    // to hydrateRoot.\n                    // TODO: As an optimization, Fizz should only emit these markers if form\n                    // state is passed at the root.\n                    return isFormStateMarkerMatching(markerInstance);\n                }\n            } // Should have found a marker instance. Throw an error to trigger client\n            // rendering. We don't bother to check if we're in a concurrent root because\n            // useActionState is a new API, so backwards compat is not an issue.\n            throwOnHydrationMismatch(fiber);\n            return false;\n        }\n        function prepareToHydrateHostInstance(fiber, hostContext) {\n            if (!supportsHydration) {\n                throw new Error('Expected prepareToHydrateHostInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n            }\n            var instance = fiber.stateNode;\n            var didHydrate = hydrateInstance(instance, fiber.type, fiber.memoizedProps, hostContext, fiber);\n            if (!didHydrate && favorSafetyOverHydrationPerf) {\n                throwOnHydrationMismatch(fiber);\n            }\n        }\n        function prepareToHydrateHostTextInstance(fiber) {\n            if (!supportsHydration) {\n                throw new Error('Expected prepareToHydrateHostTextInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n            }\n            var textInstance = fiber.stateNode;\n            var textContent = fiber.memoizedProps;\n            var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;\n            var parentProps = null; // We assume that prepareToHydrateHostTextInstance is called in a context where the\n            // hydration parent is the parent host component of this host text.\n            var returnFiber = hydrationParentFiber;\n            if (returnFiber !== null) {\n                switch(returnFiber.tag){\n                    case HostRoot:\n                        {\n                            {\n                                if (shouldWarnIfMismatchDev) {\n                                    var difference = diffHydratedTextForDevWarnings(textInstance, textContent, parentProps);\n                                    if (difference !== null) {\n                                        var diffNode = buildHydrationDiffNode(fiber, 0);\n                                        diffNode.serverProps = difference;\n                                    }\n                                }\n                            }\n                            break;\n                        }\n                    case HostSingleton:\n                    case HostComponent:\n                        {\n                            parentProps = returnFiber.memoizedProps;\n                            {\n                                if (shouldWarnIfMismatchDev) {\n                                    var _difference = diffHydratedTextForDevWarnings(textInstance, textContent, parentProps);\n                                    if (_difference !== null) {\n                                        var _diffNode = buildHydrationDiffNode(fiber, 0);\n                                        _diffNode.serverProps = _difference;\n                                    }\n                                }\n                            }\n                            break;\n                        }\n                } // TODO: What if it's a SuspenseInstance?\n            }\n            var didHydrate = hydrateTextInstance(textInstance, textContent, fiber, parentProps);\n            if (!didHydrate && favorSafetyOverHydrationPerf) {\n                throwOnHydrationMismatch(fiber);\n            }\n        }\n        function prepareToHydrateHostSuspenseInstance(fiber) {\n            if (!supportsHydration) {\n                throw new Error('Expected prepareToHydrateHostSuspenseInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n            }\n            var suspenseState = fiber.memoizedState;\n            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n            if (!suspenseInstance) {\n                throw new Error('Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n            }\n            hydrateSuspenseInstance(suspenseInstance, fiber);\n        }\n        function skipPastDehydratedSuspenseInstance(fiber) {\n            if (!supportsHydration) {\n                throw new Error('Expected skipPastDehydratedSuspenseInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n            }\n            var suspenseState = fiber.memoizedState;\n            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n            if (!suspenseInstance) {\n                throw new Error('Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n            }\n            return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);\n        }\n        function popToNextHostParent(fiber) {\n            hydrationParentFiber = fiber.return;\n            while(hydrationParentFiber){\n                switch(hydrationParentFiber.tag){\n                    case HostRoot:\n                    case HostSingleton:\n                        rootOrSingletonContext = true;\n                        return;\n                    case HostComponent:\n                    case SuspenseComponent:\n                        rootOrSingletonContext = false;\n                        return;\n                    default:\n                        hydrationParentFiber = hydrationParentFiber.return;\n                }\n            }\n        }\n        function popHydrationState(fiber) {\n            if (!supportsHydration) {\n                return false;\n            }\n            if (fiber !== hydrationParentFiber) {\n                // We're deeper than the current hydration context, inside an inserted\n                // tree.\n                return false;\n            }\n            if (!isHydrating) {\n                // If we're not currently hydrating but we're in a hydration context, then\n                // we were an insertion and now need to pop up reenter hydration of our\n                // siblings.\n                popToNextHostParent(fiber);\n                isHydrating = true;\n                return false;\n            }\n            var shouldClear = false;\n            if (supportsSingletons) {\n                // With float we never clear the Root, or Singleton instances. We also do not clear Instances\n                // that have singleton text content\n                if (fiber.tag !== HostRoot && fiber.tag !== HostSingleton && !(fiber.tag === HostComponent && (!shouldDeleteUnhydratedTailInstances(fiber.type) || shouldSetTextContent(fiber.type, fiber.memoizedProps)))) {\n                    shouldClear = true;\n                }\n            } else {\n                // If we have any remaining hydratable nodes, we need to delete them now.\n                // We only do this deeper than head and body since they tend to have random\n                // other nodes in them. We also ignore components with pure text content in\n                // side of them. We also don't delete anything inside the root container.\n                if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {\n                    shouldClear = true;\n                }\n            }\n            if (shouldClear) {\n                var nextInstance = nextHydratableInstance;\n                if (nextInstance) {\n                    warnIfUnhydratedTailNodes(fiber);\n                    throwOnHydrationMismatch(fiber);\n                }\n            }\n            popToNextHostParent(fiber);\n            if (fiber.tag === SuspenseComponent) {\n                nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);\n            } else {\n                nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n            }\n            return true;\n        }\n        function warnIfUnhydratedTailNodes(fiber) {\n            {\n                var nextInstance = nextHydratableInstance;\n                while(nextInstance){\n                    var diffNode = buildHydrationDiffNode(fiber, 0);\n                    var description = describeHydratableInstanceForDevWarnings(nextInstance);\n                    diffNode.serverTail.push(description);\n                    if (description.type === 'Suspense') {\n                        var suspenseInstance = nextInstance;\n                        nextInstance = getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);\n                    } else {\n                        nextInstance = getNextHydratableSibling(nextInstance);\n                    }\n                }\n            }\n        }\n        function resetHydrationState() {\n            if (!supportsHydration) {\n                return;\n            }\n            hydrationParentFiber = null;\n            nextHydratableInstance = null;\n            isHydrating = false;\n            didSuspendOrErrorDEV = false;\n        }\n        function upgradeHydrationErrorsToRecoverable() {\n            if (hydrationErrors !== null) {\n                // Successfully completed a forced client render. The errors that occurred\n                // during the hydration attempt are now recovered. We will log them in\n                // commit phase, once the entire tree has finished.\n                queueRecoverableErrors(hydrationErrors);\n                hydrationErrors = null;\n            }\n        }\n        function getIsHydrating() {\n            return isHydrating;\n        }\n        function queueHydrationError(error) {\n            if (hydrationErrors === null) {\n                hydrationErrors = [\n                    error\n                ];\n            } else {\n                hydrationErrors.push(error);\n            }\n        }\n        function emitPendingHydrationWarnings() {\n            {\n                // If we haven't yet thrown any hydration errors by the time we reach the end we've successfully\n                // hydrated, however, we might still have DEV-only mismatches that we log now.\n                var diffRoot = hydrationDiffRootDEV;\n                if (diffRoot !== null) {\n                    hydrationDiffRootDEV = null;\n                    var diff = describeDiff(diffRoot);\n                    error(\"A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. \" + 'This can happen if a SSR-ed Client Component used:\\n' + '\\n' + \"- A server/client branch `if (typeof window !== 'undefined')`.\\n\" + \"- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\\n\" + \"- Date formatting in a user's locale which doesn't match the server.\\n\" + '- External changing data without sending a snapshot of it along with the HTML.\\n' + '- Invalid HTML tag nesting.\\n' + '\\n' + 'It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\\n' + '\\n' + '%s%s', 'https://react.dev/link/hydration-mismatch', diff);\n                }\n            }\n        }\n        // we wait until the current render is over (either finished or interrupted)\n        // before adding it to the fiber/hook queue. Push to this array so we can\n        // access the queue, fiber, update, et al later.\n        var concurrentQueues = [];\n        var concurrentQueuesIndex = 0;\n        var concurrentlyUpdatedLanes = NoLanes;\n        function finishQueueingConcurrentUpdates() {\n            var endIndex = concurrentQueuesIndex;\n            concurrentQueuesIndex = 0;\n            concurrentlyUpdatedLanes = NoLanes;\n            var i = 0;\n            while(i < endIndex){\n                var fiber = concurrentQueues[i];\n                concurrentQueues[i++] = null;\n                var queue = concurrentQueues[i];\n                concurrentQueues[i++] = null;\n                var update = concurrentQueues[i];\n                concurrentQueues[i++] = null;\n                var lane = concurrentQueues[i];\n                concurrentQueues[i++] = null;\n                if (queue !== null && update !== null) {\n                    var pending = queue.pending;\n                    if (pending === null) {\n                        // This is the first update. Create a circular list.\n                        update.next = update;\n                    } else {\n                        update.next = pending.next;\n                        pending.next = update;\n                    }\n                    queue.pending = update;\n                }\n                if (lane !== NoLane) {\n                    markUpdateLaneFromFiberToRoot(fiber, update, lane);\n                }\n            }\n        }\n        function getConcurrentlyUpdatedLanes() {\n            return concurrentlyUpdatedLanes;\n        }\n        function enqueueUpdate$1(fiber, queue, update, lane) {\n            // Don't update the `childLanes` on the return path yet. If we already in\n            // the middle of rendering, wait until after it has completed.\n            concurrentQueues[concurrentQueuesIndex++] = fiber;\n            concurrentQueues[concurrentQueuesIndex++] = queue;\n            concurrentQueues[concurrentQueuesIndex++] = update;\n            concurrentQueues[concurrentQueuesIndex++] = lane;\n            concurrentlyUpdatedLanes = mergeLanes(concurrentlyUpdatedLanes, lane); // The fiber's `lane` field is used in some places to check if any work is\n            // scheduled, to perform an eager bailout, so we need to update it immediately.\n            // TODO: We should probably move this to the \"shared\" queue instead.\n            fiber.lanes = mergeLanes(fiber.lanes, lane);\n            var alternate = fiber.alternate;\n            if (alternate !== null) {\n                alternate.lanes = mergeLanes(alternate.lanes, lane);\n            }\n        }\n        function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {\n            var concurrentQueue = queue;\n            var concurrentUpdate = update;\n            enqueueUpdate$1(fiber, concurrentQueue, concurrentUpdate, lane);\n            return getRootForUpdatedFiber(fiber);\n        }\n        function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update) {\n            // This function is used to queue an update that doesn't need a rerender. The\n            // only reason we queue it is in case there's a subsequent higher priority\n            // update that causes it to be rebased.\n            var lane = NoLane;\n            var concurrentQueue = queue;\n            var concurrentUpdate = update;\n            enqueueUpdate$1(fiber, concurrentQueue, concurrentUpdate, lane); // Usually we can rely on the upcoming render phase to process the concurrent\n            // queue. However, since this is a bail out, we're not scheduling any work\n            // here. So the update we just queued will leak until something else happens\n            // to schedule work (if ever).\n            //\n            // Check if we're currently in the middle of rendering a tree, and if not,\n            // process the queue immediately to prevent a leak.\n            var isConcurrentlyRendering = getWorkInProgressRoot() !== null;\n            if (!isConcurrentlyRendering) {\n                finishQueueingConcurrentUpdates();\n            }\n        }\n        function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {\n            var concurrentQueue = queue;\n            var concurrentUpdate = update;\n            enqueueUpdate$1(fiber, concurrentQueue, concurrentUpdate, lane);\n            return getRootForUpdatedFiber(fiber);\n        }\n        function enqueueConcurrentRenderForLane(fiber, lane) {\n            enqueueUpdate$1(fiber, null, null, lane);\n            return getRootForUpdatedFiber(fiber);\n        } // Calling this function outside this module should only be done for backwards\n        // compatibility and should always be accompanied by a warning.\n        function unsafe_markUpdateLaneFromFiberToRoot(sourceFiber, lane) {\n            // NOTE: For Hyrum's Law reasons, if an infinite update loop is detected, it\n            // should throw before `markUpdateLaneFromFiberToRoot` is called. But this is\n            // undefined behavior and we can change it if we need to; it just so happens\n            // that, at the time of this writing, there's an internal product test that\n            // happens to rely on this.\n            var root = getRootForUpdatedFiber(sourceFiber);\n            markUpdateLaneFromFiberToRoot(sourceFiber, null, lane);\n            return root;\n        }\n        function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {\n            // Update the source fiber's lanes\n            sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\n            var alternate = sourceFiber.alternate;\n            if (alternate !== null) {\n                alternate.lanes = mergeLanes(alternate.lanes, lane);\n            } // Walk the parent path to the root and update the child lanes.\n            var isHidden = false;\n            var parent = sourceFiber.return;\n            var node = sourceFiber;\n            while(parent !== null){\n                parent.childLanes = mergeLanes(parent.childLanes, lane);\n                alternate = parent.alternate;\n                if (alternate !== null) {\n                    alternate.childLanes = mergeLanes(alternate.childLanes, lane);\n                }\n                if (parent.tag === OffscreenComponent) {\n                    // Check if this offscreen boundary is currently hidden.\n                    //\n                    // The instance may be null if the Offscreen parent was unmounted. Usually\n                    // the parent wouldn't be reachable in that case because we disconnect\n                    // fibers from the tree when they are deleted. However, there's a weird\n                    // edge case where setState is called on a fiber that was interrupted\n                    // before it ever mounted. Because it never mounts, it also never gets\n                    // deleted. Because it never gets deleted, its return pointer never gets\n                    // disconnected. Which means it may be attached to a deleted Offscreen\n                    // parent node. (This discovery suggests it may be better for memory usage\n                    // if we don't attach the `return` pointer until the commit phase, though\n                    // in order to do that we'd need some other way to track the return\n                    // pointer during the initial render, like on the stack.)\n                    //\n                    // This case is always accompanied by a warning, but we still need to\n                    // account for it. (There may be other cases that we haven't discovered,\n                    // too.)\n                    var offscreenInstance = parent.stateNode;\n                    if (offscreenInstance !== null && !(offscreenInstance._visibility & OffscreenVisible)) {\n                        isHidden = true;\n                    }\n                }\n                node = parent;\n                parent = parent.return;\n            }\n            if (isHidden && update !== null && node.tag === HostRoot) {\n                var root = node.stateNode;\n                markHiddenUpdate(root, update, lane);\n            }\n        }\n        function getRootForUpdatedFiber(sourceFiber) {\n            // TODO: We will detect and infinite update loop and throw even if this fiber\n            // has already unmounted. This isn't really necessary but it happens to be the\n            // current behavior we've used for several release cycles. Consider not\n            // performing this check if the updated fiber already unmounted, since it's\n            // not possible for that to cause an infinite update loop.\n            throwIfInfiniteUpdateLoopDetected(); // When a setState happens, we must ensure the root is scheduled. Because\n            // update queues do not have a backpointer to the root, the only way to do\n            // this currently is to walk up the return path. This used to not be a big\n            // deal because we would have to walk up the return path to set\n            // the `childLanes`, anyway, but now those two traversals happen at\n            // different times.\n            // TODO: Consider adding a `root` backpointer on the update queue.\n            detectUpdateOnUnmountedFiber(sourceFiber, sourceFiber);\n            var node = sourceFiber;\n            var parent = node.return;\n            while(parent !== null){\n                detectUpdateOnUnmountedFiber(sourceFiber, node);\n                node = parent;\n                parent = node.return;\n            }\n            return node.tag === HostRoot ? node.stateNode : null;\n        }\n        function detectUpdateOnUnmountedFiber(sourceFiber, parent) {\n            {\n                var alternate = parent.alternate;\n                if (alternate === null && (parent.flags & (Placement | Hydrating)) !== NoFlags$1) {\n                    warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n                }\n            }\n        }\n        // there's only a single root, but we do support multi root apps, hence this\n        // extra complexity. But this module is optimized for the single root case.\n        var firstScheduledRoot = null;\n        var lastScheduledRoot = null; // Used to prevent redundant mircotasks from being scheduled.\n        var didScheduleMicrotask = false; // `act` \"microtasks\" are scheduled on the `act` queue instead of an actual\n        // microtask, so we have to dedupe those separately. This wouldn't be an issue\n        // if we required all `act` calls to be awaited, which we might in the future.\n        var didScheduleMicrotask_act = false; // Used to quickly bail out of flushSync if there's no sync work to do.\n        var mightHavePendingSyncWork = false;\n        var isFlushingWork = false;\n        var currentEventTransitionLane = NoLane;\n        function ensureRootIsScheduled(root) {\n            // This function is called whenever a root receives an update. It does two\n            // things 1) it ensures the root is in the root schedule, and 2) it ensures\n            // there's a pending microtask to process the root schedule.\n            //\n            // Most of the actual scheduling logic does not happen until\n            // `scheduleTaskForRootDuringMicrotask` runs.\n            // Add the root to the schedule\n            if (root === lastScheduledRoot || root.next !== null) ;\n            else {\n                if (lastScheduledRoot === null) {\n                    firstScheduledRoot = lastScheduledRoot = root;\n                } else {\n                    lastScheduledRoot.next = root;\n                    lastScheduledRoot = root;\n                }\n            } // Any time a root received an update, we set this to true until the next time\n            // we process the schedule. If it's false, then we can quickly exit flushSync\n            // without consulting the schedule.\n            mightHavePendingSyncWork = true; // At the end of the current event, go through each of the roots and ensure\n            // there's a task scheduled for each one at the correct priority.\n            if (ReactSharedInternals.actQueue !== null) {\n                // We're inside an `act` scope.\n                if (!didScheduleMicrotask_act) {\n                    didScheduleMicrotask_act = true;\n                    scheduleImmediateTask(processRootScheduleInMicrotask);\n                }\n            } else {\n                if (!didScheduleMicrotask) {\n                    didScheduleMicrotask = true;\n                    scheduleImmediateTask(processRootScheduleInMicrotask);\n                }\n            }\n        }\n        function flushSyncWorkOnAllRoots() {\n            // This is allowed to be called synchronously, but the caller should check\n            // the execution context first.\n            flushSyncWorkAcrossRoots_impl(false);\n        }\n        function flushSyncWorkAcrossRoots_impl(onlyLegacy) {\n            if (isFlushingWork) {\n                // Prevent reentrancy.\n                // TODO: Is this overly defensive? The callers must check the execution\n                // context first regardless.\n                return;\n            }\n            if (!mightHavePendingSyncWork) {\n                // Fast path. There's no sync work to do.\n                return;\n            } // There may or may not be synchronous work scheduled. Let's check.\n            var didPerformSomeWork;\n            isFlushingWork = true;\n            do {\n                didPerformSomeWork = false;\n                var root = firstScheduledRoot;\n                while(root !== null){\n                    if (onlyLegacy && disableLegacyMode) ;\n                    else {\n                        var workInProgressRoot = getWorkInProgressRoot();\n                        var workInProgressRootRenderLanes = getWorkInProgressRootRenderLanes();\n                        var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n                        if (includesSyncLane(nextLanes)) {\n                            // This root has pending sync work. Flush it now.\n                            didPerformSomeWork = true;\n                            performSyncWorkOnRoot(root, nextLanes);\n                        }\n                    }\n                    root = root.next;\n                }\n            }while (didPerformSomeWork);\n            isFlushingWork = false;\n        }\n        function processRootScheduleInMicrotask() {\n            // This function is always called inside a microtask. It should never be\n            // called synchronously.\n            didScheduleMicrotask = false;\n            {\n                didScheduleMicrotask_act = false;\n            }\n            mightHavePendingSyncWork = false;\n            var currentTime = now$1();\n            var prev = null;\n            var root = firstScheduledRoot;\n            while(root !== null){\n                var next = root.next;\n                if (currentEventTransitionLane !== NoLane && shouldAttemptEagerTransition()) {\n                    // A transition was scheduled during an event, but we're going to try to\n                    // render it synchronously anyway. We do this during a popstate event to\n                    // preserve the scroll position of the previous page.\n                    upgradePendingLaneToSync(root, currentEventTransitionLane);\n                }\n                var nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);\n                if (nextLanes === NoLane) {\n                    // This root has no more pending work. Remove it from the schedule. To\n                    // guard against subtle reentrancy bugs, this microtask is the only place\n                    // we do this — you can add roots to the schedule whenever, but you can\n                    // only remove them here.\n                    // Null this out so we know it's been removed from the schedule.\n                    root.next = null;\n                    if (prev === null) {\n                        // This is the new head of the list\n                        firstScheduledRoot = next;\n                    } else {\n                        prev.next = next;\n                    }\n                    if (next === null) {\n                        // This is the new tail of the list\n                        lastScheduledRoot = prev;\n                    }\n                } else {\n                    // This root still has work. Keep it in the list.\n                    prev = root;\n                    if (includesSyncLane(nextLanes)) {\n                        mightHavePendingSyncWork = true;\n                    }\n                }\n                root = next;\n            }\n            currentEventTransitionLane = NoLane; // At the end of the microtask, flush any pending synchronous work. This has\n            // to come at the end, because it does actual rendering work that might throw.\n            flushSyncWorkOnAllRoots();\n        }\n        function scheduleTaskForRootDuringMicrotask(root, currentTime) {\n            // This function is always called inside a microtask, or at the very end of a\n            // rendering task right before we yield to the main thread. It should never be\n            // called synchronously.\n            //\n            // TODO: Unless enableDeferRootSchedulingToMicrotask is off. We need to land\n            // that ASAP to unblock additional features we have planned.\n            //\n            // This function also never performs React work synchronously; it should\n            // only schedule work to be performed later, in a separate task or microtask.\n            // Check if any lanes are being starved by other work. If so, mark them as\n            // expired so we know to work on those next.\n            markStarvedLanesAsExpired(root, currentTime); // Determine the next lanes to work on, and their priority.\n            var workInProgressRoot = getWorkInProgressRoot();\n            var workInProgressRootRenderLanes = getWorkInProgressRootRenderLanes();\n            var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n            var existingCallbackNode = root.callbackNode;\n            if (nextLanes === NoLanes || // If this root is currently suspended and waiting for data to resolve, don't\n            // schedule a task to render it. We'll either wait for a ping, or wait to\n            // receive an update.\n            //\n            // Suspended render phase\n            root === workInProgressRoot && isWorkLoopSuspendedOnData() || // Suspended commit phase\n            root.cancelPendingCommit !== null) {\n                // Fast path: There's nothing to work on.\n                if (existingCallbackNode !== null) {\n                    cancelCallback(existingCallbackNode);\n                }\n                root.callbackNode = null;\n                root.callbackPriority = NoLane;\n                return NoLane;\n            } // Schedule a new callback in the host environment.\n            if (includesSyncLane(nextLanes)) {\n                // Synchronous work is always flushed at the end of the microtask, so we\n                // don't need to schedule an additional task.\n                if (existingCallbackNode !== null) {\n                    cancelCallback(existingCallbackNode);\n                }\n                root.callbackPriority = SyncLane;\n                root.callbackNode = null;\n                return SyncLane;\n            } else {\n                // We use the highest priority lane to represent the priority of the callback.\n                var existingCallbackPriority = root.callbackPriority;\n                var newCallbackPriority = getHighestPriorityLane(nextLanes);\n                if (newCallbackPriority === existingCallbackPriority && // Special case related to `act`. If the currently scheduled task is a\n                // Scheduler task, rather than an `act` task, cancel it and re-schedule\n                // on the `act` queue.\n                !(ReactSharedInternals.actQueue !== null && existingCallbackNode !== fakeActCallbackNode$1)) {\n                    // The priority hasn't changed. We can reuse the existing task.\n                    return newCallbackPriority;\n                } else {\n                    // Cancel the existing callback. We'll schedule a new one below.\n                    cancelCallback(existingCallbackNode);\n                }\n                var schedulerPriorityLevel;\n                switch(lanesToEventPriority(nextLanes)){\n                    case DiscreteEventPriority:\n                        schedulerPriorityLevel = ImmediatePriority;\n                        break;\n                    case ContinuousEventPriority:\n                        schedulerPriorityLevel = UserBlockingPriority;\n                        break;\n                    case DefaultEventPriority:\n                        schedulerPriorityLevel = NormalPriority$1;\n                        break;\n                    case IdleEventPriority:\n                        schedulerPriorityLevel = IdlePriority;\n                        break;\n                    default:\n                        schedulerPriorityLevel = NormalPriority$1;\n                        break;\n                }\n                var newCallbackNode = scheduleCallback$2(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root));\n                root.callbackPriority = newCallbackPriority;\n                root.callbackNode = newCallbackNode;\n                return newCallbackPriority;\n            }\n        }\n        function getContinuationForRoot(root, originalCallbackNode) {\n            // This is called at the end of `performConcurrentWorkOnRoot` to determine\n            // if we need to schedule a continuation task.\n            //\n            // Usually `scheduleTaskForRootDuringMicrotask` only runs inside a microtask;\n            // however, since most of the logic for determining if we need a continuation\n            // versus a new task is the same, we cheat a bit and call it here. This is\n            // only safe to do because we know we're at the end of the browser task.\n            // So although it's not an actual microtask, it might as well be.\n            scheduleTaskForRootDuringMicrotask(root, now$1());\n            if (root.callbackNode === originalCallbackNode) {\n                // The task node scheduled for this root is the same one that's\n                // currently executed. Need to return a continuation.\n                return performConcurrentWorkOnRoot.bind(null, root);\n            }\n            return null;\n        }\n        var fakeActCallbackNode$1 = {};\n        function scheduleCallback$2(priorityLevel, callback) {\n            if (ReactSharedInternals.actQueue !== null) {\n                // Special case: We're inside an `act` scope (a testing utility).\n                // Instead of scheduling work in the host environment, add it to a\n                // fake internal queue that's managed by the `act` implementation.\n                ReactSharedInternals.actQueue.push(callback);\n                return fakeActCallbackNode$1;\n            } else {\n                return scheduleCallback$3(priorityLevel, callback);\n            }\n        }\n        function cancelCallback(callbackNode) {\n            if (callbackNode === fakeActCallbackNode$1) ;\n            else if (callbackNode !== null) {\n                cancelCallback$1(callbackNode);\n            }\n        }\n        function scheduleImmediateTask(cb) {\n            if (ReactSharedInternals.actQueue !== null) {\n                // Special case: Inside an `act` scope, we push microtasks to the fake `act`\n                // callback queue. This is because we currently support calling `act`\n                // without awaiting the result. The plan is to deprecate that, and require\n                // that you always await the result so that the microtasks have a chance to\n                // run. But it hasn't happened yet.\n                ReactSharedInternals.actQueue.push(function() {\n                    cb();\n                    return null;\n                });\n            } // TODO: Can we land supportsMicrotasks? Which environments don't support it?\n            // Alternatively, can we move this check to the host config?\n            if (supportsMicrotasks) {\n                scheduleMicrotask(function() {\n                    // In Safari, appending an iframe forces microtasks to run.\n                    // https://github.com/facebook/react/issues/22459\n                    // We don't support running callbacks in the middle of render\n                    // or commit so we need to check against that.\n                    var executionContext = getExecutionContext();\n                    if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                        // Note that this would still prematurely flush the callbacks\n                        // if this happens outside render or commit phase (e.g. in an event).\n                        // Intentionally using a macrotask instead of a microtask here. This is\n                        // wrong semantically but it prevents an infinite loop. The bug is\n                        // Safari's, not ours, so we just do our best to not crash even though\n                        // the behavior isn't completely correct.\n                        scheduleCallback$3(ImmediatePriority, cb);\n                        return;\n                    }\n                    cb();\n                });\n            } else {\n                // If microtasks are not supported, use Scheduler.\n                scheduleCallback$3(ImmediatePriority, cb);\n            }\n        }\n        function requestTransitionLane(// check that it's inside a transition before calling this function.\n        // TODO: Make this non-nullable. Requires a tweak to useOptimistic.\n        transition) {\n            // The algorithm for assigning an update to a lane should be stable for all\n            // updates at the same priority within the same event. To do this, the\n            // inputs to the algorithm must be the same.\n            //\n            // The trick we use is to cache the first of each of these inputs within an\n            // event. Then reset the cached values once we can be sure the event is\n            // over. Our heuristic for that is whenever we enter a concurrent work loop.\n            if (currentEventTransitionLane === NoLane) {\n                // All transitions within the same event are assigned the same lane.\n                currentEventTransitionLane = claimNextTransitionLane();\n            }\n            return currentEventTransitionLane;\n        }\n        // transition updates that occur while the async action is still in progress\n        // are treated as part of the action.\n        //\n        // The ideal behavior would be to treat each async function as an independent\n        // action. However, without a mechanism like AsyncContext, we can't tell which\n        // action an update corresponds to. So instead, we entangle them all into one.\n        // The listeners to notify once the entangled scope completes.\n        var currentEntangledListeners = null; // The number of pending async actions in the entangled scope.\n        var currentEntangledPendingCount = 0; // The transition lane shared by all updates in the entangled scope.\n        var currentEntangledLane = NoLane; // A thenable that resolves when the entangled scope completes. It does not\n        // resolve to a particular value because it's only used for suspending the UI\n        // until the async action scope has completed.\n        var currentEntangledActionThenable = null;\n        function entangleAsyncAction(transition, thenable) {\n            // `thenable` is the return value of the async action scope function. Create\n            // a combined thenable that resolves once every entangled scope function\n            // has finished.\n            if (currentEntangledListeners === null) {\n                // There's no outer async action scope. Create a new one.\n                var entangledListeners = currentEntangledListeners = [];\n                currentEntangledPendingCount = 0;\n                currentEntangledLane = requestTransitionLane();\n                var entangledThenable = {\n                    status: 'pending',\n                    value: undefined,\n                    then: function(resolve) {\n                        entangledListeners.push(resolve);\n                    }\n                };\n                currentEntangledActionThenable = entangledThenable;\n            }\n            currentEntangledPendingCount++;\n            thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);\n            return thenable;\n        }\n        function pingEngtangledActionScope() {\n            if (currentEntangledListeners !== null && --currentEntangledPendingCount === 0) {\n                // All the actions have finished. Close the entangled async action scope\n                // and notify all the listeners.\n                if (currentEntangledActionThenable !== null) {\n                    var fulfilledThenable = currentEntangledActionThenable;\n                    fulfilledThenable.status = 'fulfilled';\n                }\n                var listeners = currentEntangledListeners;\n                currentEntangledListeners = null;\n                currentEntangledLane = NoLane;\n                currentEntangledActionThenable = null;\n                for(var i = 0; i < listeners.length; i++){\n                    var listener = listeners[i];\n                    listener();\n                }\n            }\n        }\n        function chainThenableValue(thenable, result) {\n            // Equivalent to: Promise.resolve(thenable).then(() => result), except we can\n            // cheat a bit since we know that that this thenable is only ever consumed\n            // by React.\n            //\n            // We don't technically require promise support on the client yet, hence this\n            // extra code.\n            var listeners = [];\n            var thenableWithOverride = {\n                status: 'pending',\n                value: null,\n                reason: null,\n                then: function(resolve) {\n                    listeners.push(resolve);\n                }\n            };\n            thenable.then(function(value) {\n                var fulfilledThenable = thenableWithOverride;\n                fulfilledThenable.status = 'fulfilled';\n                fulfilledThenable.value = result;\n                for(var i = 0; i < listeners.length; i++){\n                    var listener = listeners[i];\n                    listener(result);\n                }\n            }, function(error) {\n                var rejectedThenable = thenableWithOverride;\n                rejectedThenable.status = 'rejected';\n                rejectedThenable.reason = error;\n                for(var i = 0; i < listeners.length; i++){\n                    var listener = listeners[i]; // This is a perf hack where we call the `onFulfill` ping function\n                    // instead of `onReject`, because we know that React is the only\n                    // consumer of these promises, and it passes the same listener to both.\n                    // We also know that it will read the error directly off the\n                    // `.reason` field.\n                    listener(undefined);\n                }\n            });\n            return thenableWithOverride;\n        }\n        function peekEntangledActionLane() {\n            return currentEntangledLane;\n        }\n        function peekEntangledActionThenable() {\n            return currentEntangledActionThenable;\n        }\n        var UpdateState = 0;\n        var ReplaceState = 1;\n        var ForceUpdate = 2;\n        var CaptureUpdate = 3; // Global state that is reset at the beginning of calling `processUpdateQueue`.\n        // It should only be read right after calling `processUpdateQueue`, via\n        // `checkHasForceUpdateAfterProcessing`.\n        var hasForceUpdate = false;\n        var didWarnUpdateInsideUpdate;\n        var currentlyProcessingQueue;\n        {\n            didWarnUpdateInsideUpdate = false;\n            currentlyProcessingQueue = null;\n        }\n        function initializeUpdateQueue(fiber) {\n            var queue = {\n                baseState: fiber.memoizedState,\n                firstBaseUpdate: null,\n                lastBaseUpdate: null,\n                shared: {\n                    pending: null,\n                    lanes: NoLanes,\n                    hiddenCallbacks: null\n                },\n                callbacks: null\n            };\n            fiber.updateQueue = queue;\n        }\n        function cloneUpdateQueue(current, workInProgress) {\n            // Clone the update queue from current. Unless it's already a clone.\n            var queue = workInProgress.updateQueue;\n            var currentQueue = current.updateQueue;\n            if (queue === currentQueue) {\n                var clone = {\n                    baseState: currentQueue.baseState,\n                    firstBaseUpdate: currentQueue.firstBaseUpdate,\n                    lastBaseUpdate: currentQueue.lastBaseUpdate,\n                    shared: currentQueue.shared,\n                    callbacks: null\n                };\n                workInProgress.updateQueue = clone;\n            }\n        }\n        function createUpdate(lane) {\n            var update = {\n                lane: lane,\n                tag: UpdateState,\n                payload: null,\n                callback: null,\n                next: null\n            };\n            return update;\n        }\n        function enqueueUpdate(fiber, update, lane) {\n            var updateQueue = fiber.updateQueue;\n            if (updateQueue === null) {\n                // Only occurs if the fiber has been unmounted.\n                return null;\n            }\n            var sharedQueue = updateQueue.shared;\n            {\n                if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {\n                    var componentName = getComponentNameFromFiber(fiber);\n                    error('An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.\\n\\nPlease update the following component: %s', componentName);\n                    didWarnUpdateInsideUpdate = true;\n                }\n            }\n            if (isUnsafeClassRenderPhaseUpdate()) {\n                // This is an unsafe render phase update. Add directly to the update\n                // queue so we can process it immediately during the current render.\n                var pending = sharedQueue.pending;\n                if (pending === null) {\n                    // This is the first update. Create a circular list.\n                    update.next = update;\n                } else {\n                    update.next = pending.next;\n                    pending.next = update;\n                }\n                sharedQueue.pending = update; // Update the childLanes even though we're most likely already rendering\n                // this fiber. This is for backwards compatibility in the case where you\n                // update a different component during render phase than the one that is\n                // currently renderings (a pattern that is accompanied by a warning).\n                return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);\n            } else {\n                return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);\n            }\n        }\n        function entangleTransitions(root, fiber, lane) {\n            var updateQueue = fiber.updateQueue;\n            if (updateQueue === null) {\n                // Only occurs if the fiber has been unmounted.\n                return;\n            }\n            var sharedQueue = updateQueue.shared;\n            if (isTransitionLane(lane)) {\n                var queueLanes = sharedQueue.lanes; // If any entangled lanes are no longer pending on the root, then they must\n                // have finished. We can remove them from the shared queue, which represents\n                // a superset of the actually pending lanes. In some cases we may entangle\n                // more than we need to, but that's OK. In fact it's worse if we *don't*\n                // entangle when we should.\n                queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.\n                var newQueueLanes = mergeLanes(queueLanes, lane);\n                sharedQueue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if\n                // the lane finished since the last time we entangled it. So we need to\n                // entangle it again, just to be sure.\n                markRootEntangled(root, newQueueLanes);\n            }\n        }\n        function enqueueCapturedUpdate(workInProgress, capturedUpdate) {\n            // Captured updates are updates that are thrown by a child during the render\n            // phase. They should be discarded if the render is aborted. Therefore,\n            // we should only put them on the work-in-progress queue, not the current one.\n            var queue = workInProgress.updateQueue; // Check if the work-in-progress queue is a clone.\n            var current = workInProgress.alternate;\n            if (current !== null) {\n                var currentQueue = current.updateQueue;\n                if (queue === currentQueue) {\n                    // The work-in-progress queue is the same as current. This happens when\n                    // we bail out on a parent fiber that then captures an error thrown by\n                    // a child. Since we want to append the update only to the work-in\n                    // -progress queue, we need to clone the updates. We usually clone during\n                    // processUpdateQueue, but that didn't happen in this case because we\n                    // skipped over the parent when we bailed out.\n                    var newFirst = null;\n                    var newLast = null;\n                    var firstBaseUpdate = queue.firstBaseUpdate;\n                    if (firstBaseUpdate !== null) {\n                        // Loop through the updates and clone them.\n                        var update = firstBaseUpdate;\n                        do {\n                            var clone = {\n                                lane: update.lane,\n                                tag: update.tag,\n                                payload: update.payload,\n                                // When this update is rebased, we should not fire its\n                                // callback again.\n                                callback: null,\n                                next: null\n                            };\n                            if (newLast === null) {\n                                newFirst = newLast = clone;\n                            } else {\n                                newLast.next = clone;\n                                newLast = clone;\n                            } // $FlowFixMe[incompatible-type] we bail out when we get a null\n                            update = update.next;\n                        }while (update !== null); // Append the captured update the end of the cloned list.\n                        if (newLast === null) {\n                            newFirst = newLast = capturedUpdate;\n                        } else {\n                            newLast.next = capturedUpdate;\n                            newLast = capturedUpdate;\n                        }\n                    } else {\n                        // There are no base updates.\n                        newFirst = newLast = capturedUpdate;\n                    }\n                    queue = {\n                        baseState: currentQueue.baseState,\n                        firstBaseUpdate: newFirst,\n                        lastBaseUpdate: newLast,\n                        shared: currentQueue.shared,\n                        callbacks: currentQueue.callbacks\n                    };\n                    workInProgress.updateQueue = queue;\n                    return;\n                }\n            } // Append the update to the end of the list.\n            var lastBaseUpdate = queue.lastBaseUpdate;\n            if (lastBaseUpdate === null) {\n                queue.firstBaseUpdate = capturedUpdate;\n            } else {\n                lastBaseUpdate.next = capturedUpdate;\n            }\n            queue.lastBaseUpdate = capturedUpdate;\n        }\n        function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {\n            switch(update.tag){\n                case ReplaceState:\n                    {\n                        var payload = update.payload;\n                        if (typeof payload === 'function') {\n                            // Updater function\n                            {\n                                enterDisallowedContextReadInDEV();\n                            }\n                            var nextState = payload.call(instance, prevState, nextProps);\n                            {\n                                if (workInProgress.mode & StrictLegacyMode) {\n                                    setIsStrictModeForDevtools(true);\n                                    try {\n                                        payload.call(instance, prevState, nextProps);\n                                    } finally{\n                                        setIsStrictModeForDevtools(false);\n                                    }\n                                }\n                                exitDisallowedContextReadInDEV();\n                            }\n                            return nextState;\n                        } // State object\n                        return payload;\n                    }\n                case CaptureUpdate:\n                    {\n                        workInProgress.flags = workInProgress.flags & ~ShouldCapture | DidCapture;\n                    }\n                // Intentional fallthrough\n                case UpdateState:\n                    {\n                        var _payload = update.payload;\n                        var partialState;\n                        if (typeof _payload === 'function') {\n                            // Updater function\n                            {\n                                enterDisallowedContextReadInDEV();\n                            }\n                            partialState = _payload.call(instance, prevState, nextProps);\n                            {\n                                if (workInProgress.mode & StrictLegacyMode) {\n                                    setIsStrictModeForDevtools(true);\n                                    try {\n                                        _payload.call(instance, prevState, nextProps);\n                                    } finally{\n                                        setIsStrictModeForDevtools(false);\n                                    }\n                                }\n                                exitDisallowedContextReadInDEV();\n                            }\n                        } else {\n                            // Partial state object\n                            partialState = _payload;\n                        }\n                        if (partialState === null || partialState === undefined) {\n                            // Null and undefined are treated as no-ops.\n                            return prevState;\n                        } // Merge the partial state and the previous state.\n                        return assign({}, prevState, partialState);\n                    }\n                case ForceUpdate:\n                    {\n                        hasForceUpdate = true;\n                        return prevState;\n                    }\n            }\n            return prevState;\n        }\n        var didReadFromEntangledAsyncAction = false; // Each call to processUpdateQueue should be accompanied by a call to this. It's\n        // only in a separate function because in updateHostRoot, it must happen after\n        // all the context stacks have been pushed to, to prevent a stack mismatch. A\n        // bit unfortunate.\n        function suspendIfUpdateReadFromEntangledAsyncAction() {\n            // Check if this update is part of a pending async action. If so, we'll\n            // need to suspend until the action has finished, so that it's batched\n            // together with future updates in the same action.\n            // TODO: Once we support hooks inside useMemo (or an equivalent\n            // memoization boundary like Forget), hoist this logic so that it only\n            // suspends if the memo boundary produces a new value.\n            if (didReadFromEntangledAsyncAction) {\n                var entangledActionThenable = peekEntangledActionThenable();\n                if (entangledActionThenable !== null) {\n                    // TODO: Instead of the throwing the thenable directly, throw a\n                    // special object like `use` does so we can detect if it's captured\n                    // by userspace.\n                    throw entangledActionThenable;\n                }\n            }\n        }\n        function processUpdateQueue(workInProgress, props, instance, renderLanes) {\n            didReadFromEntangledAsyncAction = false; // This is always non-null on a ClassComponent or HostRoot\n            var queue = workInProgress.updateQueue;\n            hasForceUpdate = false;\n            {\n                currentlyProcessingQueue = queue.shared;\n            }\n            var firstBaseUpdate = queue.firstBaseUpdate;\n            var lastBaseUpdate = queue.lastBaseUpdate; // Check if there are pending updates. If so, transfer them to the base queue.\n            var pendingQueue = queue.shared.pending;\n            if (pendingQueue !== null) {\n                queue.shared.pending = null; // The pending queue is circular. Disconnect the pointer between first\n                // and last so that it's non-circular.\n                var lastPendingUpdate = pendingQueue;\n                var firstPendingUpdate = lastPendingUpdate.next;\n                lastPendingUpdate.next = null; // Append pending updates to base queue\n                if (lastBaseUpdate === null) {\n                    firstBaseUpdate = firstPendingUpdate;\n                } else {\n                    lastBaseUpdate.next = firstPendingUpdate;\n                }\n                lastBaseUpdate = lastPendingUpdate; // If there's a current queue, and it's different from the base queue, then\n                // we need to transfer the updates to that queue, too. Because the base\n                // queue is a singly-linked list with no cycles, we can append to both\n                // lists and take advantage of structural sharing.\n                // TODO: Pass `current` as argument\n                var current = workInProgress.alternate;\n                if (current !== null) {\n                    // This is always non-null on a ClassComponent or HostRoot\n                    var currentQueue = current.updateQueue;\n                    var currentLastBaseUpdate = currentQueue.lastBaseUpdate;\n                    if (currentLastBaseUpdate !== lastBaseUpdate) {\n                        if (currentLastBaseUpdate === null) {\n                            currentQueue.firstBaseUpdate = firstPendingUpdate;\n                        } else {\n                            currentLastBaseUpdate.next = firstPendingUpdate;\n                        }\n                        currentQueue.lastBaseUpdate = lastPendingUpdate;\n                    }\n                }\n            } // These values may change as we process the queue.\n            if (firstBaseUpdate !== null) {\n                // Iterate through the list of updates to compute the result.\n                var newState = queue.baseState; // TODO: Don't need to accumulate this. Instead, we can remove renderLanes\n                // from the original lanes.\n                var newLanes = NoLanes;\n                var newBaseState = null;\n                var newFirstBaseUpdate = null;\n                var newLastBaseUpdate = null;\n                var update = firstBaseUpdate;\n                do {\n                    // An extra OffscreenLane bit is added to updates that were made to\n                    // a hidden tree, so that we can distinguish them from updates that were\n                    // already there when the tree was hidden.\n                    var updateLane = removeLanes(update.lane, OffscreenLane);\n                    var isHiddenUpdate = updateLane !== update.lane; // Check if this update was made while the tree was hidden. If so, then\n                    // it's not a \"base\" update and we should disregard the extra base lanes\n                    // that were added to renderLanes when we entered the Offscreen tree.\n                    var shouldSkipUpdate = isHiddenUpdate ? !isSubsetOfLanes(getWorkInProgressRootRenderLanes(), updateLane) : !isSubsetOfLanes(renderLanes, updateLane);\n                    if (shouldSkipUpdate) {\n                        // Priority is insufficient. Skip this update. If this is the first\n                        // skipped update, the previous update/state is the new base\n                        // update/state.\n                        var clone = {\n                            lane: updateLane,\n                            tag: update.tag,\n                            payload: update.payload,\n                            callback: update.callback,\n                            next: null\n                        };\n                        if (newLastBaseUpdate === null) {\n                            newFirstBaseUpdate = newLastBaseUpdate = clone;\n                            newBaseState = newState;\n                        } else {\n                            newLastBaseUpdate = newLastBaseUpdate.next = clone;\n                        } // Update the remaining priority in the queue.\n                        newLanes = mergeLanes(newLanes, updateLane);\n                    } else {\n                        // This update does have sufficient priority.\n                        // Check if this update is part of a pending async action. If so,\n                        // we'll need to suspend until the action has finished, so that it's\n                        // batched together with future updates in the same action.\n                        if (updateLane !== NoLane && updateLane === peekEntangledActionLane()) {\n                            didReadFromEntangledAsyncAction = true;\n                        }\n                        if (newLastBaseUpdate !== null) {\n                            var _clone = {\n                                // This update is going to be committed so we never want uncommit\n                                // it. Using NoLane works because 0 is a subset of all bitmasks, so\n                                // this will never be skipped by the check above.\n                                lane: NoLane,\n                                tag: update.tag,\n                                payload: update.payload,\n                                // When this update is rebased, we should not fire its\n                                // callback again.\n                                callback: null,\n                                next: null\n                            };\n                            newLastBaseUpdate = newLastBaseUpdate.next = _clone;\n                        } // Process this update.\n                        newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance);\n                        var callback = update.callback;\n                        if (callback !== null) {\n                            workInProgress.flags |= Callback;\n                            if (isHiddenUpdate) {\n                                workInProgress.flags |= Visibility;\n                            }\n                            var callbacks = queue.callbacks;\n                            if (callbacks === null) {\n                                queue.callbacks = [\n                                    callback\n                                ];\n                            } else {\n                                callbacks.push(callback);\n                            }\n                        }\n                    } // $FlowFixMe[incompatible-type] we bail out when we get a null\n                    update = update.next;\n                    if (update === null) {\n                        pendingQueue = queue.shared.pending;\n                        if (pendingQueue === null) {\n                            break;\n                        } else {\n                            // An update was scheduled from inside a reducer. Add the new\n                            // pending updates to the end of the list and keep processing.\n                            var _lastPendingUpdate = pendingQueue; // Intentionally unsound. Pending updates form a circular list, but we\n                            // unravel them when transferring them to the base queue.\n                            var _firstPendingUpdate = _lastPendingUpdate.next;\n                            _lastPendingUpdate.next = null;\n                            update = _firstPendingUpdate;\n                            queue.lastBaseUpdate = _lastPendingUpdate;\n                            queue.shared.pending = null;\n                        }\n                    }\n                }while (true);\n                if (newLastBaseUpdate === null) {\n                    newBaseState = newState;\n                }\n                queue.baseState = newBaseState;\n                queue.firstBaseUpdate = newFirstBaseUpdate;\n                queue.lastBaseUpdate = newLastBaseUpdate;\n                if (firstBaseUpdate === null) {\n                    // `queue.lanes` is used for entangling transitions. We can set it back to\n                    // zero once the queue is empty.\n                    queue.shared.lanes = NoLanes;\n                } // Set the remaining expiration time to be whatever is remaining in the queue.\n                // This should be fine because the only two other things that contribute to\n                // expiration time are props and context. We're already in the middle of the\n                // begin phase by the time we start processing the queue, so we've already\n                // dealt with the props. Context in components that specify\n                // shouldComponentUpdate is tricky; but we'll have to account for\n                // that regardless.\n                markSkippedUpdateLanes(newLanes);\n                workInProgress.lanes = newLanes;\n                workInProgress.memoizedState = newState;\n            }\n            {\n                currentlyProcessingQueue = null;\n            }\n        }\n        function callCallback(callback, context) {\n            if (typeof callback !== 'function') {\n                throw new Error('Invalid argument passed as callback. Expected a function. Instead ' + (\"received: \" + callback));\n            }\n            callback.call(context);\n        }\n        function resetHasForceUpdateBeforeProcessing() {\n            hasForceUpdate = false;\n        }\n        function checkHasForceUpdateAfterProcessing() {\n            return hasForceUpdate;\n        }\n        function deferHiddenCallbacks(updateQueue) {\n            // When an update finishes on a hidden component, its callback should not\n            // be fired until/unless the component is made visible again. Stash the\n            // callback on the shared queue object so it can be fired later.\n            var newHiddenCallbacks = updateQueue.callbacks;\n            if (newHiddenCallbacks !== null) {\n                var existingHiddenCallbacks = updateQueue.shared.hiddenCallbacks;\n                if (existingHiddenCallbacks === null) {\n                    updateQueue.shared.hiddenCallbacks = newHiddenCallbacks;\n                } else {\n                    updateQueue.shared.hiddenCallbacks = existingHiddenCallbacks.concat(newHiddenCallbacks);\n                }\n            }\n        }\n        function commitHiddenCallbacks(updateQueue, context) {\n            // This component is switching from hidden -> visible. Commit any callbacks\n            // that were previously deferred.\n            var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;\n            if (hiddenCallbacks !== null) {\n                updateQueue.shared.hiddenCallbacks = null;\n                for(var i = 0; i < hiddenCallbacks.length; i++){\n                    var callback = hiddenCallbacks[i];\n                    callCallback(callback, context);\n                }\n            }\n        }\n        function commitCallbacks(updateQueue, context) {\n            var callbacks = updateQueue.callbacks;\n            if (callbacks !== null) {\n                updateQueue.callbacks = null;\n                for(var i = 0; i < callbacks.length; i++){\n                    var callback = callbacks[i];\n                    callCallback(callback, context);\n                }\n            }\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        /**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */ function shallowEqual(objA, objB) {\n            if (objectIs(objA, objB)) {\n                return true;\n            }\n            if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n                return false;\n            }\n            var keysA = Object.keys(objA);\n            var keysB = Object.keys(objB);\n            if (keysA.length !== keysB.length) {\n                return false;\n            } // Test for A's keys different from B.\n            for(var i = 0; i < keysA.length; i++){\n                var currentKey = keysA[i];\n                if (!hasOwnProperty.call(objB, currentKey) || // $FlowFixMe[incompatible-use] lost refinement of `objB`\n                !objectIs(objA[currentKey], objB[currentKey])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        var ReactStrictModeWarnings = {\n            recordUnsafeLifecycleWarnings: function(fiber, instance) {},\n            flushPendingUnsafeLifecycleWarnings: function() {},\n            recordLegacyContextWarning: function(fiber, instance) {},\n            flushLegacyContextWarning: function() {},\n            discardPendingWarnings: function() {}\n        };\n        {\n            var findStrictRoot = function(fiber) {\n                var maybeStrictRoot = null;\n                var node = fiber;\n                while(node !== null){\n                    if (node.mode & StrictLegacyMode) {\n                        maybeStrictRoot = node;\n                    }\n                    node = node.return;\n                }\n                return maybeStrictRoot;\n            };\n            var setToSortedString = function(set) {\n                var array = [];\n                set.forEach(function(value) {\n                    array.push(value);\n                });\n                return array.sort().join(', ');\n            };\n            var pendingComponentWillMountWarnings = [];\n            var pendingUNSAFE_ComponentWillMountWarnings = [];\n            var pendingComponentWillReceivePropsWarnings = [];\n            var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n            var pendingComponentWillUpdateWarnings = [];\n            var pendingUNSAFE_ComponentWillUpdateWarnings = []; // Tracks components we have already warned about.\n            var didWarnAboutUnsafeLifecycles = new Set();\n            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {\n                // Dedupe strategy: Warn once per component.\n                if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {\n                    return;\n                }\n                if (typeof instance.componentWillMount === 'function' && // Don't warn about react-lifecycles-compat polyfilled components.\n                instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                    pendingComponentWillMountWarnings.push(fiber);\n                }\n                if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === 'function') {\n                    pendingUNSAFE_ComponentWillMountWarnings.push(fiber);\n                }\n                if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n                    pendingComponentWillReceivePropsWarnings.push(fiber);\n                }\n                if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n                    pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);\n                }\n                if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n                    pendingComponentWillUpdateWarnings.push(fiber);\n                }\n                if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === 'function') {\n                    pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);\n                }\n            };\n            ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {\n                // We do an initial pass to gather component names\n                var componentWillMountUniqueNames = new Set();\n                if (pendingComponentWillMountWarnings.length > 0) {\n                    pendingComponentWillMountWarnings.forEach(function(fiber) {\n                        componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingComponentWillMountWarnings = [];\n                }\n                var UNSAFE_componentWillMountUniqueNames = new Set();\n                if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {\n                    pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {\n                        UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingUNSAFE_ComponentWillMountWarnings = [];\n                }\n                var componentWillReceivePropsUniqueNames = new Set();\n                if (pendingComponentWillReceivePropsWarnings.length > 0) {\n                    pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {\n                        componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingComponentWillReceivePropsWarnings = [];\n                }\n                var UNSAFE_componentWillReceivePropsUniqueNames = new Set();\n                if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {\n                    pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {\n                        UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n                }\n                var componentWillUpdateUniqueNames = new Set();\n                if (pendingComponentWillUpdateWarnings.length > 0) {\n                    pendingComponentWillUpdateWarnings.forEach(function(fiber) {\n                        componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingComponentWillUpdateWarnings = [];\n                }\n                var UNSAFE_componentWillUpdateUniqueNames = new Set();\n                if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {\n                    pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {\n                        UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingUNSAFE_ComponentWillUpdateWarnings = [];\n                } // Finally, we flush all the warnings\n                // UNSAFE_ ones before the deprecated ones, since they'll be 'louder'\n                if (UNSAFE_componentWillMountUniqueNames.size > 0) {\n                    var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);\n                    error('Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. ' + 'See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n' + '\\nPlease update the following components: %s', sortedNames);\n                }\n                if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {\n                    var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);\n                    error('Using UNSAFE_componentWillReceiveProps in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + \"* If you're updating state whenever props change, \" + 'refactor your code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\\n' + '\\nPlease update the following components: %s', _sortedNames);\n                }\n                if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {\n                    var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);\n                    error('Using UNSAFE_componentWillUpdate in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + '\\nPlease update the following components: %s', _sortedNames2);\n                }\n                if (componentWillMountUniqueNames.size > 0) {\n                    var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);\n                    warn('componentWillMount has been renamed, and is not recommended for use. ' + 'See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n' + '* Rename componentWillMount to UNSAFE_componentWillMount to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n' + '\\nPlease update the following components: %s', _sortedNames3);\n                }\n                if (componentWillReceivePropsUniqueNames.size > 0) {\n                    var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);\n                    warn('componentWillReceiveProps has been renamed, and is not recommended for use. ' + 'See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + \"* If you're updating state whenever props change, refactor your \" + 'code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\\n' + '* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n' + '\\nPlease update the following components: %s', _sortedNames4);\n                }\n                if (componentWillUpdateUniqueNames.size > 0) {\n                    var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);\n                    warn('componentWillUpdate has been renamed, and is not recommended for use. ' + 'See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + '* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n' + '\\nPlease update the following components: %s', _sortedNames5);\n                }\n            };\n            var pendingLegacyContextWarning = new Map(); // Tracks components we have already warned about.\n            var didWarnAboutLegacyContext = new Set();\n            ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {\n                var strictRoot = findStrictRoot(fiber);\n                if (strictRoot === null) {\n                    error('Expected to find a StrictMode component in a strict mode tree. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n                    return;\n                } // Dedup strategy: Warn once per component.\n                if (didWarnAboutLegacyContext.has(fiber.type)) {\n                    return;\n                }\n                var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);\n                if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === 'function') {\n                    if (warningsForRoot === undefined) {\n                        warningsForRoot = [];\n                        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);\n                    }\n                    warningsForRoot.push(fiber);\n                }\n            };\n            ReactStrictModeWarnings.flushLegacyContextWarning = function() {\n                pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {\n                    if (fiberArray.length === 0) {\n                        return;\n                    }\n                    var firstFiber = fiberArray[0];\n                    var uniqueNames = new Set();\n                    fiberArray.forEach(function(fiber) {\n                        uniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n                        didWarnAboutLegacyContext.add(fiber.type);\n                    });\n                    var sortedNames = setToSortedString(uniqueNames);\n                    try {\n                        setCurrentDebugFiberInDEV(firstFiber);\n                        error('Legacy context API has been detected within a strict-mode tree.' + '\\n\\nThe old API will be supported in all 16.x releases, but applications ' + 'using it should migrate to the new version.' + '\\n\\nPlease update the following components: %s' + '\\n\\nLearn more about this warning here: https://react.dev/link/legacy-context', sortedNames);\n                    } finally{\n                        resetCurrentDebugFiberInDEV();\n                    }\n                });\n            };\n            ReactStrictModeWarnings.discardPendingWarnings = function() {\n                pendingComponentWillMountWarnings = [];\n                pendingUNSAFE_ComponentWillMountWarnings = [];\n                pendingComponentWillReceivePropsWarnings = [];\n                pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n                pendingComponentWillUpdateWarnings = [];\n                pendingUNSAFE_ComponentWillUpdateWarnings = [];\n                pendingLegacyContextWarning = new Map();\n            };\n        }\n        function getThenablesFromState(state) {\n            {\n                var devState = state;\n                return devState.thenables;\n            }\n        } // An error that is thrown (e.g. by `use`) to trigger Suspense. If we\n        // detect this is caught by userspace, we'll log a warning in development.\n        var SuspenseException = new Error(\"Suspense Exception: This is not a real error! It's an implementation \" + 'detail of `use` to interrupt the current render. You must either ' + 'rethrow it immediately, or move the `use` call outside of the ' + '`try/catch` block. Capturing without rethrowing will lead to ' + 'unexpected behavior.\\n\\n' + 'To handle async errors, wrap your component in an error boundary, or ' + \"call the promise's `.catch` method and pass the result to `use`\");\n        var SuspenseyCommitException = new Error('Suspense Exception: This is not a real error, and should not leak into ' + \"userspace. If you're seeing this, it's likely a bug in React.\"); // This is a noop thenable that we use to trigger a fallback in throwException.\n        // TODO: It would be better to refactor throwException into multiple functions\n        // so we can trigger a fallback directly without having to check the type. But\n        // for now this will do.\n        var noopSuspenseyCommitThenable = {\n            then: function() {\n                {\n                    error('Internal React error: A listener was unexpectedly attached to a ' + '\"noop\" thenable. This is a bug in React. Please file an issue.');\n                }\n            }\n        };\n        function createThenableState() {\n            // The ThenableState is created the first time a component suspends. If it\n            // suspends again, we'll reuse the same state.\n            {\n                return {\n                    didWarnAboutUncachedPromise: false,\n                    thenables: []\n                };\n            }\n        }\n        function isThenableResolved(thenable) {\n            var status = thenable.status;\n            return status === 'fulfilled' || status === 'rejected';\n        }\n        function noop$1() {}\n        function trackUsedThenable(thenableState, thenable, index) {\n            if (ReactSharedInternals.actQueue !== null) {\n                ReactSharedInternals.didUsePromise = true;\n            }\n            var trackedThenables = getThenablesFromState(thenableState);\n            var previous = trackedThenables[index];\n            if (previous === undefined) {\n                trackedThenables.push(thenable);\n            } else {\n                if (previous !== thenable) {\n                    // Reuse the previous thenable, and drop the new one. We can assume\n                    // they represent the same value, because components are idempotent.\n                    {\n                        var thenableStateDev = thenableState;\n                        if (!thenableStateDev.didWarnAboutUncachedPromise) {\n                            // We should only warn the first time an uncached thenable is\n                            // discovered per component, because if there are multiple, the\n                            // subsequent ones are likely derived from the first.\n                            //\n                            // We track this on the thenableState instead of deduping using the\n                            // component name like we usually do, because in the case of a\n                            // promise-as-React-node, the owner component is likely different from\n                            // the parent that's currently being reconciled. We'd have to track\n                            // the owner using state, which we're trying to move away from. Though\n                            // since this is dev-only, maybe that'd be OK.\n                            //\n                            // However, another benefit of doing it this way is we might\n                            // eventually have a thenableState per memo/Forget boundary instead\n                            // of per component, so this would allow us to have more\n                            // granular warnings.\n                            thenableStateDev.didWarnAboutUncachedPromise = true; // TODO: This warning should link to a corresponding docs page.\n                            error('A component was suspended by an uncached promise. Creating ' + 'promises inside a Client Component or hook is not yet ' + 'supported, except via a Suspense-compatible library or framework.');\n                        }\n                    }\n                    // intentionally ignore.\n                    thenable.then(noop$1, noop$1);\n                    thenable = previous;\n                }\n            } // We use an expando to track the status and result of a thenable so that we\n            // can synchronously unwrap the value. Think of this as an extension of the\n            // Promise API, or a custom interface that is a superset of Thenable.\n            //\n            // If the thenable doesn't have a status, set it to \"pending\" and attach\n            // a listener that will update its status and result when it resolves.\n            switch(thenable.status){\n                case 'fulfilled':\n                    {\n                        var fulfilledValue = thenable.value;\n                        return fulfilledValue;\n                    }\n                case 'rejected':\n                    {\n                        var rejectedError = thenable.reason;\n                        checkIfUseWrappedInAsyncCatch(rejectedError);\n                        throw rejectedError;\n                    }\n                default:\n                    {\n                        if (typeof thenable.status === 'string') {\n                            // Only instrument the thenable if the status if not defined. If\n                            // it's defined, but an unknown value, assume it's been instrumented by\n                            // some custom userspace implementation. We treat it as \"pending\".\n                            // Attach a dummy listener, to ensure that any lazy initialization can\n                            // happen. Flight lazily parses JSON when the value is actually awaited.\n                            thenable.then(noop$1, noop$1);\n                        } else {\n                            // This is an uncached thenable that we haven't seen before.\n                            // Detect infinite ping loops caused by uncached promises.\n                            var root = getWorkInProgressRoot();\n                            if (root !== null && root.shellSuspendCounter > 100) {\n                                // This root has suspended repeatedly in the shell without making any\n                                // progress (i.e. committing something). This is highly suggestive of\n                                // an infinite ping loop, often caused by an accidental Async Client\n                                // Component.\n                                //\n                                // During a transition, we can suspend the work loop until the promise\n                                // to resolve, but this is a sync render, so that's not an option. We\n                                // also can't show a fallback, because none was provided. So our last\n                                // resort is to throw an error.\n                                //\n                                // TODO: Remove this error in a future release. Other ways of handling\n                                // this case include forcing a concurrent render, or putting the whole\n                                // root into offscreen mode.\n                                throw new Error('async/await is not yet supported in Client Components, only ' + 'Server Components. This error is often caused by accidentally ' + \"adding `'use client'` to a module that was originally written \" + 'for the server.');\n                            }\n                            var pendingThenable = thenable;\n                            pendingThenable.status = 'pending';\n                            pendingThenable.then(function(fulfilledValue) {\n                                if (thenable.status === 'pending') {\n                                    var fulfilledThenable = thenable;\n                                    fulfilledThenable.status = 'fulfilled';\n                                    fulfilledThenable.value = fulfilledValue;\n                                }\n                            }, function(error) {\n                                if (thenable.status === 'pending') {\n                                    var rejectedThenable = thenable;\n                                    rejectedThenable.status = 'rejected';\n                                    rejectedThenable.reason = error;\n                                }\n                            });\n                        } // Check one more time in case the thenable resolved synchronously.\n                        switch(thenable.status){\n                            case 'fulfilled':\n                                {\n                                    var fulfilledThenable = thenable;\n                                    return fulfilledThenable.value;\n                                }\n                            case 'rejected':\n                                {\n                                    var rejectedThenable = thenable;\n                                    var _rejectedError = rejectedThenable.reason;\n                                    checkIfUseWrappedInAsyncCatch(_rejectedError);\n                                    throw _rejectedError;\n                                }\n                        } // Suspend.\n                        //\n                        // Throwing here is an implementation detail that allows us to unwind the\n                        // call stack. But we shouldn't allow it to leak into userspace. Throw an\n                        // opaque placeholder value instead of the actual thenable. If it doesn't\n                        // get captured by the work loop, log a warning, because that means\n                        // something in userspace must have caught it.\n                        suspendedThenable = thenable;\n                        {\n                            needsToResetSuspendedThenableDEV = true;\n                        }\n                        throw SuspenseException;\n                    }\n            }\n        }\n        function suspendCommit() {\n            // This extra indirection only exists so it can handle passing\n            // noopSuspenseyCommitThenable through to throwException.\n            // TODO: Factor the thenable check out of throwException\n            suspendedThenable = noopSuspenseyCommitThenable;\n            throw SuspenseyCommitException;\n        } // This is used to track the actual thenable that suspended so it can be\n        // passed to the rest of the Suspense implementation — which, for historical\n        // reasons, expects to receive a thenable.\n        var suspendedThenable = null;\n        var needsToResetSuspendedThenableDEV = false;\n        function getSuspendedThenable() {\n            // This is called right after `use` suspends by throwing an exception. `use`\n            // throws an opaque value instead of the thenable itself so that it can't be\n            // caught in userspace. Then the work loop accesses the actual thenable using\n            // this function.\n            if (suspendedThenable === null) {\n                throw new Error('Expected a suspended thenable. This is a bug in React. Please file ' + 'an issue.');\n            }\n            var thenable = suspendedThenable;\n            suspendedThenable = null;\n            {\n                needsToResetSuspendedThenableDEV = false;\n            }\n            return thenable;\n        }\n        function checkIfUseWrappedInTryCatch() {\n            {\n                // This was set right before SuspenseException was thrown, and it should\n                // have been cleared when the exception was handled. If it wasn't,\n                // it must have been caught by userspace.\n                if (needsToResetSuspendedThenableDEV) {\n                    needsToResetSuspendedThenableDEV = false;\n                    return true;\n                }\n            }\n            return false;\n        }\n        function checkIfUseWrappedInAsyncCatch(rejectedReason) {\n            // This check runs in prod, too, because it prevents a more confusing\n            // downstream error, where SuspenseException is caught by a promise and\n            // thrown asynchronously.\n            // TODO: Another way to prevent SuspenseException from leaking into an async\n            // execution context is to check the dispatcher every time `use` is called,\n            // or some equivalent. That might be preferable for other reasons, too, since\n            // it matches how we prevent similar mistakes for other hooks.\n            if (rejectedReason === SuspenseException) {\n                throw new Error('Hooks are not supported inside an async component. This ' + \"error is often caused by accidentally adding `'use client'` \" + 'to a module that was originally written for the server.');\n            }\n        }\n        var thenableState$1 = null;\n        var thenableIndexCounter$1 = 0;\n        function mergeDebugInfo(outer, inner) {\n            if (inner == null) {\n                return outer;\n            } else if (outer === null) {\n                return inner;\n            } else {\n                // If we have two debugInfo, we need to create a new one. This makes the array no longer\n                // live so we'll miss any future updates if we received more so ideally we should always\n                // do this after both have fully resolved/unsuspended.\n                return outer.concat(inner);\n            }\n        }\n        var didWarnAboutMaps;\n        var didWarnAboutGenerators;\n        var ownerHasKeyUseWarning;\n        var ownerHasFunctionTypeWarning;\n        var ownerHasSymbolTypeWarning;\n        var warnForMissingKey = function(child, returnFiber) {};\n        {\n            didWarnAboutMaps = false;\n            didWarnAboutGenerators = false;\n            /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */ ownerHasKeyUseWarning = {};\n            ownerHasFunctionTypeWarning = {};\n            ownerHasSymbolTypeWarning = {};\n            warnForMissingKey = function(child, returnFiber) {\n                if (child === null || typeof child !== 'object') {\n                    return;\n                }\n                if (!child._store || (child._store.validated || child.key != null) && child._store.validated !== 2) {\n                    return;\n                }\n                if (typeof child._store !== 'object') {\n                    throw new Error('React Component in warnForMissingKey should have a _store. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n                } // $FlowFixMe[cannot-write] unable to narrow type from mixed to writable object\n                child._store.validated = 1;\n                var componentName = getComponentNameFromFiber(returnFiber);\n                var componentKey = componentName || 'null';\n                if (ownerHasKeyUseWarning[componentKey]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[componentKey] = true;\n                var childOwner = child._owner;\n                var parentOwner = returnFiber._debugOwner;\n                var currentComponentErrorInfo = '';\n                if (parentOwner && typeof parentOwner.tag === 'number') {\n                    var name = getComponentNameFromFiber(parentOwner);\n                    if (name) {\n                        currentComponentErrorInfo = '\\n\\nCheck the render method of `' + name + '`.';\n                    }\n                }\n                if (!currentComponentErrorInfo) {\n                    if (componentName) {\n                        currentComponentErrorInfo = \"\\n\\nCheck the top-level render call using <\" + componentName + \">.\";\n                    }\n                } // Usually the current owner is the offender, but if it accepts children as a\n                // property, it may be the creator of the child that's responsible for\n                // assigning it a key.\n                var childOwnerAppendix = '';\n                if (childOwner != null && parentOwner !== childOwner) {\n                    var ownerName = null;\n                    if (typeof childOwner.tag === 'number') {\n                        ownerName = getComponentNameFromFiber(childOwner);\n                    } else if (typeof childOwner.name === 'string') {\n                        ownerName = childOwner.name;\n                    }\n                    if (ownerName) {\n                        // Give the component that originally created this child.\n                        childOwnerAppendix = \" It was passed a child from \" + ownerName + \".\";\n                    }\n                } // We create a fake Fiber for the child to log the stack trace from.\n                // TODO: Refactor the warnForMissingKey calls to happen after fiber creation\n                // so that we can get access to the fiber that will eventually be created.\n                // That way the log can show up associated with the right instance in DevTools.\n                var fiber = createFiberFromElement(child, returnFiber.mode, 0);\n                fiber.return = returnFiber;\n                var prevDebugFiber = getCurrentFiber();\n                setCurrentFiber(fiber);\n                error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://react.dev/link/warning-keys for more information.', currentComponentErrorInfo, childOwnerAppendix);\n                setCurrentFiber(prevDebugFiber);\n            };\n        }\n        // We do this here instead of BeginWork because the Fragment fiber doesn't have\n        // the whole props object, only the children and is shared with arrays.\n        function validateFragmentProps(element, fiber, returnFiber) {\n            {\n                var keys = Object.keys(element.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== 'children' && key !== 'key') {\n                        if (fiber === null) {\n                            // For unkeyed root fragments there's no Fiber. We create a fake one just for\n                            // error stack handling.\n                            fiber = createFiberFromElement(element, returnFiber.mode, 0);\n                            fiber.return = returnFiber;\n                        }\n                        var prevDebugFiber = getCurrentFiber();\n                        setCurrentFiber(fiber);\n                        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n                        setCurrentFiber(prevDebugFiber);\n                        break;\n                    }\n                }\n            }\n        }\n        function unwrapThenable(thenable) {\n            var index = thenableIndexCounter$1;\n            thenableIndexCounter$1 += 1;\n            if (thenableState$1 === null) {\n                thenableState$1 = createThenableState();\n            }\n            return trackUsedThenable(thenableState$1, thenable, index);\n        }\n        function coerceRef(returnFiber, current, workInProgress, element) {\n            var ref;\n            {\n                // TODO: This is a temporary, intermediate step. When enableRefAsProp is on,\n                // we should resolve the `ref` prop during the begin phase of the component\n                // it's attached to (HostComponent, ClassComponent, etc).\n                var refProp = element.props.ref;\n                ref = refProp !== undefined ? refProp : null;\n            }\n            // should always read the ref from the prop.\n            workInProgress.ref = ref;\n        }\n        function throwOnInvalidObjectType(returnFiber, newChild) {\n            if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE) {\n                throw new Error('A React Element from an older version of React was rendered. ' + 'This is not supported. It can happen if:\\n' + '- Multiple copies of the \"react\" package is used.\\n' + '- A library pre-bundled an old copy of \"react\" or \"react/jsx-runtime\".\\n' + '- A compiler tries to \"inline\" JSX instead of using the runtime.');\n            } // $FlowFixMe[method-unbinding]\n            var childString = Object.prototype.toString.call(newChild);\n            throw new Error(\"Objects are not valid as a React child (found: \" + (childString === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : childString) + \"). \" + 'If you meant to render a collection of children, use an array ' + 'instead.');\n        }\n        function warnOnFunctionType(returnFiber, invalidChild) {\n            {\n                var parentName = getComponentNameFromFiber(returnFiber) || 'Component';\n                if (ownerHasFunctionTypeWarning[parentName]) {\n                    return;\n                }\n                ownerHasFunctionTypeWarning[parentName] = true;\n                var name = invalidChild.displayName || invalidChild.name || 'Component';\n                if (returnFiber.tag === HostRoot) {\n                    error('Functions are not valid as a React child. This may happen if ' + 'you return %s instead of <%s /> from render. ' + 'Or maybe you meant to call this function rather than return it.\\n' + '  root.render(%s)', name, name, name);\n                } else {\n                    error('Functions are not valid as a React child. This may happen if ' + 'you return %s instead of <%s /> from render. ' + 'Or maybe you meant to call this function rather than return it.\\n' + '  <%s>{%s}</%s>', name, name, parentName, name, parentName);\n                }\n            }\n        }\n        function warnOnSymbolType(returnFiber, invalidChild) {\n            {\n                var parentName = getComponentNameFromFiber(returnFiber) || 'Component';\n                if (ownerHasSymbolTypeWarning[parentName]) {\n                    return;\n                }\n                ownerHasSymbolTypeWarning[parentName] = true; // eslint-disable-next-line react-internal/safe-string-coercion\n                var name = String(invalidChild);\n                if (returnFiber.tag === HostRoot) {\n                    error('Symbols are not valid as a React child.\\n' + '  root.render(%s)', name);\n                } else {\n                    error('Symbols are not valid as a React child.\\n' + '  <%s>%s</%s>', parentName, name, parentName);\n                }\n            }\n        }\n        function resolveLazy(lazyType) {\n            var payload = lazyType._payload;\n            var init = lazyType._init;\n            return init(payload);\n        } // This wrapper function exists because I expect to clone the code in each path\n        // to be able to optimize each path individually by branching early. This needs\n        // a compiler or we can do it manually. Helpers that don't need this branching\n        // live outside of this function.\n        function createChildReconciler(shouldTrackSideEffects) {\n            function deleteChild(returnFiber, childToDelete) {\n                if (!shouldTrackSideEffects) {\n                    // Noop.\n                    return;\n                }\n                var deletions = returnFiber.deletions;\n                if (deletions === null) {\n                    returnFiber.deletions = [\n                        childToDelete\n                    ];\n                    returnFiber.flags |= ChildDeletion;\n                } else {\n                    deletions.push(childToDelete);\n                }\n            }\n            function deleteRemainingChildren(returnFiber, currentFirstChild) {\n                if (!shouldTrackSideEffects) {\n                    // Noop.\n                    return null;\n                } // TODO: For the shouldClone case, this could be micro-optimized a bit by\n                // assuming that after the first child we've already added everything.\n                var childToDelete = currentFirstChild;\n                while(childToDelete !== null){\n                    deleteChild(returnFiber, childToDelete);\n                    childToDelete = childToDelete.sibling;\n                }\n                return null;\n            }\n            function mapRemainingChildren(currentFirstChild) {\n                // Add the remaining children to a temporary map so that we can find them by\n                // keys quickly. Implicit (null) keys get added to this set with their index\n                // instead.\n                var existingChildren = new Map();\n                var existingChild = currentFirstChild;\n                while(existingChild !== null){\n                    if (existingChild.key !== null) {\n                        existingChildren.set(existingChild.key, existingChild);\n                    } else {\n                        existingChildren.set(existingChild.index, existingChild);\n                    }\n                    existingChild = existingChild.sibling;\n                }\n                return existingChildren;\n            }\n            function useFiber(fiber, pendingProps) {\n                // We currently set sibling to null and index to 0 here because it is easy\n                // to forget to do before returning it. E.g. for the single child case.\n                var clone = createWorkInProgress(fiber, pendingProps);\n                clone.index = 0;\n                clone.sibling = null;\n                return clone;\n            }\n            function placeChild(newFiber, lastPlacedIndex, newIndex) {\n                newFiber.index = newIndex;\n                if (!shouldTrackSideEffects) {\n                    // During hydration, the useId algorithm needs to know which fibers are\n                    // part of a list of children (arrays, iterators).\n                    newFiber.flags |= Forked;\n                    return lastPlacedIndex;\n                }\n                var current = newFiber.alternate;\n                if (current !== null) {\n                    var oldIndex = current.index;\n                    if (oldIndex < lastPlacedIndex) {\n                        // This is a move.\n                        newFiber.flags |= Placement | PlacementDEV;\n                        return lastPlacedIndex;\n                    } else {\n                        // This item can stay in place.\n                        return oldIndex;\n                    }\n                } else {\n                    // This is an insertion.\n                    newFiber.flags |= Placement | PlacementDEV;\n                    return lastPlacedIndex;\n                }\n            }\n            function placeSingleChild(newFiber) {\n                // This is simpler for the single child case. We only need to do a\n                // placement for inserting new children.\n                if (shouldTrackSideEffects && newFiber.alternate === null) {\n                    newFiber.flags |= Placement | PlacementDEV;\n                }\n                return newFiber;\n            }\n            function updateTextNode(returnFiber, current, textContent, lanes, debugInfo) {\n                if (current === null || current.tag !== HostText) {\n                    // Insert\n                    var created = createFiberFromText(textContent, returnFiber.mode, lanes);\n                    created.return = returnFiber;\n                    {\n                        created._debugInfo = debugInfo;\n                    }\n                    return created;\n                } else {\n                    // Update\n                    var existing = useFiber(current, textContent);\n                    existing.return = returnFiber;\n                    {\n                        existing._debugInfo = debugInfo;\n                    }\n                    return existing;\n                }\n            }\n            function updateElement(returnFiber, current, element, lanes, debugInfo) {\n                var elementType = element.type;\n                if (elementType === REACT_FRAGMENT_TYPE) {\n                    var updated = updateFragment(returnFiber, current, element.props.children, lanes, element.key, debugInfo);\n                    validateFragmentProps(element, updated, returnFiber);\n                    return updated;\n                }\n                if (current !== null) {\n                    if (current.elementType === elementType || isCompatibleFamilyForHotReloading(current, element) || // Lazy types should reconcile their resolved type.\n                    // We need to do this after the Hot Reloading check above,\n                    // because hot reloading has different semantics than prod because\n                    // it doesn't resuspend. So we can't let the call below suspend.\n                    typeof elementType === 'object' && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type) {\n                        // Move based on index\n                        var existing = useFiber(current, element.props);\n                        coerceRef(returnFiber, current, existing, element);\n                        existing.return = returnFiber;\n                        {\n                            existing._debugOwner = element._owner;\n                            existing._debugInfo = debugInfo;\n                        }\n                        return existing;\n                    }\n                } // Insert\n                var created = createFiberFromElement(element, returnFiber.mode, lanes);\n                coerceRef(returnFiber, current, created, element);\n                created.return = returnFiber;\n                {\n                    created._debugInfo = debugInfo;\n                }\n                return created;\n            }\n            function updatePortal(returnFiber, current, portal, lanes, debugInfo) {\n                if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n                    // Insert\n                    var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n                    created.return = returnFiber;\n                    {\n                        created._debugInfo = debugInfo;\n                    }\n                    return created;\n                } else {\n                    // Update\n                    var existing = useFiber(current, portal.children || []);\n                    existing.return = returnFiber;\n                    {\n                        existing._debugInfo = debugInfo;\n                    }\n                    return existing;\n                }\n            }\n            function updateFragment(returnFiber, current, fragment, lanes, key, debugInfo) {\n                if (current === null || current.tag !== Fragment) {\n                    // Insert\n                    var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);\n                    created.return = returnFiber;\n                    {\n                        created._debugInfo = debugInfo;\n                    }\n                    return created;\n                } else {\n                    // Update\n                    var existing = useFiber(current, fragment);\n                    existing.return = returnFiber;\n                    {\n                        existing._debugInfo = debugInfo;\n                    }\n                    return existing;\n                }\n            }\n            function createChild(returnFiber, newChild, lanes, debugInfo) {\n                if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number' || typeof newChild === 'bigint') {\n                    // Text nodes don't have keys. If the previous node is implicitly keyed\n                    // we can continue to replace it without aborting even if it is not a text\n                    // node.\n                    var created = createFiberFromText('' + newChild, returnFiber.mode, lanes);\n                    created.return = returnFiber;\n                    {\n                        created._debugInfo = debugInfo;\n                    }\n                    return created;\n                }\n                if (typeof newChild === 'object' && newChild !== null) {\n                    switch(newChild.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            {\n                                var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);\n                                coerceRef(returnFiber, null, _created, newChild);\n                                _created.return = returnFiber;\n                                {\n                                    _created._debugInfo = mergeDebugInfo(debugInfo, newChild._debugInfo);\n                                }\n                                return _created;\n                            }\n                        case REACT_PORTAL_TYPE:\n                            {\n                                var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);\n                                _created2.return = returnFiber;\n                                {\n                                    _created2._debugInfo = debugInfo;\n                                }\n                                return _created2;\n                            }\n                        case REACT_LAZY_TYPE:\n                            {\n                                var payload = newChild._payload;\n                                var init = newChild._init;\n                                return createChild(returnFiber, init(payload), lanes, mergeDebugInfo(debugInfo, newChild._debugInfo) // call merge after init\n                                );\n                            }\n                    }\n                    if (isArray(newChild) || getIteratorFn(newChild) || enableAsyncIterableChildren) {\n                        var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);\n                        _created3.return = returnFiber;\n                        {\n                            _created3._debugInfo = mergeDebugInfo(debugInfo, newChild._debugInfo);\n                        }\n                        return _created3;\n                    } // Usable node types\n                    //\n                    // Unwrap the inner value and recursively call this function again.\n                    if (typeof newChild.then === 'function') {\n                        var thenable = newChild;\n                        return createChild(returnFiber, unwrapThenable(thenable), lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                    }\n                    if (newChild.$$typeof === REACT_CONTEXT_TYPE) {\n                        var context = newChild;\n                        return createChild(returnFiber, readContextDuringReconciliation(returnFiber, context, lanes), lanes, debugInfo);\n                    }\n                    throwOnInvalidObjectType(returnFiber, newChild);\n                }\n                {\n                    if (typeof newChild === 'function') {\n                        warnOnFunctionType(returnFiber, newChild);\n                    }\n                    if (typeof newChild === 'symbol') {\n                        warnOnSymbolType(returnFiber, newChild);\n                    }\n                }\n                return null;\n            }\n            function updateSlot(returnFiber, oldFiber, newChild, lanes, debugInfo) {\n                // Update the fiber if the keys match, otherwise return null.\n                var key = oldFiber !== null ? oldFiber.key : null;\n                if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number' || typeof newChild === 'bigint') {\n                    // Text nodes don't have keys. If the previous node is implicitly keyed\n                    // we can continue to replace it without aborting even if it is not a text\n                    // node.\n                    if (key !== null) {\n                        return null;\n                    }\n                    return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes, debugInfo);\n                }\n                if (typeof newChild === 'object' && newChild !== null) {\n                    switch(newChild.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            {\n                                if (newChild.key === key) {\n                                    return updateElement(returnFiber, oldFiber, newChild, lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                                } else {\n                                    return null;\n                                }\n                            }\n                        case REACT_PORTAL_TYPE:\n                            {\n                                if (newChild.key === key) {\n                                    return updatePortal(returnFiber, oldFiber, newChild, lanes, debugInfo);\n                                } else {\n                                    return null;\n                                }\n                            }\n                        case REACT_LAZY_TYPE:\n                            {\n                                var payload = newChild._payload;\n                                var init = newChild._init;\n                                return updateSlot(returnFiber, oldFiber, init(payload), lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                            }\n                    }\n                    if (isArray(newChild) || getIteratorFn(newChild) || enableAsyncIterableChildren) {\n                        if (key !== null) {\n                            return null;\n                        }\n                        return updateFragment(returnFiber, oldFiber, newChild, lanes, null, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                    } // Usable node types\n                    //\n                    // Unwrap the inner value and recursively call this function again.\n                    if (typeof newChild.then === 'function') {\n                        var thenable = newChild;\n                        return updateSlot(returnFiber, oldFiber, unwrapThenable(thenable), lanes, debugInfo);\n                    }\n                    if (newChild.$$typeof === REACT_CONTEXT_TYPE) {\n                        var context = newChild;\n                        return updateSlot(returnFiber, oldFiber, readContextDuringReconciliation(returnFiber, context, lanes), lanes, debugInfo);\n                    }\n                    throwOnInvalidObjectType(returnFiber, newChild);\n                }\n                {\n                    if (typeof newChild === 'function') {\n                        warnOnFunctionType(returnFiber, newChild);\n                    }\n                    if (typeof newChild === 'symbol') {\n                        warnOnSymbolType(returnFiber, newChild);\n                    }\n                }\n                return null;\n            }\n            function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes, debugInfo) {\n                if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number' || typeof newChild === 'bigint') {\n                    // Text nodes don't have keys, so we neither have to check the old nor\n                    // new node for the key. If both are text nodes, they match.\n                    var matchedFiber = existingChildren.get(newIdx) || null;\n                    return updateTextNode(returnFiber, matchedFiber, '' + newChild, lanes, debugInfo);\n                }\n                if (typeof newChild === 'object' && newChild !== null) {\n                    switch(newChild.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            {\n                                var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n                                return updateElement(returnFiber, _matchedFiber, newChild, lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                            }\n                        case REACT_PORTAL_TYPE:\n                            {\n                                var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n                                return updatePortal(returnFiber, _matchedFiber2, newChild, lanes, debugInfo);\n                            }\n                        case REACT_LAZY_TYPE:\n                            var payload = newChild._payload;\n                            var init = newChild._init;\n                            return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                    }\n                    if (isArray(newChild) || getIteratorFn(newChild) || enableAsyncIterableChildren) {\n                        var _matchedFiber3 = existingChildren.get(newIdx) || null;\n                        return updateFragment(returnFiber, _matchedFiber3, newChild, lanes, null, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                    } // Usable node types\n                    //\n                    // Unwrap the inner value and recursively call this function again.\n                    if (typeof newChild.then === 'function') {\n                        var thenable = newChild;\n                        return updateFromMap(existingChildren, returnFiber, newIdx, unwrapThenable(thenable), lanes, debugInfo);\n                    }\n                    if (newChild.$$typeof === REACT_CONTEXT_TYPE) {\n                        var context = newChild;\n                        return updateFromMap(existingChildren, returnFiber, newIdx, readContextDuringReconciliation(returnFiber, context, lanes), lanes, debugInfo);\n                    }\n                    throwOnInvalidObjectType(returnFiber, newChild);\n                }\n                {\n                    if (typeof newChild === 'function') {\n                        warnOnFunctionType(returnFiber, newChild);\n                    }\n                    if (typeof newChild === 'symbol') {\n                        warnOnSymbolType(returnFiber, newChild);\n                    }\n                }\n                return null;\n            }\n            /**\n   * Warns if there is a duplicate or missing key\n   */ function warnOnInvalidKey(child, knownKeys, returnFiber) {\n                {\n                    if (typeof child !== 'object' || child === null) {\n                        return knownKeys;\n                    }\n                    switch(child.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                        case REACT_PORTAL_TYPE:\n                            warnForMissingKey(child, returnFiber);\n                            var key = child.key;\n                            if (typeof key !== 'string') {\n                                break;\n                            }\n                            if (knownKeys === null) {\n                                knownKeys = new Set();\n                                knownKeys.add(key);\n                                break;\n                            }\n                            if (!knownKeys.has(key)) {\n                                knownKeys.add(key);\n                                break;\n                            }\n                            error('Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted — the behavior is unsupported and ' + 'could change in a future version.', key);\n                            break;\n                        case REACT_LAZY_TYPE:\n                            var payload = child._payload;\n                            var init = child._init;\n                            warnOnInvalidKey(init(payload), knownKeys, returnFiber);\n                            break;\n                    }\n                }\n                return knownKeys;\n            }\n            function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes, debugInfo) {\n                // This algorithm can't optimize by searching from both ends since we\n                // don't have backpointers on fibers. I'm trying to see how far we can get\n                // with that model. If it ends up not being worth the tradeoffs, we can\n                // add it later.\n                // Even with a two ended optimization, we'd want to optimize for the case\n                // where there are few changes and brute force the comparison instead of\n                // going for the Map. It'd like to explore hitting that path first in\n                // forward-only mode and only go for the Map once we notice that we need\n                // lots of look ahead. This doesn't handle reversal as well as two ended\n                // search but that's unusual. Besides, for the two ended optimization to\n                // work on Iterables, we'd need to copy the whole set.\n                // In this first iteration, we'll just live with hitting the bad case\n                // (adding everything to a Map) in for every insert/move.\n                // If you change this code, also update reconcileChildrenIterator() which\n                // uses the same algorithm.\n                {\n                    // First, validate keys.\n                    var knownKeys = null;\n                    for(var i = 0; i < newChildren.length; i++){\n                        var child = newChildren[i];\n                        knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n                    }\n                }\n                var resultingFirstChild = null;\n                var previousNewFiber = null;\n                var oldFiber = currentFirstChild;\n                var lastPlacedIndex = 0;\n                var newIdx = 0;\n                var nextOldFiber = null;\n                for(; oldFiber !== null && newIdx < newChildren.length; newIdx++){\n                    if (oldFiber.index > newIdx) {\n                        nextOldFiber = oldFiber;\n                        oldFiber = null;\n                    } else {\n                        nextOldFiber = oldFiber.sibling;\n                    }\n                    var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes, debugInfo);\n                    if (newFiber === null) {\n                        // TODO: This breaks on empty slots like null children. That's\n                        // unfortunate because it triggers the slow path all the time. We need\n                        // a better way to communicate whether this was a miss or null,\n                        // boolean, undefined, etc.\n                        if (oldFiber === null) {\n                            oldFiber = nextOldFiber;\n                        }\n                        break;\n                    }\n                    if (shouldTrackSideEffects) {\n                        if (oldFiber && newFiber.alternate === null) {\n                            // We matched the slot, but we didn't reuse the existing fiber, so we\n                            // need to delete the existing child.\n                            deleteChild(returnFiber, oldFiber);\n                        }\n                    }\n                    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n                    if (previousNewFiber === null) {\n                        // TODO: Move out of the loop. This only happens for the first run.\n                        resultingFirstChild = newFiber;\n                    } else {\n                        // TODO: Defer siblings if we're not at the right index for this slot.\n                        // I.e. if we had null values before, then we want to defer this\n                        // for each null value. However, we also don't want to call updateSlot\n                        // with the previous one.\n                        previousNewFiber.sibling = newFiber;\n                    }\n                    previousNewFiber = newFiber;\n                    oldFiber = nextOldFiber;\n                }\n                if (newIdx === newChildren.length) {\n                    // We've reached the end of the new children. We can delete the rest.\n                    deleteRemainingChildren(returnFiber, oldFiber);\n                    if (getIsHydrating()) {\n                        var numberOfForks = newIdx;\n                        pushTreeFork(returnFiber, numberOfForks);\n                    }\n                    return resultingFirstChild;\n                }\n                if (oldFiber === null) {\n                    // If we don't have any more existing children we can choose a fast path\n                    // since the rest will all be insertions.\n                    for(; newIdx < newChildren.length; newIdx++){\n                        var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes, debugInfo);\n                        if (_newFiber === null) {\n                            continue;\n                        }\n                        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n                        if (previousNewFiber === null) {\n                            // TODO: Move out of the loop. This only happens for the first run.\n                            resultingFirstChild = _newFiber;\n                        } else {\n                            previousNewFiber.sibling = _newFiber;\n                        }\n                        previousNewFiber = _newFiber;\n                    }\n                    if (getIsHydrating()) {\n                        var _numberOfForks = newIdx;\n                        pushTreeFork(returnFiber, _numberOfForks);\n                    }\n                    return resultingFirstChild;\n                } // Add all children to a key map for quick lookups.\n                var existingChildren = mapRemainingChildren(oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n                for(; newIdx < newChildren.length; newIdx++){\n                    var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes, debugInfo);\n                    if (_newFiber2 !== null) {\n                        if (shouldTrackSideEffects) {\n                            if (_newFiber2.alternate !== null) {\n                                // The new fiber is a work in progress, but if there exists a\n                                // current, that means that we reused the fiber. We need to delete\n                                // it from the child list so that we don't add it to the deletion\n                                // list.\n                                existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);\n                            }\n                        }\n                        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n                        if (previousNewFiber === null) {\n                            resultingFirstChild = _newFiber2;\n                        } else {\n                            previousNewFiber.sibling = _newFiber2;\n                        }\n                        previousNewFiber = _newFiber2;\n                    }\n                }\n                if (shouldTrackSideEffects) {\n                    // Any existing children that weren't consumed above were deleted. We need\n                    // to add them to the deletion list.\n                    existingChildren.forEach(function(child) {\n                        return deleteChild(returnFiber, child);\n                    });\n                }\n                if (getIsHydrating()) {\n                    var _numberOfForks2 = newIdx;\n                    pushTreeFork(returnFiber, _numberOfForks2);\n                }\n                return resultingFirstChild;\n            }\n            function reconcileChildrenIteratable(returnFiber, currentFirstChild, newChildrenIterable, lanes, debugInfo) {\n                // This is the same implementation as reconcileChildrenArray(),\n                // but using the iterator instead.\n                var iteratorFn = getIteratorFn(newChildrenIterable);\n                if (typeof iteratorFn !== 'function') {\n                    throw new Error('An object is not an iterable. This error is likely caused by a bug in ' + 'React. Please file an issue.');\n                }\n                var newChildren = iteratorFn.call(newChildrenIterable);\n                {\n                    if (newChildren === newChildrenIterable) {\n                        // We don't support rendering Generators as props because it's a mutation.\n                        // See https://github.com/facebook/react/issues/12995\n                        // We do support generators if they were created by a GeneratorFunction component\n                        // as its direct child since we can recreate those by rerendering the component\n                        // as needed.\n                        var isGeneratorComponent = returnFiber.tag === FunctionComponent && // $FlowFixMe[method-unbinding]\n                        Object.prototype.toString.call(returnFiber.type) === '[object GeneratorFunction]' && // $FlowFixMe[method-unbinding]\n                        Object.prototype.toString.call(newChildren) === '[object Generator]';\n                        if (!isGeneratorComponent) {\n                            if (!didWarnAboutGenerators) {\n                                error('Using Iterators as children is unsupported and will likely yield ' + 'unexpected results because enumerating a generator mutates it. ' + 'You may convert it to an array with `Array.from()` or the ' + '`[...spread]` operator before rendering. You can also use an ' + 'Iterable that can iterate multiple times over the same items.');\n                            }\n                            didWarnAboutGenerators = true;\n                        }\n                    } else if (newChildrenIterable.entries === iteratorFn) {\n                        // Warn about using Maps as children\n                        if (!didWarnAboutMaps) {\n                            error('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\n                            didWarnAboutMaps = true;\n                        }\n                    }\n                }\n                return reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes, debugInfo);\n            }\n            function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes, debugInfo) {\n                if (newChildren == null) {\n                    throw new Error('An iterable object provided no iterator.');\n                }\n                var resultingFirstChild = null;\n                var previousNewFiber = null;\n                var oldFiber = currentFirstChild;\n                var lastPlacedIndex = 0;\n                var newIdx = 0;\n                var nextOldFiber = null;\n                var knownKeys = null;\n                var step = newChildren.next();\n                {\n                    knownKeys = warnOnInvalidKey(step.value, knownKeys, returnFiber);\n                }\n                for(; oldFiber !== null && !step.done; newIdx++, step = newChildren.next(), knownKeys = warnOnInvalidKey(step.value, knownKeys, returnFiber)){\n                    if (oldFiber.index > newIdx) {\n                        nextOldFiber = oldFiber;\n                        oldFiber = null;\n                    } else {\n                        nextOldFiber = oldFiber.sibling;\n                    }\n                    var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes, debugInfo);\n                    if (newFiber === null) {\n                        // TODO: This breaks on empty slots like null children. That's\n                        // unfortunate because it triggers the slow path all the time. We need\n                        // a better way to communicate whether this was a miss or null,\n                        // boolean, undefined, etc.\n                        if (oldFiber === null) {\n                            oldFiber = nextOldFiber;\n                        }\n                        break;\n                    }\n                    if (shouldTrackSideEffects) {\n                        if (oldFiber && newFiber.alternate === null) {\n                            // We matched the slot, but we didn't reuse the existing fiber, so we\n                            // need to delete the existing child.\n                            deleteChild(returnFiber, oldFiber);\n                        }\n                    }\n                    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n                    if (previousNewFiber === null) {\n                        // TODO: Move out of the loop. This only happens for the first run.\n                        resultingFirstChild = newFiber;\n                    } else {\n                        // TODO: Defer siblings if we're not at the right index for this slot.\n                        // I.e. if we had null values before, then we want to defer this\n                        // for each null value. However, we also don't want to call updateSlot\n                        // with the previous one.\n                        previousNewFiber.sibling = newFiber;\n                    }\n                    previousNewFiber = newFiber;\n                    oldFiber = nextOldFiber;\n                }\n                if (step.done) {\n                    // We've reached the end of the new children. We can delete the rest.\n                    deleteRemainingChildren(returnFiber, oldFiber);\n                    if (getIsHydrating()) {\n                        var numberOfForks = newIdx;\n                        pushTreeFork(returnFiber, numberOfForks);\n                    }\n                    return resultingFirstChild;\n                }\n                if (oldFiber === null) {\n                    // If we don't have any more existing children we can choose a fast path\n                    // since the rest will all be insertions.\n                    for(; !step.done; newIdx++, step = newChildren.next(), knownKeys = warnOnInvalidKey(step.value, knownKeys, returnFiber)){\n                        var _newFiber3 = createChild(returnFiber, step.value, lanes, debugInfo);\n                        if (_newFiber3 === null) {\n                            continue;\n                        }\n                        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n                        if (previousNewFiber === null) {\n                            // TODO: Move out of the loop. This only happens for the first run.\n                            resultingFirstChild = _newFiber3;\n                        } else {\n                            previousNewFiber.sibling = _newFiber3;\n                        }\n                        previousNewFiber = _newFiber3;\n                    }\n                    if (getIsHydrating()) {\n                        var _numberOfForks3 = newIdx;\n                        pushTreeFork(returnFiber, _numberOfForks3);\n                    }\n                    return resultingFirstChild;\n                } // Add all children to a key map for quick lookups.\n                var existingChildren = mapRemainingChildren(oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n                for(; !step.done; newIdx++, step = newChildren.next(), knownKeys = warnOnInvalidKey(step.value, knownKeys, returnFiber)){\n                    var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes, debugInfo);\n                    if (_newFiber4 !== null) {\n                        if (shouldTrackSideEffects) {\n                            if (_newFiber4.alternate !== null) {\n                                // The new fiber is a work in progress, but if there exists a\n                                // current, that means that we reused the fiber. We need to delete\n                                // it from the child list so that we don't add it to the deletion\n                                // list.\n                                existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);\n                            }\n                        }\n                        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n                        if (previousNewFiber === null) {\n                            resultingFirstChild = _newFiber4;\n                        } else {\n                            previousNewFiber.sibling = _newFiber4;\n                        }\n                        previousNewFiber = _newFiber4;\n                    }\n                }\n                if (shouldTrackSideEffects) {\n                    // Any existing children that weren't consumed above were deleted. We need\n                    // to add them to the deletion list.\n                    existingChildren.forEach(function(child) {\n                        return deleteChild(returnFiber, child);\n                    });\n                }\n                if (getIsHydrating()) {\n                    var _numberOfForks4 = newIdx;\n                    pushTreeFork(returnFiber, _numberOfForks4);\n                }\n                return resultingFirstChild;\n            }\n            function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {\n                // There's no need to check for keys on text nodes since we don't have a\n                // way to define them.\n                if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n                    // We already have an existing node so let's just update it and delete\n                    // the rest.\n                    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                    var existing = useFiber(currentFirstChild, textContent);\n                    existing.return = returnFiber;\n                    return existing;\n                } // The existing first child is not a text node so we need to create one\n                // and delete the existing ones.\n                deleteRemainingChildren(returnFiber, currentFirstChild);\n                var created = createFiberFromText(textContent, returnFiber.mode, lanes);\n                created.return = returnFiber;\n                return created;\n            }\n            function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes, debugInfo) {\n                var key = element.key;\n                var child = currentFirstChild;\n                while(child !== null){\n                    // TODO: If key === null and child.key === null, then this only applies to\n                    // the first item in the list.\n                    if (child.key === key) {\n                        var elementType = element.type;\n                        if (elementType === REACT_FRAGMENT_TYPE) {\n                            if (child.tag === Fragment) {\n                                deleteRemainingChildren(returnFiber, child.sibling);\n                                var existing = useFiber(child, element.props.children);\n                                existing.return = returnFiber;\n                                {\n                                    existing._debugOwner = element._owner;\n                                    existing._debugInfo = debugInfo;\n                                }\n                                validateFragmentProps(element, existing, returnFiber);\n                                return existing;\n                            }\n                        } else {\n                            if (child.elementType === elementType || isCompatibleFamilyForHotReloading(child, element) || // Lazy types should reconcile their resolved type.\n                            // We need to do this after the Hot Reloading check above,\n                            // because hot reloading has different semantics than prod because\n                            // it doesn't resuspend. So we can't let the call below suspend.\n                            typeof elementType === 'object' && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {\n                                deleteRemainingChildren(returnFiber, child.sibling);\n                                var _existing = useFiber(child, element.props);\n                                coerceRef(returnFiber, child, _existing, element);\n                                _existing.return = returnFiber;\n                                {\n                                    _existing._debugOwner = element._owner;\n                                    _existing._debugInfo = debugInfo;\n                                }\n                                return _existing;\n                            }\n                        } // Didn't match.\n                        deleteRemainingChildren(returnFiber, child);\n                        break;\n                    } else {\n                        deleteChild(returnFiber, child);\n                    }\n                    child = child.sibling;\n                }\n                if (element.type === REACT_FRAGMENT_TYPE) {\n                    var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);\n                    created.return = returnFiber;\n                    {\n                        created._debugInfo = debugInfo;\n                    }\n                    validateFragmentProps(element, created, returnFiber);\n                    return created;\n                } else {\n                    var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);\n                    coerceRef(returnFiber, currentFirstChild, _created4, element);\n                    _created4.return = returnFiber;\n                    {\n                        _created4._debugInfo = debugInfo;\n                    }\n                    return _created4;\n                }\n            }\n            function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes, debugInfo) {\n                var key = portal.key;\n                var child = currentFirstChild;\n                while(child !== null){\n                    // TODO: If key === null and child.key === null, then this only applies to\n                    // the first item in the list.\n                    if (child.key === key) {\n                        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n                            deleteRemainingChildren(returnFiber, child.sibling);\n                            var existing = useFiber(child, portal.children || []);\n                            existing.return = returnFiber;\n                            return existing;\n                        } else {\n                            deleteRemainingChildren(returnFiber, child);\n                            break;\n                        }\n                    } else {\n                        deleteChild(returnFiber, child);\n                    }\n                    child = child.sibling;\n                }\n                var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n                created.return = returnFiber;\n                return created;\n            } // This API will tag the children with the side-effect of the reconciliation\n            // itself. They will be added to the side-effect list as we pass through the\n            // children and the parent.\n            function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes, debugInfo) {\n                // This function is only recursive for Usables/Lazy and not nested arrays.\n                // That's so that using a Lazy wrapper is unobservable to the Fragment\n                // convention.\n                // If the top level item is an array, we treat it as a set of children,\n                // not as a fragment. Nested arrays on the other hand will be treated as\n                // fragment nodes. Recursion happens at the normal flow.\n                // Handle top level unkeyed fragments as if they were arrays.\n                // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n                // We treat the ambiguous cases above the same.\n                // We don't use recursion here because a fragment inside a fragment\n                // is no longer considered \"top level\" for these purposes.\n                var isUnkeyedTopLevelFragment = typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;\n                if (isUnkeyedTopLevelFragment) {\n                    validateFragmentProps(newChild, null, returnFiber);\n                    newChild = newChild.props.children;\n                } // Handle object types\n                if (typeof newChild === 'object' && newChild !== null) {\n                    switch(newChild.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes, mergeDebugInfo(debugInfo, newChild._debugInfo)));\n                        case REACT_PORTAL_TYPE:\n                            return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));\n                        case REACT_LAZY_TYPE:\n                            var payload = newChild._payload;\n                            var init = newChild._init;\n                            return reconcileChildFibersImpl(returnFiber, currentFirstChild, init(payload), lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                    }\n                    if (isArray(newChild)) {\n                        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                    }\n                    if (getIteratorFn(newChild)) {\n                        return reconcileChildrenIteratable(returnFiber, currentFirstChild, newChild, lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                    }\n                    // a child position, it unwraps it using the same algorithm as `use`. For\n                    // example, for promises, React will throw an exception to unwind the\n                    // stack, then replay the component once the promise resolves.\n                    //\n                    // A difference from `use` is that React will keep unwrapping the value\n                    // until it reaches a non-Usable type.\n                    //\n                    // e.g. Usable<Usable<Usable<T>>> should resolve to T\n                    //\n                    // The structure is a bit unfortunate. Ideally, we shouldn't need to\n                    // replay the entire begin phase of the parent fiber in order to reconcile\n                    // the children again. This would require a somewhat significant refactor,\n                    // because reconcilation happens deep within the begin phase, and\n                    // depending on the type of work, not always at the end. We should\n                    // consider as an future improvement.\n                    if (typeof newChild.then === 'function') {\n                        var thenable = newChild;\n                        return reconcileChildFibersImpl(returnFiber, currentFirstChild, unwrapThenable(thenable), lanes, mergeDebugInfo(debugInfo, thenable._debugInfo));\n                    }\n                    if (newChild.$$typeof === REACT_CONTEXT_TYPE) {\n                        var context = newChild;\n                        return reconcileChildFibersImpl(returnFiber, currentFirstChild, readContextDuringReconciliation(returnFiber, context, lanes), lanes, debugInfo);\n                    }\n                    throwOnInvalidObjectType(returnFiber, newChild);\n                }\n                if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number' || typeof newChild === 'bigint') {\n                    return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, lanes));\n                }\n                {\n                    if (typeof newChild === 'function') {\n                        warnOnFunctionType(returnFiber, newChild);\n                    }\n                    if (typeof newChild === 'symbol') {\n                        warnOnSymbolType(returnFiber, newChild);\n                    }\n                }\n                return deleteRemainingChildren(returnFiber, currentFirstChild);\n            }\n            function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) {\n                // This indirection only exists so we can reset `thenableState` at the end.\n                // It should get inlined by Closure.\n                thenableIndexCounter$1 = 0;\n                var firstChildFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes, null // debugInfo\n                );\n                thenableState$1 = null; // Don't bother to reset `thenableIndexCounter` to 0 because it always gets\n                // set at the beginning.\n                return firstChildFiber;\n            }\n            return reconcileChildFibers;\n        }\n        var reconcileChildFibers = createChildReconciler(true);\n        var mountChildFibers = createChildReconciler(false);\n        function resetChildReconcilerOnUnwind() {\n            // On unwind, clear any pending thenables that were used.\n            thenableState$1 = null;\n            thenableIndexCounter$1 = 0;\n        }\n        function cloneChildFibers(current, workInProgress) {\n            if (current !== null && workInProgress.child !== current.child) {\n                throw new Error('Resuming work not yet implemented.');\n            }\n            if (workInProgress.child === null) {\n                return;\n            }\n            var currentChild = workInProgress.child;\n            var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);\n            workInProgress.child = newChild;\n            newChild.return = workInProgress;\n            while(currentChild.sibling !== null){\n                currentChild = currentChild.sibling;\n                newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);\n                newChild.return = workInProgress;\n            }\n            newChild.sibling = null;\n        } // Reset a workInProgress child set to prepare it for a second pass.\n        function resetChildFibers(workInProgress, lanes) {\n            var child = workInProgress.child;\n            while(child !== null){\n                resetWorkInProgress(child, lanes);\n                child = child.sibling;\n            }\n        }\n        // TODO: This isn't being used yet, but it's intended to replace the\n        // InvisibleParentContext that is currently managed by SuspenseContext.\n        var currentTreeHiddenStackCursor = createCursor(null);\n        var prevEntangledRenderLanesCursor = createCursor(NoLanes);\n        function pushHiddenContext(fiber, context) {\n            var prevEntangledRenderLanes = getEntangledRenderLanes();\n            push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);\n            push(currentTreeHiddenStackCursor, context, fiber); // When rendering a subtree that's currently hidden, we must include all\n            // lanes that would have rendered if the hidden subtree hadn't been deferred.\n            // That is, in order to reveal content from hidden -> visible, we must commit\n            // all the updates that we skipped when we originally hid the tree.\n            setEntangledRenderLanes(mergeLanes(prevEntangledRenderLanes, context.baseLanes));\n        }\n        function reuseHiddenContextOnStack(fiber) {\n            // This subtree is not currently hidden, so we don't need to add any lanes\n            // to the render lanes. But we still need to push something to avoid a\n            // context mismatch. Reuse the existing context on the stack.\n            push(prevEntangledRenderLanesCursor, getEntangledRenderLanes(), fiber);\n            push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current, fiber);\n        }\n        function popHiddenContext(fiber) {\n            // Restore the previous render lanes from the stack\n            setEntangledRenderLanes(prevEntangledRenderLanesCursor.current);\n            pop(currentTreeHiddenStackCursor, fiber);\n            pop(prevEntangledRenderLanesCursor, fiber);\n        }\n        function isCurrentTreeHidden() {\n            return currentTreeHiddenStackCursor.current !== null;\n        }\n        // suspends, i.e. it's the nearest `catch` block on the stack.\n        var suspenseHandlerStackCursor = createCursor(null); // Represents the outermost boundary that is not visible in the current tree.\n        // Everything above this is the \"shell\". When this is null, it means we're\n        // rendering in the shell of the app. If it's non-null, it means we're rendering\n        // deeper than the shell, inside a new tree that wasn't already visible.\n        //\n        // The main way we use this concept is to determine whether showing a fallback\n        // would result in a desirable or undesirable loading state. Activing a fallback\n        // in the shell is considered an undersirable loading state, because it would\n        // mean hiding visible (albeit stale) content in the current tree — we prefer to\n        // show the stale content, rather than switch to a fallback. But showing a\n        // fallback in a new tree is fine, because there's no stale content to\n        // prefer instead.\n        var shellBoundary = null;\n        function getShellBoundary() {\n            return shellBoundary;\n        }\n        function pushPrimaryTreeSuspenseHandler(handler) {\n            // TODO: Pass as argument\n            var current = handler.alternate;\n            // propagated a single level. For example, when ForceSuspenseFallback is set,\n            // it should only force the nearest Suspense boundary into fallback mode.\n            pushSuspenseListContext(handler, setDefaultShallowSuspenseListContext(suspenseStackCursor.current)); // Experimental feature: Some Suspense boundaries are marked as having an\n            // to push a nested Suspense handler, because it will get replaced by the\n            // outer fallback, anyway. Consider this as a future optimization.\n            push(suspenseHandlerStackCursor, handler, handler);\n            if (shellBoundary === null) {\n                if (current === null || isCurrentTreeHidden()) {\n                    // This boundary is not visible in the current UI.\n                    shellBoundary = handler;\n                } else {\n                    var prevState = current.memoizedState;\n                    if (prevState !== null) {\n                        // This boundary is showing a fallback in the current UI.\n                        shellBoundary = handler;\n                    }\n                }\n            }\n        }\n        function pushFallbackTreeSuspenseHandler(fiber) {\n            // We're about to render the fallback. If something in the fallback suspends,\n            // it's akin to throwing inside of a `catch` block. This boundary should not\n            // capture. Reuse the existing handler on the stack.\n            reuseSuspenseHandlerOnStack(fiber);\n        }\n        function pushOffscreenSuspenseHandler(fiber) {\n            if (fiber.tag === OffscreenComponent) {\n                // A SuspenseList context is only pushed here to avoid a push/pop mismatch.\n                // Reuse the current value on the stack.\n                // TODO: We can avoid needing to push here by by forking popSuspenseHandler\n                // into separate functions for Suspense and Offscreen.\n                pushSuspenseListContext(fiber, suspenseStackCursor.current);\n                push(suspenseHandlerStackCursor, fiber, fiber);\n                if (shellBoundary !== null) ;\n                else {\n                    var current = fiber.alternate;\n                    if (current !== null) {\n                        var prevState = current.memoizedState;\n                        if (prevState !== null) {\n                            // This is the first boundary in the stack that's already showing\n                            // a fallback. So everything outside is considered the shell.\n                            shellBoundary = fiber;\n                        }\n                    }\n                }\n            } else {\n                // This is a LegacyHidden component.\n                reuseSuspenseHandlerOnStack(fiber);\n            }\n        }\n        function reuseSuspenseHandlerOnStack(fiber) {\n            pushSuspenseListContext(fiber, suspenseStackCursor.current);\n            push(suspenseHandlerStackCursor, getSuspenseHandler(), fiber);\n        }\n        function getSuspenseHandler() {\n            return suspenseHandlerStackCursor.current;\n        }\n        function popSuspenseHandler(fiber) {\n            pop(suspenseHandlerStackCursor, fiber);\n            if (shellBoundary === fiber) {\n                // Popping back into the shell.\n                shellBoundary = null;\n            }\n            popSuspenseListContext(fiber);\n        } // SuspenseList context\n        // TODO: Move to a separate module? We may change the SuspenseList\n        // implementation to hide/show in the commit phase, anyway.\n        var DefaultSuspenseContext = 0;\n        var SubtreeSuspenseContextMask = 1; // ForceSuspenseFallback can be used by SuspenseList to force newly added\n        // items into their fallback state during one of the render passes.\n        var ForceSuspenseFallback = 2;\n        var suspenseStackCursor = createCursor(DefaultSuspenseContext);\n        function hasSuspenseListContext(parentContext, flag) {\n            return (parentContext & flag) !== 0;\n        }\n        function setDefaultShallowSuspenseListContext(parentContext) {\n            return parentContext & SubtreeSuspenseContextMask;\n        }\n        function setShallowSuspenseListContext(parentContext, shallowContext) {\n            return parentContext & SubtreeSuspenseContextMask | shallowContext;\n        }\n        function pushSuspenseListContext(fiber, newContext) {\n            push(suspenseStackCursor, newContext, fiber);\n        }\n        function popSuspenseListContext(fiber) {\n            pop(suspenseStackCursor, fiber);\n        }\n        // A non-null SuspenseState means that it is blocked for one reason or another.\n        // - A non-null dehydrated field means it's blocked pending hydration.\n        //   - A non-null dehydrated field can use isSuspenseInstancePending or\n        //     isSuspenseInstanceFallback to query the reason for being dehydrated.\n        // - A null dehydrated field means it's blocked by something suspending and\n        //   we're currently showing a fallback instead.\n        function findFirstSuspended(row) {\n            var node = row;\n            while(node !== null){\n                if (node.tag === SuspenseComponent) {\n                    var state = node.memoizedState;\n                    if (state !== null) {\n                        var dehydrated = state.dehydrated;\n                        if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {\n                            return node;\n                        }\n                    }\n                } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't\n                // keep track of whether it suspended or not.\n                node.memoizedProps.revealOrder !== undefined) {\n                    var didSuspend = (node.flags & DidCapture) !== NoFlags$1;\n                    if (didSuspend) {\n                        return node;\n                    }\n                } else if (node.child !== null) {\n                    node.child.return = node;\n                    node = node.child;\n                    continue;\n                }\n                if (node === row) {\n                    return null;\n                }\n                while(node.sibling === null){\n                    if (node.return === null || node.return === row) {\n                        return null;\n                    }\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            }\n            return null;\n        }\n        var NoFlags = /*   */ 0; // Represents whether effect should fire.\n        var HasEffect = /* */ 1; // Represents the phase in which the effect (not the clean-up) fires.\n        var Insertion = /* */ 2;\n        var Layout = /*    */ 4;\n        var Passive = /*   */ 8;\n        var didWarnAboutMismatchedHooksForComponent;\n        var didWarnUncachedGetSnapshot;\n        var didWarnAboutUseWrappedInTryCatch;\n        var didWarnAboutAsyncClientComponent;\n        var didWarnAboutUseFormState;\n        {\n            didWarnAboutMismatchedHooksForComponent = new Set();\n            didWarnAboutUseWrappedInTryCatch = new Set();\n            didWarnAboutAsyncClientComponent = new Set();\n            didWarnAboutUseFormState = new Set();\n        }\n        // lifetime of an effect. In Rust terms, a RefCell. We use it to store the\n        // \"destroy\" function that is returned from an effect, because that is stateful.\n        // The field is `undefined` if the effect is unmounted, or if the effect ran\n        // but is not stateful. We don't explicitly track whether the effect is mounted\n        // or unmounted because that can be inferred by the hiddenness of the fiber in\n        // the tree, i.e. whether there is a hidden Offscreen fiber above it.\n        //\n        // It's unfortunate that this is stored on a separate object, because it adds\n        // more memory per effect instance, but it's conceptually sound. I think there's\n        // likely a better data structure we could use for effects; perhaps just one\n        // array of effect instances per fiber. But I think this is OK for now despite\n        // the additional memory and we can follow up with performance\n        // optimizations later.\n        // These are set right before calling the component.\n        var renderLanes = NoLanes; // The work-in-progress fiber. I've named it differently to distinguish it from\n        // the work-in-progress hook.\n        var currentlyRenderingFiber$1 = null; // Hooks are stored as a linked list on the fiber's memoizedState field. The\n        // current hook list is the list that belongs to the current fiber. The\n        // work-in-progress hook list is a new list that will be added to the\n        // work-in-progress fiber.\n        var currentHook = null;\n        var workInProgressHook = null; // Whether an update was scheduled at any point during the render phase. This\n        // does not get reset if we do another render pass; only when we're completely\n        // finished evaluating this component. This is an optimization so we know\n        // whether we need to clear render phase updates after a throw.\n        var didScheduleRenderPhaseUpdate = false; // Where an update was scheduled only during the current render pass. This\n        // gets reset after each attempt.\n        // TODO: Maybe there's some way to consolidate this with\n        // `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.\n        var didScheduleRenderPhaseUpdateDuringThisPass = false;\n        var shouldDoubleInvokeUserFnsInHooksDEV = false; // Counts the number of useId hooks in this component.\n        var localIdCounter = 0; // Counts number of `use`-d thenables\n        var thenableIndexCounter = 0;\n        var thenableState = null; // Used for ids that are generated completely client-side (i.e. not during\n        // hydration). This counter is global, so client ids are not stable across\n        // render attempts.\n        var globalClientIdCounter = 0;\n        var RE_RENDER_LIMIT = 25; // In DEV, this is the name of the currently executing primitive hook\n        var currentHookNameInDev = null; // In DEV, this list ensures that hooks are called in the same order between renders.\n        // The list stores the order of hooks used during the initial render (mount).\n        // Subsequent renders (updates) reference this list.\n        var hookTypesDev = null;\n        var hookTypesUpdateIndexDev = -1; // In DEV, this tracks whether currently rendering component needs to ignore\n        // the dependencies for Hooks that need them (e.g. useEffect or useMemo).\n        // When true, such Hooks will always be \"remounted\". Only used during hot reload.\n        var ignorePreviousDependencies = false;\n        function mountHookTypesDev() {\n            {\n                var hookName = currentHookNameInDev;\n                if (hookTypesDev === null) {\n                    hookTypesDev = [\n                        hookName\n                    ];\n                } else {\n                    hookTypesDev.push(hookName);\n                }\n            }\n        }\n        function updateHookTypesDev() {\n            {\n                var hookName = currentHookNameInDev;\n                if (hookTypesDev !== null) {\n                    hookTypesUpdateIndexDev++;\n                    if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {\n                        warnOnHookMismatchInDev(hookName);\n                    }\n                }\n            }\n        }\n        function checkDepsAreArrayDev(deps) {\n            {\n                if (deps !== undefined && deps !== null && !isArray(deps)) {\n                    // Verify deps, but only on mount to avoid extra checks.\n                    // It's unlikely their type would change as usually you define them inline.\n                    error('%s received a final argument that is not an array (instead, received `%s`). When ' + 'specified, the final argument must be an array.', currentHookNameInDev, typeof deps);\n                }\n            }\n        }\n        function warnOnHookMismatchInDev(currentHookName) {\n            {\n                var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n                if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {\n                    didWarnAboutMismatchedHooksForComponent.add(componentName);\n                    if (hookTypesDev !== null) {\n                        var table = '';\n                        var secondColumnStart = 30;\n                        for(var i = 0; i <= hookTypesUpdateIndexDev; i++){\n                            var oldHookName = hookTypesDev[i];\n                            var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;\n                            var row = i + 1 + \". \" + oldHookName; // Extra space so second column lines up\n                            // lol @ IE not supporting String#repeat\n                            while(row.length < secondColumnStart){\n                                row += ' ';\n                            }\n                            row += newHookName + '\\n';\n                            table += row;\n                        }\n                        error('React has detected a change in the order of Hooks called by %s. ' + 'This will lead to bugs and errors if not fixed. ' + 'For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\\n\\n' + '   Previous render            Next render\\n' + '   ------------------------------------------------------\\n' + '%s' + '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n', componentName, table);\n                    }\n                }\n            }\n        }\n        function warnOnUseFormStateInDev() {\n            {\n                var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n                if (!didWarnAboutUseFormState.has(componentName)) {\n                    didWarnAboutUseFormState.add(componentName);\n                    error('ReactDOM.useFormState has been renamed to React.useActionState. ' + 'Please update %s to use React.useActionState.', componentName);\n                }\n            }\n        }\n        function warnIfAsyncClientComponent(Component) {\n            {\n                // This dev-only check only works for detecting native async functions,\n                // not transpiled ones. There's also a prod check that we use to prevent\n                // async client components from crashing the app; the prod one works even\n                // for transpiled async functions. Neither mechanism is completely\n                // bulletproof but together they cover the most common cases.\n                var isAsyncFunction = Object.prototype.toString.call(Component) === '[object AsyncFunction]' || // $FlowIgnore[method-unbinding]\n                Object.prototype.toString.call(Component) === '[object AsyncGeneratorFunction]';\n                if (isAsyncFunction) {\n                    // Encountered an async Client Component. This is not yet supported.\n                    var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n                    if (!didWarnAboutAsyncClientComponent.has(componentName)) {\n                        didWarnAboutAsyncClientComponent.add(componentName);\n                        error('async/await is not yet supported in Client Components, only ' + 'Server Components. This error is often caused by accidentally ' + \"adding `'use client'` to a module that was originally written \" + 'for the server.');\n                    }\n                }\n            }\n        }\n        function throwInvalidHookError() {\n            throw new Error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' + '2. You might be breaking the Rules of Hooks\\n' + '3. You might have more than one copy of React in the same app\\n' + 'See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.');\n        }\n        function areHookInputsEqual(nextDeps, prevDeps) {\n            {\n                if (ignorePreviousDependencies) {\n                    // Only true when this component is being hot reloaded.\n                    return false;\n                }\n            }\n            if (prevDeps === null) {\n                {\n                    error('%s received a final argument during this render, but not during ' + 'the previous render. Even though the final argument is optional, ' + 'its type cannot change between renders.', currentHookNameInDev);\n                }\n                return false;\n            }\n            {\n                // Don't bother comparing lengths in prod because these arrays should be\n                // passed inline.\n                if (nextDeps.length !== prevDeps.length) {\n                    error('The final argument passed to %s changed size between renders. The ' + 'order and size of this array must remain constant.\\n\\n' + 'Previous: %s\\n' + 'Incoming: %s', currentHookNameInDev, \"[\" + prevDeps.join(', ') + \"]\", \"[\" + nextDeps.join(', ') + \"]\");\n                }\n            }\n            for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++){\n                // $FlowFixMe[incompatible-use] found when upgrading Flow\n                if (objectIs(nextDeps[i], prevDeps[i])) {\n                    continue;\n                }\n                return false;\n            }\n            return true;\n        }\n        function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {\n            renderLanes = nextRenderLanes;\n            currentlyRenderingFiber$1 = workInProgress;\n            {\n                hookTypesDev = current !== null ? current._debugHookTypes : null;\n                hookTypesUpdateIndexDev = -1; // Used for hot reloading:\n                ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;\n                warnIfAsyncClientComponent(Component);\n            }\n            workInProgress.memoizedState = null;\n            workInProgress.updateQueue = null;\n            workInProgress.lanes = NoLanes; // The following should have already been reset\n            // currentHook = null;\n            // workInProgressHook = null;\n            // didScheduleRenderPhaseUpdate = false;\n            // localIdCounter = 0;\n            // thenableIndexCounter = 0;\n            // thenableState = null;\n            // TODO Warn if no hooks are used at all during mount, then some are used during update.\n            // Currently we will identify the update render as a mount because memoizedState === null.\n            // This is tricky because it's valid for certain types of components (e.g. React.lazy)\n            // Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.\n            // Non-stateful hooks (e.g. context) don't get added to memoizedState,\n            // so memoizedState would be null during updates and mounts.\n            {\n                if (current !== null && current.memoizedState !== null) {\n                    ReactSharedInternals.H = HooksDispatcherOnUpdateInDEV;\n                } else if (hookTypesDev !== null) {\n                    // This dispatcher handles an edge case where a component is updating,\n                    // but no stateful hooks have been used.\n                    // We want to match the production code behavior (which will use HooksDispatcherOnMount),\n                    // but with the extra DEV validation to ensure hooks ordering hasn't changed.\n                    // This dispatcher does that.\n                    ReactSharedInternals.H = HooksDispatcherOnMountWithHookTypesInDEV;\n                } else {\n                    ReactSharedInternals.H = HooksDispatcherOnMountInDEV;\n                }\n            }\n            // help detect side effects. The logic for how this is implemented for in\n            // hook components is a bit complex so let's break it down.\n            //\n            // We will invoke the entire component function twice. However, during the\n            // second invocation of the component, the hook state from the first\n            // invocation will be reused. That means things like `useMemo` functions won't\n            // run again, because the deps will match and the memoized result will\n            // be reused.\n            //\n            // We want memoized functions to run twice, too, so account for this, user\n            // functions are double invoked during the *first* invocation of the component\n            // function, and are *not* double invoked during the second incovation:\n            //\n            // - First execution of component function: user functions are double invoked\n            // - Second execution of component function (in Strict Mode, during\n            //   development): user functions are not double invoked.\n            //\n            // This is intentional for a few reasons; most importantly, it's because of\n            // how `use` works when something suspends: it reuses the promise that was\n            // passed during the first attempt. This is itself a form of memoization.\n            // We need to be able to memoize the reactive inputs to the `use` call using\n            // a hook (i.e. `useMemo`), which means, the reactive inputs to `use` must\n            // come from the same component invocation as the output.\n            //\n            // There are plenty of tests to ensure this behavior is correct.\n            var shouldDoubleRenderDEV = (workInProgress.mode & StrictLegacyMode) !== NoMode;\n            shouldDoubleInvokeUserFnsInHooksDEV = shouldDoubleRenderDEV;\n            var children = Component(props, secondArg);\n            shouldDoubleInvokeUserFnsInHooksDEV = false; // Check if there was a render phase update\n            if (didScheduleRenderPhaseUpdateDuringThisPass) {\n                // Keep rendering until the component stabilizes (there are no more render\n                // phase updates).\n                children = renderWithHooksAgain(workInProgress, Component, props, secondArg);\n            }\n            if (shouldDoubleRenderDEV) {\n                // In development, components are invoked twice to help detect side effects.\n                setIsStrictModeForDevtools(true);\n                try {\n                    children = renderWithHooksAgain(workInProgress, Component, props, secondArg);\n                } finally{\n                    setIsStrictModeForDevtools(false);\n                }\n            }\n            finishRenderingHooks(current, workInProgress);\n            return children;\n        }\n        function finishRenderingHooks(current, workInProgress, Component) {\n            {\n                workInProgress._debugHookTypes = hookTypesDev;\n            }\n            // at the beginning of the render phase and there's no re-entrance.\n            ReactSharedInternals.H = ContextOnlyDispatcher; // This check uses currentHook so that it works the same in DEV and prod bundles.\n            // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\n            var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;\n            renderLanes = NoLanes;\n            currentlyRenderingFiber$1 = null;\n            currentHook = null;\n            workInProgressHook = null;\n            {\n                currentHookNameInDev = null;\n                hookTypesDev = null;\n                hookTypesUpdateIndexDev = -1; // Confirm that a static flag was not added or removed since the last\n                // render. If this fires, it suggests that we incorrectly reset the static\n                // flags in some other part of the codebase. This has happened before, for\n                // example, in the SuspenseList implementation.\n                if (current !== null && (current.flags & StaticMask) !== (workInProgress.flags & StaticMask) && // and creates false positives. To make this work in legacy mode, we'd\n                // need to mark fibers that commit in an incomplete state, somehow. For\n                // now I'll disable the warning that most of the bugs that would trigger\n                // it are either exclusive to concurrent mode or exist in both.\n                disableLegacyMode) {\n                    error('Internal React error: Expected static flag was missing. Please ' + 'notify the React team.');\n                }\n            }\n            didScheduleRenderPhaseUpdate = false; // This is reset by checkDidRenderIdHook\n            // localIdCounter = 0;\n            thenableIndexCounter = 0;\n            thenableState = null;\n            if (didRenderTooFewHooks) {\n                throw new Error('Rendered fewer hooks than expected. This may be caused by an accidental ' + 'early return statement.');\n            }\n            {\n                if (checkIfUseWrappedInTryCatch()) {\n                    var componentName = getComponentNameFromFiber(workInProgress) || 'Unknown';\n                    if (!didWarnAboutUseWrappedInTryCatch.has(componentName) && // This warning also fires if you suspend with `use` inside an\n                    // async component. Since we warn for that above, we'll silence this\n                    // second warning by checking here.\n                    !didWarnAboutAsyncClientComponent.has(componentName)) {\n                        didWarnAboutUseWrappedInTryCatch.add(componentName);\n                        error('`use` was called from inside a try/catch block. This is not allowed ' + 'and can lead to unexpected behavior. To handle errors triggered ' + 'by `use`, wrap your component in a error boundary.');\n                    }\n                }\n            }\n        }\n        function replaySuspendedComponentWithHooks(current, workInProgress, Component, props, secondArg) {\n            // This function is used to replay a component that previously suspended,\n            // after its data resolves.\n            //\n            // It's a simplified version of renderWithHooks, but it doesn't need to do\n            // most of the set up work because they weren't reset when we suspended; they\n            // only get reset when the component either completes (finishRenderingHooks)\n            // or unwinds (resetHooksOnUnwind).\n            {\n                hookTypesUpdateIndexDev = -1; // Used for hot reloading:\n                ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;\n            }\n            var children = renderWithHooksAgain(workInProgress, Component, props, secondArg);\n            finishRenderingHooks(current, workInProgress);\n            return children;\n        }\n        function renderWithHooksAgain(workInProgress, Component, props, secondArg) {\n            // This is used to perform another render pass. It's used when setState is\n            // called during render, and for double invoking components in Strict Mode\n            // during development.\n            //\n            // The state from the previous pass is reused whenever possible. So, state\n            // updates that were already processed are not processed again, and memoized\n            // functions (`useMemo`) are not invoked again.\n            //\n            // Keep rendering in a loop for as long as render phase updates continue to\n            // be scheduled. Use a counter to prevent infinite loops.\n            currentlyRenderingFiber$1 = workInProgress;\n            var numberOfReRenders = 0;\n            var children;\n            do {\n                if (didScheduleRenderPhaseUpdateDuringThisPass) {\n                    // It's possible that a use() value depended on a state that was updated in\n                    // this rerender, so we need to watch for different thenables this time.\n                    thenableState = null;\n                }\n                thenableIndexCounter = 0;\n                didScheduleRenderPhaseUpdateDuringThisPass = false;\n                if (numberOfReRenders >= RE_RENDER_LIMIT) {\n                    throw new Error('Too many re-renders. React limits the number of renders to prevent ' + 'an infinite loop.');\n                }\n                numberOfReRenders += 1;\n                {\n                    // Even when hot reloading, allow dependencies to stabilize\n                    // after first render to prevent infinite render phase updates.\n                    ignorePreviousDependencies = false;\n                }\n                currentHook = null;\n                workInProgressHook = null;\n                workInProgress.updateQueue = null;\n                {\n                    // Also validate hook order for cascading updates.\n                    hookTypesUpdateIndexDev = -1;\n                }\n                ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;\n                children = Component(props, secondArg);\n            }while (didScheduleRenderPhaseUpdateDuringThisPass);\n            return children;\n        }\n        function renderTransitionAwareHostComponentWithHooks(current, workInProgress, lanes) {\n            return renderWithHooks(current, workInProgress, TransitionAwareHostComponent, null, null, lanes);\n        }\n        function TransitionAwareHostComponent() {\n            var dispatcher = ReactSharedInternals.H;\n            var _dispatcher$useState = dispatcher.useState(), maybeThenable = _dispatcher$useState[0];\n            var nextState;\n            if (typeof maybeThenable.then === 'function') {\n                var thenable = maybeThenable;\n                nextState = useThenable(thenable);\n            } else {\n                var status = maybeThenable;\n                nextState = status;\n            } // The \"reset state\" is an object. If it changes, that means something\n            // requested that we reset the form.\n            var _dispatcher$useState2 = dispatcher.useState(), nextResetState = _dispatcher$useState2[0];\n            var prevResetState = currentHook !== null ? currentHook.memoizedState : null;\n            if (prevResetState !== nextResetState) {\n                // Schedule a form reset\n                currentlyRenderingFiber$1.flags |= FormReset;\n            }\n            return nextState;\n        }\n        function checkDidRenderIdHook() {\n            // This should be called immediately after every renderWithHooks call.\n            // Conceptually, it's part of the return value of renderWithHooks; it's only a\n            // separate function to avoid using an array tuple.\n            var didRenderIdHook = localIdCounter !== 0;\n            localIdCounter = 0;\n            return didRenderIdHook;\n        }\n        function bailoutHooks(current, workInProgress, lanes) {\n            workInProgress.updateQueue = current.updateQueue; // TODO: Don't need to reset the flags here, because they're reset in the\n            // complete phase (bubbleProperties).\n            if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                workInProgress.flags &= ~(MountPassiveDev | MountLayoutDev | Passive$1 | Update);\n            } else {\n                workInProgress.flags &= ~(Passive$1 | Update);\n            }\n            current.lanes = removeLanes(current.lanes, lanes);\n        }\n        function resetHooksAfterThrow() {\n            // This is called immediaetly after a throw. It shouldn't reset the entire\n            // module state, because the work loop might decide to replay the component\n            // again without rewinding.\n            //\n            // It should only reset things like the current dispatcher, to prevent hooks\n            // from being called outside of a component.\n            currentlyRenderingFiber$1 = null; // We can assume the previous dispatcher is always this one, since we set it\n            // at the beginning of the render phase and there's no re-entrance.\n            ReactSharedInternals.H = ContextOnlyDispatcher;\n        }\n        function resetHooksOnUnwind(workInProgress) {\n            if (didScheduleRenderPhaseUpdate) {\n                // There were render phase updates. These are only valid for this render\n                // phase, which we are now aborting. Remove the updates from the queues so\n                // they do not persist to the next render. Do not remove updates from hooks\n                // that weren't processed.\n                //\n                // Only reset the updates from the queue if it has a clone. If it does\n                // not have a clone, that means it wasn't processed, and the updates were\n                // scheduled before we entered the render phase.\n                var hook = workInProgress.memoizedState;\n                while(hook !== null){\n                    var queue = hook.queue;\n                    if (queue !== null) {\n                        queue.pending = null;\n                    }\n                    hook = hook.next;\n                }\n                didScheduleRenderPhaseUpdate = false;\n            }\n            renderLanes = NoLanes;\n            currentlyRenderingFiber$1 = null;\n            currentHook = null;\n            workInProgressHook = null;\n            {\n                hookTypesDev = null;\n                hookTypesUpdateIndexDev = -1;\n                currentHookNameInDev = null;\n            }\n            didScheduleRenderPhaseUpdateDuringThisPass = false;\n            localIdCounter = 0;\n            thenableIndexCounter = 0;\n            thenableState = null;\n        }\n        function mountWorkInProgressHook() {\n            var hook = {\n                memoizedState: null,\n                baseState: null,\n                baseQueue: null,\n                queue: null,\n                next: null\n            };\n            if (workInProgressHook === null) {\n                // This is the first hook in the list\n                currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;\n            } else {\n                // Append to the end of the list\n                workInProgressHook = workInProgressHook.next = hook;\n            }\n            return workInProgressHook;\n        }\n        function updateWorkInProgressHook() {\n            // This function is used both for updates and for re-renders triggered by a\n            // render phase update. It assumes there is either a current hook we can\n            // clone, or a work-in-progress hook from a previous render pass that we can\n            // use as a base.\n            var nextCurrentHook;\n            if (currentHook === null) {\n                var current = currentlyRenderingFiber$1.alternate;\n                if (current !== null) {\n                    nextCurrentHook = current.memoizedState;\n                } else {\n                    nextCurrentHook = null;\n                }\n            } else {\n                nextCurrentHook = currentHook.next;\n            }\n            var nextWorkInProgressHook;\n            if (workInProgressHook === null) {\n                nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;\n            } else {\n                nextWorkInProgressHook = workInProgressHook.next;\n            }\n            if (nextWorkInProgressHook !== null) {\n                // There's already a work-in-progress. Reuse it.\n                workInProgressHook = nextWorkInProgressHook;\n                nextWorkInProgressHook = workInProgressHook.next;\n                currentHook = nextCurrentHook;\n            } else {\n                // Clone from the current hook.\n                if (nextCurrentHook === null) {\n                    var currentFiber = currentlyRenderingFiber$1.alternate;\n                    if (currentFiber === null) {\n                        // This is the initial render. This branch is reached when the component\n                        // suspends, resumes, then renders an additional hook.\n                        // Should never be reached because we should switch to the mount dispatcher first.\n                        throw new Error('Update hook called on initial render. This is likely a bug in React. Please file an issue.');\n                    } else {\n                        // This is an update. We should always have a current hook.\n                        throw new Error('Rendered more hooks than during the previous render.');\n                    }\n                }\n                currentHook = nextCurrentHook;\n                var newHook = {\n                    memoizedState: currentHook.memoizedState,\n                    baseState: currentHook.baseState,\n                    baseQueue: currentHook.baseQueue,\n                    queue: currentHook.queue,\n                    next: null\n                };\n                if (workInProgressHook === null) {\n                    // This is the first hook in the list.\n                    currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;\n                } else {\n                    // Append to the end of the list.\n                    workInProgressHook = workInProgressHook.next = newHook;\n                }\n            }\n            return workInProgressHook;\n        } // NOTE: defining two versions of this function to avoid size impact when this feature is disabled.\n        // Previously this function was inlined, the additional `memoCache` property makes it not inlined.\n        var createFunctionComponentUpdateQueue;\n        {\n            createFunctionComponentUpdateQueue = function() {\n                return {\n                    lastEffect: null,\n                    events: null,\n                    stores: null,\n                    memoCache: null\n                };\n            };\n        }\n        function useThenable(thenable) {\n            // Track the position of the thenable within this fiber.\n            var index = thenableIndexCounter;\n            thenableIndexCounter += 1;\n            if (thenableState === null) {\n                thenableState = createThenableState();\n            }\n            var result = trackUsedThenable(thenableState, thenable, index);\n            if (currentlyRenderingFiber$1.alternate === null && (workInProgressHook === null ? currentlyRenderingFiber$1.memoizedState === null : workInProgressHook.next === null)) {\n                // Initial render, and either this is the first time the component is\n                // called, or there were no Hooks called after this use() the previous\n                // time (perhaps because it threw). Subsequent Hook calls should use the\n                // mount dispatcher.\n                {\n                    ReactSharedInternals.H = HooksDispatcherOnMountInDEV;\n                }\n            }\n            return result;\n        }\n        function use(usable) {\n            if (usable !== null && typeof usable === 'object') {\n                // $FlowFixMe[method-unbinding]\n                if (typeof usable.then === 'function') {\n                    // This is a thenable.\n                    var thenable = usable;\n                    return useThenable(thenable);\n                } else if (usable.$$typeof === REACT_CONTEXT_TYPE) {\n                    var context = usable;\n                    return readContext(context);\n                }\n            } // eslint-disable-next-line react-internal/safe-string-coercion\n            throw new Error('An unsupported type was passed to use(): ' + String(usable));\n        }\n        function useMemoCache(size) {\n            var memoCache = null; // Fast-path, load memo cache from wip fiber if already prepared\n            var updateQueue = currentlyRenderingFiber$1.updateQueue;\n            if (updateQueue !== null) {\n                memoCache = updateQueue.memoCache;\n            } // Otherwise clone from the current fiber\n            if (memoCache == null) {\n                var current = currentlyRenderingFiber$1.alternate;\n                if (current !== null) {\n                    var currentUpdateQueue = current.updateQueue;\n                    if (currentUpdateQueue !== null) {\n                        var currentMemoCache = currentUpdateQueue.memoCache;\n                        if (currentMemoCache != null) {\n                            memoCache = {\n                                // When enableNoCloningMemoCache is enabled, instead of treating the\n                                // cache as copy-on-write, like we do with fibers, we share the same\n                                // cache instance across all render attempts, even if the component\n                                // is interrupted before it commits.\n                                //\n                                // If an update is interrupted, either because it suspended or\n                                // because of another update, we can reuse the memoized computations\n                                // from the previous attempt. We can do this because the React\n                                // Compiler performs atomic writes to the memo cache, i.e. it will\n                                // not record the inputs to a memoization without also recording its\n                                // output.\n                                //\n                                // This gives us a form of \"resuming\" within components and hooks.\n                                //\n                                // This only works when updating a component that already mounted.\n                                // It has no impact during initial render, because the memo cache is\n                                // stored on the fiber, and since we have not implemented resuming\n                                // for fibers, it's always a fresh memo cache, anyway.\n                                //\n                                // However, this alone is pretty useful — it happens whenever you\n                                // update the UI with fresh data after a mutation/action, which is\n                                // extremely common in a Suspense-driven (e.g. RSC or Relay) app.\n                                data: currentMemoCache.data.map(function(array) {\n                                    return array.slice();\n                                }),\n                                index: 0\n                            };\n                        }\n                    }\n                }\n            } // Finally fall back to allocating a fresh instance of the cache\n            if (memoCache == null) {\n                memoCache = {\n                    data: [],\n                    index: 0\n                };\n            }\n            if (updateQueue === null) {\n                updateQueue = createFunctionComponentUpdateQueue();\n                currentlyRenderingFiber$1.updateQueue = updateQueue;\n            }\n            updateQueue.memoCache = memoCache;\n            var data = memoCache.data[memoCache.index];\n            if (data === undefined) {\n                data = memoCache.data[memoCache.index] = new Array(size);\n                for(var i = 0; i < size; i++){\n                    data[i] = REACT_MEMO_CACHE_SENTINEL;\n                }\n            } else if (data.length !== size) {\n                // TODO: consider warning or throwing here\n                {\n                    error('Expected a constant size argument for each invocation of useMemoCache. ' + 'The previous cache was allocated with size %s but size %s was requested.', data.length, size);\n                }\n            }\n            memoCache.index++;\n            return data;\n        }\n        function basicStateReducer(state, action) {\n            // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types\n            return typeof action === 'function' ? action(state) : action;\n        }\n        function mountReducer(reducer, initialArg, init) {\n            var hook = mountWorkInProgressHook();\n            var initialState;\n            if (init !== undefined) {\n                initialState = init(initialArg);\n                if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                    setIsStrictModeForDevtools(true);\n                    init(initialArg);\n                    setIsStrictModeForDevtools(false);\n                }\n            } else {\n                initialState = initialArg;\n            }\n            hook.memoizedState = hook.baseState = initialState;\n            var queue = {\n                pending: null,\n                lanes: NoLanes,\n                dispatch: null,\n                lastRenderedReducer: reducer,\n                lastRenderedState: initialState\n            };\n            hook.queue = queue;\n            var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);\n            return [\n                hook.memoizedState,\n                dispatch\n            ];\n        }\n        function updateReducer(reducer, initialArg, init) {\n            var hook = updateWorkInProgressHook();\n            return updateReducerImpl(hook, currentHook, reducer);\n        }\n        function updateReducerImpl(hook, current, reducer) {\n            var queue = hook.queue;\n            if (queue === null) {\n                throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');\n            }\n            queue.lastRenderedReducer = reducer; // The last rebase update that is NOT part of the base state.\n            var baseQueue = hook.baseQueue; // The last pending update that hasn't been processed yet.\n            var pendingQueue = queue.pending;\n            if (pendingQueue !== null) {\n                // We have new updates that haven't been processed yet.\n                // We'll add them to the base queue.\n                if (baseQueue !== null) {\n                    // Merge the pending queue and the base queue.\n                    var baseFirst = baseQueue.next;\n                    var pendingFirst = pendingQueue.next;\n                    baseQueue.next = pendingFirst;\n                    pendingQueue.next = baseFirst;\n                }\n                {\n                    if (current.baseQueue !== baseQueue) {\n                        // Internal invariant that should never happen, but feasibly could in\n                        // the future if we implement resuming, or some form of that.\n                        error('Internal error: Expected work-in-progress queue to be a clone. ' + 'This is a bug in React.');\n                    }\n                }\n                current.baseQueue = baseQueue = pendingQueue;\n                queue.pending = null;\n            }\n            var baseState = hook.baseState;\n            if (baseQueue === null) {\n                // If there are no pending updates, then the memoized state should be the\n                // same as the base state. Currently these only diverge in the case of\n                // useOptimistic, because useOptimistic accepts a new baseState on\n                // every render.\n                hook.memoizedState = baseState; // We don't need to call markWorkInProgressReceivedUpdate because\n            // baseState is derived from other reactive values.\n            } else {\n                // We have a queue to process.\n                var first = baseQueue.next;\n                var newState = baseState;\n                var newBaseState = null;\n                var newBaseQueueFirst = null;\n                var newBaseQueueLast = null;\n                var update = first;\n                var didReadFromEntangledAsyncAction = false;\n                do {\n                    // An extra OffscreenLane bit is added to updates that were made to\n                    // a hidden tree, so that we can distinguish them from updates that were\n                    // already there when the tree was hidden.\n                    var updateLane = removeLanes(update.lane, OffscreenLane);\n                    var isHiddenUpdate = updateLane !== update.lane; // Check if this update was made while the tree was hidden. If so, then\n                    // it's not a \"base\" update and we should disregard the extra base lanes\n                    // that were added to renderLanes when we entered the Offscreen tree.\n                    var shouldSkipUpdate = isHiddenUpdate ? !isSubsetOfLanes(getWorkInProgressRootRenderLanes(), updateLane) : !isSubsetOfLanes(renderLanes, updateLane);\n                    if (shouldSkipUpdate) {\n                        // Priority is insufficient. Skip this update. If this is the first\n                        // skipped update, the previous update/state is the new base\n                        // update/state.\n                        var clone = {\n                            lane: updateLane,\n                            revertLane: update.revertLane,\n                            action: update.action,\n                            hasEagerState: update.hasEagerState,\n                            eagerState: update.eagerState,\n                            next: null\n                        };\n                        if (newBaseQueueLast === null) {\n                            newBaseQueueFirst = newBaseQueueLast = clone;\n                            newBaseState = newState;\n                        } else {\n                            newBaseQueueLast = newBaseQueueLast.next = clone;\n                        } // Update the remaining priority in the queue.\n                        // TODO: Don't need to accumulate this. Instead, we can remove\n                        // renderLanes from the original lanes.\n                        currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);\n                        markSkippedUpdateLanes(updateLane);\n                    } else {\n                        // This update does have sufficient priority.\n                        // Check if this is an optimistic update.\n                        var revertLane = update.revertLane;\n                        if (revertLane === NoLane) {\n                            // This is not an optimistic update, and we're going to apply it now.\n                            // But, if there were earlier updates that were skipped, we need to\n                            // leave this update in the queue so it can be rebased later.\n                            if (newBaseQueueLast !== null) {\n                                var _clone = {\n                                    // This update is going to be committed so we never want uncommit\n                                    // it. Using NoLane works because 0 is a subset of all bitmasks, so\n                                    // this will never be skipped by the check above.\n                                    lane: NoLane,\n                                    revertLane: NoLane,\n                                    action: update.action,\n                                    hasEagerState: update.hasEagerState,\n                                    eagerState: update.eagerState,\n                                    next: null\n                                };\n                                newBaseQueueLast = newBaseQueueLast.next = _clone;\n                            } // Check if this update is part of a pending async action. If so,\n                            // we'll need to suspend until the action has finished, so that it's\n                            // batched together with future updates in the same action.\n                            if (updateLane === peekEntangledActionLane()) {\n                                didReadFromEntangledAsyncAction = true;\n                            }\n                        } else {\n                            // This is an optimistic update. If the \"revert\" priority is\n                            // sufficient, don't apply the update. Otherwise, apply the update,\n                            // but leave it in the queue so it can be either reverted or\n                            // rebased in a subsequent render.\n                            if (isSubsetOfLanes(renderLanes, revertLane)) {\n                                // The transition that this optimistic update is associated with\n                                // has finished. Pretend the update doesn't exist by skipping\n                                // over it.\n                                update = update.next; // Check if this update is part of a pending async action. If so,\n                                // we'll need to suspend until the action has finished, so that it's\n                                // batched together with future updates in the same action.\n                                if (revertLane === peekEntangledActionLane()) {\n                                    didReadFromEntangledAsyncAction = true;\n                                }\n                                continue;\n                            } else {\n                                var _clone2 = {\n                                    // Once we commit an optimistic update, we shouldn't uncommit it\n                                    // until the transition it is associated with has finished\n                                    // (represented by revertLane). Using NoLane here works because 0\n                                    // is a subset of all bitmasks, so this will never be skipped by\n                                    // the check above.\n                                    lane: NoLane,\n                                    // Reuse the same revertLane so we know when the transition\n                                    // has finished.\n                                    revertLane: update.revertLane,\n                                    action: update.action,\n                                    hasEagerState: update.hasEagerState,\n                                    eagerState: update.eagerState,\n                                    next: null\n                                };\n                                if (newBaseQueueLast === null) {\n                                    newBaseQueueFirst = newBaseQueueLast = _clone2;\n                                    newBaseState = newState;\n                                } else {\n                                    newBaseQueueLast = newBaseQueueLast.next = _clone2;\n                                } // Update the remaining priority in the queue.\n                                // TODO: Don't need to accumulate this. Instead, we can remove\n                                // renderLanes from the original lanes.\n                                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, revertLane);\n                                markSkippedUpdateLanes(revertLane);\n                            }\n                        } // Process this update.\n                        var action = update.action;\n                        if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                            reducer(newState, action);\n                        }\n                        if (update.hasEagerState) {\n                            // If this update is a state update (not a reducer) and was processed eagerly,\n                            // we can use the eagerly computed state\n                            newState = update.eagerState;\n                        } else {\n                            newState = reducer(newState, action);\n                        }\n                    }\n                    update = update.next;\n                }while (update !== null && update !== first);\n                if (newBaseQueueLast === null) {\n                    newBaseState = newState;\n                } else {\n                    newBaseQueueLast.next = newBaseQueueFirst;\n                } // Mark that the fiber performed work, but only if the new state is\n                // different from the current state.\n                if (!objectIs(newState, hook.memoizedState)) {\n                    markWorkInProgressReceivedUpdate(); // Check if this update is part of a pending async action. If so, we'll\n                    // need to suspend until the action has finished, so that it's batched\n                    // together with future updates in the same action.\n                    // TODO: Once we support hooks inside useMemo (or an equivalent\n                    // memoization boundary like Forget), hoist this logic so that it only\n                    // suspends if the memo boundary produces a new value.\n                    if (didReadFromEntangledAsyncAction) {\n                        var entangledActionThenable = peekEntangledActionThenable();\n                        if (entangledActionThenable !== null) {\n                            // TODO: Instead of the throwing the thenable directly, throw a\n                            // special object like `use` does so we can detect if it's captured\n                            // by userspace.\n                            throw entangledActionThenable;\n                        }\n                    }\n                }\n                hook.memoizedState = newState;\n                hook.baseState = newBaseState;\n                hook.baseQueue = newBaseQueueLast;\n                queue.lastRenderedState = newState;\n            }\n            if (baseQueue === null) {\n                // `queue.lanes` is used for entangling transitions. We can set it back to\n                // zero once the queue is empty.\n                queue.lanes = NoLanes;\n            }\n            var dispatch = queue.dispatch;\n            return [\n                hook.memoizedState,\n                dispatch\n            ];\n        }\n        function rerenderReducer(reducer, initialArg, init) {\n            var hook = updateWorkInProgressHook();\n            var queue = hook.queue;\n            if (queue === null) {\n                throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');\n            }\n            queue.lastRenderedReducer = reducer; // This is a re-render. Apply the new render phase updates to the previous\n            // work-in-progress hook.\n            var dispatch = queue.dispatch;\n            var lastRenderPhaseUpdate = queue.pending;\n            var newState = hook.memoizedState;\n            if (lastRenderPhaseUpdate !== null) {\n                // The queue doesn't persist past this render pass.\n                queue.pending = null;\n                var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n                var update = firstRenderPhaseUpdate;\n                do {\n                    // Process this render phase update. We don't have to check the\n                    // priority because it will always be the same as the current\n                    // render's.\n                    var action = update.action;\n                    newState = reducer(newState, action);\n                    update = update.next;\n                }while (update !== firstRenderPhaseUpdate); // Mark that the fiber performed work, but only if the new state is\n                // different from the current state.\n                if (!objectIs(newState, hook.memoizedState)) {\n                    markWorkInProgressReceivedUpdate();\n                }\n                hook.memoizedState = newState; // Don't persist the state accumulated from the render phase updates to\n                // the base state unless the queue is empty.\n                // TODO: Not sure if this is the desired semantics, but it's what we\n                // do for gDSFP. I can't remember why.\n                if (hook.baseQueue === null) {\n                    hook.baseState = newState;\n                }\n                queue.lastRenderedState = newState;\n            }\n            return [\n                newState,\n                dispatch\n            ];\n        }\n        function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n            var fiber = currentlyRenderingFiber$1;\n            var hook = mountWorkInProgressHook();\n            var nextSnapshot;\n            var isHydrating = getIsHydrating();\n            if (isHydrating) {\n                if (getServerSnapshot === undefined) {\n                    throw new Error('Missing getServerSnapshot, which is required for ' + 'server-rendered content. Will revert to client rendering.');\n                }\n                nextSnapshot = getServerSnapshot();\n                {\n                    if (!didWarnUncachedGetSnapshot) {\n                        if (nextSnapshot !== getServerSnapshot()) {\n                            error('The result of getServerSnapshot should be cached to avoid an infinite loop');\n                            didWarnUncachedGetSnapshot = true;\n                        }\n                    }\n                }\n            } else {\n                nextSnapshot = getSnapshot();\n                {\n                    if (!didWarnUncachedGetSnapshot) {\n                        var cachedSnapshot = getSnapshot();\n                        if (!objectIs(nextSnapshot, cachedSnapshot)) {\n                            error('The result of getSnapshot should be cached to avoid an infinite loop');\n                            didWarnUncachedGetSnapshot = true;\n                        }\n                    }\n                }\n                // Right before committing, we will walk the tree and check if any of the\n                // stores were mutated.\n                //\n                // We won't do this if we're hydrating server-rendered content, because if\n                // the content is stale, it's already visible anyway. Instead we'll patch\n                // it up in a passive effect.\n                var root = getWorkInProgressRoot();\n                if (root === null) {\n                    throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');\n                }\n                var rootRenderLanes = getWorkInProgressRootRenderLanes();\n                if (!includesBlockingLane(root, rootRenderLanes)) {\n                    pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n                }\n            } // Read the current snapshot from the store on every render. This breaks the\n            // normal rules of React, and only works because store updates are\n            // always synchronous.\n            hook.memoizedState = nextSnapshot;\n            var inst = {\n                value: nextSnapshot,\n                getSnapshot: getSnapshot\n            };\n            hook.queue = inst; // Schedule an effect to subscribe to the store.\n            mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [\n                subscribe\n            ]); // Schedule an effect to update the mutable instance fields. We will update\n            // this whenever subscribe, getSnapshot, or value changes. Because there's no\n            // clean-up function, and we track the deps correctly, we can call pushEffect\n            // directly, without storing any additional state. For the same reason, we\n            // don't need to set a static flag, either.\n            fiber.flags |= Passive$1;\n            pushEffect(HasEffect | Passive, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), createEffectInstance(), null);\n            return nextSnapshot;\n        }\n        function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n            var fiber = currentlyRenderingFiber$1;\n            var hook = updateWorkInProgressHook(); // Read the current snapshot from the store on every render. This breaks the\n            // normal rules of React, and only works because store updates are\n            // always synchronous.\n            var nextSnapshot;\n            var isHydrating = getIsHydrating();\n            if (isHydrating) {\n                // Needed for strict mode double render\n                if (getServerSnapshot === undefined) {\n                    throw new Error('Missing getServerSnapshot, which is required for ' + 'server-rendered content. Will revert to client rendering.');\n                }\n                nextSnapshot = getServerSnapshot();\n            } else {\n                nextSnapshot = getSnapshot();\n                {\n                    if (!didWarnUncachedGetSnapshot) {\n                        var cachedSnapshot = getSnapshot();\n                        if (!objectIs(nextSnapshot, cachedSnapshot)) {\n                            error('The result of getSnapshot should be cached to avoid an infinite loop');\n                            didWarnUncachedGetSnapshot = true;\n                        }\n                    }\n                }\n            }\n            var prevSnapshot = (currentHook || hook).memoizedState;\n            var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);\n            if (snapshotChanged) {\n                hook.memoizedState = nextSnapshot;\n                markWorkInProgressReceivedUpdate();\n            }\n            var inst = hook.queue;\n            updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [\n                subscribe\n            ]); // Whenever getSnapshot or subscribe changes, we need to check in the\n            // commit phase if there was an interleaved mutation. In concurrent mode\n            // this can happen all the time, but even in synchronous mode, an earlier\n            // effect may have mutated the store.\n            if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the subscribe function changed. We can save some memory by\n            // checking whether we scheduled a subscription effect above.\n            workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {\n                fiber.flags |= Passive$1;\n                pushEffect(HasEffect | Passive, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), createEffectInstance(), null); // Unless we're rendering a blocking lane, schedule a consistency check.\n                // Right before committing, we will walk the tree and check if any of the\n                // stores were mutated.\n                var root = getWorkInProgressRoot();\n                if (root === null) {\n                    throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');\n                }\n                if (!isHydrating && !includesBlockingLane(root, renderLanes)) {\n                    pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n                }\n            }\n            return nextSnapshot;\n        }\n        function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\n            fiber.flags |= StoreConsistency;\n            var check = {\n                getSnapshot: getSnapshot,\n                value: renderedSnapshot\n            };\n            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;\n            if (componentUpdateQueue === null) {\n                componentUpdateQueue = createFunctionComponentUpdateQueue();\n                currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;\n                componentUpdateQueue.stores = [\n                    check\n                ];\n            } else {\n                var stores = componentUpdateQueue.stores;\n                if (stores === null) {\n                    componentUpdateQueue.stores = [\n                        check\n                    ];\n                } else {\n                    stores.push(check);\n                }\n            }\n        }\n        function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\n            // These are updated in the passive phase\n            inst.value = nextSnapshot;\n            inst.getSnapshot = getSnapshot; // Something may have been mutated in between render and commit. This could\n            // have been in an event that fired before the passive effects, or it could\n            // have been in a layout effect. In that case, we would have used the old\n            // snapsho and getSnapshot values to bail out. We need to check one more time.\n            if (checkIfSnapshotChanged(inst)) {\n                // Force a re-render.\n                forceStoreRerender(fiber);\n            }\n        }\n        function subscribeToStore(fiber, inst, subscribe) {\n            var handleStoreChange = function() {\n                // The store changed. Check if the snapshot changed since the last time we\n                // read from the store.\n                if (checkIfSnapshotChanged(inst)) {\n                    // Force a re-render.\n                    forceStoreRerender(fiber);\n                }\n            }; // Subscribe to the store and return a clean-up function.\n            return subscribe(handleStoreChange);\n        }\n        function checkIfSnapshotChanged(inst) {\n            var latestGetSnapshot = inst.getSnapshot;\n            var prevValue = inst.value;\n            try {\n                var nextValue = latestGetSnapshot();\n                return !objectIs(prevValue, nextValue);\n            } catch (error) {\n                return true;\n            }\n        }\n        function forceStoreRerender(fiber) {\n            var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n            if (root !== null) {\n                scheduleUpdateOnFiber(root, fiber, SyncLane);\n            }\n        }\n        function mountStateImpl(initialState) {\n            var hook = mountWorkInProgressHook();\n            if (typeof initialState === 'function') {\n                var initialStateInitializer = initialState; // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types\n                initialState = initialStateInitializer();\n                if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                    setIsStrictModeForDevtools(true); // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types\n                    initialStateInitializer();\n                    setIsStrictModeForDevtools(false);\n                }\n            }\n            hook.memoizedState = hook.baseState = initialState;\n            var queue = {\n                pending: null,\n                lanes: NoLanes,\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: initialState\n            };\n            hook.queue = queue;\n            return hook;\n        }\n        function mountState(initialState) {\n            var hook = mountStateImpl(initialState);\n            var queue = hook.queue;\n            var dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);\n            queue.dispatch = dispatch;\n            return [\n                hook.memoizedState,\n                dispatch\n            ];\n        }\n        function updateState(initialState) {\n            return updateReducer(basicStateReducer);\n        }\n        function rerenderState(initialState) {\n            return rerenderReducer(basicStateReducer);\n        }\n        function mountOptimistic(passthrough, reducer) {\n            var hook = mountWorkInProgressHook();\n            hook.memoizedState = hook.baseState = passthrough;\n            var queue = {\n                pending: null,\n                lanes: NoLanes,\n                dispatch: null,\n                // Optimistic state does not use the eager update optimization.\n                lastRenderedReducer: null,\n                lastRenderedState: null\n            };\n            hook.queue = queue; // This is different than the normal setState function.\n            var dispatch = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, true, queue);\n            queue.dispatch = dispatch;\n            return [\n                passthrough,\n                dispatch\n            ];\n        }\n        function updateOptimistic(passthrough, reducer) {\n            var hook = updateWorkInProgressHook();\n            return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n        }\n        function updateOptimisticImpl(hook, current, passthrough, reducer) {\n            // Optimistic updates are always rebased on top of the latest value passed in\n            // as an argument. It's called a passthrough because if there are no pending\n            // updates, it will be returned as-is.\n            //\n            // Reset the base state to the passthrough. Future updates will be applied\n            // on top of this.\n            hook.baseState = passthrough; // If a reducer is not provided, default to the same one used by useState.\n            var resolvedReducer = typeof reducer === 'function' ? reducer : basicStateReducer;\n            return updateReducerImpl(hook, currentHook, resolvedReducer);\n        }\n        function rerenderOptimistic(passthrough, reducer) {\n            // Unlike useState, useOptimistic doesn't support render phase updates.\n            // Also unlike useState, we need to replay all pending updates again in case\n            // the passthrough value changed.\n            //\n            // So instead of a forked re-render implementation that knows how to handle\n            // render phase udpates, we can use the same implementation as during a\n            // regular mount or update.\n            var hook = updateWorkInProgressHook();\n            if (currentHook !== null) {\n                // This is an update. Process the update queue.\n                return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n            } // This is a mount. No updates to process.\n            // Reset the base state to the passthrough. Future updates will be applied\n            // on top of this.\n            hook.baseState = passthrough;\n            var dispatch = hook.queue.dispatch;\n            return [\n                passthrough,\n                dispatch\n            ];\n        } // useActionState actions run sequentially, because each action receives the\n        // previous state as an argument. We store pending actions on a queue.\n        function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {\n            if (isRenderPhaseUpdate(fiber)) {\n                throw new Error('Cannot update form state while rendering.');\n            }\n            var last = actionQueue.pending;\n            if (last === null) {\n                // There are no pending actions; this is the first one. We can run\n                // it immediately.\n                var newLast = {\n                    payload: payload,\n                    next: null // circular\n                };\n                newLast.next = actionQueue.pending = newLast;\n                runActionStateAction(actionQueue, setPendingState, setState, payload);\n            } else {\n                // There's already an action running. Add to the queue.\n                var first = last.next;\n                var _newLast = {\n                    payload: payload,\n                    next: first\n                };\n                actionQueue.pending = last.next = _newLast;\n            }\n        }\n        function runActionStateAction(actionQueue, setPendingState, setState, payload) {\n            var action = actionQueue.action;\n            var prevState = actionQueue.state; // This is a fork of startTransition\n            var prevTransition = ReactSharedInternals.T;\n            var currentTransition = {};\n            ReactSharedInternals.T = currentTransition;\n            {\n                ReactSharedInternals.T._updatedFibers = new Set();\n            }\n            // This will be reverted automatically when all actions are finished.\n            setPendingState(true);\n            try {\n                var returnValue = action(prevState, payload);\n                var onStartTransitionFinish = ReactSharedInternals.S;\n                if (onStartTransitionFinish !== null) {\n                    onStartTransitionFinish(currentTransition, returnValue);\n                }\n                if (returnValue !== null && typeof returnValue === 'object' && // $FlowFixMe[method-unbinding]\n                typeof returnValue.then === 'function') {\n                    var thenable = returnValue; // Attach a listener to read the return state of the action. As soon as\n                    // this resolves, we can run the next action in the sequence.\n                    thenable.then(function(nextState) {\n                        actionQueue.state = nextState;\n                        finishRunningActionStateAction(actionQueue, setPendingState, setState);\n                    }, function() {\n                        return finishRunningActionStateAction(actionQueue, setPendingState, setState);\n                    });\n                    setState(thenable);\n                } else {\n                    setState(returnValue);\n                    var nextState = returnValue;\n                    actionQueue.state = nextState;\n                    finishRunningActionStateAction(actionQueue, setPendingState, setState);\n                }\n            } catch (error) {\n                // This is a trick to get the `useActionState` hook to rethrow the error.\n                // When it unwraps the thenable with the `use` algorithm, the error\n                // will be thrown.\n                var rejectedThenable = {\n                    then: function() {},\n                    status: 'rejected',\n                    reason: error // $FlowFixMe: Not sure why this doesn't work\n                };\n                setState(rejectedThenable);\n                finishRunningActionStateAction(actionQueue, setPendingState, setState);\n            } finally{\n                ReactSharedInternals.T = prevTransition;\n                {\n                    if (prevTransition === null && currentTransition._updatedFibers) {\n                        var updatedFibersCount = currentTransition._updatedFibers.size;\n                        currentTransition._updatedFibers.clear();\n                        if (updatedFibersCount > 10) {\n                            warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');\n                        }\n                    }\n                }\n            }\n        }\n        function finishRunningActionStateAction(actionQueue, setPendingState, setState) {\n            // The action finished running. Pop it from the queue and run the next pending\n            // action, if there are any.\n            var last = actionQueue.pending;\n            if (last !== null) {\n                var first = last.next;\n                if (first === last) {\n                    // This was the last action in the queue.\n                    actionQueue.pending = null;\n                } else {\n                    // Remove the first node from the circular queue.\n                    var next = first.next;\n                    last.next = next; // Run the next action.\n                    runActionStateAction(actionQueue, setPendingState, setState, next.payload);\n                }\n            }\n        }\n        function actionStateReducer(oldState, newState) {\n            return newState;\n        }\n        function mountActionState(action, initialStateProp, permalink) {\n            var initialState = initialStateProp;\n            if (getIsHydrating()) {\n                var root = getWorkInProgressRoot();\n                var ssrFormState = root.formState; // If a formState option was passed to the root, there are form state\n                // markers that we need to hydrate. These indicate whether the form state\n                // matches this hook instance.\n                if (ssrFormState !== null) {\n                    var isMatching = tryToClaimNextHydratableFormMarkerInstance(currentlyRenderingFiber$1);\n                    if (isMatching) {\n                        initialState = ssrFormState[0];\n                    }\n                }\n            } // State hook. The state is stored in a thenable which is then unwrapped by\n            // the `use` algorithm during render.\n            var stateHook = mountWorkInProgressHook();\n            stateHook.memoizedState = stateHook.baseState = initialState; // TODO: Typing this \"correctly\" results in recursion limit errors\n            // const stateQueue: UpdateQueue<S | Awaited<S>, S | Awaited<S>> = {\n            var stateQueue = {\n                pending: null,\n                lanes: NoLanes,\n                dispatch: null,\n                lastRenderedReducer: actionStateReducer,\n                lastRenderedState: initialState\n            };\n            stateHook.queue = stateQueue;\n            var setState = dispatchSetState.bind(null, currentlyRenderingFiber$1, stateQueue);\n            stateQueue.dispatch = setState; // Pending state. This is used to store the pending state of the action.\n            // Tracked optimistically, like a transition pending state.\n            var pendingStateHook = mountStateImpl(false);\n            var setPendingState = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, false, pendingStateHook.queue); // Action queue hook. This is used to queue pending actions. The queue is\n            // shared between all instances of the hook. Similar to a regular state queue,\n            // but different because the actions are run sequentially, and they run in\n            // an event instead of during render.\n            var actionQueueHook = mountWorkInProgressHook();\n            var actionQueue = {\n                state: initialState,\n                dispatch: null,\n                // circular\n                action: action,\n                pending: null\n            };\n            actionQueueHook.queue = actionQueue;\n            var dispatch = dispatchActionState.bind(null, currentlyRenderingFiber$1, actionQueue, setPendingState, setState);\n            actionQueue.dispatch = dispatch; // Stash the action function on the memoized state of the hook. We'll use this\n            // to detect when the action function changes so we can update it in\n            // an effect.\n            actionQueueHook.memoizedState = action;\n            return [\n                initialState,\n                dispatch,\n                false\n            ];\n        }\n        function updateActionState(action, initialState, permalink) {\n            var stateHook = updateWorkInProgressHook();\n            var currentStateHook = currentHook;\n            return updateActionStateImpl(stateHook, currentStateHook, action);\n        }\n        function updateActionStateImpl(stateHook, currentStateHook, action, initialState, permalink) {\n            var _updateReducerImpl = updateReducerImpl(stateHook, currentStateHook, actionStateReducer), actionResult = _updateReducerImpl[0];\n            var _updateState = updateState(), isPending = _updateState[0]; // This will suspend until the action finishes.\n            var state = typeof actionResult === 'object' && actionResult !== null && // $FlowFixMe[method-unbinding]\n            typeof actionResult.then === 'function' ? useThenable(actionResult) : actionResult;\n            var actionQueueHook = updateWorkInProgressHook();\n            var actionQueue = actionQueueHook.queue;\n            var dispatch = actionQueue.dispatch; // Check if a new action was passed. If so, update it in an effect.\n            var prevAction = actionQueueHook.memoizedState;\n            if (action !== prevAction) {\n                currentlyRenderingFiber$1.flags |= Passive$1;\n                pushEffect(HasEffect | Passive, actionStateActionEffect.bind(null, actionQueue, action), createEffectInstance(), null);\n            }\n            return [\n                state,\n                dispatch,\n                isPending\n            ];\n        }\n        function actionStateActionEffect(actionQueue, action) {\n            actionQueue.action = action;\n        }\n        function rerenderActionState(action, initialState, permalink) {\n            // Unlike useState, useActionState doesn't support render phase updates.\n            // Also unlike useState, we need to replay all pending updates again in case\n            // the passthrough value changed.\n            //\n            // So instead of a forked re-render implementation that knows how to handle\n            // render phase udpates, we can use the same implementation as during a\n            // regular mount or update.\n            var stateHook = updateWorkInProgressHook();\n            var currentStateHook = currentHook;\n            if (currentStateHook !== null) {\n                // This is an update. Process the update queue.\n                return updateActionStateImpl(stateHook, currentStateHook, action);\n            }\n            updateWorkInProgressHook(); // State\n            // This is a mount. No updates to process.\n            var state = stateHook.memoizedState;\n            var actionQueueHook = updateWorkInProgressHook();\n            var actionQueue = actionQueueHook.queue;\n            var dispatch = actionQueue.dispatch; // This may have changed during the rerender.\n            actionQueueHook.memoizedState = action; // For mount, pending is always false.\n            return [\n                state,\n                dispatch,\n                false\n            ];\n        }\n        function pushEffect(tag, create, inst, deps) {\n            var effect = {\n                tag: tag,\n                create: create,\n                inst: inst,\n                deps: deps,\n                // Circular\n                next: null\n            };\n            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;\n            if (componentUpdateQueue === null) {\n                componentUpdateQueue = createFunctionComponentUpdateQueue();\n                currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;\n                componentUpdateQueue.lastEffect = effect.next = effect;\n            } else {\n                var lastEffect = componentUpdateQueue.lastEffect;\n                if (lastEffect === null) {\n                    componentUpdateQueue.lastEffect = effect.next = effect;\n                } else {\n                    var firstEffect = lastEffect.next;\n                    lastEffect.next = effect;\n                    effect.next = firstEffect;\n                    componentUpdateQueue.lastEffect = effect;\n                }\n            }\n            return effect;\n        }\n        function createEffectInstance() {\n            return {\n                destroy: undefined\n            };\n        }\n        function mountRef(initialValue) {\n            var hook = mountWorkInProgressHook();\n            var ref = {\n                current: initialValue\n            };\n            hook.memoizedState = ref;\n            return ref;\n        }\n        function updateRef(initialValue) {\n            var hook = updateWorkInProgressHook();\n            return hook.memoizedState;\n        }\n        function mountEffectImpl(fiberFlags, hookFlags, create, deps) {\n            var hook = mountWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            currentlyRenderingFiber$1.flags |= fiberFlags;\n            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, createEffectInstance(), nextDeps);\n        }\n        function updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n            var hook = updateWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            var effect = hook.memoizedState;\n            var inst = effect.inst; // currentHook is null on initial mount when rerendering after a render phase\n            // state update or for strict mode.\n            if (currentHook !== null) {\n                if (nextDeps !== null) {\n                    var prevEffect = currentHook.memoizedState;\n                    var prevDeps = prevEffect.deps;\n                    if (areHookInputsEqual(nextDeps, prevDeps)) {\n                        hook.memoizedState = pushEffect(hookFlags, create, inst, nextDeps);\n                        return;\n                    }\n                }\n            }\n            currentlyRenderingFiber$1.flags |= fiberFlags;\n            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, inst, nextDeps);\n        }\n        function mountEffect(create, deps) {\n            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode && (currentlyRenderingFiber$1.mode & NoStrictPassiveEffectsMode) === NoMode) {\n                mountEffectImpl(MountPassiveDev | Passive$1 | PassiveStatic, Passive, create, deps);\n            } else {\n                mountEffectImpl(Passive$1 | PassiveStatic, Passive, create, deps);\n            }\n        }\n        function updateEffect(create, deps) {\n            updateEffectImpl(Passive$1, Passive, create, deps);\n        }\n        function mountInsertionEffect(create, deps) {\n            mountEffectImpl(Update, Insertion, create, deps);\n        }\n        function updateInsertionEffect(create, deps) {\n            return updateEffectImpl(Update, Insertion, create, deps);\n        }\n        function mountLayoutEffect(create, deps) {\n            var fiberFlags = Update | LayoutStatic;\n            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n                fiberFlags |= MountLayoutDev;\n            }\n            return mountEffectImpl(fiberFlags, Layout, create, deps);\n        }\n        function updateLayoutEffect(create, deps) {\n            return updateEffectImpl(Update, Layout, create, deps);\n        }\n        function imperativeHandleEffect(create, ref) {\n            if (typeof ref === 'function') {\n                var refCallback = ref;\n                var inst = create();\n                var refCleanup = refCallback(inst);\n                return function() {\n                    if (typeof refCleanup === 'function') {\n                        // $FlowFixMe[incompatible-use] we need to assume no parameters\n                        refCleanup();\n                    } else {\n                        refCallback(null);\n                    }\n                };\n            } else if (ref !== null && ref !== undefined) {\n                var refObject = ref;\n                {\n                    if (!refObject.hasOwnProperty('current')) {\n                        error('Expected useImperativeHandle() first argument to either be a ' + 'ref callback or React.createRef() object. Instead received: %s.', 'an object with keys {' + Object.keys(refObject).join(', ') + '}');\n                    }\n                }\n                var _inst = create();\n                refObject.current = _inst;\n                return function() {\n                    refObject.current = null;\n                };\n            }\n        }\n        function mountImperativeHandle(ref, create, deps) {\n            {\n                if (typeof create !== 'function') {\n                    error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');\n                }\n            }\n            var effectDeps = deps !== null && deps !== undefined ? deps.concat([\n                ref\n            ]) : null;\n            var fiberFlags = Update | LayoutStatic;\n            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n                fiberFlags |= MountLayoutDev;\n            }\n            mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n        }\n        function updateImperativeHandle(ref, create, deps) {\n            {\n                if (typeof create !== 'function') {\n                    error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');\n                }\n            }\n            var effectDeps = deps !== null && deps !== undefined ? deps.concat([\n                ref\n            ]) : null;\n            updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n        }\n        function mountDebugValue(value, formatterFn) {\n        // The react-debug-hooks package injects its own implementation\n        // so that e.g. DevTools can display custom hook values.\n        }\n        var updateDebugValue = mountDebugValue;\n        function mountCallback(callback, deps) {\n            var hook = mountWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            hook.memoizedState = [\n                callback,\n                nextDeps\n            ];\n            return callback;\n        }\n        function updateCallback(callback, deps) {\n            var hook = updateWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            var prevState = hook.memoizedState;\n            if (nextDeps !== null) {\n                var prevDeps = prevState[1];\n                if (areHookInputsEqual(nextDeps, prevDeps)) {\n                    return prevState[0];\n                }\n            }\n            hook.memoizedState = [\n                callback,\n                nextDeps\n            ];\n            return callback;\n        }\n        function mountMemo(nextCreate, deps) {\n            var hook = mountWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            var nextValue = nextCreate();\n            if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                setIsStrictModeForDevtools(true);\n                nextCreate();\n                setIsStrictModeForDevtools(false);\n            }\n            hook.memoizedState = [\n                nextValue,\n                nextDeps\n            ];\n            return nextValue;\n        }\n        function updateMemo(nextCreate, deps) {\n            var hook = updateWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            var prevState = hook.memoizedState; // Assume these are defined. If they're not, areHookInputsEqual will warn.\n            if (nextDeps !== null) {\n                var prevDeps = prevState[1];\n                if (areHookInputsEqual(nextDeps, prevDeps)) {\n                    return prevState[0];\n                }\n            }\n            var nextValue = nextCreate();\n            if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                setIsStrictModeForDevtools(true);\n                nextCreate();\n                setIsStrictModeForDevtools(false);\n            }\n            hook.memoizedState = [\n                nextValue,\n                nextDeps\n            ];\n            return nextValue;\n        }\n        function mountDeferredValue(value, initialValue) {\n            var hook = mountWorkInProgressHook();\n            return mountDeferredValueImpl(hook, value, initialValue);\n        }\n        function updateDeferredValue(value, initialValue) {\n            var hook = updateWorkInProgressHook();\n            var resolvedCurrentHook = currentHook;\n            var prevValue = resolvedCurrentHook.memoizedState;\n            return updateDeferredValueImpl(hook, prevValue, value, initialValue);\n        }\n        function rerenderDeferredValue(value, initialValue) {\n            var hook = updateWorkInProgressHook();\n            if (currentHook === null) {\n                // This is a rerender during a mount.\n                return mountDeferredValueImpl(hook, value, initialValue);\n            } else {\n                // This is a rerender during an update.\n                var prevValue = currentHook.memoizedState;\n                return updateDeferredValueImpl(hook, prevValue, value, initialValue);\n            }\n        }\n        function mountDeferredValueImpl(hook, value, initialValue) {\n            if (// current render is not synchronous.\n            initialValue !== undefined && // However, to avoid waterfalls, we do not defer if this render\n            // was itself spawned by an earlier useDeferredValue. Check if DeferredLane\n            // is part of the render lanes.\n            !includesSomeLane(renderLanes, DeferredLane)) {\n                // Render with the initial value\n                hook.memoizedState = initialValue; // Schedule a deferred render to switch to the final value.\n                var deferredLane = requestDeferredLane();\n                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);\n                markSkippedUpdateLanes(deferredLane);\n                return initialValue;\n            } else {\n                hook.memoizedState = value;\n                return value;\n            }\n        }\n        function updateDeferredValueImpl(hook, prevValue, value, initialValue) {\n            if (objectIs(value, prevValue)) {\n                // The incoming value is referentially identical to the currently rendered\n                // value, so we can bail out quickly.\n                return value;\n            } else {\n                // Received a new value that's different from the current value.\n                // Check if we're inside a hidden tree\n                if (isCurrentTreeHidden()) {\n                    // Revealing a prerendered tree is considered the same as mounting new\n                    // one, so we reuse the \"mount\" path in this case.\n                    var resultValue = mountDeferredValueImpl(hook, value, initialValue); // Unlike during an actual mount, we need to mark this as an update if\n                    // the value changed.\n                    if (!objectIs(resultValue, prevValue)) {\n                        markWorkInProgressReceivedUpdate();\n                    }\n                    return resultValue;\n                }\n                var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);\n                if (shouldDeferValue) {\n                    // This is an urgent update. Since the value has changed, keep using the\n                    // previous value and spawn a deferred render to update it later.\n                    // Schedule a deferred render\n                    var deferredLane = requestDeferredLane();\n                    currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);\n                    markSkippedUpdateLanes(deferredLane); // Reuse the previous value. We do not need to mark this as an update,\n                    // because we did not render a new value.\n                    return prevValue;\n                } else {\n                    // This is not an urgent update, so we can use the latest value regardless\n                    // of what it is. No need to defer it.\n                    // Mark this as an update to prevent the fiber from bailing out.\n                    markWorkInProgressReceivedUpdate();\n                    hook.memoizedState = value;\n                    return value;\n                }\n            }\n        }\n        function startTransition(fiber, queue, pendingState, finishedState, callback, options) {\n            var previousPriority = getCurrentUpdatePriority();\n            setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));\n            var prevTransition = ReactSharedInternals.T;\n            var currentTransition = {};\n            {\n                // We don't really need to use an optimistic update here, because we\n                // schedule a second \"revert\" update below (which we use to suspend the\n                // transition until the async action scope has finished). But we'll use an\n                // optimistic update anyway to make it less likely the behavior accidentally\n                // diverges; for example, both an optimistic update and this one should\n                // share the same lane.\n                ReactSharedInternals.T = currentTransition;\n                dispatchOptimisticSetState(fiber, false, queue, pendingState);\n            }\n            {\n                currentTransition._updatedFibers = new Set();\n            }\n            try {\n                if (enableAsyncActions) {\n                    var returnValue = callback();\n                    var onStartTransitionFinish = ReactSharedInternals.S;\n                    if (onStartTransitionFinish !== null) {\n                        onStartTransitionFinish(currentTransition, returnValue);\n                    } // Check if we're inside an async action scope. If so, we'll entangle\n                    // this new action with the existing scope.\n                    //\n                    // If we're not already inside an async action scope, and this action is\n                    // async, then we'll create a new async scope.\n                    //\n                    // In the async case, the resulting render will suspend until the async\n                    // action scope has finished.\n                    if (returnValue !== null && typeof returnValue === 'object' && typeof returnValue.then === 'function') {\n                        var thenable = returnValue; // Create a thenable that resolves to `finishedState` once the async\n                        // action has completed.\n                        var thenableForFinishedState = chainThenableValue(thenable, finishedState);\n                        dispatchSetState(fiber, queue, thenableForFinishedState);\n                    } else {\n                        dispatchSetState(fiber, queue, finishedState);\n                    }\n                }\n            } catch (error) {\n                {\n                    // This is a trick to get the `useTransition` hook to rethrow the error.\n                    // When it unwraps the thenable with the `use` algorithm, the error\n                    // will be thrown.\n                    var rejectedThenable = {\n                        then: function() {},\n                        status: 'rejected',\n                        reason: error\n                    };\n                    dispatchSetState(fiber, queue, rejectedThenable);\n                }\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactSharedInternals.T = prevTransition;\n                {\n                    if (prevTransition === null && currentTransition._updatedFibers) {\n                        var updatedFibersCount = currentTransition._updatedFibers.size;\n                        currentTransition._updatedFibers.clear();\n                        if (updatedFibersCount > 10) {\n                            warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');\n                        }\n                    }\n                }\n            }\n        }\n        var noop = function() {};\n        function startHostTransition(formFiber, pendingState, action, formData) {\n            if (formFiber.tag !== HostComponent) {\n                throw new Error('Expected the form instance to be a HostComponent. This ' + 'is a bug in React.');\n            }\n            var stateHook = ensureFormComponentIsStateful(formFiber);\n            var queue = stateHook.queue;\n            startTransition(formFiber, queue, pendingState, NotPendingTransition, // the action, if one is provided. Consider refactoring these two\n            // concerns to avoid the extra lambda.\n            action === null ? // set the pending form status.\n            noop : function() {\n                // Automatically reset the form when the action completes.\n                requestFormReset(formFiber);\n                return action(formData);\n            });\n        }\n        function ensureFormComponentIsStateful(formFiber) {\n            var existingStateHook = formFiber.memoizedState;\n            if (existingStateHook !== null) {\n                // This fiber was already upgraded to be stateful.\n                return existingStateHook;\n            } // Upgrade this host component fiber to be stateful. We're going to pretend\n            // it was stateful all along so we can reuse most of the implementation\n            // for function components and useTransition.\n            //\n            // Create the state hook used by TransitionAwareHostComponent. This is\n            // essentially an inlined version of mountState.\n            var newQueue = {\n                pending: null,\n                lanes: NoLanes,\n                // We're going to cheat and intentionally not create a bound dispatch\n                // method, because we can call it directly in startTransition.\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: NotPendingTransition\n            };\n            var stateHook = {\n                memoizedState: NotPendingTransition,\n                baseState: NotPendingTransition,\n                baseQueue: null,\n                queue: newQueue,\n                next: null\n            }; // We use another state hook to track whether the form needs to be reset.\n            // The state is an empty object. To trigger a reset, we update the state\n            // to a new object. Then during rendering, we detect that the state has\n            // changed and schedule a commit effect.\n            var initialResetState = {};\n            var newResetStateQueue = {\n                pending: null,\n                lanes: NoLanes,\n                // We're going to cheat and intentionally not create a bound dispatch\n                // method, because we can call it directly in startTransition.\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: initialResetState\n            };\n            var resetStateHook = {\n                memoizedState: initialResetState,\n                baseState: initialResetState,\n                baseQueue: null,\n                queue: newResetStateQueue,\n                next: null\n            };\n            stateHook.next = resetStateHook; // Add the hook list to both fiber alternates. The idea is that the fiber\n            // had this hook all along.\n            formFiber.memoizedState = stateHook;\n            var alternate = formFiber.alternate;\n            if (alternate !== null) {\n                alternate.memoizedState = stateHook;\n            }\n            return stateHook;\n        }\n        function requestFormReset(formFiber) {\n            var transition = requestCurrentTransition();\n            {\n                if (transition === null) {\n                    // An optimistic update occurred, but startTransition is not on the stack.\n                    // The form reset will be scheduled at default (sync) priority, which\n                    // is probably not what the user intended. Most likely because the\n                    // requestFormReset call happened after an `await`.\n                    // TODO: Theoretically, requestFormReset is still useful even for\n                    // non-transition updates because it allows you to update defaultValue\n                    // synchronously and then wait to reset until after the update commits.\n                    // I've chosen to warn anyway because it's more likely the `await` mistake\n                    // described above. But arguably we shouldn't.\n                    error('requestFormReset was called outside a transition or action. To ' + 'fix, move to an action, or wrap with startTransition.');\n                }\n            }\n            var stateHook = ensureFormComponentIsStateful(formFiber);\n            var newResetState = {};\n            var resetStateHook = stateHook.next;\n            var resetStateQueue = resetStateHook.queue;\n            dispatchSetState(formFiber, resetStateQueue, newResetState);\n        }\n        function mountTransition() {\n            var stateHook = mountStateImpl(false); // The `start` method never changes.\n            var start = startTransition.bind(null, currentlyRenderingFiber$1, stateHook.queue, true, false);\n            var hook = mountWorkInProgressHook();\n            hook.memoizedState = start;\n            return [\n                false,\n                start\n            ];\n        }\n        function updateTransition() {\n            var _updateState2 = updateState(), booleanOrThenable = _updateState2[0];\n            var hook = updateWorkInProgressHook();\n            var start = hook.memoizedState;\n            var isPending = typeof booleanOrThenable === 'boolean' ? booleanOrThenable : useThenable(booleanOrThenable);\n            return [\n                isPending,\n                start\n            ];\n        }\n        function rerenderTransition() {\n            var _rerenderState = rerenderState(), booleanOrThenable = _rerenderState[0];\n            var hook = updateWorkInProgressHook();\n            var start = hook.memoizedState;\n            var isPending = typeof booleanOrThenable === 'boolean' ? booleanOrThenable : useThenable(booleanOrThenable);\n            return [\n                isPending,\n                start\n            ];\n        }\n        function useHostTransitionStatus() {\n            var status = readContext(HostTransitionContext);\n            return status !== null ? status : NotPendingTransition;\n        }\n        function mountId() {\n            var hook = mountWorkInProgressHook();\n            var root = getWorkInProgressRoot(); // TODO: In Fizz, id generation is specific to each server config. Maybe we\n            // should do this in Fiber, too? Deferring this decision for now because\n            // there's no other place to store the prefix except for an internal field on\n            // the public createRoot object, which the fiber tree does not currently have\n            // a reference to.\n            var identifierPrefix = root.identifierPrefix;\n            var id;\n            if (getIsHydrating()) {\n                var treeId = getTreeId(); // Use a captial R prefix for server-generated ids.\n                id = ':' + identifierPrefix + 'R' + treeId; // Unless this is the first id at this level, append a number at the end\n                // that represents the position of this useId hook among all the useId\n                // hooks for this fiber.\n                var localId = localIdCounter++;\n                if (localId > 0) {\n                    id += 'H' + localId.toString(32);\n                }\n                id += ':';\n            } else {\n                // Use a lowercase r prefix for client-generated ids.\n                var globalClientId = globalClientIdCounter++;\n                id = ':' + identifierPrefix + 'r' + globalClientId.toString(32) + ':';\n            }\n            hook.memoizedState = id;\n            return id;\n        }\n        function updateId() {\n            var hook = updateWorkInProgressHook();\n            var id = hook.memoizedState;\n            return id;\n        }\n        function mountRefresh() {\n            var hook = mountWorkInProgressHook();\n            var refresh = hook.memoizedState = refreshCache.bind(null, currentlyRenderingFiber$1);\n            return refresh;\n        }\n        function updateRefresh() {\n            var hook = updateWorkInProgressHook();\n            return hook.memoizedState;\n        }\n        function refreshCache(fiber, seedKey, seedValue) {\n            // TODO: Consider warning if the refresh is at discrete priority, or if we\n            // otherwise suspect that it wasn't batched properly.\n            var provider = fiber.return;\n            while(provider !== null){\n                switch(provider.tag){\n                    case CacheComponent:\n                    case HostRoot:\n                        {\n                            // Schedule an update on the cache boundary to trigger a refresh.\n                            var lane = requestUpdateLane(provider);\n                            var refreshUpdate = createUpdate(lane);\n                            var root = enqueueUpdate(provider, refreshUpdate, lane);\n                            if (root !== null) {\n                                scheduleUpdateOnFiber(root, provider, lane);\n                                entangleTransitions(root, provider, lane);\n                            } // TODO: If a refresh never commits, the new cache created here must be\n                            // released. A simple case is start refreshing a cache boundary, but then\n                            // unmount that boundary before the refresh completes.\n                            var seededCache = createCache();\n                            if (seedKey !== null && seedKey !== undefined && root !== null) {\n                                {\n                                    {\n                                        error('The seed argument is not enabled outside experimental channels.');\n                                    }\n                                }\n                            }\n                            var payload = {\n                                cache: seededCache\n                            };\n                            refreshUpdate.payload = payload;\n                            return;\n                        }\n                }\n                provider = provider.return;\n            } // TODO: Warn if unmounted?\n        }\n        function dispatchReducerAction(fiber, queue, action) {\n            {\n                if (typeof arguments[3] === 'function') {\n                    error(\"State updates from the useState() and useReducer() Hooks don't support the \" + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');\n                }\n            }\n            var lane = requestUpdateLane(fiber);\n            var update = {\n                lane: lane,\n                revertLane: NoLane,\n                action: action,\n                hasEagerState: false,\n                eagerState: null,\n                next: null\n            };\n            if (isRenderPhaseUpdate(fiber)) {\n                enqueueRenderPhaseUpdate(queue, update);\n            } else {\n                var root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, lane);\n                    entangleTransitionUpdate(root, queue, lane);\n                }\n            }\n            markUpdateInDevTools(fiber, lane);\n        }\n        function dispatchSetState(fiber, queue, action) {\n            {\n                if (typeof arguments[3] === 'function') {\n                    error(\"State updates from the useState() and useReducer() Hooks don't support the \" + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');\n                }\n            }\n            var lane = requestUpdateLane(fiber);\n            var update = {\n                lane: lane,\n                revertLane: NoLane,\n                action: action,\n                hasEagerState: false,\n                eagerState: null,\n                next: null\n            };\n            if (isRenderPhaseUpdate(fiber)) {\n                enqueueRenderPhaseUpdate(queue, update);\n            } else {\n                var alternate = fiber.alternate;\n                if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {\n                    // The queue is currently empty, which means we can eagerly compute the\n                    // next state before entering the render phase. If the new state is the\n                    // same as the current state, we may be able to bail out entirely.\n                    var lastRenderedReducer = queue.lastRenderedReducer;\n                    if (lastRenderedReducer !== null) {\n                        var prevDispatcher = null;\n                        {\n                            prevDispatcher = ReactSharedInternals.H;\n                            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                        }\n                        try {\n                            var currentState = queue.lastRenderedState;\n                            var eagerState = lastRenderedReducer(currentState, action); // Stash the eagerly computed state, and the reducer used to compute\n                            // it, on the update object. If the reducer hasn't changed by the\n                            // time we enter the render phase, then the eager state can be used\n                            // without calling the reducer again.\n                            update.hasEagerState = true;\n                            update.eagerState = eagerState;\n                            if (objectIs(eagerState, currentState)) {\n                                // Fast path. We can bail out without scheduling React to re-render.\n                                // It's still possible that we'll need to rebase this update later,\n                                // if the component re-renders for a different reason and by that\n                                // time the reducer has changed.\n                                // TODO: Do we still need to entangle transitions in this case?\n                                enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update);\n                                return;\n                            }\n                        } catch (error) {} finally{\n                            {\n                                ReactSharedInternals.H = prevDispatcher;\n                            }\n                        }\n                    }\n                }\n                var root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, lane);\n                    entangleTransitionUpdate(root, queue, lane);\n                }\n            }\n            markUpdateInDevTools(fiber, lane);\n        }\n        function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {\n            var transition = requestCurrentTransition();\n            {\n                if (transition === null) {\n                    // An optimistic update occurred, but startTransition is not on the stack.\n                    // There are two likely scenarios.\n                    // One possibility is that the optimistic update is triggered by a regular\n                    // event handler (e.g. `onSubmit`) instead of an action. This is a mistake\n                    // and we will warn.\n                    // The other possibility is the optimistic update is inside an async\n                    // action, but after an `await`. In this case, we can make it \"just work\"\n                    // by associating the optimistic update with the pending async action.\n                    // Technically it's possible that the optimistic update is unrelated to\n                    // the pending action, but we don't have a way of knowing this for sure\n                    // because browsers currently do not provide a way to track async scope.\n                    // (The AsyncContext proposal, if it lands, will solve this in the\n                    // future.) However, this is no different than the problem of unrelated\n                    // transitions being grouped together — it's not wrong per se, but it's\n                    // not ideal.\n                    // Once AsyncContext starts landing in browsers, we will provide better\n                    // warnings in development for these cases.\n                    if (peekEntangledActionLane() !== NoLane) ;\n                    else {\n                        // There's no pending async action. The most likely cause is that we're\n                        // inside a regular event handler (e.g. onSubmit) instead of an action.\n                        error('An optimistic state update occurred outside a transition or ' + 'action. To fix, move the update to an action, or wrap ' + 'with startTransition.');\n                    }\n                }\n            }\n            var update = {\n                // An optimistic update commits synchronously.\n                lane: SyncLane,\n                // After committing, the optimistic update is \"reverted\" using the same\n                // lane as the transition it's associated with.\n                revertLane: requestTransitionLane(),\n                action: action,\n                hasEagerState: false,\n                eagerState: null,\n                next: null\n            };\n            if (isRenderPhaseUpdate(fiber)) {\n                // When calling startTransition during render, this warns instead of\n                // throwing because throwing would be a breaking change. setOptimisticState\n                // is a new API so it's OK to throw.\n                if (throwIfDuringRender) {\n                    throw new Error('Cannot update optimistic state while rendering.');\n                } else {\n                    // startTransition was called during render. We don't need to do anything\n                    // besides warn here because the render phase update would be overidden by\n                    // the second update, anyway. We can remove this branch and make it throw\n                    // in a future release.\n                    {\n                        error('Cannot call startTransition while rendering.');\n                    }\n                }\n            } else {\n                var root = enqueueConcurrentHookUpdate(fiber, queue, update, SyncLane);\n                if (root !== null) {\n                    // NOTE: The optimistic update implementation assumes that the transition\n                    // will never be attempted before the optimistic update. This currently\n                    // holds because the optimistic update is always synchronous. If we ever\n                    // change that, we'll need to account for this.\n                    scheduleUpdateOnFiber(root, fiber, SyncLane); // Optimistic updates are always synchronous, so we don't need to call\n                // entangleTransitionUpdate here.\n                }\n            }\n            markUpdateInDevTools(fiber, SyncLane);\n        }\n        function isRenderPhaseUpdate(fiber) {\n            var alternate = fiber.alternate;\n            return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;\n        }\n        function enqueueRenderPhaseUpdate(queue, update) {\n            // This is a render phase update. Stash it in a lazily-created map of\n            // queue -> linked list of updates. After this render pass, we'll restart\n            // and apply the stashed updates on top of the work-in-progress hook.\n            didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;\n            var pending = queue.pending;\n            if (pending === null) {\n                // This is the first update. Create a circular list.\n                update.next = update;\n            } else {\n                update.next = pending.next;\n                pending.next = update;\n            }\n            queue.pending = update;\n        } // TODO: Move to ReactFiberConcurrentUpdates?\n        function entangleTransitionUpdate(root, queue, lane) {\n            if (isTransitionLane(lane)) {\n                var queueLanes = queue.lanes; // If any entangled lanes are no longer pending on the root, then they\n                // must have finished. We can remove them from the shared queue, which\n                // represents a superset of the actually pending lanes. In some cases we\n                // may entangle more than we need to, but that's OK. In fact it's worse if\n                // we *don't* entangle when we should.\n                queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.\n                var newQueueLanes = mergeLanes(queueLanes, lane);\n                queue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if\n                // the lane finished since the last time we entangled it. So we need to\n                // entangle it again, just to be sure.\n                markRootEntangled(root, newQueueLanes);\n            }\n        }\n        function markUpdateInDevTools(fiber, lane, action) {\n            {\n                markStateUpdateScheduled(fiber, lane);\n            }\n        }\n        var ContextOnlyDispatcher = {\n            readContext: readContext,\n            use: use,\n            useCallback: throwInvalidHookError,\n            useContext: throwInvalidHookError,\n            useEffect: throwInvalidHookError,\n            useImperativeHandle: throwInvalidHookError,\n            useLayoutEffect: throwInvalidHookError,\n            useInsertionEffect: throwInvalidHookError,\n            useMemo: throwInvalidHookError,\n            useReducer: throwInvalidHookError,\n            useRef: throwInvalidHookError,\n            useState: throwInvalidHookError,\n            useDebugValue: throwInvalidHookError,\n            useDeferredValue: throwInvalidHookError,\n            useTransition: throwInvalidHookError,\n            useSyncExternalStore: throwInvalidHookError,\n            useId: throwInvalidHookError\n        };\n        {\n            ContextOnlyDispatcher.useCacheRefresh = throwInvalidHookError;\n        }\n        {\n            ContextOnlyDispatcher.useMemoCache = throwInvalidHookError;\n        }\n        {\n            ContextOnlyDispatcher.useHostTransitionStatus = throwInvalidHookError;\n            ContextOnlyDispatcher.useFormState = throwInvalidHookError;\n            ContextOnlyDispatcher.useActionState = throwInvalidHookError;\n        }\n        {\n            ContextOnlyDispatcher.useOptimistic = throwInvalidHookError;\n        }\n        var HooksDispatcherOnMountInDEV = null;\n        var HooksDispatcherOnMountWithHookTypesInDEV = null;\n        var HooksDispatcherOnUpdateInDEV = null;\n        var HooksDispatcherOnRerenderInDEV = null;\n        var InvalidNestedHooksDispatcherOnMountInDEV = null;\n        var InvalidNestedHooksDispatcherOnUpdateInDEV = null;\n        var InvalidNestedHooksDispatcherOnRerenderInDEV = null;\n        {\n            var warnInvalidContextAccess = function() {\n                error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\n            };\n            var warnInvalidHookAccess = function() {\n                error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' + 'You can only call Hooks at the top level of your React function. ' + 'For more information, see ' + 'https://react.dev/link/rules-of-hooks');\n            };\n            HooksDispatcherOnMountInDEV = {\n                readContext: function(context) {\n                    return readContext(context);\n                },\n                use: use,\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = 'useCallback';\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = 'useContext';\n                    mountHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = 'useEffect';\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = 'useImperativeHandle';\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = 'useInsertionEffect';\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = 'useLayoutEffect';\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = 'useMemo';\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountMemo(create, deps);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = 'useReducer';\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = 'useRef';\n                    mountHookTypesDev();\n                    return mountRef(initialValue);\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = 'useState';\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountState(initialState);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = 'useDebugValue';\n                    mountHookTypesDev();\n                    return mountDebugValue();\n                },\n                useDeferredValue: function(value, initialValue) {\n                    currentHookNameInDev = 'useDeferredValue';\n                    mountHookTypesDev();\n                    return mountDeferredValue(value, initialValue);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = 'useTransition';\n                    mountHookTypesDev();\n                    return mountTransition();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = 'useSyncExternalStore';\n                    mountHookTypesDev();\n                    return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = 'useId';\n                    mountHookTypesDev();\n                    return mountId();\n                }\n            };\n            {\n                HooksDispatcherOnMountInDEV.useCacheRefresh = function useCacheRefresh() {\n                    currentHookNameInDev = 'useCacheRefresh';\n                    mountHookTypesDev();\n                    return mountRefresh();\n                };\n            }\n            {\n                HooksDispatcherOnMountInDEV.useMemoCache = useMemoCache;\n            }\n            {\n                HooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;\n                HooksDispatcherOnMountInDEV.useFormState = function useFormState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useFormState';\n                    mountHookTypesDev();\n                    return mountActionState(action, initialState);\n                };\n                HooksDispatcherOnMountInDEV.useActionState = function useActionState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useActionState';\n                    mountHookTypesDev();\n                    return mountActionState(action, initialState);\n                };\n            }\n            {\n                HooksDispatcherOnMountInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {\n                    currentHookNameInDev = 'useOptimistic';\n                    mountHookTypesDev();\n                    return mountOptimistic(passthrough);\n                };\n            }\n            HooksDispatcherOnMountWithHookTypesInDEV = {\n                readContext: function(context) {\n                    return readContext(context);\n                },\n                use: use,\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = 'useCallback';\n                    updateHookTypesDev();\n                    return mountCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = 'useContext';\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = 'useEffect';\n                    updateHookTypesDev();\n                    return mountEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = 'useImperativeHandle';\n                    updateHookTypesDev();\n                    return mountImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = 'useInsertionEffect';\n                    updateHookTypesDev();\n                    return mountInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = 'useLayoutEffect';\n                    updateHookTypesDev();\n                    return mountLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = 'useMemo';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountMemo(create, deps);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = 'useReducer';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = 'useRef';\n                    updateHookTypesDev();\n                    return mountRef(initialValue);\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = 'useState';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountState(initialState);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = 'useDebugValue';\n                    updateHookTypesDev();\n                    return mountDebugValue();\n                },\n                useDeferredValue: function(value, initialValue) {\n                    currentHookNameInDev = 'useDeferredValue';\n                    updateHookTypesDev();\n                    return mountDeferredValue(value, initialValue);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = 'useTransition';\n                    updateHookTypesDev();\n                    return mountTransition();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = 'useSyncExternalStore';\n                    updateHookTypesDev();\n                    return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = 'useId';\n                    updateHookTypesDev();\n                    return mountId();\n                }\n            };\n            {\n                HooksDispatcherOnMountWithHookTypesInDEV.useCacheRefresh = function useCacheRefresh() {\n                    currentHookNameInDev = 'useCacheRefresh';\n                    updateHookTypesDev();\n                    return mountRefresh();\n                };\n            }\n            {\n                HooksDispatcherOnMountWithHookTypesInDEV.useMemoCache = useMemoCache;\n            }\n            {\n                HooksDispatcherOnMountWithHookTypesInDEV.useHostTransitionStatus = useHostTransitionStatus;\n                HooksDispatcherOnMountWithHookTypesInDEV.useFormState = function useFormState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useFormState';\n                    updateHookTypesDev();\n                    warnOnUseFormStateInDev();\n                    return mountActionState(action, initialState);\n                };\n                HooksDispatcherOnMountWithHookTypesInDEV.useActionState = function useActionState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useActionState';\n                    updateHookTypesDev();\n                    return mountActionState(action, initialState);\n                };\n            }\n            {\n                HooksDispatcherOnMountWithHookTypesInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {\n                    currentHookNameInDev = 'useOptimistic';\n                    updateHookTypesDev();\n                    return mountOptimistic(passthrough);\n                };\n            }\n            HooksDispatcherOnUpdateInDEV = {\n                readContext: function(context) {\n                    return readContext(context);\n                },\n                use: use,\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = 'useCallback';\n                    updateHookTypesDev();\n                    return updateCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = 'useContext';\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = 'useEffect';\n                    updateHookTypesDev();\n                    return updateEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = 'useImperativeHandle';\n                    updateHookTypesDev();\n                    return updateImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = 'useInsertionEffect';\n                    updateHookTypesDev();\n                    return updateInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = 'useLayoutEffect';\n                    updateHookTypesDev();\n                    return updateLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = 'useMemo';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateMemo(create, deps);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = 'useReducer';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = 'useRef';\n                    updateHookTypesDev();\n                    return updateRef();\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = 'useState';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateState(initialState);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = 'useDebugValue';\n                    updateHookTypesDev();\n                    return updateDebugValue();\n                },\n                useDeferredValue: function(value, initialValue) {\n                    currentHookNameInDev = 'useDeferredValue';\n                    updateHookTypesDev();\n                    return updateDeferredValue(value, initialValue);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = 'useTransition';\n                    updateHookTypesDev();\n                    return updateTransition();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = 'useSyncExternalStore';\n                    updateHookTypesDev();\n                    return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = 'useId';\n                    updateHookTypesDev();\n                    return updateId();\n                }\n            };\n            {\n                HooksDispatcherOnUpdateInDEV.useCacheRefresh = function useCacheRefresh() {\n                    currentHookNameInDev = 'useCacheRefresh';\n                    updateHookTypesDev();\n                    return updateRefresh();\n                };\n            }\n            {\n                HooksDispatcherOnUpdateInDEV.useMemoCache = useMemoCache;\n            }\n            {\n                HooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;\n                HooksDispatcherOnUpdateInDEV.useFormState = function useFormState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useFormState';\n                    updateHookTypesDev();\n                    warnOnUseFormStateInDev();\n                    return updateActionState(action);\n                };\n                HooksDispatcherOnUpdateInDEV.useActionState = function useActionState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useActionState';\n                    updateHookTypesDev();\n                    return updateActionState(action);\n                };\n            }\n            {\n                HooksDispatcherOnUpdateInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {\n                    currentHookNameInDev = 'useOptimistic';\n                    updateHookTypesDev();\n                    return updateOptimistic(passthrough, reducer);\n                };\n            }\n            HooksDispatcherOnRerenderInDEV = {\n                readContext: function(context) {\n                    return readContext(context);\n                },\n                use: use,\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = 'useCallback';\n                    updateHookTypesDev();\n                    return updateCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = 'useContext';\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = 'useEffect';\n                    updateHookTypesDev();\n                    return updateEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = 'useImperativeHandle';\n                    updateHookTypesDev();\n                    return updateImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = 'useInsertionEffect';\n                    updateHookTypesDev();\n                    return updateInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = 'useLayoutEffect';\n                    updateHookTypesDev();\n                    return updateLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = 'useMemo';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n                    try {\n                        return updateMemo(create, deps);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = 'useReducer';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n                    try {\n                        return rerenderReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = 'useRef';\n                    updateHookTypesDev();\n                    return updateRef();\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = 'useState';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n                    try {\n                        return rerenderState(initialState);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = 'useDebugValue';\n                    updateHookTypesDev();\n                    return updateDebugValue();\n                },\n                useDeferredValue: function(value, initialValue) {\n                    currentHookNameInDev = 'useDeferredValue';\n                    updateHookTypesDev();\n                    return rerenderDeferredValue(value, initialValue);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = 'useTransition';\n                    updateHookTypesDev();\n                    return rerenderTransition();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = 'useSyncExternalStore';\n                    updateHookTypesDev();\n                    return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = 'useId';\n                    updateHookTypesDev();\n                    return updateId();\n                }\n            };\n            {\n                HooksDispatcherOnRerenderInDEV.useCacheRefresh = function useCacheRefresh() {\n                    currentHookNameInDev = 'useCacheRefresh';\n                    updateHookTypesDev();\n                    return updateRefresh();\n                };\n            }\n            {\n                HooksDispatcherOnRerenderInDEV.useMemoCache = useMemoCache;\n            }\n            {\n                HooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;\n                HooksDispatcherOnRerenderInDEV.useFormState = function useFormState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useFormState';\n                    updateHookTypesDev();\n                    warnOnUseFormStateInDev();\n                    return rerenderActionState(action);\n                };\n                HooksDispatcherOnRerenderInDEV.useActionState = function useActionState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useActionState';\n                    updateHookTypesDev();\n                    return rerenderActionState(action);\n                };\n            }\n            {\n                HooksDispatcherOnRerenderInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {\n                    currentHookNameInDev = 'useOptimistic';\n                    updateHookTypesDev();\n                    return rerenderOptimistic(passthrough, reducer);\n                };\n            }\n            InvalidNestedHooksDispatcherOnMountInDEV = {\n                readContext: function(context) {\n                    warnInvalidContextAccess();\n                    return readContext(context);\n                },\n                use: function(usable) {\n                    warnInvalidHookAccess();\n                    return use(usable);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = 'useCallback';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = 'useContext';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = 'useEffect';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = 'useImperativeHandle';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = 'useInsertionEffect';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = 'useLayoutEffect';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = 'useMemo';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountMemo(create, deps);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = 'useReducer';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = 'useRef';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountRef(initialValue);\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = 'useState';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountState(initialState);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = 'useDebugValue';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountDebugValue();\n                },\n                useDeferredValue: function(value, initialValue) {\n                    currentHookNameInDev = 'useDeferredValue';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountDeferredValue(value, initialValue);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = 'useTransition';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountTransition();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = 'useSyncExternalStore';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = 'useId';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountId();\n                }\n            };\n            {\n                InvalidNestedHooksDispatcherOnMountInDEV.useCacheRefresh = function useCacheRefresh() {\n                    currentHookNameInDev = 'useCacheRefresh';\n                    mountHookTypesDev();\n                    return mountRefresh();\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnMountInDEV.useMemoCache = function(size) {\n                    warnInvalidHookAccess();\n                    return useMemoCache(size);\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;\n                InvalidNestedHooksDispatcherOnMountInDEV.useFormState = function useFormState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useFormState';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountActionState(action, initialState);\n                };\n                InvalidNestedHooksDispatcherOnMountInDEV.useActionState = function useActionState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useActionState';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountActionState(action, initialState);\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnMountInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {\n                    currentHookNameInDev = 'useOptimistic';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountOptimistic(passthrough);\n                };\n            }\n            InvalidNestedHooksDispatcherOnUpdateInDEV = {\n                readContext: function(context) {\n                    warnInvalidContextAccess();\n                    return readContext(context);\n                },\n                use: function(usable) {\n                    warnInvalidHookAccess();\n                    return use(usable);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = 'useCallback';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = 'useContext';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = 'useEffect';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = 'useImperativeHandle';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = 'useInsertionEffect';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = 'useLayoutEffect';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = 'useMemo';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateMemo(create, deps);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = 'useReducer';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = 'useRef';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateRef();\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = 'useState';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateState(initialState);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = 'useDebugValue';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateDebugValue();\n                },\n                useDeferredValue: function(value, initialValue) {\n                    currentHookNameInDev = 'useDeferredValue';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateDeferredValue(value, initialValue);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = 'useTransition';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateTransition();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = 'useSyncExternalStore';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = 'useId';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateId();\n                }\n            };\n            {\n                InvalidNestedHooksDispatcherOnUpdateInDEV.useCacheRefresh = function useCacheRefresh() {\n                    currentHookNameInDev = 'useCacheRefresh';\n                    updateHookTypesDev();\n                    return updateRefresh();\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnUpdateInDEV.useMemoCache = function(size) {\n                    warnInvalidHookAccess();\n                    return useMemoCache(size);\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;\n                InvalidNestedHooksDispatcherOnUpdateInDEV.useFormState = function useFormState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useFormState';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateActionState(action);\n                };\n                InvalidNestedHooksDispatcherOnUpdateInDEV.useActionState = function useActionState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useActionState';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateActionState(action);\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnUpdateInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {\n                    currentHookNameInDev = 'useOptimistic';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateOptimistic(passthrough, reducer);\n                };\n            }\n            InvalidNestedHooksDispatcherOnRerenderInDEV = {\n                readContext: function(context) {\n                    warnInvalidContextAccess();\n                    return readContext(context);\n                },\n                use: function(usable) {\n                    warnInvalidHookAccess();\n                    return use(usable);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = 'useCallback';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = 'useContext';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = 'useEffect';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = 'useImperativeHandle';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = 'useInsertionEffect';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = 'useLayoutEffect';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = 'useMemo';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateMemo(create, deps);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = 'useReducer';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return rerenderReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = 'useRef';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateRef();\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = 'useState';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return rerenderState(initialState);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = 'useDebugValue';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateDebugValue();\n                },\n                useDeferredValue: function(value, initialValue) {\n                    currentHookNameInDev = 'useDeferredValue';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return rerenderDeferredValue(value, initialValue);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = 'useTransition';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return rerenderTransition();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = 'useSyncExternalStore';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = 'useId';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateId();\n                }\n            };\n            {\n                InvalidNestedHooksDispatcherOnRerenderInDEV.useCacheRefresh = function useCacheRefresh() {\n                    currentHookNameInDev = 'useCacheRefresh';\n                    updateHookTypesDev();\n                    return updateRefresh();\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnRerenderInDEV.useMemoCache = function(size) {\n                    warnInvalidHookAccess();\n                    return useMemoCache(size);\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;\n                InvalidNestedHooksDispatcherOnRerenderInDEV.useFormState = function useFormState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useFormState';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return rerenderActionState(action);\n                };\n                InvalidNestedHooksDispatcherOnRerenderInDEV.useActionState = function useActionState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useActionState';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return rerenderActionState(action);\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnRerenderInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {\n                    currentHookNameInDev = 'useOptimistic';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return rerenderOptimistic(passthrough, reducer);\n                };\n            }\n        }\n        var now = Scheduler.unstable_now;\n        var commitTime = 0;\n        var layoutEffectStartTime = -1;\n        var profilerStartTime = -1;\n        var passiveEffectStartTime = -1;\n        /**\n * Tracks whether the current update was a nested/cascading update (scheduled from a layout effect).\n *\n * The overall sequence is:\n *   1. render\n *   2. commit (and call `onRender`, `onCommit`)\n *   3. check for nested updates\n *   4. flush passive effects (and call `onPostCommit`)\n *\n * Nested updates are identified in step 3 above,\n * but step 4 still applies to the work that was just committed.\n * We use two flags to track nested updates then:\n * one tracks whether the upcoming update is a nested update,\n * and the other tracks whether the current update was a nested update.\n * The first value gets synced to the second at the start of the render phase.\n */ var currentUpdateIsNested = false;\n        var nestedUpdateScheduled = false;\n        function isCurrentUpdateNested() {\n            return currentUpdateIsNested;\n        }\n        function markNestedUpdateScheduled() {\n            {\n                nestedUpdateScheduled = true;\n            }\n        }\n        function resetNestedUpdateFlag() {\n            {\n                currentUpdateIsNested = false;\n                nestedUpdateScheduled = false;\n            }\n        }\n        function syncNestedUpdateFlag() {\n            {\n                currentUpdateIsNested = nestedUpdateScheduled;\n                nestedUpdateScheduled = false;\n            }\n        }\n        function getCommitTime() {\n            return commitTime;\n        }\n        function recordCommitTime() {\n            commitTime = now();\n        }\n        function startProfilerTimer(fiber) {\n            profilerStartTime = now();\n            if (fiber.actualStartTime < 0) {\n                fiber.actualStartTime = now();\n            }\n        }\n        function stopProfilerTimerIfRunning(fiber) {\n            profilerStartTime = -1;\n        }\n        function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {\n            if (profilerStartTime >= 0) {\n                var elapsedTime = now() - profilerStartTime;\n                fiber.actualDuration += elapsedTime;\n                if (overrideBaseTime) {\n                    fiber.selfBaseDuration = elapsedTime;\n                }\n                profilerStartTime = -1;\n            }\n        }\n        function recordLayoutEffectDuration(fiber) {\n            if (layoutEffectStartTime >= 0) {\n                var elapsedTime = now() - layoutEffectStartTime;\n                layoutEffectStartTime = -1; // Store duration on the next nearest Profiler ancestor\n                // Or the root (for the DevTools Profiler to read)\n                var parentFiber = fiber.return;\n                while(parentFiber !== null){\n                    switch(parentFiber.tag){\n                        case HostRoot:\n                            var root = parentFiber.stateNode;\n                            root.effectDuration += elapsedTime;\n                            return;\n                        case Profiler:\n                            var parentStateNode = parentFiber.stateNode;\n                            parentStateNode.effectDuration += elapsedTime;\n                            return;\n                    }\n                    parentFiber = parentFiber.return;\n                }\n            }\n        }\n        function recordPassiveEffectDuration(fiber) {\n            if (passiveEffectStartTime >= 0) {\n                var elapsedTime = now() - passiveEffectStartTime;\n                passiveEffectStartTime = -1; // Store duration on the next nearest Profiler ancestor\n                // Or the root (for the DevTools Profiler to read)\n                var parentFiber = fiber.return;\n                while(parentFiber !== null){\n                    switch(parentFiber.tag){\n                        case HostRoot:\n                            var root = parentFiber.stateNode;\n                            if (root !== null) {\n                                root.passiveEffectDuration += elapsedTime;\n                            }\n                            return;\n                        case Profiler:\n                            var parentStateNode = parentFiber.stateNode;\n                            if (parentStateNode !== null) {\n                                // Detached fibers have their state node cleared out.\n                                // In this case, the return pointer is also cleared out,\n                                // so we won't be able to report the time spent in this Profiler's subtree.\n                                parentStateNode.passiveEffectDuration += elapsedTime;\n                            }\n                            return;\n                    }\n                    parentFiber = parentFiber.return;\n                }\n            }\n        }\n        function startLayoutEffectTimer() {\n            layoutEffectStartTime = now();\n        }\n        function startPassiveEffectTimer() {\n            passiveEffectStartTime = now();\n        }\n        function transferActualDuration(fiber) {\n            // Transfer time spent rendering these children so we don't lose it\n            // after we rerender. This is used as a helper in special cases\n            // where we should count the work of multiple passes.\n            var child = fiber.child;\n            while(child){\n                // $FlowFixMe[unsafe-addition] addition with possible null/undefined value\n                fiber.actualDuration += child.actualDuration;\n                child = child.sibling;\n            }\n        }\n        var fakeInternalInstance = {};\n        var didWarnAboutStateAssignmentForComponent;\n        var didWarnAboutUninitializedState;\n        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\n        var didWarnAboutLegacyLifecyclesAndDerivedState;\n        var didWarnAboutUndefinedDerivedState;\n        var didWarnAboutDirectlyAssigningPropsToState;\n        var didWarnAboutInvalidateContextType;\n        var didWarnOnInvalidCallback;\n        {\n            didWarnAboutStateAssignmentForComponent = new Set();\n            didWarnAboutUninitializedState = new Set();\n            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n            didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n            didWarnAboutDirectlyAssigningPropsToState = new Set();\n            didWarnAboutUndefinedDerivedState = new Set();\n            didWarnAboutInvalidateContextType = new Set();\n            didWarnOnInvalidCallback = new Set(); // This is so gross but it's at least non-critical and can be removed if\n            // it causes problems. This is meant to give a nicer error message for\n            // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n            // ...)) which otherwise throws a \"_processChildContext is not a function\"\n            // exception.\n            Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n                enumerable: false,\n                value: function() {\n                    throw new Error('_processChildContext is not available in React 16+. This likely ' + 'means you have multiple copies of React and are attempting to nest ' + 'a React 15 tree inside a React 16 tree using ' + \"unstable_renderSubtreeIntoContainer, which isn't supported. Try \" + 'to make sure you have only one copy of React (and ideally, switch ' + 'to ReactDOM.createPortal).');\n                }\n            });\n            Object.freeze(fakeInternalInstance);\n        }\n        function warnOnInvalidCallback(callback) {\n            {\n                if (callback === null || typeof callback === 'function') {\n                    return;\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var key = String(callback);\n                if (!didWarnOnInvalidCallback.has(key)) {\n                    didWarnOnInvalidCallback.add(key);\n                    error('Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n                }\n            }\n        }\n        function warnOnUndefinedDerivedState(type, partialState) {\n            {\n                if (partialState === undefined) {\n                    var componentName = getComponentNameFromType(type) || 'Component';\n                    if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n                        didWarnAboutUndefinedDerivedState.add(componentName);\n                        error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', componentName);\n                    }\n                }\n            }\n        }\n        function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {\n            var prevState = workInProgress.memoizedState;\n            var partialState = getDerivedStateFromProps(nextProps, prevState);\n            {\n                if (workInProgress.mode & StrictLegacyMode) {\n                    setIsStrictModeForDevtools(true);\n                    try {\n                        // Invoke the function an extra time to help detect side-effects.\n                        partialState = getDerivedStateFromProps(nextProps, prevState);\n                    } finally{\n                        setIsStrictModeForDevtools(false);\n                    }\n                }\n                warnOnUndefinedDerivedState(ctor, partialState);\n            }\n            var memoizedState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);\n            workInProgress.memoizedState = memoizedState; // Once the update queue is empty, persist the derived state onto the\n            // base state.\n            if (workInProgress.lanes === NoLanes) {\n                // Queue is always non-null for classes\n                var updateQueue = workInProgress.updateQueue;\n                updateQueue.baseState = memoizedState;\n            }\n        }\n        var classComponentUpdater = {\n            isMounted: isMounted,\n            // $FlowFixMe[missing-local-annot]\n            enqueueSetState: function(inst, payload, callback) {\n                var fiber = get(inst);\n                var lane = requestUpdateLane(fiber);\n                var update = createUpdate(lane);\n                update.payload = payload;\n                if (callback !== undefined && callback !== null) {\n                    {\n                        warnOnInvalidCallback(callback);\n                    }\n                    update.callback = callback;\n                }\n                var root = enqueueUpdate(fiber, update, lane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, lane);\n                    entangleTransitions(root, fiber, lane);\n                }\n                {\n                    markStateUpdateScheduled(fiber, lane);\n                }\n            },\n            enqueueReplaceState: function(inst, payload, callback) {\n                var fiber = get(inst);\n                var lane = requestUpdateLane(fiber);\n                var update = createUpdate(lane);\n                update.tag = ReplaceState;\n                update.payload = payload;\n                if (callback !== undefined && callback !== null) {\n                    {\n                        warnOnInvalidCallback(callback);\n                    }\n                    update.callback = callback;\n                }\n                var root = enqueueUpdate(fiber, update, lane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, lane);\n                    entangleTransitions(root, fiber, lane);\n                }\n                {\n                    markStateUpdateScheduled(fiber, lane);\n                }\n            },\n            // $FlowFixMe[missing-local-annot]\n            enqueueForceUpdate: function(inst, callback) {\n                var fiber = get(inst);\n                var lane = requestUpdateLane(fiber);\n                var update = createUpdate(lane);\n                update.tag = ForceUpdate;\n                if (callback !== undefined && callback !== null) {\n                    {\n                        warnOnInvalidCallback(callback);\n                    }\n                    update.callback = callback;\n                }\n                var root = enqueueUpdate(fiber, update, lane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, lane);\n                    entangleTransitions(root, fiber, lane);\n                }\n                {\n                    markForceUpdateScheduled(fiber, lane);\n                }\n            }\n        };\n        function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {\n            var instance = workInProgress.stateNode;\n            if (typeof instance.shouldComponentUpdate === 'function') {\n                var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n                {\n                    if (workInProgress.mode & StrictLegacyMode) {\n                        setIsStrictModeForDevtools(true);\n                        try {\n                            // Invoke the function an extra time to help detect side-effects.\n                            shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n                        } finally{\n                            setIsStrictModeForDevtools(false);\n                        }\n                    }\n                    if (shouldUpdate === undefined) {\n                        error('%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentNameFromType(ctor) || 'Component');\n                    }\n                }\n                return shouldUpdate;\n            }\n            if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n                return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n            }\n            return true;\n        }\n        function checkClassInstance(workInProgress, ctor, newProps) {\n            var instance = workInProgress.stateNode;\n            {\n                var name = getComponentNameFromType(ctor) || 'Component';\n                var renderPresent = instance.render;\n                if (!renderPresent) {\n                    if (ctor.prototype && typeof ctor.prototype.render === 'function') {\n                        error('No `render` method found on the %s ' + 'instance: did you accidentally return an object from the constructor?', name);\n                    } else {\n                        error('No `render` method found on the %s ' + 'instance: you may have forgotten to define `render`.', name);\n                    }\n                }\n                if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {\n                    error('getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);\n                }\n                if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {\n                    error('getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);\n                }\n                if (instance.propTypes) {\n                    error('propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);\n                }\n                if (instance.contextType) {\n                    error('contextType was defined as an instance property on %s. Use a static ' + 'property to define contextType instead.', name);\n                }\n                {\n                    if (ctor.childContextTypes) {\n                        error('%s uses the legacy childContextTypes API which was removed in React 19. ' + 'Use React.createContext() instead.', name);\n                    }\n                    if (ctor.contextTypes) {\n                        error('%s uses the legacy contextTypes API which was removed in React 19. ' + 'Use React.createContext() with static contextType instead.', name);\n                    }\n                }\n                if (typeof instance.componentShouldUpdate === 'function') {\n                    error('%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);\n                }\n                if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {\n                    error('%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentNameFromType(ctor) || 'A pure component');\n                }\n                if (typeof instance.componentDidUnmount === 'function') {\n                    error('%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);\n                }\n                if (typeof instance.componentDidReceiveProps === 'function') {\n                    error('%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);\n                }\n                if (typeof instance.componentWillRecieveProps === 'function') {\n                    error('%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);\n                }\n                if (typeof instance.UNSAFE_componentWillRecieveProps === 'function') {\n                    error('%s has a method called ' + 'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?', name);\n                }\n                var hasMutatedProps = instance.props !== newProps;\n                if (instance.props !== undefined && hasMutatedProps) {\n                    error('When calling super() in `%s`, make sure to pass ' + \"up the same props that your component's constructor was passed.\", name);\n                }\n                if (instance.defaultProps) {\n                    error('Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\n                    didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n                    error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' + 'This component defines getSnapshotBeforeUpdate() only.', getComponentNameFromType(ctor));\n                }\n                if (typeof instance.getDerivedStateFromProps === 'function') {\n                    error('%s: getDerivedStateFromProps() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);\n                }\n                if (typeof instance.getDerivedStateFromError === 'function') {\n                    error('%s: getDerivedStateFromError() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);\n                }\n                if (typeof ctor.getSnapshotBeforeUpdate === 'function') {\n                    error('%s: getSnapshotBeforeUpdate() is defined as a static method ' + 'and will be ignored. Instead, declare it as an instance method.', name);\n                }\n                var state = instance.state;\n                if (state && (typeof state !== 'object' || isArray(state))) {\n                    error('%s.state: must be set to an object or null', name);\n                }\n                if (typeof instance.getChildContext === 'function' && typeof ctor.childContextTypes !== 'object') {\n                    error('%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', name);\n                }\n            }\n        }\n        function constructClassInstance(workInProgress, ctor, props) {\n            var context = emptyContextObject;\n            var contextType = ctor.contextType;\n            {\n                if ('contextType' in ctor) {\n                    var isValid = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE;\n                    if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n                        didWarnAboutInvalidateContextType.add(ctor);\n                        var addendum = '';\n                        if (contextType === undefined) {\n                            addendum = ' However, it is set to undefined. ' + 'This can be caused by a typo or by mixing up named and default imports. ' + 'This can also happen due to a circular dependency, so ' + 'try moving the createContext() call to a separate file.';\n                        } else if (typeof contextType !== 'object') {\n                            addendum = ' However, it is set to a ' + typeof contextType + '.';\n                        } else if (contextType.$$typeof === REACT_CONSUMER_TYPE) {\n                            addendum = ' Did you accidentally pass the Context.Consumer instead?';\n                        } else {\n                            addendum = ' However, it is set to an object with keys {' + Object.keys(contextType).join(', ') + '}.';\n                        }\n                        error('%s defines an invalid contextType. ' + 'contextType should point to the Context object returned by React.createContext().%s', getComponentNameFromType(ctor) || 'Component', addendum);\n                    }\n                }\n            }\n            if (typeof contextType === 'object' && contextType !== null) {\n                context = readContext(contextType);\n            }\n            var instance = new ctor(props, context); // Instantiate twice to help detect side-effects.\n            {\n                if (workInProgress.mode & StrictLegacyMode) {\n                    setIsStrictModeForDevtools(true);\n                    try {\n                        instance = new ctor(props, context); // eslint-disable-line no-new\n                    } finally{\n                        setIsStrictModeForDevtools(false);\n                    }\n                }\n            }\n            var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;\n            instance.updater = classComponentUpdater;\n            workInProgress.stateNode = instance; // The instance needs access to the fiber so that it can schedule updates\n            set(instance, workInProgress);\n            {\n                instance._reactInternalInstance = fakeInternalInstance;\n            }\n            {\n                if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {\n                    var componentName = getComponentNameFromType(ctor) || 'Component';\n                    if (!didWarnAboutUninitializedState.has(componentName)) {\n                        didWarnAboutUninitializedState.add(componentName);\n                        error('`%s` uses `getDerivedStateFromProps` but its initial state is ' + '%s. This is not recommended. Instead, define the initial state by ' + 'assigning an object to `this.state` in the constructor of `%s`. ' + 'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.', componentName, instance.state === null ? 'null' : 'undefined', componentName);\n                    }\n                } // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n                // Warn about these lifecycles if they are present.\n                // Don't warn about react-lifecycles-compat polyfilled methods though.\n                if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {\n                    var foundWillMountName = null;\n                    var foundWillReceivePropsName = null;\n                    var foundWillUpdateName = null;\n                    if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                        foundWillMountName = 'componentWillMount';\n                    } else if (typeof instance.UNSAFE_componentWillMount === 'function') {\n                        foundWillMountName = 'UNSAFE_componentWillMount';\n                    }\n                    if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n                        foundWillReceivePropsName = 'componentWillReceiveProps';\n                    } else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n                        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n                    }\n                    if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n                        foundWillUpdateName = 'componentWillUpdate';\n                    } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n                        foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n                    }\n                    if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n                        var _componentName = getComponentNameFromType(ctor) || 'Component';\n                        var newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';\n                        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n                            didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n                            error('Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' + '%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n' + 'The above lifecycles should be removed. Learn more about this warning here:\\n' + 'https://react.dev/link/unsafe-component-lifecycles', _componentName, newApiName, foundWillMountName !== null ? \"\\n  \" + foundWillMountName : '', foundWillReceivePropsName !== null ? \"\\n  \" + foundWillReceivePropsName : '', foundWillUpdateName !== null ? \"\\n  \" + foundWillUpdateName : '');\n                        }\n                    }\n                }\n            }\n            return instance;\n        }\n        function callComponentWillMount(workInProgress, instance) {\n            var oldState = instance.state;\n            if (typeof instance.componentWillMount === 'function') {\n                instance.componentWillMount();\n            }\n            if (typeof instance.UNSAFE_componentWillMount === 'function') {\n                instance.UNSAFE_componentWillMount();\n            }\n            if (oldState !== instance.state) {\n                {\n                    error('%s.componentWillMount(): Assigning directly to this.state is ' + \"deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentNameFromFiber(workInProgress) || 'Component');\n                }\n                classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n            }\n        }\n        function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {\n            var oldState = instance.state;\n            if (typeof instance.componentWillReceiveProps === 'function') {\n                instance.componentWillReceiveProps(newProps, nextContext);\n            }\n            if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n                instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n            }\n            if (instance.state !== oldState) {\n                {\n                    var componentName = getComponentNameFromFiber(workInProgress) || 'Component';\n                    if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n                        didWarnAboutStateAssignmentForComponent.add(componentName);\n                        error('%s.componentWillReceiveProps(): Assigning directly to ' + \"this.state is deprecated (except inside a component's \" + 'constructor). Use setState instead.', componentName);\n                    }\n                }\n                classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n            }\n        } // Invokes the mount life-cycles on a previously never rendered instance.\n        function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {\n            {\n                checkClassInstance(workInProgress, ctor, newProps);\n            }\n            var instance = workInProgress.stateNode;\n            instance.props = newProps;\n            instance.state = workInProgress.memoizedState;\n            instance.refs = {};\n            initializeUpdateQueue(workInProgress);\n            var contextType = ctor.contextType;\n            if (typeof contextType === 'object' && contextType !== null) {\n                instance.context = readContext(contextType);\n            } else {\n                instance.context = emptyContextObject;\n            }\n            {\n                if (instance.state === newProps) {\n                    var componentName = getComponentNameFromType(ctor) || 'Component';\n                    if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n                        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n                        error('%s: It is not recommended to assign props directly to state ' + \"because updates to props won't be reflected in state. \" + 'In most cases, it is better to use props directly.', componentName);\n                    }\n                }\n                if (workInProgress.mode & StrictLegacyMode) {\n                    ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);\n                }\n                ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);\n            }\n            instance.state = workInProgress.memoizedState;\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n            if (typeof getDerivedStateFromProps === 'function') {\n                applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n                instance.state = workInProgress.memoizedState;\n            } // In order to support react-lifecycles-compat polyfilled components,\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\n            if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n                callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's\n                // process them now.\n                processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n                suspendIfUpdateReadFromEntangledAsyncAction();\n                instance.state = workInProgress.memoizedState;\n            }\n            if (typeof instance.componentDidMount === 'function') {\n                workInProgress.flags |= Update | LayoutStatic;\n            }\n            if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                workInProgress.flags |= MountLayoutDev;\n            }\n        }\n        function resumeMountClassInstance(workInProgress, ctor, newProps, renderLanes) {\n            var instance = workInProgress.stateNode;\n            var unresolvedOldProps = workInProgress.memoizedProps;\n            var oldProps = resolveClassComponentProps(ctor, unresolvedOldProps);\n            instance.props = oldProps;\n            var oldContext = instance.context;\n            var contextType = ctor.contextType;\n            var nextContext = emptyContextObject;\n            if (typeof contextType === 'object' && contextType !== null) {\n                nextContext = readContext(contextType);\n            }\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n            var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // When comparing whether props changed, we should compare using the\n            // unresolved props object that is stored on the fiber, rather than the\n            // one that gets assigned to the instance, because that object may have been\n            // cloned to resolve default props and/or remove `ref`.\n            var unresolvedNewProps = workInProgress.pendingProps;\n            var didReceiveNewProps = unresolvedNewProps !== unresolvedOldProps; // Note: During these life-cycles, instance.props/instance.state are what\n            // ever the previously attempted to render - not the \"current\". However,\n            // during componentDidUpdate we pass the \"current\" props.\n            // In order to support react-lifecycles-compat polyfilled components,\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\n            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n                if (didReceiveNewProps || oldContext !== nextContext) {\n                    callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n                }\n            }\n            resetHasForceUpdateBeforeProcessing();\n            var oldState = workInProgress.memoizedState;\n            var newState = instance.state = oldState;\n            processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n            suspendIfUpdateReadFromEntangledAsyncAction();\n            newState = workInProgress.memoizedState;\n            if (!didReceiveNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\n                // If an update was already in progress, we should schedule an Update\n                // effect even though we're bailing out, so that cWU/cDU are called.\n                if (typeof instance.componentDidMount === 'function') {\n                    workInProgress.flags |= Update | LayoutStatic;\n                }\n                if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                    workInProgress.flags |= MountLayoutDev;\n                }\n                return false;\n            }\n            if (typeof getDerivedStateFromProps === 'function') {\n                applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n                newState = workInProgress.memoizedState;\n            }\n            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);\n            if (shouldUpdate) {\n                // In order to support react-lifecycles-compat polyfilled components,\n                // Unsafe lifecycles should not be invoked for components using the new APIs.\n                if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n                    if (typeof instance.componentWillMount === 'function') {\n                        instance.componentWillMount();\n                    }\n                    if (typeof instance.UNSAFE_componentWillMount === 'function') {\n                        instance.UNSAFE_componentWillMount();\n                    }\n                }\n                if (typeof instance.componentDidMount === 'function') {\n                    workInProgress.flags |= Update | LayoutStatic;\n                }\n                if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                    workInProgress.flags |= MountLayoutDev;\n                }\n            } else {\n                // If an update was already in progress, we should schedule an Update\n                // effect even though we're bailing out, so that cWU/cDU are called.\n                if (typeof instance.componentDidMount === 'function') {\n                    workInProgress.flags |= Update | LayoutStatic;\n                }\n                if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                    workInProgress.flags |= MountLayoutDev;\n                } // If shouldComponentUpdate returned false, we should still update the\n                // memoized state to indicate that this work can be reused.\n                workInProgress.memoizedProps = newProps;\n                workInProgress.memoizedState = newState;\n            } // Update the existing instance's state, props, and context pointers even\n            // if shouldComponentUpdate returns false.\n            instance.props = newProps;\n            instance.state = newState;\n            instance.context = nextContext;\n            return shouldUpdate;\n        } // Invokes the update life-cycles and returns false if it shouldn't rerender.\n        function updateClassInstance(current, workInProgress, ctor, newProps, renderLanes) {\n            var instance = workInProgress.stateNode;\n            cloneUpdateQueue(current, workInProgress);\n            var unresolvedOldProps = workInProgress.memoizedProps;\n            var oldProps = resolveClassComponentProps(ctor, unresolvedOldProps);\n            instance.props = oldProps;\n            var unresolvedNewProps = workInProgress.pendingProps;\n            var oldContext = instance.context;\n            var contextType = ctor.contextType;\n            var nextContext = emptyContextObject;\n            if (typeof contextType === 'object' && contextType !== null) {\n                nextContext = readContext(contextType);\n            }\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n            var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what\n            // ever the previously attempted to render - not the \"current\". However,\n            // during componentDidUpdate we pass the \"current\" props.\n            // In order to support react-lifecycles-compat polyfilled components,\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\n            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n                if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {\n                    callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n                }\n            }\n            resetHasForceUpdateBeforeProcessing();\n            var oldState = workInProgress.memoizedState;\n            var newState = instance.state = oldState;\n            processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n            suspendIfUpdateReadFromEntangledAsyncAction();\n            newState = workInProgress.memoizedState;\n            if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation) {\n                // If an update was already in progress, we should schedule an Update\n                // effect even though we're bailing out, so that cWU/cDU are called.\n                if (typeof instance.componentDidUpdate === 'function') {\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n                        workInProgress.flags |= Update;\n                    }\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n                        workInProgress.flags |= Snapshot;\n                    }\n                }\n                return false;\n            }\n            if (typeof getDerivedStateFromProps === 'function') {\n                applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n                newState = workInProgress.memoizedState;\n            }\n            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,\n            // both before and after `shouldComponentUpdate` has been called. Not ideal,\n            // but I'm loath to refactor this function. This only happens for memoized\n            // components so it's not that common.\n            enableLazyContextPropagation;\n            if (shouldUpdate) {\n                // In order to support react-lifecycles-compat polyfilled components,\n                // Unsafe lifecycles should not be invoked for components using the new APIs.\n                if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === 'function' || typeof instance.componentWillUpdate === 'function')) {\n                    if (typeof instance.componentWillUpdate === 'function') {\n                        instance.componentWillUpdate(newProps, newState, nextContext);\n                    }\n                    if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n                        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);\n                    }\n                }\n                if (typeof instance.componentDidUpdate === 'function') {\n                    workInProgress.flags |= Update;\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n                    workInProgress.flags |= Snapshot;\n                }\n            } else {\n                // If an update was already in progress, we should schedule an Update\n                // effect even though we're bailing out, so that cWU/cDU are called.\n                if (typeof instance.componentDidUpdate === 'function') {\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n                        workInProgress.flags |= Update;\n                    }\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n                        workInProgress.flags |= Snapshot;\n                    }\n                } // If shouldComponentUpdate returned false, we should still update the\n                // memoized props/state to indicate that this work can be reused.\n                workInProgress.memoizedProps = newProps;\n                workInProgress.memoizedState = newState;\n            } // Update the existing instance's state, props, and context pointers even\n            // if shouldComponentUpdate returns false.\n            instance.props = newProps;\n            instance.state = newState;\n            instance.context = nextContext;\n            return shouldUpdate;\n        }\n        function resolveClassComponentProps(Component, baseProps, // would have already been resolved by the JSX runtime.\n        // TODO: We're going to remove default prop resolution from the JSX runtime\n        // and keep it only for class components. As part of that change, we should\n        // remove this extra check.\n        alreadyResolvedDefaultProps) {\n            var newProps = baseProps;\n            {\n                // Remove ref from the props object, if it exists.\n                if ('ref' in baseProps) {\n                    newProps = {};\n                    for(var propName in baseProps){\n                        if (propName !== 'ref') {\n                            newProps[propName] = baseProps[propName];\n                        }\n                    }\n                }\n            }\n            var defaultProps = Component.defaultProps;\n            if (defaultProps && // default props here in the reconciler, rather than in the JSX runtime.\n            disableDefaultPropsExceptForClasses) {\n                // We may have already copied the props object above to remove ref. If so,\n                // we can modify that. Otherwise, copy the props object with Object.assign.\n                if (newProps === baseProps) {\n                    newProps = assign({}, newProps);\n                } // Taken from old JSX runtime, where this used to live.\n                for(var _propName in defaultProps){\n                    if (newProps[_propName] === undefined) {\n                        newProps[_propName] = defaultProps[_propName];\n                    }\n                }\n            }\n            return newProps;\n        }\n        var reportGlobalError = typeof reportError === 'function' ? // emulating an uncaught JavaScript error.\n        reportError : function(error) {\n            if (false) { var shouldLog, event, message; } else if (typeof process === 'object' && // $FlowFixMe[method-unbinding]\n            typeof process.emit === 'function') {\n                // Node Polyfill\n                process.emit('uncaughtException', error);\n                return;\n            } // eslint-disable-next-line react-internal/no-production-logging\n            console['error'](error);\n        };\n        var componentName = null;\n        var errorBoundaryName = null;\n        function defaultOnUncaughtError(error, errorInfo) {\n            // Overriding this can silence these warnings e.g. for tests.\n            // See https://github.com/facebook/react/pull/13384\n            // For uncaught root errors we report them as uncaught to the browser's\n            // onerror callback. This won't have component stacks and the error addendum.\n            // So we add those into a separate console.warn.\n            reportGlobalError(error);\n            {\n                var componentNameMessage = componentName ? \"An error occurred in the <\" + componentName + \"> component.\" : 'An error occurred in one of your React components.';\n                var errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\\n' + 'Visit https://react.dev/link/error-boundaries to learn more about error boundaries.';\n                {\n                    // The current Fiber is disconnected at this point which means that console printing\n                    // cannot add a component stack since it terminates at the deletion node. This is not\n                    // a problem for owner stacks which are not disconnected but for the parent component\n                    // stacks we need to use the snapshot we've previously extracted.\n                    var componentStack = errorInfo.componentStack != null ? errorInfo.componentStack : ''; // Don't transform to our wrapper\n                    console['warn']('%s\\n\\n%s\\n%s', componentNameMessage, errorBoundaryMessage, componentStack);\n                }\n            }\n        }\n        function defaultOnCaughtError(error$1, errorInfo) {\n            // Overriding this can silence these warnings e.g. for tests.\n            // See https://github.com/facebook/react/pull/13384\n            // Caught by error boundary\n            {\n                var componentNameMessage = componentName ? \"The above error occurred in the <\" + componentName + \"> component.\" : 'The above error occurred in one of your React components.'; // In development, we provide our own message which includes the component stack\n                // in addition to the error.\n                var recreateMessage = \"React will try to recreate this component tree from scratch \" + (\"using the error boundary you provided, \" + (errorBoundaryName || 'Anonymous') + \".\");\n                {\n                    // The current Fiber is disconnected at this point which means that console printing\n                    // cannot add a component stack since it terminates at the deletion node. This is not\n                    // a problem for owner stacks which are not disconnected but for the parent component\n                    // stacks we need to use the snapshot we've previously extracted.\n                    var componentStack = errorInfo.componentStack != null ? errorInfo.componentStack : ''; // Don't transform to our wrapper\n                    console['error']('%o\\n\\n%s\\n\\n%s\\n%s', error$1, componentNameMessage, recreateMessage, componentStack);\n                }\n            }\n        }\n        function defaultOnRecoverableError(error, errorInfo) {\n            reportGlobalError(error);\n        }\n        function logUncaughtError(root, errorInfo) {\n            try {\n                if (true) {\n                    componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;\n                    errorBoundaryName = null;\n                }\n                var error = errorInfo.value;\n                if ( true && ReactSharedInternals.actQueue !== null) {\n                    // For uncaught errors inside act, we track them on the act and then\n                    // rethrow them into the test.\n                    ReactSharedInternals.thrownErrors.push(error);\n                    return;\n                }\n                var onUncaughtError = root.onUncaughtError;\n                onUncaughtError(error, {\n                    componentStack: errorInfo.stack\n                });\n            } catch (e) {\n                // This method must not throw, or React internal state will get messed up.\n                // If console.error is overridden, or logCapturedError() shows a dialog that throws,\n                // we want to report this error outside of the normal stack as a last resort.\n                // https://github.com/facebook/react/issues/13188\n                setTimeout(function() {\n                    throw e;\n                });\n            }\n        }\n        function logCaughtError(root, boundary, errorInfo) {\n            try {\n                if (true) {\n                    componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;\n                    errorBoundaryName = getComponentNameFromFiber(boundary);\n                }\n                var error = errorInfo.value;\n                var onCaughtError = root.onCaughtError;\n                onCaughtError(error, {\n                    componentStack: errorInfo.stack,\n                    errorBoundary: boundary.tag === ClassComponent ? boundary.stateNode // This should always be the case as long as we only have class boundaries\n                     : null\n                });\n            } catch (e) {\n                // This method must not throw, or React internal state will get messed up.\n                // If console.error is overridden, or logCapturedError() shows a dialog that throws,\n                // we want to report this error outside of the normal stack as a last resort.\n                // https://github.com/facebook/react/issues/13188\n                setTimeout(function() {\n                    throw e;\n                });\n            }\n        }\n        function createRootErrorUpdate(root, errorInfo, lane) {\n            var update = createUpdate(lane); // Unmount the root by rendering null.\n            update.tag = CaptureUpdate; // Caution: React DevTools currently depends on this property\n            // being called \"element\".\n            update.payload = {\n                element: null\n            };\n            update.callback = function() {\n                var prevFiber = getCurrentFiber(); // should just be the root\n                setCurrentDebugFiberInDEV(errorInfo.source);\n                logUncaughtError(root, errorInfo);\n                setCurrentDebugFiberInDEV(prevFiber);\n            };\n            return update;\n        }\n        function createClassErrorUpdate(lane) {\n            var update = createUpdate(lane);\n            update.tag = CaptureUpdate;\n            return update;\n        }\n        function initializeClassErrorUpdate(update, root, fiber, errorInfo) {\n            var getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n            if (typeof getDerivedStateFromError === 'function') {\n                var error$1 = errorInfo.value;\n                update.payload = function() {\n                    return getDerivedStateFromError(error$1);\n                };\n                update.callback = function() {\n                    {\n                        markFailedErrorBoundaryForHotReloading(fiber);\n                    }\n                    var prevFiber = getCurrentFiber(); // should be the error boundary\n                    setCurrentDebugFiberInDEV(errorInfo.source);\n                    logCaughtError(root, fiber, errorInfo);\n                    setCurrentDebugFiberInDEV(prevFiber);\n                };\n            }\n            var inst = fiber.stateNode;\n            if (inst !== null && typeof inst.componentDidCatch === 'function') {\n                // $FlowFixMe[missing-this-annot]\n                update.callback = function callback() {\n                    {\n                        markFailedErrorBoundaryForHotReloading(fiber);\n                    }\n                    var prevFiber = getCurrentFiber(); // should be the error boundary\n                    setCurrentDebugFiberInDEV(errorInfo.source);\n                    logCaughtError(root, fiber, errorInfo);\n                    setCurrentDebugFiberInDEV(prevFiber);\n                    if (typeof getDerivedStateFromError !== 'function') {\n                        // To preserve the preexisting retry behavior of error boundaries,\n                        // we keep track of which ones already failed during this batch.\n                        // This gets reset before we yield back to the browser.\n                        // TODO: Warn in strict mode if getDerivedStateFromError is\n                        // not defined.\n                        markLegacyErrorBoundaryAsFailed(this);\n                    }\n                    var error$1 = errorInfo.value;\n                    var stack = errorInfo.stack;\n                    this.componentDidCatch(error$1, {\n                        componentStack: stack !== null ? stack : ''\n                    });\n                    {\n                        if (typeof getDerivedStateFromError !== 'function') {\n                            // If componentDidCatch is the only error boundary method defined,\n                            // then it needs to call setState to recover from errors.\n                            // If no state update is scheduled then the boundary will swallow the error.\n                            if (!includesSomeLane(fiber.lanes, SyncLane)) {\n                                error('%s: Error boundaries should implement getDerivedStateFromError(). ' + 'In that method, return a state update to display an error message or fallback UI.', getComponentNameFromFiber(fiber) || 'Unknown');\n                            }\n                        }\n                    }\n                };\n            }\n        }\n        function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes) {\n            // with the normal suspend path.\n            //\n            // After this we'll use a set of heuristics to determine whether this\n            // render pass will run to completion or restart or \"suspend\" the commit.\n            // The actual logic for this is spread out in different places.\n            //\n            // This first principle is that if we're going to suspend when we complete\n            // a root, then we should also restart if we get an update or ping that\n            // might unsuspend it, and vice versa. The only reason to suspend is\n            // because you think you might want to restart before committing. However,\n            // it doesn't make sense to restart only while in the period we're suspended.\n            //\n            // Restarting too aggressively is also not good because it starves out any\n            // intermediate loading state. So we use heuristics to determine when.\n            // Suspense Heuristics\n            //\n            // If nothing threw a Promise or all the same fallbacks are already showing,\n            // then don't suspend/restart.\n            //\n            // If this is an initial render of a new tree of Suspense boundaries and\n            // those trigger a fallback, then don't suspend/restart. We want to ensure\n            // that we can show the initial loading state as quickly as possible.\n            //\n            // If we hit a \"Delayed\" case, such as when we'd switch from content back into\n            // a fallback, then we should always suspend/restart. Transitions apply\n            // to this case. If none is defined, JND is used instead.\n            //\n            // If we're already showing a fallback and it gets \"retried\", allowing us to show\n            // another level, but there's still an inner boundary that would show a fallback,\n            // then we suspend/restart for 500ms since the last time we showed a fallback\n            // anywhere in the tree. This effectively throttles progressive loading into a\n            // consistent train of commits. This also gives us an opportunity to restart to\n            // get to the completed state slightly earlier.\n            //\n            // If there's ambiguity due to batching it's resolved in preference of:\n            // 1) \"delayed\", 2) \"initial render\", 3) \"retry\".\n            //\n            // We want to ensure that a \"busy\" state doesn't get force committed. We want to\n            // ensure that new initial loading states can commit as soon as possible.\n            suspenseBoundary.flags |= ShouldCapture; // TODO: I think we can remove this, since we now use `DidCapture` in\n            // the begin phase to prevent an early bailout.\n            suspenseBoundary.lanes = rootRenderLanes;\n            return suspenseBoundary;\n        }\n        function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {\n            // The source fiber did not complete.\n            sourceFiber.flags |= Incomplete;\n            {\n                if (isDevToolsPresent) {\n                    // If we have pending work still, restore the original updaters\n                    restorePendingUpdaters(root, rootRenderLanes);\n                }\n            }\n            if (value !== null && typeof value === 'object') {\n                if (typeof value.then === 'function') {\n                    // This is a wakeable. The component suspended.\n                    var wakeable = value;\n                    {\n                        if (getIsHydrating() && disableLegacyMode) {\n                            markDidThrowWhileHydratingDEV();\n                        }\n                    }\n                    var suspenseBoundary = getSuspenseHandler();\n                    if (suspenseBoundary !== null) {\n                        switch(suspenseBoundary.tag){\n                            case SuspenseComponent:\n                                {\n                                    // If this suspense boundary is not already showing a fallback, mark\n                                    // the in-progress render as suspended. We try to perform this logic\n                                    // as soon as soon as possible during the render phase, so the work\n                                    // loop can know things like whether it's OK to switch to other tasks,\n                                    // or whether it can wait for data to resolve before continuing.\n                                    // TODO: Most of these checks are already performed when entering a\n                                    // Suspense boundary. We should track the information on the stack so\n                                    // we don't have to recompute it on demand. This would also allow us\n                                    // to unify with `use` which needs to perform this logic even sooner,\n                                    // before `throwException` is called.\n                                    {\n                                        if (getShellBoundary() === null) {\n                                            // Suspended in the \"shell\" of the app. This is an undesirable\n                                            // loading state. We should avoid committing this tree.\n                                            renderDidSuspendDelayIfPossible();\n                                        } else {\n                                            // If we suspended deeper than the shell, we don't need to delay\n                                            // the commmit. However, we still call renderDidSuspend if this is\n                                            // a new boundary, to tell the work loop that a new fallback has\n                                            // appeared during this render.\n                                            // TODO: Theoretically we should be able to delete this branch.\n                                            // It's currently used for two things: 1) to throttle the\n                                            // appearance of successive loading states, and 2) in\n                                            // SuspenseList, to determine whether the children include any\n                                            // pending fallbacks. For 1, we should apply throttling to all\n                                            // retries, not just ones that render an additional fallback. For\n                                            // 2, we should check subtreeFlags instead. Then we can delete\n                                            // this branch.\n                                            var current = suspenseBoundary.alternate;\n                                            if (current === null) {\n                                                renderDidSuspend();\n                                            }\n                                        }\n                                    }\n                                    suspenseBoundary.flags &= ~ForceClientRender;\n                                    markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes); // Retry listener\n                                    //\n                                    // If the fallback does commit, we need to attach a different type of\n                                    // listener. This one schedules an update on the Suspense boundary to\n                                    // turn the fallback state off.\n                                    //\n                                    // Stash the wakeable on the boundary fiber so we can access it in the\n                                    // commit phase.\n                                    //\n                                    // When the wakeable resolves, we'll attempt to render the boundary\n                                    // again (\"retry\").\n                                    // Check if this is a Suspensey resource. We do not attach retry\n                                    // listeners to these, because we don't actually need them for\n                                    // rendering. Only for committing. Instead, if a fallback commits\n                                    // and the only thing that suspended was a Suspensey resource, we\n                                    // retry immediately.\n                                    // TODO: Refactor throwException so that we don't have to do this type\n                                    // check. The caller already knows what the cause was.\n                                    var isSuspenseyResource = wakeable === noopSuspenseyCommitThenable;\n                                    if (isSuspenseyResource) {\n                                        suspenseBoundary.flags |= ScheduleRetry;\n                                    } else {\n                                        var retryQueue = suspenseBoundary.updateQueue;\n                                        if (retryQueue === null) {\n                                            suspenseBoundary.updateQueue = new Set([\n                                                wakeable\n                                            ]);\n                                        } else {\n                                            retryQueue.add(wakeable);\n                                        } // We only attach ping listeners in concurrent mode. Legacy\n                                        // Suspense always commits fallbacks synchronously, so there are\n                                        // no pings.\n                                        {\n                                            attachPingListener(root, wakeable, rootRenderLanes);\n                                        }\n                                    }\n                                    return false;\n                                }\n                            case OffscreenComponent:\n                                {\n                                    {\n                                        suspenseBoundary.flags |= ShouldCapture;\n                                        var _isSuspenseyResource = wakeable === noopSuspenseyCommitThenable;\n                                        if (_isSuspenseyResource) {\n                                            suspenseBoundary.flags |= ScheduleRetry;\n                                        } else {\n                                            var offscreenQueue = suspenseBoundary.updateQueue;\n                                            if (offscreenQueue === null) {\n                                                var newOffscreenQueue = {\n                                                    transitions: null,\n                                                    markerInstances: null,\n                                                    retryQueue: new Set([\n                                                        wakeable\n                                                    ])\n                                                };\n                                                suspenseBoundary.updateQueue = newOffscreenQueue;\n                                            } else {\n                                                var _retryQueue = offscreenQueue.retryQueue;\n                                                if (_retryQueue === null) {\n                                                    offscreenQueue.retryQueue = new Set([\n                                                        wakeable\n                                                    ]);\n                                                } else {\n                                                    _retryQueue.add(wakeable);\n                                                }\n                                            }\n                                            attachPingListener(root, wakeable, rootRenderLanes);\n                                        }\n                                        return false;\n                                    }\n                                }\n                        }\n                        throw new Error(\"Unexpected Suspense handler tag (\" + suspenseBoundary.tag + \"). This \" + 'is a bug in React.');\n                    } else {\n                        // No boundary was found. Unless this is a sync update, this is OK.\n                        // We can suspend and wait for more data to arrive.\n                        {\n                            // In a concurrent root, suspending without a Suspense boundary is\n                            // allowed. It will suspend indefinitely without committing.\n                            //\n                            // TODO: Should we have different behavior for discrete updates? What\n                            // about flushSync? Maybe it should put the tree into an inert state,\n                            // and potentially log a warning. Revisit this for a future release.\n                            attachPingListener(root, wakeable, rootRenderLanes);\n                            renderDidSuspendDelayIfPossible();\n                            return false;\n                        }\n                    }\n                }\n            } // This is a regular error, not a Suspense wakeable.\n            if (getIsHydrating() && disableLegacyMode) {\n                markDidThrowWhileHydratingDEV();\n                var _suspenseBoundary = getSuspenseHandler(); // If the error was thrown during hydration, we may be able to recover by\n                // discarding the dehydrated content and switching to a client render.\n                // Instead of surfacing the error, find the nearest Suspense boundary\n                // and render it again without hydration.\n                if (_suspenseBoundary !== null) {\n                    if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags$1) {\n                        // Set a flag to indicate that we should try rendering the normal\n                        // children again, not the fallback.\n                        _suspenseBoundary.flags |= ForceClientRender;\n                    }\n                    markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes); // Even though the user may not be affected by this error, we should\n                    // still log it so it can be fixed.\n                    if (value !== HydrationMismatchException) {\n                        var _wrapperError = new Error('There was an error while hydrating but React was able to recover by ' + 'instead client rendering from the nearest Suspense boundary.', {\n                            cause: value\n                        });\n                        queueHydrationError(createCapturedValueAtFiber(_wrapperError, sourceFiber));\n                    }\n                    return false;\n                } else {\n                    if (value !== HydrationMismatchException) {\n                        var _wrapperError2 = new Error('There was an error while hydrating but React was able to recover by ' + 'instead client rendering the entire root.', {\n                            cause: value\n                        });\n                        queueHydrationError(createCapturedValueAtFiber(_wrapperError2, sourceFiber));\n                    }\n                    var _workInProgress = root.current.alternate; // Schedule an update at the root to log the error but this shouldn't\n                    // actually happen because we should recover.\n                    _workInProgress.flags |= ShouldCapture;\n                    var lane = pickArbitraryLane(rootRenderLanes);\n                    _workInProgress.lanes = mergeLanes(_workInProgress.lanes, lane);\n                    var rootErrorInfo = createCapturedValueAtFiber(value, sourceFiber);\n                    var update = createRootErrorUpdate(_workInProgress.stateNode, rootErrorInfo, lane);\n                    enqueueCapturedUpdate(_workInProgress, update);\n                    renderDidError();\n                    return false;\n                }\n            }\n            var wrapperError = new Error('There was an error during concurrent rendering but React was able to recover by ' + 'instead synchronously rendering the entire root.', {\n                cause: value\n            });\n            queueConcurrentError(createCapturedValueAtFiber(wrapperError, sourceFiber));\n            renderDidError(); // We didn't find a boundary that could handle this type of exception. Start\n            // over and traverse parent path again, this time treating the exception\n            // as an error.\n            if (returnFiber === null) {\n                // There's no return fiber, which means the root errored. This should never\n                // happen. Return `true` to trigger a fatal error (panic).\n                return true;\n            }\n            var errorInfo = createCapturedValueAtFiber(value, sourceFiber);\n            var workInProgress = returnFiber;\n            do {\n                switch(workInProgress.tag){\n                    case HostRoot:\n                        {\n                            workInProgress.flags |= ShouldCapture;\n                            var _lane = pickArbitraryLane(rootRenderLanes);\n                            workInProgress.lanes = mergeLanes(workInProgress.lanes, _lane);\n                            var _update = createRootErrorUpdate(workInProgress.stateNode, errorInfo, _lane);\n                            enqueueCapturedUpdate(workInProgress, _update);\n                            return false;\n                        }\n                    case ClassComponent:\n                        // Capture and retry\n                        var ctor = workInProgress.type;\n                        var instance = workInProgress.stateNode;\n                        if ((workInProgress.flags & DidCapture) === NoFlags$1 && (typeof ctor.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance))) {\n                            workInProgress.flags |= ShouldCapture;\n                            var _lane2 = pickArbitraryLane(rootRenderLanes);\n                            workInProgress.lanes = mergeLanes(workInProgress.lanes, _lane2); // Schedule the error boundary to re-render using updated state\n                            var _update2 = createClassErrorUpdate(_lane2);\n                            initializeClassErrorUpdate(_update2, root, workInProgress, errorInfo);\n                            enqueueCapturedUpdate(workInProgress, _update2);\n                            return false;\n                        }\n                        break;\n                } // $FlowFixMe[incompatible-type] we bail out when we get a null\n                workInProgress = workInProgress.return;\n            }while (workInProgress !== null);\n            return false;\n        }\n        // into a dehydrated boundary.\n        var SelectiveHydrationException = new Error(\"This is not a real error. It's an implementation detail of React's \" + \"selective hydration feature. If this leaks into userspace, it's a bug in \" + 'React. Please file an issue.');\n        var didReceiveUpdate = false;\n        var didWarnAboutBadClass;\n        var didWarnAboutContextTypeOnFunctionComponent;\n        var didWarnAboutGetDerivedStateOnFunctionComponent;\n        var didWarnAboutReassigningProps;\n        var didWarnAboutRevealOrder;\n        var didWarnAboutTailOptions;\n        {\n            didWarnAboutBadClass = {};\n            didWarnAboutContextTypeOnFunctionComponent = {};\n            didWarnAboutGetDerivedStateOnFunctionComponent = {};\n            didWarnAboutReassigningProps = false;\n            didWarnAboutRevealOrder = {};\n            didWarnAboutTailOptions = {};\n        }\n        function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\n            if (current === null) {\n                // If this is a fresh new component that hasn't been rendered yet, we\n                // won't update its child set by applying minimal side-effects. Instead,\n                // we will add them all to the child before it gets rendered. That means\n                // we can optimize this reconciliation pass by not tracking side-effects.\n                workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n            } else {\n                // If the current child is the same as the work in progress, it means that\n                // we haven't yet started any work on these children. Therefore, we use\n                // the clone algorithm to create a copy of all the current children.\n                // If we had any progressed work already, that is invalid at this point so\n                // let's throw it out.\n                workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);\n            }\n        }\n        function forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes) {\n            // This function is fork of reconcileChildren. It's used in cases where we\n            // want to reconcile without matching against the existing set. This has the\n            // effect of all current children being unmounted; even if the type and key\n            // are the same, the old child is unmounted and a new child is created.\n            //\n            // To do this, we're going to go through the reconcile algorithm twice. In\n            // the first pass, we schedule a deletion for all the current children by\n            // passing null.\n            workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes); // In the second pass, we mount the new children. The trick here is that we\n            // pass null in place of where we usually pass the current child set. This has\n            // the effect of remounting all children regardless of whether their\n            // identities match.\n            workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n        }\n        function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {\n            // TODO: current can be non-null here even if the component\n            // hasn't yet mounted. This happens after the first render suspends.\n            // We'll need to figure out if this is fine or can cause issues.\n            var render = Component.render;\n            var ref = workInProgress.ref;\n            var propsWithoutRef;\n            if ('ref' in nextProps) {\n                // `ref` is just a prop now, but `forwardRef` expects it to not appear in\n                // the props object. This used to happen in the JSX runtime, but now we do\n                // it here.\n                propsWithoutRef = {};\n                for(var key in nextProps){\n                    // Since `ref` should only appear in props via the JSX transform, we can\n                    // assume that this is a plain object. So we don't need a\n                    // hasOwnProperty check.\n                    if (key !== 'ref') {\n                        propsWithoutRef[key] = nextProps[key];\n                    }\n                }\n            } else {\n                propsWithoutRef = nextProps;\n            } // The rest is a fork of updateFunctionComponent\n            var nextChildren;\n            var hasId;\n            prepareToReadContext(workInProgress, renderLanes);\n            {\n                markComponentRenderStarted(workInProgress);\n            }\n            {\n                setIsRendering(true);\n                nextChildren = renderWithHooks(current, workInProgress, render, propsWithoutRef, ref, renderLanes);\n                hasId = checkDidRenderIdHook();\n                setIsRendering(false);\n            }\n            {\n                markComponentRenderStopped();\n            }\n            if (current !== null && !didReceiveUpdate) {\n                bailoutHooks(current, workInProgress, renderLanes);\n                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n            }\n            if (getIsHydrating() && hasId) {\n                pushMaterializedTreeId(workInProgress);\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n            if (current === null) {\n                var type = Component.type;\n                if (isSimpleFunctionComponent(type) && Component.compare === null && disableDefaultPropsExceptForClasses) {\n                    var resolvedType = type;\n                    {\n                        resolvedType = resolveFunctionForHotReloading(type);\n                    }\n                    // and with only the default shallow comparison, we upgrade it\n                    // to a SimpleMemoComponent to allow fast path updates.\n                    workInProgress.tag = SimpleMemoComponent;\n                    workInProgress.type = resolvedType;\n                    {\n                        validateFunctionComponentInDev(workInProgress, type);\n                    }\n                    return updateSimpleMemoComponent(current, workInProgress, resolvedType, nextProps, renderLanes);\n                }\n                var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);\n                child.ref = workInProgress.ref;\n                child.return = workInProgress;\n                workInProgress.child = child;\n                return child;\n            }\n            var currentChild = current.child; // This is always exactly one child\n            var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);\n            if (!hasScheduledUpdateOrContext) {\n                // This will be the props with resolved defaultProps,\n                // unlike current.memoizedProps which will be the unresolved ones.\n                var prevProps = currentChild.memoizedProps; // Default to shallow comparison\n                var compare = Component.compare;\n                compare = compare !== null ? compare : shallowEqual;\n                if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {\n                    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                }\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            var newChild = createWorkInProgress(currentChild, nextProps);\n            newChild.ref = workInProgress.ref;\n            newChild.return = workInProgress;\n            workInProgress.child = newChild;\n            return newChild;\n        }\n        function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n            // TODO: current can be non-null here even if the component\n            // hasn't yet mounted. This happens when the inner render suspends.\n            // We'll need to figure out if this is fine or can cause issues.\n            if (current !== null) {\n                var prevProps = current.memoizedProps;\n                if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && workInProgress.type === current.type) {\n                    didReceiveUpdate = false; // The props are shallowly equal. Reuse the previous props object, like we\n                    // would during a normal fiber bailout.\n                    //\n                    // We don't have strong guarantees that the props object is referentially\n                    // equal during updates where we can't bail out anyway — like if the props\n                    // are shallowly equal, but there's a local state or context update in the\n                    // same batch.\n                    //\n                    // However, as a principle, we should aim to make the behavior consistent\n                    // across different ways of memoizing a component. For example, React.memo\n                    // has a different internal Fiber layout if you pass a normal function\n                    // component (SimpleMemoComponent) versus if you pass a different type\n                    // like forwardRef (MemoComponent). But this is an implementation detail.\n                    // Wrapping a component in forwardRef (or React.lazy, etc) shouldn't\n                    // affect whether the props object is reused during a bailout.\n                    workInProgress.pendingProps = nextProps = prevProps;\n                    if (!checkScheduledUpdateOrContext(current, renderLanes)) {\n                        // The pending lanes were cleared at the beginning of beginWork. We're\n                        // about to bail out, but there might be other lanes that weren't\n                        // included in the current render. Usually, the priority level of the\n                        // remaining updates is accumulated during the evaluation of the\n                        // component (i.e. when processing the update queue). But since since\n                        // we're bailing out early *without* evaluating the component, we need\n                        // to account for it here, too. Reset to the value of the current fiber.\n                        // NOTE: This only applies to SimpleMemoComponent, not MemoComponent,\n                        // because a MemoComponent fiber does not have hooks or an update queue;\n                        // rather, it wraps around an inner component, which may or may not\n                        // contains hooks.\n                        // TODO: Move the reset at in beginWork out of the common path so that\n                        // this is no longer necessary.\n                        workInProgress.lanes = current.lanes;\n                        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                    } else if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags$1) {\n                        // This is a special case that only exists for legacy mode.\n                        // See https://github.com/facebook/react/pull/19216.\n                        didReceiveUpdate = true;\n                    }\n                }\n            }\n            return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);\n        }\n        function updateOffscreenComponent(current, workInProgress, renderLanes) {\n            var nextProps = workInProgress.pendingProps;\n            var nextChildren = nextProps.children;\n            var nextIsDetached = (workInProgress.stateNode._pendingVisibility & OffscreenDetached) !== 0;\n            var prevState = current !== null ? current.memoizedState : null;\n            markRef(current, workInProgress);\n            if (nextProps.mode === 'hidden' || enableLegacyHidden || nextIsDetached) {\n                // Rendering a hidden tree.\n                var didSuspend = (workInProgress.flags & DidCapture) !== NoFlags$1;\n                if (didSuspend) {\n                    // Something suspended inside a hidden tree\n                    // Include the base lanes from the last render\n                    var nextBaseLanes = prevState !== null ? mergeLanes(prevState.baseLanes, renderLanes) : renderLanes;\n                    if (current !== null) {\n                        // Reset to the current children\n                        var currentChild = workInProgress.child = current.child; // The current render suspended, but there may be other lanes with\n                        // pending work. We can't read `childLanes` from the current Offscreen\n                        // fiber because we reset it when it was deferred; however, we can read\n                        // the pending lanes from the child fibers.\n                        var currentChildLanes = NoLanes;\n                        while(currentChild !== null){\n                            currentChildLanes = mergeLanes(mergeLanes(currentChildLanes, currentChild.lanes), currentChild.childLanes);\n                            currentChild = currentChild.sibling;\n                        }\n                        var lanesWeJustAttempted = nextBaseLanes;\n                        var remainingChildLanes = removeLanes(currentChildLanes, lanesWeJustAttempted);\n                        workInProgress.childLanes = remainingChildLanes;\n                    } else {\n                        workInProgress.childLanes = NoLanes;\n                        workInProgress.child = null;\n                    }\n                    return deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes);\n                }\n                if (!includesSomeLane(renderLanes, OffscreenLane)) {\n                    // We're hidden, and we're not rendering at Offscreen. We will bail out\n                    // and resume this tree later.\n                    // Schedule this fiber to re-render at Offscreen priority\n                    workInProgress.lanes = workInProgress.childLanes = laneToLanes(OffscreenLane); // Include the base lanes from the last render\n                    var _nextBaseLanes = prevState !== null ? mergeLanes(prevState.baseLanes, renderLanes) : renderLanes;\n                    return deferHiddenOffscreenComponent(current, workInProgress, _nextBaseLanes);\n                } else {\n                    // This is the second render. The surrounding visible content has already\n                    // committed. Now we resume rendering the hidden tree.\n                    // Rendering at offscreen, so we can clear the base lanes.\n                    var _nextState = {\n                        baseLanes: NoLanes,\n                        cachePool: null\n                    };\n                    workInProgress.memoizedState = _nextState;\n                    if (current !== null) {\n                        // If the render that spawned this one accessed the cache pool, resume\n                        // using the same cache. Unless the parent changed, since that means\n                        // there was a refresh.\n                        var prevCachePool = prevState !== null ? prevState.cachePool : null; // TODO: Consider if and how Offscreen pre-rendering should\n                        // be attributed to the transition that spawned it\n                        pushTransition(workInProgress, prevCachePool);\n                    } // Push the lanes that were skipped when we bailed out.\n                    if (prevState !== null) {\n                        pushHiddenContext(workInProgress, prevState);\n                    } else {\n                        reuseHiddenContextOnStack(workInProgress);\n                    }\n                    pushOffscreenSuspenseHandler(workInProgress);\n                }\n            } else {\n                // Rendering a visible tree.\n                if (prevState !== null) {\n                    // We're going from hidden -> visible.\n                    var _prevCachePool = null;\n                    {\n                        // If the render that spawned this one accessed the cache pool, resume\n                        // using the same cache. Unless the parent changed, since that means\n                        // there was a refresh.\n                        _prevCachePool = prevState.cachePool;\n                    }\n                    pushTransition(workInProgress, _prevCachePool); // Push the lanes that were skipped when we bailed out.\n                    pushHiddenContext(workInProgress, prevState);\n                    reuseSuspenseHandlerOnStack(workInProgress); // Since we're not hidden anymore, reset the state\n                    workInProgress.memoizedState = null;\n                } else {\n                    // We weren't previously hidden, and we still aren't, so there's nothing\n                    // special to do. Need to push to the stack regardless, though, to avoid\n                    // a push/pop misalignment.\n                    {\n                        // If the render that spawned this one accessed the cache pool, resume\n                        // using the same cache. Unless the parent changed, since that means\n                        // there was a refresh.\n                        if (current !== null) {\n                            pushTransition(workInProgress, null);\n                        }\n                    }\n                    // to avoid a push/pop misalignment.\n                    reuseHiddenContextOnStack(workInProgress);\n                    reuseSuspenseHandlerOnStack(workInProgress);\n                }\n            }\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes, renderLanes) {\n            var nextState = {\n                baseLanes: nextBaseLanes,\n                // Save the cache pool so we can resume later.\n                cachePool: getOffscreenDeferredCache()\n            };\n            workInProgress.memoizedState = nextState;\n            {\n                // push the cache pool even though we're going to bail out\n                // because otherwise there'd be a context mismatch\n                if (current !== null) {\n                    pushTransition(workInProgress, null);\n                }\n            }\n            // to avoid a push/pop misalignment.\n            reuseHiddenContextOnStack(workInProgress);\n            pushOffscreenSuspenseHandler(workInProgress);\n            return null;\n        } // Note: These happen to have identical begin phases, for now. We shouldn't hold\n        function updateCacheComponent(current, workInProgress, renderLanes) {\n            prepareToReadContext(workInProgress, renderLanes);\n            var parentCache = readContext(CacheContext);\n            if (current === null) {\n                // Initial mount. Request a fresh cache from the pool.\n                var freshCache = requestCacheFromPool(renderLanes);\n                var initialState = {\n                    parent: parentCache,\n                    cache: freshCache\n                };\n                workInProgress.memoizedState = initialState;\n                initializeUpdateQueue(workInProgress);\n                pushCacheProvider(workInProgress, freshCache);\n            } else {\n                // Check for updates\n                if (includesSomeLane(current.lanes, renderLanes)) {\n                    cloneUpdateQueue(current, workInProgress);\n                    processUpdateQueue(workInProgress, null, null, renderLanes);\n                    suspendIfUpdateReadFromEntangledAsyncAction();\n                }\n                var prevState = current.memoizedState;\n                var nextState = workInProgress.memoizedState; // Compare the new parent cache to the previous to see detect there was\n                // a refresh.\n                if (prevState.parent !== parentCache) {\n                    // Refresh in parent. Update the parent.\n                    var derivedState = {\n                        parent: parentCache,\n                        cache: parentCache\n                    }; // Copied from getDerivedStateFromProps implementation. Once the update\n                    // queue is empty, persist the derived state onto the base state.\n                    workInProgress.memoizedState = derivedState;\n                    if (workInProgress.lanes === NoLanes) {\n                        var updateQueue = workInProgress.updateQueue;\n                        workInProgress.memoizedState = updateQueue.baseState = derivedState;\n                    }\n                    pushCacheProvider(workInProgress, parentCache); // No need to propagate a context change because the refreshed parent\n                // already did.\n                } else {\n                    // The parent didn't refresh. Now check if this cache did.\n                    var nextCache = nextState.cache;\n                    pushCacheProvider(workInProgress, nextCache);\n                    if (nextCache !== prevState.cache) {\n                        // This cache refreshed. Propagate a context change.\n                        propagateContextChange(workInProgress, CacheContext, renderLanes);\n                    }\n                }\n            }\n            var nextChildren = workInProgress.pendingProps.children;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        } // This should only be called if the name changes\n        function updateFragment(current, workInProgress, renderLanes) {\n            var nextChildren = workInProgress.pendingProps;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateMode(current, workInProgress, renderLanes) {\n            var nextChildren = workInProgress.pendingProps.children;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateProfiler(current, workInProgress, renderLanes) {\n            {\n                workInProgress.flags |= Update;\n                {\n                    // Reset effect durations for the next eventual effect phase.\n                    // These are reset during render to allow the DevTools commit hook a chance to read them,\n                    var stateNode = workInProgress.stateNode;\n                    stateNode.effectDuration = 0;\n                    stateNode.passiveEffectDuration = 0;\n                }\n            }\n            var nextProps = workInProgress.pendingProps;\n            var nextChildren = nextProps.children;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function markRef(current, workInProgress) {\n            // TODO: Check props.ref instead of fiber.ref when enableRefAsProp is on.\n            var ref = workInProgress.ref;\n            if (ref === null) {\n                if (current !== null && current.ref !== null) {\n                    // Schedule a Ref effect\n                    workInProgress.flags |= Ref | RefStatic;\n                }\n            } else {\n                if (typeof ref !== 'function' && typeof ref !== 'object') {\n                    throw new Error('Expected ref to be a function, an object returned by React.createRef(), or undefined/null.');\n                }\n                if (current === null || current.ref !== ref) {\n                    workInProgress.flags |= Ref | RefStatic;\n                }\n            }\n        }\n        function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {\n            {\n                if (Component.prototype && typeof Component.prototype.render === 'function') {\n                    var componentName = getComponentNameFromType(Component) || 'Unknown';\n                    if (!didWarnAboutBadClass[componentName]) {\n                        error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);\n                        didWarnAboutBadClass[componentName] = true;\n                    }\n                }\n                if (workInProgress.mode & StrictLegacyMode) {\n                    ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n                }\n                if (current === null) {\n                    // Some validations were previously done in mountIndeterminateComponent however and are now run\n                    // in updateFuntionComponent but only on mount\n                    validateFunctionComponentInDev(workInProgress, workInProgress.type);\n                    if (Component.contextTypes) {\n                        error('%s uses the legacy contextTypes API which was removed in React 19. ' + 'Use React.createContext() with React.useContext() instead.', getComponentNameFromType(Component) || 'Unknown');\n                    }\n                }\n            }\n            var context;\n            var nextChildren;\n            var hasId;\n            prepareToReadContext(workInProgress, renderLanes);\n            {\n                markComponentRenderStarted(workInProgress);\n            }\n            {\n                setIsRendering(true);\n                nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);\n                hasId = checkDidRenderIdHook();\n                setIsRendering(false);\n            }\n            {\n                markComponentRenderStopped();\n            }\n            if (current !== null && !didReceiveUpdate) {\n                bailoutHooks(current, workInProgress, renderLanes);\n                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n            }\n            if (getIsHydrating() && hasId) {\n                pushMaterializedTreeId(workInProgress);\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function replayFunctionComponent(current, workInProgress, nextProps, Component, secondArg, renderLanes) {\n            // This function is used to replay a component that previously suspended,\n            // after its data resolves. It's a simplified version of\n            // updateFunctionComponent that reuses the hooks from the previous attempt.\n            prepareToReadContext(workInProgress, renderLanes);\n            {\n                markComponentRenderStarted(workInProgress);\n            }\n            var nextChildren = replaySuspendedComponentWithHooks(current, workInProgress, Component, nextProps, secondArg);\n            var hasId = checkDidRenderIdHook();\n            {\n                markComponentRenderStopped();\n            }\n            if (current !== null && !didReceiveUpdate) {\n                bailoutHooks(current, workInProgress, renderLanes);\n                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n            }\n            if (getIsHydrating() && hasId) {\n                pushMaterializedTreeId(workInProgress);\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {\n            {\n                // This is used by DevTools to force a boundary to error.\n                switch(shouldError(workInProgress)){\n                    case false:\n                        {\n                            var _instance = workInProgress.stateNode;\n                            var ctor = workInProgress.type; // TODO This way of resetting the error boundary state is a hack.\n                            // Is there a better way to do this?\n                            var tempInstance = new ctor(workInProgress.memoizedProps, _instance.context);\n                            var state = tempInstance.state;\n                            _instance.updater.enqueueSetState(_instance, state, null);\n                            break;\n                        }\n                    case true:\n                        {\n                            workInProgress.flags |= DidCapture;\n                            workInProgress.flags |= ShouldCapture; // eslint-disable-next-line react-internal/prod-error-codes\n                            var error$1 = new Error('Simulated error coming from DevTools');\n                            var lane = pickArbitraryLane(renderLanes);\n                            workInProgress.lanes = mergeLanes(workInProgress.lanes, lane); // Schedule the error boundary to re-render using updated state\n                            var root = getWorkInProgressRoot();\n                            if (root === null) {\n                                throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');\n                            }\n                            var update = createClassErrorUpdate(lane);\n                            initializeClassErrorUpdate(update, root, workInProgress, createCapturedValueAtFiber(error$1, workInProgress));\n                            enqueueCapturedUpdate(workInProgress, update);\n                            break;\n                        }\n                }\n            }\n            // During mounting we don't know the child context yet as the instance doesn't exist.\n            // We will invalidate the child context in finishClassComponent() right after rendering.\n            var hasContext;\n            if (isContextProvider()) {\n                hasContext = true;\n            } else {\n                hasContext = false;\n            }\n            prepareToReadContext(workInProgress, renderLanes);\n            var instance = workInProgress.stateNode;\n            var shouldUpdate;\n            if (instance === null) {\n                constructClassInstance(workInProgress, Component, nextProps);\n                mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n                shouldUpdate = true;\n            } else if (current === null) {\n                // In a resume, we'll already have an instance we can reuse.\n                shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderLanes);\n            } else {\n                shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderLanes);\n            }\n            var nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes);\n            {\n                var inst = workInProgress.stateNode;\n                if (shouldUpdate && inst.props !== nextProps) {\n                    if (!didWarnAboutReassigningProps) {\n                        error('It looks like %s is reassigning its own `this.props` while rendering. ' + 'This is not supported and can lead to confusing bugs.', getComponentNameFromFiber(workInProgress) || 'a component');\n                    }\n                    didWarnAboutReassigningProps = true;\n                }\n            }\n            return nextUnitOfWork;\n        }\n        function finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes) {\n            // Refs should update even if shouldComponentUpdate returns false\n            markRef(current, workInProgress);\n            var didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags$1;\n            if (!shouldUpdate && !didCaptureError) {\n                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n            }\n            var instance = workInProgress.stateNode; // Rerender\n            {\n                setCurrentFiber(workInProgress);\n            }\n            var nextChildren;\n            if (didCaptureError && typeof Component.getDerivedStateFromError !== 'function') {\n                // If we captured an error, but getDerivedStateFromError is not defined,\n                // unmount all the children. componentDidCatch will schedule an update to\n                // re-render a fallback. This is temporary until we migrate everyone to\n                // the new API.\n                // TODO: Warn in a future release.\n                nextChildren = null;\n                {\n                    stopProfilerTimerIfRunning();\n                }\n            } else {\n                {\n                    markComponentRenderStarted(workInProgress);\n                }\n                {\n                    setIsRendering(true);\n                    nextChildren = instance.render();\n                    if (workInProgress.mode & StrictLegacyMode) {\n                        setIsStrictModeForDevtools(true);\n                        try {\n                            instance.render();\n                        } finally{\n                            setIsStrictModeForDevtools(false);\n                        }\n                    }\n                    setIsRendering(false);\n                }\n                {\n                    markComponentRenderStopped();\n                }\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            if (current !== null && didCaptureError) {\n                // If we're recovering from an error, reconcile without reusing any of\n                // the existing children. Conceptually, the normal children and the children\n                // that are shown on error are two different sets, so we shouldn't reuse\n                // normal children even if their identities match.\n                forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes);\n            } else {\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            } // Memoize state using the values we just used to render.\n            // TODO: Restructure so we never read values from the instance.\n            workInProgress.memoizedState = instance.state; // The context might have changed so we need to recalculate it.\n            return workInProgress.child;\n        }\n        function pushHostRootContext(workInProgress) {\n            var root = workInProgress.stateNode;\n            pushHostContainer(workInProgress, root.containerInfo);\n        }\n        function updateHostRoot(current, workInProgress, renderLanes) {\n            pushHostRootContext(workInProgress);\n            if (current === null) {\n                throw new Error('Should have a current fiber. This is a bug in React.');\n            }\n            var nextProps = workInProgress.pendingProps;\n            var prevState = workInProgress.memoizedState;\n            var prevChildren = prevState.element;\n            cloneUpdateQueue(current, workInProgress);\n            processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n            var nextState = workInProgress.memoizedState;\n            {\n                var nextCache = nextState.cache;\n                pushCacheProvider(workInProgress, nextCache);\n                if (nextCache !== prevState.cache) {\n                    // The root cache refreshed.\n                    propagateContextChange(workInProgress, CacheContext, renderLanes);\n                }\n            }\n            // it needs to happen after the `pushCacheProvider` call above to avoid a\n            // context stack mismatch. A bit unfortunate.\n            suspendIfUpdateReadFromEntangledAsyncAction(); // Caution: React DevTools currently depends on this property\n            // being called \"element\".\n            var nextChildren = nextState.element;\n            if (supportsHydration && prevState.isDehydrated) {\n                // This is a hydration root whose shell has not yet hydrated. We should\n                // attempt to hydrate.\n                // Flip isDehydrated to false to indicate that when this render\n                // finishes, the root will no longer be dehydrated.\n                var overrideState = {\n                    element: nextChildren,\n                    isDehydrated: false,\n                    cache: nextState.cache\n                };\n                var updateQueue = workInProgress.updateQueue; // `baseState` can always be the last state because the root doesn't\n                // have reducer functions so it doesn't need rebasing.\n                updateQueue.baseState = overrideState;\n                workInProgress.memoizedState = overrideState;\n                if (workInProgress.flags & ForceClientRender) {\n                    // Something errored during a previous attempt to hydrate the shell, so we\n                    // forced a client render. We should have a recoverable error already scheduled.\n                    return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes);\n                } else if (nextChildren !== prevChildren) {\n                    var recoverableError = createCapturedValueAtFiber(new Error('This root received an early update, before anything was able ' + 'hydrate. Switched the entire root to client rendering.'), workInProgress);\n                    queueHydrationError(recoverableError);\n                    return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes);\n                } else {\n                    // The outermost shell has not hydrated yet. Start hydrating.\n                    enterHydrationState(workInProgress);\n                    var child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n                    workInProgress.child = child;\n                    var node = child;\n                    while(node){\n                        // Mark each child as hydrating. This is a fast path to know whether this\n                        // tree is part of a hydrating tree. This is used to determine if a child\n                        // node has fully mounted yet, and for scheduling event replaying.\n                        // Conceptually this is similar to Placement in that a new subtree is\n                        // inserted into the React tree here. It just happens to not need DOM\n                        // mutations because it already exists.\n                        node.flags = node.flags & ~Placement | Hydrating;\n                        node = node.sibling;\n                    }\n                }\n            } else {\n                // Root is not dehydrated. Either this is a client-only root, or it\n                // already hydrated.\n                resetHydrationState();\n                if (nextChildren === prevChildren) {\n                    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                }\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            }\n            return workInProgress.child;\n        }\n        function mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes) {\n            // Revert to client rendering.\n            resetHydrationState();\n            workInProgress.flags |= ForceClientRender;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateHostComponent$1(current, workInProgress, renderLanes) {\n            if (current === null) {\n                tryToClaimNextHydratableInstance(workInProgress);\n            }\n            pushHostContext(workInProgress);\n            var type = workInProgress.type;\n            var nextProps = workInProgress.pendingProps;\n            var prevProps = current !== null ? current.memoizedProps : null;\n            var nextChildren = nextProps.children;\n            var isDirectTextChild = shouldSetTextContent(type, nextProps);\n            if (isDirectTextChild) {\n                // We special case a direct text child of a host node. This is a common\n                // case. We won't handle it as a reified child. We will instead handle\n                // this in the host environment that also has access to this prop. That\n                // avoids allocating another HostText fiber and traversing it.\n                nextChildren = null;\n            } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n                // If we're switching from a direct text child to a normal child, or to\n                // empty, we need to schedule the text content to be reset.\n                workInProgress.flags |= ContentReset;\n            }\n            {\n                var memoizedState = workInProgress.memoizedState;\n                if (memoizedState !== null) {\n                    // This fiber has been upgraded to a stateful component. The only way\n                    // happens currently is for form actions. We use hooks to track the\n                    // pending and error state of the form.\n                    //\n                    // Once a fiber is upgraded to be stateful, it remains stateful for the\n                    // rest of its lifetime.\n                    var newState = renderTransitionAwareHostComponentWithHooks(current, workInProgress, renderLanes); // If the transition state changed, propagate the change to all the\n                    // descendents. We use Context as an implementation detail for this.\n                    //\n                    // This is intentionally set here instead of pushHostContext because\n                    // pushHostContext gets called before we process the state hook, to avoid\n                    // a state mismatch in the event that something suspends.\n                    //\n                    // NOTE: This assumes that there cannot be nested transition providers,\n                    // because the only renderer that implements this feature is React DOM,\n                    // and forms cannot be nested. If we did support nested providers, then\n                    // we would need to push a context value even for host fibers that\n                    // haven't been upgraded yet.\n                    if (isPrimaryRenderer) {\n                        HostTransitionContext._currentValue = newState;\n                    } else {\n                        HostTransitionContext._currentValue2 = newState;\n                    }\n                    {\n                        if (didReceiveUpdate) {\n                            if (current !== null) {\n                                var oldStateHook = current.memoizedState;\n                                var oldState = oldStateHook.memoizedState; // This uses regular equality instead of Object.is because we assume\n                                // that host transition state doesn't include NaN as a valid type.\n                                if (oldState !== newState) {\n                                    propagateContextChange(workInProgress, HostTransitionContext, renderLanes);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            markRef(current, workInProgress);\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateHostHoistable(current, workInProgress, renderLanes) {\n            markRef(current, workInProgress);\n            var currentProps = current === null ? null : current.memoizedProps;\n            var resource = workInProgress.memoizedState = getResource(workInProgress.type, currentProps, workInProgress.pendingProps);\n            if (current === null) {\n                if (!getIsHydrating() && resource === null) {\n                    // This is not a Resource Hoistable and we aren't hydrating so we construct the instance.\n                    workInProgress.stateNode = createHoistableInstance(workInProgress.type, workInProgress.pendingProps, getRootHostContainer(), workInProgress);\n                }\n            } // Resources never have reconciler managed children. It is possible for\n            // the host implementation of getResource to consider children in the\n            // resource construction but they will otherwise be discarded. In practice\n            // this precludes all but the simplest children and Host specific warnings\n            // should be implemented to warn when children are passsed when otherwise not\n            // expected\n            return null;\n        }\n        function updateHostSingleton(current, workInProgress, renderLanes) {\n            pushHostContext(workInProgress);\n            if (current === null) {\n                claimHydratableSingleton(workInProgress);\n            }\n            var nextChildren = workInProgress.pendingProps.children;\n            if (current === null && !getIsHydrating()) {\n                // Similar to Portals we append Singleton children in the commit phase. So we\n                // Track insertions even on mount.\n                // TODO: Consider unifying this with how the root works.\n                workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n            } else {\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            }\n            markRef(current, workInProgress);\n            return workInProgress.child;\n        }\n        function updateHostText$1(current, workInProgress) {\n            if (current === null) {\n                tryToClaimNextHydratableTextInstance(workInProgress);\n            } // Nothing to do here. This is terminal. We'll do the completion step\n            // immediately after.\n            return null;\n        }\n        function mountLazyComponent(_current, workInProgress, elementType, renderLanes) {\n            var props = workInProgress.pendingProps;\n            var lazyComponent = elementType;\n            var payload = lazyComponent._payload;\n            var init = lazyComponent._init;\n            var Component = init(payload); // Store the unwrapped component in the type.\n            workInProgress.type = Component;\n            if (typeof Component === 'function') {\n                if (isFunctionClassComponent(Component)) {\n                    var resolvedProps = resolveClassComponentProps(Component, props);\n                    workInProgress.tag = ClassComponent;\n                    {\n                        workInProgress.type = Component = resolveClassForHotReloading(Component);\n                    }\n                    return updateClassComponent(null, workInProgress, Component, resolvedProps, renderLanes);\n                } else {\n                    var _resolvedProps = props;\n                    workInProgress.tag = FunctionComponent;\n                    {\n                        validateFunctionComponentInDev(workInProgress, Component);\n                        workInProgress.type = Component = resolveFunctionForHotReloading(Component);\n                    }\n                    return updateFunctionComponent(null, workInProgress, Component, _resolvedProps, renderLanes);\n                }\n            } else if (Component !== undefined && Component !== null) {\n                var $$typeof = Component.$$typeof;\n                if ($$typeof === REACT_FORWARD_REF_TYPE) {\n                    var _resolvedProps2 = props;\n                    workInProgress.tag = ForwardRef;\n                    {\n                        workInProgress.type = Component = resolveForwardRefForHotReloading(Component);\n                    }\n                    return updateForwardRef(null, workInProgress, Component, _resolvedProps2, renderLanes);\n                } else if ($$typeof === REACT_MEMO_TYPE) {\n                    var _resolvedProps3 = props;\n                    workInProgress.tag = MemoComponent;\n                    return updateMemoComponent(null, workInProgress, Component, _resolvedProps3, renderLanes);\n                }\n            }\n            var hint = '';\n            {\n                if (Component !== null && typeof Component === 'object' && Component.$$typeof === REACT_LAZY_TYPE) {\n                    hint = ' Did you wrap a component in React.lazy() more than once?';\n                }\n            }\n            // because the fact that it's a separate type of work is an\n            // implementation detail.\n            throw new Error(\"Element type is invalid. Received a promise that resolves to: \" + Component + \". \" + (\"Lazy element type must resolve to a class or function.\" + hint));\n        }\n        function validateFunctionComponentInDev(workInProgress, Component) {\n            {\n                if (Component) {\n                    if (Component.childContextTypes) {\n                        error('childContextTypes cannot be defined on a function component.\\n' + '  %s.childContextTypes = ...', Component.displayName || Component.name || 'Component');\n                    }\n                }\n                if (typeof Component.getDerivedStateFromProps === 'function') {\n                    var _componentName2 = getComponentNameFromType(Component) || 'Unknown';\n                    if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2]) {\n                        error('%s: Function components do not support getDerivedStateFromProps.', _componentName2);\n                        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] = true;\n                    }\n                }\n                if (typeof Component.contextType === 'object' && Component.contextType !== null) {\n                    var _componentName3 = getComponentNameFromType(Component) || 'Unknown';\n                    if (!didWarnAboutContextTypeOnFunctionComponent[_componentName3]) {\n                        error('%s: Function components do not support contextType.', _componentName3);\n                        didWarnAboutContextTypeOnFunctionComponent[_componentName3] = true;\n                    }\n                }\n            }\n        }\n        var SUSPENDED_MARKER = {\n            dehydrated: null,\n            treeContext: null,\n            retryLane: NoLane\n        };\n        function mountSuspenseOffscreenState(renderLanes) {\n            return {\n                baseLanes: renderLanes,\n                cachePool: getSuspendedCache()\n            };\n        }\n        function updateSuspenseOffscreenState(prevOffscreenState, renderLanes) {\n            var cachePool = null;\n            {\n                var prevCachePool = prevOffscreenState.cachePool;\n                if (prevCachePool !== null) {\n                    var parentCache = isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2;\n                    if (prevCachePool.parent !== parentCache) {\n                        // Detected a refresh in the parent. This overrides any previously\n                        // suspended cache.\n                        cachePool = {\n                            parent: parentCache,\n                            pool: parentCache\n                        };\n                    } else {\n                        // We can reuse the cache from last time. The only thing that would have\n                        // overridden it is a parent refresh, which we checked for above.\n                        cachePool = prevCachePool;\n                    }\n                } else {\n                    // If there's no previous cache pool, grab the current one.\n                    cachePool = getSuspendedCache();\n                }\n            }\n            return {\n                baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes),\n                cachePool: cachePool\n            };\n        } // TODO: Probably should inline this back\n        function shouldRemainOnFallback(current, workInProgress, renderLanes) {\n            // If we're already showing a fallback, there are cases where we need to\n            // remain on that fallback regardless of whether the content has resolved.\n            // For example, SuspenseList coordinates when nested content appears.\n            // TODO: For compatibility with offscreen prerendering, this should also check\n            // whether the current fiber (if it exists) was visible in the previous tree.\n            if (current !== null) {\n                var suspenseState = current.memoizedState;\n                if (suspenseState === null) {\n                    // Currently showing content. Don't hide it, even if ForceSuspenseFallback\n                    // is true. More precise name might be \"ForceRemainSuspenseFallback\".\n                    // Note: This is a factoring smell. Can't remain on a fallback if there's\n                    // no fallback to remain on.\n                    return false;\n                }\n            } // Not currently showing content. Consult the Suspense context.\n            var suspenseContext = suspenseStackCursor.current;\n            return hasSuspenseListContext(suspenseContext, ForceSuspenseFallback);\n        }\n        function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes) {\n            var remainingLanes = current !== null ? removeLanes(current.childLanes, renderLanes) : NoLanes;\n            if (primaryTreeDidDefer) {\n                // A useDeferredValue hook spawned a deferred task inside the primary tree.\n                // Ensure that we retry this component at the deferred priority.\n                // TODO: We could make this a per-subtree value instead of a global one.\n                // Would need to track it on the context stack somehow, similar to what\n                // we'd have to do for resumable contexts.\n                remainingLanes = mergeLanes(remainingLanes, peekDeferredLane());\n            }\n            return remainingLanes;\n        }\n        function updateSuspenseComponent(current, workInProgress, renderLanes) {\n            var nextProps = workInProgress.pendingProps; // This is used by DevTools to force a boundary to suspend.\n            {\n                if (shouldSuspend(workInProgress)) {\n                    workInProgress.flags |= DidCapture;\n                }\n            }\n            var showFallback = false;\n            var didSuspend = (workInProgress.flags & DidCapture) !== NoFlags$1;\n            if (didSuspend || shouldRemainOnFallback(current)) {\n                // Something in this boundary's subtree already suspended. Switch to\n                // rendering the fallback children.\n                showFallback = true;\n                workInProgress.flags &= ~DidCapture;\n            } // Check if the primary children spawned a deferred task (useDeferredValue)\n            // during the first pass.\n            var didPrimaryChildrenDefer = (workInProgress.flags & DidDefer) !== NoFlags$1;\n            workInProgress.flags &= ~DidDefer; // OK, the next part is confusing. We're about to reconcile the Suspense\n            // boundary's children. This involves some custom reconciliation logic. Two\n            // main reasons this is so complicated.\n            //\n            // First, Legacy Mode has different semantics for backwards compatibility. The\n            // primary tree will commit in an inconsistent state, so when we do the\n            // second pass to render the fallback, we do some exceedingly, uh, clever\n            // hacks to make that not totally break. Like transferring effects and\n            // deletions from hidden tree. In Concurrent Mode, it's much simpler,\n            // because we bailout on the primary tree completely and leave it in its old\n            // state, no effects. Same as what we do for Offscreen (except that\n            // Offscreen doesn't have the first render pass).\n            //\n            // Second is hydration. During hydration, the Suspense fiber has a slightly\n            // different layout, where the child points to a dehydrated fragment, which\n            // contains the DOM rendered by the server.\n            //\n            // Third, even if you set all that aside, Suspense is like error boundaries in\n            // that we first we try to render one tree, and if that fails, we render again\n            // and switch to a different tree. Like a try/catch block. So we have to track\n            // which branch we're currently rendering. Ideally we would model this using\n            // a stack.\n            if (current === null) {\n                // Initial mount\n                // Special path for hydration\n                // If we're currently hydrating, try to hydrate this boundary.\n                if (getIsHydrating()) {\n                    // We must push the suspense handler context *before* attempting to\n                    // hydrate, to avoid a mismatch in case it errors.\n                    if (showFallback) {\n                        pushPrimaryTreeSuspenseHandler(workInProgress);\n                    } else {\n                        pushFallbackTreeSuspenseHandler(workInProgress);\n                    }\n                    tryToClaimNextHydratableSuspenseInstance(workInProgress); // This could've been a dehydrated suspense component.\n                    var suspenseState = workInProgress.memoizedState;\n                    if (suspenseState !== null) {\n                        var dehydrated = suspenseState.dehydrated;\n                        if (dehydrated !== null) {\n                            return mountDehydratedSuspenseComponent(workInProgress, dehydrated);\n                        }\n                    } // If hydration didn't succeed, fall through to the normal Suspense path.\n                    // To avoid a stack mismatch we need to pop the Suspense handler that we\n                    // pushed above. This will become less awkward when move the hydration\n                    // logic to its own fiber.\n                    popSuspenseHandler(workInProgress);\n                }\n                var nextPrimaryChildren = nextProps.children;\n                var nextFallbackChildren = nextProps.fallback;\n                if (showFallback) {\n                    pushFallbackTreeSuspenseHandler(workInProgress);\n                    var fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n                    var primaryChildFragment = workInProgress.child;\n                    primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);\n                    primaryChildFragment.childLanes = getRemainingWorkInPrimaryTree(current, didPrimaryChildrenDefer, renderLanes);\n                    workInProgress.memoizedState = SUSPENDED_MARKER;\n                    return fallbackFragment;\n                } else {\n                    pushPrimaryTreeSuspenseHandler(workInProgress);\n                    return mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren);\n                }\n            } else {\n                // This is an update.\n                // Special path for hydration\n                var prevState = current.memoizedState;\n                if (prevState !== null) {\n                    var _dehydrated = prevState.dehydrated;\n                    if (_dehydrated !== null) {\n                        return updateDehydratedSuspenseComponent(current, workInProgress, didSuspend, didPrimaryChildrenDefer, nextProps, _dehydrated, prevState, renderLanes);\n                    }\n                }\n                if (showFallback) {\n                    pushFallbackTreeSuspenseHandler(workInProgress);\n                    var _nextFallbackChildren = nextProps.fallback;\n                    var _nextPrimaryChildren = nextProps.children;\n                    var fallbackChildFragment = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren, _nextFallbackChildren, renderLanes);\n                    var _primaryChildFragment2 = workInProgress.child;\n                    var prevOffscreenState = current.child.memoizedState;\n                    _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);\n                    _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current, didPrimaryChildrenDefer, renderLanes);\n                    workInProgress.memoizedState = SUSPENDED_MARKER;\n                    return fallbackChildFragment;\n                } else {\n                    pushPrimaryTreeSuspenseHandler(workInProgress);\n                    var _nextPrimaryChildren2 = nextProps.children;\n                    var _primaryChildFragment3 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren2);\n                    workInProgress.memoizedState = null;\n                    return _primaryChildFragment3;\n                }\n            }\n        }\n        function mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes) {\n            var mode = workInProgress.mode;\n            var primaryChildProps = {\n                mode: 'visible',\n                children: primaryChildren\n            };\n            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);\n            primaryChildFragment.return = workInProgress;\n            workInProgress.child = primaryChildFragment;\n            return primaryChildFragment;\n        }\n        function mountSuspenseFallbackChildren(workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n            var mode = workInProgress.mode;\n            var primaryChildProps = {\n                mode: 'hidden',\n                children: primaryChildren\n            };\n            var primaryChildFragment;\n            var fallbackChildFragment;\n            {\n                primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);\n                fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);\n            }\n            primaryChildFragment.return = workInProgress;\n            fallbackChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = fallbackChildFragment;\n            workInProgress.child = primaryChildFragment;\n            return fallbackChildFragment;\n        }\n        function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes) {\n            // The props argument to `createFiberFromOffscreen` is `any` typed, so we use\n            // this wrapper function to constrain it.\n            return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);\n        }\n        function updateWorkInProgressOffscreenFiber(current, offscreenProps) {\n            // The props argument to `createWorkInProgress` is `any` typed, so we use this\n            // wrapper function to constrain it.\n            return createWorkInProgress(current, offscreenProps);\n        }\n        function updateSuspensePrimaryChildren(current, workInProgress, primaryChildren, renderLanes) {\n            var currentPrimaryChildFragment = current.child;\n            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n            var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {\n                mode: 'visible',\n                children: primaryChildren\n            });\n            primaryChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = null;\n            if (currentFallbackChildFragment !== null) {\n                // Delete the fallback child fragment\n                var deletions = workInProgress.deletions;\n                if (deletions === null) {\n                    workInProgress.deletions = [\n                        currentFallbackChildFragment\n                    ];\n                    workInProgress.flags |= ChildDeletion;\n                } else {\n                    deletions.push(currentFallbackChildFragment);\n                }\n            }\n            workInProgress.child = primaryChildFragment;\n            return primaryChildFragment;\n        }\n        function updateSuspenseFallbackChildren(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n            var mode = workInProgress.mode;\n            var currentPrimaryChildFragment = current.child;\n            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n            var primaryChildProps = {\n                mode: 'hidden',\n                children: primaryChildren\n            };\n            var primaryChildFragment;\n            {\n                primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps); // Since we're reusing a current tree, we need to reuse the flags, too.\n                // (We don't do this in legacy mode, because in legacy mode we don't re-use\n                // the current tree; see previous branch.)\n                primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;\n            }\n            var fallbackChildFragment;\n            if (currentFallbackChildFragment !== null) {\n                fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);\n            } else {\n                fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null); // Needs a placement effect because the parent (the Suspense boundary) already\n                // mounted but this is a new fiber.\n                fallbackChildFragment.flags |= Placement;\n            }\n            fallbackChildFragment.return = workInProgress;\n            primaryChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = fallbackChildFragment;\n            workInProgress.child = primaryChildFragment;\n            return fallbackChildFragment;\n        }\n        function retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes) {\n            // Falling back to client rendering. Because this has performance\n            // implications, it's considered a recoverable error, even though the user\n            // likely won't observe anything wrong with the UI.\n            // This will add the old fiber to the deletion list\n            reconcileChildFibers(workInProgress, current.child, null, renderLanes); // We're now not suspended nor dehydrated.\n            var nextProps = workInProgress.pendingProps;\n            var primaryChildren = nextProps.children;\n            var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren); // Needs a placement effect because the parent (the Suspense boundary) already\n            // mounted but this is a new fiber.\n            primaryChildFragment.flags |= Placement;\n            workInProgress.memoizedState = null;\n            return primaryChildFragment;\n        }\n        function mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n            var fiberMode = workInProgress.mode;\n            var primaryChildProps = {\n                mode: 'visible',\n                children: primaryChildren\n            };\n            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);\n            var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes, null); // Needs a placement effect because the parent (the Suspense\n            // boundary) already mounted but this is a new fiber.\n            fallbackChildFragment.flags |= Placement;\n            primaryChildFragment.return = workInProgress;\n            fallbackChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = fallbackChildFragment;\n            workInProgress.child = primaryChildFragment;\n            {\n                // We will have dropped the effect list which contains the\n                // deletion. We need to reconcile to delete the current child.\n                reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n            }\n            return fallbackChildFragment;\n        }\n        function mountDehydratedSuspenseComponent(workInProgress, suspenseInstance, renderLanes) {\n            // During the first pass, we'll bail out and not drill into the children.\n            // Instead, we'll leave the content in place and try to hydrate it later.\n            if (isSuspenseInstanceFallback(suspenseInstance)) {\n                // This is a client-only boundary. Since we won't get any content from the server\n                // for this, we need to schedule that at a higher priority based on when it would\n                // have timed out. In theory we could render it in this pass but it would have the\n                // wrong priority associated with it and will prevent hydration of parent path.\n                // Instead, we'll leave work left on it to render it in a separate commit.\n                // TODO This time should be the time at which the server rendered response that is\n                // a parent to this boundary was displayed. However, since we currently don't have\n                // a protocol to transfer that time, we'll just estimate it by using the current\n                // time. This will mean that Suspense timeouts are slightly shifted to later than\n                // they should be.\n                // Schedule a normal pri update to render this content.\n                workInProgress.lanes = laneToLanes(DefaultHydrationLane);\n            } else {\n                // We'll continue hydrating the rest at offscreen priority since we'll already\n                // be showing the right content coming from the server, it is no rush.\n                workInProgress.lanes = laneToLanes(OffscreenLane);\n            }\n            return null;\n        }\n        function updateDehydratedSuspenseComponent(current, workInProgress, didSuspend, didPrimaryChildrenDefer, nextProps, suspenseInstance, suspenseState, renderLanes) {\n            if (!didSuspend) {\n                // This is the first render pass. Attempt to hydrate.\n                pushPrimaryTreeSuspenseHandler(workInProgress); // We should never be hydrating at this point because it is the first pass,\n                // but after we've already committed once.\n                warnIfHydrating();\n                if (isSuspenseInstanceFallback(suspenseInstance)) {\n                    // This boundary is in a permanent fallback state. In this case, we'll never\n                    // get an update and we'll never be able to hydrate the final content. Let's just try the\n                    // client side render instead.\n                    var digest;\n                    var message;\n                    var stack = null;\n                    var componentStack = null;\n                    {\n                        var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);\n                        digest = _getSuspenseInstanceF.digest;\n                        message = _getSuspenseInstanceF.message;\n                        stack = _getSuspenseInstanceF.stack;\n                        componentStack = _getSuspenseInstanceF.componentStack;\n                    }\n                    {\n                        var error;\n                        if (message) {\n                            // eslint-disable-next-line react-internal/prod-error-codes\n                            error = new Error(message);\n                        } else {\n                            error = new Error('The server could not finish this Suspense boundary, likely ' + 'due to an error during server rendering. ' + 'Switched to client rendering.');\n                        } // Replace the stack with the server stack\n                        error.stack = stack || '';\n                        error.digest = digest;\n                        var capturedValue = createCapturedValueFromError(error, componentStack === undefined ? null : componentStack);\n                        queueHydrationError(capturedValue);\n                    }\n                    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n                }\n                // any context has changed, we need to treat is as if the input might have changed.\n                var hasContextChanged = includesSomeLane(renderLanes, current.childLanes);\n                if (didReceiveUpdate || hasContextChanged) {\n                    // This boundary has changed since the first render. This means that we are now unable to\n                    // hydrate it. We might still be able to hydrate it using a higher priority lane.\n                    var root = getWorkInProgressRoot();\n                    if (root !== null) {\n                        var attemptHydrationAtLane = getBumpedLaneForHydration(root, renderLanes);\n                        if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {\n                            // Intentionally mutating since this render will get interrupted. This\n                            // is one of the very rare times where we mutate the current tree\n                            // during the render phase.\n                            suspenseState.retryLane = attemptHydrationAtLane;\n                            enqueueConcurrentRenderForLane(current, attemptHydrationAtLane);\n                            scheduleUpdateOnFiber(root, current, attemptHydrationAtLane); // Throw a special object that signals to the work loop that it should\n                            // interrupt the current render.\n                            //\n                            // Because we're inside a React-only execution stack, we don't\n                            // strictly need to throw here — we could instead modify some internal\n                            // work loop state. But using an exception means we don't need to\n                            // check for this case on every iteration of the work loop. So doing\n                            // it this way moves the check out of the fast path.\n                            throw SelectiveHydrationException;\n                        }\n                    } // If we did not selectively hydrate, we'll continue rendering without\n                    // hydrating. Mark this tree as suspended to prevent it from committing\n                    // outside a transition.\n                    //\n                    // This path should only happen if the hydration lane already suspended.\n                    // Currently, it also happens during sync updates because there is no\n                    // hydration lane for sync updates.\n                    // TODO: We should ideally have a sync hydration lane that we can apply to do\n                    // a pass where we hydrate this subtree in place using the previous Context and then\n                    // reapply the update afterwards.\n                    if (isSuspenseInstancePending(suspenseInstance)) ;\n                    else {\n                        renderDidSuspendDelayIfPossible();\n                    }\n                    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n                } else if (isSuspenseInstancePending(suspenseInstance)) {\n                    // This component is still pending more data from the server, so we can't hydrate its\n                    // content. We treat it as if this component suspended itself. It might seem as if\n                    // we could just try to render it client-side instead. However, this will perform a\n                    // lot of unnecessary work and is unlikely to complete since it often will suspend\n                    // on missing data anyway. Additionally, the server might be able to render more\n                    // than we can on the client yet. In that case we'd end up with more fallback states\n                    // on the client than if we just leave it alone. If the server times out or errors\n                    // these should update this boundary to the permanent Fallback state instead.\n                    // Mark it as having captured (i.e. suspended).\n                    workInProgress.flags |= DidCapture; // Leave the child in place. I.e. the dehydrated fragment.\n                    workInProgress.child = current.child; // Register a callback to retry this boundary once the server has sent the result.\n                    var retry = retryDehydratedSuspenseBoundary.bind(null, current);\n                    registerSuspenseInstanceRetry(suspenseInstance, retry);\n                    return null;\n                } else {\n                    // This is the first attempt.\n                    reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress, suspenseInstance, suspenseState.treeContext);\n                    var primaryChildren = nextProps.children;\n                    var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren); // Mark the children as hydrating. This is a fast path to know whether this\n                    // tree is part of a hydrating tree. This is used to determine if a child\n                    // node has fully mounted yet, and for scheduling event replaying.\n                    // Conceptually this is similar to Placement in that a new subtree is\n                    // inserted into the React tree here. It just happens to not need DOM\n                    // mutations because it already exists.\n                    primaryChildFragment.flags |= Hydrating;\n                    return primaryChildFragment;\n                }\n            } else {\n                // This is the second render pass. We already attempted to hydrated, but\n                // something either suspended or errored.\n                if (workInProgress.flags & ForceClientRender) {\n                    // Something errored during hydration. Try again without hydrating.\n                    // The error should've already been logged in throwException.\n                    pushPrimaryTreeSuspenseHandler(workInProgress);\n                    workInProgress.flags &= ~ForceClientRender;\n                    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n                } else if (workInProgress.memoizedState !== null) {\n                    // Something suspended and we should still be in dehydrated mode.\n                    // Leave the existing child in place.\n                    // Push to avoid a mismatch\n                    pushFallbackTreeSuspenseHandler(workInProgress);\n                    workInProgress.child = current.child; // The dehydrated completion pass expects this flag to be there\n                    // but the normal suspense pass doesn't.\n                    workInProgress.flags |= DidCapture;\n                    return null;\n                } else {\n                    // Suspended but we should no longer be in dehydrated mode.\n                    // Therefore we now have to render the fallback.\n                    pushFallbackTreeSuspenseHandler(workInProgress);\n                    var nextPrimaryChildren = nextProps.children;\n                    var nextFallbackChildren = nextProps.fallback;\n                    var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n                    var _primaryChildFragment4 = workInProgress.child;\n                    _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes);\n                    _primaryChildFragment4.childLanes = getRemainingWorkInPrimaryTree(current, didPrimaryChildrenDefer, renderLanes);\n                    workInProgress.memoizedState = SUSPENDED_MARKER;\n                    return fallbackChildFragment;\n                }\n            }\n        }\n        function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {\n            fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\n            var alternate = fiber.alternate;\n            if (alternate !== null) {\n                alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\n            }\n            scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);\n        }\n        function propagateSuspenseContextChange(workInProgress, firstChild, renderLanes) {\n            // Mark any Suspense boundaries with fallbacks as having work to do.\n            // If they were previously forced into fallbacks, they may now be able\n            // to unblock.\n            var node = firstChild;\n            while(node !== null){\n                if (node.tag === SuspenseComponent) {\n                    var state = node.memoizedState;\n                    if (state !== null) {\n                        scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\n                    }\n                } else if (node.tag === SuspenseListComponent) {\n                    // If the tail is hidden there might not be an Suspense boundaries\n                    // to schedule work on. In this case we have to schedule it on the\n                    // list itself.\n                    // We don't have to traverse to the children of the list since\n                    // the list will propagate the change when it rerenders.\n                    scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\n                } else if (node.child !== null) {\n                    node.child.return = node;\n                    node = node.child;\n                    continue;\n                }\n                if (node === workInProgress) {\n                    return;\n                } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                while(node.sibling === null){\n                    // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    if (node.return === null || node.return === workInProgress) {\n                        return;\n                    }\n                    node = node.return;\n                } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                node.sibling.return = node.return;\n                node = node.sibling;\n            }\n        }\n        function findLastContentRow(firstChild) {\n            // This is going to find the last row among these children that is already\n            // showing content on the screen, as opposed to being in fallback state or\n            // new. If a row has multiple Suspense boundaries, any of them being in the\n            // fallback state, counts as the whole row being in a fallback state.\n            // Note that the \"rows\" will be workInProgress, but any nested children\n            // will still be current since we haven't rendered them yet. The mounted\n            // order may not be the same as the new order. We use the new order.\n            var row = firstChild;\n            var lastContentRow = null;\n            while(row !== null){\n                var currentRow = row.alternate; // New rows can't be content rows.\n                if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n                    lastContentRow = row;\n                }\n                row = row.sibling;\n            }\n            return lastContentRow;\n        }\n        function validateRevealOrder(revealOrder) {\n            {\n                if (revealOrder !== undefined && revealOrder !== 'forwards' && revealOrder !== 'backwards' && revealOrder !== 'together' && !didWarnAboutRevealOrder[revealOrder]) {\n                    didWarnAboutRevealOrder[revealOrder] = true;\n                    if (typeof revealOrder === 'string') {\n                        switch(revealOrder.toLowerCase()){\n                            case 'together':\n                            case 'forwards':\n                            case 'backwards':\n                                {\n                                    error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'Use lowercase \"%s\" instead.', revealOrder, revealOrder.toLowerCase());\n                                    break;\n                                }\n                            case 'forward':\n                            case 'backward':\n                                {\n                                    error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'React uses the -s suffix in the spelling. Use \"%ss\" instead.', revealOrder, revealOrder.toLowerCase());\n                                    break;\n                                }\n                            default:\n                                error('\"%s\" is not a supported revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n                                break;\n                        }\n                    } else {\n                        error('%s is not a supported value for revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n                    }\n                }\n            }\n        }\n        function validateTailOptions(tailMode, revealOrder) {\n            {\n                if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {\n                    if (tailMode !== 'collapsed' && tailMode !== 'hidden') {\n                        didWarnAboutTailOptions[tailMode] = true;\n                        error('\"%s\" is not a supported value for tail on <SuspenseList />. ' + 'Did you mean \"collapsed\" or \"hidden\"?', tailMode);\n                    } else if (revealOrder !== 'forwards' && revealOrder !== 'backwards') {\n                        didWarnAboutTailOptions[tailMode] = true;\n                        error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is ' + '\"forwards\" or \"backwards\". ' + 'Did you mean to specify revealOrder=\"forwards\"?', tailMode);\n                    }\n                }\n            }\n        }\n        function validateSuspenseListNestedChild(childSlot, index) {\n            {\n                var isAnArray = isArray(childSlot);\n                var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === 'function';\n                if (isAnArray || isIterable) {\n                    var type = isAnArray ? 'array' : 'iterable';\n                    error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in ' + 'an additional SuspenseList to configure its revealOrder: ' + '<SuspenseList revealOrder=...> ... ' + '<SuspenseList revealOrder=...>{%s}</SuspenseList> ... ' + '</SuspenseList>', type, index, type);\n                    return false;\n                }\n            }\n            return true;\n        }\n        function validateSuspenseListChildren(children, revealOrder) {\n            {\n                if ((revealOrder === 'forwards' || revealOrder === 'backwards') && children !== undefined && children !== null && children !== false) {\n                    if (isArray(children)) {\n                        for(var i = 0; i < children.length; i++){\n                            if (!validateSuspenseListNestedChild(children[i], i)) {\n                                return;\n                            }\n                        }\n                    } else {\n                        var iteratorFn = getIteratorFn(children);\n                        if (typeof iteratorFn === 'function') {\n                            var childrenIterator = iteratorFn.call(children);\n                            if (childrenIterator) {\n                                var step = childrenIterator.next();\n                                var _i = 0;\n                                for(; !step.done; step = childrenIterator.next()){\n                                    if (!validateSuspenseListNestedChild(step.value, _i)) {\n                                        return;\n                                    }\n                                    _i++;\n                                }\n                            }\n                        } else {\n                            error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. ' + 'This is not useful since it needs multiple rows. ' + 'Did you mean to pass multiple children or an array?', revealOrder);\n                        }\n                    }\n                }\n            }\n        }\n        function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {\n            var renderState = workInProgress.memoizedState;\n            if (renderState === null) {\n                workInProgress.memoizedState = {\n                    isBackwards: isBackwards,\n                    rendering: null,\n                    renderingStartTime: 0,\n                    last: lastContentRow,\n                    tail: tail,\n                    tailMode: tailMode\n                };\n            } else {\n                // We can reuse the existing object from previous renders.\n                renderState.isBackwards = isBackwards;\n                renderState.rendering = null;\n                renderState.renderingStartTime = 0;\n                renderState.last = lastContentRow;\n                renderState.tail = tail;\n                renderState.tailMode = tailMode;\n            }\n        } // This can end up rendering this component multiple passes.\n        // The first pass splits the children fibers into two sets. A head and tail.\n        // We first render the head. If anything is in fallback state, we do another\n        // pass through beginWork to rerender all children (including the tail) with\n        // the force suspend context. If the first render didn't have anything in\n        // in fallback state. Then we render each row in the tail one-by-one.\n        // That happens in the completeWork phase without going back to beginWork.\n        function updateSuspenseListComponent(current, workInProgress, renderLanes) {\n            var nextProps = workInProgress.pendingProps;\n            var revealOrder = nextProps.revealOrder;\n            var tailMode = nextProps.tail;\n            var newChildren = nextProps.children;\n            validateRevealOrder(revealOrder);\n            validateTailOptions(tailMode, revealOrder);\n            validateSuspenseListChildren(newChildren, revealOrder);\n            reconcileChildren(current, workInProgress, newChildren, renderLanes);\n            var suspenseContext = suspenseStackCursor.current;\n            var shouldForceFallback = hasSuspenseListContext(suspenseContext, ForceSuspenseFallback);\n            if (shouldForceFallback) {\n                suspenseContext = setShallowSuspenseListContext(suspenseContext, ForceSuspenseFallback);\n                workInProgress.flags |= DidCapture;\n            } else {\n                var didSuspendBefore = current !== null && (current.flags & DidCapture) !== NoFlags$1;\n                if (didSuspendBefore) {\n                    // If we previously forced a fallback, we need to schedule work\n                    // on any nested boundaries to let them know to try to render\n                    // again. This is the same as context updating.\n                    propagateSuspenseContextChange(workInProgress, workInProgress.child, renderLanes);\n                }\n                suspenseContext = setDefaultShallowSuspenseListContext(suspenseContext);\n            }\n            pushSuspenseListContext(workInProgress, suspenseContext);\n            {\n                switch(revealOrder){\n                    case 'forwards':\n                        {\n                            var lastContentRow = findLastContentRow(workInProgress.child);\n                            var tail;\n                            if (lastContentRow === null) {\n                                // The whole list is part of the tail.\n                                // TODO: We could fast path by just rendering the tail now.\n                                tail = workInProgress.child;\n                                workInProgress.child = null;\n                            } else {\n                                // Disconnect the tail rows after the content row.\n                                // We're going to render them separately later.\n                                tail = lastContentRow.sibling;\n                                lastContentRow.sibling = null;\n                            }\n                            initSuspenseListRenderState(workInProgress, false, tail, lastContentRow, tailMode);\n                            break;\n                        }\n                    case 'backwards':\n                        {\n                            // We're going to find the first row that has existing content.\n                            // At the same time we're going to reverse the list of everything\n                            // we pass in the meantime. That's going to be our tail in reverse\n                            // order.\n                            var _tail = null;\n                            var row = workInProgress.child;\n                            workInProgress.child = null;\n                            while(row !== null){\n                                var currentRow = row.alternate; // New rows can't be content rows.\n                                if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n                                    // This is the beginning of the main content.\n                                    workInProgress.child = row;\n                                    break;\n                                }\n                                var nextRow = row.sibling;\n                                row.sibling = _tail;\n                                _tail = row;\n                                row = nextRow;\n                            } // TODO: If workInProgress.child is null, we can continue on the tail immediately.\n                            initSuspenseListRenderState(workInProgress, true, _tail, null, tailMode);\n                            break;\n                        }\n                    case 'together':\n                        {\n                            initSuspenseListRenderState(workInProgress, false, null, null, undefined);\n                            break;\n                        }\n                    default:\n                        {\n                            // The default reveal order is the same as not having\n                            // a boundary.\n                            workInProgress.memoizedState = null;\n                        }\n                }\n            }\n            return workInProgress.child;\n        }\n        function updatePortalComponent(current, workInProgress, renderLanes) {\n            pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n            var nextChildren = workInProgress.pendingProps;\n            if (current === null) {\n                // Portals are special because we don't append the children during mount\n                // but at commit. Therefore we need to track insertions which the normal\n                // flow doesn't do during mount. This doesn't happen at the root because\n                // the root always starts with a \"current\" with a null child.\n                // TODO: Consider unifying this with how the root works.\n                workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n            } else {\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            }\n            return workInProgress.child;\n        }\n        var hasWarnedAboutUsingNoValuePropOnContextProvider = false;\n        function updateContextProvider(current, workInProgress, renderLanes) {\n            var context;\n            {\n                context = workInProgress.type;\n            }\n            var newProps = workInProgress.pendingProps;\n            var oldProps = workInProgress.memoizedProps;\n            var newValue = newProps.value;\n            {\n                if (!('value' in newProps)) {\n                    if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {\n                        hasWarnedAboutUsingNoValuePropOnContextProvider = true;\n                        error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');\n                    }\n                }\n            }\n            pushProvider(workInProgress, context, newValue);\n            {\n                if (oldProps !== null) {\n                    var oldValue = oldProps.value;\n                    if (objectIs(oldValue, newValue)) {\n                        // No change. Bailout early if children are the same.\n                        if (oldProps.children === newProps.children && !hasContextChanged()) {\n                            return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                        }\n                    } else {\n                        // The context value changed. Search for matching consumers and schedule\n                        // them to update.\n                        propagateContextChange(workInProgress, context, renderLanes);\n                    }\n                }\n            }\n            var newChildren = newProps.children;\n            reconcileChildren(current, workInProgress, newChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateContextConsumer(current, workInProgress, renderLanes) {\n            var context;\n            {\n                var consumerType = workInProgress.type;\n                context = consumerType._context;\n            }\n            var newProps = workInProgress.pendingProps;\n            var render = newProps.children;\n            {\n                if (typeof render !== 'function') {\n                    error('A context consumer was rendered with multiple children, or a child ' + \"that isn't a function. A context consumer expects a single child \" + 'that is a function. If you did pass a function, make sure there ' + 'is no trailing or leading whitespace around it.');\n                }\n            }\n            prepareToReadContext(workInProgress, renderLanes);\n            var newValue = readContext(context);\n            {\n                markComponentRenderStarted(workInProgress);\n            }\n            var newChildren;\n            {\n                setIsRendering(true);\n                newChildren = render(newValue);\n                setIsRendering(false);\n            }\n            {\n                markComponentRenderStopped();\n            }\n            workInProgress.flags |= PerformedWork;\n            reconcileChildren(current, workInProgress, newChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function markWorkInProgressReceivedUpdate() {\n            didReceiveUpdate = true;\n        }\n        function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {\n            if (current !== null) {\n                // Reuse previous dependencies\n                workInProgress.dependencies = current.dependencies;\n            }\n            {\n                // Don't update \"base\" render times for bailouts.\n                stopProfilerTimerIfRunning();\n            }\n            markSkippedUpdateLanes(workInProgress.lanes); // Check if the children have any pending work.\n            if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {\n                // The children don't have any work either. We can skip them.\n                // TODO: Once we add back resuming, we should check if the children are\n                // a work-in-progress set. If so, we need to transfer their effects.\n                {\n                    return null;\n                }\n            } // This fiber doesn't have work, but its subtree does. Clone the child\n            // fibers and continue.\n            cloneChildFibers(current, workInProgress);\n            return workInProgress.child;\n        }\n        function remountFiber(current, oldWorkInProgress, newWorkInProgress) {\n            {\n                var returnFiber = oldWorkInProgress.return;\n                if (returnFiber === null) {\n                    // eslint-disable-next-line react-internal/prod-error-codes\n                    throw new Error('Cannot swap the root fiber.');\n                } // Disconnect from the old current.\n                // It will get deleted.\n                current.alternate = null;\n                oldWorkInProgress.alternate = null; // Connect to the new tree.\n                newWorkInProgress.index = oldWorkInProgress.index;\n                newWorkInProgress.sibling = oldWorkInProgress.sibling;\n                newWorkInProgress.return = oldWorkInProgress.return;\n                newWorkInProgress.ref = oldWorkInProgress.ref;\n                {\n                    newWorkInProgress._debugInfo = oldWorkInProgress._debugInfo;\n                }\n                if (oldWorkInProgress === returnFiber.child) {\n                    returnFiber.child = newWorkInProgress;\n                } else {\n                    var prevSibling = returnFiber.child;\n                    if (prevSibling === null) {\n                        // eslint-disable-next-line react-internal/prod-error-codes\n                        throw new Error('Expected parent to have a child.');\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    while(prevSibling.sibling !== oldWorkInProgress){\n                        // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        prevSibling = prevSibling.sibling;\n                        if (prevSibling === null) {\n                            // eslint-disable-next-line react-internal/prod-error-codes\n                            throw new Error('Expected to find the previous sibling.');\n                        }\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    prevSibling.sibling = newWorkInProgress;\n                } // Delete the old fiber and place the new one.\n                // Since the old fiber is disconnected, we have to schedule it manually.\n                var deletions = returnFiber.deletions;\n                if (deletions === null) {\n                    returnFiber.deletions = [\n                        current\n                    ];\n                    returnFiber.flags |= ChildDeletion;\n                } else {\n                    deletions.push(current);\n                }\n                newWorkInProgress.flags |= Placement; // Restart work from the new fiber.\n                return newWorkInProgress;\n            }\n        }\n        function checkScheduledUpdateOrContext(current, renderLanes) {\n            // Before performing an early bailout, we must check if there are pending\n            // updates or context.\n            var updateLanes = current.lanes;\n            if (includesSomeLane(updateLanes, renderLanes)) {\n                return true;\n            } // No pending update, but because context is propagated lazily, we need\n            return false;\n        }\n        function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {\n            // This fiber does not have any pending work. Bailout without entering\n            // the begin phase. There's still some bookkeeping we that needs to be done\n            // in this optimized path, mostly pushing stuff onto the stack.\n            switch(workInProgress.tag){\n                case HostRoot:\n                    pushHostRootContext(workInProgress);\n                    {\n                        var cache = current.memoizedState.cache;\n                        pushCacheProvider(workInProgress, cache);\n                    }\n                    resetHydrationState();\n                    break;\n                case HostSingleton:\n                case HostComponent:\n                    pushHostContext(workInProgress);\n                    break;\n                case ClassComponent:\n                    {\n                        break;\n                    }\n                case HostPortal:\n                    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                    break;\n                case ContextProvider:\n                    {\n                        var newValue = workInProgress.memoizedProps.value;\n                        var context;\n                        {\n                            context = workInProgress.type;\n                        }\n                        pushProvider(workInProgress, context, newValue);\n                        break;\n                    }\n                case Profiler:\n                    {\n                        // Profiler should only call onRender when one of its descendants actually rendered.\n                        var hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n                        if (hasChildWork) {\n                            workInProgress.flags |= Update;\n                        }\n                        {\n                            // Reset effect durations for the next eventual effect phase.\n                            // These are reset during render to allow the DevTools commit hook a chance to read them,\n                            var stateNode = workInProgress.stateNode;\n                            stateNode.effectDuration = 0;\n                            stateNode.passiveEffectDuration = 0;\n                        }\n                    }\n                    break;\n                case SuspenseComponent:\n                    {\n                        var state = workInProgress.memoizedState;\n                        if (state !== null) {\n                            if (state.dehydrated !== null) {\n                                // We're not going to render the children, so this is just to maintain\n                                // push/pop symmetry\n                                pushPrimaryTreeSuspenseHandler(workInProgress); // We know that this component will suspend again because if it has\n                                // been unsuspended it has committed as a resolved Suspense component.\n                                // If it needs to be retried, it should have work scheduled on it.\n                                workInProgress.flags |= DidCapture; // We should never render the children of a dehydrated boundary until we\n                                // upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.\n                                return null;\n                            } // If this boundary is currently timed out, we need to decide\n                            // whether to retry the primary children, or to skip over it and\n                            // go straight to the fallback. Check the priority of the primary\n                            // child fragment.\n                            var primaryChildFragment = workInProgress.child;\n                            var primaryChildLanes = primaryChildFragment.childLanes;\n                            if (includesSomeLane(renderLanes, primaryChildLanes)) {\n                                // The primary children have pending work. Use the normal path\n                                // to attempt to render the primary children again.\n                                return updateSuspenseComponent(current, workInProgress, renderLanes);\n                            } else {\n                                // The primary child fragment does not have pending work marked\n                                // on it\n                                pushPrimaryTreeSuspenseHandler(workInProgress); // The primary children do not have pending work with sufficient\n                                // priority. Bailout.\n                                var child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                                if (child !== null) {\n                                    // The fallback children have pending work. Skip over the\n                                    // primary children and work on the fallback.\n                                    return child.sibling;\n                                } else {\n                                    // Note: We can return `null` here because we already checked\n                                    // whether there were nested context consumers, via the call to\n                                    // `bailoutOnAlreadyFinishedWork` above.\n                                    return null;\n                                }\n                            }\n                        } else {\n                            pushPrimaryTreeSuspenseHandler(workInProgress);\n                        }\n                        break;\n                    }\n                case SuspenseListComponent:\n                    {\n                        var didSuspendBefore = (current.flags & DidCapture) !== NoFlags$1;\n                        var _hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n                        if (didSuspendBefore) {\n                            if (_hasChildWork) {\n                                // If something was in fallback state last time, and we have all the\n                                // same children then we're still in progressive loading state.\n                                // Something might get unblocked by state updates or retries in the\n                                // tree which will affect the tail. So we need to use the normal\n                                // path to compute the correct tail.\n                                return updateSuspenseListComponent(current, workInProgress, renderLanes);\n                            } // If none of the children had any work, that means that none of\n                            // them got retried so they'll still be blocked in the same way\n                            // as before. We can fast bail out.\n                            workInProgress.flags |= DidCapture;\n                        } // If nothing suspended before and we're rendering the same children,\n                        // then the tail doesn't matter. Anything new that suspends will work\n                        // in the \"together\" mode, so we can continue from the state we had.\n                        var renderState = workInProgress.memoizedState;\n                        if (renderState !== null) {\n                            // Reset to the \"together\" mode in case we've started a different\n                            // update in the past but didn't complete it.\n                            renderState.rendering = null;\n                            renderState.tail = null;\n                            renderState.lastEffect = null;\n                        }\n                        pushSuspenseListContext(workInProgress, suspenseStackCursor.current);\n                        if (_hasChildWork) {\n                            break;\n                        } else {\n                            // If none of the children had any work, that means that none of\n                            // them got retried so they'll still be blocked in the same way\n                            // as before. We can fast bail out.\n                            return null;\n                        }\n                    }\n                case OffscreenComponent:\n                case LegacyHiddenComponent:\n                    {\n                        // Need to check if the tree still needs to be deferred. This is\n                        // almost identical to the logic used in the normal update path,\n                        // so we'll just enter that. The only difference is we'll bail out\n                        // at the next level instead of this one, because the child props\n                        // have not changed. Which is fine.\n                        // TODO: Probably should refactor `beginWork` to split the bailout\n                        // path from the normal path. I'm tempted to do a labeled break here\n                        // but I won't :)\n                        workInProgress.lanes = NoLanes;\n                        return updateOffscreenComponent(current, workInProgress, renderLanes);\n                    }\n                case CacheComponent:\n                    {\n                        {\n                            var _cache = current.memoizedState.cache;\n                            pushCacheProvider(workInProgress, _cache);\n                        }\n                        break;\n                    }\n            }\n            return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        }\n        function beginWork(current, workInProgress, renderLanes) {\n            {\n                if (workInProgress._debugNeedsRemount && current !== null) {\n                    // This will restart the begin phase with a new fiber.\n                    return remountFiber(current, workInProgress, createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes));\n                }\n            }\n            if (current !== null) {\n                var oldProps = current.memoizedProps;\n                var newProps = workInProgress.pendingProps;\n                if (oldProps !== newProps || hasContextChanged() || workInProgress.type !== current.type) {\n                    // If props or context changed, mark the fiber as having performed work.\n                    // This may be unset if the props are determined to be equal later (memo).\n                    didReceiveUpdate = true;\n                } else {\n                    // Neither props nor legacy context changes. Check if there's a pending\n                    // update or context change.\n                    var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);\n                    if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there\n                    // may not be work scheduled on `current`, so we check for this flag.\n                    (workInProgress.flags & DidCapture) === NoFlags$1) {\n                        // No pending updates or context. Bail out now.\n                        didReceiveUpdate = false;\n                        return attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);\n                    }\n                    if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags$1) {\n                        // This is a special case that only exists for legacy mode.\n                        // See https://github.com/facebook/react/pull/19216.\n                        didReceiveUpdate = true;\n                    } else {\n                        // An update was scheduled on this fiber, but there are no new props\n                        // nor legacy context. Set this to false. If an update queue or context\n                        // consumer produces a changed value, it will set this to true. Otherwise,\n                        // the component will assume the children have not changed and bail out.\n                        didReceiveUpdate = false;\n                    }\n                }\n            } else {\n                didReceiveUpdate = false;\n                if (getIsHydrating() && isForkedChild(workInProgress)) {\n                    // Check if this child belongs to a list of muliple children in\n                    // its parent.\n                    //\n                    // In a true multi-threaded implementation, we would render children on\n                    // parallel threads. This would represent the beginning of a new render\n                    // thread for this subtree.\n                    //\n                    // We only use this for id generation during hydration, which is why the\n                    // logic is located in this special branch.\n                    var slotIndex = workInProgress.index;\n                    var numberOfForks = getForksAtLevel();\n                    pushTreeId(workInProgress, numberOfForks, slotIndex);\n                }\n            } // Before entering the begin phase, clear pending update priority.\n            // TODO: This assumes that we're about to evaluate the component and process\n            // the update queue. However, there's an exception: SimpleMemoComponent\n            // sometimes bails out later in the begin phase. This indicates that we should\n            // move this assignment out of the common path and into each branch.\n            workInProgress.lanes = NoLanes;\n            switch(workInProgress.tag){\n                case LazyComponent:\n                    {\n                        var elementType = workInProgress.elementType;\n                        return mountLazyComponent(current, workInProgress, elementType, renderLanes);\n                    }\n                case FunctionComponent:\n                    {\n                        var Component = workInProgress.type;\n                        var unresolvedProps = workInProgress.pendingProps;\n                        var resolvedProps = unresolvedProps;\n                        return updateFunctionComponent(current, workInProgress, Component, resolvedProps, renderLanes);\n                    }\n                case ClassComponent:\n                    {\n                        var _Component = workInProgress.type;\n                        var _unresolvedProps = workInProgress.pendingProps;\n                        var _resolvedProps4 = resolveClassComponentProps(_Component, _unresolvedProps);\n                        return updateClassComponent(current, workInProgress, _Component, _resolvedProps4, renderLanes);\n                    }\n                case HostRoot:\n                    return updateHostRoot(current, workInProgress, renderLanes);\n                case HostHoistable:\n                    if (supportsResources) {\n                        return updateHostHoistable(current, workInProgress);\n                    }\n                // Fall through\n                case HostSingleton:\n                    if (supportsSingletons) {\n                        return updateHostSingleton(current, workInProgress, renderLanes);\n                    }\n                // Fall through\n                case HostComponent:\n                    return updateHostComponent$1(current, workInProgress, renderLanes);\n                case HostText:\n                    return updateHostText$1(current, workInProgress);\n                case SuspenseComponent:\n                    return updateSuspenseComponent(current, workInProgress, renderLanes);\n                case HostPortal:\n                    return updatePortalComponent(current, workInProgress, renderLanes);\n                case ForwardRef:\n                    {\n                        var type = workInProgress.type;\n                        var _unresolvedProps2 = workInProgress.pendingProps;\n                        var _resolvedProps5 = _unresolvedProps2;\n                        return updateForwardRef(current, workInProgress, type, _resolvedProps5, renderLanes);\n                    }\n                case Fragment:\n                    return updateFragment(current, workInProgress, renderLanes);\n                case Mode:\n                    return updateMode(current, workInProgress, renderLanes);\n                case Profiler:\n                    return updateProfiler(current, workInProgress, renderLanes);\n                case ContextProvider:\n                    return updateContextProvider(current, workInProgress, renderLanes);\n                case ContextConsumer:\n                    return updateContextConsumer(current, workInProgress, renderLanes);\n                case MemoComponent:\n                    {\n                        var _type = workInProgress.type;\n                        var _unresolvedProps3 = workInProgress.pendingProps; // Resolve outer props first, then resolve inner props.\n                        var _resolvedProps6 = _unresolvedProps3;\n                        _resolvedProps6 = _resolvedProps6;\n                        return updateMemoComponent(current, workInProgress, _type, _resolvedProps6, renderLanes);\n                    }\n                case SimpleMemoComponent:\n                    {\n                        return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n                    }\n                case IncompleteClassComponent:\n                    {\n                        {\n                            break;\n                        }\n                    }\n                case IncompleteFunctionComponent:\n                    {\n                        {\n                            break;\n                        }\n                    }\n                case SuspenseListComponent:\n                    {\n                        return updateSuspenseListComponent(current, workInProgress, renderLanes);\n                    }\n                case ScopeComponent:\n                    {\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        return updateOffscreenComponent(current, workInProgress, renderLanes);\n                    }\n                case LegacyHiddenComponent:\n                    {\n                        break;\n                    }\n                case CacheComponent:\n                    {\n                        {\n                            return updateCacheComponent(current, workInProgress, renderLanes);\n                        }\n                    }\n            }\n            throw new Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in \" + 'React. Please file an issue.');\n        }\n        var valueCursor = createCursor(null);\n        var rendererCursorDEV;\n        {\n            rendererCursorDEV = createCursor(null);\n        }\n        var renderer2CursorDEV;\n        {\n            renderer2CursorDEV = createCursor(null);\n        }\n        var rendererSigil;\n        {\n            // Use this to detect multiple renderers using the same context\n            rendererSigil = {};\n        }\n        var currentlyRenderingFiber = null;\n        var lastContextDependency = null;\n        var lastFullyObservedContext = null;\n        var isDisallowedContextReadInDEV = false;\n        function resetContextDependencies() {\n            // This is called right before React yields execution, to ensure `readContext`\n            // cannot be called outside the render phase.\n            currentlyRenderingFiber = null;\n            lastContextDependency = null;\n            lastFullyObservedContext = null;\n            {\n                isDisallowedContextReadInDEV = false;\n            }\n        }\n        function enterDisallowedContextReadInDEV() {\n            {\n                isDisallowedContextReadInDEV = true;\n            }\n        }\n        function exitDisallowedContextReadInDEV() {\n            {\n                isDisallowedContextReadInDEV = false;\n            }\n        }\n        function pushProvider(providerFiber, context, nextValue) {\n            if (isPrimaryRenderer) {\n                push(valueCursor, context._currentValue, providerFiber);\n                context._currentValue = nextValue;\n                {\n                    push(rendererCursorDEV, context._currentRenderer, providerFiber);\n                    if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {\n                        error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');\n                    }\n                    context._currentRenderer = rendererSigil;\n                }\n            } else {\n                push(valueCursor, context._currentValue2, providerFiber);\n                context._currentValue2 = nextValue;\n                {\n                    push(renderer2CursorDEV, context._currentRenderer2, providerFiber);\n                    if (context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {\n                        error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');\n                    }\n                    context._currentRenderer2 = rendererSigil;\n                }\n            }\n        }\n        function popProvider(context, providerFiber) {\n            var currentValue = valueCursor.current;\n            if (isPrimaryRenderer) {\n                context._currentValue = currentValue;\n                {\n                    var currentRenderer = rendererCursorDEV.current;\n                    pop(rendererCursorDEV, providerFiber);\n                    context._currentRenderer = currentRenderer;\n                }\n            } else {\n                context._currentValue2 = currentValue;\n                {\n                    var currentRenderer2 = renderer2CursorDEV.current;\n                    pop(renderer2CursorDEV, providerFiber);\n                    context._currentRenderer2 = currentRenderer2;\n                }\n            }\n            pop(valueCursor, providerFiber);\n        }\n        function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {\n            // Update the child lanes of all the ancestors, including the alternates.\n            var node = parent;\n            while(node !== null){\n                var alternate = node.alternate;\n                if (!isSubsetOfLanes(node.childLanes, renderLanes)) {\n                    node.childLanes = mergeLanes(node.childLanes, renderLanes);\n                    if (alternate !== null) {\n                        alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);\n                    }\n                } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes)) {\n                    alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);\n                } else ;\n                if (node === propagationRoot) {\n                    break;\n                }\n                node = node.return;\n            }\n            {\n                if (node !== propagationRoot) {\n                    error('Expected to find the propagation root when scheduling context work. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n                }\n            }\n        }\n        function propagateContextChange(workInProgress, context, renderLanes) {\n            {\n                propagateContextChange_eager(workInProgress, context, renderLanes);\n            }\n        }\n        function propagateContextChange_eager(workInProgress, context, renderLanes) {\n            var fiber = workInProgress.child;\n            if (fiber !== null) {\n                // Set the return pointer of the child to the work-in-progress fiber.\n                fiber.return = workInProgress;\n            }\n            while(fiber !== null){\n                var nextFiber = void 0; // Visit this fiber.\n                var list = fiber.dependencies;\n                if (list !== null) {\n                    nextFiber = fiber.child;\n                    var dependency = list.firstContext;\n                    while(dependency !== null){\n                        // Check if the context matches.\n                        if (dependency.context === context) {\n                            // Match! Schedule an update on this fiber.\n                            if (fiber.tag === ClassComponent) {\n                                // Schedule a force update on the work-in-progress.\n                                var lane = pickArbitraryLane(renderLanes);\n                                var update = createUpdate(lane);\n                                update.tag = ForceUpdate; // TODO: Because we don't have a work-in-progress, this will add the\n                                // update to the current fiber, too, which means it will persist even if\n                                // this render is thrown away. Since it's a race condition, not sure it's\n                                // worth fixing.\n                                // Inlined `enqueueUpdate` to remove interleaved update check\n                                var updateQueue = fiber.updateQueue;\n                                if (updateQueue === null) ;\n                                else {\n                                    var sharedQueue = updateQueue.shared;\n                                    var pending = sharedQueue.pending;\n                                    if (pending === null) {\n                                        // This is the first update. Create a circular list.\n                                        update.next = update;\n                                    } else {\n                                        update.next = pending.next;\n                                        pending.next = update;\n                                    }\n                                    sharedQueue.pending = update;\n                                }\n                            }\n                            fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\n                            var alternate = fiber.alternate;\n                            if (alternate !== null) {\n                                alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\n                            }\n                            scheduleContextWorkOnParentPath(fiber.return, renderLanes, workInProgress); // Mark the updated lanes on the list, too.\n                            list.lanes = mergeLanes(list.lanes, renderLanes); // Since we already found a match, we can stop traversing the\n                            break;\n                        }\n                        dependency = dependency.next;\n                    }\n                } else if (fiber.tag === ContextProvider) {\n                    // Don't scan deeper if this is a matching provider\n                    nextFiber = fiber.type === workInProgress.type ? null : fiber.child;\n                } else if (fiber.tag === DehydratedFragment) {\n                    // If a dehydrated suspense boundary is in this subtree, we don't know\n                    // if it will have any context consumers in it. The best we can do is\n                    // mark it as having updates.\n                    var parentSuspense = fiber.return;\n                    if (parentSuspense === null) {\n                        throw new Error('We just came from a parent so we must have had a parent. This is a bug in React.');\n                    }\n                    parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes);\n                    var _alternate = parentSuspense.alternate;\n                    if (_alternate !== null) {\n                        _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes);\n                    } // This is intentionally passing this fiber as the parent\n                    // because we want to schedule this fiber as having work\n                    // on its children. We'll use the childLanes on\n                    // this fiber to indicate that a context has changed.\n                    scheduleContextWorkOnParentPath(parentSuspense, renderLanes, workInProgress);\n                    nextFiber = fiber.sibling;\n                } else {\n                    // Traverse down.\n                    nextFiber = fiber.child;\n                }\n                if (nextFiber !== null) {\n                    // Set the return pointer of the child to the work-in-progress fiber.\n                    nextFiber.return = fiber;\n                } else {\n                    // No child. Traverse to next sibling.\n                    nextFiber = fiber;\n                    while(nextFiber !== null){\n                        if (nextFiber === workInProgress) {\n                            // We're back to the root of this subtree. Exit.\n                            nextFiber = null;\n                            break;\n                        }\n                        var sibling = nextFiber.sibling;\n                        if (sibling !== null) {\n                            // Set the return pointer of the sibling to the work-in-progress fiber.\n                            sibling.return = nextFiber.return;\n                            nextFiber = sibling;\n                            break;\n                        } // No more siblings. Traverse up.\n                        nextFiber = nextFiber.return;\n                    }\n                }\n                fiber = nextFiber;\n            }\n        }\n        function prepareToReadContext(workInProgress, renderLanes) {\n            currentlyRenderingFiber = workInProgress;\n            lastContextDependency = null;\n            lastFullyObservedContext = null;\n            var dependencies = workInProgress.dependencies;\n            if (dependencies !== null) {\n                {\n                    var firstContext = dependencies.firstContext;\n                    if (firstContext !== null) {\n                        if (includesSomeLane(dependencies.lanes, renderLanes)) {\n                            // Context list has a pending update. Mark that this fiber performed work.\n                            markWorkInProgressReceivedUpdate();\n                        } // Reset the work-in-progress list\n                        dependencies.firstContext = null;\n                    }\n                }\n            }\n        }\n        function readContext(context) {\n            {\n                // This warning would fire if you read context inside a Hook like useMemo.\n                // Unlike the class check below, it's not enforced in production for perf.\n                if (isDisallowedContextReadInDEV) {\n                    error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\n                }\n            }\n            return readContextForConsumer(currentlyRenderingFiber, context);\n        }\n        function readContextDuringReconciliation(consumer, context, renderLanes) {\n            if (currentlyRenderingFiber === null) {\n                prepareToReadContext(consumer, renderLanes);\n            }\n            return readContextForConsumer(consumer, context);\n        }\n        function readContextForConsumer(consumer, context) {\n            var value = isPrimaryRenderer ? context._currentValue : context._currentValue2;\n            if (lastFullyObservedContext === context) ;\n            else {\n                var contextItem = {\n                    context: context,\n                    memoizedValue: value,\n                    next: null\n                };\n                if (lastContextDependency === null) {\n                    if (consumer === null) {\n                        throw new Error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\n                    } // This is the first dependency for this component. Create a new list.\n                    lastContextDependency = contextItem;\n                    consumer.dependencies = {\n                        lanes: NoLanes,\n                        firstContext: contextItem\n                    };\n                } else {\n                    // Append a new context item.\n                    lastContextDependency = lastContextDependency.next = contextItem;\n                }\n            }\n            return value;\n        }\n        // replace it with a lightweight shim that only has the features we use.\n        var AbortControllerLocal = typeof AbortController !== 'undefined' ? AbortController : // $FlowFixMe[prop-missing]\n        function AbortControllerShim() {\n            var listeners = [];\n            var signal = this.signal = {\n                aborted: false,\n                addEventListener: function(type, listener) {\n                    listeners.push(listener);\n                }\n            };\n            this.abort = function() {\n                signal.aborted = true;\n                listeners.forEach(function(listener) {\n                    return listener();\n                });\n            };\n        }; // Intentionally not named imports because Rollup would\n        // use dynamic dispatch for CommonJS interop named imports.\n        var scheduleCallback$1 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority;\n        var CacheContext = {\n            $$typeof: REACT_CONTEXT_TYPE,\n            // We don't use Consumer/Provider for Cache components. So we'll cheat.\n            Consumer: null,\n            Provider: null,\n            // We'll initialize these at the root.\n            _currentValue: null,\n            _currentValue2: null,\n            _threadCount: 0\n        };\n        {\n            CacheContext._currentRenderer = null;\n            CacheContext._currentRenderer2 = null;\n        }\n        // for retaining the cache once it is in use (retainCache), and releasing the cache\n        // once it is no longer needed (releaseCache).\n        function createCache() {\n            var cache = {\n                controller: new AbortControllerLocal(),\n                data: new Map(),\n                refCount: 0\n            };\n            return cache;\n        }\n        function retainCache(cache) {\n            {\n                if (cache.controller.signal.aborted) {\n                    warn('A cache instance was retained after it was already freed. ' + 'This likely indicates a bug in React.');\n                }\n            }\n            cache.refCount++;\n        } // Cleanup a cache instance, potentially freeing it if there are no more references\n        function releaseCache(cache) {\n            cache.refCount--;\n            {\n                if (cache.refCount < 0) {\n                    warn('A cache instance was released after it was already freed. ' + 'This likely indicates a bug in React.');\n                }\n            }\n            if (cache.refCount === 0) {\n                scheduleCallback$1(NormalPriority, function() {\n                    cache.controller.abort();\n                });\n            }\n        }\n        function pushCacheProvider(workInProgress, cache) {\n            pushProvider(workInProgress, CacheContext, cache);\n        }\n        function popCacheProvider(workInProgress, cache) {\n            popProvider(CacheContext, workInProgress);\n        }\n        // the shared internals object. This is used by the isomorphic implementation of\n        // startTransition to compose all the startTransitions together.\n        //\n        //   function startTransition(fn) {\n        //     return startTransitionDOM(() => {\n        //       return startTransitionART(() => {\n        //         return startTransitionThreeFiber(() => {\n        //           // and so on...\n        //           return fn();\n        //         });\n        //       });\n        //     });\n        //   }\n        //\n        // Currently we only compose together the code that runs at the end of each\n        // startTransition, because for now that's sufficient — the part that sets\n        // isTransition=true on the stack uses a separate shared internal field. But\n        // really we should delete the shared field and track isTransition per\n        // reconciler. Leaving this for a future PR.\n        var prevOnStartTransitionFinish = ReactSharedInternals.S;\n        ReactSharedInternals.S = function onStartTransitionFinishForReconciler(transition, returnValue) {\n            if (typeof returnValue === 'object' && returnValue !== null && typeof returnValue.then === 'function') {\n                // This is an async action\n                var thenable = returnValue;\n                entangleAsyncAction(transition, thenable);\n            }\n            if (prevOnStartTransitionFinish !== null) {\n                prevOnStartTransitionFinish(transition, returnValue);\n            }\n        };\n        function requestCurrentTransition() {\n            return ReactSharedInternals.T;\n        } // When retrying a Suspense/Offscreen boundary, we restore the cache that was\n        // used during the previous render by placing it here, on the stack.\n        var resumedCache = createCursor(null); // During the render/synchronous commit phase, we don't actually process the\n        function peekCacheFromPool() {\n            // If we're rendering inside a Suspense boundary that is currently hidden,\n            // we should use the same cache that we used during the previous render, if\n            // one exists.\n            var cacheResumedFromPreviousRender = resumedCache.current;\n            if (cacheResumedFromPreviousRender !== null) {\n                return cacheResumedFromPreviousRender;\n            } // Otherwise, check the root's cache pool.\n            var root = getWorkInProgressRoot();\n            var cacheFromRootCachePool = root.pooledCache;\n            return cacheFromRootCachePool;\n        }\n        function requestCacheFromPool(renderLanes) {\n            // Similar to previous function, except if there's not already a cache in the\n            // pool, we allocate a new one.\n            var cacheFromPool = peekCacheFromPool();\n            if (cacheFromPool !== null) {\n                return cacheFromPool;\n            } // Create a fresh cache and add it to the root cache pool. A cache can have\n            // multiple owners:\n            // - A cache pool that lives on the FiberRoot. This is where all fresh caches\n            //   are originally created (TODO: except during refreshes, until we implement\n            //   this correctly). The root takes ownership immediately when the cache is\n            //   created. Conceptually, root.pooledCache is an Option<Arc<Cache>> (owned),\n            //   and the return value of this function is a &Arc<Cache> (borrowed).\n            // - One of several fiber types: host root, cache boundary, suspense\n            //   component. These retain and release in the commit phase.\n            var root = getWorkInProgressRoot();\n            var freshCache = createCache();\n            root.pooledCache = freshCache;\n            retainCache(freshCache);\n            if (freshCache !== null) {\n                root.pooledCacheLanes |= renderLanes;\n            }\n            return freshCache;\n        }\n        function pushTransition(offscreenWorkInProgress, prevCachePool, newTransitions) {\n            {\n                if (prevCachePool === null) {\n                    push(resumedCache, resumedCache.current, offscreenWorkInProgress);\n                } else {\n                    push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);\n                }\n            }\n        }\n        function popTransition(workInProgress, current) {\n            if (current !== null) {\n                {\n                    pop(resumedCache, workInProgress);\n                }\n            }\n        }\n        function getSuspendedCache() {\n            // cache that would have been used to render fresh data during this render,\n            // if there was any, so that we can resume rendering with the same cache when\n            // we receive more data.\n            var cacheFromPool = peekCacheFromPool();\n            if (cacheFromPool === null) {\n                return null;\n            }\n            return {\n                // We must also save the parent, so that when we resume we can detect\n                // a refresh.\n                parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,\n                pool: cacheFromPool\n            };\n        }\n        function getOffscreenDeferredCache() {\n            var cacheFromPool = peekCacheFromPool();\n            if (cacheFromPool === null) {\n                return null;\n            }\n            return {\n                // We must also store the parent, so that when we resume we can detect\n                // a refresh.\n                parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,\n                pool: cacheFromPool\n            };\n        }\n        /**\n * Tag the fiber with an update effect. This turns a Placement into\n * a PlacementAndUpdate.\n */ function markUpdate(workInProgress) {\n            workInProgress.flags |= Update;\n        }\n        /**\n * In persistent mode, return whether this update needs to clone the subtree.\n */ function doesRequireClone(current, completedWork) {\n            var didBailout = current !== null && current.child === completedWork.child;\n            if (didBailout) {\n                return false;\n            }\n            if ((completedWork.flags & ChildDeletion) !== NoFlags$1) {\n                return true;\n            } // TODO: If we move the `doesRequireClone` call after `bubbleProperties`\n            // then we only have to check the `completedWork.subtreeFlags`.\n            var child = completedWork.child;\n            while(child !== null){\n                if ((child.flags & MutationMask) !== NoFlags$1 || (child.subtreeFlags & MutationMask) !== NoFlags$1) {\n                    return true;\n                }\n                child = child.sibling;\n            }\n            return false;\n        }\n        function appendAllChildren(parent, workInProgress, needsVisibilityToggle, isHidden) {\n            if (supportsMutation) {\n                // We only have the top Fiber that was created but we need recurse down its\n                // children to find all the terminal nodes.\n                var node = workInProgress.child;\n                while(node !== null){\n                    if (node.tag === HostComponent || node.tag === HostText) {\n                        appendInitialChild(parent, node.stateNode);\n                    } else if (node.tag === HostPortal || (supportsSingletons ? node.tag === HostSingleton : false)) ;\n                    else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                    if (node === workInProgress) {\n                        return;\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    while(node.sibling === null){\n                        // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        if (node.return === null || node.return === workInProgress) {\n                            return;\n                        }\n                        node = node.return;\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            } else if (supportsPersistence) {\n                // We only have the top Fiber that was created but we need recurse down its\n                // children to find all the terminal nodes.\n                var _node = workInProgress.child;\n                while(_node !== null){\n                    if (_node.tag === HostComponent) {\n                        var instance = _node.stateNode;\n                        if (needsVisibilityToggle && isHidden) {\n                            // This child is inside a timed out tree. Hide it.\n                            var props = _node.memoizedProps;\n                            var type = _node.type;\n                            instance = cloneHiddenInstance(instance, type, props);\n                        }\n                        appendInitialChild(parent, instance);\n                    } else if (_node.tag === HostText) {\n                        var _instance = _node.stateNode;\n                        if (needsVisibilityToggle && isHidden) {\n                            // This child is inside a timed out tree. Hide it.\n                            var text = _node.memoizedProps;\n                            _instance = cloneHiddenTextInstance(_instance, text);\n                        }\n                        appendInitialChild(parent, _instance);\n                    } else if (_node.tag === HostPortal) ;\n                    else if (_node.tag === OffscreenComponent && _node.memoizedState !== null) {\n                        // The children in this boundary are hidden. Toggle their visibility\n                        // before appending.\n                        var child = _node.child;\n                        if (child !== null) {\n                            child.return = _node;\n                        }\n                        appendAllChildren(parent, _node, /* needsVisibilityToggle */ true, /* isHidden */ true);\n                    } else if (_node.child !== null) {\n                        _node.child.return = _node;\n                        _node = _node.child;\n                        continue;\n                    }\n                    if (_node === workInProgress) {\n                        return;\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    while(_node.sibling === null){\n                        // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        if (_node.return === null || _node.return === workInProgress) {\n                            return;\n                        }\n                        _node = _node.return;\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    _node.sibling.return = _node.return;\n                    _node = _node.sibling;\n                }\n            }\n        } // An unfortunate fork of appendAllChildren because we have two different parent types.\n        function appendAllChildrenToContainer(containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {\n            if (supportsPersistence) {\n                // We only have the top Fiber that was created but we need recurse down its\n                // children to find all the terminal nodes.\n                var node = workInProgress.child;\n                while(node !== null){\n                    if (node.tag === HostComponent) {\n                        var instance = node.stateNode;\n                        if (needsVisibilityToggle && isHidden) {\n                            // This child is inside a timed out tree. Hide it.\n                            var props = node.memoizedProps;\n                            var type = node.type;\n                            instance = cloneHiddenInstance(instance, type, props);\n                        }\n                        appendChildToContainerChildSet(containerChildSet, instance);\n                    } else if (node.tag === HostText) {\n                        var _instance2 = node.stateNode;\n                        if (needsVisibilityToggle && isHidden) {\n                            // This child is inside a timed out tree. Hide it.\n                            var text = node.memoizedProps;\n                            _instance2 = cloneHiddenTextInstance(_instance2, text);\n                        }\n                        appendChildToContainerChildSet(containerChildSet, _instance2);\n                    } else if (node.tag === HostPortal) ;\n                    else if (node.tag === OffscreenComponent && node.memoizedState !== null) {\n                        // The children in this boundary are hidden. Toggle their visibility\n                        // before appending.\n                        var child = node.child;\n                        if (child !== null) {\n                            child.return = node;\n                        } // If Offscreen is not in manual mode, detached tree is hidden from user space.\n                        var _needsVisibilityToggle = !isOffscreenManual(node);\n                        appendAllChildrenToContainer(containerChildSet, node, /* needsVisibilityToggle */ _needsVisibilityToggle, /* isHidden */ true);\n                    } else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                    node = node;\n                    if (node === workInProgress) {\n                        return;\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    while(node.sibling === null){\n                        // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        if (node.return === null || node.return === workInProgress) {\n                            return;\n                        }\n                        node = node.return;\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            }\n        }\n        function updateHostContainer(current, workInProgress) {\n            if (supportsPersistence) {\n                if (doesRequireClone(current, workInProgress)) {\n                    var portalOrRoot = workInProgress.stateNode;\n                    var container = portalOrRoot.containerInfo;\n                    var newChildSet = createContainerChildSet(); // If children might have changed, we have to add them all to the set.\n                    appendAllChildrenToContainer(newChildSet, workInProgress, /* needsVisibilityToggle */ false, /* isHidden */ false);\n                    portalOrRoot.pendingChildren = newChildSet; // Schedule an update on the container to swap out the container.\n                    markUpdate(workInProgress);\n                    finalizeContainerChildren(container, newChildSet);\n                }\n            }\n        }\n        function updateHostComponent(current, workInProgress, type, newProps, renderLanes) {\n            if (supportsMutation) {\n                // If we have an alternate, that means this is an update and we need to\n                // schedule a side-effect to do the updates.\n                var oldProps = current.memoizedProps;\n                if (oldProps === newProps) {\n                    // In mutation mode, this is sufficient for a bailout because\n                    // we won't touch this node even if children changed.\n                    return;\n                }\n                markUpdate(workInProgress);\n            } else if (supportsPersistence) {\n                var currentInstance = current.stateNode;\n                var _oldProps = current.memoizedProps; // If there are no effects associated with this node, then none of our children had any updates.\n                // This guarantees that we can reuse all of them.\n                var requiresClone = doesRequireClone(current, workInProgress);\n                if (!requiresClone && _oldProps === newProps) {\n                    // No changes, just reuse the existing instance.\n                    // Note that this might release a previous clone.\n                    workInProgress.stateNode = currentInstance;\n                    return;\n                }\n                var currentHostContext = getHostContext();\n                var newChildSet = null;\n                if (requiresClone && passChildrenWhenCloningPersistedNodes) {\n                    newChildSet = createContainerChildSet(); // If children might have changed, we have to add them all to the set.\n                    appendAllChildrenToContainer(newChildSet, workInProgress, /* needsVisibilityToggle */ false, /* isHidden */ false);\n                }\n                var newInstance = cloneInstance(currentInstance, type, _oldProps, newProps, !requiresClone, newChildSet);\n                if (newInstance === currentInstance) {\n                    // No changes, just reuse the existing instance.\n                    // Note that this might release a previous clone.\n                    workInProgress.stateNode = currentInstance;\n                    return;\n                } // Certain renderers require commit-time effects for initial mount.\n                // (eg DOM renderer supports auto-focus for certain elements).\n                // Make sure such renderers get scheduled for later work.\n                if (finalizeInitialChildren(newInstance, type, newProps, currentHostContext)) {\n                    markUpdate(workInProgress);\n                }\n                workInProgress.stateNode = newInstance;\n                if (!requiresClone) {\n                    // If there are no other effects in this tree, we need to flag this node as having one.\n                    // Even though we're not going to use it for anything.\n                    // Otherwise parents won't know that there are new children to propagate upwards.\n                    markUpdate(workInProgress);\n                } else {\n                    // If children might have changed, we have to add them all to the set.\n                    appendAllChildren(newInstance, workInProgress, /* needsVisibilityToggle */ false, /* isHidden */ false);\n                }\n            }\n        } // This function must be called at the very end of the complete phase, because\n        // it might throw to suspend, and if the resource immediately loads, the work\n        // loop will resume rendering as if the work-in-progress completed. So it must\n        // fully complete.\n        // TODO: This should ideally move to begin phase, but currently the instance is\n        // not created until the complete phase. For our existing use cases, host nodes\n        // that suspend don't have children, so it doesn't matter. But that might not\n        // always be true in the future.\n        function preloadInstanceAndSuspendIfNeeded(workInProgress, type, props, renderLanes) {\n            if (!maySuspendCommit(type, props)) {\n                // If this flag was set previously, we can remove it. The flag\n                // represents whether this particular set of props might ever need to\n                // suspend. The safest thing to do is for maySuspendCommit to always\n                // return true, but if the renderer is reasonably confident that the\n                // underlying resource won't be evicted, it can return false as a\n                // performance optimization.\n                workInProgress.flags &= ~MaySuspendCommit;\n                return;\n            } // Mark this fiber with a flag. This gets set on all host instances\n            // that might possibly suspend, even if they don't need to suspend\n            // currently. We use this when revealing a prerendered tree, because\n            // even though the tree has \"mounted\", its resources might not have\n            // loaded yet.\n            workInProgress.flags |= MaySuspendCommit; // preload the instance if necessary. Even if this is an urgent render there\n            // could be benefits to preloading early.\n            // @TODO we should probably do the preload in begin work\n            var isReady = preloadInstance(type, props);\n            if (!isReady) {\n                if (shouldRemainOnPreviousScreen()) {\n                    workInProgress.flags |= ShouldSuspendCommit;\n                } else {\n                    suspendCommit();\n                }\n            }\n        }\n        function preloadResourceAndSuspendIfNeeded(workInProgress, resource, type, props, renderLanes) {\n            // This is a fork of preloadInstanceAndSuspendIfNeeded, but for resources.\n            if (!mayResourceSuspendCommit(resource)) {\n                workInProgress.flags &= ~MaySuspendCommit;\n                return;\n            }\n            workInProgress.flags |= MaySuspendCommit;\n            var isReady = preloadResource(resource);\n            if (!isReady) {\n                if (shouldRemainOnPreviousScreen()) {\n                    workInProgress.flags |= ShouldSuspendCommit;\n                } else {\n                    suspendCommit();\n                }\n            }\n        }\n        function scheduleRetryEffect(workInProgress, retryQueue) {\n            var wakeables = retryQueue;\n            if (wakeables !== null) {\n                // Schedule an effect to attach a retry listener to the promise.\n                // TODO: Move to passive phase\n                workInProgress.flags |= Update;\n            } else {\n                // This boundary suspended, but no wakeables were added to the retry\n                // queue. Check if the renderer suspended commit. If so, this means\n                // that once the fallback is committed, we can immediately retry\n                // rendering again, because rendering wasn't actually blocked. Only\n                // the commit phase.\n                // TODO: Consider a model where we always schedule an immediate retry, even\n                // for normal Suspense. That way the retry can partially render up to the\n                // first thing that suspends.\n                if (workInProgress.flags & ScheduleRetry) {\n                    var retryLane = // I also suspect that we need some further consolidation of offscreen\n                    // and retry lanes.\n                    workInProgress.tag !== OffscreenComponent ? claimNextRetryLane() : OffscreenLane;\n                    workInProgress.lanes = mergeLanes(workInProgress.lanes, retryLane);\n                }\n            }\n        }\n        function updateHostText(current, workInProgress, oldText, newText) {\n            if (supportsMutation) {\n                // If the text differs, mark it as an update. All the work in done in commitWork.\n                if (oldText !== newText) {\n                    markUpdate(workInProgress);\n                }\n            } else if (supportsPersistence) {\n                if (oldText !== newText) {\n                    // If the text content differs, we'll create a new text instance for it.\n                    var rootContainerInstance = getRootHostContainer();\n                    var currentHostContext = getHostContext();\n                    workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress); // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n                    // This lets the parents know that at least one of their children has changed.\n                    markUpdate(workInProgress);\n                } else {\n                    workInProgress.stateNode = current.stateNode;\n                }\n            }\n        }\n        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n            if (getIsHydrating()) {\n                // If we're hydrating, we should consume as many items as we can\n                // so we don't leave any behind.\n                return;\n            }\n            switch(renderState.tailMode){\n                case 'hidden':\n                    {\n                        // Any insertions at the end of the tail list after this point\n                        // should be invisible. If there are already mounted boundaries\n                        // anything before them are not considered for collapsing.\n                        // Therefore we need to go through the whole tail to find if\n                        // there are any.\n                        var tailNode = renderState.tail;\n                        var lastTailNode = null;\n                        while(tailNode !== null){\n                            if (tailNode.alternate !== null) {\n                                lastTailNode = tailNode;\n                            }\n                            tailNode = tailNode.sibling;\n                        } // Next we're simply going to delete all insertions after the\n                        // last rendered item.\n                        if (lastTailNode === null) {\n                            // All remaining items in the tail are insertions.\n                            renderState.tail = null;\n                        } else {\n                            // Detach the insertion after the last node that was already\n                            // inserted.\n                            lastTailNode.sibling = null;\n                        }\n                        break;\n                    }\n                case 'collapsed':\n                    {\n                        // Any insertions at the end of the tail list after this point\n                        // should be invisible. If there are already mounted boundaries\n                        // anything before them are not considered for collapsing.\n                        // Therefore we need to go through the whole tail to find if\n                        // there are any.\n                        var _tailNode = renderState.tail;\n                        var _lastTailNode = null;\n                        while(_tailNode !== null){\n                            if (_tailNode.alternate !== null) {\n                                _lastTailNode = _tailNode;\n                            }\n                            _tailNode = _tailNode.sibling;\n                        } // Next we're simply going to delete all insertions after the\n                        // last rendered item.\n                        if (_lastTailNode === null) {\n                            // All remaining items in the tail are insertions.\n                            if (!hasRenderedATailFallback && renderState.tail !== null) {\n                                // We suspended during the head. We want to show at least one\n                                // row at the tail. So we'll keep on and cut off the rest.\n                                renderState.tail.sibling = null;\n                            } else {\n                                renderState.tail = null;\n                            }\n                        } else {\n                            // Detach the insertion after the last node that was already\n                            // inserted.\n                            _lastTailNode.sibling = null;\n                        }\n                        break;\n                    }\n            }\n        }\n        function bubbleProperties(completedWork) {\n            var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;\n            var newChildLanes = NoLanes;\n            var subtreeFlags = NoFlags$1;\n            if (!didBailout) {\n                // Bubble up the earliest expiration time.\n                if ((completedWork.mode & ProfileMode) !== NoMode) {\n                    // In profiling mode, resetChildExpirationTime is also used to reset\n                    // profiler durations.\n                    var actualDuration = completedWork.actualDuration;\n                    var treeBaseDuration = completedWork.selfBaseDuration;\n                    var child = completedWork.child;\n                    while(child !== null){\n                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));\n                        subtreeFlags |= child.subtreeFlags;\n                        subtreeFlags |= child.flags; // When a fiber is cloned, its actualDuration is reset to 0. This value will\n                        // only be updated if work is done on the fiber (i.e. it doesn't bailout).\n                        // When work is done, it should bubble to the parent's actualDuration. If\n                        // the fiber has not been cloned though, (meaning no work was done), then\n                        // this value will reflect the amount of time spent working on a previous\n                        // render. In that case it should not bubble. We determine whether it was\n                        // cloned by comparing the child pointer.\n                        // $FlowFixMe[unsafe-addition] addition with possible null/undefined value\n                        actualDuration += child.actualDuration; // $FlowFixMe[unsafe-addition] addition with possible null/undefined value\n                        treeBaseDuration += child.treeBaseDuration;\n                        child = child.sibling;\n                    }\n                    completedWork.actualDuration = actualDuration;\n                    completedWork.treeBaseDuration = treeBaseDuration;\n                } else {\n                    var _child = completedWork.child;\n                    while(_child !== null){\n                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));\n                        subtreeFlags |= _child.subtreeFlags;\n                        subtreeFlags |= _child.flags; // Update the return pointer so the tree is consistent. This is a code\n                        // smell because it assumes the commit phase is never concurrent with\n                        // the render phase. Will address during refactor to alternate model.\n                        _child.return = completedWork;\n                        _child = _child.sibling;\n                    }\n                }\n                completedWork.subtreeFlags |= subtreeFlags;\n            } else {\n                // Bubble up the earliest expiration time.\n                if ((completedWork.mode & ProfileMode) !== NoMode) {\n                    // In profiling mode, resetChildExpirationTime is also used to reset\n                    // profiler durations.\n                    var _treeBaseDuration = completedWork.selfBaseDuration;\n                    var _child2 = completedWork.child;\n                    while(_child2 !== null){\n                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes)); // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n                        // so we should bubble those up even during a bailout. All the other\n                        // flags have a lifetime only of a single render + commit, so we should\n                        // ignore them.\n                        subtreeFlags |= _child2.subtreeFlags & StaticMask;\n                        subtreeFlags |= _child2.flags & StaticMask; // $FlowFixMe[unsafe-addition] addition with possible null/undefined value\n                        _treeBaseDuration += _child2.treeBaseDuration;\n                        _child2 = _child2.sibling;\n                    }\n                    completedWork.treeBaseDuration = _treeBaseDuration;\n                } else {\n                    var _child3 = completedWork.child;\n                    while(_child3 !== null){\n                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes)); // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n                        // so we should bubble those up even during a bailout. All the other\n                        // flags have a lifetime only of a single render + commit, so we should\n                        // ignore them.\n                        subtreeFlags |= _child3.subtreeFlags & StaticMask;\n                        subtreeFlags |= _child3.flags & StaticMask; // Update the return pointer so the tree is consistent. This is a code\n                        // smell because it assumes the commit phase is never concurrent with\n                        // the render phase. Will address during refactor to alternate model.\n                        _child3.return = completedWork;\n                        _child3 = _child3.sibling;\n                    }\n                }\n                completedWork.subtreeFlags |= subtreeFlags;\n            }\n            completedWork.childLanes = newChildLanes;\n            return didBailout;\n        }\n        function completeDehydratedSuspenseBoundary(current, workInProgress, nextState) {\n            var wasHydrated = popHydrationState(workInProgress);\n            if (nextState !== null && nextState.dehydrated !== null) {\n                // We might be inside a hydration state the first time we're picking up this\n                // Suspense boundary, and also after we've reentered it for further hydration.\n                if (current === null) {\n                    if (!wasHydrated) {\n                        throw new Error('A dehydrated suspense component was completed without a hydrated node. ' + 'This is probably a bug in React.');\n                    }\n                    prepareToHydrateHostSuspenseInstance(workInProgress);\n                    bubbleProperties(workInProgress);\n                    {\n                        if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                            var isTimedOutSuspense = nextState !== null;\n                            if (isTimedOutSuspense) {\n                                // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                                var primaryChildFragment = workInProgress.child;\n                                if (primaryChildFragment !== null) {\n                                    // $FlowFixMe[unsafe-arithmetic] Flow doesn't support type casting in combination with the -= operator\n                                    workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n                                }\n                            }\n                        }\n                    }\n                    return false;\n                } else {\n                    emitPendingHydrationWarnings(); // We might have reentered this boundary to hydrate it. If so, we need to reset the hydration\n                    // state since we're now exiting out of it. popHydrationState doesn't do that for us.\n                    resetHydrationState();\n                    if ((workInProgress.flags & DidCapture) === NoFlags$1) {\n                        // This boundary did not suspend so it's now hydrated and unsuspended.\n                        workInProgress.memoizedState = null;\n                    } // If nothing suspended, we need to schedule an effect to mark this boundary\n                    // as having hydrated so events know that they're free to be invoked.\n                    // It's also a signal to replay events and the suspense callback.\n                    // If something suspended, schedule an effect to attach retry listeners.\n                    // So we might as well always mark this.\n                    workInProgress.flags |= Update;\n                    bubbleProperties(workInProgress);\n                    {\n                        if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                            var _isTimedOutSuspense = nextState !== null;\n                            if (_isTimedOutSuspense) {\n                                // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                                var _primaryChildFragment = workInProgress.child;\n                                if (_primaryChildFragment !== null) {\n                                    // $FlowFixMe[unsafe-arithmetic] Flow doesn't support type casting in combination with the -= operator\n                                    workInProgress.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;\n                                }\n                            }\n                        }\n                    }\n                    return false;\n                }\n            } else {\n                // Successfully completed this tree. If this was a forced client render,\n                // there may have been recoverable errors during first hydration\n                // attempt. If so, add them to a queue so we can log them in the\n                // commit phase.\n                upgradeHydrationErrorsToRecoverable(); // Fall through to normal Suspense path\n                return true;\n            }\n        }\n        function completeWork(current, workInProgress, renderLanes) {\n            var newProps = workInProgress.pendingProps; // Note: This intentionally doesn't check if we're hydrating because comparing\n            // to the current tree provider fiber is just as fast and less error-prone.\n            // Ideally we would have a special version of the work loop only\n            // for hydration.\n            popTreeContext(workInProgress);\n            switch(workInProgress.tag){\n                case IncompleteFunctionComponent:\n                    {\n                        {\n                            break;\n                        }\n                    }\n                case LazyComponent:\n                case SimpleMemoComponent:\n                case FunctionComponent:\n                case ForwardRef:\n                case Fragment:\n                case Mode:\n                case Profiler:\n                case ContextConsumer:\n                case MemoComponent:\n                    bubbleProperties(workInProgress);\n                    return null;\n                case ClassComponent:\n                    {\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case HostRoot:\n                    {\n                        var fiberRoot = workInProgress.stateNode;\n                        {\n                            var previousCache = null;\n                            if (current !== null) {\n                                previousCache = current.memoizedState.cache;\n                            }\n                            var cache = workInProgress.memoizedState.cache;\n                            if (cache !== previousCache) {\n                                // Run passive effects to retain/release the cache.\n                                workInProgress.flags |= Passive$1;\n                            }\n                            popCacheProvider(workInProgress);\n                        }\n                        popHostContainer(workInProgress);\n                        if (fiberRoot.pendingContext) {\n                            fiberRoot.context = fiberRoot.pendingContext;\n                            fiberRoot.pendingContext = null;\n                        }\n                        if (current === null || current.child === null) {\n                            // If we hydrated, pop so that we can delete any remaining children\n                            // that weren't hydrated.\n                            var wasHydrated = popHydrationState(workInProgress);\n                            if (wasHydrated) {\n                                emitPendingHydrationWarnings(); // If we hydrated, then we'll need to schedule an update for\n                                // the commit side-effects on the root.\n                                markUpdate(workInProgress);\n                            } else {\n                                if (current !== null) {\n                                    var prevState = current.memoizedState;\n                                    if (!prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)\n                                    (workInProgress.flags & ForceClientRender) !== NoFlags$1) {\n                                        // Schedule an effect to clear this container at the start of the\n                                        // next commit. This handles the case of React rendering into a\n                                        // container with previous children. It's also safe to do for\n                                        // updates too, because current.child would only be null if the\n                                        // previous render was null (so the container would already\n                                        // be empty).\n                                        workInProgress.flags |= Snapshot; // If this was a forced client render, there may have been\n                                        // recoverable errors during first hydration attempt. If so, add\n                                        // them to a queue so we can log them in the commit phase.\n                                        upgradeHydrationErrorsToRecoverable();\n                                    }\n                                }\n                            }\n                        }\n                        updateHostContainer(current, workInProgress);\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case HostHoistable:\n                    {\n                        if (supportsResources) {\n                            // The branching here is more complicated than you might expect because\n                            // a HostHoistable sometimes corresponds to a Resource and sometimes\n                            // corresponds to an Instance. It can also switch during an update.\n                            var type = workInProgress.type;\n                            var nextResource = workInProgress.memoizedState;\n                            if (current === null) {\n                                // We are mounting and must Update this Hoistable in this commit\n                                // @TODO refactor this block to create the instance here in complete\n                                // phase if we are not hydrating.\n                                markUpdate(workInProgress);\n                                if (nextResource !== null) {\n                                    // This is a Hoistable Resource\n                                    // This must come at the very end of the complete phase.\n                                    bubbleProperties(workInProgress);\n                                    preloadResourceAndSuspendIfNeeded(workInProgress, nextResource);\n                                    return null;\n                                } else {\n                                    // This is a Hoistable Instance\n                                    // This must come at the very end of the complete phase.\n                                    bubbleProperties(workInProgress);\n                                    preloadInstanceAndSuspendIfNeeded(workInProgress, type, newProps);\n                                    return null;\n                                }\n                            } else {\n                                // We are updating.\n                                var currentResource = current.memoizedState;\n                                if (nextResource !== currentResource) {\n                                    // We are transitioning to, from, or between Hoistable Resources\n                                    // and require an update\n                                    markUpdate(workInProgress);\n                                }\n                                if (nextResource !== null) {\n                                    // This is a Hoistable Resource\n                                    // This must come at the very end of the complete phase.\n                                    bubbleProperties(workInProgress);\n                                    if (nextResource === currentResource) {\n                                        workInProgress.flags &= ~MaySuspendCommit;\n                                    } else {\n                                        preloadResourceAndSuspendIfNeeded(workInProgress, nextResource);\n                                    }\n                                    return null;\n                                } else {\n                                    // This is a Hoistable Instance\n                                    // We may have props to update on the Hoistable instance.\n                                    if (supportsMutation) {\n                                        var oldProps = current.memoizedProps;\n                                        if (oldProps !== newProps) {\n                                            markUpdate(workInProgress);\n                                        }\n                                    } else {\n                                        // We use the updateHostComponent path becuase it produces\n                                        // the update queue we need for Hoistables.\n                                        updateHostComponent(current, workInProgress, type, newProps);\n                                    } // This must come at the very end of the complete phase.\n                                    bubbleProperties(workInProgress);\n                                    preloadInstanceAndSuspendIfNeeded(workInProgress, type, newProps);\n                                    return null;\n                                }\n                            }\n                        } // Fall through\n                    }\n                case HostSingleton:\n                    {\n                        if (supportsSingletons) {\n                            popHostContext(workInProgress);\n                            var rootContainerInstance = getRootHostContainer();\n                            var _type = workInProgress.type;\n                            if (current !== null && workInProgress.stateNode != null) {\n                                if (supportsMutation) {\n                                    var _oldProps2 = current.memoizedProps;\n                                    if (_oldProps2 !== newProps) {\n                                        markUpdate(workInProgress);\n                                    }\n                                } else {\n                                    updateHostComponent(current, workInProgress, _type, newProps);\n                                }\n                            } else {\n                                if (!newProps) {\n                                    if (workInProgress.stateNode === null) {\n                                        throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n                                    } // This can happen when we abort work.\n                                    bubbleProperties(workInProgress);\n                                    return null;\n                                }\n                                var currentHostContext = getHostContext();\n                                var _wasHydrated = popHydrationState(workInProgress);\n                                var instance;\n                                if (_wasHydrated) {\n                                    // We ignore the boolean indicating there is an updateQueue because\n                                    // it is used only to set text children and HostSingletons do not\n                                    // use them.\n                                    prepareToHydrateHostInstance(workInProgress, currentHostContext);\n                                    instance = workInProgress.stateNode;\n                                } else {\n                                    instance = resolveSingletonInstance(_type, newProps, rootContainerInstance, currentHostContext, true);\n                                    workInProgress.stateNode = instance;\n                                    markUpdate(workInProgress);\n                                }\n                            }\n                            bubbleProperties(workInProgress);\n                            return null;\n                        } // Fall through\n                    }\n                case HostComponent:\n                    {\n                        popHostContext(workInProgress);\n                        var _type2 = workInProgress.type;\n                        if (current !== null && workInProgress.stateNode != null) {\n                            updateHostComponent(current, workInProgress, _type2, newProps);\n                        } else {\n                            if (!newProps) {\n                                if (workInProgress.stateNode === null) {\n                                    throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n                                } // This can happen when we abort work.\n                                bubbleProperties(workInProgress);\n                                return null;\n                            }\n                            var _currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context\n                            // \"stack\" as the parent. Then append children as we go in beginWork\n                            // or completeWork depending on whether we want to add them top->down or\n                            // bottom->up. Top->down is faster in IE11.\n                            var _wasHydrated2 = popHydrationState(workInProgress);\n                            if (_wasHydrated2) {\n                                // TODO: Move this and createInstance step into the beginPhase\n                                // to consolidate.\n                                prepareToHydrateHostInstance(workInProgress, _currentHostContext);\n                            } else {\n                                var _rootContainerInstance = getRootHostContainer();\n                                var _instance3 = createInstance(_type2, newProps, _rootContainerInstance, _currentHostContext, workInProgress); // TODO: For persistent renderers, we should pass children as part\n                                // of the initial instance creation\n                                appendAllChildren(_instance3, workInProgress, false, false);\n                                workInProgress.stateNode = _instance3; // Certain renderers require commit-time effects for initial mount.\n                                // (eg DOM renderer supports auto-focus for certain elements).\n                                // Make sure such renderers get scheduled for later work.\n                                if (finalizeInitialChildren(_instance3, _type2, newProps, _currentHostContext)) {\n                                    markUpdate(workInProgress);\n                                }\n                            }\n                        }\n                        bubbleProperties(workInProgress); // This must come at the very end of the complete phase, because it might\n                        // throw to suspend, and if the resource immediately loads, the work loop\n                        // will resume rendering as if the work-in-progress completed. So it must\n                        // fully complete.\n                        preloadInstanceAndSuspendIfNeeded(workInProgress, workInProgress.type, workInProgress.pendingProps);\n                        return null;\n                    }\n                case HostText:\n                    {\n                        var newText = newProps;\n                        if (current && workInProgress.stateNode != null) {\n                            var oldText = current.memoizedProps; // If we have an alternate, that means this is an update and we need\n                            // to schedule a side-effect to do the updates.\n                            updateHostText(current, workInProgress, oldText, newText);\n                        } else {\n                            if (typeof newText !== 'string') {\n                                if (workInProgress.stateNode === null) {\n                                    throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n                                } // This can happen when we abort work.\n                            }\n                            var _rootContainerInstance2 = getRootHostContainer();\n                            var _currentHostContext2 = getHostContext();\n                            var _wasHydrated3 = popHydrationState(workInProgress);\n                            if (_wasHydrated3) {\n                                prepareToHydrateHostTextInstance(workInProgress);\n                            } else {\n                                workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance2, _currentHostContext2, workInProgress);\n                            }\n                        }\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case SuspenseComponent:\n                    {\n                        var nextState = workInProgress.memoizedState; // Special path for dehydrated boundaries. We may eventually move this\n                        // to its own fiber type so that we can add other kinds of hydration\n                        // boundaries that aren't associated with a Suspense tree. In anticipation\n                        // of such a refactor, all the hydration logic is contained in\n                        // this branch.\n                        if (current === null || current.memoizedState !== null && current.memoizedState.dehydrated !== null) {\n                            var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current, workInProgress, nextState);\n                            if (!fallthroughToNormalSuspensePath) {\n                                if (workInProgress.flags & ForceClientRender) {\n                                    popSuspenseHandler(workInProgress); // Special case. There were remaining unhydrated nodes. We treat\n                                    // this as a mismatch. Revert to client rendering.\n                                    return workInProgress;\n                                } else {\n                                    popSuspenseHandler(workInProgress); // Did not finish hydrating, either because this is the initial\n                                    // render or because something suspended.\n                                    return null;\n                                }\n                            } // Continue with the normal Suspense path.\n                        }\n                        popSuspenseHandler(workInProgress);\n                        if ((workInProgress.flags & DidCapture) !== NoFlags$1) {\n                            // Something suspended. Re-render with the fallback children.\n                            workInProgress.lanes = renderLanes; // Do not reset the effect list.\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                transferActualDuration(workInProgress);\n                            } // Don't bubble properties in this case.\n                            return workInProgress;\n                        }\n                        var nextDidTimeout = nextState !== null;\n                        var prevDidTimeout = current !== null && current.memoizedState !== null;\n                        if (nextDidTimeout) {\n                            var offscreenFiber = workInProgress.child;\n                            var _previousCache = null;\n                            if (offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null && offscreenFiber.alternate.memoizedState.cachePool !== null) {\n                                _previousCache = offscreenFiber.alternate.memoizedState.cachePool.pool;\n                            }\n                            var _cache = null;\n                            if (offscreenFiber.memoizedState !== null && offscreenFiber.memoizedState.cachePool !== null) {\n                                _cache = offscreenFiber.memoizedState.cachePool.pool;\n                            }\n                            if (_cache !== _previousCache) {\n                                // Run passive effects to retain/release the cache.\n                                offscreenFiber.flags |= Passive$1;\n                            }\n                        } // If the suspended state of the boundary changes, we need to schedule\n                        // a passive effect, which is when we process the transitions\n                        if (nextDidTimeout !== prevDidTimeout) {\n                            // an effect to toggle the subtree's visibility. When we switch from\n                            // fallback -> primary, the inner Offscreen fiber schedules this effect\n                            // as part of its normal complete phase. But when we switch from\n                            // primary -> fallback, the inner Offscreen fiber does not have a complete\n                            // phase. So we need to schedule its effect here.\n                            //\n                            // We also use this flag to connect/disconnect the effects, but the same\n                            // logic applies: when re-connecting, the Offscreen fiber's complete\n                            // phase will handle scheduling the effect. It's only when the fallback\n                            // is active that we have to do anything special.\n                            if (nextDidTimeout) {\n                                var _offscreenFiber2 = workInProgress.child;\n                                _offscreenFiber2.flags |= Visibility;\n                            }\n                        }\n                        var retryQueue = workInProgress.updateQueue;\n                        scheduleRetryEffect(workInProgress, retryQueue);\n                        bubbleProperties(workInProgress);\n                        {\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                if (nextDidTimeout) {\n                                    // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                                    var primaryChildFragment = workInProgress.child;\n                                    if (primaryChildFragment !== null) {\n                                        // $FlowFixMe[unsafe-arithmetic] Flow doesn't support type casting in combination with the -= operator\n                                        workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n                                    }\n                                }\n                            }\n                        }\n                        return null;\n                    }\n                case HostPortal:\n                    popHostContainer(workInProgress);\n                    updateHostContainer(current, workInProgress);\n                    if (current === null) {\n                        preparePortalMount(workInProgress.stateNode.containerInfo);\n                    }\n                    bubbleProperties(workInProgress);\n                    return null;\n                case ContextProvider:\n                    // Pop provider fiber\n                    var context;\n                    {\n                        context = workInProgress.type;\n                    }\n                    popProvider(context, workInProgress);\n                    bubbleProperties(workInProgress);\n                    return null;\n                case IncompleteClassComponent:\n                    {\n                        {\n                            break;\n                        }\n                    }\n                case SuspenseListComponent:\n                    {\n                        popSuspenseListContext(workInProgress);\n                        var renderState = workInProgress.memoizedState;\n                        if (renderState === null) {\n                            // We're running in the default, \"independent\" mode.\n                            // We don't do anything in this mode.\n                            bubbleProperties(workInProgress);\n                            return null;\n                        }\n                        var didSuspendAlready = (workInProgress.flags & DidCapture) !== NoFlags$1;\n                        var renderedTail = renderState.rendering;\n                        if (renderedTail === null) {\n                            // We just rendered the head.\n                            if (!didSuspendAlready) {\n                                // This is the first pass. We need to figure out if anything is still\n                                // suspended in the rendered set.\n                                // If new content unsuspended, but there's still some content that\n                                // didn't. Then we need to do a second pass that forces everything\n                                // to keep showing their fallbacks.\n                                // We might be suspended if something in this render pass suspended, or\n                                // something in the previous committed pass suspended. Otherwise,\n                                // there's no chance so we can skip the expensive call to\n                                // findFirstSuspended.\n                                var cannotBeSuspended = renderHasNotSuspendedYet() && (current === null || (current.flags & DidCapture) === NoFlags$1);\n                                if (!cannotBeSuspended) {\n                                    var row = workInProgress.child;\n                                    while(row !== null){\n                                        var suspended = findFirstSuspended(row);\n                                        if (suspended !== null) {\n                                            didSuspendAlready = true;\n                                            workInProgress.flags |= DidCapture;\n                                            cutOffTailIfNeeded(renderState, false); // If this is a newly suspended tree, it might not get committed as\n                                            // part of the second pass. In that case nothing will subscribe to\n                                            // its thenables. Instead, we'll transfer its thenables to the\n                                            // SuspenseList so that it can retry if they resolve.\n                                            // There might be multiple of these in the list but since we're\n                                            // going to wait for all of them anyway, it doesn't really matter\n                                            // which ones gets to ping. In theory we could get clever and keep\n                                            // track of how many dependencies remain but it gets tricky because\n                                            // in the meantime, we can add/remove/change items and dependencies.\n                                            // We might bail out of the loop before finding any but that\n                                            // doesn't matter since that means that the other boundaries that\n                                            // we did find already has their listeners attached.\n                                            var _retryQueue = suspended.updateQueue;\n                                            workInProgress.updateQueue = _retryQueue;\n                                            scheduleRetryEffect(workInProgress, _retryQueue); // Rerender the whole list, but this time, we'll force fallbacks\n                                            // to stay in place.\n                                            // Reset the effect flags before doing the second pass since that's now invalid.\n                                            // Reset the child fibers to their original state.\n                                            workInProgress.subtreeFlags = NoFlags$1;\n                                            resetChildFibers(workInProgress, renderLanes); // Set up the Suspense List Context to force suspense and\n                                            // immediately rerender the children.\n                                            pushSuspenseListContext(workInProgress, setShallowSuspenseListContext(suspenseStackCursor.current, ForceSuspenseFallback)); // Don't bubble properties in this case.\n                                            return workInProgress.child;\n                                        }\n                                        row = row.sibling;\n                                    }\n                                }\n                                if (renderState.tail !== null && now$1() > getRenderTargetTime()) {\n                                    // We have already passed our CPU deadline but we still have rows\n                                    // left in the tail. We'll just give up further attempts to render\n                                    // the main content and only render fallbacks.\n                                    workInProgress.flags |= DidCapture;\n                                    didSuspendAlready = true;\n                                    cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\n                                    // to get it started back up to attempt the next item. While in terms\n                                    // of priority this work has the same priority as this current render,\n                                    // it's not part of the same transition once the transition has\n                                    // committed. If it's sync, we still want to yield so that it can be\n                                    // painted. Conceptually, this is really the same as pinging.\n                                    // We can use any RetryLane even if it's the one currently rendering\n                                    // since we're leaving it behind on this node.\n                                    workInProgress.lanes = SomeRetryLane;\n                                }\n                            } else {\n                                cutOffTailIfNeeded(renderState, false);\n                            } // Next we're going to render the tail.\n                        } else {\n                            // Append the rendered row to the child list.\n                            if (!didSuspendAlready) {\n                                var _suspended = findFirstSuspended(renderedTail);\n                                if (_suspended !== null) {\n                                    workInProgress.flags |= DidCapture;\n                                    didSuspendAlready = true; // Ensure we transfer the update queue to the parent so that it doesn't\n                                    // get lost if this row ends up dropped during a second pass.\n                                    var _retryQueue2 = _suspended.updateQueue;\n                                    workInProgress.updateQueue = _retryQueue2;\n                                    scheduleRetryEffect(workInProgress, _retryQueue2);\n                                    cutOffTailIfNeeded(renderState, true); // This might have been modified.\n                                    if (renderState.tail === null && renderState.tailMode === 'hidden' && !renderedTail.alternate && !getIsHydrating() // We don't cut it if we're hydrating.\n                                    ) {\n                                        // We're done.\n                                        bubbleProperties(workInProgress);\n                                        return null;\n                                    }\n                                } else if (// time we have to render. So rendering one more row would likely\n                                // exceed it.\n                                now$1() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes !== OffscreenLane) {\n                                    // We have now passed our CPU deadline and we'll just give up further\n                                    // attempts to render the main content and only render fallbacks.\n                                    // The assumption is that this is usually faster.\n                                    workInProgress.flags |= DidCapture;\n                                    didSuspendAlready = true;\n                                    cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\n                                    // to get it started back up to attempt the next item. While in terms\n                                    // of priority this work has the same priority as this current render,\n                                    // it's not part of the same transition once the transition has\n                                    // committed. If it's sync, we still want to yield so that it can be\n                                    // painted. Conceptually, this is really the same as pinging.\n                                    // We can use any RetryLane even if it's the one currently rendering\n                                    // since we're leaving it behind on this node.\n                                    workInProgress.lanes = SomeRetryLane;\n                                }\n                            }\n                            if (renderState.isBackwards) {\n                                // The effect list of the backwards tail will have been added\n                                // to the end. This breaks the guarantee that life-cycles fire in\n                                // sibling order but that isn't a strong guarantee promised by React.\n                                // Especially since these might also just pop in during future commits.\n                                // Append to the beginning of the list.\n                                renderedTail.sibling = workInProgress.child;\n                                workInProgress.child = renderedTail;\n                            } else {\n                                var previousSibling = renderState.last;\n                                if (previousSibling !== null) {\n                                    previousSibling.sibling = renderedTail;\n                                } else {\n                                    workInProgress.child = renderedTail;\n                                }\n                                renderState.last = renderedTail;\n                            }\n                        }\n                        if (renderState.tail !== null) {\n                            // We still have tail rows to render.\n                            // Pop a row.\n                            var next = renderState.tail;\n                            renderState.rendering = next;\n                            renderState.tail = next.sibling;\n                            renderState.renderingStartTime = now$1();\n                            next.sibling = null; // Restore the context.\n                            // TODO: We can probably just avoid popping it instead and only\n                            // setting it the first time we go from not suspended to suspended.\n                            var suspenseContext = suspenseStackCursor.current;\n                            if (didSuspendAlready) {\n                                suspenseContext = setShallowSuspenseListContext(suspenseContext, ForceSuspenseFallback);\n                            } else {\n                                suspenseContext = setDefaultShallowSuspenseListContext(suspenseContext);\n                            }\n                            pushSuspenseListContext(workInProgress, suspenseContext); // Do a pass over the next row.\n                            // Don't bubble properties in this case.\n                            return next;\n                        }\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case ScopeComponent:\n                    {\n                        break;\n                    }\n                case OffscreenComponent:\n                case LegacyHiddenComponent:\n                    {\n                        popSuspenseHandler(workInProgress);\n                        popHiddenContext(workInProgress);\n                        var _nextState = workInProgress.memoizedState;\n                        var nextIsHidden = _nextState !== null; // Schedule a Visibility effect if the visibility has changed\n                        {\n                            if (current !== null) {\n                                var _prevState = current.memoizedState;\n                                var prevIsHidden = _prevState !== null;\n                                if (prevIsHidden !== nextIsHidden) {\n                                    workInProgress.flags |= Visibility;\n                                }\n                            } else {\n                                // On initial mount, we only need a Visibility effect if the tree\n                                // is hidden.\n                                if (nextIsHidden) {\n                                    workInProgress.flags |= Visibility;\n                                }\n                            }\n                        }\n                        if (!nextIsHidden || !disableLegacyMode) {\n                            bubbleProperties(workInProgress);\n                        } else {\n                            // Don't bubble properties for hidden children unless we're rendering\n                            // at offscreen priority.\n                            if (includesSomeLane(renderLanes, OffscreenLane) && // Also don't bubble if the tree suspended\n                            (workInProgress.flags & DidCapture) === NoLanes) {\n                                bubbleProperties(workInProgress); // Check if there was an insertion or update in the hidden subtree.\n                                // If so, we need to hide those nodes in the commit phase, so\n                                // schedule a visibility effect.\n                                if (workInProgress.subtreeFlags & (Placement | Update)) {\n                                    workInProgress.flags |= Visibility;\n                                }\n                            }\n                        }\n                        var offscreenQueue = workInProgress.updateQueue;\n                        if (offscreenQueue !== null) {\n                            var _retryQueue3 = offscreenQueue.retryQueue;\n                            scheduleRetryEffect(workInProgress, _retryQueue3);\n                        }\n                        {\n                            var _previousCache2 = null;\n                            if (current !== null && current.memoizedState !== null && current.memoizedState.cachePool !== null) {\n                                _previousCache2 = current.memoizedState.cachePool.pool;\n                            }\n                            var _cache2 = null;\n                            if (workInProgress.memoizedState !== null && workInProgress.memoizedState.cachePool !== null) {\n                                _cache2 = workInProgress.memoizedState.cachePool.pool;\n                            }\n                            if (_cache2 !== _previousCache2) {\n                                // Run passive effects to retain/release the cache.\n                                workInProgress.flags |= Passive$1;\n                            }\n                        }\n                        popTransition(workInProgress, current);\n                        return null;\n                    }\n                case CacheComponent:\n                    {\n                        {\n                            var _previousCache3 = null;\n                            if (current !== null) {\n                                _previousCache3 = current.memoizedState.cache;\n                            }\n                            var _cache3 = workInProgress.memoizedState.cache;\n                            if (_cache3 !== _previousCache3) {\n                                // Run passive effects to retain/release the cache.\n                                workInProgress.flags |= Passive$1;\n                            }\n                            popCacheProvider(workInProgress);\n                            bubbleProperties(workInProgress);\n                        }\n                        return null;\n                    }\n                case TracingMarkerComponent:\n                    {\n                        return null;\n                    }\n            }\n            throw new Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in \" + 'React. Please file an issue.');\n        }\n        function unwindWork(current, workInProgress, renderLanes) {\n            // Note: This intentionally doesn't check if we're hydrating because comparing\n            // to the current tree provider fiber is just as fast and less error-prone.\n            // Ideally we would have a special version of the work loop only\n            // for hydration.\n            popTreeContext(workInProgress);\n            switch(workInProgress.tag){\n                case ClassComponent:\n                    {\n                        var flags = workInProgress.flags;\n                        if (flags & ShouldCapture) {\n                            workInProgress.flags = flags & ~ShouldCapture | DidCapture;\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                transferActualDuration(workInProgress);\n                            }\n                            return workInProgress;\n                        }\n                        return null;\n                    }\n                case HostRoot:\n                    {\n                        {\n                            popCacheProvider(workInProgress);\n                        }\n                        popHostContainer(workInProgress);\n                        var _flags = workInProgress.flags;\n                        if ((_flags & ShouldCapture) !== NoFlags$1 && (_flags & DidCapture) === NoFlags$1) {\n                            // There was an error during render that wasn't captured by a suspense\n                            // boundary. Do a second pass on the root to unmount the children.\n                            workInProgress.flags = _flags & ~ShouldCapture | DidCapture;\n                            return workInProgress;\n                        } // We unwound to the root without completing it. Exit.\n                        return null;\n                    }\n                case HostHoistable:\n                case HostSingleton:\n                case HostComponent:\n                    {\n                        // TODO: popHydrationState\n                        popHostContext(workInProgress);\n                        return null;\n                    }\n                case SuspenseComponent:\n                    {\n                        popSuspenseHandler(workInProgress);\n                        var suspenseState = workInProgress.memoizedState;\n                        if (suspenseState !== null && suspenseState.dehydrated !== null) {\n                            if (workInProgress.alternate === null) {\n                                throw new Error('Threw in newly mounted dehydrated component. This is likely a bug in ' + 'React. Please file an issue.');\n                            }\n                            resetHydrationState();\n                        }\n                        var _flags2 = workInProgress.flags;\n                        if (_flags2 & ShouldCapture) {\n                            workInProgress.flags = _flags2 & ~ShouldCapture | DidCapture; // Captured a suspense effect. Re-render the boundary.\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                transferActualDuration(workInProgress);\n                            }\n                            return workInProgress;\n                        }\n                        return null;\n                    }\n                case SuspenseListComponent:\n                    {\n                        popSuspenseListContext(workInProgress); // SuspenseList doesn't actually catch anything. It should've been\n                        // caught by a nested boundary. If not, it should bubble through.\n                        return null;\n                    }\n                case HostPortal:\n                    popHostContainer(workInProgress);\n                    return null;\n                case ContextProvider:\n                    var context;\n                    {\n                        context = workInProgress.type;\n                    }\n                    popProvider(context, workInProgress);\n                    return null;\n                case OffscreenComponent:\n                case LegacyHiddenComponent:\n                    {\n                        popSuspenseHandler(workInProgress);\n                        popHiddenContext(workInProgress);\n                        popTransition(workInProgress, current);\n                        var _flags3 = workInProgress.flags;\n                        if (_flags3 & ShouldCapture) {\n                            workInProgress.flags = _flags3 & ~ShouldCapture | DidCapture; // Captured a suspense effect. Re-render the boundary.\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                transferActualDuration(workInProgress);\n                            }\n                            return workInProgress;\n                        }\n                        return null;\n                    }\n                case CacheComponent:\n                    {\n                        popCacheProvider(workInProgress);\n                    }\n                    return null;\n                case TracingMarkerComponent:\n                    return null;\n                default:\n                    return null;\n            }\n        }\n        function unwindInterruptedWork(current, interruptedWork, renderLanes) {\n            // Note: This intentionally doesn't check if we're hydrating because comparing\n            // to the current tree provider fiber is just as fast and less error-prone.\n            // Ideally we would have a special version of the work loop only\n            // for hydration.\n            popTreeContext(interruptedWork);\n            switch(interruptedWork.tag){\n                case ClassComponent:\n                    {\n                        break;\n                    }\n                case HostRoot:\n                    {\n                        {\n                            popCacheProvider(interruptedWork);\n                        }\n                        popHostContainer(interruptedWork);\n                        break;\n                    }\n                case HostHoistable:\n                case HostSingleton:\n                case HostComponent:\n                    {\n                        popHostContext(interruptedWork);\n                        break;\n                    }\n                case HostPortal:\n                    popHostContainer(interruptedWork);\n                    break;\n                case SuspenseComponent:\n                    popSuspenseHandler(interruptedWork);\n                    break;\n                case SuspenseListComponent:\n                    popSuspenseListContext(interruptedWork);\n                    break;\n                case ContextProvider:\n                    var context;\n                    {\n                        context = interruptedWork.type;\n                    }\n                    popProvider(context, interruptedWork);\n                    break;\n                case OffscreenComponent:\n                case LegacyHiddenComponent:\n                    popSuspenseHandler(interruptedWork);\n                    popHiddenContext(interruptedWork);\n                    popTransition(interruptedWork, current);\n                    break;\n                case CacheComponent:\n                    {\n                        popCacheProvider(interruptedWork);\n                    }\n                    break;\n            }\n        }\n        var didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n        {\n            didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n        }\n        // Allows us to avoid traversing the return path to find the nearest Offscreen ancestor.\n        var offscreenSubtreeIsHidden = false;\n        var offscreenSubtreeWasHidden = false; // Used to track if a form needs to be reset at the end of the mutation phase.\n        var needsFormReset = false;\n        var PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;\n        var nextEffect = null; // Used for Profiling builds to track updaters.\n        var inProgressLanes = null;\n        var inProgressRoot = null;\n        function shouldProfile(current) {\n            return (current.mode & ProfileMode) !== NoMode && (getExecutionContext() & CommitContext) !== NoContext;\n        }\n        function callComponentWillUnmountWithTimer(current, instance) {\n            instance.props = resolveClassComponentProps(current.type, current.memoizedProps);\n            instance.state = current.memoizedState;\n            if (shouldProfile(current)) {\n                try {\n                    startLayoutEffectTimer();\n                    instance.componentWillUnmount();\n                } finally{\n                    recordLayoutEffectDuration(current);\n                }\n            } else {\n                instance.componentWillUnmount();\n            }\n        } // Capture errors so they don't interrupt unmounting.\n        function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {\n            try {\n                callComponentWillUnmountWithTimer(current, instance);\n            } catch (error) {\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        } // Capture errors so they don't interrupt mounting.\n        function safelyAttachRef(current, nearestMountedAncestor) {\n            try {\n                commitAttachRef(current);\n            } catch (error) {\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n        function safelyDetachRef(current, nearestMountedAncestor) {\n            var ref = current.ref;\n            var refCleanup = current.refCleanup;\n            if (ref !== null) {\n                if (typeof refCleanup === 'function') {\n                    try {\n                        if (shouldProfile(current)) {\n                            try {\n                                startLayoutEffectTimer();\n                                refCleanup();\n                            } finally{\n                                recordLayoutEffectDuration(current);\n                            }\n                        } else {\n                            refCleanup();\n                        }\n                    } catch (error) {\n                        captureCommitPhaseError(current, nearestMountedAncestor, error);\n                    } finally{\n                        // `refCleanup` has been called. Nullify all references to it to prevent double invocation.\n                        current.refCleanup = null;\n                        var finishedWork = current.alternate;\n                        if (finishedWork != null) {\n                            finishedWork.refCleanup = null;\n                        }\n                    }\n                } else if (typeof ref === 'function') {\n                    try {\n                        if (shouldProfile(current)) {\n                            try {\n                                startLayoutEffectTimer();\n                                ref(null);\n                            } finally{\n                                recordLayoutEffectDuration(current);\n                            }\n                        } else {\n                            ref(null);\n                        }\n                    } catch (error) {\n                        captureCommitPhaseError(current, nearestMountedAncestor, error);\n                    }\n                } else {\n                    // $FlowFixMe[incompatible-use] unable to narrow type to RefObject\n                    ref.current = null;\n                }\n            }\n        }\n        function safelyCallDestroy(current, nearestMountedAncestor, destroy) {\n            try {\n                destroy();\n            } catch (error) {\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n        var shouldFireAfterActiveInstanceBlur = false;\n        function commitBeforeMutationEffects(root, firstChild) {\n            prepareForCommit(root.containerInfo);\n            nextEffect = firstChild;\n            commitBeforeMutationEffects_begin(); // We no longer need to track the active instance fiber\n            var shouldFire = shouldFireAfterActiveInstanceBlur;\n            shouldFireAfterActiveInstanceBlur = false;\n            return shouldFire;\n        }\n        function commitBeforeMutationEffects_begin() {\n            while(nextEffect !== null){\n                var fiber = nextEffect; // This phase is only used for beforeActiveInstanceBlur.\n                var child = fiber.child;\n                if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags$1 && child !== null) {\n                    child.return = fiber;\n                    nextEffect = child;\n                } else {\n                    commitBeforeMutationEffects_complete();\n                }\n            }\n        }\n        function commitBeforeMutationEffects_complete() {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                setCurrentDebugFiberInDEV(fiber);\n                try {\n                    commitBeforeMutationEffectsOnFiber(fiber);\n                } catch (error) {\n                    captureCommitPhaseError(fiber, fiber.return, error);\n                }\n                resetCurrentDebugFiberInDEV();\n                var sibling = fiber.sibling;\n                if (sibling !== null) {\n                    sibling.return = fiber.return;\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = fiber.return;\n            }\n        }\n        function commitBeforeMutationEffectsOnFiber(finishedWork) {\n            var current = finishedWork.alternate;\n            var flags = finishedWork.flags;\n            if ((flags & Snapshot) !== NoFlags$1) {\n                setCurrentDebugFiberInDEV(finishedWork);\n            }\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                    {\n                        break;\n                    }\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        break;\n                    }\n                case ClassComponent:\n                    {\n                        if ((flags & Snapshot) !== NoFlags$1) {\n                            if (current !== null) {\n                                var prevProps = current.memoizedProps;\n                                var prevState = current.memoizedState;\n                                var instance = finishedWork.stateNode; // We could update instance props and state here,\n                                // but instead we rely on them being set during last render.\n                                // TODO: revisit this when we implement resuming.\n                                {\n                                    if (!finishedWork.type.defaultProps && !('ref' in finishedWork.memoizedProps) && !didWarnAboutReassigningProps) {\n                                        if (instance.props !== finishedWork.memoizedProps) {\n                                            error('Expected %s props to match memoized props before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                                        }\n                                        if (instance.state !== finishedWork.memoizedState) {\n                                            error('Expected %s state to match memoized state before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                                        }\n                                    }\n                                }\n                                var snapshot = instance.getSnapshotBeforeUpdate(resolveClassComponentProps(finishedWork.type, prevProps), prevState);\n                                {\n                                    var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\n                                    if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n                                        didWarnSet.add(finishedWork.type);\n                                        error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' + 'must be returned. You have returned undefined.', getComponentNameFromFiber(finishedWork));\n                                    }\n                                }\n                                instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n                            }\n                        }\n                        break;\n                    }\n                case HostRoot:\n                    {\n                        if ((flags & Snapshot) !== NoFlags$1) {\n                            if (supportsMutation) {\n                                var root = finishedWork.stateNode;\n                                clearContainer(root.containerInfo);\n                            }\n                        }\n                        break;\n                    }\n                case HostComponent:\n                case HostHoistable:\n                case HostSingleton:\n                case HostText:\n                case HostPortal:\n                case IncompleteClassComponent:\n                    break;\n                default:\n                    {\n                        if ((flags & Snapshot) !== NoFlags$1) {\n                            throw new Error('This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');\n                        }\n                    }\n            }\n            if ((flags & Snapshot) !== NoFlags$1) {\n                resetCurrentDebugFiberInDEV();\n            }\n        }\n        function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {\n            var updateQueue = finishedWork.updateQueue;\n            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n            if (lastEffect !== null) {\n                var firstEffect = lastEffect.next;\n                var effect = firstEffect;\n                do {\n                    if ((effect.tag & flags) === flags) {\n                        // Unmount\n                        var inst = effect.inst;\n                        var destroy = inst.destroy;\n                        if (destroy !== undefined) {\n                            inst.destroy = undefined;\n                            {\n                                if ((flags & Passive) !== NoFlags) {\n                                    markComponentPassiveEffectUnmountStarted(finishedWork);\n                                } else if ((flags & Layout) !== NoFlags) {\n                                    markComponentLayoutEffectUnmountStarted(finishedWork);\n                                }\n                            }\n                            {\n                                if ((flags & Insertion) !== NoFlags) {\n                                    setIsRunningInsertionEffect(true);\n                                }\n                            }\n                            safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);\n                            {\n                                if ((flags & Insertion) !== NoFlags) {\n                                    setIsRunningInsertionEffect(false);\n                                }\n                            }\n                            {\n                                if ((flags & Passive) !== NoFlags) {\n                                    markComponentPassiveEffectUnmountStopped();\n                                } else if ((flags & Layout) !== NoFlags) {\n                                    markComponentLayoutEffectUnmountStopped();\n                                }\n                            }\n                        }\n                    }\n                    effect = effect.next;\n                }while (effect !== firstEffect);\n            }\n        }\n        function commitHookEffectListMount(flags, finishedWork) {\n            var updateQueue = finishedWork.updateQueue;\n            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n            if (lastEffect !== null) {\n                var firstEffect = lastEffect.next;\n                var effect = firstEffect;\n                do {\n                    if ((effect.tag & flags) === flags) {\n                        {\n                            if ((flags & Passive) !== NoFlags) {\n                                markComponentPassiveEffectMountStarted(finishedWork);\n                            } else if ((flags & Layout) !== NoFlags) {\n                                markComponentLayoutEffectMountStarted(finishedWork);\n                            }\n                        }\n                        var create = effect.create;\n                        {\n                            if ((flags & Insertion) !== NoFlags) {\n                                setIsRunningInsertionEffect(true);\n                            }\n                        }\n                        var inst = effect.inst;\n                        var destroy = create();\n                        inst.destroy = destroy;\n                        {\n                            if ((flags & Insertion) !== NoFlags) {\n                                setIsRunningInsertionEffect(false);\n                            }\n                        }\n                        {\n                            if ((flags & Passive) !== NoFlags) {\n                                markComponentPassiveEffectMountStopped();\n                            } else if ((flags & Layout) !== NoFlags) {\n                                markComponentLayoutEffectMountStopped();\n                            }\n                        }\n                        {\n                            if (destroy !== undefined && typeof destroy !== 'function') {\n                                var hookName = void 0;\n                                if ((effect.tag & Layout) !== NoFlags$1) {\n                                    hookName = 'useLayoutEffect';\n                                } else if ((effect.tag & Insertion) !== NoFlags$1) {\n                                    hookName = 'useInsertionEffect';\n                                } else {\n                                    hookName = 'useEffect';\n                                }\n                                var addendum = void 0;\n                                if (destroy === null) {\n                                    addendum = ' You returned null. If your effect does not require clean ' + 'up, return undefined (or nothing).';\n                                } else if (typeof destroy.then === 'function') {\n                                    addendum = '\\n\\nIt looks like you wrote ' + hookName + '(async () => ...) or returned a Promise. ' + 'Instead, write the async function inside your effect ' + 'and call it immediately:\\n\\n' + hookName + '(() => {\\n' + '  async function fetchData() {\\n' + '    // You can await here\\n' + '    const response = await MyAPI.getData(someId);\\n' + '    // ...\\n' + '  }\\n' + '  fetchData();\\n' + \"}, [someId]); // Or [] if effect doesn't need props or state\\n\\n\" + 'Learn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching';\n                                } else {\n                                    addendum = ' You returned: ' + destroy;\n                                }\n                                error('%s must not return anything besides a function, ' + 'which is used for clean-up.%s', hookName, addendum);\n                            }\n                        }\n                    }\n                    effect = effect.next;\n                }while (effect !== firstEffect);\n            }\n        }\n        function commitPassiveEffectDurations(finishedRoot, finishedWork) {\n            if (getExecutionContext() & CommitContext) {\n                // Only Profilers with work in their subtree will have an Update effect scheduled.\n                if ((finishedWork.flags & Update) !== NoFlags$1) {\n                    switch(finishedWork.tag){\n                        case Profiler:\n                            {\n                                var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;\n                                var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit; // This value will still reflect the previous commit phase.\n                                // It does not get reset until the start of the next commit phase.\n                                var commitTime = getCommitTime();\n                                var phase = finishedWork.alternate === null ? 'mount' : 'update';\n                                {\n                                    if (isCurrentUpdateNested()) {\n                                        phase = 'nested-update';\n                                    }\n                                }\n                                if (typeof onPostCommit === 'function') {\n                                    onPostCommit(id, phase, passiveEffectDuration, commitTime);\n                                } // Bubble times to the next nearest ancestor Profiler.\n                                // After we process that Profiler, we'll bubble further up.\n                                var parentFiber = finishedWork.return;\n                                outer: while(parentFiber !== null){\n                                    switch(parentFiber.tag){\n                                        case HostRoot:\n                                            var root = parentFiber.stateNode;\n                                            root.passiveEffectDuration += passiveEffectDuration;\n                                            break outer;\n                                        case Profiler:\n                                            var parentStateNode = parentFiber.stateNode;\n                                            parentStateNode.passiveEffectDuration += passiveEffectDuration;\n                                            break outer;\n                                    }\n                                    parentFiber = parentFiber.return;\n                                }\n                                break;\n                            }\n                    }\n                }\n            }\n        }\n        function commitHookLayoutEffects(finishedWork, hookFlags) {\n            // At this point layout effects have already been destroyed (during mutation phase).\n            // This is done to prevent sibling component effects from interfering with each other,\n            // e.g. a destroy function in one component should never override a ref set\n            // by a create function in another component during the same commit.\n            if (shouldProfile(finishedWork)) {\n                try {\n                    startLayoutEffectTimer();\n                    commitHookEffectListMount(hookFlags, finishedWork);\n                } catch (error) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n                recordLayoutEffectDuration(finishedWork);\n            } else {\n                try {\n                    commitHookEffectListMount(hookFlags, finishedWork);\n                } catch (error) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n            }\n        }\n        function commitClassLayoutLifecycles(finishedWork, current) {\n            var instance = finishedWork.stateNode;\n            if (current === null) {\n                // We could update instance props and state here,\n                // but instead we rely on them being set during last render.\n                // TODO: revisit this when we implement resuming.\n                {\n                    if (!finishedWork.type.defaultProps && !('ref' in finishedWork.memoizedProps) && !didWarnAboutReassigningProps) {\n                        if (instance.props !== finishedWork.memoizedProps) {\n                            error('Expected %s props to match memoized props before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                        }\n                        if (instance.state !== finishedWork.memoizedState) {\n                            error('Expected %s state to match memoized state before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                        }\n                    }\n                }\n                if (shouldProfile(finishedWork)) {\n                    try {\n                        startLayoutEffectTimer();\n                        instance.componentDidMount();\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                    recordLayoutEffectDuration(finishedWork);\n                } else {\n                    try {\n                        instance.componentDidMount();\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n            } else {\n                var prevProps = resolveClassComponentProps(finishedWork.type, current.memoizedProps);\n                var prevState = current.memoizedState; // We could update instance props and state here,\n                // but instead we rely on them being set during last render.\n                // TODO: revisit this when we implement resuming.\n                {\n                    if (!finishedWork.type.defaultProps && !('ref' in finishedWork.memoizedProps) && !didWarnAboutReassigningProps) {\n                        if (instance.props !== finishedWork.memoizedProps) {\n                            error('Expected %s props to match memoized props before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                        }\n                        if (instance.state !== finishedWork.memoizedState) {\n                            error('Expected %s state to match memoized state before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                        }\n                    }\n                }\n                if (shouldProfile(finishedWork)) {\n                    try {\n                        startLayoutEffectTimer();\n                        instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                    recordLayoutEffectDuration(finishedWork);\n                } else {\n                    try {\n                        instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n            }\n        }\n        function commitClassCallbacks(finishedWork) {\n            // TODO: I think this is now always non-null by the time it reaches the\n            // commit phase. Consider removing the type check.\n            var updateQueue = finishedWork.updateQueue;\n            if (updateQueue !== null) {\n                var instance = finishedWork.stateNode;\n                {\n                    if (!finishedWork.type.defaultProps && !('ref' in finishedWork.memoizedProps) && !didWarnAboutReassigningProps) {\n                        if (instance.props !== finishedWork.memoizedProps) {\n                            error('Expected %s props to match memoized props before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                        }\n                        if (instance.state !== finishedWork.memoizedState) {\n                            error('Expected %s state to match memoized state before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                        }\n                    }\n                }\n                // but instead we rely on them being set during last render.\n                // TODO: revisit this when we implement resuming.\n                try {\n                    commitCallbacks(updateQueue, instance);\n                } catch (error) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n            }\n        }\n        function commitHostComponentMount(finishedWork) {\n            var type = finishedWork.type;\n            var props = finishedWork.memoizedProps;\n            var instance = finishedWork.stateNode;\n            try {\n                commitMount(instance, type, props, finishedWork);\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n        }\n        function commitProfilerUpdate(finishedWork, current) {\n            if (getExecutionContext() & CommitContext) {\n                try {\n                    var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;\n                    var effectDuration = finishedWork.stateNode.effectDuration;\n                    var commitTime = getCommitTime();\n                    var phase = current === null ? 'mount' : 'update';\n                    if (enableProfilerNestedUpdatePhase) {\n                        if (isCurrentUpdateNested()) {\n                            phase = 'nested-update';\n                        }\n                    }\n                    if (typeof onRender === 'function') {\n                        onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime);\n                    }\n                    if (enableProfilerCommitHooks) {\n                        if (typeof onCommit === 'function') {\n                            onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime);\n                        } // Schedule a passive effect for this Profiler to call onPostCommit hooks.\n                        // This effect should be scheduled even if there is no onPostCommit callback for this Profiler,\n                        // because the effect is also where times bubble to parent Profilers.\n                        enqueuePendingPassiveProfilerEffect(finishedWork); // Propagate layout effect durations to the next nearest Profiler ancestor.\n                        // Do not reset these values until the next render so DevTools has a chance to read them first.\n                        var parentFiber = finishedWork.return;\n                        outer: while(parentFiber !== null){\n                            switch(parentFiber.tag){\n                                case HostRoot:\n                                    var root = parentFiber.stateNode;\n                                    root.effectDuration += effectDuration;\n                                    break outer;\n                                case Profiler:\n                                    var parentStateNode = parentFiber.stateNode;\n                                    parentStateNode.effectDuration += effectDuration;\n                                    break outer;\n                            }\n                            parentFiber = parentFiber.return;\n                        }\n                    }\n                } catch (error) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n            }\n        }\n        function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork, committedLanes) {\n            // When updating this function, also update reappearLayoutEffects, which does\n            // most of the same things when an offscreen tree goes from hidden -> visible.\n            var flags = finishedWork.flags;\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                        if (flags & Update) {\n                            commitHookLayoutEffects(finishedWork, Layout | HasEffect);\n                        }\n                        break;\n                    }\n                case ClassComponent:\n                    {\n                        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                        if (flags & Update) {\n                            commitClassLayoutLifecycles(finishedWork, current);\n                        }\n                        if (flags & Callback) {\n                            commitClassCallbacks(finishedWork);\n                        }\n                        if (flags & Ref) {\n                            safelyAttachRef(finishedWork, finishedWork.return);\n                        }\n                        break;\n                    }\n                case HostRoot:\n                    {\n                        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                        if (flags & Callback) {\n                            // TODO: I think this is now always non-null by the time it reaches the\n                            // commit phase. Consider removing the type check.\n                            var updateQueue = finishedWork.updateQueue;\n                            if (updateQueue !== null) {\n                                var instance = null;\n                                if (finishedWork.child !== null) {\n                                    switch(finishedWork.child.tag){\n                                        case HostSingleton:\n                                        case HostComponent:\n                                            instance = getPublicInstance(finishedWork.child.stateNode);\n                                            break;\n                                        case ClassComponent:\n                                            instance = finishedWork.child.stateNode;\n                                            break;\n                                    }\n                                }\n                                try {\n                                    commitCallbacks(updateQueue, instance);\n                                } catch (error) {\n                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                }\n                            }\n                        }\n                        break;\n                    }\n                case HostHoistable:\n                    {\n                        if (supportsResources) {\n                            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                            if (flags & Ref) {\n                                safelyAttachRef(finishedWork, finishedWork.return);\n                            }\n                            break;\n                        } // Fall through\n                    }\n                case HostSingleton:\n                case HostComponent:\n                    {\n                        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork); // Renderers may schedule work to be done after host components are mounted\n                        // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n                        // These effects should only be committed when components are first mounted,\n                        // aka when there is no current/alternate.\n                        if (current === null && flags & Update) {\n                            commitHostComponentMount(finishedWork);\n                        }\n                        if (flags & Ref) {\n                            safelyAttachRef(finishedWork, finishedWork.return);\n                        }\n                        break;\n                    }\n                case Profiler:\n                    {\n                        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork); // TODO: Should this fire inside an offscreen tree? Or should it wait to\n                        // fire when the tree becomes visible again.\n                        if (flags & Update) {\n                            commitProfilerUpdate(finishedWork, current);\n                        }\n                        break;\n                    }\n                case SuspenseComponent:\n                    {\n                        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                        if (flags & Update) {\n                            commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n                        }\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        var isModernRoot = disableLegacyMode;\n                        if (isModernRoot) {\n                            var isHidden = finishedWork.memoizedState !== null;\n                            var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;\n                            if (newOffscreenSubtreeIsHidden) ;\n                            else {\n                                // The Offscreen tree is visible.\n                                var wasHidden = current !== null && current.memoizedState !== null;\n                                var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;\n                                var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;\n                                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                                offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;\n                                offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;\n                                if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {\n                                    // This is the root of a reappearing boundary. As we continue\n                                    // traversing the layout effects, we must also re-mount layout\n                                    // effects that were unmounted when the Offscreen subtree was\n                                    // hidden. So this is a superset of the normal commitLayoutEffects.\n                                    var includeWorkInProgressEffects = (finishedWork.subtreeFlags & LayoutMask) !== NoFlags$1;\n                                    recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                                } else {\n                                    recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                                }\n                                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n                                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                            }\n                        } else {\n                            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                        }\n                        if (flags & Ref) {\n                            var props = finishedWork.memoizedProps;\n                            if (props.mode === 'manual') {\n                                safelyAttachRef(finishedWork, finishedWork.return);\n                            } else {\n                                safelyDetachRef(finishedWork, finishedWork.return);\n                            }\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                        break;\n                    }\n            }\n        }\n        function hideOrUnhideAllChildren(finishedWork, isHidden) {\n            // Only hide or unhide the top-most host nodes.\n            var hostSubtreeRoot = null;\n            if (supportsMutation) {\n                // We only have the top Fiber that was inserted but we need to recurse down its\n                // children to find all the terminal nodes.\n                var node = finishedWork;\n                while(true){\n                    if (node.tag === HostComponent || (supportsResources ? node.tag === HostHoistable : false) || (supportsSingletons ? node.tag === HostSingleton : false)) {\n                        if (hostSubtreeRoot === null) {\n                            hostSubtreeRoot = node;\n                            try {\n                                var instance = node.stateNode;\n                                if (isHidden) {\n                                    hideInstance(instance);\n                                } else {\n                                    unhideInstance(node.stateNode, node.memoizedProps);\n                                }\n                            } catch (error) {\n                                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                            }\n                        }\n                    } else if (node.tag === HostText) {\n                        if (hostSubtreeRoot === null) {\n                            try {\n                                var _instance = node.stateNode;\n                                if (isHidden) {\n                                    hideTextInstance(_instance);\n                                } else {\n                                    unhideTextInstance(_instance, node.memoizedProps);\n                                }\n                            } catch (error) {\n                                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                            }\n                        }\n                    } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) ;\n                    else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                    if (node === finishedWork) {\n                        return;\n                    }\n                    while(node.sibling === null){\n                        if (node.return === null || node.return === finishedWork) {\n                            return;\n                        }\n                        if (hostSubtreeRoot === node) {\n                            hostSubtreeRoot = null;\n                        }\n                        node = node.return;\n                    }\n                    if (hostSubtreeRoot === node) {\n                        hostSubtreeRoot = null;\n                    }\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            }\n        }\n        function commitAttachRef(finishedWork) {\n            var ref = finishedWork.ref;\n            if (ref !== null) {\n                var instance = finishedWork.stateNode;\n                var instanceToUse;\n                switch(finishedWork.tag){\n                    case HostHoistable:\n                    case HostSingleton:\n                    case HostComponent:\n                        instanceToUse = getPublicInstance(instance);\n                        break;\n                    default:\n                        instanceToUse = instance;\n                } // Moved outside to ensure DCE works with this flag\n                if (typeof ref === 'function') {\n                    if (shouldProfile(finishedWork)) {\n                        try {\n                            startLayoutEffectTimer();\n                            finishedWork.refCleanup = ref(instanceToUse);\n                        } finally{\n                            recordLayoutEffectDuration(finishedWork);\n                        }\n                    } else {\n                        finishedWork.refCleanup = ref(instanceToUse);\n                    }\n                } else {\n                    {\n                        // TODO: We should move these warnings to happen during the render\n                        // phase (markRef).\n                        if (typeof ref === 'string') {\n                            error('String refs are no longer supported.');\n                        } else if (!ref.hasOwnProperty('current')) {\n                            error('Unexpected ref object provided for %s. ' + 'Use either a ref-setter function or React.createRef().', getComponentNameFromFiber(finishedWork));\n                        }\n                    }\n                    ref.current = instanceToUse;\n                }\n            }\n        }\n        function detachFiberMutation(fiber) {\n            // Cut off the return pointer to disconnect it from the tree.\n            // This enables us to detect and warn against state updates on an unmounted component.\n            // It also prevents events from bubbling from within disconnected components.\n            //\n            // Ideally, we should also clear the child pointer of the parent alternate to let this\n            // get GC:ed but we don't know which for sure which parent is the current\n            // one so we'll settle for GC:ing the subtree of this child.\n            // This child itself will be GC:ed when the parent updates the next time.\n            //\n            // Note that we can't clear child or sibling pointers yet.\n            // They're needed for passive effects and for findDOMNode.\n            // We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).\n            //\n            // Don't reset the alternate yet, either. We need that so we can detach the\n            // alternate's fields in the passive phase. Clearing the return pointer is\n            // sufficient for findDOMNode semantics.\n            var alternate = fiber.alternate;\n            if (alternate !== null) {\n                alternate.return = null;\n            }\n            fiber.return = null;\n        }\n        function detachFiberAfterEffects(fiber) {\n            var alternate = fiber.alternate;\n            if (alternate !== null) {\n                fiber.alternate = null;\n                detachFiberAfterEffects(alternate);\n            } // Clear cyclical Fiber fields. This level alone is designed to roughly\n            // approximate the planned Fiber refactor. In that world, `setState` will be\n            // bound to a special \"instance\" object instead of a Fiber. The Instance\n            // object will not have any of these fields. It will only be connected to\n            // the fiber tree via a single link at the root. So if this level alone is\n            // sufficient to fix memory issues, that bodes well for our plans.\n            fiber.child = null;\n            fiber.deletions = null;\n            fiber.sibling = null; // The `stateNode` is cyclical because on host nodes it points to the host\n            // tree, which has its own pointers to children, parents, and siblings.\n            // The other host nodes also point back to fibers, so we should detach that\n            // one, too.\n            if (fiber.tag === HostComponent) {\n                var hostInstance = fiber.stateNode;\n                if (hostInstance !== null) {\n                    detachDeletedInstance(hostInstance);\n                }\n            }\n            fiber.stateNode = null;\n            {\n                fiber._debugOwner = null;\n            }\n            // disconnected the fiber from the tree. So even if something leaks this\n            // particular fiber, it won't leak anything else.\n            fiber.return = null;\n            fiber.dependencies = null;\n            fiber.memoizedProps = null;\n            fiber.memoizedState = null;\n            fiber.pendingProps = null;\n            fiber.stateNode = null; // TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.\n            fiber.updateQueue = null;\n        }\n        function emptyPortalContainer(current) {\n            if (!supportsPersistence) {\n                return;\n            }\n            var portal = current.stateNode;\n            var containerInfo = portal.containerInfo;\n            var emptyChildSet = createContainerChildSet();\n            replaceContainerChildren(containerInfo, emptyChildSet);\n        }\n        function getHostParentFiber(fiber) {\n            var parent = fiber.return;\n            while(parent !== null){\n                if (isHostParent(parent)) {\n                    return parent;\n                }\n                parent = parent.return;\n            }\n            throw new Error('Expected to find a host parent. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n        }\n        function isHostParent(fiber) {\n            return fiber.tag === HostComponent || fiber.tag === HostRoot || (supportsResources ? fiber.tag === HostHoistable : false) || (supportsSingletons ? fiber.tag === HostSingleton : false) || fiber.tag === HostPortal;\n        }\n        function getHostSibling(fiber) {\n            // We're going to search forward into the tree until we find a sibling host\n            // node. Unfortunately, if multiple insertions are done in a row we have to\n            // search past them. This leads to exponential search for the next sibling.\n            // TODO: Find a more efficient way to do this.\n            var node = fiber;\n            siblings: while(true){\n                // If we didn't find anything, let's try the next sibling.\n                while(node.sibling === null){\n                    if (node.return === null || isHostParent(node.return)) {\n                        // If we pop out of the root or hit the parent the fiber we are the\n                        // last sibling.\n                        return null;\n                    } // $FlowFixMe[incompatible-type] found when upgrading Flow\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n                while(node.tag !== HostComponent && node.tag !== HostText && (!supportsSingletons ? true : node.tag !== HostSingleton) && node.tag !== DehydratedFragment){\n                    // If it is not host node and, we might have a host node inside it.\n                    // Try to search down until we find one.\n                    if (node.flags & Placement) {\n                        continue siblings;\n                    } // If we don't have a child, try the siblings instead.\n                    // We also skip portals because they are not part of this host tree.\n                    if (node.child === null || node.tag === HostPortal) {\n                        continue siblings;\n                    } else {\n                        node.child.return = node;\n                        node = node.child;\n                    }\n                } // Check if this host node is stable or about to be placed.\n                if (!(node.flags & Placement)) {\n                    // Found it!\n                    return node.stateNode;\n                }\n            }\n        }\n        function commitPlacement(finishedWork) {\n            if (!supportsMutation) {\n                return;\n            }\n            if (supportsSingletons) {\n                if (finishedWork.tag === HostSingleton) {\n                    // Singletons are already in the Host and don't need to be placed\n                    // Since they operate somewhat like Portals though their children will\n                    // have Placement and will get placed inside them\n                    return;\n                }\n            } // Recursively insert all host nodes into the parent.\n            var parentFiber = getHostParentFiber(finishedWork);\n            switch(parentFiber.tag){\n                case HostSingleton:\n                    {\n                        if (supportsSingletons) {\n                            var parent = parentFiber.stateNode;\n                            var before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its\n                            // children to find all the terminal nodes.\n                            insertOrAppendPlacementNode(finishedWork, before, parent);\n                            break;\n                        } // Fall through\n                    }\n                case HostComponent:\n                    {\n                        var _parent = parentFiber.stateNode;\n                        if (parentFiber.flags & ContentReset) {\n                            // Reset the text content of the parent before doing any insertions\n                            resetTextContent(_parent); // Clear ContentReset from the effect tag\n                            parentFiber.flags &= ~ContentReset;\n                        }\n                        var _before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its\n                        // children to find all the terminal nodes.\n                        insertOrAppendPlacementNode(finishedWork, _before, _parent);\n                        break;\n                    }\n                case HostRoot:\n                case HostPortal:\n                    {\n                        var _parent2 = parentFiber.stateNode.containerInfo;\n                        var _before2 = getHostSibling(finishedWork);\n                        insertOrAppendPlacementNodeIntoContainer(finishedWork, _before2, _parent2);\n                        break;\n                    }\n                default:\n                    throw new Error('Invalid host parent fiber. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n            }\n        }\n        function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n            var tag = node.tag;\n            var isHost = tag === HostComponent || tag === HostText;\n            if (isHost) {\n                var stateNode = node.stateNode;\n                if (before) {\n                    insertInContainerBefore(parent, stateNode, before);\n                } else {\n                    appendChildToContainer(parent, stateNode);\n                }\n            } else if (tag === HostPortal || (supportsSingletons ? tag === HostSingleton : false)) ;\n            else {\n                var child = node.child;\n                if (child !== null) {\n                    insertOrAppendPlacementNodeIntoContainer(child, before, parent);\n                    var sibling = child.sibling;\n                    while(sibling !== null){\n                        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);\n                        sibling = sibling.sibling;\n                    }\n                }\n            }\n        }\n        function insertOrAppendPlacementNode(node, before, parent) {\n            var tag = node.tag;\n            var isHost = tag === HostComponent || tag === HostText;\n            if (isHost) {\n                var stateNode = node.stateNode;\n                if (before) {\n                    insertBefore(parent, stateNode, before);\n                } else {\n                    appendChild(parent, stateNode);\n                }\n            } else if (tag === HostPortal || (supportsSingletons ? tag === HostSingleton : false)) ;\n            else {\n                var child = node.child;\n                if (child !== null) {\n                    insertOrAppendPlacementNode(child, before, parent);\n                    var sibling = child.sibling;\n                    while(sibling !== null){\n                        insertOrAppendPlacementNode(sibling, before, parent);\n                        sibling = sibling.sibling;\n                    }\n                }\n            }\n        } // These are tracked on the stack as we recursively traverse a\n        // deleted subtree.\n        // TODO: Update these during the whole mutation phase, not just during\n        // a deletion.\n        var hostParent = null;\n        var hostParentIsContainer = false;\n        function commitDeletionEffects(root, returnFiber, deletedFiber) {\n            if (supportsMutation) {\n                // We only have the top Fiber that was deleted but we need to recurse down its\n                // children to find all the terminal nodes.\n                // Recursively delete all host nodes from the parent, detach refs, clean\n                // up mounted layout effects, and call componentWillUnmount.\n                // We only need to remove the topmost host child in each branch. But then we\n                // still need to keep traversing to unmount effects, refs, and cWU. TODO: We\n                // could split this into two separate traversals functions, where the second\n                // one doesn't include any removeChild logic. This is maybe the same\n                // function as \"disappearLayoutEffects\" (or whatever that turns into after\n                // the layout phase is refactored to use recursion).\n                // Before starting, find the nearest host parent on the stack so we know\n                // which instance/container to remove the children from.\n                // TODO: Instead of searching up the fiber return path on every deletion, we\n                // can track the nearest host component on the JS stack as we traverse the\n                // tree during the commit phase. This would make insertions faster, too.\n                var parent = returnFiber;\n                findParent: while(parent !== null){\n                    switch(parent.tag){\n                        case HostSingleton:\n                        case HostComponent:\n                            {\n                                hostParent = parent.stateNode;\n                                hostParentIsContainer = false;\n                                break findParent;\n                            }\n                        case HostRoot:\n                            {\n                                hostParent = parent.stateNode.containerInfo;\n                                hostParentIsContainer = true;\n                                break findParent;\n                            }\n                        case HostPortal:\n                            {\n                                hostParent = parent.stateNode.containerInfo;\n                                hostParentIsContainer = true;\n                                break findParent;\n                            }\n                    }\n                    parent = parent.return;\n                }\n                if (hostParent === null) {\n                    throw new Error('Expected to find a host parent. This error is likely caused by ' + 'a bug in React. Please file an issue.');\n                }\n                commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n                hostParent = null;\n                hostParentIsContainer = false;\n            } else {\n                // Detach refs and call componentWillUnmount() on the whole subtree.\n                commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n            }\n            detachFiberMutation(deletedFiber);\n        }\n        function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {\n            // TODO: Use a static flag to skip trees that don't have unmount effects\n            var child = parent.child;\n            while(child !== null){\n                commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);\n                child = child.sibling;\n            }\n        }\n        function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {\n            onCommitUnmount(deletedFiber); // The cases in this outer switch modify the stack before they traverse\n            // into their subtree. There are simpler cases in the inner switch\n            // that don't modify the stack.\n            switch(deletedFiber.tag){\n                case HostHoistable:\n                    {\n                        if (supportsResources) {\n                            if (!offscreenSubtreeWasHidden) {\n                                safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                            }\n                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                            if (deletedFiber.memoizedState) {\n                                releaseResource(deletedFiber.memoizedState);\n                            } else if (deletedFiber.stateNode) {\n                                unmountHoistable(deletedFiber.stateNode);\n                            }\n                            return;\n                        } // Fall through\n                    }\n                case HostSingleton:\n                    {\n                        if (supportsSingletons) {\n                            if (!offscreenSubtreeWasHidden) {\n                                safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                            }\n                            var prevHostParent = hostParent;\n                            var prevHostParentIsContainer = hostParentIsContainer;\n                            hostParent = deletedFiber.stateNode;\n                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber); // Normally this is called in passive unmount effect phase however with\n                            // HostSingleton we warn if you acquire one that is already associated to\n                            // a different fiber. To increase our chances of avoiding this, specifically\n                            // if you keyed a HostSingleton so there will be a delete followed by a Placement\n                            // we treat detach eagerly here\n                            releaseSingletonInstance(deletedFiber.stateNode);\n                            hostParent = prevHostParent;\n                            hostParentIsContainer = prevHostParentIsContainer;\n                            return;\n                        } // Fall through\n                    }\n                case HostComponent:\n                    {\n                        if (!offscreenSubtreeWasHidden) {\n                            safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                        } // Intentional fallthrough to next branch\n                    }\n                case HostText:\n                    {\n                        // We only need to remove the nearest host child. Set the host parent\n                        // to `null` on the stack to indicate that nested children don't\n                        // need to be removed.\n                        if (supportsMutation) {\n                            var _prevHostParent = hostParent;\n                            var _prevHostParentIsContainer = hostParentIsContainer;\n                            hostParent = null;\n                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                            hostParent = _prevHostParent;\n                            hostParentIsContainer = _prevHostParentIsContainer;\n                            if (hostParent !== null) {\n                                // Now that all the child effects have unmounted, we can remove the\n                                // node from the tree.\n                                if (hostParentIsContainer) {\n                                    removeChildFromContainer(hostParent, deletedFiber.stateNode);\n                                } else {\n                                    removeChild(hostParent, deletedFiber.stateNode);\n                                }\n                            }\n                        } else {\n                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                        }\n                        return;\n                    }\n                case DehydratedFragment:\n                    {\n                        // Delete the dehydrated suspense boundary and all of its content.\n                        if (supportsMutation) {\n                            if (hostParent !== null) {\n                                if (hostParentIsContainer) {\n                                    clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);\n                                } else {\n                                    clearSuspenseBoundary(hostParent, deletedFiber.stateNode);\n                                }\n                            }\n                        }\n                        return;\n                    }\n                case HostPortal:\n                    {\n                        if (supportsMutation) {\n                            // When we go into a portal, it becomes the parent to remove from.\n                            var _prevHostParent2 = hostParent;\n                            var _prevHostParentIsContainer2 = hostParentIsContainer;\n                            hostParent = deletedFiber.stateNode.containerInfo;\n                            hostParentIsContainer = true;\n                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                            hostParent = _prevHostParent2;\n                            hostParentIsContainer = _prevHostParentIsContainer2;\n                        } else {\n                            emptyPortalContainer(deletedFiber);\n                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                        }\n                        return;\n                    }\n                case FunctionComponent:\n                case ForwardRef:\n                case MemoComponent:\n                case SimpleMemoComponent:\n                    {\n                        if (!offscreenSubtreeWasHidden) {\n                            var updateQueue = deletedFiber.updateQueue;\n                            if (updateQueue !== null) {\n                                var lastEffect = updateQueue.lastEffect;\n                                if (lastEffect !== null) {\n                                    var firstEffect = lastEffect.next;\n                                    var effect = firstEffect;\n                                    do {\n                                        var tag = effect.tag;\n                                        var inst = effect.inst;\n                                        var destroy = inst.destroy;\n                                        if (destroy !== undefined) {\n                                            if ((tag & Insertion) !== NoFlags) {\n                                                inst.destroy = undefined;\n                                                safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                                            } else if ((tag & Layout) !== NoFlags) {\n                                                {\n                                                    markComponentLayoutEffectUnmountStarted(deletedFiber);\n                                                }\n                                                if (shouldProfile(deletedFiber)) {\n                                                    startLayoutEffectTimer();\n                                                    inst.destroy = undefined;\n                                                    safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                                                    recordLayoutEffectDuration(deletedFiber);\n                                                } else {\n                                                    inst.destroy = undefined;\n                                                    safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                                                }\n                                                {\n                                                    markComponentLayoutEffectUnmountStopped();\n                                                }\n                                            }\n                                        }\n                                        effect = effect.next;\n                                    }while (effect !== firstEffect);\n                                }\n                            }\n                        }\n                        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                        return;\n                    }\n                case ClassComponent:\n                    {\n                        if (!offscreenSubtreeWasHidden) {\n                            safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                            var instance = deletedFiber.stateNode;\n                            if (typeof instance.componentWillUnmount === 'function') {\n                                safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);\n                            }\n                        }\n                        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                        return;\n                    }\n                case ScopeComponent:\n                    {\n                        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                        return;\n                    }\n                case OffscreenComponent:\n                    {\n                        safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                        {\n                            // If this offscreen component is hidden, we already unmounted it. Before\n                            // deleting the children, track that it's already unmounted so that we\n                            // don't attempt to unmount the effects again.\n                            // TODO: If the tree is hidden, in most cases we should be able to skip\n                            // over the nested children entirely. An exception is we haven't yet found\n                            // the topmost host node to delete, which we already track on the stack.\n                            // But the other case is portals, which need to be detached no matter how\n                            // deeply they are nested. We should use a subtree flag to track whether a\n                            // subtree includes a nested portal.\n                            var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;\n                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                        return;\n                    }\n            }\n        }\n        function commitSuspenseCallback(finishedWork) {}\n        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n            if (!supportsHydration) {\n                return;\n            }\n            var newState = finishedWork.memoizedState;\n            if (newState === null) {\n                var current = finishedWork.alternate;\n                if (current !== null) {\n                    var prevState = current.memoizedState;\n                    if (prevState !== null) {\n                        var suspenseInstance = prevState.dehydrated;\n                        if (suspenseInstance !== null) {\n                            try {\n                                commitHydratedSuspenseInstance(suspenseInstance);\n                                var hydrationCallbacks, onHydrated;\n                                if (enableSuspenseCallback) ;\n                            } catch (error) {\n                                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        function getRetryCache(finishedWork) {\n            // TODO: Unify the interface for the retry cache so we don't have to switch\n            // on the tag like this.\n            switch(finishedWork.tag){\n                case SuspenseComponent:\n                case SuspenseListComponent:\n                    {\n                        var retryCache = finishedWork.stateNode;\n                        if (retryCache === null) {\n                            retryCache = finishedWork.stateNode = new PossiblyWeakSet();\n                        }\n                        return retryCache;\n                    }\n                case OffscreenComponent:\n                    {\n                        var instance = finishedWork.stateNode;\n                        var _retryCache = instance._retryCache;\n                        if (_retryCache === null) {\n                            _retryCache = instance._retryCache = new PossiblyWeakSet();\n                        }\n                        return _retryCache;\n                    }\n                default:\n                    {\n                        throw new Error(\"Unexpected Suspense handler tag (\" + finishedWork.tag + \"). This is a \" + 'bug in React.');\n                    }\n            }\n        }\n        function detachOffscreenInstance(instance) {\n            var fiber = instance._current;\n            if (fiber === null) {\n                throw new Error('Calling Offscreen.detach before instance handle has been set.');\n            }\n            if ((instance._pendingVisibility & OffscreenDetached) !== NoFlags$1) {\n                // The instance is already detached, this is a noop.\n                return;\n            } // TODO: There is an opportunity to optimise this by not entering commit phase\n            // and unmounting effects directly.\n            var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n            if (root !== null) {\n                instance._pendingVisibility |= OffscreenDetached;\n                scheduleUpdateOnFiber(root, fiber, SyncLane);\n            }\n        }\n        function attachOffscreenInstance(instance) {\n            var fiber = instance._current;\n            if (fiber === null) {\n                throw new Error('Calling Offscreen.detach before instance handle has been set.');\n            }\n            if ((instance._pendingVisibility & OffscreenDetached) === NoFlags$1) {\n                // The instance is already attached, this is a noop.\n                return;\n            }\n            var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n            if (root !== null) {\n                instance._pendingVisibility &= ~OffscreenDetached;\n                scheduleUpdateOnFiber(root, fiber, SyncLane);\n            }\n        }\n        function attachSuspenseRetryListeners(finishedWork, wakeables) {\n            // If this boundary just timed out, then it will have a set of wakeables.\n            // For each wakeable, attach a listener so that when it resolves, React\n            // attempts to re-render the boundary in the primary (pre-timeout) state.\n            var retryCache = getRetryCache(finishedWork);\n            wakeables.forEach(function(wakeable) {\n                // Memoize using the boundary fiber to prevent redundant listeners.\n                var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n                if (!retryCache.has(wakeable)) {\n                    retryCache.add(wakeable);\n                    {\n                        if (isDevToolsPresent) {\n                            if (inProgressLanes !== null && inProgressRoot !== null) {\n                                // If we have pending work still, associate the original updaters with it.\n                                restorePendingUpdaters(inProgressRoot, inProgressLanes);\n                            } else {\n                                throw Error('Expected finished root and lanes to be set. This is a bug in React.');\n                            }\n                        }\n                    }\n                    wakeable.then(retry, retry);\n                }\n            });\n        } // This function detects when a Suspense boundary goes from visible to hidden.\n        function commitMutationEffects(root, finishedWork, committedLanes) {\n            inProgressLanes = committedLanes;\n            inProgressRoot = root;\n            setCurrentDebugFiberInDEV(finishedWork);\n            commitMutationEffectsOnFiber(finishedWork, root);\n            resetCurrentDebugFiberInDEV();\n            inProgressLanes = null;\n            inProgressRoot = null;\n        }\n        function recursivelyTraverseMutationEffects(root, parentFiber, lanes) {\n            // Deletions effects can be scheduled on any fiber type. They need to happen\n            // before the children effects hae fired.\n            var deletions = parentFiber.deletions;\n            if (deletions !== null) {\n                for(var i = 0; i < deletions.length; i++){\n                    var childToDelete = deletions[i];\n                    try {\n                        commitDeletionEffects(root, parentFiber, childToDelete);\n                    } catch (error) {\n                        captureCommitPhaseError(childToDelete, parentFiber, error);\n                    }\n                }\n            }\n            var prevDebugFiber = getCurrentFiber();\n            if (parentFiber.subtreeFlags & MutationMask) {\n                var child = parentFiber.child;\n                while(child !== null){\n                    setCurrentDebugFiberInDEV(child);\n                    commitMutationEffectsOnFiber(child, root);\n                    child = child.sibling;\n                }\n            }\n            setCurrentDebugFiberInDEV(prevDebugFiber);\n        }\n        var currentHoistableRoot = null;\n        function commitMutationEffectsOnFiber(finishedWork, root, lanes) {\n            var current = finishedWork.alternate;\n            var flags = finishedWork.flags; // The effect flag should be checked *after* we refine the type of fiber,\n            // because the fiber tag is more specific. An exception is any flag related\n            // to reconciliation, because those can be set on all fiber types.\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case MemoComponent:\n                case SimpleMemoComponent:\n                    {\n                        recursivelyTraverseMutationEffects(root, finishedWork);\n                        commitReconciliationEffects(finishedWork);\n                        if (flags & Update) {\n                            try {\n                                commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);\n                                commitHookEffectListMount(Insertion | HasEffect, finishedWork);\n                            } catch (error) {\n                                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                            } // Layout effects are destroyed during the mutation phase so that all\n                            // destroy functions for all fibers are called before any create functions.\n                            // This prevents sibling component effects from interfering with each other,\n                            // e.g. a destroy function in one component should never override a ref set\n                            // by a create function in another component during the same commit.\n                            if (shouldProfile(finishedWork)) {\n                                try {\n                                    startLayoutEffectTimer();\n                                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n                                } catch (error) {\n                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                }\n                                recordLayoutEffectDuration(finishedWork);\n                            } else {\n                                try {\n                                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n                                } catch (error) {\n                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                }\n                            }\n                        }\n                        return;\n                    }\n                case ClassComponent:\n                    {\n                        recursivelyTraverseMutationEffects(root, finishedWork);\n                        commitReconciliationEffects(finishedWork);\n                        if (flags & Ref) {\n                            if (current !== null) {\n                                safelyDetachRef(current, current.return);\n                            }\n                        }\n                        if (flags & Callback && offscreenSubtreeIsHidden) {\n                            var updateQueue = finishedWork.updateQueue;\n                            if (updateQueue !== null) {\n                                deferHiddenCallbacks(updateQueue);\n                            }\n                        }\n                        return;\n                    }\n                case HostHoistable:\n                    {\n                        if (supportsResources) {\n                            // We cast because we always set the root at the React root and so it cannot be\n                            // null while we are processing mutation effects\n                            var hoistableRoot = currentHoistableRoot;\n                            recursivelyTraverseMutationEffects(root, finishedWork);\n                            commitReconciliationEffects(finishedWork);\n                            if (flags & Ref) {\n                                if (current !== null) {\n                                    safelyDetachRef(current, current.return);\n                                }\n                            }\n                            if (flags & Update) {\n                                var currentResource = current !== null ? current.memoizedState : null;\n                                var newResource = finishedWork.memoizedState;\n                                if (current === null) {\n                                    // We are mounting a new HostHoistable Fiber. We fork the mount\n                                    // behavior based on whether this instance is a Hoistable Instance\n                                    // or a Hoistable Resource\n                                    if (newResource === null) {\n                                        if (finishedWork.stateNode === null) {\n                                            finishedWork.stateNode = hydrateHoistable(hoistableRoot, finishedWork.type, finishedWork.memoizedProps, finishedWork);\n                                        } else {\n                                            mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode);\n                                        }\n                                    } else {\n                                        finishedWork.stateNode = acquireResource(hoistableRoot, newResource, finishedWork.memoizedProps);\n                                    }\n                                } else if (currentResource !== newResource) {\n                                    // We are moving to or from Hoistable Resource, or between different Hoistable Resources\n                                    if (currentResource === null) {\n                                        if (current.stateNode !== null) {\n                                            unmountHoistable(current.stateNode);\n                                        }\n                                    } else {\n                                        releaseResource(currentResource);\n                                    }\n                                    if (newResource === null) {\n                                        mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode);\n                                    } else {\n                                        acquireResource(hoistableRoot, newResource, finishedWork.memoizedProps);\n                                    }\n                                } else if (newResource === null && finishedWork.stateNode !== null) {\n                                    try {\n                                        commitUpdate(finishedWork.stateNode, finishedWork.type, current.memoizedProps, finishedWork.memoizedProps, finishedWork);\n                                    } catch (error) {\n                                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                    }\n                                }\n                            }\n                            return;\n                        } // Fall through\n                    }\n                case HostSingleton:\n                    {\n                        if (supportsSingletons) {\n                            if (flags & Update) {\n                                var previousWork = finishedWork.alternate;\n                                if (previousWork === null) {\n                                    var singleton = finishedWork.stateNode;\n                                    var props = finishedWork.memoizedProps; // This was a new mount, we need to clear and set initial properties\n                                    clearSingleton(singleton);\n                                    acquireSingletonInstance(finishedWork.type, props, singleton, finishedWork);\n                                }\n                            }\n                        } // Fall through\n                    }\n                case HostComponent:\n                    {\n                        recursivelyTraverseMutationEffects(root, finishedWork);\n                        commitReconciliationEffects(finishedWork);\n                        if (flags & Ref) {\n                            if (current !== null) {\n                                safelyDetachRef(current, current.return);\n                            }\n                        }\n                        if (supportsMutation) {\n                            // TODO: ContentReset gets cleared by the children during the commit\n                            // phase. This is a refactor hazard because it means we must read\n                            // flags the flags after `commitReconciliationEffects` has already run;\n                            // the order matters. We should refactor so that ContentReset does not\n                            // rely on mutating the flag during commit. Like by setting a flag\n                            // during the render phase instead.\n                            if (finishedWork.flags & ContentReset) {\n                                var instance = finishedWork.stateNode;\n                                try {\n                                    resetTextContent(instance);\n                                } catch (error) {\n                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                }\n                            }\n                            if (flags & Update) {\n                                var _instance2 = finishedWork.stateNode;\n                                if (_instance2 != null) {\n                                    // Commit the work prepared earlier.\n                                    var newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n                                    // as the newProps. The updatePayload will contain the real change in\n                                    // this case.\n                                    var oldProps = current !== null ? current.memoizedProps : newProps;\n                                    var type = finishedWork.type;\n                                    try {\n                                        commitUpdate(_instance2, type, oldProps, newProps, finishedWork);\n                                    } catch (error) {\n                                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                    }\n                                }\n                            }\n                            if (flags & FormReset) {\n                                needsFormReset = true;\n                                {\n                                    if (finishedWork.type !== 'form') {\n                                        // Paranoid coding. In case we accidentally start using the\n                                        // FormReset bit for something else.\n                                        error('Unexpected host component type. Expected a form. This is a ' + 'bug in React.');\n                                    }\n                                }\n                            }\n                        }\n                        return;\n                    }\n                case HostText:\n                    {\n                        recursivelyTraverseMutationEffects(root, finishedWork);\n                        commitReconciliationEffects(finishedWork);\n                        if (flags & Update) {\n                            if (supportsMutation) {\n                                if (finishedWork.stateNode === null) {\n                                    throw new Error('This should have a text node initialized. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n                                }\n                                var textInstance = finishedWork.stateNode;\n                                var newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n                                // as the newProps. The updatePayload will contain the real change in\n                                // this case.\n                                var oldText = current !== null ? current.memoizedProps : newText;\n                                try {\n                                    commitTextUpdate(textInstance, oldText, newText);\n                                } catch (error) {\n                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                }\n                            }\n                        }\n                        return;\n                    }\n                case HostRoot:\n                    {\n                        if (supportsResources) {\n                            prepareToCommitHoistables();\n                            var previousHoistableRoot = currentHoistableRoot;\n                            currentHoistableRoot = getHoistableRoot(root.containerInfo);\n                            recursivelyTraverseMutationEffects(root, finishedWork);\n                            currentHoistableRoot = previousHoistableRoot;\n                            commitReconciliationEffects(finishedWork);\n                        } else {\n                            recursivelyTraverseMutationEffects(root, finishedWork);\n                            commitReconciliationEffects(finishedWork);\n                        }\n                        if (flags & Update) {\n                            if (supportsMutation && supportsHydration) {\n                                if (current !== null) {\n                                    var prevRootState = current.memoizedState;\n                                    if (prevRootState.isDehydrated) {\n                                        try {\n                                            commitHydratedContainer(root.containerInfo);\n                                        } catch (error) {\n                                            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                        }\n                                    }\n                                }\n                            }\n                            if (supportsPersistence) {\n                                var containerInfo = root.containerInfo;\n                                var pendingChildren = root.pendingChildren;\n                                try {\n                                    replaceContainerChildren(containerInfo, pendingChildren);\n                                } catch (error) {\n                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                }\n                            }\n                        }\n                        if (needsFormReset) {\n                            // A form component requested to be reset during this commit. We do this\n                            // after all mutations in the rest of the tree so that `defaultValue`\n                            // will already be updated. This way you can update `defaultValue` using\n                            // data sent by the server as a result of the form submission.\n                            //\n                            // Theoretically we could check finishedWork.subtreeFlags & FormReset,\n                            // but the FormReset bit is overloaded with other flags used by other\n                            // fiber types. So this extra variable lets us skip traversing the tree\n                            // except when a form was actually submitted.\n                            needsFormReset = false;\n                            recursivelyResetForms(finishedWork);\n                        }\n                        return;\n                    }\n                case HostPortal:\n                    {\n                        if (supportsResources) {\n                            var _previousHoistableRoot = currentHoistableRoot;\n                            currentHoistableRoot = getHoistableRoot(finishedWork.stateNode.containerInfo);\n                            recursivelyTraverseMutationEffects(root, finishedWork);\n                            commitReconciliationEffects(finishedWork);\n                            currentHoistableRoot = _previousHoistableRoot;\n                        } else {\n                            recursivelyTraverseMutationEffects(root, finishedWork);\n                            commitReconciliationEffects(finishedWork);\n                        }\n                        if (flags & Update) {\n                            if (supportsPersistence) {\n                                var portal = finishedWork.stateNode;\n                                var _containerInfo = portal.containerInfo;\n                                var _pendingChildren = portal.pendingChildren;\n                                try {\n                                    replaceContainerChildren(_containerInfo, _pendingChildren);\n                                } catch (error) {\n                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                }\n                            }\n                        }\n                        return;\n                    }\n                case SuspenseComponent:\n                    {\n                        recursivelyTraverseMutationEffects(root, finishedWork);\n                        commitReconciliationEffects(finishedWork); // TODO: We should mark a flag on the Suspense fiber itself, rather than\n                        // relying on the Offscreen fiber having a flag also being marked. The\n                        // reason is that this offscreen fiber might not be part of the work-in-\n                        // progress tree! It could have been reused from a previous render. This\n                        // doesn't lead to incorrect behavior because we don't rely on the flag\n                        // check alone; we also compare the states explicitly below. But for\n                        // modeling purposes, we _should_ be able to rely on the flag check alone.\n                        // So this is a bit fragile.\n                        //\n                        // Also, all this logic could/should move to the passive phase so it\n                        // doesn't block paint.\n                        var offscreenFiber = finishedWork.child;\n                        if (offscreenFiber.flags & Visibility) {\n                            // Throttle the appearance and disappearance of Suspense fallbacks.\n                            var isShowingFallback = finishedWork.memoizedState !== null;\n                            var wasShowingFallback = current !== null && current.memoizedState !== null;\n                            {\n                                if (isShowingFallback !== wasShowingFallback) {\n                                    // A fallback is either appearing or disappearing.\n                                    markCommitTimeOfFallback();\n                                }\n                            }\n                        }\n                        if (flags & Update) {\n                            try {\n                                commitSuspenseCallback(finishedWork);\n                            } catch (error) {\n                                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                            }\n                            var retryQueue = finishedWork.updateQueue;\n                            if (retryQueue !== null) {\n                                finishedWork.updateQueue = null;\n                                attachSuspenseRetryListeners(finishedWork, retryQueue);\n                            }\n                        }\n                        return;\n                    }\n                case OffscreenComponent:\n                    {\n                        if (flags & Ref) {\n                            if (current !== null) {\n                                safelyDetachRef(current, current.return);\n                            }\n                        }\n                        var newState = finishedWork.memoizedState;\n                        var isHidden = newState !== null;\n                        var wasHidden = current !== null && current.memoizedState !== null;\n                        {\n                            // Before committing the children, track on the stack whether this\n                            // offscreen subtree was already hidden, so that we don't unmount the\n                            // effects again.\n                            var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;\n                            var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || isHidden;\n                            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;\n                            recursivelyTraverseMutationEffects(root, finishedWork);\n                            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n                        }\n                        commitReconciliationEffects(finishedWork);\n                        var offscreenInstance = finishedWork.stateNode; // TODO: Add explicit effect flag to set _current.\n                        offscreenInstance._current = finishedWork; // Offscreen stores pending changes to visibility in `_pendingVisibility`. This is\n                        // to support batching of `attach` and `detach` calls.\n                        offscreenInstance._visibility &= ~OffscreenDetached;\n                        offscreenInstance._visibility |= offscreenInstance._pendingVisibility & OffscreenDetached;\n                        if (flags & Visibility) {\n                            // Track the current state on the Offscreen instance so we can\n                            // read it during an event\n                            if (isHidden) {\n                                offscreenInstance._visibility &= ~OffscreenVisible;\n                            } else {\n                                offscreenInstance._visibility |= OffscreenVisible;\n                            }\n                            if (isHidden) {\n                                var isUpdate = current !== null;\n                                var wasHiddenByAncestorOffscreen = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden; // Only trigger disapper layout effects if:\n                                //   - This is an update, not first mount.\n                                //   - This Offscreen was not hidden before.\n                                //   - Ancestor Offscreen was not hidden in previous commit.\n                                if (isUpdate && !wasHidden && !wasHiddenByAncestorOffscreen) {\n                                    {\n                                        // Disappear the layout effects of all the children\n                                        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                                    }\n                                }\n                            } // Offscreen with manual mode manages visibility manually.\n                            if (supportsMutation && !isOffscreenManual(finishedWork)) {\n                                // TODO: This needs to run whenever there's an insertion or update\n                                // inside a hidden Offscreen tree.\n                                hideOrUnhideAllChildren(finishedWork, isHidden);\n                            }\n                        } // TODO: Move to passive phase\n                        if (flags & Update) {\n                            var offscreenQueue = finishedWork.updateQueue;\n                            if (offscreenQueue !== null) {\n                                var _retryQueue = offscreenQueue.retryQueue;\n                                if (_retryQueue !== null) {\n                                    offscreenQueue.retryQueue = null;\n                                    attachSuspenseRetryListeners(finishedWork, _retryQueue);\n                                }\n                            }\n                        }\n                        return;\n                    }\n                case SuspenseListComponent:\n                    {\n                        recursivelyTraverseMutationEffects(root, finishedWork);\n                        commitReconciliationEffects(finishedWork);\n                        if (flags & Update) {\n                            var _retryQueue2 = finishedWork.updateQueue;\n                            if (_retryQueue2 !== null) {\n                                finishedWork.updateQueue = null;\n                                attachSuspenseRetryListeners(finishedWork, _retryQueue2);\n                            }\n                        }\n                        return;\n                    }\n                case ScopeComponent:\n                    {\n                        return;\n                    }\n                default:\n                    {\n                        recursivelyTraverseMutationEffects(root, finishedWork);\n                        commitReconciliationEffects(finishedWork);\n                        return;\n                    }\n            }\n        }\n        function commitReconciliationEffects(finishedWork) {\n            // Placement effects (insertions, reorders) can be scheduled on any fiber\n            // type. They needs to happen after the children effects have fired, but\n            // before the effects on this fiber have fired.\n            var flags = finishedWork.flags;\n            if (flags & Placement) {\n                try {\n                    commitPlacement(finishedWork);\n                } catch (error) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                } // Clear the \"placement\" from effect tag so that we know that this is\n                // inserted, before any life-cycles like componentDidMount gets called.\n                // TODO: findDOMNode doesn't rely on this any more but isMounted does\n                // and isMounted is deprecated anyway so we should be able to kill this.\n                finishedWork.flags &= ~Placement;\n            }\n            if (flags & Hydrating) {\n                finishedWork.flags &= ~Hydrating;\n            }\n        }\n        function recursivelyResetForms(parentFiber) {\n            if (parentFiber.subtreeFlags & FormReset) {\n                var child = parentFiber.child;\n                while(child !== null){\n                    resetFormOnFiber(child);\n                    child = child.sibling;\n                }\n            }\n        }\n        function resetFormOnFiber(fiber) {\n            recursivelyResetForms(fiber);\n            if (fiber.tag === HostComponent && fiber.flags & FormReset) {\n                var formInstance = fiber.stateNode;\n                resetFormInstance(formInstance);\n            }\n        }\n        function commitLayoutEffects(finishedWork, root, committedLanes) {\n            inProgressLanes = committedLanes;\n            inProgressRoot = root;\n            setCurrentDebugFiberInDEV(finishedWork);\n            var current = finishedWork.alternate;\n            commitLayoutEffectOnFiber(root, current, finishedWork);\n            resetCurrentDebugFiberInDEV();\n            inProgressLanes = null;\n            inProgressRoot = null;\n        }\n        function recursivelyTraverseLayoutEffects(root, parentFiber, lanes) {\n            var prevDebugFiber = getCurrentFiber();\n            if (parentFiber.subtreeFlags & LayoutMask) {\n                var child = parentFiber.child;\n                while(child !== null){\n                    setCurrentDebugFiberInDEV(child);\n                    var current = child.alternate;\n                    commitLayoutEffectOnFiber(root, current, child);\n                    child = child.sibling;\n                }\n            }\n            setCurrentDebugFiberInDEV(prevDebugFiber);\n        }\n        function disappearLayoutEffects(finishedWork) {\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case MemoComponent:\n                case SimpleMemoComponent:\n                    {\n                        // TODO (Offscreen) Check: flags & LayoutStatic\n                        if (shouldProfile(finishedWork)) {\n                            try {\n                                startLayoutEffectTimer();\n                                commitHookEffectListUnmount(Layout, finishedWork, finishedWork.return);\n                            } finally{\n                                recordLayoutEffectDuration(finishedWork);\n                            }\n                        } else {\n                            commitHookEffectListUnmount(Layout, finishedWork, finishedWork.return);\n                        }\n                        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                        break;\n                    }\n                case ClassComponent:\n                    {\n                        // TODO (Offscreen) Check: flags & RefStatic\n                        safelyDetachRef(finishedWork, finishedWork.return);\n                        var instance = finishedWork.stateNode;\n                        if (typeof instance.componentWillUnmount === 'function') {\n                            safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance);\n                        }\n                        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                        break;\n                    }\n                case HostHoistable:\n                case HostSingleton:\n                case HostComponent:\n                    {\n                        // TODO (Offscreen) Check: flags & RefStatic\n                        safelyDetachRef(finishedWork, finishedWork.return);\n                        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        // TODO (Offscreen) Check: flags & RefStatic\n                        safelyDetachRef(finishedWork, finishedWork.return);\n                        var isHidden = finishedWork.memoizedState !== null;\n                        if (isHidden) ;\n                        else {\n                            recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                        break;\n                    }\n            }\n        }\n        function recursivelyTraverseDisappearLayoutEffects(parentFiber) {\n            // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\n            var child = parentFiber.child;\n            while(child !== null){\n                disappearLayoutEffects(child);\n                child = child.sibling;\n            }\n        }\n        function reappearLayoutEffects(finishedRoot, current, finishedWork, // from a previously committed tree. We cannot check non-static flags if the\n        // node was reused.\n        includeWorkInProgressEffects) {\n            // Turn on layout effects in a tree that previously disappeared.\n            var flags = finishedWork.flags;\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects); // TODO: Check flags & LayoutStatic\n                        commitHookLayoutEffects(finishedWork, Layout);\n                        break;\n                    }\n                case ClassComponent:\n                    {\n                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects); // TODO: Check for LayoutStatic flag\n                        var instance = finishedWork.stateNode;\n                        if (typeof instance.componentDidMount === 'function') {\n                            try {\n                                instance.componentDidMount();\n                            } catch (error) {\n                                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                            }\n                        } // Commit any callbacks that would have fired while the component\n                        // was hidden.\n                        var updateQueue = finishedWork.updateQueue;\n                        if (updateQueue !== null) {\n                            commitHiddenCallbacks(updateQueue, instance);\n                        } // If this is newly finished work, check for setState callbacks\n                        if (includeWorkInProgressEffects && flags & Callback) {\n                            commitClassCallbacks(finishedWork);\n                        } // TODO: Check flags & RefStatic\n                        safelyAttachRef(finishedWork, finishedWork.return);\n                        break;\n                    }\n                // Unlike commitLayoutEffectsOnFiber, we don't need to handle HostRoot\n                // because this function only visits nodes that are inside an\n                // Offscreen fiber.\n                // case HostRoot: {\n                //  ...\n                // }\n                case HostHoistable:\n                case HostSingleton:\n                case HostComponent:\n                    {\n                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects); // Renderers may schedule work to be done after host components are mounted\n                        // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n                        // These effects should only be committed when components are first mounted,\n                        // aka when there is no current/alternate.\n                        if (includeWorkInProgressEffects && current === null && flags & Update) {\n                            commitHostComponentMount(finishedWork);\n                        } // TODO: Check flags & Ref\n                        safelyAttachRef(finishedWork, finishedWork.return);\n                        break;\n                    }\n                case Profiler:\n                    {\n                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects); // TODO: Figure out how Profiler updates should work with Offscreen\n                        if (includeWorkInProgressEffects && flags & Update) {\n                            commitProfilerUpdate(finishedWork, current);\n                        }\n                        break;\n                    }\n                case SuspenseComponent:\n                    {\n                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects); // TODO: Figure out how Suspense hydration callbacks should work\n                        // with Offscreen.\n                        if (includeWorkInProgressEffects && flags & Update) {\n                            commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n                        }\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        var offscreenState = finishedWork.memoizedState;\n                        var isHidden = offscreenState !== null;\n                        if (isHidden) ;\n                        else {\n                            recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                        } // TODO: Check flags & Ref\n                        safelyAttachRef(finishedWork, finishedWork.return);\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                        break;\n                    }\n            }\n        }\n        function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {\n            // This function visits both newly finished work and nodes that were re-used\n            // from a previously committed tree. We cannot check non-static flags if the\n            // node was reused.\n            var childShouldIncludeWorkInProgressEffects = includeWorkInProgressEffects && (parentFiber.subtreeFlags & LayoutMask) !== NoFlags$1; // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\n            var prevDebugFiber = getCurrentFiber();\n            var child = parentFiber.child;\n            while(child !== null){\n                var current = child.alternate;\n                reappearLayoutEffects(finishedRoot, current, child, childShouldIncludeWorkInProgressEffects);\n                child = child.sibling;\n            }\n            setCurrentDebugFiberInDEV(prevDebugFiber);\n        }\n        function commitHookPassiveMountEffects(finishedWork, hookFlags) {\n            if (shouldProfile(finishedWork)) {\n                startPassiveEffectTimer();\n                try {\n                    commitHookEffectListMount(hookFlags, finishedWork);\n                } catch (error) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n                recordPassiveEffectDuration(finishedWork);\n            } else {\n                try {\n                    commitHookEffectListMount(hookFlags, finishedWork);\n                } catch (error) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n            }\n        }\n        function commitOffscreenPassiveMountEffects(current, finishedWork, instance) {\n            {\n                var previousCache = null;\n                if (current !== null && current.memoizedState !== null && current.memoizedState.cachePool !== null) {\n                    previousCache = current.memoizedState.cachePool.pool;\n                }\n                var nextCache = null;\n                if (finishedWork.memoizedState !== null && finishedWork.memoizedState.cachePool !== null) {\n                    nextCache = finishedWork.memoizedState.cachePool.pool;\n                } // Retain/release the cache used for pending (suspended) nodes.\n                // Note that this is only reached in the non-suspended/visible case:\n                // when the content is suspended/hidden, the retain/release occurs\n                // via the parent Suspense component (see case above).\n                if (nextCache !== previousCache) {\n                    if (nextCache != null) {\n                        retainCache(nextCache);\n                    }\n                    if (previousCache != null) {\n                        releaseCache(previousCache);\n                    }\n                }\n            }\n        }\n        function commitCachePassiveMountEffect(current, finishedWork) {\n            {\n                var previousCache = null;\n                if (finishedWork.alternate !== null) {\n                    previousCache = finishedWork.alternate.memoizedState.cache;\n                }\n                var nextCache = finishedWork.memoizedState.cache; // Retain/release the cache. In theory the cache component\n                // could be \"borrowing\" a cache instance owned by some parent,\n                // in which case we could avoid retaining/releasing. But it\n                // is non-trivial to determine when that is the case, so we\n                // always retain/release.\n                if (nextCache !== previousCache) {\n                    retainCache(nextCache);\n                    if (previousCache != null) {\n                        releaseCache(previousCache);\n                    }\n                }\n            }\n        }\n        function commitPassiveMountEffects(root, finishedWork, committedLanes, committedTransitions) {\n            setCurrentDebugFiberInDEV(finishedWork);\n            commitPassiveMountOnFiber(root, finishedWork, committedLanes, committedTransitions);\n            resetCurrentDebugFiberInDEV();\n        }\n        function recursivelyTraversePassiveMountEffects(root, parentFiber, committedLanes, committedTransitions) {\n            var prevDebugFiber = getCurrentFiber();\n            if (parentFiber.subtreeFlags & PassiveMask) {\n                var child = parentFiber.child;\n                while(child !== null){\n                    setCurrentDebugFiberInDEV(child);\n                    commitPassiveMountOnFiber(root, child, committedLanes, committedTransitions);\n                    child = child.sibling;\n                }\n            }\n            setCurrentDebugFiberInDEV(prevDebugFiber);\n        }\n        function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {\n            // When updating this function, also update reconnectPassiveEffects, which does\n            // most of the same things when an offscreen tree goes from hidden -> visible,\n            // or when toggling effects inside a hidden tree.\n            var flags = finishedWork.flags;\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                        if (flags & Passive$1) {\n                            commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);\n                        }\n                        break;\n                    }\n                case HostRoot:\n                    {\n                        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                        if (flags & Passive$1) {\n                            {\n                                var previousCache = null;\n                                if (finishedWork.alternate !== null) {\n                                    previousCache = finishedWork.alternate.memoizedState.cache;\n                                }\n                                var nextCache = finishedWork.memoizedState.cache; // Retain/release the root cache.\n                                // Note that on initial mount, previousCache and nextCache will be the same\n                                // and this retain won't occur. To counter this, we instead retain the HostRoot's\n                                // initial cache when creating the root itself (see createFiberRoot() in\n                                // ReactFiberRoot.js). Subsequent updates that change the cache are reflected\n                                // here, such that previous/next caches are retained correctly.\n                                if (nextCache !== previousCache) {\n                                    retainCache(nextCache);\n                                    if (previousCache != null) {\n                                        releaseCache(previousCache);\n                                    }\n                                }\n                            }\n                        }\n                        break;\n                    }\n                case LegacyHiddenComponent:\n                    {\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        // TODO: Pass `current` as argument to this function\n                        var _instance3 = finishedWork.stateNode;\n                        var nextState = finishedWork.memoizedState;\n                        var isHidden = nextState !== null;\n                        if (isHidden) {\n                            if (_instance3._visibility & OffscreenPassiveEffectsConnected) {\n                                // The effects are currently connected. Update them.\n                                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                            } else {\n                                {\n                                    // The effects are currently disconnected. Since the tree is hidden,\n                                    // don't connect them. This also applies to the initial render.\n                                    {\n                                        // \"Atomic\" effects are ones that need to fire on every commit,\n                                        // even during pre-rendering. An example is updating the reference\n                                        // count on cache instances.\n                                        recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n                                    }\n                                }\n                            }\n                        } else {\n                            // Tree is visible\n                            if (_instance3._visibility & OffscreenPassiveEffectsConnected) {\n                                // The effects are currently connected. Update them.\n                                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                            } else {\n                                // The effects are currently disconnected. Reconnect them, while also\n                                // firing effects inside newly mounted trees. This also applies to\n                                // the initial render.\n                                _instance3._visibility |= OffscreenPassiveEffectsConnected;\n                                var includeWorkInProgressEffects = (finishedWork.subtreeFlags & PassiveMask) !== NoFlags$1;\n                                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                            }\n                        }\n                        if (flags & Passive$1) {\n                            var _current = finishedWork.alternate;\n                            commitOffscreenPassiveMountEffects(_current, finishedWork);\n                        }\n                        break;\n                    }\n                case CacheComponent:\n                    {\n                        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                        if (flags & Passive$1) {\n                            // TODO: Pass `current` as argument to this function\n                            var _current2 = finishedWork.alternate;\n                            commitCachePassiveMountEffect(_current2, finishedWork);\n                        }\n                        break;\n                    }\n                case TracingMarkerComponent:\n                default:\n                    {\n                        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                        break;\n                    }\n            }\n        }\n        function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects) {\n            // This function visits both newly finished work and nodes that were re-used\n            // from a previously committed tree. We cannot check non-static flags if the\n            // node was reused.\n            var childShouldIncludeWorkInProgressEffects = includeWorkInProgressEffects && (parentFiber.subtreeFlags & PassiveMask) !== NoFlags$1; // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\n            var prevDebugFiber = getCurrentFiber();\n            var child = parentFiber.child;\n            while(child !== null){\n                reconnectPassiveEffects(finishedRoot, child, committedLanes, committedTransitions, childShouldIncludeWorkInProgressEffects);\n                child = child.sibling;\n            }\n            setCurrentDebugFiberInDEV(prevDebugFiber);\n        }\n        function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, // from a previously committed tree. We cannot check non-static flags if the\n        // node was reused.\n        includeWorkInProgressEffects) {\n            var flags = finishedWork.flags;\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects); // TODO: Check for PassiveStatic flag\n                        commitHookPassiveMountEffects(finishedWork, Passive);\n                        break;\n                    }\n                // Unlike commitPassiveMountOnFiber, we don't need to handle HostRoot\n                // because this function only visits nodes that are inside an\n                // Offscreen fiber.\n                // case HostRoot: {\n                //  ...\n                // }\n                case LegacyHiddenComponent:\n                    {\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        var _instance4 = finishedWork.stateNode;\n                        var nextState = finishedWork.memoizedState;\n                        var isHidden = nextState !== null;\n                        if (isHidden) {\n                            if (_instance4._visibility & OffscreenPassiveEffectsConnected) {\n                                // The effects are currently connected. Update them.\n                                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                            } else {\n                                {\n                                    // The effects are currently disconnected. Since the tree is hidden,\n                                    // don't connect them. This also applies to the initial render.\n                                    {\n                                        // \"Atomic\" effects are ones that need to fire on every commit,\n                                        // even during pre-rendering. An example is updating the reference\n                                        // count on cache instances.\n                                        recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n                                    }\n                                }\n                            }\n                        } else {\n                            // Tree is visible\n                            // Since we're already inside a reconnecting tree, it doesn't matter\n                            // whether the effects are currently connected. In either case, we'll\n                            // continue traversing the tree and firing all the effects.\n                            //\n                            // We do need to set the \"connected\" flag on the instance, though.\n                            _instance4._visibility |= OffscreenPassiveEffectsConnected;\n                            recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                        }\n                        if (includeWorkInProgressEffects && flags & Passive$1) {\n                            // TODO: Pass `current` as argument to this function\n                            var _current3 = finishedWork.alternate;\n                            commitOffscreenPassiveMountEffects(_current3, finishedWork);\n                        }\n                        break;\n                    }\n                case CacheComponent:\n                    {\n                        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                        if (includeWorkInProgressEffects && flags & Passive$1) {\n                            // TODO: Pass `current` as argument to this function\n                            var _current4 = finishedWork.alternate;\n                            commitCachePassiveMountEffect(_current4, finishedWork);\n                        }\n                        break;\n                    }\n                case TracingMarkerComponent:\n                default:\n                    {\n                        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                        break;\n                    }\n            }\n        }\n        function recursivelyTraverseAtomicPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions) {\n            // \"Atomic\" effects are ones that need to fire on every commit, even during\n            // pre-rendering. We call this function when traversing a hidden tree whose\n            // regular effects are currently disconnected.\n            var prevDebugFiber = getCurrentFiber(); // TODO: Add special flag for atomic effects\n            if (parentFiber.subtreeFlags & PassiveMask) {\n                var child = parentFiber.child;\n                while(child !== null){\n                    setCurrentDebugFiberInDEV(child);\n                    commitAtomicPassiveEffects(finishedRoot, child);\n                    child = child.sibling;\n                }\n            }\n            setCurrentDebugFiberInDEV(prevDebugFiber);\n        }\n        function commitAtomicPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) {\n            // \"Atomic\" effects are ones that need to fire on every commit, even during\n            // pre-rendering. We call this function when traversing a hidden tree whose\n            // regular effects are currently disconnected.\n            var flags = finishedWork.flags;\n            switch(finishedWork.tag){\n                case OffscreenComponent:\n                    {\n                        recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n                        if (flags & Passive$1) {\n                            // TODO: Pass `current` as argument to this function\n                            var current = finishedWork.alternate;\n                            commitOffscreenPassiveMountEffects(current, finishedWork);\n                        }\n                        break;\n                    }\n                case CacheComponent:\n                    {\n                        recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n                        if (flags & Passive$1) {\n                            // TODO: Pass `current` as argument to this function\n                            var _current5 = finishedWork.alternate;\n                            commitCachePassiveMountEffect(_current5, finishedWork);\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n                        break;\n                    }\n            }\n        }\n        function commitPassiveUnmountEffects(finishedWork) {\n            setCurrentDebugFiberInDEV(finishedWork);\n            commitPassiveUnmountOnFiber(finishedWork);\n            resetCurrentDebugFiberInDEV();\n        } // If we're inside a brand new tree, or a tree that was already visible, then we\n        // should only suspend host components that have a ShouldSuspendCommit flag.\n        // Components without it haven't changed since the last commit, so we can skip\n        // over those.\n        //\n        // When we enter a tree that is being revealed (going from hidden -> visible),\n        // we need to suspend _any_ component that _may_ suspend. Even if they're\n        // already in the \"current\" tree. Because their visibility has changed, the\n        // browser may not have prerendered them yet. So we check the MaySuspendCommit\n        // flag instead.\n        var suspenseyCommitFlag = ShouldSuspendCommit;\n        function accumulateSuspenseyCommit(finishedWork) {\n            accumulateSuspenseyCommitOnFiber(finishedWork);\n        }\n        function recursivelyAccumulateSuspenseyCommit(parentFiber) {\n            if (parentFiber.subtreeFlags & suspenseyCommitFlag) {\n                var child = parentFiber.child;\n                while(child !== null){\n                    accumulateSuspenseyCommitOnFiber(child);\n                    child = child.sibling;\n                }\n            }\n        }\n        function accumulateSuspenseyCommitOnFiber(fiber) {\n            switch(fiber.tag){\n                case HostHoistable:\n                    {\n                        recursivelyAccumulateSuspenseyCommit(fiber);\n                        if (fiber.flags & suspenseyCommitFlag) {\n                            if (fiber.memoizedState !== null) {\n                                suspendResource(currentHoistableRoot, fiber.memoizedState, fiber.memoizedProps);\n                            } else {\n                                var type = fiber.type;\n                                var props = fiber.memoizedProps;\n                                suspendInstance(type, props);\n                            }\n                        }\n                        break;\n                    }\n                case HostComponent:\n                    {\n                        recursivelyAccumulateSuspenseyCommit(fiber);\n                        if (fiber.flags & suspenseyCommitFlag) {\n                            var _type = fiber.type;\n                            var _props = fiber.memoizedProps;\n                            suspendInstance(_type, _props);\n                        }\n                        break;\n                    }\n                case HostRoot:\n                case HostPortal:\n                    {\n                        if (supportsResources) {\n                            var previousHoistableRoot = currentHoistableRoot;\n                            var container = fiber.stateNode.containerInfo;\n                            currentHoistableRoot = getHoistableRoot(container);\n                            recursivelyAccumulateSuspenseyCommit(fiber);\n                            currentHoistableRoot = previousHoistableRoot;\n                        } else {\n                            recursivelyAccumulateSuspenseyCommit(fiber);\n                        }\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        var isHidden = fiber.memoizedState !== null;\n                        if (isHidden) ;\n                        else {\n                            var current = fiber.alternate;\n                            var wasHidden = current !== null && current.memoizedState !== null;\n                            if (wasHidden) {\n                                // This tree is being revealed. Visit all newly visible suspensey\n                                // instances, even if they're in the current tree.\n                                var prevFlags = suspenseyCommitFlag;\n                                suspenseyCommitFlag = MaySuspendCommit;\n                                recursivelyAccumulateSuspenseyCommit(fiber);\n                                suspenseyCommitFlag = prevFlags;\n                            } else {\n                                recursivelyAccumulateSuspenseyCommit(fiber);\n                            }\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyAccumulateSuspenseyCommit(fiber);\n                    }\n            }\n        }\n        function detachAlternateSiblings(parentFiber) {\n            // A fiber was deleted from this parent fiber, but it's still part of the\n            // previous (alternate) parent fiber's list of children. Because children\n            // are a linked list, an earlier sibling that's still alive will be\n            // connected to the deleted fiber via its `alternate`:\n            //\n            //   live fiber --alternate--> previous live fiber --sibling--> deleted\n            //   fiber\n            //\n            // We can't disconnect `alternate` on nodes that haven't been deleted yet,\n            // but we can disconnect the `sibling` and `child` pointers.\n            var previousFiber = parentFiber.alternate;\n            if (previousFiber !== null) {\n                var detachedChild = previousFiber.child;\n                if (detachedChild !== null) {\n                    previousFiber.child = null;\n                    do {\n                        // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        var detachedSibling = detachedChild.sibling; // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        detachedChild.sibling = null;\n                        detachedChild = detachedSibling;\n                    }while (detachedChild !== null);\n                }\n            }\n        }\n        function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {\n            if (shouldProfile(finishedWork)) {\n                startPassiveEffectTimer();\n                commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);\n                recordPassiveEffectDuration(finishedWork);\n            } else {\n                commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);\n            }\n        }\n        function recursivelyTraversePassiveUnmountEffects(parentFiber) {\n            // Deletions effects can be scheduled on any fiber type. They need to happen\n            // before the children effects have fired.\n            var deletions = parentFiber.deletions;\n            if ((parentFiber.flags & ChildDeletion) !== NoFlags$1) {\n                if (deletions !== null) {\n                    for(var i = 0; i < deletions.length; i++){\n                        var childToDelete = deletions[i]; // TODO: Convert this to use recursion\n                        nextEffect = childToDelete;\n                        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);\n                    }\n                }\n                detachAlternateSiblings(parentFiber);\n            }\n            var prevDebugFiber = getCurrentFiber(); // TODO: Split PassiveMask into separate masks for mount and unmount?\n            if (parentFiber.subtreeFlags & PassiveMask) {\n                var child = parentFiber.child;\n                while(child !== null){\n                    setCurrentDebugFiberInDEV(child);\n                    commitPassiveUnmountOnFiber(child);\n                    child = child.sibling;\n                }\n            }\n            setCurrentDebugFiberInDEV(prevDebugFiber);\n        }\n        function commitPassiveUnmountOnFiber(finishedWork) {\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        recursivelyTraversePassiveUnmountEffects(finishedWork);\n                        if (finishedWork.flags & Passive$1) {\n                            commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive | HasEffect);\n                        }\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        var instance = finishedWork.stateNode;\n                        var nextState = finishedWork.memoizedState;\n                        var isHidden = nextState !== null;\n                        if (isHidden && instance._visibility & OffscreenPassiveEffectsConnected && // the future we may change this to unmount after a delay.\n                        (finishedWork.return === null || finishedWork.return.tag !== SuspenseComponent)) {\n                            // The effects are currently connected. Disconnect them.\n                            // TODO: Add option or heuristic to delay before disconnecting the\n                            // effects. Then if the tree reappears before the delay has elapsed, we\n                            // can skip toggling the effects entirely.\n                            instance._visibility &= ~OffscreenPassiveEffectsConnected;\n                            recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n                        } else {\n                            recursivelyTraversePassiveUnmountEffects(finishedWork);\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyTraversePassiveUnmountEffects(finishedWork);\n                        break;\n                    }\n            }\n        }\n        function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {\n            // Deletions effects can be scheduled on any fiber type. They need to happen\n            // before the children effects have fired.\n            var deletions = parentFiber.deletions;\n            if ((parentFiber.flags & ChildDeletion) !== NoFlags$1) {\n                if (deletions !== null) {\n                    for(var i = 0; i < deletions.length; i++){\n                        var childToDelete = deletions[i]; // TODO: Convert this to use recursion\n                        nextEffect = childToDelete;\n                        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);\n                    }\n                }\n                detachAlternateSiblings(parentFiber);\n            }\n            var prevDebugFiber = getCurrentFiber(); // TODO: Check PassiveStatic flag\n            var child = parentFiber.child;\n            while(child !== null){\n                setCurrentDebugFiberInDEV(child);\n                disconnectPassiveEffect(child);\n                child = child.sibling;\n            }\n            setCurrentDebugFiberInDEV(prevDebugFiber);\n        }\n        function disconnectPassiveEffect(finishedWork) {\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        // TODO: Check PassiveStatic flag\n                        commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive); // When disconnecting passive effects, we fire the effects in the same\n                        // order as during a deletiong: parent before child\n                        recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        var instance = finishedWork.stateNode;\n                        if (instance._visibility & OffscreenPassiveEffectsConnected) {\n                            instance._visibility &= ~OffscreenPassiveEffectsConnected;\n                            recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n                        break;\n                    }\n            }\n        }\n        function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {\n            while(nextEffect !== null){\n                var fiber = nextEffect; // Deletion effects fire in parent -> child order\n                // TODO: Check if fiber has a PassiveStatic flag\n                setCurrentDebugFiberInDEV(fiber);\n                commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);\n                resetCurrentDebugFiberInDEV();\n                var child = fiber.child; // TODO: Only traverse subtree if it has a PassiveStatic flag.\n                if (child !== null) {\n                    child.return = fiber;\n                    nextEffect = child;\n                } else {\n                    commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);\n                }\n            }\n        }\n        function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                var sibling = fiber.sibling;\n                var returnFiber = fiber.return; // Recursively traverse the entire deleted tree and clean up fiber fields.\n                // This is more aggressive than ideal, and the long term goal is to only\n                // have to detach the deleted tree at the root.\n                detachFiberAfterEffects(fiber);\n                if (fiber === deletedSubtreeRoot) {\n                    nextEffect = null;\n                    return;\n                }\n                if (sibling !== null) {\n                    sibling.return = returnFiber;\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = returnFiber;\n            }\n        }\n        function commitPassiveUnmountInsideDeletedTreeOnFiber(current, nearestMountedAncestor) {\n            switch(current.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        commitHookPassiveUnmountEffects(current, nearestMountedAncestor, Passive);\n                        break;\n                    }\n                // TODO: run passive unmount effects when unmounting a root.\n                // Because passive unmount effects are not currently run,\n                // the cache instance owned by the root will never be freed.\n                // When effects are run, the cache should be freed here:\n                // case HostRoot: {\n                //   if (enableCache) {\n                //     const cache = current.memoizedState.cache;\n                //     releaseCache(cache);\n                //   }\n                //   break;\n                // }\n                case LegacyHiddenComponent:\n                case OffscreenComponent:\n                    {\n                        {\n                            if (current.memoizedState !== null && current.memoizedState.cachePool !== null) {\n                                var cache = current.memoizedState.cachePool.pool; // Retain/release the cache used for pending (suspended) nodes.\n                                // Note that this is only reached in the non-suspended/visible case:\n                                // when the content is suspended/hidden, the retain/release occurs\n                                // via the parent Suspense component (see case above).\n                                if (cache != null) {\n                                    retainCache(cache);\n                                }\n                            }\n                        }\n                        break;\n                    }\n                case SuspenseComponent:\n                    {\n                        break;\n                    }\n                case CacheComponent:\n                    {\n                        {\n                            var _cache = current.memoizedState.cache;\n                            releaseCache(_cache);\n                        }\n                        break;\n                    }\n            }\n        }\n        function getCacheForType(resourceType) {\n            var cache = readContext(CacheContext);\n            var cacheForType = cache.data.get(resourceType);\n            if (cacheForType === undefined) {\n                cacheForType = resourceType();\n                cache.data.set(resourceType, cacheForType);\n            }\n            return cacheForType;\n        }\n        var DefaultAsyncDispatcher = {\n            getCacheForType: getCacheForType\n        };\n        {\n            DefaultAsyncDispatcher.getOwner = function() {\n                return current;\n            };\n        }\n        var COMPONENT_TYPE = 0;\n        var HAS_PSEUDO_CLASS_TYPE = 1;\n        var ROLE_TYPE = 2;\n        var TEST_NAME_TYPE = 3;\n        var TEXT_TYPE = 4;\n        if (typeof Symbol === 'function' && Symbol.for) {\n            var symbolFor = Symbol.for;\n            COMPONENT_TYPE = symbolFor('selector.component');\n            HAS_PSEUDO_CLASS_TYPE = symbolFor('selector.has_pseudo_class');\n            ROLE_TYPE = symbolFor('selector.role');\n            TEST_NAME_TYPE = symbolFor('selector.test_id');\n            TEXT_TYPE = symbolFor('selector.text');\n        }\n        function createComponentSelector(component) {\n            return {\n                $$typeof: COMPONENT_TYPE,\n                value: component\n            };\n        }\n        function createHasPseudoClassSelector(selectors) {\n            return {\n                $$typeof: HAS_PSEUDO_CLASS_TYPE,\n                value: selectors\n            };\n        }\n        function createRoleSelector(role) {\n            return {\n                $$typeof: ROLE_TYPE,\n                value: role\n            };\n        }\n        function createTextSelector(text) {\n            return {\n                $$typeof: TEXT_TYPE,\n                value: text\n            };\n        }\n        function createTestNameSelector(id) {\n            return {\n                $$typeof: TEST_NAME_TYPE,\n                value: id\n            };\n        }\n        function findFiberRootForHostRoot(hostRoot) {\n            var maybeFiber = getInstanceFromNode(hostRoot);\n            if (maybeFiber != null) {\n                if (typeof maybeFiber.memoizedProps['data-testname'] !== 'string') {\n                    throw new Error('Invalid host root specified. Should be either a React container or a node with a testname attribute.');\n                }\n                return maybeFiber;\n            } else {\n                var fiberRoot = findFiberRoot(hostRoot);\n                if (fiberRoot === null) {\n                    throw new Error('Could not find React container within specified host subtree.');\n                } // The Flow type for FiberRoot is a little funky.\n                // createFiberRoot() cheats this by treating the root as :any and adding stateNode lazily.\n                return fiberRoot.stateNode.current;\n            }\n        }\n        function matchSelector(fiber, selector) {\n            var tag = fiber.tag;\n            switch(selector.$$typeof){\n                case COMPONENT_TYPE:\n                    if (fiber.type === selector.value) {\n                        return true;\n                    }\n                    break;\n                case HAS_PSEUDO_CLASS_TYPE:\n                    return hasMatchingPaths(fiber, selector.value);\n                case ROLE_TYPE:\n                    if (tag === HostComponent || tag === HostHoistable || tag === HostSingleton) {\n                        var node = fiber.stateNode;\n                        if (matchAccessibilityRole(node, selector.value)) {\n                            return true;\n                        }\n                    }\n                    break;\n                case TEXT_TYPE:\n                    if (tag === HostComponent || tag === HostText || tag === HostHoistable || tag === HostSingleton) {\n                        var textContent = getTextContent(fiber);\n                        if (textContent !== null && textContent.indexOf(selector.value) >= 0) {\n                            return true;\n                        }\n                    }\n                    break;\n                case TEST_NAME_TYPE:\n                    if (tag === HostComponent || tag === HostHoistable || tag === HostSingleton) {\n                        var dataTestID = fiber.memoizedProps['data-testname'];\n                        if (typeof dataTestID === 'string' && dataTestID.toLowerCase() === selector.value.toLowerCase()) {\n                            return true;\n                        }\n                    }\n                    break;\n                default:\n                    throw new Error('Invalid selector type specified.');\n            }\n            return false;\n        }\n        function selectorToString(selector) {\n            switch(selector.$$typeof){\n                case COMPONENT_TYPE:\n                    var displayName = getComponentNameFromType(selector.value) || 'Unknown';\n                    return \"<\" + displayName + \">\";\n                case HAS_PSEUDO_CLASS_TYPE:\n                    return \":has(\" + (selectorToString(selector) || '') + \")\";\n                case ROLE_TYPE:\n                    return \"[role=\\\"\" + selector.value + \"\\\"]\";\n                case TEXT_TYPE:\n                    return \"\\\"\" + selector.value + \"\\\"\";\n                case TEST_NAME_TYPE:\n                    return \"[data-testname=\\\"\" + selector.value + \"\\\"]\";\n                default:\n                    throw new Error('Invalid selector type specified.');\n            }\n        }\n        function findPaths(root, selectors) {\n            var matchingFibers = [];\n            var stack = [\n                root,\n                0\n            ];\n            var index = 0;\n            while(index < stack.length){\n                var fiber = stack[index++];\n                var tag = fiber.tag;\n                var selectorIndex = stack[index++];\n                var selector = selectors[selectorIndex];\n                if ((tag === HostComponent || tag === HostHoistable || tag === HostSingleton) && isHiddenSubtree(fiber)) {\n                    continue;\n                } else {\n                    while(selector != null && matchSelector(fiber, selector)){\n                        selectorIndex++;\n                        selector = selectors[selectorIndex];\n                    }\n                }\n                if (selectorIndex === selectors.length) {\n                    matchingFibers.push(fiber);\n                } else {\n                    var child = fiber.child;\n                    while(child !== null){\n                        stack.push(child, selectorIndex);\n                        child = child.sibling;\n                    }\n                }\n            }\n            return matchingFibers;\n        } // Same as findPaths but with eager bailout on first match\n        function hasMatchingPaths(root, selectors) {\n            var stack = [\n                root,\n                0\n            ];\n            var index = 0;\n            while(index < stack.length){\n                var fiber = stack[index++];\n                var tag = fiber.tag;\n                var selectorIndex = stack[index++];\n                var selector = selectors[selectorIndex];\n                if ((tag === HostComponent || tag === HostHoistable || tag === HostSingleton) && isHiddenSubtree(fiber)) {\n                    continue;\n                } else {\n                    while(selector != null && matchSelector(fiber, selector)){\n                        selectorIndex++;\n                        selector = selectors[selectorIndex];\n                    }\n                }\n                if (selectorIndex === selectors.length) {\n                    return true;\n                } else {\n                    var child = fiber.child;\n                    while(child !== null){\n                        stack.push(child, selectorIndex);\n                        child = child.sibling;\n                    }\n                }\n            }\n            return false;\n        }\n        function findAllNodes(hostRoot, selectors) {\n            if (!supportsTestSelectors) {\n                throw new Error('Test selector API is not supported by this renderer.');\n            }\n            var root = findFiberRootForHostRoot(hostRoot);\n            var matchingFibers = findPaths(root, selectors);\n            var instanceRoots = [];\n            var stack = Array.from(matchingFibers);\n            var index = 0;\n            while(index < stack.length){\n                var node = stack[index++];\n                var tag = node.tag;\n                if (tag === HostComponent || tag === HostHoistable || tag === HostSingleton) {\n                    if (isHiddenSubtree(node)) {\n                        continue;\n                    }\n                    instanceRoots.push(node.stateNode);\n                } else {\n                    var child = node.child;\n                    while(child !== null){\n                        stack.push(child);\n                        child = child.sibling;\n                    }\n                }\n            }\n            return instanceRoots;\n        }\n        function getFindAllNodesFailureDescription(hostRoot, selectors) {\n            if (!supportsTestSelectors) {\n                throw new Error('Test selector API is not supported by this renderer.');\n            }\n            var root = findFiberRootForHostRoot(hostRoot);\n            var maxSelectorIndex = 0;\n            var matchedNames = []; // The logic of this loop should be kept in sync with findPaths()\n            var stack = [\n                root,\n                0\n            ];\n            var index = 0;\n            while(index < stack.length){\n                var fiber = stack[index++];\n                var tag = fiber.tag;\n                var selectorIndex = stack[index++];\n                var selector = selectors[selectorIndex];\n                if ((tag === HostComponent || tag === HostHoistable || tag === HostSingleton) && isHiddenSubtree(fiber)) {\n                    continue;\n                } else if (matchSelector(fiber, selector)) {\n                    matchedNames.push(selectorToString(selector));\n                    selectorIndex++;\n                    if (selectorIndex > maxSelectorIndex) {\n                        maxSelectorIndex = selectorIndex;\n                    }\n                }\n                if (selectorIndex < selectors.length) {\n                    var child = fiber.child;\n                    while(child !== null){\n                        stack.push(child, selectorIndex);\n                        child = child.sibling;\n                    }\n                }\n            }\n            if (maxSelectorIndex < selectors.length) {\n                var unmatchedNames = [];\n                for(var i = maxSelectorIndex; i < selectors.length; i++){\n                    unmatchedNames.push(selectorToString(selectors[i]));\n                }\n                return 'findAllNodes was able to match part of the selector:\\n' + (\"  \" + matchedNames.join(' > ') + \"\\n\\n\") + 'No matching component was found for:\\n' + (\"  \" + unmatchedNames.join(' > '));\n            }\n            return null;\n        }\n        function findBoundingRects(hostRoot, selectors) {\n            if (!supportsTestSelectors) {\n                throw new Error('Test selector API is not supported by this renderer.');\n            }\n            var instanceRoots = findAllNodes(hostRoot, selectors);\n            var boundingRects = [];\n            for(var i = 0; i < instanceRoots.length; i++){\n                boundingRects.push(getBoundingRect(instanceRoots[i]));\n            }\n            for(var _i = boundingRects.length - 1; _i > 0; _i--){\n                var targetRect = boundingRects[_i];\n                var targetLeft = targetRect.x;\n                var targetRight = targetLeft + targetRect.width;\n                var targetTop = targetRect.y;\n                var targetBottom = targetTop + targetRect.height;\n                for(var j = _i - 1; j >= 0; j--){\n                    if (_i !== j) {\n                        var otherRect = boundingRects[j];\n                        var otherLeft = otherRect.x;\n                        var otherRight = otherLeft + otherRect.width;\n                        var otherTop = otherRect.y;\n                        var otherBottom = otherTop + otherRect.height; // Merging all rects to the minimums set would be complicated,\n                        // but we can handle the most common cases:\n                        // 1. completely overlapping rects\n                        // 2. adjacent rects that are the same width or height (e.g. items in a list)\n                        //\n                        // Even given the above constraints,\n                        // we still won't end up with the fewest possible rects without doing multiple passes,\n                        // but it's good enough for this purpose.\n                        if (targetLeft >= otherLeft && targetTop >= otherTop && targetRight <= otherRight && targetBottom <= otherBottom) {\n                            // Complete overlapping rects; remove the inner one.\n                            boundingRects.splice(_i, 1);\n                            break;\n                        } else if (targetLeft === otherLeft && targetRect.width === otherRect.width && !(otherBottom < targetTop) && !(otherTop > targetBottom)) {\n                            // Adjacent vertical rects; merge them.\n                            if (otherTop > targetTop) {\n                                otherRect.height += otherTop - targetTop;\n                                otherRect.y = targetTop;\n                            }\n                            if (otherBottom < targetBottom) {\n                                otherRect.height = targetBottom - otherTop;\n                            }\n                            boundingRects.splice(_i, 1);\n                            break;\n                        } else if (targetTop === otherTop && targetRect.height === otherRect.height && !(otherRight < targetLeft) && !(otherLeft > targetRight)) {\n                            // Adjacent horizontal rects; merge them.\n                            if (otherLeft > targetLeft) {\n                                otherRect.width += otherLeft - targetLeft;\n                                otherRect.x = targetLeft;\n                            }\n                            if (otherRight < targetRight) {\n                                otherRect.width = targetRight - otherLeft;\n                            }\n                            boundingRects.splice(_i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n            return boundingRects;\n        }\n        function focusWithin(hostRoot, selectors) {\n            if (!supportsTestSelectors) {\n                throw new Error('Test selector API is not supported by this renderer.');\n            }\n            var root = findFiberRootForHostRoot(hostRoot);\n            var matchingFibers = findPaths(root, selectors);\n            var stack = Array.from(matchingFibers);\n            var index = 0;\n            while(index < stack.length){\n                var fiber = stack[index++];\n                var tag = fiber.tag;\n                if (isHiddenSubtree(fiber)) {\n                    continue;\n                }\n                if (tag === HostComponent || tag === HostHoistable || tag === HostSingleton) {\n                    var node = fiber.stateNode;\n                    if (setFocusIfFocusable(node)) {\n                        return true;\n                    }\n                }\n                var child = fiber.child;\n                while(child !== null){\n                    stack.push(child);\n                    child = child.sibling;\n                }\n            }\n            return false;\n        }\n        var commitHooks = [];\n        function onCommitRoot() {\n            if (supportsTestSelectors) {\n                commitHooks.forEach(function(commitHook) {\n                    return commitHook();\n                });\n            }\n        }\n        function observeVisibleRects(hostRoot, selectors, callback, options) {\n            if (!supportsTestSelectors) {\n                throw new Error('Test selector API is not supported by this renderer.');\n            }\n            var instanceRoots = findAllNodes(hostRoot, selectors);\n            var _setupIntersectionObs = setupIntersectionObserver(instanceRoots, callback, options), disconnect = _setupIntersectionObs.disconnect, observe = _setupIntersectionObs.observe, unobserve = _setupIntersectionObs.unobserve; // When React mutates the host environment, we may need to change what we're listening to.\n            var commitHook = function() {\n                var nextInstanceRoots = findAllNodes(hostRoot, selectors);\n                instanceRoots.forEach(function(target) {\n                    if (nextInstanceRoots.indexOf(target) < 0) {\n                        unobserve(target);\n                    }\n                });\n                nextInstanceRoots.forEach(function(target) {\n                    if (instanceRoots.indexOf(target) < 0) {\n                        observe(target);\n                    }\n                });\n            };\n            commitHooks.push(commitHook);\n            return {\n                disconnect: function() {\n                    // Stop listening for React mutations:\n                    var index = commitHooks.indexOf(commitHook);\n                    if (index >= 0) {\n                        commitHooks.splice(index, 1);\n                    } // Disconnect the host observer:\n                    disconnect();\n                }\n            };\n        }\n        function isConcurrentActEnvironment() {\n            {\n                var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== 'undefined' ? IS_REACT_ACT_ENVIRONMENT : undefined;\n                if (!isReactActEnvironmentGlobal && ReactSharedInternals.actQueue !== null) {\n                    // TODO: Include link to relevant documentation page.\n                    error('The current testing environment is not configured to support ' + 'act(...)');\n                }\n                return isReactActEnvironmentGlobal;\n            }\n        }\n        var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n        var NoContext = /*             */ 0;\n        var BatchedContext = /*               */ 1;\n        var RenderContext = /*         */ 2;\n        var CommitContext = /*         */ 4;\n        var RootInProgress = 0;\n        var RootFatalErrored = 1;\n        var RootErrored = 2;\n        var RootSuspended = 3;\n        var RootSuspendedWithDelay = 4;\n        var RootCompleted = 5;\n        var RootDidNotComplete = 6; // Describes where we are in the React execution stack\n        var executionContext = NoContext; // The root we're working on\n        var workInProgressRoot = null; // The fiber we're working on\n        var workInProgress = null; // The lanes we're rendering\n        var workInProgressRootRenderLanes = NoLanes;\n        var NotSuspended = 0;\n        var SuspendedOnError = 1;\n        var SuspendedOnData = 2;\n        var SuspendedOnImmediate = 3;\n        var SuspendedOnInstance = 4;\n        var SuspendedOnInstanceAndReadyToContinue = 5;\n        var SuspendedOnDeprecatedThrowPromise = 6;\n        var SuspendedAndReadyToContinue = 7;\n        var SuspendedOnHydration = 8; // When this is true, the work-in-progress fiber just suspended (or errored) and\n        // we've yet to unwind the stack. In some cases, we may yield to the main thread\n        // after this happens. If the fiber is pinged before we resume, we can retry\n        // immediately instead of unwinding the stack.\n        var workInProgressSuspendedReason = NotSuspended;\n        var workInProgressThrownValue = null; // Whether a ping listener was attached during this render. This is slightly\n        // different that whether something suspended, because we don't add multiple\n        // listeners to a promise we've already seen (per root and lane).\n        var workInProgressRootDidAttachPingListener = false; // A contextual version of workInProgressRootRenderLanes. It is a superset of\n        // the lanes that we started working on at the root. When we enter a subtree\n        // that is currently hidden, we add the lanes that would have committed if\n        // the hidden tree hadn't been deferred. This is modified by the\n        // HiddenContext module.\n        //\n        // Most things in the work loop should deal with workInProgressRootRenderLanes.\n        // Most things in begin/complete phases should deal with entangledRenderLanes.\n        var entangledRenderLanes = NoLanes; // Whether to root completed, errored, suspended, etc.\n        var workInProgressRootExitStatus = RootInProgress; // The work left over by components that were visited during this render. Only\n        // includes unprocessed updates, not work in bailed out children.\n        var workInProgressRootSkippedLanes = NoLanes; // Lanes that were updated (in an interleaved event) during this render.\n        var workInProgressRootInterleavedUpdatedLanes = NoLanes; // Lanes that were updated during the render phase (*not* an interleaved event).\n        var workInProgressRootPingedLanes = NoLanes; // If this lane scheduled deferred work, this is the lane of the deferred task.\n        var workInProgressDeferredLane = NoLane; // Errors that are thrown during the render phase.\n        var workInProgressRootConcurrentErrors = null; // These are errors that we recovered from without surfacing them to the UI.\n        // We will log them once the tree commits.\n        var workInProgressRootRecoverableErrors = null; // Tracks when an update occurs during the render phase.\n        var workInProgressRootDidIncludeRecursiveRenderUpdate = false; // Thacks when an update occurs during the commit phase. It's a separate\n        // variable from the one for renders because the commit phase may run\n        // concurrently to a render phase.\n        var didIncludeCommitPhaseUpdate = false; // The most recent time we either committed a fallback, or when a fallback was\n        // filled in with the resolved UI. This lets us throttle the appearance of new\n        // content as it streams in, to minimize jank.\n        // TODO: Think of a better name for this variable?\n        var globalMostRecentFallbackTime = 0;\n        var FALLBACK_THROTTLE_MS = 300; // The absolute time for when we should start giving up on rendering\n        // more and prefer CPU suspense heuristics instead.\n        var workInProgressRootRenderTargetTime = Infinity; // How long a render is supposed to take before we start following CPU\n        // suspense heuristics and opt out of rendering more content.\n        var RENDER_TIMEOUT_MS = 500;\n        var workInProgressTransitions = null;\n        function resetRenderTimer() {\n            workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;\n        }\n        function getRenderTargetTime() {\n            return workInProgressRootRenderTargetTime;\n        }\n        var legacyErrorBoundariesThatAlreadyFailed = null;\n        var rootDoesHavePassiveEffects = false;\n        var rootWithPendingPassiveEffects = null;\n        var pendingPassiveEffectsLanes = NoLanes;\n        var pendingPassiveProfilerEffects = [];\n        var pendingPassiveEffectsRemainingLanes = NoLanes;\n        var pendingPassiveTransitions = null; // Use these to prevent an infinite loop of nested updates\n        var NESTED_UPDATE_LIMIT = 50;\n        var nestedUpdateCount = 0;\n        var rootWithNestedUpdates = null;\n        var isFlushingPassiveEffects = false;\n        var didScheduleUpdateDuringPassiveEffects = false;\n        var NESTED_PASSIVE_UPDATE_LIMIT = 50;\n        var nestedPassiveUpdateCount = 0;\n        var rootWithPassiveNestedUpdates = null;\n        var isRunningInsertionEffect = false;\n        function getWorkInProgressRoot() {\n            return workInProgressRoot;\n        }\n        function getWorkInProgressRootRenderLanes() {\n            return workInProgressRootRenderLanes;\n        }\n        function isWorkLoopSuspendedOnData() {\n            return workInProgressSuspendedReason === SuspendedOnData;\n        }\n        function requestUpdateLane(fiber) {\n            if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {\n                // This is a render phase update. These are not officially supported. The\n                // old behavior is to give this the same \"thread\" (lanes) as\n                // whatever is currently rendering. So if you call `setState` on a component\n                // that happens later in the same render, it will flush. Ideally, we want to\n                // remove the special case and treat them as if they came from an\n                // interleaved event. Regardless, this pattern is not officially supported.\n                // This behavior is only a fallback. The flag only exists until we can roll\n                // out the setState warning, since existing code might accidentally rely on\n                // the current behavior.\n                return pickArbitraryLane(workInProgressRootRenderLanes);\n            }\n            var transition = requestCurrentTransition();\n            if (transition !== null) {\n                {\n                    if (!transition._updatedFibers) {\n                        transition._updatedFibers = new Set();\n                    }\n                    transition._updatedFibers.add(fiber);\n                }\n                var actionScopeLane = peekEntangledActionLane();\n                return actionScopeLane !== NoLane ? actionScopeLane : // is the first update in that scope. Either way, we need to get a\n                // fresh transition lane.\n                requestTransitionLane();\n            }\n            return eventPriorityToLane(resolveUpdatePriority());\n        }\n        function requestRetryLane(fiber) {\n            return claimNextRetryLane();\n        }\n        function requestDeferredLane() {\n            if (workInProgressDeferredLane === NoLane) {\n                // If there are multiple useDeferredValue hooks in the same render, the\n                // tasks that they spawn should all be batched together, so they should all\n                // receive the same lane.\n                // Check the priority of the current render to decide the priority of the\n                // deferred task.\n                // OffscreenLane is used for prerendering, but we also use OffscreenLane\n                // for incremental hydration. It's given the lowest priority because the\n                // initial HTML is the same as the final UI. But useDeferredValue during\n                // hydration is an exception — we need to upgrade the UI to the final\n                // value. So if we're currently hydrating, we treat it like a transition.\n                var isPrerendering = includesSomeLane(workInProgressRootRenderLanes, OffscreenLane) && !getIsHydrating();\n                if (isPrerendering) {\n                    // There's only one OffscreenLane, so if it contains deferred work, we\n                    // should just reschedule using the same lane.\n                    workInProgressDeferredLane = OffscreenLane;\n                } else {\n                    // Everything else is spawned as a transition.\n                    workInProgressDeferredLane = claimNextTransitionLane();\n                }\n            } // Mark the parent Suspense boundary so it knows to spawn the deferred lane.\n            var suspenseHandler = getSuspenseHandler();\n            if (suspenseHandler !== null) {\n                // TODO: As an optimization, we shouldn't entangle the lanes at the root; we\n                // can entangle them using the baseLanes of the Suspense boundary instead.\n                // We only need to do something special if there's no Suspense boundary.\n                suspenseHandler.flags |= DidDefer;\n            }\n            return workInProgressDeferredLane;\n        }\n        function peekDeferredLane() {\n            return workInProgressDeferredLane;\n        }\n        function scheduleUpdateOnFiber(root, fiber, lane) {\n            {\n                if (isRunningInsertionEffect) {\n                    error('useInsertionEffect must not schedule updates.');\n                }\n            }\n            {\n                if (isFlushingPassiveEffects) {\n                    didScheduleUpdateDuringPassiveEffects = true;\n                }\n            }\n            // finish loading.\n            if (root === workInProgressRoot && workInProgressSuspendedReason === SuspendedOnData || // Suspended commit phase\n            root.cancelPendingCommit !== null) {\n                // The incoming update might unblock the current render. Interrupt the\n                // current attempt and restart from the top.\n                prepareFreshStack(root, NoLanes);\n                markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane);\n            } // Mark that the root has a pending update.\n            markRootUpdated(root, lane);\n            if ((executionContext & RenderContext) !== NoLanes && root === workInProgressRoot) {\n                // This update was dispatched during the render phase. This is a mistake\n                // if the update originates from user space (with the exception of local\n                // hook updates, which are handled differently and don't reach this\n                // function), but there are some internal React features that use this as\n                // an implementation detail, like selective hydration.\n                warnAboutRenderPhaseUpdatesInDEV(fiber); // Track lanes that were updated during the render phase\n            } else {\n                // This is a normal update, scheduled from outside the render phase. For\n                // example, during an input event.\n                {\n                    if (isDevToolsPresent) {\n                        addFiberToLanesMap(root, fiber, lane);\n                    }\n                }\n                warnIfUpdatesNotWrappedWithActDEV(fiber);\n                if (root === workInProgressRoot) {\n                    // Received an update to a tree that's in the middle of rendering. Mark\n                    // that there was an interleaved update work on this root.\n                    if ((executionContext & RenderContext) === NoContext) {\n                        workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);\n                    }\n                    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n                        // The root already suspended with a delay, which means this render\n                        // definitely won't finish. Since we have a new update, let's mark it as\n                        // suspended now, right before marking the incoming update. This has the\n                        // effect of interrupting the current render and switching to the update.\n                        // TODO: Make sure this doesn't override pings that happen while we've\n                        // already started rendering.\n                        markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane);\n                    }\n                }\n                ensureRootIsScheduled(root);\n                if (lane === SyncLane && executionContext === NoContext && !disableLegacyMode && (fiber.mode & ConcurrentMode) === NoMode) {\n                    if (ReactSharedInternals.isBatchingLegacy) ;\n                    else {\n                        // Flush the synchronous work now, unless we're already working or inside\n                        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n                        // scheduleCallbackForFiber to preserve the ability to schedule a callback\n                        // without immediately flushing it. We only do this for user-initiated\n                        // updates, to preserve historical behavior of legacy mode.\n                        resetRenderTimer();\n                    }\n                }\n            }\n        }\n        function scheduleInitialHydrationOnRoot(root, lane) {\n            // This is a special fork of scheduleUpdateOnFiber that is only used to\n            // schedule the initial hydration of a root that has just been created. Most\n            // of the stuff in scheduleUpdateOnFiber can be skipped.\n            //\n            // The main reason for this separate path, though, is to distinguish the\n            // initial children from subsequent updates. In fully client-rendered roots\n            // (createRoot instead of hydrateRoot), all top-level renders are modeled as\n            // updates, but hydration roots are special because the initial render must\n            // match what was rendered on the server.\n            var current = root.current;\n            current.lanes = lane;\n            markRootUpdated(root, lane);\n            ensureRootIsScheduled(root);\n        }\n        function isUnsafeClassRenderPhaseUpdate(fiber) {\n            // Check if this is a render phase update. Only called by class components,\n            // which special (deprecated) behavior for UNSAFE_componentWillReceive props.\n            return (executionContext & RenderContext) !== NoContext;\n        } // This is the entry point for every concurrent task, i.e. anything that\n        // goes through Scheduler.\n        function performConcurrentWorkOnRoot(root, didTimeout) {\n            {\n                resetNestedUpdateFlag();\n            }\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                throw new Error('Should not already be working.');\n            } // Flush any pending passive effects before deciding which lanes to work on,\n            // in case they schedule additional work.\n            var originalCallbackNode = root.callbackNode;\n            var didFlushPassiveEffects = flushPassiveEffects();\n            if (didFlushPassiveEffects) {\n                // Something in the passive effect phase may have canceled the current task.\n                // Check if the task node for this root was changed.\n                if (root.callbackNode !== originalCallbackNode) {\n                    // The current task was canceled. Exit. We don't need to call\n                    // `ensureRootIsScheduled` because the check above implies either that\n                    // there's a new task, or that there's no remaining work on this root.\n                    return null;\n                }\n            } // Determine the next lanes to work on, using the fields stored\n            // on the root.\n            // TODO: This was already computed in the caller. Pass it as an argument.\n            var lanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n            if (lanes === NoLanes) {\n                // Defensive coding. This is never expected to happen.\n                return null;\n            } // We disable time-slicing in some cases: if the work has been CPU-bound\n            // for too long (\"expired\" work, to prevent starvation), or we're in\n            // sync-updates-by-default mode.\n            // TODO: We only check `didTimeout` defensively, to account for a Scheduler\n            // bug we're still investigating. Once the bug in Scheduler is fixed,\n            // we can remove this, since we track expiration ourselves.\n            var shouldTimeSlice = !includesBlockingLane(root, lanes) && !includesExpiredLane(root, lanes) && !didTimeout;\n            var exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);\n            if (exitStatus !== RootInProgress) {\n                var renderWasConcurrent = shouldTimeSlice;\n                do {\n                    if (exitStatus === RootDidNotComplete) {\n                        // The render unwound without completing the tree. This happens in special\n                        // cases where need to exit the current render without producing a\n                        // consistent tree or committing.\n                        markRootSuspended(root, lanes, NoLane);\n                    } else {\n                        // The render completed.\n                        // Check if this render may have yielded to a concurrent event, and if so,\n                        // confirm that any newly rendered stores are consistent.\n                        // TODO: It's possible that even a concurrent render may never have yielded\n                        // to the main thread, if it was fast enough, or if it expired. We could\n                        // skip the consistency check in that case, too.\n                        var finishedWork = root.current.alternate;\n                        if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {\n                            // A store was mutated in an interleaved event. Render again,\n                            // synchronously, to block further mutations.\n                            exitStatus = renderRootSync(root, lanes); // We assume the tree is now consistent because we didn't yield to any\n                            // concurrent events.\n                            renderWasConcurrent = false; // Need to check the exit status again.\n                            continue;\n                        } // Check if something threw\n                        if (exitStatus === RootErrored) {\n                            var lanesThatJustErrored = lanes;\n                            var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root, lanesThatJustErrored);\n                            if (errorRetryLanes !== NoLanes) {\n                                lanes = errorRetryLanes;\n                                exitStatus = recoverFromConcurrentError(root, lanesThatJustErrored, errorRetryLanes);\n                                renderWasConcurrent = false; // Need to check the exit status again.\n                                if (exitStatus !== RootErrored) {\n                                    continue;\n                                }\n                            }\n                        }\n                        if (exitStatus === RootFatalErrored) {\n                            prepareFreshStack(root, NoLanes);\n                            markRootSuspended(root, lanes, NoLane);\n                            break;\n                        } // We now have a consistent tree. The next step is either to commit it,\n                        // or, if something suspended, wait to commit it after a timeout.\n                        root.finishedWork = finishedWork;\n                        root.finishedLanes = lanes;\n                        finishConcurrentRender(root, exitStatus, finishedWork, lanes);\n                    }\n                    break;\n                }while (true);\n            }\n            ensureRootIsScheduled(root);\n            return getContinuationForRoot(root, originalCallbackNode);\n        }\n        function recoverFromConcurrentError(root, originallyAttemptedLanes, errorRetryLanes) {\n            // If an error occurred during hydration, discard server response and fall\n            // back to client side render.\n            // Before rendering again, save the errors from the previous attempt.\n            var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;\n            var wasRootDehydrated = supportsHydration && isRootDehydrated(root);\n            if (wasRootDehydrated) {\n                // The shell failed to hydrate. Set a flag to force a client rendering\n                // during the next attempt. To do this, we call prepareFreshStack now\n                // to create the root work-in-progress fiber. This is a bit weird in terms\n                // of factoring, because it relies on renderRootSync not calling\n                // prepareFreshStack again in the call below, which happens because the\n                // root and lanes haven't changed.\n                //\n                // TODO: I think what we should do is set ForceClientRender inside\n                // throwException, like we do for nested Suspense boundaries. The reason\n                // it's here instead is so we can switch to the synchronous work loop, too.\n                // Something to consider for a future refactor.\n                var rootWorkInProgress = prepareFreshStack(root, errorRetryLanes);\n                rootWorkInProgress.flags |= ForceClientRender;\n            }\n            var exitStatus = renderRootSync(root, errorRetryLanes);\n            if (exitStatus !== RootErrored) {\n                // Successfully finished rendering on retry\n                if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {\n                    // During the synchronous render, we attached additional ping listeners.\n                    // This is highly suggestive of an uncached promise (though it's not the\n                    // only reason this would happen). If it was an uncached promise, then\n                    // it may have masked a downstream error from ocurring without actually\n                    // fixing it. Example:\n                    //\n                    //    use(Promise.resolve('uncached'))\n                    //    throw new Error('Oops!')\n                    //\n                    // When this happens, there's a conflict between blocking potential\n                    // concurrent data races and unwrapping uncached promise values. We\n                    // have to choose one or the other. Because the data race recovery is\n                    // a last ditch effort, we'll disable it.\n                    root.errorRecoveryDisabledLanes = mergeLanes(root.errorRecoveryDisabledLanes, originallyAttemptedLanes); // Mark the current render as suspended and force it to restart. Once\n                    // these lanes finish successfully, we'll re-enable the error recovery\n                    // mechanism for subsequent updates.\n                    workInProgressRootInterleavedUpdatedLanes |= originallyAttemptedLanes;\n                    return RootSuspendedWithDelay;\n                } // The errors from the failed first attempt have been recovered. Add\n                // them to the collection of recoverable errors. We'll log them in the\n                // commit phase.\n                var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;\n                workInProgressRootRecoverableErrors = errorsFromFirstAttempt; // The errors from the second attempt should be queued after the errors\n                // from the first attempt, to preserve the causal sequence.\n                if (errorsFromSecondAttempt !== null) {\n                    queueRecoverableErrors(errorsFromSecondAttempt);\n                }\n            }\n            return exitStatus;\n        }\n        function queueRecoverableErrors(errors) {\n            if (workInProgressRootRecoverableErrors === null) {\n                workInProgressRootRecoverableErrors = errors;\n            } else {\n                // $FlowFixMe[method-unbinding]\n                workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);\n            }\n        }\n        function finishConcurrentRender(root, exitStatus, finishedWork, lanes) {\n            // TODO: The fact that most of these branches are identical suggests that some\n            // of the exit statuses are not best modeled as exit statuses and should be\n            // tracked orthogonally.\n            switch(exitStatus){\n                case RootInProgress:\n                case RootFatalErrored:\n                    {\n                        throw new Error('Root did not complete. This is a bug in React.');\n                    }\n                case RootSuspendedWithDelay:\n                    {\n                        if (includesOnlyTransitions(lanes)) {\n                            // This is a transition, so we should exit without committing a\n                            // placeholder and without scheduling a timeout. Delay indefinitely\n                            // until we receive more data.\n                            markRootSuspended(root, lanes, workInProgressDeferredLane);\n                            return;\n                        } // Commit the placeholder.\n                        break;\n                    }\n                case RootErrored:\n                    {\n                        // This render errored. Ignore any recoverable errors because we weren't actually\n                        // able to recover. Instead, whatever the final errors were is the ones we log.\n                        // This ensures that we only log the actual client side error if it's just a plain\n                        // error thrown from a component on the server and the client.\n                        workInProgressRootRecoverableErrors = null;\n                        break;\n                    }\n                case RootSuspended:\n                case RootCompleted:\n                    {\n                        break;\n                    }\n                default:\n                    {\n                        throw new Error('Unknown root exit status.');\n                    }\n            }\n            if (shouldForceFlushFallbacksInDEV()) {\n                // We're inside an `act` scope. Commit immediately.\n                commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, workInProgressDeferredLane);\n            } else {\n                if (includesOnlyRetries(lanes) && alwaysThrottleRetries) {\n                    // This render only included retries, no updates. Throttle committing\n                    // retries so that we don't show too many loading states too quickly.\n                    var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(); // Don't bother with a very short suspense time.\n                    if (msUntilTimeout > 10) {\n                        markRootSuspended(root, lanes, workInProgressDeferredLane);\n                        var nextLanes = getNextLanes(root, NoLanes);\n                        if (nextLanes !== NoLanes) {\n                            // There's additional work we can do on this root. We might as well\n                            // attempt to work on that while we're suspended.\n                            return;\n                        } // The render is suspended, it hasn't timed out, and there's no\n                        // lower priority work to do. Instead of committing the fallback\n                        // immediately, wait for more data to arrive.\n                        // TODO: Combine retry throttling with Suspensey commits. Right now they\n                        // run one after the other.\n                        root.timeoutHandle = scheduleTimeout(commitRootWhenReady.bind(null, root, finishedWork, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane), msUntilTimeout);\n                        return;\n                    }\n                }\n                commitRootWhenReady(root, finishedWork, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane);\n            }\n        }\n        function commitRootWhenReady(root, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane) {\n            // TODO: Combine retry throttling with Suspensey commits. Right now they run\n            // one after the other.\n            var BothVisibilityAndMaySuspendCommit = Visibility | MaySuspendCommit;\n            var subtreeFlags = finishedWork.subtreeFlags;\n            if (subtreeFlags & ShouldSuspendCommit || (subtreeFlags & BothVisibilityAndMaySuspendCommit) === BothVisibilityAndMaySuspendCommit) {\n                // Before committing, ask the renderer whether the host tree is ready.\n                // If it's not, we'll wait until it notifies us.\n                startSuspendingCommit(); // This will walk the completed fiber tree and attach listeners to all\n                // the suspensey resources. The renderer is responsible for accumulating\n                // all the load events. This all happens in a single synchronous\n                // transaction, so it track state in its own module scope.\n                accumulateSuspenseyCommit(finishedWork); // At the end, ask the renderer if it's ready to commit, or if we should\n                // suspend. If it's not ready, it will return a callback to subscribe to\n                // a ready event.\n                var schedulePendingCommit = waitForCommitToBeReady();\n                if (schedulePendingCommit !== null) {\n                    // NOTE: waitForCommitToBeReady returns a subscribe function so that we\n                    // only allocate a function if the commit isn't ready yet. The other\n                    // pattern would be to always pass a callback to waitForCommitToBeReady.\n                    // Not yet ready to commit. Delay the commit until the renderer notifies\n                    // us that it's ready. This will be canceled if we start work on the\n                    // root again.\n                    root.cancelPendingCommit = schedulePendingCommit(commitRoot.bind(null, root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate));\n                    markRootSuspended(root, lanes, spawnedLane);\n                    return;\n                }\n            } // Otherwise, commit immediately.\n            commitRoot(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane);\n        }\n        function isRenderConsistentWithExternalStores(finishedWork) {\n            // Search the rendered tree for external store reads, and check whether the\n            // stores were mutated in a concurrent event. Intentionally using an iterative\n            // loop instead of recursion so we can exit early.\n            var node = finishedWork;\n            while(true){\n                if (node.flags & StoreConsistency) {\n                    var updateQueue = node.updateQueue;\n                    if (updateQueue !== null) {\n                        var checks = updateQueue.stores;\n                        if (checks !== null) {\n                            for(var i = 0; i < checks.length; i++){\n                                var check = checks[i];\n                                var getSnapshot = check.getSnapshot;\n                                var renderedValue = check.value;\n                                try {\n                                    if (!objectIs(getSnapshot(), renderedValue)) {\n                                        // Found an inconsistent store.\n                                        return false;\n                                    }\n                                } catch (error) {\n                                    // If `getSnapshot` throws, return `false`. This will schedule\n                                    // a re-render, and the error will be rethrown during render.\n                                    return false;\n                                }\n                            }\n                        }\n                    }\n                }\n                var child = node.child;\n                if (node.subtreeFlags & StoreConsistency && child !== null) {\n                    child.return = node;\n                    node = child;\n                    continue;\n                }\n                if (node === finishedWork) {\n                    return true;\n                }\n                while(node.sibling === null){\n                    if (node.return === null || node.return === finishedWork) {\n                        return true;\n                    }\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            } // Flow doesn't know this is unreachable, but eslint does\n            // eslint-disable-next-line no-unreachable\n            return true;\n        } // The extra indirections around markRootUpdated and markRootSuspended is\n        // needed to avoid a circular dependency between this module and\n        // ReactFiberLane. There's probably a better way to split up these modules and\n        // avoid this problem. Perhaps all the root-marking functions should move into\n        // the work loop.\n        function markRootUpdated(root, updatedLanes) {\n            markRootUpdated$1(root, updatedLanes);\n            {\n                // Check for recursive updates\n                if (executionContext & RenderContext) {\n                    workInProgressRootDidIncludeRecursiveRenderUpdate = true;\n                } else if (executionContext & CommitContext) {\n                    didIncludeCommitPhaseUpdate = true;\n                }\n                throwIfInfiniteUpdateLoopDetected();\n            }\n        }\n        function markRootPinged(root, pingedLanes) {\n            markRootPinged$1(root, pingedLanes);\n            {\n                // Check for recursive pings. Pings are conceptually different from updates in\n                // other contexts but we call it an \"update\" in this context because\n                // repeatedly pinging a suspended render can cause a recursive render loop.\n                // The relevant property is that it can result in a new render attempt\n                // being scheduled.\n                if (executionContext & RenderContext) {\n                    workInProgressRootDidIncludeRecursiveRenderUpdate = true;\n                } else if (executionContext & CommitContext) {\n                    didIncludeCommitPhaseUpdate = true;\n                }\n                throwIfInfiniteUpdateLoopDetected();\n            }\n        }\n        function markRootSuspended(root, suspendedLanes, spawnedLane) {\n            // When suspending, we should always exclude lanes that were pinged or (more\n            // rarely, since we try to avoid it) updated during the render phase.\n            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\n            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);\n            markRootSuspended$1(root, suspendedLanes, spawnedLane);\n        } // This is the entry point for synchronous tasks that don't go\n        // through Scheduler\n        function performSyncWorkOnRoot(root, lanes) {\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                throw new Error('Should not already be working.');\n            }\n            var didFlushPassiveEffects = flushPassiveEffects();\n            if (didFlushPassiveEffects) {\n                // If passive effects were flushed, exit to the outer work loop in the root\n                // scheduler, so we can recompute the priority.\n                // TODO: We don't actually need this `ensureRootIsScheduled` call because\n                // this path is only reachable if the root is already part of the schedule.\n                // I'm including it only for consistency with the other exit points from\n                // this function. Can address in a subsequent refactor.\n                ensureRootIsScheduled(root);\n                return null;\n            }\n            {\n                syncNestedUpdateFlag();\n            }\n            var exitStatus = renderRootSync(root, lanes);\n            if (exitStatus === RootErrored) {\n                // If something threw an error, try rendering one more time. We'll render\n                // synchronously to block concurrent data mutations, and we'll includes\n                // all pending updates are included. If it still fails after the second\n                // attempt, we'll give up and commit the resulting tree.\n                var originallyAttemptedLanes = lanes;\n                var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root, originallyAttemptedLanes);\n                if (errorRetryLanes !== NoLanes) {\n                    lanes = errorRetryLanes;\n                    exitStatus = recoverFromConcurrentError(root, originallyAttemptedLanes, errorRetryLanes);\n                }\n            }\n            if (exitStatus === RootFatalErrored) {\n                prepareFreshStack(root, NoLanes);\n                markRootSuspended(root, lanes, NoLane);\n                ensureRootIsScheduled(root);\n                return null;\n            }\n            if (exitStatus === RootDidNotComplete) {\n                // The render unwound without completing the tree. This happens in special\n                // cases where need to exit the current render without producing a\n                // consistent tree or committing.\n                markRootSuspended(root, lanes, workInProgressDeferredLane);\n                ensureRootIsScheduled(root);\n                return null;\n            } // We now have a consistent tree. Because this is a sync render, we\n            // will commit it even if something suspended.\n            var finishedWork = root.current.alternate;\n            root.finishedWork = finishedWork;\n            root.finishedLanes = lanes;\n            commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, workInProgressDeferredLane); // Before exiting, make sure there's a callback scheduled for the next\n            // pending level.\n            ensureRootIsScheduled(root);\n            return null;\n        }\n        function flushRoot(root, lanes) {\n            if (lanes !== NoLanes) {\n                upgradePendingLanesToSync(root, lanes);\n                ensureRootIsScheduled(root);\n                if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n                    resetRenderTimer(); // TODO: For historical reasons this flushes all sync work across all\n                    // roots. It shouldn't really matter either way, but we could change this\n                    // to only flush the given root.\n                    flushSyncWorkOnAllRoots();\n                }\n            }\n        }\n        function getExecutionContext() {\n            return executionContext;\n        }\n        function deferredUpdates(fn) {\n            var prevTransition = ReactSharedInternals.T;\n            var previousPriority = getCurrentUpdatePriority();\n            try {\n                setCurrentUpdatePriority(DefaultEventPriority);\n                ReactSharedInternals.T = null;\n                return fn();\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactSharedInternals.T = prevTransition;\n            }\n        }\n        function batchedUpdates(fn, a) {\n            {\n                // batchedUpdates is a no-op now, but there's still some internal react-dom\n                // code calling it, that we can't remove until we remove legacy mode.\n                return fn(a);\n            }\n        }\n        function discreteUpdates(fn, a, b, c, d) {\n            var prevTransition = ReactSharedInternals.T;\n            var previousPriority = getCurrentUpdatePriority();\n            try {\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                ReactSharedInternals.T = null;\n                return fn(a, b, c, d);\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactSharedInternals.T = prevTransition;\n                if (executionContext === NoContext) {\n                    resetRenderTimer();\n                }\n            }\n        } // Overload the definition to the two valid signatures.\n        // Warning, this opts-out of checking the function body.\n        // eslint-disable-next-line no-unused-vars\n        // eslint-disable-next-line no-redeclare\n        // eslint-disable-next-line no-redeclare\n        function flushSyncFromReconciler(fn) {\n            // In legacy mode, we flush pending passive effects at the beginning of the\n            // next event, not at the end of the previous one.\n            if (rootWithPendingPassiveEffects !== null && !disableLegacyMode && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {\n                flushPassiveEffects();\n            }\n            var prevExecutionContext = executionContext;\n            executionContext |= BatchedContext;\n            var prevTransition = ReactSharedInternals.T;\n            var previousPriority = getCurrentUpdatePriority();\n            try {\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                ReactSharedInternals.T = null;\n                if (fn) {\n                    return fn();\n                } else {\n                    return undefined;\n                }\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactSharedInternals.T = prevTransition;\n                executionContext = prevExecutionContext; // Flush the immediate callbacks that were scheduled during this batch.\n                // Note that this will happen even if batchedUpdates is higher up\n                // the stack.\n                if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n                    flushSyncWorkOnAllRoots();\n                }\n            }\n        } // If called outside of a render or commit will flush all sync work on all roots\n        // Returns whether the the call was during a render or not\n        function flushSyncWork() {\n            if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n                flushSyncWorkOnAllRoots();\n                return false;\n            }\n            return true;\n        }\n        function isAlreadyRendering() {\n            // Used by the renderer to print a warning if certain APIs are called from\n            // the wrong context.\n            return (executionContext & (RenderContext | CommitContext)) !== NoContext;\n        }\n        // hidden subtree. The stack logic is managed there because that's the only\n        // place that ever modifies it. Which module it lives in doesn't matter for\n        // performance because this function will get inlined regardless\n        function setEntangledRenderLanes(newEntangledRenderLanes) {\n            entangledRenderLanes = newEntangledRenderLanes;\n        }\n        function getEntangledRenderLanes() {\n            return entangledRenderLanes;\n        }\n        function resetWorkInProgressStack() {\n            if (workInProgress === null) return;\n            var interruptedWork;\n            if (workInProgressSuspendedReason === NotSuspended) {\n                // Normal case. Work-in-progress hasn't started yet. Unwind all\n                // its parents.\n                interruptedWork = workInProgress.return;\n            } else {\n                // Work-in-progress is in suspended state. Reset the work loop and unwind\n                // both the suspended fiber and all its parents.\n                resetSuspendedWorkLoopOnUnwind(workInProgress);\n                interruptedWork = workInProgress;\n            }\n            while(interruptedWork !== null){\n                var current = interruptedWork.alternate;\n                unwindInterruptedWork(current, interruptedWork);\n                interruptedWork = interruptedWork.return;\n            }\n            workInProgress = null;\n        }\n        function prepareFreshStack(root, lanes) {\n            root.finishedWork = null;\n            root.finishedLanes = NoLanes;\n            var timeoutHandle = root.timeoutHandle;\n            if (timeoutHandle !== noTimeout) {\n                // The root previous suspended and scheduled a timeout to commit a fallback\n                // state. Now that we have additional work, cancel the timeout.\n                root.timeoutHandle = noTimeout; // $FlowFixMe[incompatible-call] Complains noTimeout is not a TimeoutID, despite the check above\n                cancelTimeout(timeoutHandle);\n            }\n            var cancelPendingCommit = root.cancelPendingCommit;\n            if (cancelPendingCommit !== null) {\n                root.cancelPendingCommit = null;\n                cancelPendingCommit();\n            }\n            resetWorkInProgressStack();\n            workInProgressRoot = root;\n            var rootWorkInProgress = createWorkInProgress(root.current, null);\n            workInProgress = rootWorkInProgress;\n            workInProgressRootRenderLanes = lanes;\n            workInProgressSuspendedReason = NotSuspended;\n            workInProgressThrownValue = null;\n            workInProgressRootDidAttachPingListener = false;\n            workInProgressRootExitStatus = RootInProgress;\n            workInProgressRootSkippedLanes = NoLanes;\n            workInProgressRootInterleavedUpdatedLanes = NoLanes;\n            workInProgressRootPingedLanes = NoLanes;\n            workInProgressDeferredLane = NoLane;\n            workInProgressRootConcurrentErrors = null;\n            workInProgressRootRecoverableErrors = null;\n            workInProgressRootDidIncludeRecursiveRenderUpdate = false; // Get the lanes that are entangled with whatever we're about to render. We\n            // track these separately so we can distinguish the priority of the render\n            // task from the priority of the lanes it is entangled with. For example, a\n            // transition may not be allowed to finish unless it includes the Sync lane,\n            // which is currently suspended. We should be able to render the Transition\n            // and Sync lane in the same batch, but at Transition priority, because the\n            // Sync lane already suspended.\n            entangledRenderLanes = getEntangledLanes(root, lanes);\n            finishQueueingConcurrentUpdates();\n            {\n                ReactStrictModeWarnings.discardPendingWarnings();\n            }\n            return rootWorkInProgress;\n        }\n        function resetSuspendedWorkLoopOnUnwind(fiber) {\n            // Reset module-level state that was set during the render phase.\n            resetContextDependencies();\n            resetHooksOnUnwind(fiber);\n            resetChildReconcilerOnUnwind();\n        }\n        function handleThrow(root, thrownValue) {\n            // A component threw an exception. Usually this is because it suspended, but\n            // it also includes regular program errors.\n            //\n            // We're either going to unwind the stack to show a Suspense or error\n            // boundary, or we're going to replay the component again. Like after a\n            // promise resolves.\n            //\n            // Until we decide whether we're going to unwind or replay, we should preserve\n            // the current state of the work loop without resetting anything.\n            //\n            // If we do decide to unwind the stack, module-level variables will be reset\n            // in resetSuspendedWorkLoopOnUnwind.\n            // These should be reset immediately because they're only supposed to be set\n            // when React is executing user code.\n            resetHooksAfterThrow();\n            {\n                resetCurrentFiber();\n            }\n            if (thrownValue === SuspenseException) {\n                // This is a special type of exception used for Suspense. For historical\n                // reasons, the rest of the Suspense implementation expects the thrown value\n                // to be a thenable, because before `use` existed that was the (unstable)\n                // API for suspending. This implementation detail can change later, once we\n                // deprecate the old API in favor of `use`.\n                thrownValue = getSuspendedThenable();\n                workInProgressSuspendedReason = shouldRemainOnPreviousScreen() && // Check if there are other pending updates that might possibly unblock this\n                // component from suspending. This mirrors the check in\n                // renderDidSuspendDelayIfPossible. We should attempt to unify them somehow.\n                // TODO: Consider unwinding immediately, using the\n                // SuspendedOnHydration mechanism.\n                !includesNonIdleWork(workInProgressRootSkippedLanes) && !includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes) ? SuspendedOnData : // immediately resolved (i.e. in a microtask). Otherwise, trigger the\n                // nearest Suspense fallback.\n                SuspendedOnImmediate;\n            } else if (thrownValue === SuspenseyCommitException) {\n                thrownValue = getSuspendedThenable();\n                workInProgressSuspendedReason = SuspendedOnInstance;\n            } else if (thrownValue === SelectiveHydrationException) {\n                // An update flowed into a dehydrated boundary. Before we can apply the\n                // update, we need to finish hydrating. Interrupt the work-in-progress\n                // render so we can restart at the hydration lane.\n                //\n                // The ideal implementation would be able to switch contexts without\n                // unwinding the current stack.\n                //\n                // We could name this something more general but as of now it's the only\n                // case where we think this should happen.\n                workInProgressSuspendedReason = SuspendedOnHydration;\n            } else {\n                // This is a regular error.\n                var isWakeable = thrownValue !== null && typeof thrownValue === 'object' && typeof thrownValue.then === 'function';\n                workInProgressSuspendedReason = isWakeable ? // This has slightly different behavior than suspending with `use`.\n                SuspendedOnDeprecatedThrowPromise : // suspended, we must clear the thenable state to unblock the work loop.\n                SuspendedOnError;\n            }\n            workInProgressThrownValue = thrownValue;\n            var erroredWork = workInProgress;\n            if (erroredWork === null) {\n                // This is a fatal error\n                workInProgressRootExitStatus = RootFatalErrored;\n                logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));\n                return;\n            }\n            if (erroredWork.mode & ProfileMode) {\n                // Record the time spent rendering before an error was thrown. This\n                // avoids inaccurate Profiler durations in the case of a\n                // suspended render.\n                stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\n            }\n            {\n                markComponentRenderStopped();\n                switch(workInProgressSuspendedReason){\n                    case SuspendedOnError:\n                        {\n                            markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);\n                            break;\n                        }\n                    case SuspendedOnData:\n                    case SuspendedOnImmediate:\n                    case SuspendedOnDeprecatedThrowPromise:\n                    case SuspendedAndReadyToContinue:\n                        {\n                            var wakeable = thrownValue;\n                            markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);\n                            break;\n                        }\n                }\n            }\n        }\n        function shouldRemainOnPreviousScreen() {\n            // This is asking whether it's better to suspend the transition and remain\n            // on the previous screen, versus showing a fallback as soon as possible. It\n            // takes into account both the priority of render and also whether showing a\n            // fallback would produce a desirable user experience.\n            var handler = getSuspenseHandler();\n            if (handler === null) {\n                // There's no Suspense boundary that can provide a fallback. We have no\n                // choice but to remain on the previous screen.\n                // NOTE: We do this even for sync updates, for lack of any better option. In\n                // the future, we may change how we handle this, like by putting the whole\n                // root into a \"detached\" mode.\n                return true;\n            } // TODO: Once `use` has fully replaced the `throw promise` pattern, we should\n            // be able to remove the equivalent check in finishConcurrentRender, and rely\n            // just on this one.\n            if (includesOnlyTransitions(workInProgressRootRenderLanes)) {\n                if (getShellBoundary() === null) {\n                    // We're rendering inside the \"shell\" of the app. Activating the nearest\n                    // fallback would cause visible content to disappear. It's better to\n                    // suspend the transition and remain on the previous screen.\n                    return true;\n                } else {\n                    // We're rendering content that wasn't part of the previous screen.\n                    // Rather than block the transition, it's better to show a fallback as\n                    // soon as possible. The appearance of any nested fallbacks will be\n                    // throttled to avoid jank.\n                    return false;\n                }\n            }\n            if (includesOnlyRetries(workInProgressRootRenderLanes) || // In this context, an OffscreenLane counts as a Retry\n            // TODO: It's become increasingly clear that Retries and Offscreen are\n            // deeply connected. They probably can be unified further.\n            includesSomeLane(workInProgressRootRenderLanes, OffscreenLane)) {\n                // During a retry, we can suspend rendering if the nearest Suspense boundary\n                // is the boundary of the \"shell\", because we're guaranteed not to block\n                // any new content from appearing.\n                //\n                // The reason we must check if this is a retry is because it guarantees\n                // that suspending the work loop won't block an actual update, because\n                // retries don't \"update\" anything; they fill in fallbacks that were left\n                // behind by a previous transition.\n                return handler === getShellBoundary();\n            } // For all other Lanes besides Transitions and Retries, we should not wait\n            // for the data to load.\n            return false;\n        }\n        function pushDispatcher(container) {\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = ContextOnlyDispatcher;\n            if (prevDispatcher === null) {\n                // The React isomorphic package does not include a default dispatcher.\n                // Instead the first renderer will lazily attach one, in order to give\n                // nicer error messages.\n                return ContextOnlyDispatcher;\n            } else {\n                return prevDispatcher;\n            }\n        }\n        function popDispatcher(prevDispatcher) {\n            ReactSharedInternals.H = prevDispatcher;\n        }\n        function pushAsyncDispatcher() {\n            {\n                var prevAsyncDispatcher = ReactSharedInternals.A;\n                ReactSharedInternals.A = DefaultAsyncDispatcher;\n                return prevAsyncDispatcher;\n            }\n        }\n        function popAsyncDispatcher(prevAsyncDispatcher) {\n            {\n                ReactSharedInternals.A = prevAsyncDispatcher;\n            }\n        }\n        function markCommitTimeOfFallback() {\n            globalMostRecentFallbackTime = now$1();\n        }\n        function markSkippedUpdateLanes(lane) {\n            workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);\n        }\n        function renderDidSuspend() {\n            if (workInProgressRootExitStatus === RootInProgress) {\n                workInProgressRootExitStatus = RootSuspended;\n            }\n        }\n        function renderDidSuspendDelayIfPossible() {\n            workInProgressRootExitStatus = RootSuspendedWithDelay; // Check if there are updates that we skipped tree that might have unblocked\n            // this render.\n            if ((includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes)) && workInProgressRoot !== null) {\n                // Mark the current render as suspended so that we switch to working on\n                // the updates that were skipped. Usually we only suspend at the end of\n                // the render phase.\n                // TODO: We should probably always mark the root as suspended immediately\n                // (inside this function), since by suspending at the end of the render\n                // phase introduces a potential mistake where we suspend lanes that were\n                // pinged or updated while we were rendering.\n                // TODO: Consider unwinding immediately, using the\n                // SuspendedOnHydration mechanism.\n                markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane);\n            }\n        }\n        function renderDidError() {\n            if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {\n                workInProgressRootExitStatus = RootErrored;\n            }\n        }\n        function queueConcurrentError(error) {\n            if (workInProgressRootConcurrentErrors === null) {\n                workInProgressRootConcurrentErrors = [\n                    error\n                ];\n            } else {\n                workInProgressRootConcurrentErrors.push(error);\n            }\n        } // Called during render to determine if anything has suspended.\n        // Returns false if we're not sure.\n        function renderHasNotSuspendedYet() {\n            // If something errored or completed, we can't really be sure,\n            // so those are false.\n            return workInProgressRootExitStatus === RootInProgress;\n        } // TODO: Over time, this function and renderRootConcurrent have become more\n        // and more similar. Not sure it makes sense to maintain forked paths. Consider\n        // unifying them again.\n        function renderRootSync(root, lanes) {\n            var prevExecutionContext = executionContext;\n            executionContext |= RenderContext;\n            var prevDispatcher = pushDispatcher();\n            var prevAsyncDispatcher = pushAsyncDispatcher(); // If the root or lanes have changed, throw out the existing stack\n            // and prepare a fresh one. Otherwise we'll continue where we left off.\n            if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n                {\n                    if (isDevToolsPresent) {\n                        var memoizedUpdaters = root.memoizedUpdaters;\n                        if (memoizedUpdaters.size > 0) {\n                            restorePendingUpdaters(root, workInProgressRootRenderLanes);\n                            memoizedUpdaters.clear();\n                        } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n                        // If we bailout on this work, we'll move them back (like above).\n                        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n                        // That way we can keep the current update and future updates separate.\n                        movePendingFibersToMemoized(root, lanes);\n                    }\n                }\n                workInProgressTransitions = getTransitionsForLanes();\n                prepareFreshStack(root, lanes);\n            }\n            {\n                markRenderStarted(lanes);\n            }\n            var didSuspendInShell = false;\n            outer: do {\n                try {\n                    if (workInProgressSuspendedReason !== NotSuspended && workInProgress !== null) {\n                        // The work loop is suspended. During a synchronous render, we don't\n                        // yield to the main thread. Immediately unwind the stack. This will\n                        // trigger either a fallback or an error boundary.\n                        // TODO: For discrete and \"default\" updates (anything that's not\n                        // flushSync), we want to wait for the microtasks the flush before\n                        // unwinding. Will probably implement this using renderRootConcurrent,\n                        // or merge renderRootSync and renderRootConcurrent into the same\n                        // function and fork the behavior some other way.\n                        var unitOfWork = workInProgress;\n                        var thrownValue = workInProgressThrownValue;\n                        switch(workInProgressSuspendedReason){\n                            case SuspendedOnHydration:\n                                {\n                                    // Selective hydration. An update flowed into a dehydrated tree.\n                                    // Interrupt the current render so the work loop can switch to the\n                                    // hydration lane.\n                                    resetWorkInProgressStack();\n                                    workInProgressRootExitStatus = RootDidNotComplete;\n                                    break outer;\n                                }\n                            case SuspendedOnImmediate:\n                            case SuspendedOnData:\n                                {\n                                    if (!didSuspendInShell && getSuspenseHandler() === null) {\n                                        didSuspendInShell = true;\n                                    } // Intentional fallthrough\n                                }\n                            default:\n                                {\n                                    // Unwind then continue with the normal work loop.\n                                    workInProgressSuspendedReason = NotSuspended;\n                                    workInProgressThrownValue = null;\n                                    throwAndUnwindWorkLoop(root, unitOfWork, thrownValue);\n                                    break;\n                                }\n                        }\n                    }\n                    workLoopSync();\n                    break;\n                } catch (thrownValue) {\n                    handleThrow(root, thrownValue);\n                }\n            }while (true); // Check if something suspended in the shell. We use this to detect an\n            // infinite ping loop caused by an uncached promise.\n            //\n            // Only increment this counter once per synchronous render attempt across the\n            // whole tree. Even if there are many sibling components that suspend, this\n            // counter only gets incremented once.\n            if (didSuspendInShell) {\n                root.shellSuspendCounter++;\n            }\n            resetContextDependencies();\n            executionContext = prevExecutionContext;\n            popDispatcher(prevDispatcher);\n            popAsyncDispatcher(prevAsyncDispatcher);\n            if (workInProgress !== null) {\n                // This is a sync render, so we should have finished the whole tree.\n                throw new Error('Cannot commit an incomplete root. This error is likely caused by a ' + 'bug in React. Please file an issue.');\n            }\n            {\n                markRenderStopped();\n            }\n            workInProgressRoot = null;\n            workInProgressRootRenderLanes = NoLanes; // It's safe to process the queue now that the render phase is complete.\n            finishQueueingConcurrentUpdates();\n            return workInProgressRootExitStatus;\n        } // The work loop is an extremely hot path. Tell Closure not to inline it.\n        /** @noinline */ function workLoopSync() {\n            // Perform work without checking if we need to yield between fiber.\n            while(workInProgress !== null){\n                performUnitOfWork(workInProgress);\n            }\n        }\n        function renderRootConcurrent(root, lanes) {\n            var prevExecutionContext = executionContext;\n            executionContext |= RenderContext;\n            var prevDispatcher = pushDispatcher();\n            var prevAsyncDispatcher = pushAsyncDispatcher(); // If the root or lanes have changed, throw out the existing stack\n            // and prepare a fresh one. Otherwise we'll continue where we left off.\n            if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n                {\n                    if (isDevToolsPresent) {\n                        var memoizedUpdaters = root.memoizedUpdaters;\n                        if (memoizedUpdaters.size > 0) {\n                            restorePendingUpdaters(root, workInProgressRootRenderLanes);\n                            memoizedUpdaters.clear();\n                        } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n                        // If we bailout on this work, we'll move them back (like above).\n                        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n                        // That way we can keep the current update and future updates separate.\n                        movePendingFibersToMemoized(root, lanes);\n                    }\n                }\n                workInProgressTransitions = getTransitionsForLanes();\n                resetRenderTimer();\n                prepareFreshStack(root, lanes);\n            }\n            {\n                markRenderStarted(lanes);\n            }\n            outer: do {\n                try {\n                    if (workInProgressSuspendedReason !== NotSuspended && workInProgress !== null) {\n                        // The work loop is suspended. We need to either unwind the stack or\n                        // replay the suspended component.\n                        var unitOfWork = workInProgress;\n                        var thrownValue = workInProgressThrownValue;\n                        resumeOrUnwind: switch(workInProgressSuspendedReason){\n                            case SuspendedOnError:\n                                {\n                                    // Unwind then continue with the normal work loop.\n                                    workInProgressSuspendedReason = NotSuspended;\n                                    workInProgressThrownValue = null;\n                                    throwAndUnwindWorkLoop(root, unitOfWork, thrownValue);\n                                    break;\n                                }\n                            case SuspendedOnData:\n                                {\n                                    var thenable = thrownValue;\n                                    if (isThenableResolved(thenable)) {\n                                        // The data resolved. Try rendering the component again.\n                                        workInProgressSuspendedReason = NotSuspended;\n                                        workInProgressThrownValue = null;\n                                        replaySuspendedUnitOfWork(unitOfWork);\n                                        break;\n                                    } // The work loop is suspended on data. We should wait for it to\n                                    // resolve before continuing to render.\n                                    // TODO: Handle the case where the promise resolves synchronously.\n                                    // Usually this is handled when we instrument the promise to add a\n                                    // `status` field, but if the promise already has a status, we won't\n                                    // have added a listener until right here.\n                                    var onResolution = function() {\n                                        // Check if the root is still suspended on this promise.\n                                        if (workInProgressSuspendedReason === SuspendedOnData && workInProgressRoot === root) {\n                                            // Mark the root as ready to continue rendering.\n                                            workInProgressSuspendedReason = SuspendedAndReadyToContinue;\n                                        } // Ensure the root is scheduled. We should do this even if we're\n                                        // currently working on a different root, so that we resume\n                                        // rendering later.\n                                        ensureRootIsScheduled(root);\n                                    };\n                                    thenable.then(onResolution, onResolution);\n                                    break outer;\n                                }\n                            case SuspendedOnImmediate:\n                                {\n                                    // If this fiber just suspended, it's possible the data is already\n                                    // cached. Yield to the main thread to give it a chance to ping. If\n                                    // it does, we can retry immediately without unwinding the stack.\n                                    workInProgressSuspendedReason = SuspendedAndReadyToContinue;\n                                    break outer;\n                                }\n                            case SuspendedOnInstance:\n                                {\n                                    workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;\n                                    break outer;\n                                }\n                            case SuspendedAndReadyToContinue:\n                                {\n                                    var _thenable = thrownValue;\n                                    if (isThenableResolved(_thenable)) {\n                                        // The data resolved. Try rendering the component again.\n                                        workInProgressSuspendedReason = NotSuspended;\n                                        workInProgressThrownValue = null;\n                                        replaySuspendedUnitOfWork(unitOfWork);\n                                    } else {\n                                        // Otherwise, unwind then continue with the normal work loop.\n                                        workInProgressSuspendedReason = NotSuspended;\n                                        workInProgressThrownValue = null;\n                                        throwAndUnwindWorkLoop(root, unitOfWork, thrownValue);\n                                    }\n                                    break;\n                                }\n                            case SuspendedOnInstanceAndReadyToContinue:\n                                {\n                                    var resource = null;\n                                    switch(workInProgress.tag){\n                                        case HostHoistable:\n                                            {\n                                                resource = workInProgress.memoizedState;\n                                            }\n                                        // intentional fallthrough\n                                        case HostComponent:\n                                        case HostSingleton:\n                                            {\n                                                // Before unwinding the stack, check one more time if the\n                                                // instance is ready. It may have loaded when React yielded to\n                                                // the main thread.\n                                                // Assigning this to a constant so Flow knows the binding won't\n                                                // be mutated by `preloadInstance`.\n                                                var hostFiber = workInProgress;\n                                                var type = hostFiber.type;\n                                                var props = hostFiber.pendingProps;\n                                                var isReady = resource ? preloadResource(resource) : preloadInstance(type, props);\n                                                if (isReady) {\n                                                    // The data resolved. Resume the work loop as if nothing\n                                                    // suspended. Unlike when a user component suspends, we don't\n                                                    // have to replay anything because the host fiber\n                                                    // already completed.\n                                                    workInProgressSuspendedReason = NotSuspended;\n                                                    workInProgressThrownValue = null;\n                                                    var sibling = hostFiber.sibling;\n                                                    if (sibling !== null) {\n                                                        workInProgress = sibling;\n                                                    } else {\n                                                        var returnFiber = hostFiber.return;\n                                                        if (returnFiber !== null) {\n                                                            workInProgress = returnFiber;\n                                                            completeUnitOfWork(returnFiber);\n                                                        } else {\n                                                            workInProgress = null;\n                                                        }\n                                                    }\n                                                    break resumeOrUnwind;\n                                                }\n                                                break;\n                                            }\n                                        default:\n                                            {\n                                                // This will fail gracefully but it's not correct, so log a\n                                                // warning in dev.\n                                                if (true) {\n                                                    error('Unexpected type of fiber triggered a suspensey commit. ' + 'This is a bug in React.');\n                                                }\n                                                break;\n                                            }\n                                    } // Otherwise, unwind then continue with the normal work loop.\n                                    workInProgressSuspendedReason = NotSuspended;\n                                    workInProgressThrownValue = null;\n                                    throwAndUnwindWorkLoop(root, unitOfWork, thrownValue);\n                                    break;\n                                }\n                            case SuspendedOnDeprecatedThrowPromise:\n                                {\n                                    // Suspended by an old implementation that uses the `throw promise`\n                                    // pattern. The newer replaying behavior can cause subtle issues\n                                    // like infinite ping loops. So we maintain the old behavior and\n                                    // always unwind.\n                                    workInProgressSuspendedReason = NotSuspended;\n                                    workInProgressThrownValue = null;\n                                    throwAndUnwindWorkLoop(root, unitOfWork, thrownValue);\n                                    break;\n                                }\n                            case SuspendedOnHydration:\n                                {\n                                    // Selective hydration. An update flowed into a dehydrated tree.\n                                    // Interrupt the current render so the work loop can switch to the\n                                    // hydration lane.\n                                    resetWorkInProgressStack();\n                                    workInProgressRootExitStatus = RootDidNotComplete;\n                                    break outer;\n                                }\n                            default:\n                                {\n                                    throw new Error('Unexpected SuspendedReason. This is a bug in React.');\n                                }\n                        }\n                    }\n                    if ( true && ReactSharedInternals.actQueue !== null) {\n                        // `act` special case: If we're inside an `act` scope, don't consult\n                        // `shouldYield`. Always keep working until the render is complete.\n                        // This is not just an optimization: in a unit test environment, we\n                        // can't trust the result of `shouldYield`, because the host I/O is\n                        // likely mocked.\n                        workLoopSync();\n                    } else {\n                        workLoopConcurrent();\n                    }\n                    break;\n                } catch (thrownValue) {\n                    handleThrow(root, thrownValue);\n                }\n            }while (true);\n            resetContextDependencies();\n            popDispatcher(prevDispatcher);\n            popAsyncDispatcher(prevAsyncDispatcher);\n            executionContext = prevExecutionContext;\n            if (workInProgress !== null) {\n                // Still work remaining.\n                {\n                    markRenderYielded();\n                }\n                return RootInProgress;\n            } else {\n                // Completed the tree.\n                {\n                    markRenderStopped();\n                }\n                workInProgressRoot = null;\n                workInProgressRootRenderLanes = NoLanes; // It's safe to process the queue now that the render phase is complete.\n                finishQueueingConcurrentUpdates(); // Return the final exit status.\n                return workInProgressRootExitStatus;\n            }\n        }\n        /** @noinline */ function workLoopConcurrent() {\n            // Perform work until Scheduler asks us to yield\n            while(workInProgress !== null && !shouldYield()){\n                // $FlowFixMe[incompatible-call] found when upgrading Flow\n                performUnitOfWork(workInProgress);\n            }\n        }\n        function performUnitOfWork(unitOfWork) {\n            // The current, flushed, state of this fiber is the alternate. Ideally\n            // nothing should rely on this, but relying on it here means that we don't\n            // need an additional field on the work in progress.\n            var current = unitOfWork.alternate;\n            setCurrentDebugFiberInDEV(unitOfWork);\n            var next;\n            if ((unitOfWork.mode & ProfileMode) !== NoMode) {\n                startProfilerTimer(unitOfWork);\n                next = beginWork(current, unitOfWork, entangledRenderLanes);\n                stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n            } else {\n                next = beginWork(current, unitOfWork, entangledRenderLanes);\n            }\n            {\n                resetCurrentFiber();\n            }\n            unitOfWork.memoizedProps = unitOfWork.pendingProps;\n            if (next === null) {\n                // If this doesn't spawn new work, complete the current work.\n                completeUnitOfWork(unitOfWork);\n            } else {\n                workInProgress = next;\n            }\n        }\n        function replaySuspendedUnitOfWork(unitOfWork) {\n            // This is a fork of performUnitOfWork specifcally for replaying a fiber that\n            // just suspended.\n            //\n            var current = unitOfWork.alternate;\n            setCurrentDebugFiberInDEV(unitOfWork);\n            var next;\n            var isProfilingMode = (unitOfWork.mode & ProfileMode) !== NoMode;\n            if (isProfilingMode) {\n                startProfilerTimer(unitOfWork);\n            }\n            switch(unitOfWork.tag){\n                case SimpleMemoComponent:\n                case FunctionComponent:\n                    {\n                        // Resolve `defaultProps`. This logic is copied from `beginWork`.\n                        // TODO: Consider moving this switch statement into that module. Also,\n                        // could maybe use this as an opportunity to say `use` doesn't work with\n                        // `defaultProps` :)\n                        var Component = unitOfWork.type;\n                        var unresolvedProps = unitOfWork.pendingProps;\n                        var resolvedProps = unresolvedProps;\n                        var context;\n                        next = replayFunctionComponent(current, unitOfWork, resolvedProps, Component, context, workInProgressRootRenderLanes);\n                        break;\n                    }\n                case ForwardRef:\n                    {\n                        // Resolve `defaultProps`. This logic is copied from `beginWork`.\n                        // TODO: Consider moving this switch statement into that module. Also,\n                        // could maybe use this as an opportunity to say `use` doesn't work with\n                        // `defaultProps` :)\n                        var _Component = unitOfWork.type.render;\n                        var _unresolvedProps = unitOfWork.pendingProps;\n                        var _resolvedProps = _unresolvedProps;\n                        next = replayFunctionComponent(current, unitOfWork, _resolvedProps, _Component, unitOfWork.ref, workInProgressRootRenderLanes);\n                        break;\n                    }\n                case HostComponent:\n                    {\n                        // Some host components are stateful (that's how we implement form\n                        // actions) but we don't bother to reuse the memoized state because it's\n                        // not worth the extra code. The main reason to reuse the previous hooks\n                        // is to reuse uncached promises, but we happen to know that the only\n                        // promises that a host component might suspend on are definitely cached\n                        // because they are controlled by us. So don't bother.\n                        resetHooksOnUnwind(unitOfWork); // Fallthrough to the next branch.\n                    }\n                default:\n                    {\n                        // Other types besides function components are reset completely before\n                        // being replayed. Currently this only happens when a Usable type is\n                        // reconciled — the reconciler will suspend.\n                        //\n                        // We reset the fiber back to its original state; however, this isn't\n                        // a full \"unwind\" because we're going to reuse the promises that were\n                        // reconciled previously. So it's intentional that we don't call\n                        // resetSuspendedWorkLoopOnUnwind here.\n                        unwindInterruptedWork(current, unitOfWork);\n                        unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes);\n                        next = beginWork(current, unitOfWork, entangledRenderLanes);\n                        break;\n                    }\n            }\n            if (isProfilingMode) {\n                stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n            } // The begin phase finished successfully without suspending. Return to the\n            // normal work loop.\n            {\n                resetCurrentFiber();\n            }\n            unitOfWork.memoizedProps = unitOfWork.pendingProps;\n            if (next === null) {\n                // If this doesn't spawn new work, complete the current work.\n                completeUnitOfWork(unitOfWork);\n            } else {\n                workInProgress = next;\n            }\n        }\n        function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue) {\n            // This is a fork of performUnitOfWork specifcally for unwinding a fiber\n            // that threw an exception.\n            //\n            // Return to the normal work loop. This will unwind the stack, and potentially\n            // result in showing a fallback.\n            resetSuspendedWorkLoopOnUnwind(unitOfWork);\n            var returnFiber = unitOfWork.return;\n            try {\n                // Find and mark the nearest Suspense or error boundary that can handle\n                // this \"exception\".\n                var didFatal = throwException(root, returnFiber, unitOfWork, thrownValue, workInProgressRootRenderLanes);\n                if (didFatal) {\n                    panicOnRootError(root, thrownValue);\n                    return;\n                }\n            } catch (error) {\n                // We had trouble processing the error. An example of this happening is\n                // when accessing the `componentDidCatch` property of an error boundary\n                // throws an error. A weird edge case. There's a regression test for this.\n                // To prevent an infinite loop, bubble the error up to the next parent.\n                if (returnFiber !== null) {\n                    workInProgress = returnFiber;\n                    throw error;\n                } else {\n                    panicOnRootError(root, thrownValue);\n                    return;\n                }\n            }\n            if (unitOfWork.flags & Incomplete) {\n                // Unwind the stack until we reach the nearest boundary.\n                unwindUnitOfWork(unitOfWork);\n            } else {\n                // Although the fiber suspended, we're intentionally going to commit it in\n                // an inconsistent state. We can do this safely in cases where we know the\n                // inconsistent tree will be hidden.\n                //\n                // This currently only applies to Legacy Suspense implementation, but we may\n                // port a version of this to concurrent roots, too, when performing a\n                // synchronous render. Because that will allow us to mutate the tree as we\n                // go instead of buffering mutations until the end. Though it's unclear if\n                // this particular path is how that would be implemented.\n                completeUnitOfWork(unitOfWork);\n            }\n        }\n        function panicOnRootError(root, error) {\n            // There's no ancestor that can handle this exception. This should never\n            // happen because the root is supposed to capture all errors that weren't\n            // caught by an error boundary. This is a fatal error, or panic condition,\n            // because we've run out of ways to recover.\n            workInProgressRootExitStatus = RootFatalErrored;\n            logUncaughtError(root, createCapturedValueAtFiber(error, root.current)); // Set `workInProgress` to null. This represents advancing to the next\n            // sibling, or the parent if there are no siblings. But since the root\n            // has no siblings nor a parent, we set it to null. Usually this is\n            // handled by `completeUnitOfWork` or `unwindWork`, but since we're\n            // intentionally not calling those, we need set it here.\n            // TODO: Consider calling `unwindWork` to pop the contexts.\n            workInProgress = null;\n        }\n        function completeUnitOfWork(unitOfWork) {\n            // Attempt to complete the current unit of work, then move to the next\n            // sibling. If there are no more siblings, return to the parent fiber.\n            var completedWork = unitOfWork;\n            do {\n                {\n                    if ((completedWork.flags & Incomplete) !== NoFlags$1) {\n                        // NOTE: If we re-enable sibling prerendering in some cases, this branch\n                        // is where we would switch to the unwinding path.\n                        error('Internal React error: Expected this fiber to be complete, but ' + \"it isn't. It should have been unwound. This is a bug in React.\");\n                    }\n                }\n                // nothing should rely on this, but relying on it here means that we don't\n                // need an additional field on the work in progress.\n                var current = completedWork.alternate;\n                var returnFiber = completedWork.return;\n                setCurrentDebugFiberInDEV(completedWork);\n                var next = void 0;\n                if ((completedWork.mode & ProfileMode) === NoMode) {\n                    next = completeWork(current, completedWork, entangledRenderLanes);\n                } else {\n                    startProfilerTimer(completedWork);\n                    next = completeWork(current, completedWork, entangledRenderLanes); // Update render duration assuming we didn't error.\n                    stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\n                }\n                resetCurrentDebugFiberInDEV();\n                if (next !== null) {\n                    // Completing this fiber spawned new work. Work on that next.\n                    workInProgress = next;\n                    return;\n                }\n                var siblingFiber = completedWork.sibling;\n                if (siblingFiber !== null) {\n                    // If there is more work to do in this returnFiber, do that next.\n                    workInProgress = siblingFiber;\n                    return;\n                } // Otherwise, return to the parent\n                // $FlowFixMe[incompatible-type] we bail out when we get a null\n                completedWork = returnFiber; // Update the next thing we're working on in case something throws.\n                workInProgress = completedWork;\n            }while (completedWork !== null); // We've reached the root.\n            if (workInProgressRootExitStatus === RootInProgress) {\n                workInProgressRootExitStatus = RootCompleted;\n            }\n        }\n        function unwindUnitOfWork(unitOfWork) {\n            var incompleteWork = unitOfWork;\n            do {\n                // The current, flushed, state of this fiber is the alternate. Ideally\n                // nothing should rely on this, but relying on it here means that we don't\n                // need an additional field on the work in progress.\n                var current = incompleteWork.alternate; // This fiber did not complete because something threw. Pop values off\n                // the stack without entering the complete phase. If this is a boundary,\n                // capture values if possible.\n                var next = unwindWork(current, incompleteWork); // Because this fiber did not complete, don't reset its lanes.\n                if (next !== null) {\n                    // Found a boundary that can handle this exception. Re-renter the\n                    // begin phase. This branch will return us to the normal work loop.\n                    //\n                    // Since we're restarting, remove anything that is not a host effect\n                    // from the effect tag.\n                    next.flags &= HostEffectMask;\n                    workInProgress = next;\n                    return;\n                } // Keep unwinding until we reach either a boundary or the root.\n                if ((incompleteWork.mode & ProfileMode) !== NoMode) {\n                    // Record the render duration for the fiber that errored.\n                    stopProfilerTimerIfRunningAndRecordDelta(incompleteWork, false); // Include the time spent working on failed children before continuing.\n                    var actualDuration = incompleteWork.actualDuration;\n                    var child = incompleteWork.child;\n                    while(child !== null){\n                        // $FlowFixMe[unsafe-addition] addition with possible null/undefined value\n                        actualDuration += child.actualDuration;\n                        child = child.sibling;\n                    }\n                    incompleteWork.actualDuration = actualDuration;\n                } // TODO: Once we stop prerendering siblings, instead of resetting the parent\n                // of the node being unwound, we should be able to reset node itself as we\n                // unwind the stack. Saves an additional null check.\n                var returnFiber = incompleteWork.return;\n                if (returnFiber !== null) {\n                    // Mark the parent fiber as incomplete and clear its subtree flags.\n                    // TODO: Once we stop prerendering siblings, we may be able to get rid of\n                    // the Incomplete flag because unwinding to the nearest boundary will\n                    // happen synchronously.\n                    returnFiber.flags |= Incomplete;\n                    returnFiber.subtreeFlags = NoFlags$1;\n                    returnFiber.deletions = null;\n                } // NOTE: If we re-enable sibling prerendering in some cases, here we\n                // would switch to the normal completion path: check if a sibling\n                // exists, and if so, begin work on it.\n                // Otherwise, return to the parent\n                // $FlowFixMe[incompatible-type] we bail out when we get a null\n                incompleteWork = returnFiber; // Update the next thing we're working on in case something throws.\n                workInProgress = incompleteWork;\n            }while (incompleteWork !== null); // We've unwound all the way to the root.\n            workInProgressRootExitStatus = RootDidNotComplete;\n            workInProgress = null;\n        }\n        function commitRoot(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane) {\n            // TODO: This no longer makes any sense. We already wrap the mutation and\n            // layout phases. Should be able to remove.\n            var prevTransition = ReactSharedInternals.T;\n            var previousUpdateLanePriority = getCurrentUpdatePriority();\n            try {\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                ReactSharedInternals.T = null;\n                commitRootImpl(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, previousUpdateLanePriority, spawnedLane);\n            } finally{\n                ReactSharedInternals.T = prevTransition;\n                setCurrentUpdatePriority(previousUpdateLanePriority);\n            }\n            return null;\n        }\n        function commitRootImpl(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, renderPriorityLevel, spawnedLane) {\n            do {\n                // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\n                // means `flushPassiveEffects` will sometimes result in additional\n                // passive effects. So we need to keep flushing in a loop until there are\n                // no more pending effects.\n                // TODO: Might be better if `flushPassiveEffects` did not automatically\n                // flush synchronous work at the end, to avoid factoring hazards like this.\n                flushPassiveEffects();\n            }while (rootWithPendingPassiveEffects !== null);\n            flushRenderPhaseStrictModeWarningsInDEV();\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                throw new Error('Should not already be working.');\n            }\n            var finishedWork = root.finishedWork;\n            var lanes = root.finishedLanes;\n            {\n                markCommitStarted(lanes);\n            }\n            if (finishedWork === null) {\n                {\n                    markCommitStopped();\n                }\n                return null;\n            } else {\n                {\n                    if (lanes === NoLanes) {\n                        error('root.finishedLanes should not be empty during a commit. This is a ' + 'bug in React.');\n                    }\n                }\n            }\n            root.finishedWork = null;\n            root.finishedLanes = NoLanes;\n            if (finishedWork === root.current) {\n                throw new Error('Cannot commit the same tree as before. This error is likely caused by ' + 'a bug in React. Please file an issue.');\n            } // commitRoot never returns a continuation; it always finishes synchronously.\n            // So we can clear these now to allow a new callback to be scheduled.\n            root.callbackNode = null;\n            root.callbackPriority = NoLane;\n            root.cancelPendingCommit = null; // Check which lanes no longer have any work scheduled on them, and mark\n            // those as finished.\n            var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes); // Make sure to account for lanes that were updated by a concurrent event\n            // during the render phase; don't mark them as finished.\n            var concurrentlyUpdatedLanes = getConcurrentlyUpdatedLanes();\n            remainingLanes = mergeLanes(remainingLanes, concurrentlyUpdatedLanes);\n            markRootFinished(root, remainingLanes, spawnedLane); // Reset this before firing side effects so we can detect recursive updates.\n            didIncludeCommitPhaseUpdate = false;\n            if (root === workInProgressRoot) {\n                // We can reset these now that they are finished.\n                workInProgressRoot = null;\n                workInProgress = null;\n                workInProgressRootRenderLanes = NoLanes;\n            } // If there are pending passive effects, schedule a callback to process them.\n            // Do this as early as possible, so it is queued before anything else that\n            // might get scheduled in the commit phase. (See #16714.)\n            // TODO: Delete all other places that schedule the passive effect callback\n            // They're redundant.\n            if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags$1 || (finishedWork.flags & PassiveMask) !== NoFlags$1) {\n                if (!rootDoesHavePassiveEffects) {\n                    rootDoesHavePassiveEffects = true;\n                    pendingPassiveEffectsRemainingLanes = remainingLanes; // workInProgressTransitions might be overwritten, so we want\n                    // to store it in pendingPassiveTransitions until they get processed\n                    // We need to pass this through as an argument to commitRoot\n                    // because workInProgressTransitions might have changed between\n                    // the previous render and commit if we throttle the commit\n                    // with setTimeout\n                    pendingPassiveTransitions = transitions;\n                    scheduleCallback(NormalPriority$1, function() {\n                        flushPassiveEffects(); // This render triggered passive effects: release the root cache pool\n                        // *after* passive effects fire to avoid freeing a cache pool that may\n                        // be referenced by a node in the tree (HostRoot, Cache boundary etc)\n                        return null;\n                    });\n                }\n            } // Check if there are any effects in the whole tree.\n            // TODO: This is left over from the effect list implementation, where we had\n            // to check for the existence of `firstEffect` to satisfy Flow. I think the\n            // only other reason this optimization exists is because it affects profiling.\n            // Reconsider whether this is necessary.\n            var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags$1;\n            var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags$1;\n            if (subtreeHasEffects || rootHasEffect) {\n                var prevTransition = ReactSharedInternals.T;\n                ReactSharedInternals.T = null;\n                var previousPriority = getCurrentUpdatePriority();\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                var prevExecutionContext = executionContext;\n                executionContext |= CommitContext; // The commit phase is broken into several sub-phases. We do a separate pass\n                // of the effect list for each phase: all mutation effects come before all\n                // layout effects, and so on.\n                // The first phase a \"before mutation\" phase. We use this phase to read the\n                // state of the host tree right before we mutate it. This is where\n                // getSnapshotBeforeUpdate is called.\n                commitBeforeMutationEffects(root, finishedWork);\n                {\n                    // Mark the current commit time to be shared by all Profilers in this\n                    // batch. This enables them to be grouped later.\n                    recordCommitTime();\n                }\n                commitMutationEffects(root, finishedWork, lanes);\n                resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after\n                // the mutation phase, so that the previous tree is still current during\n                // componentWillUnmount, but before the layout phase, so that the finished\n                // work is current during componentDidMount/Update.\n                root.current = finishedWork; // The next phase is the layout phase, where we call effects that read\n                {\n                    markLayoutEffectsStarted(lanes);\n                }\n                commitLayoutEffects(finishedWork, root, lanes);\n                {\n                    markLayoutEffectsStopped();\n                }\n                // opportunity to paint.\n                requestPaint();\n                executionContext = prevExecutionContext; // Reset the priority to the previous non-sync value.\n                setCurrentUpdatePriority(previousPriority);\n                ReactSharedInternals.T = prevTransition;\n            } else {\n                // No effects.\n                root.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were\n                // no effects.\n                // TODO: Maybe there's a better way to report this.\n                {\n                    recordCommitTime();\n                }\n            }\n            var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\n            if (rootDoesHavePassiveEffects) {\n                // This commit has passive effects. Stash a reference to them. But don't\n                // schedule a callback until after flushing layout work.\n                rootDoesHavePassiveEffects = false;\n                rootWithPendingPassiveEffects = root;\n                pendingPassiveEffectsLanes = lanes;\n            } else {\n                // There were no passive effects, so we can immediately release the cache\n                // pool for this render.\n                releaseRootPooledCache(root, remainingLanes);\n                {\n                    nestedPassiveUpdateCount = 0;\n                    rootWithPassiveNestedUpdates = null;\n                }\n            } // Read this again, since an effect might have updated it\n            remainingLanes = root.pendingLanes; // Check if there's remaining work on this root\n            // TODO: This is part of the `componentDidCatch` implementation. Its purpose\n            // is to detect whether something might have called setState inside\n            // `componentDidCatch`. The mechanism is known to be flawed because `setState`\n            // inside `componentDidCatch` is itself flawed — that's why we recommend\n            // `getDerivedStateFromError` instead. However, it could be improved by\n            // checking if remainingLanes includes Sync work, instead of whether there's\n            // any work remaining at all (which would also include stuff like Suspense\n            // retries or transitions). It's been like this for a while, though, so fixing\n            // it probably isn't that urgent.\n            if (remainingLanes === NoLanes) {\n                // If there's no remaining work, we can clear the set of already failed\n                // error boundaries.\n                legacyErrorBoundariesThatAlreadyFailed = null;\n            }\n            {\n                if (!rootDidHavePassiveEffects) {\n                    commitDoubleInvokeEffectsInDEV(root);\n                }\n            }\n            onCommitRoot$1(finishedWork.stateNode, renderPriorityLevel);\n            {\n                if (isDevToolsPresent) {\n                    root.memoizedUpdaters.clear();\n                }\n            }\n            {\n                onCommitRoot();\n            }\n            // additional work on this root is scheduled.\n            ensureRootIsScheduled(root);\n            if (recoverableErrors !== null) {\n                // There were errors during this render, but recovered from them without\n                // needing to surface it to the UI. We log them here.\n                var onRecoverableError = root.onRecoverableError;\n                for(var i = 0; i < recoverableErrors.length; i++){\n                    var recoverableError = recoverableErrors[i];\n                    var errorInfo = makeErrorInfo(recoverableError.stack);\n                    setCurrentDebugFiberInDEV(recoverableError.source);\n                    onRecoverableError(recoverableError.value, errorInfo);\n                    resetCurrentDebugFiberInDEV();\n                }\n            } // If the passive effects are the result of a discrete render, flush them\n            // synchronously at the end of the current task so that the result is\n            // immediately observable. Otherwise, we assume that they are not\n            // order-dependent and do not need to be observed by external systems, so we\n            // can wait until after paint.\n            // TODO: We can optimize this by not scheduling the callback earlier. Since we\n            // currently schedule the callback in multiple places, will wait until those\n            // are consolidated.\n            if (includesSyncLane(pendingPassiveEffectsLanes) && disableLegacyMode) {\n                flushPassiveEffects();\n            } // Read this again, since a passive effect might have updated it\n            remainingLanes = root.pendingLanes; // Check if this render scheduled a cascading synchronous update. This is a\n            // heurstic to detect infinite update loops. We are intentionally excluding\n            // hydration lanes in this check, because render triggered by selective\n            // hydration is conceptually not an update.\n            if (// the render phase or the commit phase. We track these explicitly because\n            // we can't infer from the remaining lanes alone.\n            didIncludeRenderPhaseUpdate || didIncludeCommitPhaseUpdate || // Was the finished render the result of an update (not hydration)?\n            includesSomeLane(lanes, UpdateLanes) && // Did it schedule a sync update?\n            includesSomeLane(remainingLanes, SyncUpdateLanes)) {\n                {\n                    markNestedUpdateScheduled();\n                }\n                // finishing. If there are too many, it indicates an infinite update loop.\n                if (root === rootWithNestedUpdates) {\n                    nestedUpdateCount++;\n                } else {\n                    nestedUpdateCount = 0;\n                    rootWithNestedUpdates = root;\n                }\n            } else {\n                nestedUpdateCount = 0;\n            } // If layout work was scheduled, flush it now.\n            flushSyncWorkOnAllRoots();\n            {\n                markCommitStopped();\n            }\n            return null;\n        }\n        function makeErrorInfo(componentStack) {\n            var errorInfo = {\n                componentStack: componentStack\n            };\n            {\n                Object.defineProperty(errorInfo, 'digest', {\n                    get: function() {\n                        error('You are accessing \"digest\" from the errorInfo object passed to onRecoverableError.' + ' This property is no longer provided as part of errorInfo but can be accessed as a property' + ' of the Error instance itself.');\n                    }\n                });\n            }\n            return errorInfo;\n        }\n        function releaseRootPooledCache(root, remainingLanes) {\n            {\n                var pooledCacheLanes = root.pooledCacheLanes &= remainingLanes;\n                if (pooledCacheLanes === NoLanes) {\n                    // None of the remaining work relies on the cache pool. Clear it so\n                    // subsequent requests get a new cache\n                    var pooledCache = root.pooledCache;\n                    if (pooledCache != null) {\n                        root.pooledCache = null;\n                        releaseCache(pooledCache);\n                    }\n                }\n            }\n        }\n        function flushPassiveEffects() {\n            // Returns whether passive effects were flushed.\n            // TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should\n            // probably just combine the two functions. I believe they were only separate\n            // in the first place because we used to wrap it with\n            // `Scheduler.runWithPriority`, which accepts a function. But now we track the\n            // priority within React itself, so we can mutate the variable directly.\n            if (rootWithPendingPassiveEffects !== null) {\n                // Cache the root since rootWithPendingPassiveEffects is cleared in\n                // flushPassiveEffectsImpl\n                var root = rootWithPendingPassiveEffects; // Cache and clear the remaining lanes flag; it must be reset since this\n                // method can be called from various places, not always from commitRoot\n                // where the remaining lanes are known\n                var remainingLanes = pendingPassiveEffectsRemainingLanes;\n                pendingPassiveEffectsRemainingLanes = NoLanes;\n                var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);\n                var priority = lowerEventPriority(DefaultEventPriority, renderPriority);\n                var prevTransition = ReactSharedInternals.T;\n                var previousPriority = getCurrentUpdatePriority();\n                try {\n                    setCurrentUpdatePriority(priority);\n                    ReactSharedInternals.T = null;\n                    return flushPassiveEffectsImpl();\n                } finally{\n                    setCurrentUpdatePriority(previousPriority);\n                    ReactSharedInternals.T = prevTransition; // Once passive effects have run for the tree - giving components a\n                    // chance to retain cache instances they use - release the pooled\n                    // cache at the root (if there is one)\n                    releaseRootPooledCache(root, remainingLanes);\n                }\n            }\n            return false;\n        }\n        function enqueuePendingPassiveProfilerEffect(fiber) {\n            {\n                pendingPassiveProfilerEffects.push(fiber);\n                if (!rootDoesHavePassiveEffects) {\n                    rootDoesHavePassiveEffects = true;\n                    scheduleCallback(NormalPriority$1, function() {\n                        flushPassiveEffects();\n                        return null;\n                    });\n                }\n            }\n        }\n        function flushPassiveEffectsImpl() {\n            if (rootWithPendingPassiveEffects === null) {\n                return false;\n            } // Cache and clear the transitions flag\n            var transitions = pendingPassiveTransitions;\n            pendingPassiveTransitions = null;\n            var root = rootWithPendingPassiveEffects;\n            var lanes = pendingPassiveEffectsLanes;\n            rootWithPendingPassiveEffects = null; // TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.\n            // Figure out why and fix it. It's not causing any known issues (probably\n            // because it's only used for profiling), but it's a refactor hazard.\n            pendingPassiveEffectsLanes = NoLanes;\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                throw new Error('Cannot flush passive effects while already rendering.');\n            }\n            {\n                isFlushingPassiveEffects = true;\n                didScheduleUpdateDuringPassiveEffects = false;\n            }\n            {\n                markPassiveEffectsStarted(lanes);\n            }\n            var prevExecutionContext = executionContext;\n            executionContext |= CommitContext;\n            commitPassiveUnmountEffects(root.current);\n            commitPassiveMountEffects(root, root.current, lanes, transitions); // TODO: Move to commitPassiveMountEffects\n            {\n                var profilerEffects = pendingPassiveProfilerEffects;\n                pendingPassiveProfilerEffects = [];\n                for(var i = 0; i < profilerEffects.length; i++){\n                    var fiber = profilerEffects[i];\n                    commitPassiveEffectDurations(root, fiber);\n                }\n            }\n            {\n                markPassiveEffectsStopped();\n            }\n            {\n                commitDoubleInvokeEffectsInDEV(root);\n            }\n            executionContext = prevExecutionContext;\n            flushSyncWorkOnAllRoots();\n            {\n                // If additional passive effects were scheduled, increment a counter. If this\n                // exceeds the limit, we'll fire a warning.\n                if (didScheduleUpdateDuringPassiveEffects) {\n                    if (root === rootWithPassiveNestedUpdates) {\n                        nestedPassiveUpdateCount++;\n                    } else {\n                        nestedPassiveUpdateCount = 0;\n                        rootWithPassiveNestedUpdates = root;\n                    }\n                } else {\n                    nestedPassiveUpdateCount = 0;\n                }\n                isFlushingPassiveEffects = false;\n                didScheduleUpdateDuringPassiveEffects = false;\n            }\n            onPostCommitRoot(root);\n            {\n                var stateNode = root.current.stateNode;\n                stateNode.effectDuration = 0;\n                stateNode.passiveEffectDuration = 0;\n            }\n            return true;\n        }\n        function isAlreadyFailedLegacyErrorBoundary(instance) {\n            return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);\n        }\n        function markLegacyErrorBoundaryAsFailed(instance) {\n            if (legacyErrorBoundariesThatAlreadyFailed === null) {\n                legacyErrorBoundariesThatAlreadyFailed = new Set([\n                    instance\n                ]);\n            } else {\n                legacyErrorBoundariesThatAlreadyFailed.add(instance);\n            }\n        }\n        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {\n            var errorInfo = createCapturedValueAtFiber(error, sourceFiber);\n            var update = createRootErrorUpdate(rootFiber.stateNode, errorInfo, SyncLane);\n            var root = enqueueUpdate(rootFiber, update, SyncLane);\n            if (root !== null) {\n                markRootUpdated(root, SyncLane);\n                ensureRootIsScheduled(root);\n            }\n        }\n        function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {\n            {\n                setIsRunningInsertionEffect(false);\n            }\n            if (sourceFiber.tag === HostRoot) {\n                // Error was thrown at the root. There is no parent, so the root\n                // itself should capture it.\n                captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);\n                return;\n            }\n            var fiber = nearestMountedAncestor;\n            while(fiber !== null){\n                if (fiber.tag === HostRoot) {\n                    captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);\n                    return;\n                } else if (fiber.tag === ClassComponent) {\n                    var ctor = fiber.type;\n                    var instance = fiber.stateNode;\n                    if (typeof ctor.getDerivedStateFromError === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {\n                        var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);\n                        var update = createClassErrorUpdate(SyncLane);\n                        var root = enqueueUpdate(fiber, update, SyncLane);\n                        if (root !== null) {\n                            initializeClassErrorUpdate(update, root, fiber, errorInfo);\n                            markRootUpdated(root, SyncLane);\n                            ensureRootIsScheduled(root);\n                        }\n                        return;\n                    }\n                }\n                fiber = fiber.return;\n            }\n            {\n                error('Internal React error: Attempted to capture a commit phase error ' + 'inside a detached tree. This indicates a bug in React. Potential ' + 'causes include deleting the same fiber more than once, committing an ' + 'already-finished tree, or an inconsistent return pointer.\\n\\n' + 'Error message:\\n\\n%s', error$1);\n            }\n        }\n        function attachPingListener(root, wakeable, lanes) {\n            // Attach a ping listener\n            //\n            // The data might resolve before we have a chance to commit the fallback. Or,\n            // in the case of a refresh, we'll never commit a fallback. So we need to\n            // attach a listener now. When it resolves (\"pings\"), we can decide whether to\n            // try rendering the tree again.\n            //\n            // Only attach a listener if one does not already exist for the lanes\n            // we're currently rendering (which acts like a \"thread ID\" here).\n            //\n            // We only need to do this in concurrent mode. Legacy Suspense always\n            // commits fallbacks synchronously, so there are no pings.\n            var pingCache = root.pingCache;\n            var threadIDs;\n            if (pingCache === null) {\n                pingCache = root.pingCache = new PossiblyWeakMap();\n                threadIDs = new Set();\n                pingCache.set(wakeable, threadIDs);\n            } else {\n                threadIDs = pingCache.get(wakeable);\n                if (threadIDs === undefined) {\n                    threadIDs = new Set();\n                    pingCache.set(wakeable, threadIDs);\n                }\n            }\n            if (!threadIDs.has(lanes)) {\n                workInProgressRootDidAttachPingListener = true; // Memoize using the thread ID to prevent redundant listeners.\n                threadIDs.add(lanes);\n                var ping = pingSuspendedRoot.bind(null, root, wakeable, lanes);\n                {\n                    if (isDevToolsPresent) {\n                        // If we have pending work still, restore the original updaters\n                        restorePendingUpdaters(root, lanes);\n                    }\n                }\n                wakeable.then(ping, ping);\n            }\n        }\n        function pingSuspendedRoot(root, wakeable, pingedLanes) {\n            var pingCache = root.pingCache;\n            if (pingCache !== null) {\n                // The wakeable resolved, so we no longer need to memoize, because it will\n                // never be thrown again.\n                pingCache.delete(wakeable);\n            }\n            markRootPinged(root, pingedLanes);\n            warnIfSuspenseResolutionNotWrappedWithActDEV();\n            if (workInProgressRoot === root && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {\n                // Received a ping at the same priority level at which we're currently\n                // rendering. We might want to restart this render. This should mirror\n                // the logic of whether or not a root suspends once it completes.\n                // TODO: If we're rendering sync either due to Sync, Batched or expired,\n                // we should probably never restart.\n                // If we're suspended with delay, or if it's a retry, we'll always suspend\n                // so we can always restart.\n                if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {\n                    // Force a restart from the root by unwinding the stack. Unless this is\n                    // being called from the render phase, because that would cause a crash.\n                    if ((executionContext & RenderContext) === NoContext) {\n                        prepareFreshStack(root, NoLanes);\n                    }\n                } else {\n                    // Even though we can't restart right now, we might get an\n                    // opportunity later. So we mark this render as having a ping.\n                    workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);\n                }\n            }\n            ensureRootIsScheduled(root);\n        }\n        function retryTimedOutBoundary(boundaryFiber, retryLane) {\n            // The boundary fiber (a Suspense component or SuspenseList component)\n            // previously was rendered in its fallback state. One of the promises that\n            // suspended it has resolved, which means at least part of the tree was\n            // likely unblocked. Try rendering again, at a new lanes.\n            if (retryLane === NoLane) {\n                // TODO: Assign this to `suspenseState.retryLane`? to avoid\n                // unnecessary entanglement?\n                retryLane = requestRetryLane();\n            } // TODO: Special case idle priority?\n            var root = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);\n            if (root !== null) {\n                markRootUpdated(root, retryLane);\n                ensureRootIsScheduled(root);\n            }\n        }\n        function retryDehydratedSuspenseBoundary(boundaryFiber) {\n            var suspenseState = boundaryFiber.memoizedState;\n            var retryLane = NoLane;\n            if (suspenseState !== null) {\n                retryLane = suspenseState.retryLane;\n            }\n            retryTimedOutBoundary(boundaryFiber, retryLane);\n        }\n        function resolveRetryWakeable(boundaryFiber, wakeable) {\n            var retryLane = NoLane; // Default\n            var retryCache;\n            switch(boundaryFiber.tag){\n                case SuspenseComponent:\n                    retryCache = boundaryFiber.stateNode;\n                    var suspenseState = boundaryFiber.memoizedState;\n                    if (suspenseState !== null) {\n                        retryLane = suspenseState.retryLane;\n                    }\n                    break;\n                case SuspenseListComponent:\n                    retryCache = boundaryFiber.stateNode;\n                    break;\n                case OffscreenComponent:\n                    {\n                        var instance = boundaryFiber.stateNode;\n                        retryCache = instance._retryCache;\n                        break;\n                    }\n                default:\n                    throw new Error('Pinged unknown suspense boundary type. ' + 'This is probably a bug in React.');\n            }\n            if (retryCache !== null) {\n                // The wakeable resolved, so we no longer need to memoize, because it will\n                // never be thrown again.\n                retryCache.delete(wakeable);\n            }\n            retryTimedOutBoundary(boundaryFiber, retryLane);\n        }\n        function throwIfInfiniteUpdateLoopDetected() {\n            if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n                nestedUpdateCount = 0;\n                nestedPassiveUpdateCount = 0;\n                rootWithNestedUpdates = null;\n                rootWithPassiveNestedUpdates = null;\n                {\n                    if (executionContext & RenderContext && workInProgressRoot !== null) {\n                        // We're in the render phase. Disable the concurrent error recovery\n                        // mechanism to ensure that the error we're about to throw gets handled.\n                        // We need it to trigger the nearest error boundary so that the infinite\n                        // update loop is broken.\n                        workInProgressRoot.errorRecoveryDisabledLanes = mergeLanes(workInProgressRoot.errorRecoveryDisabledLanes, workInProgressRootRenderLanes);\n                    }\n                }\n                throw new Error('Maximum update depth exceeded. This can happen when a component ' + 'repeatedly calls setState inside componentWillUpdate or ' + 'componentDidUpdate. React limits the number of nested updates to ' + 'prevent infinite loops.');\n            }\n            {\n                if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\n                    nestedPassiveUpdateCount = 0;\n                    rootWithPassiveNestedUpdates = null;\n                    error('Maximum update depth exceeded. This can happen when a component ' + \"calls setState inside useEffect, but useEffect either doesn't \" + 'have a dependency array, or one of the dependencies changes on ' + 'every render.');\n                }\n            }\n        }\n        function flushRenderPhaseStrictModeWarningsInDEV() {\n            {\n                ReactStrictModeWarnings.flushLegacyContextWarning();\n                ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n            }\n        }\n        function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, parentFiber, isInStrictMode) {\n            if ((parentFiber.subtreeFlags & (PlacementDEV | Visibility)) === NoFlags$1) {\n                // Parent's descendants have already had effects double invoked.\n                // Early exit to avoid unnecessary tree traversal.\n                return;\n            }\n            var child = parentFiber.child;\n            while(child !== null){\n                doubleInvokeEffectsInDEVIfNecessary(root, child, isInStrictMode);\n                child = child.sibling;\n            }\n        } // Unconditionally disconnects and connects passive and layout effects.\n        function doubleInvokeEffectsOnFiber(root, fiber) {\n            var shouldDoubleInvokePassiveEffects = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n            setIsStrictModeForDevtools(true);\n            disappearLayoutEffects(fiber);\n            if (shouldDoubleInvokePassiveEffects) {\n                disconnectPassiveEffect(fiber);\n            }\n            reappearLayoutEffects(root, fiber.alternate, fiber, false);\n            if (shouldDoubleInvokePassiveEffects) {\n                reconnectPassiveEffects(root, fiber, NoLanes, null, false);\n            }\n            setIsStrictModeForDevtools(false);\n        }\n        function doubleInvokeEffectsInDEVIfNecessary(root, fiber, parentIsInStrictMode) {\n            var isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;\n            var isInStrictMode = parentIsInStrictMode || isStrictModeFiber; // First case: the fiber **is not** of type OffscreenComponent. No\n            // special rules apply to double invoking effects.\n            if (fiber.tag !== OffscreenComponent) {\n                if (fiber.flags & PlacementDEV) {\n                    setCurrentDebugFiberInDEV(fiber);\n                    if (isInStrictMode) {\n                        doubleInvokeEffectsOnFiber(root, fiber, (fiber.mode & NoStrictPassiveEffectsMode) === NoMode);\n                    }\n                    resetCurrentDebugFiberInDEV();\n                } else {\n                    recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, fiber, isInStrictMode);\n                }\n                return;\n            } // Second case: the fiber **is** of type OffscreenComponent.\n            // This branch contains cases specific to Offscreen.\n            if (fiber.memoizedState === null) {\n                // Only consider Offscreen that is visible.\n                // TODO (Offscreen) Handle manual mode.\n                setCurrentDebugFiberInDEV(fiber);\n                if (isInStrictMode && fiber.flags & Visibility) {\n                    // Double invoke effects on Offscreen's subtree only\n                    // if it is visible and its visibility has changed.\n                    doubleInvokeEffectsOnFiber(root, fiber);\n                } else if (fiber.subtreeFlags & PlacementDEV) {\n                    // Something in the subtree could have been suspended.\n                    // We need to continue traversal and find newly inserted fibers.\n                    recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, fiber, isInStrictMode);\n                }\n                resetCurrentDebugFiberInDEV();\n            }\n        }\n        function commitDoubleInvokeEffectsInDEV(root, hasPassiveEffects) {\n            {\n                {\n                    var doubleInvokeEffects = true;\n                    if (!(root.current.mode & (StrictLegacyMode | StrictEffectsMode))) {\n                        doubleInvokeEffects = false;\n                    }\n                    recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, root.current, doubleInvokeEffects);\n                }\n            }\n        }\n        var didWarnStateUpdateForNotYetMountedComponent = null;\n        function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\n            {\n                if ((executionContext & RenderContext) !== NoContext) {\n                    // We let the other warning about render phase updates deal with this one.\n                    return;\n                }\n                var tag = fiber.tag;\n                if (tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {\n                    // Only warn for user-defined components, not internal ones like Suspense.\n                    return;\n                } // We show the whole stack but dedupe on the top component's name because\n                // the problematic code almost always lies inside that component.\n                var componentName = getComponentNameFromFiber(fiber) || 'ReactComponent';\n                if (didWarnStateUpdateForNotYetMountedComponent !== null) {\n                    if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\n                        return;\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    didWarnStateUpdateForNotYetMountedComponent.add(componentName);\n                } else {\n                    didWarnStateUpdateForNotYetMountedComponent = new Set([\n                        componentName\n                    ]);\n                }\n                var previousFiber = current;\n                try {\n                    setCurrentDebugFiberInDEV(fiber);\n                    error(\"Can't perform a React state update on a component that hasn't mounted yet. \" + 'This indicates that you have a side-effect in your render function that ' + 'asynchronously later calls tries to update the component. Move this work to ' + 'useEffect instead.');\n                } finally{\n                    if (previousFiber) {\n                        setCurrentDebugFiberInDEV(fiber);\n                    } else {\n                        resetCurrentDebugFiberInDEV();\n                    }\n                }\n            }\n        }\n        var didWarnAboutUpdateInRender = false;\n        var didWarnAboutUpdateInRenderForAnotherComponent;\n        {\n            didWarnAboutUpdateInRenderForAnotherComponent = new Set();\n        }\n        function warnAboutRenderPhaseUpdatesInDEV(fiber) {\n            {\n                if (isRendering) {\n                    switch(fiber.tag){\n                        case FunctionComponent:\n                        case ForwardRef:\n                        case SimpleMemoComponent:\n                            {\n                                var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || 'Unknown'; // Dedupe by the rendering component because it's the one that needs to be fixed.\n                                var dedupeKey = renderingComponentName;\n                                if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\n                                    didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\n                                    var setStateComponentName = getComponentNameFromFiber(fiber) || 'Unknown';\n                                    error('Cannot update a component (`%s`) while rendering a ' + 'different component (`%s`). To locate the bad setState() call inside `%s`, ' + 'follow the stack trace as described in https://react.dev/link/setstate-in-render', setStateComponentName, renderingComponentName, renderingComponentName);\n                                }\n                                break;\n                            }\n                        case ClassComponent:\n                            {\n                                if (!didWarnAboutUpdateInRender) {\n                                    error('Cannot update during an existing state transition (such as ' + 'within `render`). Render methods should be a pure ' + 'function of props and state.');\n                                    didWarnAboutUpdateInRender = true;\n                                }\n                                break;\n                            }\n                    }\n                }\n            }\n        }\n        function restorePendingUpdaters(root, lanes) {\n            {\n                if (isDevToolsPresent) {\n                    var memoizedUpdaters = root.memoizedUpdaters;\n                    memoizedUpdaters.forEach(function(schedulingFiber) {\n                        addFiberToLanesMap(root, schedulingFiber, lanes);\n                    }); // This function intentionally does not clear memoized updaters.\n                // Those may still be relevant to the current commit\n                // and a future one (e.g. Suspense).\n                }\n            }\n        }\n        var fakeActCallbackNode = {}; // $FlowFixMe[missing-local-annot]\n        function scheduleCallback(priorityLevel, callback) {\n            {\n                // If we're currently inside an `act` scope, bypass Scheduler and push to\n                // the `act` queue instead.\n                var actQueue = ReactSharedInternals.actQueue;\n                if (actQueue !== null) {\n                    actQueue.push(callback);\n                    return fakeActCallbackNode;\n                } else {\n                    return scheduleCallback$3(priorityLevel, callback);\n                }\n            }\n        }\n        function shouldForceFlushFallbacksInDEV() {\n            // Never force flush in production. This function should get stripped out.\n            return ReactSharedInternals.actQueue !== null;\n        }\n        function warnIfUpdatesNotWrappedWithActDEV(fiber) {\n            {\n                {\n                    if (!isConcurrentActEnvironment()) {\n                        // Not in an act environment. No need to warn.\n                        return;\n                    }\n                }\n                if (ReactSharedInternals.actQueue === null) {\n                    var previousFiber = current;\n                    try {\n                        setCurrentDebugFiberInDEV(fiber);\n                        error('An update to %s inside a test was not wrapped in act(...).\\n\\n' + 'When testing, code that causes React state updates should be ' + 'wrapped into act(...):\\n\\n' + 'act(() => {\\n' + '  /* fire events that update state */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://react.dev/link/wrap-tests-with-act', getComponentNameFromFiber(fiber));\n                    } finally{\n                        if (previousFiber) {\n                            setCurrentDebugFiberInDEV(fiber);\n                        } else {\n                            resetCurrentDebugFiberInDEV();\n                        }\n                    }\n                }\n            }\n        }\n        function warnIfSuspenseResolutionNotWrappedWithActDEV(root) {\n            {\n                if (isConcurrentActEnvironment() && ReactSharedInternals.actQueue === null) {\n                    error('A suspended resource finished loading inside a test, but the event ' + 'was not wrapped in act(...).\\n\\n' + 'When testing, code that resolves suspended data should be wrapped ' + 'into act(...):\\n\\n' + 'act(() => {\\n' + '  /* finish loading suspended data */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://react.dev/link/wrap-tests-with-act');\n                }\n            }\n        }\n        function setIsRunningInsertionEffect(isRunning) {\n            {\n                isRunningInsertionEffect = isRunning;\n            }\n        }\n        /* eslint-disable react-internal/prod-error-codes */ // Used by React Refresh runtime through DevTools Global Hook.\n        var resolveFamily = null;\n        var failedBoundaries = null;\n        var setRefreshHandler = function(handler) {\n            {\n                resolveFamily = handler;\n            }\n        };\n        function resolveFunctionForHotReloading(type) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return type;\n                }\n                var family = resolveFamily(type);\n                if (family === undefined) {\n                    return type;\n                } // Use the latest known implementation.\n                return family.current;\n            }\n        }\n        function resolveClassForHotReloading(type) {\n            // No implementation differences.\n            return resolveFunctionForHotReloading(type);\n        }\n        function resolveForwardRefForHotReloading(type) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return type;\n                }\n                var family = resolveFamily(type);\n                if (family === undefined) {\n                    // Check if we're dealing with a real forwardRef. Don't want to crash early.\n                    if (type !== null && type !== undefined && typeof type.render === 'function') {\n                        // ForwardRef is special because its resolved .type is an object,\n                        // but it's possible that we only have its inner render function in the map.\n                        // If that inner render function is different, we'll build a new forwardRef type.\n                        var currentRender = resolveFunctionForHotReloading(type.render);\n                        if (type.render !== currentRender) {\n                            var syntheticType = {\n                                $$typeof: REACT_FORWARD_REF_TYPE,\n                                render: currentRender\n                            };\n                            if (type.displayName !== undefined) {\n                                syntheticType.displayName = type.displayName;\n                            }\n                            return syntheticType;\n                        }\n                    }\n                    return type;\n                } // Use the latest known implementation.\n                return family.current;\n            }\n        }\n        function isCompatibleFamilyForHotReloading(fiber, element) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return false;\n                }\n                var prevType = fiber.elementType;\n                var nextType = element.type; // If we got here, we know types aren't === equal.\n                var needsCompareFamilies = false;\n                var $$typeofNextType = typeof nextType === 'object' && nextType !== null ? nextType.$$typeof : null;\n                switch(fiber.tag){\n                    case ClassComponent:\n                        {\n                            if (typeof nextType === 'function') {\n                                needsCompareFamilies = true;\n                            }\n                            break;\n                        }\n                    case FunctionComponent:\n                        {\n                            if (typeof nextType === 'function') {\n                                needsCompareFamilies = true;\n                            } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                                // We don't know the inner type yet.\n                                // We're going to assume that the lazy inner type is stable,\n                                // and so it is sufficient to avoid reconciling it away.\n                                // We're not going to unwrap or actually use the new lazy type.\n                                needsCompareFamilies = true;\n                            }\n                            break;\n                        }\n                    case ForwardRef:\n                        {\n                            if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {\n                                needsCompareFamilies = true;\n                            } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                                needsCompareFamilies = true;\n                            }\n                            break;\n                        }\n                    case MemoComponent:\n                    case SimpleMemoComponent:\n                        {\n                            if ($$typeofNextType === REACT_MEMO_TYPE) {\n                                // TODO: if it was but can no longer be simple,\n                                // we shouldn't set this.\n                                needsCompareFamilies = true;\n                            } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                                needsCompareFamilies = true;\n                            }\n                            break;\n                        }\n                    default:\n                        return false;\n                } // Check if both types have a family and it's the same one.\n                if (needsCompareFamilies) {\n                    // Note: memo() and forwardRef() we'll compare outer rather than inner type.\n                    // This means both of them need to be registered to preserve state.\n                    // If we unwrapped and compared the inner types for wrappers instead,\n                    // then we would risk falsely saying two separate memo(Foo)\n                    // calls are equivalent because they wrap the same Foo function.\n                    var prevFamily = resolveFamily(prevType); // $FlowFixMe[not-a-function] found when upgrading Flow\n                    if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        }\n        function markFailedErrorBoundaryForHotReloading(fiber) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return;\n                }\n                if (typeof WeakSet !== 'function') {\n                    return;\n                }\n                if (failedBoundaries === null) {\n                    failedBoundaries = new WeakSet();\n                }\n                failedBoundaries.add(fiber);\n            }\n        }\n        var scheduleRefresh = function(root, update) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return;\n                }\n                var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;\n                flushPassiveEffects();\n                scheduleFibersWithFamiliesRecursively(root.current, updatedFamilies, staleFamilies);\n                flushSyncWork();\n            }\n        };\n        var scheduleRoot = function(root, element) {\n            {\n                if (root.context !== emptyContextObject) {\n                    // Super edge case: root has a legacy _renderSubtree context\n                    // but we don't know the parentComponent so we can't pass it.\n                    // Just ignore. We'll delete this with _renderSubtree code path later.\n                    return;\n                }\n                updateContainerSync(element, root, null, null);\n                flushSyncWork();\n            }\n        };\n        function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {\n            {\n                var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;\n                var candidateType = null;\n                switch(tag){\n                    case FunctionComponent:\n                    case SimpleMemoComponent:\n                    case ClassComponent:\n                        candidateType = type;\n                        break;\n                    case ForwardRef:\n                        candidateType = type.render;\n                        break;\n                }\n                if (resolveFamily === null) {\n                    throw new Error('Expected resolveFamily to be set during hot reload.');\n                }\n                var needsRender = false;\n                var needsRemount = false;\n                if (candidateType !== null) {\n                    var family = resolveFamily(candidateType);\n                    if (family !== undefined) {\n                        if (staleFamilies.has(family)) {\n                            needsRemount = true;\n                        } else if (updatedFamilies.has(family)) {\n                            if (tag === ClassComponent) {\n                                needsRemount = true;\n                            } else {\n                                needsRender = true;\n                            }\n                        }\n                    }\n                }\n                if (failedBoundaries !== null) {\n                    if (failedBoundaries.has(fiber) || // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    alternate !== null && failedBoundaries.has(alternate)) {\n                        needsRemount = true;\n                    }\n                }\n                if (needsRemount) {\n                    fiber._debugNeedsRemount = true;\n                }\n                if (needsRemount || needsRender) {\n                    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                    if (root !== null) {\n                        scheduleUpdateOnFiber(root, fiber, SyncLane);\n                    }\n                }\n                if (child !== null && !needsRemount) {\n                    scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);\n                }\n                if (sibling !== null) {\n                    scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);\n                }\n            }\n        }\n        var findHostInstancesForRefresh = function(root, families) {\n            {\n                var hostInstances = new Set();\n                var types = new Set(families.map(function(family) {\n                    return family.current;\n                }));\n                findHostInstancesForMatchingFibersRecursively(root.current, types, hostInstances);\n                return hostInstances;\n            }\n        };\n        function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {\n            {\n                var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;\n                var candidateType = null;\n                switch(tag){\n                    case FunctionComponent:\n                    case SimpleMemoComponent:\n                    case ClassComponent:\n                        candidateType = type;\n                        break;\n                    case ForwardRef:\n                        candidateType = type.render;\n                        break;\n                }\n                var didMatch = false;\n                if (candidateType !== null) {\n                    if (types.has(candidateType)) {\n                        didMatch = true;\n                    }\n                }\n                if (didMatch) {\n                    // We have a match. This only drills down to the closest host components.\n                    // There's no need to search deeper because for the purpose of giving\n                    // visual feedback, \"flashing\" outermost parent rectangles is sufficient.\n                    findHostInstancesForFiberShallowly(fiber, hostInstances);\n                } else {\n                    // If there's no match, maybe there will be one further down in the child tree.\n                    if (child !== null) {\n                        findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);\n                    }\n                }\n                if (sibling !== null) {\n                    findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);\n                }\n            }\n        }\n        function findHostInstancesForFiberShallowly(fiber, hostInstances) {\n            {\n                var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);\n                if (foundHostInstances) {\n                    return;\n                } // If we didn't find any host children, fallback to closest host parent.\n                var node = fiber;\n                while(true){\n                    switch(node.tag){\n                        case HostSingleton:\n                        case HostComponent:\n                            hostInstances.add(node.stateNode);\n                            return;\n                        case HostPortal:\n                            hostInstances.add(node.stateNode.containerInfo);\n                            return;\n                        case HostRoot:\n                            hostInstances.add(node.stateNode.containerInfo);\n                            return;\n                    }\n                    if (node.return === null) {\n                        throw new Error('Expected to reach root first.');\n                    }\n                    node = node.return;\n                }\n            }\n        }\n        function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {\n            {\n                var node = fiber;\n                var foundHostInstances = false;\n                while(true){\n                    if (node.tag === HostComponent || node.tag === HostHoistable || (supportsSingletons ? node.tag === HostSingleton : false)) {\n                        // We got a match.\n                        foundHostInstances = true;\n                        hostInstances.add(node.stateNode); // There may still be more, so keep searching.\n                    } else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                    if (node === fiber) {\n                        return foundHostInstances;\n                    }\n                    while(node.sibling === null){\n                        if (node.return === null || node.return === fiber) {\n                            return foundHostInstances;\n                        }\n                        node = node.return;\n                    }\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            }\n            return false;\n        }\n        var hasBadMapPolyfill;\n        {\n            hasBadMapPolyfill = false;\n            try {\n                var nonExtensibleObject = Object.preventExtensions({});\n                /* eslint-disable no-new */ new Map([\n                    [\n                        nonExtensibleObject,\n                        null\n                    ]\n                ]);\n                new Set([\n                    nonExtensibleObject\n                ]);\n            /* eslint-enable no-new */ } catch (e) {\n                // TODO: Consider warning about bad polyfills\n                hasBadMapPolyfill = true;\n            }\n        }\n        function FiberNode(tag, pendingProps, key, mode) {\n            // Instance\n            this.tag = tag;\n            this.key = key;\n            this.elementType = null;\n            this.type = null;\n            this.stateNode = null; // Fiber\n            this.return = null;\n            this.child = null;\n            this.sibling = null;\n            this.index = 0;\n            this.ref = null;\n            this.refCleanup = null;\n            this.pendingProps = pendingProps;\n            this.memoizedProps = null;\n            this.updateQueue = null;\n            this.memoizedState = null;\n            this.dependencies = null;\n            this.mode = mode; // Effects\n            this.flags = NoFlags$1;\n            this.subtreeFlags = NoFlags$1;\n            this.deletions = null;\n            this.lanes = NoLanes;\n            this.childLanes = NoLanes;\n            this.alternate = null;\n            {\n                // Note: The following is done to avoid a v8 performance cliff.\n                //\n                // Initializing the fields below to smis and later updating them with\n                // double values will cause Fibers to end up having separate shapes.\n                // This behavior/bug has something to do with Object.preventExtension().\n                // Fortunately this only impacts DEV builds.\n                // Unfortunately it makes React unusably slow for some applications.\n                // To work around this, initialize the fields below with doubles.\n                //\n                // Learn more about this here:\n                // https://github.com/facebook/react/issues/14365\n                // https://bugs.chromium.org/p/v8/issues/detail?id=8538\n                this.actualDuration = Number.NaN;\n                this.actualStartTime = Number.NaN;\n                this.selfBaseDuration = Number.NaN;\n                this.treeBaseDuration = Number.NaN; // It's okay to replace the initial doubles with smis after initialization.\n                // This won't trigger the performance cliff mentioned above,\n                // and it simplifies other profiler code (including DevTools).\n                this.actualDuration = 0;\n                this.actualStartTime = -1;\n                this.selfBaseDuration = 0;\n                this.treeBaseDuration = 0;\n            }\n            {\n                // This isn't directly used but is handy for debugging internals:\n                this._debugInfo = null;\n                this._debugOwner = null;\n                this._debugNeedsRemount = false;\n                this._debugHookTypes = null;\n                if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\n                    Object.preventExtensions(this);\n                }\n            }\n        } // This is a constructor function, rather than a POJO constructor, still\n        // please ensure we do the following:\n        // 1) Nobody should add any instance methods on this. Instance methods can be\n        //    more difficult to predict when they get optimized and they are almost\n        //    never inlined properly in static compilers.\n        // 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n        //    always know when it is a fiber.\n        // 3) We might want to experiment with using numeric keys since they are easier\n        //    to optimize in a non-JIT environment.\n        // 4) We can easily go from a constructor to a createFiber object literal if that\n        //    is faster.\n        // 5) It should be easy to port this to a C struct and keep a C implementation\n        //    compatible.\n        function createFiber(tag, pendingProps, key, mode) {\n            // $FlowFixMe[invalid-constructor]: the shapes are exact here but Flow doesn't like constructors\n            return new FiberNode(tag, pendingProps, key, mode);\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function isSimpleFunctionComponent(type) {\n            return typeof type === 'function' && !shouldConstruct(type) && type.defaultProps === undefined;\n        }\n        function isFunctionClassComponent(type) {\n            return shouldConstruct(type);\n        } // This is used to create an alternate fiber to do work on.\n        function createWorkInProgress(current, pendingProps) {\n            var workInProgress = current.alternate;\n            if (workInProgress === null) {\n                // We use a double buffering pooling technique because we know that we'll\n                // only ever need at most two versions of a tree. We pool the \"other\" unused\n                // node that we're free to reuse. This is lazily created to avoid allocating\n                // extra objects for things that are never updated. It also allow us to\n                // reclaim the extra memory if needed.\n                workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);\n                workInProgress.elementType = current.elementType;\n                workInProgress.type = current.type;\n                workInProgress.stateNode = current.stateNode;\n                {\n                    // DEV-only fields\n                    workInProgress._debugOwner = current._debugOwner;\n                    workInProgress._debugHookTypes = current._debugHookTypes;\n                }\n                workInProgress.alternate = current;\n                current.alternate = workInProgress;\n            } else {\n                workInProgress.pendingProps = pendingProps; // Needed because Blocks store data on type.\n                workInProgress.type = current.type; // We already have an alternate.\n                // Reset the effect tag.\n                workInProgress.flags = NoFlags$1; // The effects are no longer valid.\n                workInProgress.subtreeFlags = NoFlags$1;\n                workInProgress.deletions = null;\n                {\n                    // We intentionally reset, rather than copy, actualDuration & actualStartTime.\n                    // This prevents time from endlessly accumulating in new commits.\n                    // This has the downside of resetting values for different priority renders,\n                    // But works for yielding (the common case) and should support resuming.\n                    workInProgress.actualDuration = 0;\n                    workInProgress.actualStartTime = -1;\n                }\n            } // Reset all effects except static ones.\n            // Static effects are not specific to a render.\n            workInProgress.flags = current.flags & StaticMask;\n            workInProgress.childLanes = current.childLanes;\n            workInProgress.lanes = current.lanes;\n            workInProgress.child = current.child;\n            workInProgress.memoizedProps = current.memoizedProps;\n            workInProgress.memoizedState = current.memoizedState;\n            workInProgress.updateQueue = current.updateQueue; // Clone the dependencies object. This is mutated during the render phase, so\n            // it cannot be shared with the current fiber.\n            var currentDependencies = current.dependencies;\n            workInProgress.dependencies = currentDependencies === null ? null : {\n                lanes: currentDependencies.lanes,\n                firstContext: currentDependencies.firstContext\n            }; // These will be overridden during the parent's reconciliation\n            workInProgress.sibling = current.sibling;\n            workInProgress.index = current.index;\n            workInProgress.ref = current.ref;\n            workInProgress.refCleanup = current.refCleanup;\n            {\n                workInProgress.selfBaseDuration = current.selfBaseDuration;\n                workInProgress.treeBaseDuration = current.treeBaseDuration;\n            }\n            {\n                workInProgress._debugInfo = current._debugInfo;\n                workInProgress._debugNeedsRemount = current._debugNeedsRemount;\n                switch(workInProgress.tag){\n                    case FunctionComponent:\n                    case SimpleMemoComponent:\n                        workInProgress.type = resolveFunctionForHotReloading(current.type);\n                        break;\n                    case ClassComponent:\n                        workInProgress.type = resolveClassForHotReloading(current.type);\n                        break;\n                    case ForwardRef:\n                        workInProgress.type = resolveForwardRefForHotReloading(current.type);\n                        break;\n                }\n            }\n            return workInProgress;\n        } // Used to reuse a Fiber for a second pass.\n        function resetWorkInProgress(workInProgress, renderLanes) {\n            // This resets the Fiber to what createFiber or createWorkInProgress would\n            // have set the values to before during the first pass. Ideally this wouldn't\n            // be necessary but unfortunately many code paths reads from the workInProgress\n            // when they should be reading from current and writing to workInProgress.\n            // We assume pendingProps, index, key, ref, return are still untouched to\n            // avoid doing another reconciliation.\n            // Reset the effect flags but keep any Placement tags, since that's something\n            // that child fiber is setting, not the reconciliation.\n            workInProgress.flags &= StaticMask | Placement; // The effects are no longer valid.\n            var current = workInProgress.alternate;\n            if (current === null) {\n                // Reset to createFiber's initial values.\n                workInProgress.childLanes = NoLanes;\n                workInProgress.lanes = renderLanes;\n                workInProgress.child = null;\n                workInProgress.subtreeFlags = NoFlags$1;\n                workInProgress.memoizedProps = null;\n                workInProgress.memoizedState = null;\n                workInProgress.updateQueue = null;\n                workInProgress.dependencies = null;\n                workInProgress.stateNode = null;\n                {\n                    // Note: We don't reset the actualTime counts. It's useful to accumulate\n                    // actual time across multiple render passes.\n                    workInProgress.selfBaseDuration = 0;\n                    workInProgress.treeBaseDuration = 0;\n                }\n            } else {\n                // Reset to the cloned values that createWorkInProgress would've.\n                workInProgress.childLanes = current.childLanes;\n                workInProgress.lanes = current.lanes;\n                workInProgress.child = current.child;\n                workInProgress.subtreeFlags = NoFlags$1;\n                workInProgress.deletions = null;\n                workInProgress.memoizedProps = current.memoizedProps;\n                workInProgress.memoizedState = current.memoizedState;\n                workInProgress.updateQueue = current.updateQueue; // Needed because Blocks store data on type.\n                workInProgress.type = current.type; // Clone the dependencies object. This is mutated during the render phase, so\n                // it cannot be shared with the current fiber.\n                var currentDependencies = current.dependencies;\n                workInProgress.dependencies = currentDependencies === null ? null : {\n                    lanes: currentDependencies.lanes,\n                    firstContext: currentDependencies.firstContext\n                };\n                {\n                    // Note: We don't reset the actualTime counts. It's useful to accumulate\n                    // actual time across multiple render passes.\n                    workInProgress.selfBaseDuration = current.selfBaseDuration;\n                    workInProgress.treeBaseDuration = current.treeBaseDuration;\n                }\n            }\n            return workInProgress;\n        }\n        function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {\n            var mode;\n            {\n                mode = ConcurrentMode;\n                if (isStrictMode === true) {\n                    mode |= StrictLegacyMode | StrictEffectsMode;\n                }\n            }\n            if (isDevToolsPresent) {\n                // Always collect profile timings when DevTools are present.\n                // This enables DevTools to start capturing timing at any point–\n                // Without some nodes in the tree having empty base times.\n                mode |= ProfileMode;\n            }\n            return createFiber(HostRoot, null, null, mode);\n        }\n        function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {\n            var fiberTag = FunctionComponent; // The resolved type is set if we know what the final type will be. I.e. it's not lazy.\n            var resolvedType = type;\n            if (typeof type === 'function') {\n                if (shouldConstruct(type)) {\n                    fiberTag = ClassComponent;\n                    {\n                        resolvedType = resolveClassForHotReloading(resolvedType);\n                    }\n                } else {\n                    {\n                        resolvedType = resolveFunctionForHotReloading(resolvedType);\n                    }\n                }\n            } else if (typeof type === 'string') {\n                if (supportsResources && supportsSingletons) {\n                    var hostContext = getHostContext();\n                    fiberTag = isHostHoistableType(type, pendingProps, hostContext) ? HostHoistable : isHostSingletonType(type) ? HostSingleton : HostComponent;\n                } else if (supportsResources) {\n                    var _hostContext = getHostContext();\n                    fiberTag = isHostHoistableType(type, pendingProps, _hostContext) ? HostHoistable : HostComponent;\n                } else if (supportsSingletons) {\n                    fiberTag = isHostSingletonType(type) ? HostSingleton : HostComponent;\n                } else {\n                    fiberTag = HostComponent;\n                }\n            } else {\n                getTag: switch(type){\n                    case REACT_FRAGMENT_TYPE:\n                        return createFiberFromFragment(pendingProps.children, mode, lanes, key);\n                    case REACT_STRICT_MODE_TYPE:\n                        fiberTag = Mode;\n                        mode |= StrictLegacyMode;\n                        {\n                            // Strict effects should never run on legacy roots\n                            mode |= StrictEffectsMode;\n                        }\n                        break;\n                    case REACT_PROFILER_TYPE:\n                        return createFiberFromProfiler(pendingProps, mode, lanes, key);\n                    case REACT_SUSPENSE_TYPE:\n                        return createFiberFromSuspense(pendingProps, mode, lanes, key);\n                    case REACT_SUSPENSE_LIST_TYPE:\n                        return createFiberFromSuspenseList(pendingProps, mode, lanes, key);\n                    case REACT_OFFSCREEN_TYPE:\n                        return createFiberFromOffscreen(pendingProps, mode, lanes, key);\n                    case REACT_LEGACY_HIDDEN_TYPE:\n                    // Fall through\n                    case REACT_SCOPE_TYPE:\n                    // Fall through\n                    case REACT_TRACING_MARKER_TYPE:\n                    // Fall through\n                    case REACT_DEBUG_TRACING_MODE_TYPE:\n                    // Fall through\n                    default:\n                        {\n                            if (typeof type === 'object' && type !== null) {\n                                switch(type.$$typeof){\n                                    case REACT_PROVIDER_TYPE:\n                                    // Fall through\n                                    case REACT_CONTEXT_TYPE:\n                                        {\n                                            fiberTag = ContextProvider;\n                                            break getTag;\n                                        }\n                                    case REACT_CONSUMER_TYPE:\n                                        {\n                                            fiberTag = ContextConsumer;\n                                            break getTag;\n                                        }\n                                    // Fall through\n                                    case REACT_FORWARD_REF_TYPE:\n                                        fiberTag = ForwardRef;\n                                        {\n                                            resolvedType = resolveForwardRefForHotReloading(resolvedType);\n                                        }\n                                        break getTag;\n                                    case REACT_MEMO_TYPE:\n                                        fiberTag = MemoComponent;\n                                        break getTag;\n                                    case REACT_LAZY_TYPE:\n                                        fiberTag = LazyComponent;\n                                        resolvedType = null;\n                                        break getTag;\n                                }\n                            }\n                            var info = '';\n                            var typeString;\n                            {\n                                if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n                                    info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n                                }\n                                if (type === null) {\n                                    typeString = 'null';\n                                } else if (isArray(type)) {\n                                    typeString = 'array';\n                                } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                                    typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n                                    info = ' Did you accidentally export a JSX literal instead of a component?';\n                                } else {\n                                    typeString = typeof type;\n                                }\n                                var ownerName = owner ? getComponentNameFromOwner(owner) : null;\n                                if (ownerName) {\n                                    info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n                                }\n                            }\n                            throw new Error('Element type is invalid: expected a string (for built-in ' + 'components) or a class/function (for composite components) ' + (\"but got: \" + typeString + \".\" + info));\n                        }\n                }\n            }\n            var fiber = createFiber(fiberTag, pendingProps, key, mode);\n            fiber.elementType = type;\n            fiber.type = resolvedType;\n            fiber.lanes = lanes;\n            {\n                fiber._debugOwner = owner;\n            }\n            return fiber;\n        }\n        function createFiberFromElement(element, mode, lanes) {\n            var owner = null;\n            {\n                owner = element._owner;\n            }\n            var type = element.type;\n            var key = element.key;\n            var pendingProps = element.props;\n            var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);\n            {\n                fiber._debugOwner = element._owner;\n            }\n            return fiber;\n        }\n        function createFiberFromFragment(elements, mode, lanes, key) {\n            var fiber = createFiber(Fragment, elements, key, mode);\n            fiber.lanes = lanes;\n            return fiber;\n        }\n        function createFiberFromProfiler(pendingProps, mode, lanes, key) {\n            {\n                if (typeof pendingProps.id !== 'string') {\n                    error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);\n                }\n            }\n            var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);\n            fiber.elementType = REACT_PROFILER_TYPE;\n            fiber.lanes = lanes;\n            {\n                fiber.stateNode = {\n                    effectDuration: 0,\n                    passiveEffectDuration: 0\n                };\n            }\n            return fiber;\n        }\n        function createFiberFromSuspense(pendingProps, mode, lanes, key) {\n            var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);\n            fiber.elementType = REACT_SUSPENSE_TYPE;\n            fiber.lanes = lanes;\n            return fiber;\n        }\n        function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {\n            var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);\n            fiber.elementType = REACT_SUSPENSE_LIST_TYPE;\n            fiber.lanes = lanes;\n            return fiber;\n        }\n        function createFiberFromOffscreen(pendingProps, mode, lanes, key) {\n            var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);\n            fiber.elementType = REACT_OFFSCREEN_TYPE;\n            fiber.lanes = lanes;\n            var primaryChildInstance = {\n                _visibility: OffscreenVisible,\n                _pendingVisibility: OffscreenVisible,\n                _pendingMarkers: null,\n                _retryCache: null,\n                _transitions: null,\n                _current: null,\n                detach: function() {\n                    return detachOffscreenInstance(primaryChildInstance);\n                },\n                attach: function() {\n                    return attachOffscreenInstance(primaryChildInstance);\n                }\n            };\n            fiber.stateNode = primaryChildInstance;\n            return fiber;\n        }\n        function createFiberFromText(content, mode, lanes) {\n            var fiber = createFiber(HostText, content, null, mode);\n            fiber.lanes = lanes;\n            return fiber;\n        }\n        function createFiberFromDehydratedFragment(dehydratedNode) {\n            var fiber = createFiber(DehydratedFragment, null, null, NoMode);\n            fiber.stateNode = dehydratedNode;\n            return fiber;\n        }\n        function createFiberFromPortal(portal, mode, lanes) {\n            var pendingProps = portal.children !== null ? portal.children : [];\n            var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);\n            fiber.lanes = lanes;\n            fiber.stateNode = {\n                containerInfo: portal.containerInfo,\n                pendingChildren: null,\n                // Used by persistent updates\n                implementation: portal.implementation\n            };\n            return fiber;\n        }\n        function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {\n            this.tag = ConcurrentRoot;\n            this.containerInfo = containerInfo;\n            this.pendingChildren = null;\n            this.current = null;\n            this.pingCache = null;\n            this.finishedWork = null;\n            this.timeoutHandle = noTimeout;\n            this.cancelPendingCommit = null;\n            this.context = null;\n            this.pendingContext = null;\n            this.next = null;\n            this.callbackNode = null;\n            this.callbackPriority = NoLane;\n            this.expirationTimes = createLaneMap(NoTimestamp);\n            this.pendingLanes = NoLanes;\n            this.suspendedLanes = NoLanes;\n            this.pingedLanes = NoLanes;\n            this.expiredLanes = NoLanes;\n            this.finishedLanes = NoLanes;\n            this.errorRecoveryDisabledLanes = NoLanes;\n            this.shellSuspendCounter = 0;\n            this.entangledLanes = NoLanes;\n            this.entanglements = createLaneMap(NoLanes);\n            this.hiddenUpdates = createLaneMap(null);\n            this.identifierPrefix = identifierPrefix;\n            this.onUncaughtError = onUncaughtError;\n            this.onCaughtError = onCaughtError;\n            this.onRecoverableError = onRecoverableError;\n            {\n                this.pooledCache = null;\n                this.pooledCacheLanes = NoLanes;\n            }\n            this.formState = formState;\n            this.incompleteTransitions = new Map();\n            {\n                this.effectDuration = 0;\n                this.passiveEffectDuration = 0;\n            }\n            {\n                this.memoizedUpdaters = new Set();\n                var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];\n                for(var _i = 0; _i < TotalLanes; _i++){\n                    pendingUpdatersLaneMap.push(new Set());\n                }\n            }\n            {\n                {\n                    // TODO: This varies by each renderer.\n                    this._debugRootType = hydrate ? 'hydrateRoot()' : 'createRoot()';\n                }\n            }\n        }\n        function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, // host config, but because they are passed in at runtime, we have to thread\n        // them through the root constructor. Perhaps we should put them all into a\n        // single type, like a DynamicHostConfig that is defined by the renderer.\n        identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {\n            // $FlowFixMe[invalid-constructor] Flow no longer supports calling new on functions\n            var root = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState);\n            // stateNode is any.\n            var uninitializedFiber = createHostRootFiber(tag, isStrictMode);\n            root.current = uninitializedFiber;\n            uninitializedFiber.stateNode = root;\n            {\n                var initialCache = createCache();\n                retainCache(initialCache); // The pooledCache is a fresh cache instance that is used temporarily\n                // for newly mounted boundaries during a render. In general, the\n                // pooledCache is always cleared from the root at the end of a render:\n                // it is either released when render commits, or moved to an Offscreen\n                // component if rendering suspends. Because the lifetime of the pooled\n                // cache is distinct from the main memoizedState.cache, it must be\n                // retained separately.\n                root.pooledCache = initialCache;\n                retainCache(initialCache);\n                var initialState = {\n                    element: initialChildren,\n                    isDehydrated: hydrate,\n                    cache: initialCache\n                };\n                uninitializedFiber.memoizedState = initialState;\n            }\n            initializeUpdateQueue(uninitializedFiber);\n            return root;\n        }\n        var ReactVersion = '19.0.0-rc-935180c7e0-20240524';\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return '' + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function createPortal(children, containerInfo, implementation) {\n            var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n            {\n                checkKeyStringCoercion(key);\n            }\n            return {\n                // This tag allow us to uniquely identify this as a React Portal\n                $$typeof: REACT_PORTAL_TYPE,\n                key: key == null ? null : '' + key,\n                children: children,\n                containerInfo: containerInfo,\n                implementation: implementation\n            };\n        }\n        // Might add PROFILE later.\n        var didWarnAboutNestedUpdates;\n        var didWarnAboutFindNodeInStrictMode;\n        {\n            didWarnAboutNestedUpdates = false;\n            didWarnAboutFindNodeInStrictMode = {};\n        }\n        function getContextForSubtree(parentComponent) {\n            if (!parentComponent) {\n                return emptyContextObject;\n            }\n            var fiber = get(parentComponent);\n            var parentContext = findCurrentUnmaskedContext();\n            if (fiber.tag === ClassComponent) {\n                var Component = fiber.type;\n                if (isContextProvider()) {\n                    return processChildContext(fiber, Component, parentContext);\n                }\n            }\n            return parentContext;\n        }\n        function findHostInstance(component) {\n            var fiber = get(component);\n            if (fiber === undefined) {\n                if (typeof component.render === 'function') {\n                    throw new Error('Unable to find node on an unmounted component.');\n                } else {\n                    var keys = Object.keys(component).join(',');\n                    throw new Error(\"Argument appears to not be a ReactComponent. Keys: \" + keys);\n                }\n            }\n            var hostFiber = findCurrentHostFiber(fiber);\n            if (hostFiber === null) {\n                return null;\n            }\n            return getPublicInstance(hostFiber.stateNode);\n        }\n        function findHostInstanceWithWarning(component, methodName) {\n            {\n                var fiber = get(component);\n                if (fiber === undefined) {\n                    if (typeof component.render === 'function') {\n                        throw new Error('Unable to find node on an unmounted component.');\n                    } else {\n                        var keys = Object.keys(component).join(',');\n                        throw new Error(\"Argument appears to not be a ReactComponent. Keys: \" + keys);\n                    }\n                }\n                var hostFiber = findCurrentHostFiber(fiber);\n                if (hostFiber === null) {\n                    return null;\n                }\n                if (hostFiber.mode & StrictLegacyMode) {\n                    var componentName = getComponentNameFromFiber(fiber) || 'Component';\n                    if (!didWarnAboutFindNodeInStrictMode[componentName]) {\n                        didWarnAboutFindNodeInStrictMode[componentName] = true;\n                        var previousFiber = current;\n                        try {\n                            setCurrentDebugFiberInDEV(hostFiber);\n                            if (fiber.mode & StrictLegacyMode) {\n                                error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which is inside StrictMode. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://react.dev/link/strict-mode-find-node', methodName, methodName, componentName);\n                            } else {\n                                error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which renders StrictMode children. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://react.dev/link/strict-mode-find-node', methodName, methodName, componentName);\n                            }\n                        } finally{\n                            // Ideally this should reset to previous but this shouldn't be called in\n                            // render and there's another warning for that anyway.\n                            if (previousFiber) {\n                                setCurrentDebugFiberInDEV(previousFiber);\n                            } else {\n                                resetCurrentDebugFiberInDEV();\n                            }\n                        }\n                    }\n                }\n                return getPublicInstance(hostFiber.stateNode);\n            }\n        }\n        function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks) {\n            var hydrate = false;\n            var initialChildren = null;\n            return createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, null);\n        }\n        function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {\n            var hydrate = true;\n            var root = createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState); // TODO: Move this to FiberRoot constructor\n            root.context = getContextForSubtree(null); // Schedule the initial render. In a hydration root, this is different from\n            // a regular update because the initial render must match was was rendered\n            // on the server.\n            // NOTE: This update intentionally doesn't have a payload. We're only using\n            // the update to schedule work on the root fiber (and, for legacy roots, to\n            // enqueue the callback if one is provided).\n            var current = root.current;\n            var lane = requestUpdateLane(current);\n            var update = createUpdate(lane);\n            update.callback = callback !== undefined && callback !== null ? callback : null;\n            enqueueUpdate(current, update, lane);\n            scheduleInitialHydrationOnRoot(root, lane);\n            return root;\n        }\n        function updateContainer(element, container, parentComponent, callback) {\n            var current = container.current;\n            var lane = requestUpdateLane(current);\n            updateContainerImpl(current, lane, element, container, parentComponent, callback);\n            return lane;\n        }\n        function updateContainerSync(element, container, parentComponent, callback) {\n            if (container.tag === LegacyRoot) {\n                flushPassiveEffects();\n            }\n            var current = container.current;\n            updateContainerImpl(current, SyncLane, element, container, parentComponent, callback);\n            return SyncLane;\n        }\n        function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {\n            {\n                onScheduleRoot(container, element);\n            }\n            {\n                markRenderScheduled(lane);\n            }\n            var context = getContextForSubtree(parentComponent);\n            if (container.context === null) {\n                container.context = context;\n            } else {\n                container.pendingContext = context;\n            }\n            {\n                if (isRendering && current !== null && !didWarnAboutNestedUpdates) {\n                    didWarnAboutNestedUpdates = true;\n                    error('Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentNameFromFiber(current) || 'Unknown');\n                }\n            }\n            var update = createUpdate(lane); // Caution: React DevTools currently depends on this property\n            // being called \"element\".\n            update.payload = {\n                element: element\n            };\n            callback = callback === undefined ? null : callback;\n            if (callback !== null) {\n                {\n                    if (typeof callback !== 'function') {\n                        error('Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n                    }\n                }\n                update.callback = callback;\n            }\n            var root = enqueueUpdate(rootFiber, update, lane);\n            if (root !== null) {\n                scheduleUpdateOnFiber(root, rootFiber, lane);\n                entangleTransitions(root, rootFiber, lane);\n            }\n        }\n        function getPublicRootInstance(container) {\n            var containerFiber = container.current;\n            if (!containerFiber.child) {\n                return null;\n            }\n            switch(containerFiber.child.tag){\n                case HostSingleton:\n                case HostComponent:\n                    return getPublicInstance(containerFiber.child.stateNode);\n                default:\n                    return containerFiber.child.stateNode;\n            }\n        }\n        function attemptSynchronousHydration(fiber) {\n            switch(fiber.tag){\n                case HostRoot:\n                    {\n                        var root = fiber.stateNode;\n                        if (isRootDehydrated(root)) {\n                            // Flush the first scheduled \"update\".\n                            var lanes = getHighestPriorityPendingLanes(root);\n                            flushRoot(root, lanes);\n                        }\n                        break;\n                    }\n                case SuspenseComponent:\n                    {\n                        var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                        if (_root !== null) {\n                            scheduleUpdateOnFiber(_root, fiber, SyncLane);\n                        }\n                        flushSyncWork(); // If we're still blocked after this, we need to increase\n                        // the priority of any promises resolving within this\n                        // boundary so that they next attempt also has higher pri.\n                        var retryLane = SyncLane;\n                        markRetryLaneIfNotHydrated(fiber, retryLane);\n                        break;\n                    }\n            }\n        }\n        function markRetryLaneImpl(fiber, retryLane) {\n            var suspenseState = fiber.memoizedState;\n            if (suspenseState !== null && suspenseState.dehydrated !== null) {\n                suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);\n            }\n        } // Increases the priority of thenables when they resolve within this boundary.\n        function markRetryLaneIfNotHydrated(fiber, retryLane) {\n            markRetryLaneImpl(fiber, retryLane);\n            var alternate = fiber.alternate;\n            if (alternate) {\n                markRetryLaneImpl(alternate, retryLane);\n            }\n        }\n        function attemptContinuousHydration(fiber) {\n            if (fiber.tag !== SuspenseComponent) {\n                // We ignore HostRoots here because we can't increase\n                // their priority and they should not suspend on I/O,\n                // since you have to wrap anything that might suspend in\n                // Suspense.\n                return;\n            }\n            var lane = SelectiveHydrationLane;\n            var root = enqueueConcurrentRenderForLane(fiber, lane);\n            if (root !== null) {\n                scheduleUpdateOnFiber(root, fiber, lane);\n            }\n            markRetryLaneIfNotHydrated(fiber, lane);\n        }\n        function attemptHydrationAtCurrentPriority(fiber) {\n            if (fiber.tag !== SuspenseComponent) {\n                // We ignore HostRoots here because we can't increase\n                // their priority other than synchronously flush it.\n                return;\n            }\n            var lane = requestUpdateLane(fiber);\n            var root = enqueueConcurrentRenderForLane(fiber, lane);\n            if (root !== null) {\n                scheduleUpdateOnFiber(root, fiber, lane);\n            }\n            markRetryLaneIfNotHydrated(fiber, lane);\n        }\n        function findHostInstanceWithNoPortals(fiber) {\n            var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n            if (hostFiber === null) {\n                return null;\n            }\n            return getPublicInstance(hostFiber.stateNode);\n        }\n        var shouldErrorImpl = function(fiber) {\n            return null;\n        };\n        function shouldError(fiber) {\n            return shouldErrorImpl(fiber);\n        }\n        var shouldSuspendImpl = function(fiber) {\n            return false;\n        };\n        function shouldSuspend(fiber) {\n            return shouldSuspendImpl(fiber);\n        }\n        var overrideHookState = null;\n        var overrideHookStateDeletePath = null;\n        var overrideHookStateRenamePath = null;\n        var overrideProps = null;\n        var overridePropsDeletePath = null;\n        var overridePropsRenamePath = null;\n        var scheduleUpdate = null;\n        var setErrorHandler = null;\n        var setSuspenseHandler = null;\n        {\n            var copyWithDeleteImpl = function(obj, path, index) {\n                var key = path[index];\n                var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n                if (index + 1 === path.length) {\n                    if (isArray(updated)) {\n                        updated.splice(key, 1);\n                    } else {\n                        delete updated[key];\n                    }\n                    return updated;\n                } // $FlowFixMe[incompatible-use] number or string is fine here\n                updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);\n                return updated;\n            };\n            var copyWithDelete = function(obj, path) {\n                return copyWithDeleteImpl(obj, path, 0);\n            };\n            var copyWithRenameImpl = function(obj, oldPath, newPath, index) {\n                var oldKey = oldPath[index];\n                var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n                if (index + 1 === oldPath.length) {\n                    var newKey = newPath[index]; // $FlowFixMe[incompatible-use] number or string is fine here\n                    updated[newKey] = updated[oldKey];\n                    if (isArray(updated)) {\n                        updated.splice(oldKey, 1);\n                    } else {\n                        delete updated[oldKey];\n                    }\n                } else {\n                    // $FlowFixMe[incompatible-use] number or string is fine here\n                    updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index + 1);\n                }\n                return updated;\n            };\n            var copyWithRename = function(obj, oldPath, newPath) {\n                if (oldPath.length !== newPath.length) {\n                    warn('copyWithRename() expects paths of the same length');\n                    return;\n                } else {\n                    for(var i = 0; i < newPath.length - 1; i++){\n                        if (oldPath[i] !== newPath[i]) {\n                            warn('copyWithRename() expects paths to be the same except for the deepest key');\n                            return;\n                        }\n                    }\n                }\n                return copyWithRenameImpl(obj, oldPath, newPath, 0);\n            };\n            var copyWithSetImpl = function(obj, path, index, value) {\n                if (index >= path.length) {\n                    return value;\n                }\n                var key = path[index];\n                var updated = isArray(obj) ? obj.slice() : assign({}, obj); // $FlowFixMe[incompatible-use] number or string is fine here\n                updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);\n                return updated;\n            };\n            var copyWithSet = function(obj, path, value) {\n                return copyWithSetImpl(obj, path, 0, value);\n            };\n            var findHook = function(fiber, id) {\n                // For now, the \"id\" of stateful hooks is just the stateful hook index.\n                // This may change in the future with e.g. nested hooks.\n                var currentHook = fiber.memoizedState;\n                while(currentHook !== null && id > 0){\n                    currentHook = currentHook.next;\n                    id--;\n                }\n                return currentHook;\n            }; // Support DevTools editable values for useState and useReducer.\n            overrideHookState = function(fiber, id, path, value) {\n                var hook = findHook(fiber, id);\n                if (hook !== null) {\n                    var newState = copyWithSet(hook.memoizedState, path, value);\n                    hook.memoizedState = newState;\n                    hook.baseState = newState; // We aren't actually adding an update to the queue,\n                    // because there is no update we can add for useReducer hooks that won't trigger an error.\n                    // (There's no appropriate action type for DevTools overrides.)\n                    // As a result though, React will see the scheduled update as a noop and bailout.\n                    // Shallow cloning props works as a workaround for now to bypass the bailout check.\n                    fiber.memoizedProps = assign({}, fiber.memoizedProps);\n                    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                    if (root !== null) {\n                        scheduleUpdateOnFiber(root, fiber, SyncLane);\n                    }\n                }\n            };\n            overrideHookStateDeletePath = function(fiber, id, path) {\n                var hook = findHook(fiber, id);\n                if (hook !== null) {\n                    var newState = copyWithDelete(hook.memoizedState, path);\n                    hook.memoizedState = newState;\n                    hook.baseState = newState; // We aren't actually adding an update to the queue,\n                    // because there is no update we can add for useReducer hooks that won't trigger an error.\n                    // (There's no appropriate action type for DevTools overrides.)\n                    // As a result though, React will see the scheduled update as a noop and bailout.\n                    // Shallow cloning props works as a workaround for now to bypass the bailout check.\n                    fiber.memoizedProps = assign({}, fiber.memoizedProps);\n                    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                    if (root !== null) {\n                        scheduleUpdateOnFiber(root, fiber, SyncLane);\n                    }\n                }\n            };\n            overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {\n                var hook = findHook(fiber, id);\n                if (hook !== null) {\n                    var newState = copyWithRename(hook.memoizedState, oldPath, newPath);\n                    hook.memoizedState = newState;\n                    hook.baseState = newState; // We aren't actually adding an update to the queue,\n                    // because there is no update we can add for useReducer hooks that won't trigger an error.\n                    // (There's no appropriate action type for DevTools overrides.)\n                    // As a result though, React will see the scheduled update as a noop and bailout.\n                    // Shallow cloning props works as a workaround for now to bypass the bailout check.\n                    fiber.memoizedProps = assign({}, fiber.memoizedProps);\n                    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                    if (root !== null) {\n                        scheduleUpdateOnFiber(root, fiber, SyncLane);\n                    }\n                }\n            }; // Support DevTools props for function components, forwardRef, memo, host components, etc.\n            overrideProps = function(fiber, path, value) {\n                fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);\n                if (fiber.alternate) {\n                    fiber.alternate.pendingProps = fiber.pendingProps;\n                }\n                var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, SyncLane);\n                }\n            };\n            overridePropsDeletePath = function(fiber, path) {\n                fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);\n                if (fiber.alternate) {\n                    fiber.alternate.pendingProps = fiber.pendingProps;\n                }\n                var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, SyncLane);\n                }\n            };\n            overridePropsRenamePath = function(fiber, oldPath, newPath) {\n                fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);\n                if (fiber.alternate) {\n                    fiber.alternate.pendingProps = fiber.pendingProps;\n                }\n                var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, SyncLane);\n                }\n            };\n            scheduleUpdate = function(fiber) {\n                var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, SyncLane);\n                }\n            };\n            setErrorHandler = function(newShouldErrorImpl) {\n                shouldErrorImpl = newShouldErrorImpl;\n            };\n            setSuspenseHandler = function(newShouldSuspendImpl) {\n                shouldSuspendImpl = newShouldSuspendImpl;\n            };\n        }\n        function findHostInstanceByFiber(fiber) {\n            var hostFiber = findCurrentHostFiber(fiber);\n            if (hostFiber === null) {\n                return null;\n            }\n            return hostFiber.stateNode;\n        }\n        function emptyFindFiberByHostInstance(instance) {\n            return null;\n        }\n        function getCurrentFiberForDevTools() {\n            return current;\n        }\n        function injectIntoDevTools(devToolsConfig) {\n            var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n            return injectInternals({\n                bundleType: devToolsConfig.bundleType,\n                version: devToolsConfig.version,\n                rendererPackageName: devToolsConfig.rendererPackageName,\n                rendererConfig: devToolsConfig.rendererConfig,\n                overrideHookState: overrideHookState,\n                overrideHookStateDeletePath: overrideHookStateDeletePath,\n                overrideHookStateRenamePath: overrideHookStateRenamePath,\n                overrideProps: overrideProps,\n                overridePropsDeletePath: overridePropsDeletePath,\n                overridePropsRenamePath: overridePropsRenamePath,\n                setErrorHandler: setErrorHandler,\n                setSuspenseHandler: setSuspenseHandler,\n                scheduleUpdate: scheduleUpdate,\n                currentDispatcherRef: ReactSharedInternals,\n                findHostInstanceByFiber: findHostInstanceByFiber,\n                findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,\n                // React Refresh\n                findHostInstancesForRefresh: findHostInstancesForRefresh,\n                scheduleRefresh: scheduleRefresh,\n                scheduleRoot: scheduleRoot,\n                setRefreshHandler: setRefreshHandler,\n                // Enables DevTools to append owner stacks to error messages in DEV mode.\n                getCurrentFiber: getCurrentFiberForDevTools,\n                // Enables DevTools to detect reconciler version rather than renderer version\n                // which may not match for third party renderers.\n                reconcilerVersion: ReactVersion\n            });\n        }\n        exports.attemptContinuousHydration = attemptContinuousHydration;\n        exports.attemptHydrationAtCurrentPriority = attemptHydrationAtCurrentPriority;\n        exports.attemptSynchronousHydration = attemptSynchronousHydration;\n        exports.batchedUpdates = batchedUpdates;\n        exports.createComponentSelector = createComponentSelector;\n        exports.createContainer = createContainer;\n        exports.createHasPseudoClassSelector = createHasPseudoClassSelector;\n        exports.createHydrationContainer = createHydrationContainer;\n        exports.createPortal = createPortal;\n        exports.createRoleSelector = createRoleSelector;\n        exports.createTestNameSelector = createTestNameSelector;\n        exports.createTextSelector = createTextSelector;\n        exports.defaultOnCaughtError = defaultOnCaughtError;\n        exports.defaultOnRecoverableError = defaultOnRecoverableError;\n        exports.defaultOnUncaughtError = defaultOnUncaughtError;\n        exports.deferredUpdates = deferredUpdates;\n        exports.discreteUpdates = discreteUpdates;\n        exports.findAllNodes = findAllNodes;\n        exports.findBoundingRects = findBoundingRects;\n        exports.findHostInstance = findHostInstance;\n        exports.findHostInstanceWithNoPortals = findHostInstanceWithNoPortals;\n        exports.findHostInstanceWithWarning = findHostInstanceWithWarning;\n        exports.flushPassiveEffects = flushPassiveEffects;\n        exports.flushSyncFromReconciler = flushSyncFromReconciler;\n        exports.flushSyncWork = flushSyncWork;\n        exports.focusWithin = focusWithin;\n        exports.getFindAllNodesFailureDescription = getFindAllNodesFailureDescription;\n        exports.getPublicRootInstance = getPublicRootInstance;\n        exports.injectIntoDevTools = injectIntoDevTools;\n        exports.isAlreadyRendering = isAlreadyRendering;\n        exports.observeVisibleRects = observeVisibleRects;\n        exports.shouldError = shouldError;\n        exports.shouldSuspend = shouldSuspend;\n        exports.startHostTransition = startHostTransition;\n        exports.updateContainer = updateContainer;\n        exports.updateContainerSync = updateContainerSync;\n        return exports;\n    };\n    module.exports[\"default\"] = module.exports;\n    Object.defineProperty(module.exports, \"__esModule\", ({\n        value: true\n    }));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtcmVjb25jaWxlckAwLjMxLjAtcmMtOTM1MTgwYzdlMC0yMDI0MDUyNF9yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL3JlYWN0LXJlY29uY2lsZXIvY2pzL3JlYWN0LXJlY29uY2lsZXIuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0NBUUMsR0FFWTtBQUViLElBQUlBLElBQXFDLEVBQUU7SUFDekNDLE9BQU9DLE9BQU8sR0FBRyxTQUFTQyxjQUFjQyxTQUFTO1FBQy9DLElBQUlGLFVBQVUsQ0FBQztRQUNuQjtRQUVBLElBQUlHLFFBQVFDLG1CQUFPQSxDQUFDLDhKQUFPO1FBQzNCLElBQUlDLFlBQVlELG1CQUFPQSxDQUFDLHFIQUFXO1FBRW5DLElBQUlFLHVCQUF1QkgsTUFBTUksK0RBQStEO1FBRWhHLElBQUlDLGtCQUFrQjtRQUN0QixTQUFTQyxtQkFBbUJDLGtCQUFrQjtZQUM1QztnQkFDRUYsa0JBQWtCRTtZQUNwQjtRQUNGLEVBQUUsK0RBQStEO1FBQ2pFLCtDQUErQztRQUMvQyxFQUFFO1FBQ0YsOERBQThEO1FBQzlELHFDQUFxQztRQUVyQyxTQUFTQyxLQUFLQyxNQUFNO1lBQ2xCO2dCQUNFLElBQUksQ0FBQ0osaUJBQWlCO29CQUNwQixJQUFLLElBQUlLLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsT0FBTyxJQUFJQyxNQUFNSixPQUFPLElBQUlBLE9BQU8sSUFBSSxJQUFJSyxPQUFPLEdBQUdBLE9BQU9MLE1BQU1LLE9BQVE7d0JBQzFHRixJQUFJLENBQUNFLE9BQU8sRUFBRSxHQUFHSixTQUFTLENBQUNJLEtBQUs7b0JBQ2xDO29CQUVBQyxhQUFhLFFBQVFQLFFBQVFJO2dCQUMvQjtZQUNGO1FBQ0Y7UUFDQSxTQUFTSSxNQUFNUixNQUFNO1lBQ25CO2dCQUNFLElBQUksQ0FBQ0osaUJBQWlCO29CQUNwQixJQUFLLElBQUlhLFFBQVFQLFVBQVVDLE1BQU0sRUFBRUMs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b0Q7UUFBRU8sT0FBTztJQUFLLENBQUMsRUFBQztBQUN0RSIsInNvdXJjZXMiOlsiL1VzZXJzL21obWQvRG9jdW1lbnRzL0dpdEh1Yi9BV00tTGFiZWViLUFpL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1yZWNvbmNpbGVyQDAuMzEuMC1yYy05MzUxODBjN2UwLTIwMjQwNTI0X3JlYWN0QDE5LjAuMC9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9janMvcmVhY3QtcmVjb25jaWxlci5kZXZlbG9wbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1yZWNvbmNpbGVyLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAkJCRyZWNvbmNpbGVyKCQkJGNvbmZpZykge1xuICAgIHZhciBleHBvcnRzID0ge307XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgU2NoZWR1bGVyID0gcmVxdWlyZSgnc2NoZWR1bGVyJyk7XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fQ0xJRU5UX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1dBUk5fVVNFUlNfVEhFWV9DQU5OT1RfVVBHUkFERTtcblxudmFyIHN1cHByZXNzV2FybmluZyA9IGZhbHNlO1xuZnVuY3Rpb24gc2V0U3VwcHJlc3NXYXJuaW5nKG5ld1N1cHByZXNzV2FybmluZykge1xuICB7XG4gICAgc3VwcHJlc3NXYXJuaW5nID0gbmV3U3VwcHJlc3NXYXJuaW5nO1xuICB9XG59IC8vIEluIERFViwgY2FsbHMgdG8gY29uc29sZS53YXJuIGFuZCBjb25zb2xlLmVycm9yIGdldCByZXBsYWNlZFxuLy8gYnkgY2FsbHMgdG8gdGhlc2UgbWV0aG9kcyBieSBhIEJhYmVsIHBsdWdpbi5cbi8vXG4vLyBJbiBQUk9EIChvciBpbiBwYWNrYWdlcyB3aXRob3V0IGFjY2VzcyB0byBSZWFjdCBpbnRlcm5hbHMpLFxuLy8gdGhleSBhcmUgbGVmdCBhcyB0aGV5IGFyZSBpbnN0ZWFkLlxuXG5mdW5jdGlvbiB3YXJuKGZvcm1hdCkge1xuICB7XG4gICAgaWYgKCFzdXBwcmVzc1dhcm5pbmcpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnd2FybicsIGZvcm1hdCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIGlmICghc3VwcHJlc3NXYXJuaW5nKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIGlzRXJyb3JMb2dnZXIgPSBmb3JtYXQgPT09ICclc1xcblxcbiVzXFxuJyB8fCBmb3JtYXQgPT09ICclb1xcblxcbiVzXFxuXFxuJXNcXG4nO1xuXG4gICAgaWYgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjaykge1xuICAgICAgdmFyIHN0YWNrID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrKCk7XG5cbiAgICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNFcnJvckxvZ2dlcikge1xuICAgICAgLy8gRG9uJ3QgcHJlZml4IG91ciBkZWZhdWx0IGxvZ2dpbmcgZm9ybWF0dGluZyBpbiBSZWFjdEZpYmVyRXJyb3JMb2dnZ2VyLlxuICAgICAgLy8gRG9uJ3QgdG9TdHJpbmcgdGhlIGFyZ3VtZW50cy5cbiAgICAgIGFyZ3MudW5zaGlmdChmb3JtYXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBwcmVmaXggYW5kIHN0b3AgdG9TdHJpbmdpbmcgaW4gdGhlIHdyYXBwZXIgYW5kXG4gICAgICAvLyBpbnN0ZWFkIGRvIGl0IGF0IGVhY2ggY2FsbHNpdGUgYXMgbmVlZGVkLlxuICAgICAgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgICAgYXJncyA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgICB9KTtcbiAgICAgIGFyZ3MudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7XG4gICAgfSAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzKTtcbiAgfVxufVxuXG52YXIgYXNzaWduID0gT2JqZWN0LmFzc2lnbjtcblxudmFyIExlZ2FjeVJvb3QgPSAwO1xudmFyIENvbmN1cnJlbnRSb290ID0gMTtcblxuLyoqXG4gKiBgUmVhY3RJbnN0YW5jZU1hcGAgbWFpbnRhaW5zIGEgbWFwcGluZyBmcm9tIGEgcHVibGljIGZhY2luZyBzdGF0ZWZ1bFxuICogaW5zdGFuY2UgKGtleSkgYW5kIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiAodmFsdWUpLiBUaGlzIGFsbG93cyBwdWJsaWNcbiAqIG1ldGhvZHMgdG8gYWNjZXB0IHRoZSB1c2VyIGZhY2luZyBpbnN0YW5jZSBhcyBhbiBhcmd1bWVudCBhbmQgbWFwIHRoZW0gYmFja1xuICogdG8gaW50ZXJuYWwgbWV0aG9kcy5cbiAqXG4gKiBOb3RlIHRoYXQgdGhpcyBtb2R1bGUgaXMgY3VycmVudGx5IHNoYXJlZCBhbmQgYXNzdW1lZCB0byBiZSBzdGF0ZWxlc3MuXG4gKiBJZiB0aGlzIGJlY29tZXMgYW4gYWN0dWFsIE1hcCwgdGhhdCB3aWxsIGJyZWFrLlxuICovXG5mdW5jdGlvbiBnZXQoa2V5KSB7XG4gIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxzO1xufVxuZnVuY3Rpb24gc2V0KGtleSwgdmFsdWUpIHtcbiAga2V5Ll9yZWFjdEludGVybmFscyA9IHZhbHVlO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gS2lsbHN3aXRjaFxuLy9cbi8vIEZsYWdzIHRoYXQgZXhpc3Qgc29sZWx5IHRvIHR1cm4gb2ZmIGEgY2hhbmdlIGluIGNhc2UgaXQgY2F1c2VzIGEgcmVncmVzc2lvblxuLy8gd2hlbiBpdCByb2xscyBvdXQgdG8gcHJvZC4gV2Ugc2hvdWxkIHJlbW92ZSB0aGVzZSBhcyBzb29uIGFzIHBvc3NpYmxlLlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBMYW5kIG9yIHJlbW92ZSAobW9kZXJhdGUgZWZmb3J0KVxuLy9cbi8vIEZsYWdzIHRoYXQgY2FuIGJlIHByb2JhYmx5IGRlbGV0ZWQgb3IgbGFuZGVkLCBidXQgbWlnaHQgcmVxdWlyZSBleHRyYSBlZmZvcnRcbi8vIGxpa2UgbWlncmF0aW5nIGludGVybmFsIGNhbGxlcnMgb3IgcGVyZm9ybWFuY2UgdGVzdGluZy5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUT0RPOiBGaW5pc2ggcm9sbGluZyBvdXQgaW4gd3d3XG5cbnZhciBmYXZvclNhZmV0eU92ZXJIeWRyYXRpb25QZXJmID0gdHJ1ZTtcbnZhciBlbmFibGVBc3luY0FjdGlvbnMgPSB0cnVlOyAvLyBOZWVkIHRvIHJlbW92ZSBkaWRUaW1lb3V0IGFyZ3VtZW50IGZyb20gU2NoZWR1bGVyIGJlZm9yZSBsYW5kaW5nXG5cbnZhciBkaXNhYmxlRGVmYXVsdFByb3BzRXhjZXB0Rm9yQ2xhc3NlcyA9IHRydWU7IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBTbGF0ZWQgZm9yIHJlbW92YWwgaW4gdGhlIGZ1dHVyZSAoc2lnbmlmaWNhbnQgZWZmb3J0KVxuLy9cbi8vIFRoZXNlIGFyZSBleHBlcmltZW50cyB0aGF0IGRpZG4ndCB3b3JrIG91dCwgYW5kIG5ldmVyIHNoaXBwZWQsIGJ1dCB3ZSBjYW4ndFxuLy8gZGVsZXRlIGZyb20gdGhlIGNvZGViYXNlIHVudGlsIHdlIG1pZ3JhdGUgaW50ZXJuYWwgY2FsbGVycy5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBBZGQgYSBjYWxsYmFjayBwcm9wZXJ0eSB0byBzdXNwZW5zZSB0byBub3RpZnkgd2hpY2ggcHJvbWlzZXMgYXJlIGN1cnJlbnRseVxuLy8gaW4gdGhlIHVwZGF0ZSBxdWV1ZS4gVGhpcyBhbGxvd3MgcmVwb3J0aW5nIGFuZCB0cmFjaW5nIG9mIHdoYXQgaXMgY2F1c2luZ1xuLy8gdGhlIHVzZXIgdG8gc2VlIGEgbG9hZGluZyBzdGF0ZS5cbi8vXG4vLyBBbHNvIGFsbG93cyBoeWRyYXRpb24gY2FsbGJhY2tzIHRvIGZpcmUgd2hlbiBhIGRlaHlkcmF0ZWQgYm91bmRhcnkgZ2V0c1xuLy8gaHlkcmF0ZWQgb3IgZGVsZXRlZC5cbi8vXG4vLyBUaGlzIHdpbGwgZXZlbnR1YWxseSBiZSByZXBsYWNlZCBieSB0aGUgVHJhbnNpdGlvbiBUcmFjaW5nIHByb3Bvc2FsLlxuXG52YXIgZW5hYmxlU3VzcGVuc2VDYWxsYmFjayA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgU2NvcGUgc3VwcG9ydC5cbnZhciBlbmFibGVBc3luY0l0ZXJhYmxlQ2hpbGRyZW4gPSBmYWxzZTtcblxudmFyIGVuYWJsZUxhenlDb250ZXh0UHJvcGFnYXRpb24gPSBmYWxzZTsgLy8gRkItb25seSB1c2FnZS4gVGhlIG5ldyBBUEkgaGFzIGRpZmZlcmVudCBzZW1hbnRpY3MuXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG52YXIgYWx3YXlzVGhyb3R0bGVSZXRyaWVzID0gdHJ1ZTtcbnZhciBwYXNzQ2hpbGRyZW5XaGVuQ2xvbmluZ1BlcnNpc3RlZE5vZGVzID0gZmFsc2U7XG52YXIgc3luY0xhbmVFeHBpcmF0aW9uTXMgPSAyNTA7XG52YXIgdHJhbnNpdGlvbkxhbmVFeHBpcmF0aW9uTXMgPSA1MDAwOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gVGhpcyBhbGxvd3MgdXMgdG8gbGFuZCBicmVha2luZyBjaGFuZ2VzIHRvIHJlbW92ZSBsZWdhY3kgbW9kZSBBUElzIGluIGV4cGVyaW1lbnRhbCBidWlsZHNcbi8vIGJlZm9yZSByZW1vdmluZyB0aGVtIGluIHN0YWJsZSBpbiB0aGUgbmV4dCBNYWpvclxuXG52YXIgZGlzYWJsZUxlZ2FjeU1vZGUgPSB0cnVlO1xuLy8gRGVidWdnaW5nIGFuZCBEZXZUb29sc1xuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEFkZHMgdXNlciB0aW1pbmcgbWFya3MgZm9yIGUuZy4gc3RhdGUgdXBkYXRlcywgc3VzcGVuc2UsIGFuZCB3b3JrIGxvb3Agc3R1ZmYsXG4vLyBmb3IgYW4gZXhwZXJpbWVudGFsIHRpbWVsaW5lIHRvb2wuXG5cbnZhciBlbmFibGVTY2hlZHVsaW5nUHJvZmlsZXIgPSB0cnVlOyAvLyBIZWxwcyBpZGVudGlmeSBzaWRlIGVmZmVjdHMgaW4gcmVuZGVyLXBoYXNlIGxpZmVjeWNsZSBob29rcyBhbmQgc2V0U3RhdGVcblxudmFyIGVuYWJsZVByb2ZpbGVyVGltZXIgPSB0cnVlOyAvLyBSZWNvcmQgZHVyYXRpb25zIGZvciBjb21taXQgYW5kIHBhc3NpdmUgZWZmZWN0cyBwaGFzZXMuXG5cbnZhciBlbmFibGVQcm9maWxlckNvbW1pdEhvb2tzID0gdHJ1ZTsgLy8gUGhhc2UgcGFyYW0gcGFzc2VkIHRvIG9uUmVuZGVyIGNhbGxiYWNrIGRpZmZlcmVudGlhdGVzIGJldHdlZW4gYW4gXCJ1cGRhdGVcIiBhbmQgYSBcImNhc2NhZGluZy11cGRhdGVcIi5cblxudmFyIGVuYWJsZVByb2ZpbGVyTmVzdGVkVXBkYXRlUGhhc2UgPSB0cnVlOyAvLyBBZGRzIHZlcmJvc2UgY29uc29sZSBsb2dnaW5nIGZvciBlLmcuIHN0YXRlIHVwZGF0ZXMsIHN1c3BlbnNlLCBhbmQgd29yayBsb29wXG5cbnZhciBGdW5jdGlvbkNvbXBvbmVudCA9IDA7XG52YXIgQ2xhc3NDb21wb25lbnQgPSAxO1xudmFyIEhvc3RSb290ID0gMzsgLy8gUm9vdCBvZiBhIGhvc3QgdHJlZS4gQ291bGQgYmUgbmVzdGVkIGluc2lkZSBhbm90aGVyIG5vZGUuXG5cbnZhciBIb3N0UG9ydGFsID0gNDsgLy8gQSBzdWJ0cmVlLiBDb3VsZCBiZSBhbiBlbnRyeSBwb2ludCB0byBhIGRpZmZlcmVudCByZW5kZXJlci5cblxudmFyIEhvc3RDb21wb25lbnQgPSA1O1xudmFyIEhvc3RUZXh0ID0gNjtcbnZhciBGcmFnbWVudCA9IDc7XG52YXIgTW9kZSA9IDg7XG52YXIgQ29udGV4dENvbnN1bWVyID0gOTtcbnZhciBDb250ZXh0UHJvdmlkZXIgPSAxMDtcbnZhciBGb3J3YXJkUmVmID0gMTE7XG52YXIgUHJvZmlsZXIgPSAxMjtcbnZhciBTdXNwZW5zZUNvbXBvbmVudCA9IDEzO1xudmFyIE1lbW9Db21wb25lbnQgPSAxNDtcbnZhciBTaW1wbGVNZW1vQ29tcG9uZW50ID0gMTU7XG52YXIgTGF6eUNvbXBvbmVudCA9IDE2O1xudmFyIEluY29tcGxldGVDbGFzc0NvbXBvbmVudCA9IDE3O1xudmFyIERlaHlkcmF0ZWRGcmFnbWVudCA9IDE4O1xudmFyIFN1c3BlbnNlTGlzdENvbXBvbmVudCA9IDE5O1xudmFyIFNjb3BlQ29tcG9uZW50ID0gMjE7XG52YXIgT2Zmc2NyZWVuQ29tcG9uZW50ID0gMjI7XG52YXIgTGVnYWN5SGlkZGVuQ29tcG9uZW50ID0gMjM7XG52YXIgQ2FjaGVDb21wb25lbnQgPSAyNDtcbnZhciBUcmFjaW5nTWFya2VyQ29tcG9uZW50ID0gMjU7XG52YXIgSG9zdEhvaXN0YWJsZSA9IDI2O1xudmFyIEhvc3RTaW5nbGV0b24gPSAyNztcbnZhciBJbmNvbXBsZXRlRnVuY3Rpb25Db21wb25lbnQgPSAyODtcblxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG5cbnZhciBSRUFDVF9MRUdBQ1lfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnRyYW5zaXRpb25hbC5lbGVtZW50JykgO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7IC8vIFRPRE86IERlbGV0ZSB3aXRoIGVuYWJsZVJlbmRlcmFibGVDb250ZXh0XG5cbnZhciBSRUFDVF9DT05TVU1FUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29uc3VtZXInKTtcbnZhciBSRUFDVF9DT05URVhUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb250ZXh0Jyk7XG52YXIgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZvcndhcmRfcmVmJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlJyk7XG52YXIgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2VfbGlzdCcpO1xudmFyIFJFQUNUX01FTU9fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW8nKTtcbnZhciBSRUFDVF9MQVpZX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sYXp5Jyk7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnNjb3BlJyk7XG52YXIgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5kZWJ1Z190cmFjZV9tb2RlJyk7XG52YXIgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5vZmZzY3JlZW4nKTtcbnZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5sZWdhY3lfaGlkZGVuJyk7XG52YXIgUkVBQ1RfVFJBQ0lOR19NQVJLRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnRyYWNpbmdfbWFya2VyJyk7XG52YXIgUkVBQ1RfTUVNT19DQUNIRV9TRU5USU5FTCA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm1lbW9fY2FjaGVfc2VudGluZWwnKTtcbnZhciBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgPSBTeW1ib2wuaXRlcmF0b3I7XG52YXIgRkFVWF9JVEVSQVRPUl9TWU1CT0wgPSAnQEBpdGVyYXRvcic7XG5mdW5jdGlvbiBnZXRJdGVyYXRvckZuKG1heWJlSXRlcmFibGUpIHtcbiAgaWYgKG1heWJlSXRlcmFibGUgPT09IG51bGwgfHwgdHlwZW9mIG1heWJlSXRlcmFibGUgIT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgbWF5YmVJdGVyYXRvciA9IE1BWUJFX0lURVJBVE9SX1NZTUJPTCAmJiBtYXliZUl0ZXJhYmxlW01BWUJFX0lURVJBVE9SX1NZTUJPTF0gfHwgbWF5YmVJdGVyYWJsZVtGQVVYX0lURVJBVE9SX1NZTUJPTF07XG5cbiAgaWYgKHR5cGVvZiBtYXliZUl0ZXJhdG9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIG1heWJlSXRlcmF0b3I7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUkMShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lO1xuXG4gIGlmIChkaXNwbGF5TmFtZSkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgfVxuXG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG59IC8vIEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJlY29uY2lsZXIvZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlclxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lJDEodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFID0gU3ltYm9sLmZvcigncmVhY3QuY2xpZW50LnJlZmVyZW5jZScpOyAvLyBOb3RlIHRoYXQgdGhlIHJlY29uY2lsZXIgcGFja2FnZSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcigpIGluc3RlYWQuXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICAvLyBUT0RPOiBDcmVhdGUgYSBjb252ZW50aW9uIGZvciBuYW1pbmcgY2xpZW50IHJlZmVyZW5jZXMgd2l0aCBkZWJ1ZyBpbmZvLlxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuXG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSgpLiAnICsgJ1RoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG5cbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZSQxKGNvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05TVU1FUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGNvbnN1bWVyID0gdHlwZTtcbiAgICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUkMShjb25zdW1lci5fY29udGV4dCkgKyAnLkNvbnN1bWVyJztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSQxKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgdmFyIG91dGVyTmFtZSA9IHR5cGUuZGlzcGxheU5hbWUgfHwgbnVsbDtcblxuICAgICAgICBpZiAob3V0ZXJOYW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG91dGVyTmFtZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnTWVtbyc7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0V3JhcHBlZE5hbWUob3V0ZXJUeXBlLCBpbm5lclR5cGUsIHdyYXBwZXJOYW1lKSB7XG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBvdXRlclR5cGUuZGlzcGxheU5hbWUgfHwgKGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZSk7XG59IC8vIEtlZXAgaW4gc3luYyB3aXRoIHNoYXJlZC9nZXRDb21wb25lbnROYW1lRnJvbVR5cGVcblxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21Pd25lcihvd25lcikge1xuICBpZiAodHlwZW9mIG93bmVyLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihvd25lcik7XG4gIH1cblxuICBpZiAodHlwZW9mIG93bmVyLm5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIG93bmVyLm5hbWU7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHtcbiAgdmFyIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgIHR5cGUgPSBmaWJlci50eXBlO1xuXG4gIHN3aXRjaCAodGFnKSB7XG4gICAgY2FzZSBDYWNoZUNvbXBvbmVudDpcbiAgICAgIHJldHVybiAnQ2FjaGUnO1xuXG4gICAgY2FzZSBDb250ZXh0Q29uc3VtZXI6XG4gICAgICB7XG4gICAgICAgIHZhciBjb25zdW1lciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb25zdW1lci5fY29udGV4dCkgKyAnLkNvbnN1bWVyJztcbiAgICAgIH1cblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAge1xuICAgICAgICB2YXIgX2NvbnRleHQgPSB0eXBlO1xuICAgICAgICByZXR1cm4gZ2V0Q29udGV4dE5hbWUoX2NvbnRleHQpICsgJy5Qcm92aWRlcic7XG4gICAgICB9XG5cbiAgICBjYXNlIERlaHlkcmF0ZWRGcmFnbWVudDpcbiAgICAgIHJldHVybiAnRGVoeWRyYXRlZEZyYWdtZW50JztcblxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgSG9zdEhvaXN0YWJsZTpcbiAgICBjYXNlIEhvc3RTaW5nbGV0b246XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgLy8gSG9zdCBjb21wb25lbnQgdHlwZSBpcyB0aGUgZGlzcGxheSBuYW1lIChlLmcuIFwiZGl2XCIsIFwiVmlld1wiKVxuICAgICAgcmV0dXJuIHR5cGU7XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAgcmV0dXJuICdSb290JztcblxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICByZXR1cm4gJ1RleHQnO1xuXG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgICAgLy8gTmFtZSBjb21lcyBmcm9tIHRoZSB0eXBlIGluIHRoaXMgY2FzZTsgd2UgZG9uJ3QgaGF2ZSBhIHRhZy5cbiAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG5cbiAgICBjYXNlIE1vZGU6XG4gICAgICBpZiAodHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRSkge1xuICAgICAgICAvLyBEb24ndCBiZSBsZXNzIHNwZWNpZmljIHRoYW4gc2hhcmVkL2dldENvbXBvbmVudE5hbWVGcm9tVHlwZVxuICAgICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ01vZGUnO1xuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICByZXR1cm4gJ09mZnNjcmVlbic7XG5cbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAgcmV0dXJuICdTY29wZSc7XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgVHJhY2luZ01hcmtlckNvbXBvbmVudDpcbiAgICAgIHJldHVybiAnVHJhY2luZ01hcmtlcic7XG4gICAgLy8gVGhlIGRpc3BsYXkgbmFtZSBmb3IgdGhlc2UgdGFncyBjb21lIGZyb20gdGhlIHVzZXItcHJvdmlkZWQgdHlwZTpcblxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgIGNhc2UgSW5jb21wbGV0ZUZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIC8vIEZhbGx0aHJvdWdoXG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgTm9GbGFncyQxID1cbi8qICAgICAgICAgICAgICAgICAgICAgICovXG4wO1xudmFyIFBlcmZvcm1lZFdvcmsgPVxuLyogICAgICAgICAgICAgICAgKi9cbjE7XG52YXIgUGxhY2VtZW50ID1cbi8qICAgICAgICAgICAgICAgICAgICAqL1xuMjtcbnZhciBEaWRDYXB0dXJlID1cbi8qICAgICAgICAgICAgICAgICAgICovXG4xMjg7XG52YXIgSHlkcmF0aW5nID1cbi8qICAgICAgICAgICAgICAgICAgICAqL1xuNDA5NjsgLy8gWW91IGNhbiBjaGFuZ2UgdGhlIHJlc3QgKGFuZCBhZGQgbW9yZSkuXG5cbnZhciBVcGRhdGUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG40O1xuLyogU2tpcHBlZCB2YWx1ZTogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwYjAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDA7ICovXG5cbnZhciBDaGlsZERlbGV0aW9uID1cbi8qICAgICAgICAgICAgICAgICovXG4xNjtcbnZhciBDb250ZW50UmVzZXQgPVxuLyogICAgICAgICAgICAgICAgICovXG4zMjtcbnZhciBDYWxsYmFjayA9XG4vKiAgICAgICAgICAgICAgICAgICAgICovXG42NDtcbi8qIFVzZWQgYnkgRGlkQ2FwdHVyZTogICAgICAgICAgICAgICAgICAgICAgICAgICAgMGIwMDAwMDAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwOyAqL1xuXG52YXIgRm9yY2VDbGllbnRSZW5kZXIgPVxuLyogICAgICAgICAgICAqL1xuMjU2O1xudmFyIFJlZiA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjUxMjtcbnZhciBTbmFwc2hvdCA9XG4vKiAgICAgICAgICAgICAgICAgICAgICovXG4xMDI0O1xudmFyIFBhc3NpdmUkMSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAqL1xuMjA0ODtcbi8qIFVzZWQgYnkgSHlkcmF0aW5nOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMGIwMDAwMDAwMDAwMDAwMDAxMDAwMDAwMDAwMDAwOyAqL1xuXG52YXIgVmlzaWJpbGl0eSA9XG4vKiAgICAgICAgICAgICAgICAgICAqL1xuODE5MjtcbnZhciBTdG9yZUNvbnNpc3RlbmN5ID1cbi8qICAgICAgICAgICAgICovXG4xNjM4NDsgLy8gSXQncyBPSyB0byByZXVzZSB0aGVzZSBiaXRzIGJlY2F1c2UgdGhlc2UgZmxhZ3MgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSBmb3Jcbi8vIGRpZmZlcmVudCBmaWJlciB0eXBlcy4gV2Ugc2hvdWxkIHJlYWxseSBiZSBkb2luZyB0aGlzIGZvciBhcyBtYW55IGZsYWdzIGFzXG4vLyBwb3NzaWJsZSwgYmVjYXVzZSB3ZSdyZSBhYm91dCB0byBydW4gb3V0IG9mIGJpdHMuXG5cbnZhciBTY2hlZHVsZVJldHJ5ID0gU3RvcmVDb25zaXN0ZW5jeTtcbnZhciBTaG91bGRTdXNwZW5kQ29tbWl0ID0gVmlzaWJpbGl0eTtcbnZhciBEaWREZWZlciA9IENvbnRlbnRSZXNldDtcbnZhciBGb3JtUmVzZXQgPSBTbmFwc2hvdDtcblxudmFyIEhvc3RFZmZlY3RNYXNrID1cbi8qICAgICAgICAgICAgICAgKi9cbjMyNzY3OyAvLyBUaGVzZSBhcmUgbm90IHJlYWxseSBzaWRlIGVmZmVjdHMsIGJ1dCB3ZSBzdGlsbCByZXVzZSB0aGlzIGZpZWxkLlxuXG52YXIgSW5jb21wbGV0ZSA9XG4vKiAgICAgICAgICAgICAgICAgICAqL1xuMzI3Njg7XG52YXIgU2hvdWxkQ2FwdHVyZSA9XG4vKiAgICAgICAgICAgICAgICAqL1xuNjU1MzY7XG52YXIgRm9yY2VVcGRhdGVGb3JMZWdhY3lTdXNwZW5zZSA9XG4vKiAqL1xuMTMxMDcyO1xudmFyIEZvcmtlZCA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjEwNDg1NzY7IC8vIFN0YXRpYyB0YWdzIGRlc2NyaWJlIGFzcGVjdHMgb2YgYSBmaWJlciB0aGF0IGFyZSBub3Qgc3BlY2lmaWMgdG8gYSByZW5kZXIsXG4vLyBlLmcuIGEgZmliZXIgdXNlcyBhIHBhc3NpdmUgZWZmZWN0IChldmVuIGlmIHRoZXJlIGFyZSBubyB1cGRhdGVzIG9uIHRoaXMgcGFydGljdWxhciByZW5kZXIpLlxuLy8gVGhpcyBlbmFibGVzIHVzIHRvIGRlZmVyIG1vcmUgd29yayBpbiB0aGUgdW5tb3VudCBjYXNlLFxuLy8gc2luY2Ugd2UgY2FuIGRlZmVyIHRyYXZlcnNpbmcgdGhlIHRyZWUgZHVyaW5nIGxheW91dCB0byBsb29rIGZvciBQYXNzaXZlIGVmZmVjdHMsXG4vLyBhbmQgaW5zdGVhZCByZWx5IG9uIHRoZSBzdGF0aWMgZmxhZyBhcyBhIHNpZ25hbCB0aGF0IHRoZXJlIG1heSBiZSBjbGVhbnVwIHdvcmsuXG5cbnZhciBSZWZTdGF0aWMgPVxuLyogICAgICAgICAgICAgICAgICAgICovXG4yMDk3MTUyO1xudmFyIExheW91dFN0YXRpYyA9XG4vKiAgICAgICAgICAgICAgICAgKi9cbjQxOTQzMDQ7XG52YXIgUGFzc2l2ZVN0YXRpYyA9XG4vKiAgICAgICAgICAgICAgICAqL1xuODM4ODYwODtcbnZhciBNYXlTdXNwZW5kQ29tbWl0ID1cbi8qICAgICAgICAgICAgICovXG4xNjc3NzIxNjsgLy8gRmxhZyB1c2VkIHRvIGlkZW50aWZ5IG5ld2x5IGluc2VydGVkIGZpYmVycy4gSXQgaXNuJ3QgcmVzZXQgYWZ0ZXIgY29tbWl0IHVubGlrZSBgUGxhY2VtZW50YC5cblxudmFyIFBsYWNlbWVudERFViA9XG4vKiAgICAgICAgICAgICAgICAgKi9cbjMzNTU0NDMyO1xudmFyIE1vdW50TGF5b3V0RGV2ID1cbi8qICAgICAgICAgICAgICAgKi9cbjY3MTA4ODY0O1xudmFyIE1vdW50UGFzc2l2ZURldiA9XG4vKiAgICAgICAgICAgICAgKi9cbjEzNDIxNzcyODsgLy8gR3JvdXBzIG9mIGZsYWdzIHRoYXQgYXJlIHVzZWQgaW4gdGhlIGNvbW1pdCBwaGFzZSB0byBza2lwIG92ZXIgdHJlZXMgdGhhdFxuLy8gZG9uJ3QgY29udGFpbiBlZmZlY3RzLCBieSBjaGVja2luZyBzdWJ0cmVlRmxhZ3MuXG5cbnZhciBCZWZvcmVNdXRhdGlvbk1hc2sgPSAvLyBUT0RPOiBSZW1vdmUgVXBkYXRlIGZsYWcgZnJvbSBiZWZvcmUgbXV0YXRpb24gcGhhc2UgYnkgcmUtbGFuZGluZyBWaXNpYmlsaXR5XG4vLyBmbGFnIGxvZ2ljIChzZWUgIzIwMDQzKVxuVXBkYXRlIHwgU25hcHNob3QgfCAoMCk7XG52YXIgTXV0YXRpb25NYXNrID0gUGxhY2VtZW50IHwgVXBkYXRlIHwgQ2hpbGREZWxldGlvbiB8IENvbnRlbnRSZXNldCB8IFJlZiB8IEh5ZHJhdGluZyB8IFZpc2liaWxpdHkgfCBGb3JtUmVzZXQ7XG52YXIgTGF5b3V0TWFzayA9IFVwZGF0ZSB8IENhbGxiYWNrIHwgUmVmIHwgVmlzaWJpbGl0eTsgLy8gVE9ETzogU3BsaXQgaW50byBQYXNzaXZlTW91bnRNYXNrIGFuZCBQYXNzaXZlVW5tb3VudE1hc2tcblxudmFyIFBhc3NpdmVNYXNrID0gUGFzc2l2ZSQxIHwgVmlzaWJpbGl0eSB8IENoaWxkRGVsZXRpb247IC8vIFVuaW9uIG9mIHRhZ3MgdGhhdCBkb24ndCBnZXQgcmVzZXQgb24gY2xvbmVzLlxuLy8gVGhpcyBhbGxvd3MgY2VydGFpbiBjb25jZXB0cyB0byBwZXJzaXN0IHdpdGhvdXQgcmVjYWxjdWxhdGluZyB0aGVtLFxuLy8gZS5nLiB3aGV0aGVyIGEgc3VidHJlZSBjb250YWlucyBwYXNzaXZlIGVmZmVjdHMgb3IgcG9ydGFscy5cblxudmFyIFN0YXRpY01hc2sgPSBMYXlvdXRTdGF0aWMgfCBQYXNzaXZlU3RhdGljIHwgUmVmU3RhdGljIHwgTWF5U3VzcGVuZENvbW1pdDtcblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGxvZzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZJbmZvXG4gICAgICAgIH0pLFxuICAgICAgICB3YXJuOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZXYXJuXG4gICAgICAgIH0pLFxuICAgICAgICBlcnJvcjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwQ29sbGFwc2VkXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cEVuZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxuZnVuY3Rpb24gZGVzY3JpYmVEZWJ1Z0luZm9GcmFtZShuYW1lLCBlbnYpIHtcbiAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUgKyAoZW52ID8gJyAoJyArIGVudiArICcpJyA6ICcnKSk7XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCQxID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xuICBjb21wb25lbnRGcmFtZUNhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCQxKCk7XG59XG4vKipcbiAqIExldmVyYWdlcyBuYXRpdmUgYnJvd3Nlci9WTSBzdGFjayBmcmFtZXMgdG8gZ2V0IHByb3BlciBkZXRhaWxzIChlLmcuXG4gKiBmaWxlbmFtZSwgbGluZSArIGNvbCBudW1iZXIpIGZvciBhIHNpbmdsZSBjb21wb25lbnQgaW4gYSBjb21wb25lbnQgc3RhY2suIFdlXG4gKiBkbyB0aGlzIGJ5OlxuICogICAoMSkgdGhyb3dpbmcgYW5kIGNhdGNoaW5nIGFuIGVycm9yIGluIHRoZSBmdW5jdGlvbiAtIHRoaXMgd2lsbCBiZSBvdXJcbiAqICAgICAgIGNvbnRyb2wgZXJyb3IuXG4gKiAgICgyKSBjYWxsaW5nIHRoZSBjb21wb25lbnQgd2hpY2ggd2lsbCBldmVudHVhbGx5IHRocm93IGFuIGVycm9yIHRoYXQgd2UnbGxcbiAqICAgICAgIGNhdGNoIC0gdGhpcyB3aWxsIGJlIG91ciBzYW1wbGUgZXJyb3IuXG4gKiAgICgzKSBkaWZmaW5nIHRoZSBjb250cm9sIGFuZCBzYW1wbGUgZXJyb3Igc3RhY2tzIHRvIGZpbmQgdGhlIHN0YWNrIGZyYW1lXG4gKiAgICAgICB3aGljaCByZXByZXNlbnRzIG91ciBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXIgPSBudWxsO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IOyAvLyBTZXQgdGhlIGRpc3BhdGNoZXIgaW4gREVWIGJlY2F1c2UgdGhpcyBtaWdodCBiZSBjYWxsIGluIHRoZSByZW5kZXIgZnVuY3Rpb25cbiAgICAvLyBmb3Igd2FybmluZ3MuXG5cbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kaW5nIGEgY29tbW9uIHN0YWNrIGZyYW1lIGJldHdlZW4gc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBjYW4gYmVcbiAgICogdHJpY2t5IGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMgYW5kIGxldmVscyBvZiBzdGFjayB0cmFjZSB0cnVuY2F0aW9uIGZyb21cbiAgICogZGlmZmVyZW50IEpTIFZNcy4gU28gaW5zdGVhZCB3ZSdsbCBhdHRlbXB0IHRvIGNvbnRyb2wgd2hhdCB0aGF0IGNvbW1vblxuICAgKiBmcmFtZSBzaG91bGQgYmUgdGhyb3VnaCB0aGlzIG9iamVjdCBtZXRob2Q6XG4gICAqIEhhdmluZyBib3RoIHRoZSBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGJlIGluIHRoZSBmdW5jdGlvbiB1bmRlciB0aGVcbiAgICogYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBwcm9wZXJ0eSwgKyBzZXR0aW5nIHRoZSBgbmFtZWAgYW5kXG4gICAqIGBkaXNwbGF5TmFtZWAgcHJvcGVydGllcyBvZiB0aGUgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGEgc3RhY2tcbiAgICogZnJhbWUgZXhpc3RzIHRoYXQgaGFzIHRoZSBtZXRob2QgbmFtZSBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIGluXG4gICAqIGl0IGZvciBib3RoIGNvbnRyb2wgYW5kIHNhbXBsZSBzdGFja3MuXG4gICAqL1xuXG5cbiAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRyb2w7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAgICAgLy8gY29tcG9uZW50LCB3aGljaCB3ZSBkb24ndCB5ZXQgc3VwcG9ydC4gQXR0YWNoIGEgbm9vcCBjYXRjaCBoYW5kbGVyIHRvXG4gICAgICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgIH1cbiAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID0gJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCc7XG4gIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgJ25hbWUnKTsgLy8gQmVmb3JlIEVTNiwgdGhlIGBuYW1lYCBwcm9wZXJ0eSB3YXMgbm90IGNvbmZpZ3VyYWJsZS5cblxuICBpZiAobmFtZVByb3BEZXNjcmlwdG9yICYmIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAvLyBWOCB1dGlsaXplcyBhIGZ1bmN0aW9uJ3MgYG5hbWVgIHByb3BlcnR5IHdoZW4gZ2VuZXJhdGluZyBhIHN0YWNrIHRyYWNlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsIC8vIENvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1cGRhdGVkIGV2ZW4gaWYgaXRzIHdyaXRhYmxlIGRlc2NyaXB0b3JcbiAgICAvLyBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cbiAgICAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290J1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID0gUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG5cbiAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBjID0gMDtcblxuICAgICAgd2hpbGUgKHMgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiYgIXNhbXBsZUxpbmVzW3NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBzKys7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJiAhY29udHJvbExpbmVzW2NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBjKys7XG4gICAgICB9IC8vIFdlIGNvdWxkbid0IGZpbmQgb3VyIGludGVudGlvbmFsbHkgaW5qZWN0ZWQgY29tbW9uIHJvb3QgZnJhbWUsIGF0dGVtcHRcbiAgICAgIC8vIHRvIGZpbmQgYW5vdGhlciBjb21tb24gcm9vdCBmcmFtZSBieSBzZWFyY2ggZnJvbSB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgLy8gY29udHJvbCBzdGFjay4uLlxuXG5cbiAgICAgIGlmIChzID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHwgYyA9PT0gY29udHJvbExpbmVzLmxlbmd0aCkge1xuICAgICAgICBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgYy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2aW91c0Rpc3BhdGNoZXI7XG4gICAgICByZWVuYWJsZUxvZ3MoKTtcbiAgICB9XG5cbiAgICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2U7XG4gIH0gLy8gRmFsbGJhY2sgdG8ganVzdCB1c2luZyB0aGUgbmFtZSBpZiB3ZSBjb3VsZG4ndCBtYWtlIGl0IHRocm93LlxuXG5cbiAgdmFyIG5hbWUgPSBmbiA/IGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgOiAnJztcbiAgdmFyIHN5bnRoZXRpY0ZyYW1lID0gbmFtZSA/IGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUpIDogJyc7XG5cbiAge1xuICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNvbXBvbmVudEZyYW1lQ2FjaGUuc2V0KGZuLCBzeW50aGV0aWNGcmFtZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN5bnRoZXRpY0ZyYW1lO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUoY3Rvcikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoY3RvciwgdHJ1ZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXNjcmliZUZpYmVyKGZpYmVyKSB7XG4gIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgY2FzZSBIb3N0SG9pc3RhYmxlOlxuICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7XG5cbiAgICBjYXNlIExhenlDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ0xhenknKTtcblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG5cbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7XG5cbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUucmVuZGVyKTtcblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZGVzY3JpYmVDbGFzc0NvbXBvbmVudEZyYW1lKGZpYmVyLnR5cGUpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qod29ya0luUHJvZ3Jlc3MpIHtcbiAgdHJ5IHtcbiAgICB2YXIgaW5mbyA9ICcnO1xuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3M7XG5cbiAgICBkbyB7XG4gICAgICBpbmZvICs9IGRlc2NyaWJlRmliZXIobm9kZSk7XG5cbiAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgIC8vIEFkZCBhbnkgU2VydmVyIENvbXBvbmVudCBzdGFjayBmcmFtZXMgaW4gcmV2ZXJzZSBvcmRlci5cbiAgICAgICAgdmFyIGRlYnVnSW5mbyA9IG5vZGUuX2RlYnVnSW5mbztcblxuICAgICAgICBpZiAoZGVidWdJbmZvKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IGRlYnVnSW5mby5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gZGVidWdJbmZvW2ldO1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGVudHJ5Lm5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGluZm8gKz0gZGVzY3JpYmVEZWJ1Z0luZm9GcmFtZShlbnRyeS5uYW1lLCBlbnRyeS5lbnYpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSB3ZSBiYWlsIG91dCB3aGVuIHdlIGdldCBhIG51bGxcblxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfSB3aGlsZSAobm9kZSk7XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfSBjYXRjaCAoeCkge1xuICAgIHJldHVybiAnXFxuRXJyb3IgZ2VuZXJhdGluZyBzdGFjazogJyArIHgubWVzc2FnZSArICdcXG4nICsgeC5zdGFjaztcbiAgfVxufVxuXG52YXIgY3VycmVudCA9IG51bGw7XG52YXIgaXNSZW5kZXJpbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldigpIHtcbiAge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfSAvLyBTYWZlIGJlY2F1c2UgaWYgY3VycmVudCBmaWJlciBleGlzdHMsIHdlIGFyZSByZWNvbmNpbGluZyxcbiAgICAvLyBhbmQgaXQgaXMgZ3VhcmFudGVlZCB0byBiZSB0aGUgd29yay1pbi1wcm9ncmVzcyB2ZXJzaW9uLlxuXG5cbiAgICByZXR1cm4gZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKGN1cnJlbnQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVigpIHtcbiAge1xuICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoZmliZXIpIHtcbiAge1xuICAgIHNldEN1cnJlbnRGaWJlcihmaWJlcik7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc2V0Q3VycmVudEZpYmVyKCkge1xuICB7XG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gbnVsbDtcbiAgICBpc1JlbmRlcmluZyA9IGZhbHNlO1xuICB9XG5cbiAgY3VycmVudCA9IG51bGw7XG59XG5mdW5jdGlvbiBzZXRDdXJyZW50RmliZXIoZmliZXIpIHtcbiAge1xuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmdldEN1cnJlbnRTdGFjayA9IGZpYmVyID09PSBudWxsID8gbnVsbCA6IGdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXY7XG4gICAgaXNSZW5kZXJpbmcgPSBmYWxzZTtcbiAgfVxuXG4gIGN1cnJlbnQgPSBmaWJlcjtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlcigpIHtcbiAge1xuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG59XG5mdW5jdGlvbiBzZXRJc1JlbmRlcmluZyhyZW5kZXJpbmcpIHtcbiAge1xuICAgIGlzUmVuZGVyaW5nID0gcmVuZGVyaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpIHtcbiAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgdmFyIG5lYXJlc3RNb3VudGVkID0gZmliZXI7XG5cbiAgaWYgKCFmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAvLyBJZiB0aGVyZSBpcyBubyBhbHRlcm5hdGUsIHRoaXMgbWlnaHQgYmUgYSBuZXcgdHJlZSB0aGF0IGlzbid0IGluc2VydGVkXG4gICAgLy8geWV0LiBJZiBpdCBpcywgdGhlbiBpdCB3aWxsIGhhdmUgYSBwZW5kaW5nIGluc2VydGlvbiBlZmZlY3Qgb24gaXQuXG4gICAgdmFyIG5leHROb2RlID0gbm9kZTtcblxuICAgIGRvIHtcbiAgICAgIG5vZGUgPSBuZXh0Tm9kZTtcblxuICAgICAgaWYgKChub2RlLmZsYWdzICYgKFBsYWNlbWVudCB8IEh5ZHJhdGluZykpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhbiBpbnNlcnRpb24gb3IgaW4tcHJvZ3Jlc3MgaHlkcmF0aW9uLiBUaGUgbmVhcmVzdCBwb3NzaWJsZVxuICAgICAgICAvLyBtb3VudGVkIGZpYmVyIGlzIHRoZSBwYXJlbnQgYnV0IHdlIG5lZWQgdG8gY29udGludWUgdG8gZmlndXJlIG91dFxuICAgICAgICAvLyBpZiB0aGF0IG9uZSBpcyBzdGlsbCBtb3VudGVkLlxuICAgICAgICBuZWFyZXN0TW91bnRlZCA9IG5vZGUucmV0dXJuO1xuICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSB3ZSBiYWlsIG91dCB3aGVuIHdlIGdldCBhIG51bGxcblxuXG4gICAgICBuZXh0Tm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH0gd2hpbGUgKG5leHROb2RlKTtcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAobm9kZS5yZXR1cm4pIHtcbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAobm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgLy8gVE9ETzogQ2hlY2sgaWYgdGhpcyB3YXMgYSBuZXN0ZWQgSG9zdFJvb3Qgd2hlbiB1c2VkIHdpdGhcbiAgICAvLyByZW5kZXJDb250YWluZXJJbnRvU3VidHJlZS5cbiAgICByZXR1cm4gbmVhcmVzdE1vdW50ZWQ7XG4gIH0gLy8gSWYgd2UgZGlkbid0IGhpdCB0aGUgcm9vdCwgdGhhdCBtZWFucyB0aGF0IHdlJ3JlIGluIGFuIGRpc2Nvbm5lY3RlZCB0cmVlXG4gIC8vIHRoYXQgaGFzIGJlZW4gdW5tb3VudGVkLlxuXG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBpc01vdW50ZWQoY29tcG9uZW50KSB7XG4gIHtcbiAgICB2YXIgb3duZXIgPSBjdXJyZW50O1xuXG4gICAgaWYgKG93bmVyICE9PSBudWxsICYmIGlzUmVuZGVyaW5nICYmIG93bmVyLnRhZyA9PT0gQ2xhc3NDb21wb25lbnQpIHtcbiAgICAgIHZhciBvd25lckZpYmVyID0gb3duZXI7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBvd25lckZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgaWYgKCFpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIpIHtcbiAgICAgICAgZXJyb3IoJyVzIGlzIGFjY2Vzc2luZyBpc01vdW50ZWQgaW5zaWRlIGl0cyByZW5kZXIoKSBmdW5jdGlvbi4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIob3duZXJGaWJlcikgfHwgJ0EgY29tcG9uZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KGNvbXBvbmVudCk7XG5cbiAgaWYgKCFmaWJlcikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSA9PT0gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGFzc2VydElzTW91bnRlZChmaWJlcikge1xuICBpZiAoZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcikgIT09IGZpYmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgoZmliZXIpIHtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoIWFsdGVybmF0ZSkge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGFsdGVybmF0ZSwgdGhlbiB3ZSBvbmx5IG5lZWQgdG8gY2hlY2sgaWYgaXQgaXMgbW91bnRlZC5cbiAgICB2YXIgbmVhcmVzdE1vdW50ZWQgPSBnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKTtcblxuICAgIGlmIChuZWFyZXN0TW91bnRlZCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfVxuXG4gICAgaWYgKG5lYXJlc3RNb3VudGVkICE9PSBmaWJlcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZpYmVyO1xuICB9IC8vIElmIHdlIGhhdmUgdHdvIHBvc3NpYmxlIGJyYW5jaGVzLCB3ZSdsbCB3YWxrIGJhY2t3YXJkcyB1cCB0byB0aGUgcm9vdFxuICAvLyB0byBzZWUgd2hhdCBwYXRoIHRoZSByb290IHBvaW50cyB0by4gT24gdGhlIHdheSB3ZSBtYXkgaGl0IG9uZSBvZiB0aGVcbiAgLy8gc3BlY2lhbCBjYXNlcyBhbmQgd2UnbGwgZGVhbCB3aXRoIHRoZW0uXG5cblxuICB2YXIgYSA9IGZpYmVyO1xuICB2YXIgYiA9IGFsdGVybmF0ZTtcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHZhciBwYXJlbnRBID0gYS5yZXR1cm47XG5cbiAgICBpZiAocGFyZW50QSA9PT0gbnVsbCkge1xuICAgICAgLy8gV2UncmUgYXQgdGhlIHJvb3QuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgcGFyZW50QiA9IHBhcmVudEEuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKHBhcmVudEIgPT09IG51bGwpIHtcbiAgICAgIC8vIFRoZXJlIGlzIG5vIGFsdGVybmF0ZS4gVGhpcyBpcyBhbiB1bnVzdWFsIGNhc2UuIEN1cnJlbnRseSwgaXQgb25seVxuICAgICAgLy8gaGFwcGVucyB3aGVuIGEgU3VzcGVuc2UgY29tcG9uZW50IGlzIGhpZGRlbi4gQW4gZXh0cmEgZnJhZ21lbnQgZmliZXJcbiAgICAgIC8vIGlzIGluc2VydGVkIGluIGJldHdlZW4gdGhlIFN1c3BlbnNlIGZpYmVyIGFuZCBpdHMgY2hpbGRyZW4uIFNraXBcbiAgICAgIC8vIG92ZXIgdGhpcyBleHRyYSBmcmFnbWVudCBmaWJlciBhbmQgcHJvY2VlZCB0byB0aGUgbmV4dCBwYXJlbnQuXG4gICAgICB2YXIgbmV4dFBhcmVudCA9IHBhcmVudEEucmV0dXJuO1xuXG4gICAgICBpZiAobmV4dFBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICBhID0gYiA9IG5leHRQYXJlbnQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSAvLyBJZiB0aGVyZSdzIG5vIHBhcmVudCwgd2UncmUgYXQgdGhlIHJvb3QuXG5cblxuICAgICAgYnJlYWs7XG4gICAgfSAvLyBJZiBib3RoIGNvcGllcyBvZiB0aGUgcGFyZW50IGZpYmVyIHBvaW50IHRvIHRoZSBzYW1lIGNoaWxkLCB3ZSBjYW5cbiAgICAvLyBhc3N1bWUgdGhhdCB0aGUgY2hpbGQgaXMgY3VycmVudC4gVGhpcyBoYXBwZW5zIHdoZW4gd2UgYmFpbG91dCBvbiBsb3dcbiAgICAvLyBwcmlvcml0eTogdGhlIGJhaWxlZCBvdXQgZmliZXIncyBjaGlsZCByZXVzZXMgdGhlIGN1cnJlbnQgY2hpbGQuXG5cblxuICAgIGlmIChwYXJlbnRBLmNoaWxkID09PSBwYXJlbnRCLmNoaWxkKSB7XG4gICAgICB2YXIgY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoY2hpbGQpIHtcbiAgICAgICAgaWYgKGNoaWxkID09PSBhKSB7XG4gICAgICAgICAgLy8gV2UndmUgZGV0ZXJtaW5lZCB0aGF0IEEgaXMgdGhlIGN1cnJlbnQgYnJhbmNoLlxuICAgICAgICAgIGFzc2VydElzTW91bnRlZChwYXJlbnRBKTtcbiAgICAgICAgICByZXR1cm4gZmliZXI7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQiBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgICAgICAgYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO1xuICAgICAgICAgIHJldHVybiBhbHRlcm5hdGU7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9IC8vIFdlIHNob3VsZCBuZXZlciBoYXZlIGFuIGFsdGVybmF0ZSBmb3IgYW55IG1vdW50aW5nIG5vZGUuIFNvIHRoZSBvbmx5XG4gICAgICAvLyB3YXkgdGhpcyBjb3VsZCBwb3NzaWJseSBoYXBwZW4gaXMgaWYgdGhpcyB3YXMgdW5tb3VudGVkLCBpZiBhdCBhbGwuXG5cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfVxuXG4gICAgaWYgKGEucmV0dXJuICE9PSBiLnJldHVybikge1xuICAgICAgLy8gVGhlIHJldHVybiBwb2ludGVyIG9mIEEgYW5kIHRoZSByZXR1cm4gcG9pbnRlciBvZiBCIHBvaW50IHRvIGRpZmZlcmVudFxuICAgICAgLy8gZmliZXJzLiBXZSBhc3N1bWUgdGhhdCByZXR1cm4gcG9pbnRlcnMgbmV2ZXIgY3Jpc3MtY3Jvc3MsIHNvIEEgbXVzdFxuICAgICAgLy8gYmVsb25nIHRvIHRoZSBjaGlsZCBzZXQgb2YgQS5yZXR1cm4sIGFuZCBCIG11c3QgYmVsb25nIHRvIHRoZSBjaGlsZFxuICAgICAgLy8gc2V0IG9mIEIucmV0dXJuLlxuICAgICAgYSA9IHBhcmVudEE7XG4gICAgICBiID0gcGFyZW50QjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIHJldHVybiBwb2ludGVycyBwb2ludCB0byB0aGUgc2FtZSBmaWJlci4gV2UnbGwgaGF2ZSB0byB1c2UgdGhlXG4gICAgICAvLyBkZWZhdWx0LCBzbG93IHBhdGg6IHNjYW4gdGhlIGNoaWxkIHNldHMgb2YgZWFjaCBwYXJlbnQgYWx0ZXJuYXRlIHRvIHNlZVxuICAgICAgLy8gd2hpY2ggY2hpbGQgYmVsb25ncyB0byB3aGljaCBzZXQuXG4gICAgICAvL1xuICAgICAgLy8gU2VhcmNoIHBhcmVudCBBJ3MgY2hpbGQgc2V0XG4gICAgICB2YXIgZGlkRmluZENoaWxkID0gZmFsc2U7XG4gICAgICB2YXIgX2NoaWxkID0gcGFyZW50QS5jaGlsZDtcblxuICAgICAgd2hpbGUgKF9jaGlsZCkge1xuICAgICAgICBpZiAoX2NoaWxkID09PSBhKSB7XG4gICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICBhID0gcGFyZW50QTtcbiAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgIGEgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIGlmICghZGlkRmluZENoaWxkKSB7XG4gICAgICAgIC8vIFNlYXJjaCBwYXJlbnQgQidzIGNoaWxkIHNldFxuICAgICAgICBfY2hpbGQgPSBwYXJlbnRCLmNoaWxkO1xuXG4gICAgICAgIHdoaWxlIChfY2hpbGQpIHtcbiAgICAgICAgICBpZiAoX2NoaWxkID09PSBhKSB7XG4gICAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgICBiID0gcGFyZW50QTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfY2hpbGQgPT09IGIpIHtcbiAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICBiID0gcGFyZW50QjtcbiAgICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX2NoaWxkID0gX2NoaWxkLnNpYmxpbmc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWRpZEZpbmRDaGlsZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2hpbGQgd2FzIG5vdCBmb3VuZCBpbiBlaXRoZXIgcGFyZW50IHNldC4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgJyArICdpbiBSZWFjdCByZWxhdGVkIHRvIHRoZSByZXR1cm4gcG9pbnRlci4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYS5hbHRlcm5hdGUgIT09IGIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlJldHVybiBmaWJlcnMgc2hvdWxkIGFsd2F5cyBiZSBlYWNoIG90aGVycycgYWx0ZXJuYXRlcy4gXCIgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH0gLy8gSWYgdGhlIHJvb3QgaXMgbm90IGEgaG9zdCBjb250YWluZXIsIHdlJ3JlIGluIGEgZGlzY29ubmVjdGVkIHRyZWUuIEkuZS5cbiAgLy8gdW5tb3VudGVkLlxuXG5cbiAgaWYgKGEudGFnICE9PSBIb3N0Um9vdCkge1xuICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGZpbmQgbm9kZSBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpO1xuICB9XG5cbiAgaWYgKGEuc3RhdGVOb2RlLmN1cnJlbnQgPT09IGEpIHtcbiAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgcmV0dXJuIGZpYmVyO1xuICB9IC8vIE90aGVyd2lzZSBCIGhhcyB0byBiZSBjdXJyZW50IGJyYW5jaC5cblxuXG4gIHJldHVybiBhbHRlcm5hdGU7XG59XG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcihwYXJlbnQpIHtcbiAgdmFyIGN1cnJlbnRQYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO1xuICByZXR1cm4gY3VycmVudFBhcmVudCAhPT0gbnVsbCA/IGZpbmRDdXJyZW50SG9zdEZpYmVySW1wbChjdXJyZW50UGFyZW50KSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVySW1wbChub2RlKSB7XG4gIC8vIE5leHQgd2UnbGwgZHJpbGwgZG93biB0aGlzIGNvbXBvbmVudCB0byBmaW5kIHRoZSBmaXJzdCBIb3N0Q29tcG9uZW50L1RleHQuXG4gIHZhciB0YWcgPSBub2RlLnRhZztcblxuICBpZiAodGFnID09PSBIb3N0Q29tcG9uZW50IHx8IHRhZyA9PT0gSG9zdEhvaXN0YWJsZSB8fCB0YWcgPT09IEhvc3RTaW5nbGV0b24gfHwgdGFnID09PSBIb3N0VGV4dCkge1xuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICB2YXIgbWF0Y2ggPSBmaW5kQ3VycmVudEhvc3RGaWJlckltcGwoY2hpbGQpO1xuXG4gICAgaWYgKG1hdGNoICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbWF0Y2g7XG4gICAgfVxuXG4gICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFscyhwYXJlbnQpIHtcbiAgdmFyIGN1cnJlbnRQYXJlbnQgPSBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChwYXJlbnQpO1xuICByZXR1cm4gY3VycmVudFBhcmVudCAhPT0gbnVsbCA/IGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFsc0ltcGwoY3VycmVudFBhcmVudCkgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEhvc3RGaWJlcldpdGhOb1BvcnRhbHNJbXBsKG5vZGUpIHtcbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgdmFyIHRhZyA9IG5vZGUudGFnO1xuXG4gIGlmICh0YWcgPT09IEhvc3RDb21wb25lbnQgfHwgdGFnID09PSBIb3N0SG9pc3RhYmxlIHx8IHRhZyA9PT0gSG9zdFNpbmdsZXRvbiB8fCB0YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgIGlmIChjaGlsZC50YWcgIT09IEhvc3RQb3J0YWwpIHtcbiAgICAgIHZhciBtYXRjaCA9IGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFsc0ltcGwoY2hpbGQpO1xuXG4gICAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8vIFRoaXMgaXMgYSBob3N0IGNvbmZpZyB0aGF0J3MgdXNlZCBmb3IgdGhlIGByZWFjdC1yZWNvbmNpbGVyYCBwYWNrYWdlIG9uIG5wbS5cbi8vIEl0IGlzIG9ubHkgdXNlZCBieSB0aGlyZC1wYXJ0eSByZW5kZXJlcnMuXG4vL1xuLy8gSXRzIEFQSSBsZXRzIHlvdSBwYXNzIHRoZSBob3N0IGNvbmZpZyBhcyBhbiBhcmd1bWVudC5cbi8vIEhvd2V2ZXIsIGluc2lkZSB0aGUgYHJlYWN0LXJlY29uY2lsZXJgIHdlIHRyZWF0IGhvc3QgY29uZmlnIGFzIGEgbW9kdWxlLlxuLy8gVGhpcyBmaWxlIGlzIGEgc2hpbSBiZXR3ZWVuIHR3byB3b3JsZHMuXG4vL1xuLy8gSXQgd29ya3MgYmVjYXVzZSB0aGUgYHJlYWN0LXJlY29uY2lsZXJgIGJ1bmRsZSBpcyB3cmFwcGVkIGluIHNvbWV0aGluZyBsaWtlOlxuLy9cbi8vIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCQkJGNvbmZpZykge1xuLy8gICAvKiByZWNvbmNpbGVyIGNvZGUgKi9cbi8vIH1cbi8vXG4vLyBTbyBgJCQkY29uZmlnYCBsb29rcyBsaWtlIGEgZ2xvYmFsIHZhcmlhYmxlLCBidXQgaXQnc1xuLy8gcmVhbGx5IGFuIGFyZ3VtZW50IHRvIGEgdG9wLWxldmVsIHdyYXBwaW5nIGZ1bmN0aW9uLlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxudmFyIGdldFB1YmxpY0luc3RhbmNlID0gJCQkY29uZmlnLmdldFB1YmxpY0luc3RhbmNlO1xudmFyIGdldFJvb3RIb3N0Q29udGV4dCA9ICQkJGNvbmZpZy5nZXRSb290SG9zdENvbnRleHQ7XG52YXIgZ2V0Q2hpbGRIb3N0Q29udGV4dCA9ICQkJGNvbmZpZy5nZXRDaGlsZEhvc3RDb250ZXh0O1xudmFyIHByZXBhcmVGb3JDb21taXQgPSAkJCRjb25maWcucHJlcGFyZUZvckNvbW1pdDtcbnZhciByZXNldEFmdGVyQ29tbWl0ID0gJCQkY29uZmlnLnJlc2V0QWZ0ZXJDb21taXQ7XG52YXIgY3JlYXRlSW5zdGFuY2UgPSAkJCRjb25maWcuY3JlYXRlSW5zdGFuY2U7XG52YXIgYXBwZW5kSW5pdGlhbENoaWxkID0gJCQkY29uZmlnLmFwcGVuZEluaXRpYWxDaGlsZDtcbnZhciBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbiA9ICQkJGNvbmZpZy5maW5hbGl6ZUluaXRpYWxDaGlsZHJlbjtcbnZhciBzaG91bGRTZXRUZXh0Q29udGVudCA9ICQkJGNvbmZpZy5zaG91bGRTZXRUZXh0Q29udGVudDtcbnZhciBjcmVhdGVUZXh0SW5zdGFuY2UgPSAkJCRjb25maWcuY3JlYXRlVGV4dEluc3RhbmNlO1xudmFyIHNjaGVkdWxlVGltZW91dCA9ICQkJGNvbmZpZy5zY2hlZHVsZVRpbWVvdXQ7XG52YXIgY2FuY2VsVGltZW91dCA9ICQkJGNvbmZpZy5jYW5jZWxUaW1lb3V0O1xudmFyIG5vVGltZW91dCA9ICQkJGNvbmZpZy5ub1RpbWVvdXQ7XG52YXIgaXNQcmltYXJ5UmVuZGVyZXIgPSAkJCRjb25maWcuaXNQcmltYXJ5UmVuZGVyZXI7XG4kJCRjb25maWcud2FybnNJZk5vdEFjdGluZztcbnZhciBzdXBwb3J0c011dGF0aW9uID0gJCQkY29uZmlnLnN1cHBvcnRzTXV0YXRpb247XG52YXIgc3VwcG9ydHNQZXJzaXN0ZW5jZSA9ICQkJGNvbmZpZy5zdXBwb3J0c1BlcnNpc3RlbmNlO1xudmFyIHN1cHBvcnRzSHlkcmF0aW9uID0gJCQkY29uZmlnLnN1cHBvcnRzSHlkcmF0aW9uO1xudmFyIGdldEluc3RhbmNlRnJvbU5vZGUgPSAkJCRjb25maWcuZ2V0SW5zdGFuY2VGcm9tTm9kZTtcbiQkJGNvbmZpZy5iZWZvcmVBY3RpdmVJbnN0YW5jZUJsdXI7XG4kJCRjb25maWcuYWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXI7XG52YXIgcHJlcGFyZVBvcnRhbE1vdW50ID0gJCQkY29uZmlnLnByZXBhcmVQb3J0YWxNb3VudDtcbiQkJGNvbmZpZy5wcmVwYXJlU2NvcGVVcGRhdGU7XG4kJCRjb25maWcuZ2V0SW5zdGFuY2VGcm9tU2NvcGU7XG52YXIgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5ID0gJCQkY29uZmlnLnNldEN1cnJlbnRVcGRhdGVQcmlvcml0eTtcbnZhciBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkgPSAkJCRjb25maWcuZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5O1xudmFyIHJlc29sdmVVcGRhdGVQcmlvcml0eSA9ICQkJGNvbmZpZy5yZXNvbHZlVXBkYXRlUHJpb3JpdHk7XG52YXIgc2hvdWxkQXR0ZW1wdEVhZ2VyVHJhbnNpdGlvbiA9ICQkJGNvbmZpZy5zaG91bGRBdHRlbXB0RWFnZXJUcmFuc2l0aW9uO1xudmFyIGRldGFjaERlbGV0ZWRJbnN0YW5jZSA9ICQkJGNvbmZpZy5kZXRhY2hEZWxldGVkSW5zdGFuY2U7XG4kJCRjb25maWcucmVxdWVzdFBvc3RQYWludENhbGxiYWNrO1xudmFyIG1heVN1c3BlbmRDb21taXQgPSAkJCRjb25maWcubWF5U3VzcGVuZENvbW1pdDtcbnZhciBwcmVsb2FkSW5zdGFuY2UgPSAkJCRjb25maWcucHJlbG9hZEluc3RhbmNlO1xudmFyIHN0YXJ0U3VzcGVuZGluZ0NvbW1pdCA9ICQkJGNvbmZpZy5zdGFydFN1c3BlbmRpbmdDb21taXQ7XG52YXIgc3VzcGVuZEluc3RhbmNlID0gJCQkY29uZmlnLnN1c3BlbmRJbnN0YW5jZTtcbnZhciB3YWl0Rm9yQ29tbWl0VG9CZVJlYWR5ID0gJCQkY29uZmlnLndhaXRGb3JDb21taXRUb0JlUmVhZHk7XG52YXIgTm90UGVuZGluZ1RyYW5zaXRpb24gPSAkJCRjb25maWcuTm90UGVuZGluZ1RyYW5zaXRpb247XG52YXIgcmVzZXRGb3JtSW5zdGFuY2UgPSAkJCRjb25maWcucmVzZXRGb3JtSW5zdGFuY2U7IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vICAgICAgTWljcm90YXNrc1xuLy8gICAgIChvcHRpb25hbClcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIHN1cHBvcnRzTWljcm90YXNrcyA9ICQkJGNvbmZpZy5zdXBwb3J0c01pY3JvdGFza3M7XG52YXIgc2NoZWR1bGVNaWNyb3Rhc2sgPSAkJCRjb25maWcuc2NoZWR1bGVNaWNyb3Rhc2s7IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vICAgICAgVGVzdCBzZWxlY3RvcnNcbi8vICAgICAob3B0aW9uYWwpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBzdXBwb3J0c1Rlc3RTZWxlY3RvcnMgPSAkJCRjb25maWcuc3VwcG9ydHNUZXN0U2VsZWN0b3JzO1xudmFyIGZpbmRGaWJlclJvb3QgPSAkJCRjb25maWcuZmluZEZpYmVyUm9vdDtcbnZhciBnZXRCb3VuZGluZ1JlY3QgPSAkJCRjb25maWcuZ2V0Qm91bmRpbmdSZWN0O1xudmFyIGdldFRleHRDb250ZW50ID0gJCQkY29uZmlnLmdldFRleHRDb250ZW50O1xudmFyIGlzSGlkZGVuU3VidHJlZSA9ICQkJGNvbmZpZy5pc0hpZGRlblN1YnRyZWU7XG52YXIgbWF0Y2hBY2Nlc3NpYmlsaXR5Um9sZSA9ICQkJGNvbmZpZy5tYXRjaEFjY2Vzc2liaWxpdHlSb2xlO1xudmFyIHNldEZvY3VzSWZGb2N1c2FibGUgPSAkJCRjb25maWcuc2V0Rm9jdXNJZkZvY3VzYWJsZTtcbnZhciBzZXR1cEludGVyc2VjdGlvbk9ic2VydmVyID0gJCQkY29uZmlnLnNldHVwSW50ZXJzZWN0aW9uT2JzZXJ2ZXI7IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vICAgICAgTXV0YXRpb25cbi8vICAgICAob3B0aW9uYWwpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBhcHBlbmRDaGlsZCA9ICQkJGNvbmZpZy5hcHBlbmRDaGlsZDtcbnZhciBhcHBlbmRDaGlsZFRvQ29udGFpbmVyID0gJCQkY29uZmlnLmFwcGVuZENoaWxkVG9Db250YWluZXI7XG52YXIgY29tbWl0VGV4dFVwZGF0ZSA9ICQkJGNvbmZpZy5jb21taXRUZXh0VXBkYXRlO1xudmFyIGNvbW1pdE1vdW50ID0gJCQkY29uZmlnLmNvbW1pdE1vdW50O1xudmFyIGNvbW1pdFVwZGF0ZSA9ICQkJGNvbmZpZy5jb21taXRVcGRhdGU7XG52YXIgaW5zZXJ0QmVmb3JlID0gJCQkY29uZmlnLmluc2VydEJlZm9yZTtcbnZhciBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZSA9ICQkJGNvbmZpZy5pbnNlcnRJbkNvbnRhaW5lckJlZm9yZTtcbnZhciByZW1vdmVDaGlsZCA9ICQkJGNvbmZpZy5yZW1vdmVDaGlsZDtcbnZhciByZW1vdmVDaGlsZEZyb21Db250YWluZXIgPSAkJCRjb25maWcucmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyO1xudmFyIHJlc2V0VGV4dENvbnRlbnQgPSAkJCRjb25maWcucmVzZXRUZXh0Q29udGVudDtcbnZhciBoaWRlSW5zdGFuY2UgPSAkJCRjb25maWcuaGlkZUluc3RhbmNlO1xudmFyIGhpZGVUZXh0SW5zdGFuY2UgPSAkJCRjb25maWcuaGlkZVRleHRJbnN0YW5jZTtcbnZhciB1bmhpZGVJbnN0YW5jZSA9ICQkJGNvbmZpZy51bmhpZGVJbnN0YW5jZTtcbnZhciB1bmhpZGVUZXh0SW5zdGFuY2UgPSAkJCRjb25maWcudW5oaWRlVGV4dEluc3RhbmNlO1xudmFyIGNsZWFyQ29udGFpbmVyID0gJCQkY29uZmlnLmNsZWFyQ29udGFpbmVyOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgICAgUGVyc2lzdGVuY2Vcbi8vICAgICAob3B0aW9uYWwpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBjbG9uZUluc3RhbmNlID0gJCQkY29uZmlnLmNsb25lSW5zdGFuY2U7XG52YXIgY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQgPSAkJCRjb25maWcuY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQ7XG52YXIgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0ID0gJCQkY29uZmlnLmFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldDtcbnZhciBmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuID0gJCQkY29uZmlnLmZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW47XG52YXIgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuID0gJCQkY29uZmlnLnJlcGxhY2VDb250YWluZXJDaGlsZHJlbjtcbnZhciBjbG9uZUhpZGRlbkluc3RhbmNlID0gJCQkY29uZmlnLmNsb25lSGlkZGVuSW5zdGFuY2U7XG52YXIgY2xvbmVIaWRkZW5UZXh0SW5zdGFuY2UgPSAkJCRjb25maWcuY2xvbmVIaWRkZW5UZXh0SW5zdGFuY2U7IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vICAgICBIeWRyYXRpb25cbi8vICAgICAob3B0aW9uYWwpXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nID0gJCQkY29uZmlnLmlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmc7XG52YXIgaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2sgPSAkJCRjb25maWcuaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2s7XG52YXIgZ2V0U3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrRXJyb3JEZXRhaWxzID0gJCQkY29uZmlnLmdldFN1c3BlbnNlSW5zdGFuY2VGYWxsYmFja0Vycm9yRGV0YWlscztcbnZhciByZWdpc3RlclN1c3BlbnNlSW5zdGFuY2VSZXRyeSA9ICQkJGNvbmZpZy5yZWdpc3RlclN1c3BlbnNlSW5zdGFuY2VSZXRyeTtcbnZhciBjYW5IeWRyYXRlRm9ybVN0YXRlTWFya2VyID0gJCQkY29uZmlnLmNhbkh5ZHJhdGVGb3JtU3RhdGVNYXJrZXI7XG52YXIgaXNGb3JtU3RhdGVNYXJrZXJNYXRjaGluZyA9ICQkJGNvbmZpZy5pc0Zvcm1TdGF0ZU1hcmtlck1hdGNoaW5nO1xudmFyIGdldE5leHRIeWRyYXRhYmxlU2libGluZyA9ICQkJGNvbmZpZy5nZXROZXh0SHlkcmF0YWJsZVNpYmxpbmc7XG52YXIgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQgPSAkJCRjb25maWcuZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQ7XG52YXIgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXIgPSAkJCRjb25maWcuZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXI7XG52YXIgZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5TdXNwZW5zZUluc3RhbmNlID0gJCQkY29uZmlnLmdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluU3VzcGVuc2VJbnN0YW5jZTtcbnZhciBjYW5IeWRyYXRlSW5zdGFuY2UgPSAkJCRjb25maWcuY2FuSHlkcmF0ZUluc3RhbmNlO1xudmFyIGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UgPSAkJCRjb25maWcuY2FuSHlkcmF0ZVRleHRJbnN0YW5jZTtcbnZhciBjYW5IeWRyYXRlU3VzcGVuc2VJbnN0YW5jZSA9ICQkJGNvbmZpZy5jYW5IeWRyYXRlU3VzcGVuc2VJbnN0YW5jZTtcbnZhciBoeWRyYXRlSW5zdGFuY2UgPSAkJCRjb25maWcuaHlkcmF0ZUluc3RhbmNlO1xudmFyIGh5ZHJhdGVUZXh0SW5zdGFuY2UgPSAkJCRjb25maWcuaHlkcmF0ZVRleHRJbnN0YW5jZTtcbnZhciBoeWRyYXRlU3VzcGVuc2VJbnN0YW5jZSA9ICQkJGNvbmZpZy5oeWRyYXRlU3VzcGVuc2VJbnN0YW5jZTtcbnZhciBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlID0gJCQkY29uZmlnLmdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2U7XG52YXIgY29tbWl0SHlkcmF0ZWRDb250YWluZXIgPSAkJCRjb25maWcuY29tbWl0SHlkcmF0ZWRDb250YWluZXI7XG52YXIgY29tbWl0SHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlID0gJCQkY29uZmlnLmNvbW1pdEh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZTtcbnZhciBjbGVhclN1c3BlbnNlQm91bmRhcnkgPSAkJCRjb25maWcuY2xlYXJTdXNwZW5zZUJvdW5kYXJ5O1xudmFyIGNsZWFyU3VzcGVuc2VCb3VuZGFyeUZyb21Db250YWluZXIgPSAkJCRjb25maWcuY2xlYXJTdXNwZW5zZUJvdW5kYXJ5RnJvbUNvbnRhaW5lcjtcbnZhciBzaG91bGREZWxldGVVbmh5ZHJhdGVkVGFpbEluc3RhbmNlcyA9ICQkJGNvbmZpZy5zaG91bGREZWxldGVVbmh5ZHJhdGVkVGFpbEluc3RhbmNlcztcbnZhciBkaWZmSHlkcmF0ZWRQcm9wc0ZvckRldldhcm5pbmdzID0gJCQkY29uZmlnLmRpZmZIeWRyYXRlZFByb3BzRm9yRGV2V2FybmluZ3M7XG52YXIgZGlmZkh5ZHJhdGVkVGV4dEZvckRldldhcm5pbmdzID0gJCQkY29uZmlnLmRpZmZIeWRyYXRlZFRleHRGb3JEZXZXYXJuaW5ncztcbnZhciBkZXNjcmliZUh5ZHJhdGFibGVJbnN0YW5jZUZvckRldldhcm5pbmdzID0gJCQkY29uZmlnLmRlc2NyaWJlSHlkcmF0YWJsZUluc3RhbmNlRm9yRGV2V2FybmluZ3M7XG52YXIgdmFsaWRhdGVIeWRyYXRhYmxlSW5zdGFuY2UgPSAkJCRjb25maWcudmFsaWRhdGVIeWRyYXRhYmxlSW5zdGFuY2U7XG52YXIgdmFsaWRhdGVIeWRyYXRhYmxlVGV4dEluc3RhbmNlID0gJCQkY29uZmlnLnZhbGlkYXRlSHlkcmF0YWJsZVRleHRJbnN0YW5jZTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gICAgIFJlc291cmNlc1xuLy8gICAgIChvcHRpb25hbClcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW5kZWZcblxudmFyIHN1cHBvcnRzUmVzb3VyY2VzID0gJCQkY29uZmlnLnN1cHBvcnRzUmVzb3VyY2VzO1xudmFyIGlzSG9zdEhvaXN0YWJsZVR5cGUgPSAkJCRjb25maWcuaXNIb3N0SG9pc3RhYmxlVHlwZTtcbnZhciBnZXRIb2lzdGFibGVSb290ID0gJCQkY29uZmlnLmdldEhvaXN0YWJsZVJvb3Q7XG52YXIgZ2V0UmVzb3VyY2UgPSAkJCRjb25maWcuZ2V0UmVzb3VyY2U7XG52YXIgYWNxdWlyZVJlc291cmNlID0gJCQkY29uZmlnLmFjcXVpcmVSZXNvdXJjZTtcbnZhciByZWxlYXNlUmVzb3VyY2UgPSAkJCRjb25maWcucmVsZWFzZVJlc291cmNlO1xudmFyIGh5ZHJhdGVIb2lzdGFibGUgPSAkJCRjb25maWcuaHlkcmF0ZUhvaXN0YWJsZTtcbnZhciBtb3VudEhvaXN0YWJsZSA9ICQkJGNvbmZpZy5tb3VudEhvaXN0YWJsZTtcbnZhciB1bm1vdW50SG9pc3RhYmxlID0gJCQkY29uZmlnLnVubW91bnRIb2lzdGFibGU7XG52YXIgY3JlYXRlSG9pc3RhYmxlSW5zdGFuY2UgPSAkJCRjb25maWcuY3JlYXRlSG9pc3RhYmxlSW5zdGFuY2U7XG52YXIgcHJlcGFyZVRvQ29tbWl0SG9pc3RhYmxlcyA9ICQkJGNvbmZpZy5wcmVwYXJlVG9Db21taXRIb2lzdGFibGVzO1xudmFyIG1heVJlc291cmNlU3VzcGVuZENvbW1pdCA9ICQkJGNvbmZpZy5tYXlSZXNvdXJjZVN1c3BlbmRDb21taXQ7XG52YXIgcHJlbG9hZFJlc291cmNlID0gJCQkY29uZmlnLnByZWxvYWRSZXNvdXJjZTtcbnZhciBzdXNwZW5kUmVzb3VyY2UgPSAkJCRjb25maWcuc3VzcGVuZFJlc291cmNlOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgICAgU2luZ2xldG9uc1xuLy8gICAgIChvcHRpb25hbClcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIHN1cHBvcnRzU2luZ2xldG9ucyA9ICQkJGNvbmZpZy5zdXBwb3J0c1NpbmdsZXRvbnM7XG52YXIgcmVzb2x2ZVNpbmdsZXRvbkluc3RhbmNlID0gJCQkY29uZmlnLnJlc29sdmVTaW5nbGV0b25JbnN0YW5jZTtcbnZhciBjbGVhclNpbmdsZXRvbiA9ICQkJGNvbmZpZy5jbGVhclNpbmdsZXRvbjtcbnZhciBhY3F1aXJlU2luZ2xldG9uSW5zdGFuY2UgPSAkJCRjb25maWcuYWNxdWlyZVNpbmdsZXRvbkluc3RhbmNlO1xudmFyIHJlbGVhc2VTaW5nbGV0b25JbnN0YW5jZSA9ICQkJGNvbmZpZy5yZWxlYXNlU2luZ2xldG9uSW5zdGFuY2U7XG52YXIgaXNIb3N0U2luZ2xldG9uVHlwZSA9ICQkJGNvbmZpZy5pc0hvc3RTaW5nbGV0b25UeXBlO1xuXG52YXIgdmFsdWVTdGFjayA9IFtdO1xudmFyIGZpYmVyU3RhY2s7XG5cbntcbiAgZmliZXJTdGFjayA9IFtdO1xufVxuXG52YXIgaW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY3JlYXRlQ3Vyc29yKGRlZmF1bHRWYWx1ZSkge1xuICByZXR1cm4ge1xuICAgIGN1cnJlbnQ6IGRlZmF1bHRWYWx1ZVxuICB9O1xufVxuXG5mdW5jdGlvbiBwb3AoY3Vyc29yLCBmaWJlcikge1xuICBpZiAoaW5kZXggPCAwKSB7XG4gICAge1xuICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgcG9wLicpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfVxuXG4gIHtcbiAgICBpZiAoZmliZXIgIT09IGZpYmVyU3RhY2tbaW5kZXhdKSB7XG4gICAgICBlcnJvcignVW5leHBlY3RlZCBGaWJlciBwb3BwZWQuJyk7XG4gICAgfVxuICB9XG5cbiAgY3Vyc29yLmN1cnJlbnQgPSB2YWx1ZVN0YWNrW2luZGV4XTtcbiAgdmFsdWVTdGFja1tpbmRleF0gPSBudWxsO1xuXG4gIHtcbiAgICBmaWJlclN0YWNrW2luZGV4XSA9IG51bGw7XG4gIH1cblxuICBpbmRleC0tO1xufVxuXG5mdW5jdGlvbiBwdXNoKGN1cnNvciwgdmFsdWUsIGZpYmVyKSB7XG4gIGluZGV4Kys7XG4gIHZhbHVlU3RhY2tbaW5kZXhdID0gY3Vyc29yLmN1cnJlbnQ7XG5cbiAge1xuICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gZmliZXI7XG4gIH1cblxuICBjdXJzb3IuY3VycmVudCA9IHZhbHVlO1xufVxuXG52YXIgZW1wdHlDb250ZXh0T2JqZWN0ID0ge307XG5cbntcbiAgT2JqZWN0LmZyZWV6ZShlbXB0eUNvbnRleHRPYmplY3QpO1xufSAvLyBBIGN1cnNvciB0byB0aGUgY3VycmVudCBtZXJnZWQgY29udGV4dCBvYmplY3Qgb24gdGhlIHN0YWNrLlxuXG5mdW5jdGlvbiBoYXNDb250ZXh0Q2hhbmdlZCgpIHtcbiAge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0NvbnRleHRQcm92aWRlcih0eXBlKSB7XG4gIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NoaWxkQ29udGV4dChmaWJlciwgdHlwZSwgcGFyZW50Q29udGV4dCkge1xuICB7XG4gICAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoZmliZXIpIHtcbiAge1xuICAgIHJldHVybiBlbXB0eUNvbnRleHRPYmplY3Q7XG4gIH1cbn1cblxuLy8gV2UgdXNlIHRoZSBleGlzdGVuY2Ugb2YgdGhlIHN0YXRlIG9iamVjdCBhcyBhbiBpbmRpY2F0b3IgdGhhdCB0aGUgY29tcG9uZW50XG4vLyBpcyBoaWRkZW4uXG52YXIgT2Zmc2NyZWVuVmlzaWJsZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICovXG4xO1xudmFyIE9mZnNjcmVlbkRldGFjaGVkID1cbi8qICAgICAgICAgICAgICAgICAgICAqL1xuMjtcbnZhciBPZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZCA9XG4vKiAgICAgKi9cbjQ7XG5mdW5jdGlvbiBpc09mZnNjcmVlbk1hbnVhbChvZmZzY3JlZW5GaWJlcikge1xuICByZXR1cm4gb2Zmc2NyZWVuRmliZXIubWVtb2l6ZWRQcm9wcyAhPT0gbnVsbCAmJiBvZmZzY3JlZW5GaWJlci5tZW1vaXplZFByb3BzLm1vZGUgPT09ICdtYW51YWwnO1xufVxuXG52YXIgTm9Nb2RlID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICovXG4wOyAvLyBUT0RPOiBSZW1vdmUgQ29uY3VycmVudE1vZGUgYnkgcmVhZGluZyBmcm9tIHRoZSByb290IHRhZyBpbnN0ZWFkXG5cbnZhciBDb25jdXJyZW50TW9kZSA9XG4vKiAgICAgICAgICAgICAgICAgKi9cbjE7XG52YXIgUHJvZmlsZU1vZGUgPVxuLyogICAgICAgICAgICAgICAgICAgICovXG4yO1xudmFyIFN0cmljdExlZ2FjeU1vZGUgPVxuLyogICAgICAgICAgICAgICAqL1xuODtcbnZhciBTdHJpY3RFZmZlY3RzTW9kZSA9XG4vKiAgICAgICAgICAgICAgKi9cbjE2O1xudmFyIE5vU3RyaWN0UGFzc2l2ZUVmZmVjdHNNb2RlID1cbi8qICAgICAqL1xuNjQ7XG5cbi8vIFRPRE86IFRoaXMgaXMgcHJldHR5IHdlbGwgc3VwcG9ydGVkIGJ5IGJyb3dzZXJzLiBNYXliZSB3ZSBjYW4gZHJvcCBpdC5cbnZhciBjbHozMiA9IE1hdGguY2x6MzIgPyBNYXRoLmNsejMyIDogY2x6MzJGYWxsYmFjazsgLy8gQ291bnQgbGVhZGluZyB6ZXJvcy5cbi8vIEJhc2VkIG9uOlxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvTWF0aC9jbHozMlxuXG52YXIgbG9nJDEgPSBNYXRoLmxvZztcbnZhciBMTjIgPSBNYXRoLkxOMjtcblxuZnVuY3Rpb24gY2x6MzJGYWxsYmFjayh4KSB7XG4gIHZhciBhc1VpbnQgPSB4ID4+PiAwO1xuXG4gIGlmIChhc1VpbnQgPT09IDApIHtcbiAgICByZXR1cm4gMzI7XG4gIH1cblxuICByZXR1cm4gMzEgLSAobG9nJDEoYXNVaW50KSAvIExOMiB8IDApIHwgMDtcbn1cblxuLy8gSWYgdGhvc2UgdmFsdWVzIGFyZSBjaGFuZ2VkIHRoYXQgcGFja2FnZSBzaG91bGQgYmUgcmVidWlsdCBhbmQgcmVkZXBsb3llZC5cblxudmFyIFRvdGFsTGFuZXMgPSAzMTtcbnZhciBOb0xhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjA7XG52YXIgTm9MYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuMDtcbnZhciBTeW5jSHlkcmF0aW9uTGFuZSA9XG4vKiAgICAgICAgICAgICAgICovXG4xO1xudmFyIFN5bmNMYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjI7XG52YXIgU3luY0xhbmVJbmRleCA9IDE7XG52YXIgSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZSA9XG4vKiAgICAqL1xuNDtcbnZhciBJbnB1dENvbnRpbnVvdXNMYW5lID1cbi8qICAgICAgICAgICAgICovXG44O1xudmFyIERlZmF1bHRIeWRyYXRpb25MYW5lID1cbi8qICAgICAgICAgICAgKi9cbjE2O1xudmFyIERlZmF1bHRMYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICAgKi9cbjMyO1xudmFyIFN5bmNVcGRhdGVMYW5lcyA9IFN5bmNMYW5lIHwgSW5wdXRDb250aW51b3VzTGFuZSB8IERlZmF1bHRMYW5lIDtcbnZhciBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZSA9XG4vKiAgICAgICAgICAgICAgICAqL1xuNjQ7XG52YXIgVHJhbnNpdGlvbkxhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuNDE5NDE3NjtcbnZhciBUcmFuc2l0aW9uTGFuZTEgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTI4O1xudmFyIFRyYW5zaXRpb25MYW5lMiA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG4yNTY7XG52YXIgVHJhbnNpdGlvbkxhbmUzID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjUxMjtcbnZhciBUcmFuc2l0aW9uTGFuZTQgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTAyNDtcbnZhciBUcmFuc2l0aW9uTGFuZTUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMjA0ODtcbnZhciBUcmFuc2l0aW9uTGFuZTYgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuNDA5NjtcbnZhciBUcmFuc2l0aW9uTGFuZTcgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuODE5MjtcbnZhciBUcmFuc2l0aW9uTGFuZTggPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTYzODQ7XG52YXIgVHJhbnNpdGlvbkxhbmU5ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjMyNzY4O1xudmFyIFRyYW5zaXRpb25MYW5lMTAgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG42NTUzNjtcbnZhciBUcmFuc2l0aW9uTGFuZTExID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTMxMDcyO1xudmFyIFRyYW5zaXRpb25MYW5lMTIgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG4yNjIxNDQ7XG52YXIgVHJhbnNpdGlvbkxhbmUxMyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjUyNDI4ODtcbnZhciBUcmFuc2l0aW9uTGFuZTE0ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTA0ODU3NjtcbnZhciBUcmFuc2l0aW9uTGFuZTE1ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuMjA5NzE1MjtcbnZhciBSZXRyeUxhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG42MjkxNDU2MDtcbnZhciBSZXRyeUxhbmUxID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuNDE5NDMwNDtcbnZhciBSZXRyeUxhbmUyID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuODM4ODYwODtcbnZhciBSZXRyeUxhbmUzID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTY3NzcyMTY7XG52YXIgUmV0cnlMYW5lNCA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjMzNTU0NDMyO1xudmFyIFNvbWVSZXRyeUxhbmUgPSBSZXRyeUxhbmUxO1xudmFyIFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmUgPVxuLyogICAgICAgICAgKi9cbjY3MTA4ODY0O1xudmFyIE5vbklkbGVMYW5lcyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjEzNDIxNzcyNztcbnZhciBJZGxlSHlkcmF0aW9uTGFuZSA9XG4vKiAgICAgICAgICAgICAgICovXG4xMzQyMTc3Mjg7XG52YXIgSWRsZUxhbmUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMjY4NDM1NDU2O1xudmFyIE9mZnNjcmVlbkxhbmUgPVxuLyogICAgICAgICAgICAgICAgICAgKi9cbjUzNjg3MDkxMjtcbnZhciBEZWZlcnJlZExhbmUgPVxuLyogICAgICAgICAgICAgICAgICAgICovXG4xMDczNzQxODI0OyAvLyBBbnkgbGFuZSB0aGF0IG1pZ2h0IHNjaGVkdWxlIGFuIHVwZGF0ZS4gVGhpcyBpcyB1c2VkIHRvIGRldGVjdCBpbmZpbml0ZVxuLy8gdXBkYXRlIGxvb3BzLCBzbyBpdCBkb2Vzbid0IGluY2x1ZGUgaHlkcmF0aW9uIGxhbmVzIG9yIHJldHJpZXMuXG5cbnZhciBVcGRhdGVMYW5lcyA9IFN5bmNMYW5lIHwgSW5wdXRDb250aW51b3VzTGFuZSB8IERlZmF1bHRMYW5lIHwgVHJhbnNpdGlvbkxhbmVzOyAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgZm9yIHRoZSBleHBlcmltZW50YWwgdGltZWxpbmUgKHJlYWN0LWRldnRvb2xzLXRpbWVsaW5lKVxuLy8gSXQgc2hvdWxkIGJlIGtlcHQgaW4gc3luYyB3aXRoIHRoZSBMYW5lcyB2YWx1ZXMgYWJvdmUuXG5cbmZ1bmN0aW9uIGdldExhYmVsRm9yTGFuZShsYW5lKSB7XG4gIHtcbiAgICBpZiAobGFuZSAmIFN5bmNIeWRyYXRpb25MYW5lKSB7XG4gICAgICByZXR1cm4gJ1N5bmNIeWRyYXRpb25MYW5lJztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIFN5bmNMYW5lKSB7XG4gICAgICByZXR1cm4gJ1N5bmMnO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZSkge1xuICAgICAgcmV0dXJuICdJbnB1dENvbnRpbnVvdXNIeWRyYXRpb24nO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgSW5wdXRDb250aW51b3VzTGFuZSkge1xuICAgICAgcmV0dXJuICdJbnB1dENvbnRpbnVvdXMnO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgRGVmYXVsdEh5ZHJhdGlvbkxhbmUpIHtcbiAgICAgIHJldHVybiAnRGVmYXVsdEh5ZHJhdGlvbic7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBEZWZhdWx0TGFuZSkge1xuICAgICAgcmV0dXJuICdEZWZhdWx0JztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIFRyYW5zaXRpb25IeWRyYXRpb25MYW5lKSB7XG4gICAgICByZXR1cm4gJ1RyYW5zaXRpb25IeWRyYXRpb24nO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgVHJhbnNpdGlvbkxhbmVzKSB7XG4gICAgICByZXR1cm4gJ1RyYW5zaXRpb24nO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgUmV0cnlMYW5lcykge1xuICAgICAgcmV0dXJuICdSZXRyeSc7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBTZWxlY3RpdmVIeWRyYXRpb25MYW5lKSB7XG4gICAgICByZXR1cm4gJ1NlbGVjdGl2ZUh5ZHJhdGlvbic7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBJZGxlSHlkcmF0aW9uTGFuZSkge1xuICAgICAgcmV0dXJuICdJZGxlSHlkcmF0aW9uJztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIElkbGVMYW5lKSB7XG4gICAgICByZXR1cm4gJ0lkbGUnO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgT2Zmc2NyZWVuTGFuZSkge1xuICAgICAgcmV0dXJuICdPZmZzY3JlZW4nO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgRGVmZXJyZWRMYW5lKSB7XG4gICAgICByZXR1cm4gJ0RlZmVycmVkJztcbiAgICB9XG4gIH1cbn1cbnZhciBOb1RpbWVzdGFtcCA9IC0xO1xudmFyIG5leHRUcmFuc2l0aW9uTGFuZSA9IFRyYW5zaXRpb25MYW5lMTtcbnZhciBuZXh0UmV0cnlMYW5lID0gUmV0cnlMYW5lMTtcblxuZnVuY3Rpb24gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMobGFuZXMpIHtcbiAge1xuICAgIHZhciBwZW5kaW5nU3luY0xhbmVzID0gbGFuZXMgJiBTeW5jVXBkYXRlTGFuZXM7XG5cbiAgICBpZiAocGVuZGluZ1N5bmNMYW5lcyAhPT0gMCkge1xuICAgICAgcmV0dXJuIHBlbmRpbmdTeW5jTGFuZXM7XG4gICAgfVxuICB9XG5cbiAgc3dpdGNoIChnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKGxhbmVzKSkge1xuICAgIGNhc2UgU3luY0h5ZHJhdGlvbkxhbmU6XG4gICAgICByZXR1cm4gU3luY0h5ZHJhdGlvbkxhbmU7XG5cbiAgICBjYXNlIFN5bmNMYW5lOlxuICAgICAgcmV0dXJuIFN5bmNMYW5lO1xuXG4gICAgY2FzZSBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lOlxuICAgICAgcmV0dXJuIElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmU7XG5cbiAgICBjYXNlIElucHV0Q29udGludW91c0xhbmU6XG4gICAgICByZXR1cm4gSW5wdXRDb250aW51b3VzTGFuZTtcblxuICAgIGNhc2UgRGVmYXVsdEh5ZHJhdGlvbkxhbmU6XG4gICAgICByZXR1cm4gRGVmYXVsdEh5ZHJhdGlvbkxhbmU7XG5cbiAgICBjYXNlIERlZmF1bHRMYW5lOlxuICAgICAgcmV0dXJuIERlZmF1bHRMYW5lO1xuXG4gICAgY2FzZSBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTpcbiAgICAgIHJldHVybiBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTtcblxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUyOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUzOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU0OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU1OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU2OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU3OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU4OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU5OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMDpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTE6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTEyOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTQ6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE1OlxuICAgICAgcmV0dXJuIGxhbmVzICYgVHJhbnNpdGlvbkxhbmVzO1xuXG4gICAgY2FzZSBSZXRyeUxhbmUxOlxuICAgIGNhc2UgUmV0cnlMYW5lMjpcbiAgICBjYXNlIFJldHJ5TGFuZTM6XG4gICAgY2FzZSBSZXRyeUxhbmU0OlxuICAgICAgcmV0dXJuIGxhbmVzICYgUmV0cnlMYW5lcztcblxuICAgIGNhc2UgU2VsZWN0aXZlSHlkcmF0aW9uTGFuZTpcbiAgICAgIHJldHVybiBTZWxlY3RpdmVIeWRyYXRpb25MYW5lO1xuXG4gICAgY2FzZSBJZGxlSHlkcmF0aW9uTGFuZTpcbiAgICAgIHJldHVybiBJZGxlSHlkcmF0aW9uTGFuZTtcblxuICAgIGNhc2UgSWRsZUxhbmU6XG4gICAgICByZXR1cm4gSWRsZUxhbmU7XG5cbiAgICBjYXNlIE9mZnNjcmVlbkxhbmU6XG4gICAgICByZXR1cm4gT2Zmc2NyZWVuTGFuZTtcblxuICAgIGNhc2UgRGVmZXJyZWRMYW5lOlxuICAgICAgLy8gVGhpcyBzaG91bGRuJ3QgYmUgcmVhY2hhYmxlIGJlY2F1c2UgZGVmZXJyZWQgd29yayBpcyBhbHdheXMgZW50YW5nbGVkXG4gICAgICAvLyB3aXRoIHNvbWV0aGluZyBlbHNlLlxuICAgICAgcmV0dXJuIE5vTGFuZXM7XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBlcnJvcignU2hvdWxkIGhhdmUgZm91bmQgbWF0Y2hpbmcgbGFuZXMuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9IC8vIFRoaXMgc2hvdWxkbid0IGJlIHJlYWNoYWJsZSwgYnV0IGFzIGEgZmFsbGJhY2ssIHJldHVybiB0aGUgZW50aXJlIGJpdG1hc2suXG5cblxuICAgICAgcmV0dXJuIGxhbmVzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldE5leHRMYW5lcyhyb290LCB3aXBMYW5lcykge1xuICAvLyBFYXJseSBiYWlsb3V0IGlmIHRoZXJlJ3Mgbm8gcGVuZGluZyB3b3JrIGxlZnQuXG4gIHZhciBwZW5kaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcztcblxuICBpZiAocGVuZGluZ0xhbmVzID09PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuIE5vTGFuZXM7XG4gIH1cblxuICB2YXIgbmV4dExhbmVzID0gTm9MYW5lcztcbiAgdmFyIHN1c3BlbmRlZExhbmVzID0gcm9vdC5zdXNwZW5kZWRMYW5lcztcbiAgdmFyIHBpbmdlZExhbmVzID0gcm9vdC5waW5nZWRMYW5lczsgLy8gRG8gbm90IHdvcmsgb24gYW55IGlkbGUgd29yayB1bnRpbCBhbGwgdGhlIG5vbi1pZGxlIHdvcmsgaGFzIGZpbmlzaGVkLFxuICAvLyBldmVuIGlmIHRoZSB3b3JrIGlzIHN1c3BlbmRlZC5cblxuICB2YXIgbm9uSWRsZVBlbmRpbmdMYW5lcyA9IHBlbmRpbmdMYW5lcyAmIE5vbklkbGVMYW5lcztcblxuICBpZiAobm9uSWRsZVBlbmRpbmdMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgIHZhciBub25JZGxlVW5ibG9ja2VkTGFuZXMgPSBub25JZGxlUGVuZGluZ0xhbmVzICYgfnN1c3BlbmRlZExhbmVzO1xuXG4gICAgaWYgKG5vbklkbGVVbmJsb2NrZWRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgbmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMobm9uSWRsZVVuYmxvY2tlZExhbmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIG5vbklkbGVQaW5nZWRMYW5lcyA9IG5vbklkbGVQZW5kaW5nTGFuZXMgJiBwaW5nZWRMYW5lcztcblxuICAgICAgaWYgKG5vbklkbGVQaW5nZWRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgICBuZXh0TGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhub25JZGxlUGluZ2VkTGFuZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGUgb25seSByZW1haW5pbmcgd29yayBpcyBJZGxlLlxuICAgIHZhciB1bmJsb2NrZWRMYW5lcyA9IHBlbmRpbmdMYW5lcyAmIH5zdXNwZW5kZWRMYW5lcztcblxuICAgIGlmICh1bmJsb2NrZWRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgbmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXModW5ibG9ja2VkTGFuZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGluZ2VkTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgICAgbmV4dExhbmVzID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMocGluZ2VkTGFuZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChuZXh0TGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAvLyBUaGlzIHNob3VsZCBvbmx5IGJlIHJlYWNoYWJsZSBpZiB3ZSdyZSBzdXNwZW5kZWRcbiAgICAvLyBUT0RPOiBDb25zaWRlciB3YXJuaW5nIGluIHRoaXMgcGF0aCBpZiBhIGZhbGxiYWNrIHRpbWVyIGlzIG5vdCBzY2hlZHVsZWQuXG4gICAgcmV0dXJuIE5vTGFuZXM7XG4gIH0gLy8gSWYgd2UncmUgYWxyZWFkeSBpbiB0aGUgbWlkZGxlIG9mIGEgcmVuZGVyLCBzd2l0Y2hpbmcgbGFuZXMgd2lsbCBpbnRlcnJ1cHRcbiAgLy8gaXQgYW5kIHdlJ2xsIGxvc2Ugb3VyIHByb2dyZXNzLiBXZSBzaG91bGQgb25seSBkbyB0aGlzIGlmIHRoZSBuZXcgbGFuZXMgYXJlXG4gIC8vIGhpZ2hlciBwcmlvcml0eS5cblxuXG4gIGlmICh3aXBMYW5lcyAhPT0gTm9MYW5lcyAmJiB3aXBMYW5lcyAhPT0gbmV4dExhbmVzICYmIC8vIElmIHdlIGFscmVhZHkgc3VzcGVuZGVkIHdpdGggYSBkZWxheSwgdGhlbiBpbnRlcnJ1cHRpbmcgaXMgZmluZS4gRG9uJ3RcbiAgLy8gYm90aGVyIHdhaXRpbmcgdW50aWwgdGhlIHJvb3QgaXMgY29tcGxldGUuXG4gICh3aXBMYW5lcyAmIHN1c3BlbmRlZExhbmVzKSA9PT0gTm9MYW5lcykge1xuICAgIHZhciBuZXh0TGFuZSA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmUobmV4dExhbmVzKTtcbiAgICB2YXIgd2lwTGFuZSA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmUod2lwTGFuZXMpO1xuXG4gICAgaWYgKCAvLyBUZXN0cyB3aGV0aGVyIHRoZSBuZXh0IGxhbmUgaXMgZXF1YWwgb3IgbG93ZXIgcHJpb3JpdHkgdGhhbiB0aGUgd2lwXG4gICAgLy8gb25lLiBUaGlzIHdvcmtzIGJlY2F1c2UgdGhlIGJpdHMgZGVjcmVhc2UgaW4gcHJpb3JpdHkgYXMgeW91IGdvIGxlZnQuXG4gICAgbmV4dExhbmUgPj0gd2lwTGFuZSB8fCAvLyBEZWZhdWx0IHByaW9yaXR5IHVwZGF0ZXMgc2hvdWxkIG5vdCBpbnRlcnJ1cHQgdHJhbnNpdGlvbiB1cGRhdGVzLiBUaGVcbiAgICAvLyBvbmx5IGRpZmZlcmVuY2UgYmV0d2VlbiBkZWZhdWx0IHVwZGF0ZXMgYW5kIHRyYW5zaXRpb24gdXBkYXRlcyBpcyB0aGF0XG4gICAgLy8gZGVmYXVsdCB1cGRhdGVzIGRvIG5vdCBzdXBwb3J0IHJlZnJlc2ggdHJhbnNpdGlvbnMuXG4gICAgbmV4dExhbmUgPT09IERlZmF1bHRMYW5lICYmICh3aXBMYW5lICYgVHJhbnNpdGlvbkxhbmVzKSAhPT0gTm9MYW5lcykge1xuICAgICAgLy8gS2VlcCB3b3JraW5nIG9uIHRoZSBleGlzdGluZyBpbi1wcm9ncmVzcyB0cmVlLiBEbyBub3QgaW50ZXJydXB0LlxuICAgICAgcmV0dXJuIHdpcExhbmVzO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXh0TGFuZXM7XG59XG5mdW5jdGlvbiBnZXRFbnRhbmdsZWRMYW5lcyhyb290LCByZW5kZXJMYW5lcykge1xuICB2YXIgZW50YW5nbGVkTGFuZXMgPSByZW5kZXJMYW5lcztcblxuICBpZiAoKGVudGFuZ2xlZExhbmVzICYgSW5wdXRDb250aW51b3VzTGFuZSkgIT09IE5vTGFuZXMpIHtcbiAgICAvLyBXaGVuIHVwZGF0ZXMgYXJlIHN5bmMgYnkgZGVmYXVsdCwgd2UgZW50YW5nbGUgY29udGludW91cyBwcmlvcml0eSB1cGRhdGVzXG4gICAgLy8gYW5kIGRlZmF1bHQgdXBkYXRlcywgc28gdGhleSByZW5kZXIgaW4gdGhlIHNhbWUgYmF0Y2guIFRoZSBvbmx5IHJlYXNvblxuICAgIC8vIHRoZXkgdXNlIHNlcGFyYXRlIGxhbmVzIGlzIGJlY2F1c2UgY29udGludW91cyB1cGRhdGVzIHNob3VsZCBpbnRlcnJ1cHRcbiAgICAvLyB0cmFuc2l0aW9ucywgYnV0IGRlZmF1bHQgdXBkYXRlcyBzaG91bGQgbm90LlxuICAgIGVudGFuZ2xlZExhbmVzIHw9IGVudGFuZ2xlZExhbmVzICYgRGVmYXVsdExhbmU7XG4gIH0gLy8gQ2hlY2sgZm9yIGVudGFuZ2xlZCBsYW5lcyBhbmQgYWRkIHRoZW0gdG8gdGhlIGJhdGNoLlxuICAvL1xuICAvLyBBIGxhbmUgaXMgc2FpZCB0byBiZSBlbnRhbmdsZWQgd2l0aCBhbm90aGVyIHdoZW4gaXQncyBub3QgYWxsb3dlZCB0byByZW5kZXJcbiAgLy8gaW4gYSBiYXRjaCB0aGF0IGRvZXMgbm90IGFsc28gaW5jbHVkZSB0aGUgb3RoZXIgbGFuZS4gVHlwaWNhbGx5IHdlIGRvIHRoaXNcbiAgLy8gd2hlbiBtdWx0aXBsZSB1cGRhdGVzIGhhdmUgdGhlIHNhbWUgc291cmNlLCBhbmQgd2Ugb25seSB3YW50IHRvIHJlc3BvbmQgdG9cbiAgLy8gdGhlIG1vc3QgcmVjZW50IGV2ZW50IGZyb20gdGhhdCBzb3VyY2UuXG4gIC8vXG4gIC8vIE5vdGUgdGhhdCB3ZSBhcHBseSBlbnRhbmdsZW1lbnRzICphZnRlciogY2hlY2tpbmcgZm9yIHBhcnRpYWwgd29yayBhYm92ZS5cbiAgLy8gVGhpcyBtZWFucyB0aGF0IGlmIGEgbGFuZSBpcyBlbnRhbmdsZWQgZHVyaW5nIGFuIGludGVybGVhdmVkIGV2ZW50IHdoaWxlXG4gIC8vIGl0J3MgYWxyZWFkeSByZW5kZXJpbmcsIHdlIHdvbid0IGludGVycnVwdCBpdC4gVGhpcyBpcyBpbnRlbnRpb25hbCwgc2luY2VcbiAgLy8gZW50YW5nbGVtZW50IGlzIHVzdWFsbHkgXCJiZXN0IGVmZm9ydFwiOiB3ZSdsbCB0cnkgb3VyIGJlc3QgdG8gcmVuZGVyIHRoZVxuICAvLyBsYW5lcyBpbiB0aGUgc2FtZSBiYXRjaCwgYnV0IGl0J3Mgbm90IHdvcnRoIHRocm93aW5nIG91dCBwYXJ0aWFsbHlcbiAgLy8gY29tcGxldGVkIHdvcmsgaW4gb3JkZXIgdG8gZG8gaXQuXG4gIC8vIFRPRE86IFJlY29uc2lkZXIgdGhpcy4gVGhlIGNvdW50ZXItYXJndW1lbnQgaXMgdGhhdCB0aGUgcGFydGlhbCB3b3JrXG4gIC8vIHJlcHJlc2VudHMgYW4gaW50ZXJtZWRpYXRlIHN0YXRlLCB3aGljaCB3ZSBkb24ndCB3YW50IHRvIHNob3cgdG8gdGhlIHVzZXIuXG4gIC8vIEFuZCBieSBzcGVuZGluZyBleHRyYSB0aW1lIGZpbmlzaGluZyBpdCwgd2UncmUgaW5jcmVhc2luZyB0aGUgYW1vdW50IG9mXG4gIC8vIHRpbWUgaXQgdGFrZXMgdG8gc2hvdyB0aGUgZmluYWwgc3RhdGUsIHdoaWNoIGlzIHdoYXQgdGhleSBhcmUgYWN0dWFsbHlcbiAgLy8gd2FpdGluZyBmb3IuXG4gIC8vXG4gIC8vIEZvciB0aG9zZSBleGNlcHRpb25zIHdoZXJlIGVudGFuZ2xlbWVudCBpcyBzZW1hbnRpY2FsbHkgaW1wb3J0YW50LFxuICAvLyB3ZSBzaG91bGQgZW5zdXJlIHRoYXQgdGhlcmUgaXMgbm8gcGFydGlhbCB3b3JrIGF0IHRoZVxuICAvLyB0aW1lIHdlIGFwcGx5IHRoZSBlbnRhbmdsZW1lbnQuXG5cblxuICB2YXIgYWxsRW50YW5nbGVkTGFuZXMgPSByb290LmVudGFuZ2xlZExhbmVzO1xuXG4gIGlmIChhbGxFbnRhbmdsZWRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgIHZhciBlbnRhbmdsZW1lbnRzID0gcm9vdC5lbnRhbmdsZW1lbnRzO1xuICAgIHZhciBsYW5lcyA9IGVudGFuZ2xlZExhbmVzICYgYWxsRW50YW5nbGVkTGFuZXM7XG5cbiAgICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICAgIGVudGFuZ2xlZExhbmVzIHw9IGVudGFuZ2xlbWVudHNbaW5kZXhdO1xuICAgICAgbGFuZXMgJj0gfmxhbmU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGVudGFuZ2xlZExhbmVzO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlRXhwaXJhdGlvblRpbWUobGFuZSwgY3VycmVudFRpbWUpIHtcbiAgc3dpdGNoIChsYW5lKSB7XG4gICAgY2FzZSBTeW5jSHlkcmF0aW9uTGFuZTpcbiAgICBjYXNlIFN5bmNMYW5lOlxuICAgIGNhc2UgSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZTpcbiAgICBjYXNlIElucHV0Q29udGludW91c0xhbmU6XG4gICAgICAvLyBVc2VyIGludGVyYWN0aW9ucyBzaG91bGQgZXhwaXJlIHNsaWdodGx5IG1vcmUgcXVpY2tseS5cbiAgICAgIC8vXG4gICAgICAvLyBOT1RFOiBUaGlzIGlzIHNldCB0byB0aGUgY29ycmVzcG9uZGluZyBjb25zdGFudCBhcyBpbiBTY2hlZHVsZXIuanMuXG4gICAgICAvLyBXaGVuIHdlIG1hZGUgaXQgbGFyZ2VyLCBhIHByb2R1Y3QgbWV0cmljIGluIHd3dyByZWdyZXNzZWQsIHN1Z2dlc3RpbmdcbiAgICAgIC8vIHRoZXJlJ3MgYSB1c2VyIGludGVyYWN0aW9uIHRoYXQncyBiZWluZyBzdGFydmVkIGJ5IGEgc2VyaWVzIG9mXG4gICAgICAvLyBzeW5jaHJvbm91cyB1cGRhdGVzLiBJZiB0aGF0IHRoZW9yeSBpcyBjb3JyZWN0LCB0aGUgcHJvcGVyIHNvbHV0aW9uIGlzXG4gICAgICAvLyB0byBmaXggdGhlIHN0YXJ2YXRpb24uIEhvd2V2ZXIsIHRoaXMgc2NlbmFyaW8gc3VwcG9ydHMgdGhlIGlkZWEgdGhhdFxuICAgICAgLy8gZXhwaXJhdGlvbiB0aW1lcyBhcmUgYW4gaW1wb3J0YW50IHNhZmVndWFyZCB3aGVuIHN0YXJ2YXRpb25cbiAgICAgIC8vIGRvZXMgaGFwcGVuLlxuICAgICAgcmV0dXJuIGN1cnJlbnRUaW1lICsgc3luY0xhbmVFeHBpcmF0aW9uTXM7XG5cbiAgICBjYXNlIERlZmF1bHRIeWRyYXRpb25MYW5lOlxuICAgIGNhc2UgRGVmYXVsdExhbmU6XG4gICAgY2FzZSBUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNDpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lNzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lODpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lOTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTA6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTExOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMjpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTM6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE0OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxNTpcbiAgICAgIHJldHVybiBjdXJyZW50VGltZSArIHRyYW5zaXRpb25MYW5lRXhwaXJhdGlvbk1zO1xuXG4gICAgY2FzZSBSZXRyeUxhbmUxOlxuICAgIGNhc2UgUmV0cnlMYW5lMjpcbiAgICBjYXNlIFJldHJ5TGFuZTM6XG4gICAgY2FzZSBSZXRyeUxhbmU0OlxuICAgICAgLy8gVE9ETzogUmV0cmllcyBzaG91bGQgYmUgYWxsb3dlZCB0byBleHBpcmUgaWYgdGhleSBhcmUgQ1BVIGJvdW5kIGZvclxuICAgICAgLy8gdG9vIGxvbmcsIGJ1dCB3aGVuIEkgbWFkZSB0aGlzIGNoYW5nZSBpdCBjYXVzZWQgYSBzcGlrZSBpbiBicm93c2VyXG4gICAgICAvLyBjcmFzaGVzLiBUaGVyZSBtdXN0IGJlIHNvbWUgb3RoZXIgdW5kZXJseWluZyBidWc7IG5vdCBzdXBlciB1cmdlbnQgYnV0XG4gICAgICAvLyBpZGVhbGx5IHNob3VsZCBmaWd1cmUgb3V0IHdoeSBhbmQgZml4IGl0LiBVbmZvcnR1bmF0ZWx5IHdlIGRvbid0IGhhdmVcbiAgICAgIC8vIGEgcmVwcm8gZm9yIHRoZSBjcmFzaGVzLCBvbmx5IGRldGVjdGVkIHZpYSBwcm9kdWN0aW9uIG1ldHJpY3MuXG4gICAgICByZXR1cm4gTm9UaW1lc3RhbXA7XG5cbiAgICBjYXNlIFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmU6XG4gICAgY2FzZSBJZGxlSHlkcmF0aW9uTGFuZTpcbiAgICBjYXNlIElkbGVMYW5lOlxuICAgIGNhc2UgT2Zmc2NyZWVuTGFuZTpcbiAgICBjYXNlIERlZmVycmVkTGFuZTpcbiAgICAgIC8vIEFueXRoaW5nIGlkbGUgcHJpb3JpdHkgb3IgbG93ZXIgc2hvdWxkIG5ldmVyIGV4cGlyZS5cbiAgICAgIHJldHVybiBOb1RpbWVzdGFtcDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIGVycm9yKCdTaG91bGQgaGF2ZSBmb3VuZCBtYXRjaGluZyBsYW5lcy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIE5vVGltZXN0YW1wO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGFydmVkTGFuZXNBc0V4cGlyZWQocm9vdCwgY3VycmVudFRpbWUpIHtcbiAgLy8gVE9ETzogVGhpcyBnZXRzIGNhbGxlZCBldmVyeSB0aW1lIHdlIHlpZWxkLiBXZSBjYW4gb3B0aW1pemUgYnkgc3RvcmluZ1xuICAvLyB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiB0aW1lIG9uIHRoZSByb290LiBUaGVuIHVzZSB0aGF0IHRvIHF1aWNrbHkgYmFpbCBvdXRcbiAgLy8gb2YgdGhpcyBmdW5jdGlvbi5cbiAgdmFyIHBlbmRpbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzO1xuICB2YXIgc3VzcGVuZGVkTGFuZXMgPSByb290LnN1c3BlbmRlZExhbmVzO1xuICB2YXIgcGluZ2VkTGFuZXMgPSByb290LnBpbmdlZExhbmVzO1xuICB2YXIgZXhwaXJhdGlvblRpbWVzID0gcm9vdC5leHBpcmF0aW9uVGltZXM7IC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgcGVuZGluZyBsYW5lcyBhbmQgY2hlY2sgaWYgd2UndmUgcmVhY2hlZCB0aGVpclxuICAvLyBleHBpcmF0aW9uIHRpbWUuIElmIHNvLCB3ZSdsbCBhc3N1bWUgdGhlIHVwZGF0ZSBpcyBiZWluZyBzdGFydmVkIGFuZCBtYXJrXG4gIC8vIGl0IGFzIGV4cGlyZWQgdG8gZm9yY2UgaXQgdG8gZmluaXNoLlxuICAvLyBUT0RPOiBXZSBzaG91bGQgYmUgYWJsZSB0byByZXBsYWNlIHRoaXMgd2l0aCB1cGdyYWRlUGVuZGluZ0xhbmVzVG9TeW5jXG4gIC8vXG4gIC8vIFdlIGV4Y2x1ZGUgcmV0cnkgbGFuZXMgYmVjYXVzZSB0aG9zZSBtdXN0IGFsd2F5cyBiZSB0aW1lIHNsaWNlZCwgaW4gb3JkZXJcbiAgLy8gdG8gdW53cmFwIHVuY2FjaGVkIHByb21pc2VzLlxuICAvLyBUT0RPOiBXcml0ZSBhIHRlc3QgZm9yIHRoaXNcblxuICB2YXIgbGFuZXMgPSBwZW5kaW5nTGFuZXMgJiB+UmV0cnlMYW5lcztcblxuICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgdmFyIGluZGV4ID0gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7XG4gICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgIHZhciBleHBpcmF0aW9uVGltZSA9IGV4cGlyYXRpb25UaW1lc1tpbmRleF07XG5cbiAgICBpZiAoZXhwaXJhdGlvblRpbWUgPT09IE5vVGltZXN0YW1wKSB7XG4gICAgICAvLyBGb3VuZCBhIHBlbmRpbmcgbGFuZSB3aXRoIG5vIGV4cGlyYXRpb24gdGltZS4gSWYgaXQncyBub3Qgc3VzcGVuZGVkLCBvclxuICAgICAgLy8gaWYgaXQncyBwaW5nZWQsIGFzc3VtZSBpdCdzIENQVS1ib3VuZC4gQ29tcHV0ZSBhIG5ldyBleHBpcmF0aW9uIHRpbWVcbiAgICAgIC8vIHVzaW5nIHRoZSBjdXJyZW50IHRpbWUuXG4gICAgICBpZiAoKGxhbmUgJiBzdXNwZW5kZWRMYW5lcykgPT09IE5vTGFuZXMgfHwgKGxhbmUgJiBwaW5nZWRMYW5lcykgIT09IE5vTGFuZXMpIHtcbiAgICAgICAgLy8gQXNzdW1lcyB0aW1lc3RhbXBzIGFyZSBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcuXG4gICAgICAgIGV4cGlyYXRpb25UaW1lc1tpbmRleF0gPSBjb21wdXRlRXhwaXJhdGlvblRpbWUobGFuZSwgY3VycmVudFRpbWUpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZXhwaXJhdGlvblRpbWUgPD0gY3VycmVudFRpbWUpIHtcbiAgICAgIC8vIFRoaXMgbGFuZSBleHBpcmVkXG4gICAgICByb290LmV4cGlyZWRMYW5lcyB8PSBsYW5lO1xuICAgIH1cblxuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG59IC8vIFRoaXMgcmV0dXJucyB0aGUgaGlnaGVzdCBwcmlvcml0eSBwZW5kaW5nIGxhbmVzIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGV5XG4vLyBhcmUgc3VzcGVuZGVkLlxuXG5mdW5jdGlvbiBnZXRIaWdoZXN0UHJpb3JpdHlQZW5kaW5nTGFuZXMocm9vdCkge1xuICByZXR1cm4gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZXMocm9vdC5wZW5kaW5nTGFuZXMpO1xufVxuZnVuY3Rpb24gZ2V0TGFuZXNUb1JldHJ5U3luY2hyb25vdXNseU9uRXJyb3Iocm9vdCwgb3JpZ2luYWxseUF0dGVtcHRlZExhbmVzKSB7XG4gIGlmIChyb290LmVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzICYgb3JpZ2luYWxseUF0dGVtcHRlZExhbmVzKSB7XG4gICAgLy8gVGhlIGVycm9yIHJlY292ZXJ5IG1lY2hhbmlzbSBpcyBkaXNhYmxlZCB1bnRpbCB0aGVzZSBsYW5lcyBhcmUgY2xlYXJlZC5cbiAgICByZXR1cm4gTm9MYW5lcztcbiAgfVxuXG4gIHZhciBldmVyeXRoaW5nQnV0T2Zmc2NyZWVuID0gcm9vdC5wZW5kaW5nTGFuZXMgJiB+T2Zmc2NyZWVuTGFuZTtcblxuICBpZiAoZXZlcnl0aGluZ0J1dE9mZnNjcmVlbiAhPT0gTm9MYW5lcykge1xuICAgIHJldHVybiBldmVyeXRoaW5nQnV0T2Zmc2NyZWVuO1xuICB9XG5cbiAgaWYgKGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW4gJiBPZmZzY3JlZW5MYW5lKSB7XG4gICAgcmV0dXJuIE9mZnNjcmVlbkxhbmU7XG4gIH1cblxuICByZXR1cm4gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzU3luY0xhbmUobGFuZXMpIHtcbiAgcmV0dXJuIChsYW5lcyAmIChTeW5jTGFuZSB8IFN5bmNIeWRyYXRpb25MYW5lKSkgIT09IE5vTGFuZXM7XG59XG5mdW5jdGlvbiBpbmNsdWRlc05vbklkbGVXb3JrKGxhbmVzKSB7XG4gIHJldHVybiAobGFuZXMgJiBOb25JZGxlTGFuZXMpICE9PSBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNPbmx5UmV0cmllcyhsYW5lcykge1xuICByZXR1cm4gKGxhbmVzICYgUmV0cnlMYW5lcykgPT09IGxhbmVzO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNPbmx5Tm9uVXJnZW50TGFuZXMobGFuZXMpIHtcbiAgLy8gVE9ETzogU2hvdWxkIGh5ZHJhdGlvbiBsYW5lcyBiZSBpbmNsdWRlZCBoZXJlPyBUaGlzIGZ1bmN0aW9uIGlzIG9ubHlcbiAgLy8gdXNlZCBpbiBgdXBkYXRlRGVmZXJyZWRWYWx1ZUltcGxgLlxuICB2YXIgVXJnZW50TGFuZXMgPSBTeW5jTGFuZSB8IElucHV0Q29udGludW91c0xhbmUgfCBEZWZhdWx0TGFuZTtcbiAgcmV0dXJuIChsYW5lcyAmIFVyZ2VudExhbmVzKSA9PT0gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzT25seVRyYW5zaXRpb25zKGxhbmVzKSB7XG4gIHJldHVybiAobGFuZXMgJiBUcmFuc2l0aW9uTGFuZXMpID09PSBsYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzQmxvY2tpbmdMYW5lKHJvb3QsIGxhbmVzKSB7XG5cbiAgdmFyIFN5bmNEZWZhdWx0TGFuZXMgPSBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lIHwgSW5wdXRDb250aW51b3VzTGFuZSB8IERlZmF1bHRIeWRyYXRpb25MYW5lIHwgRGVmYXVsdExhbmU7XG4gIHJldHVybiAobGFuZXMgJiBTeW5jRGVmYXVsdExhbmVzKSAhPT0gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzRXhwaXJlZExhbmUocm9vdCwgbGFuZXMpIHtcbiAgLy8gVGhpcyBpcyBhIHNlcGFyYXRlIGNoZWNrIGZyb20gaW5jbHVkZXNCbG9ja2luZ0xhbmUgYmVjYXVzZSBhIGxhbmUgY2FuXG4gIC8vIGV4cGlyZSBhZnRlciBhIHJlbmRlciBoYXMgYWxyZWFkeSBzdGFydGVkLlxuICByZXR1cm4gKGxhbmVzICYgcm9vdC5leHBpcmVkTGFuZXMpICE9PSBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaXNUcmFuc2l0aW9uTGFuZShsYW5lKSB7XG4gIHJldHVybiAobGFuZSAmIFRyYW5zaXRpb25MYW5lcykgIT09IE5vTGFuZXM7XG59XG5mdW5jdGlvbiBjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSgpIHtcbiAgLy8gQ3ljbGUgdGhyb3VnaCB0aGUgbGFuZXMsIGFzc2lnbmluZyBlYWNoIG5ldyB0cmFuc2l0aW9uIHRvIHRoZSBuZXh0IGxhbmUuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgbWVhbnMgZXZlcnkgdHJhbnNpdGlvbiBnZXRzIGl0cyBvd24gbGFuZSwgdW50aWwgd2VcbiAgLy8gcnVuIG91dCBvZiBsYW5lcyBhbmQgY3ljbGUgYmFjayB0byB0aGUgYmVnaW5uaW5nLlxuICB2YXIgbGFuZSA9IG5leHRUcmFuc2l0aW9uTGFuZTtcbiAgbmV4dFRyYW5zaXRpb25MYW5lIDw8PSAxO1xuXG4gIGlmICgobmV4dFRyYW5zaXRpb25MYW5lICYgVHJhbnNpdGlvbkxhbmVzKSA9PT0gTm9MYW5lcykge1xuICAgIG5leHRUcmFuc2l0aW9uTGFuZSA9IFRyYW5zaXRpb25MYW5lMTtcbiAgfVxuXG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gY2xhaW1OZXh0UmV0cnlMYW5lKCkge1xuICB2YXIgbGFuZSA9IG5leHRSZXRyeUxhbmU7XG4gIG5leHRSZXRyeUxhbmUgPDw9IDE7XG5cbiAgaWYgKChuZXh0UmV0cnlMYW5lICYgUmV0cnlMYW5lcykgPT09IE5vTGFuZXMpIHtcbiAgICBuZXh0UmV0cnlMYW5lID0gUmV0cnlMYW5lMTtcbiAgfVxuXG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZShsYW5lcykge1xuICByZXR1cm4gbGFuZXMgJiAtbGFuZXM7XG59XG5mdW5jdGlvbiBwaWNrQXJiaXRyYXJ5TGFuZShsYW5lcykge1xuICAvLyBUaGlzIHdyYXBwZXIgZnVuY3Rpb24gZ2V0cyBpbmxpbmVkLiBPbmx5IGV4aXN0cyBzbyB0byBjb21tdW5pY2F0ZSB0aGF0IGl0XG4gIC8vIGRvZXNuJ3QgbWF0dGVyIHdoaWNoIGJpdCBpcyBzZWxlY3RlZDsgeW91IGNhbiBwaWNrIGFueSBiaXQgd2l0aG91dFxuICAvLyBhZmZlY3RpbmcgdGhlIGFsZ29yaXRobXMgd2hlcmUgaXRzIHVzZWQuIEhlcmUgSSdtIHVzaW5nXG4gIC8vIGdldEhpZ2hlc3RQcmlvcml0eUxhbmUgYmVjYXVzZSBpdCByZXF1aXJlcyB0aGUgZmV3ZXN0IG9wZXJhdGlvbnMuXG4gIHJldHVybiBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKGxhbmVzKTtcbn1cblxuZnVuY3Rpb24gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcykge1xuICByZXR1cm4gMzEgLSBjbHozMihsYW5lcyk7XG59XG5cbmZ1bmN0aW9uIGxhbmVUb0luZGV4KGxhbmUpIHtcbiAgcmV0dXJuIHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZSk7XG59XG5cbmZ1bmN0aW9uIGluY2x1ZGVzU29tZUxhbmUoYSwgYikge1xuICByZXR1cm4gKGEgJiBiKSAhPT0gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGlzU3Vic2V0T2ZMYW5lcyhzZXQsIHN1YnNldCkge1xuICByZXR1cm4gKHNldCAmIHN1YnNldCkgPT09IHN1YnNldDtcbn1cbmZ1bmN0aW9uIG1lcmdlTGFuZXMoYSwgYikge1xuICByZXR1cm4gYSB8IGI7XG59XG5mdW5jdGlvbiByZW1vdmVMYW5lcyhzZXQsIHN1YnNldCkge1xuICByZXR1cm4gc2V0ICYgfnN1YnNldDtcbn1cbmZ1bmN0aW9uIGludGVyc2VjdExhbmVzKGEsIGIpIHtcbiAgcmV0dXJuIGEgJiBiO1xufSAvLyBTZWVtcyByZWR1bmRhbnQsIGJ1dCBpdCBjaGFuZ2VzIHRoZSB0eXBlIGZyb20gYSBzaW5nbGUgbGFuZSAodXNlZCBmb3Jcbi8vIHVwZGF0ZXMpIHRvIGEgZ3JvdXAgb2YgbGFuZXMgKHVzZWQgZm9yIGZsdXNoaW5nIHdvcmspLlxuXG5mdW5jdGlvbiBsYW5lVG9MYW5lcyhsYW5lKSB7XG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gaGlnaGVyUHJpb3JpdHlMYW5lKGEsIGIpIHtcbiAgLy8gVGhpcyB3b3JrcyBiZWNhdXNlIHRoZSBiaXQgcmFuZ2VzIGRlY3JlYXNlIGluIHByaW9yaXR5IGFzIHlvdSBnbyBsZWZ0LlxuICByZXR1cm4gYSAhPT0gTm9MYW5lICYmIGEgPCBiID8gYSA6IGI7XG59XG5mdW5jdGlvbiBjcmVhdGVMYW5lTWFwKGluaXRpYWwpIHtcbiAgLy8gSW50ZW50aW9uYWxseSBwdXNoaW5nIG9uZSBieSBvbmUuXG4gIC8vIGh0dHBzOi8vdjguZGV2L2Jsb2cvZWxlbWVudHMta2luZHMjYXZvaWQtY3JlYXRpbmctaG9sZXNcbiAgdmFyIGxhbmVNYXAgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IFRvdGFsTGFuZXM7IGkrKykge1xuICAgIGxhbmVNYXAucHVzaChpbml0aWFsKTtcbiAgfVxuXG4gIHJldHVybiBsYW5lTWFwO1xufVxuZnVuY3Rpb24gbWFya1Jvb3RVcGRhdGVkJDEocm9vdCwgdXBkYXRlTGFuZSkge1xuICByb290LnBlbmRpbmdMYW5lcyB8PSB1cGRhdGVMYW5lOyAvLyBJZiB0aGVyZSBhcmUgYW55IHN1c3BlbmRlZCB0cmFuc2l0aW9ucywgaXQncyBwb3NzaWJsZSB0aGlzIG5ldyB1cGRhdGVcbiAgLy8gY291bGQgdW5ibG9jayB0aGVtLiBDbGVhciB0aGUgc3VzcGVuZGVkIGxhbmVzIHNvIHRoYXQgd2UgY2FuIHRyeSByZW5kZXJpbmdcbiAgLy8gdGhlbSBhZ2Fpbi5cbiAgLy9cbiAgLy8gVE9ETzogV2UgcmVhbGx5IG9ubHkgbmVlZCB0byB1bnN1c3BlbmQgb25seSBsYW5lcyB0aGF0IGFyZSBpbiB0aGVcbiAgLy8gYHN1YnRyZWVMYW5lc2Agb2YgdGhlIHVwZGF0ZWQgZmliZXIsIG9yIHRoZSB1cGRhdGUgbGFuZXMgb2YgdGhlIHJldHVyblxuICAvLyBwYXRoLiBUaGlzIHdvdWxkIGV4Y2x1ZGUgc3VzcGVuZGVkIHVwZGF0ZXMgaW4gYW4gdW5yZWxhdGVkIHNpYmxpbmcgdHJlZSxcbiAgLy8gc2luY2UgdGhlcmUncyBubyB3YXkgZm9yIHRoaXMgdXBkYXRlIHRvIHVuYmxvY2sgaXQuXG4gIC8vXG4gIC8vIFdlIGRvbid0IGRvIHRoaXMgaWYgdGhlIGluY29taW5nIHVwZGF0ZSBpcyBpZGxlLCBiZWNhdXNlIHdlIG5ldmVyIHByb2Nlc3NcbiAgLy8gaWRsZSB1cGRhdGVzIHVudGlsIGFmdGVyIGFsbCB0aGUgcmVndWxhciB1cGRhdGVzIGhhdmUgZmluaXNoZWQ7IHRoZXJlJ3Mgbm9cbiAgLy8gd2F5IGl0IGNvdWxkIHVuYmxvY2sgYSB0cmFuc2l0aW9uLlxuXG4gIGlmICh1cGRhdGVMYW5lICE9PSBJZGxlTGFuZSkge1xuICAgIHJvb3Quc3VzcGVuZGVkTGFuZXMgPSBOb0xhbmVzO1xuICAgIHJvb3QucGluZ2VkTGFuZXMgPSBOb0xhbmVzO1xuICB9XG59XG5mdW5jdGlvbiBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIHN1c3BlbmRlZExhbmVzLCBzcGF3bmVkTGFuZSkge1xuICByb290LnN1c3BlbmRlZExhbmVzIHw9IHN1c3BlbmRlZExhbmVzO1xuICByb290LnBpbmdlZExhbmVzICY9IH5zdXNwZW5kZWRMYW5lczsgLy8gVGhlIHN1c3BlbmRlZCBsYW5lcyBhcmUgbm8gbG9uZ2VyIENQVS1ib3VuZC4gQ2xlYXIgdGhlaXIgZXhwaXJhdGlvbiB0aW1lcy5cblxuICB2YXIgZXhwaXJhdGlvblRpbWVzID0gcm9vdC5leHBpcmF0aW9uVGltZXM7XG4gIHZhciBsYW5lcyA9IHN1c3BlbmRlZExhbmVzO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgZXhwaXJhdGlvblRpbWVzW2luZGV4XSA9IE5vVGltZXN0YW1wO1xuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG5cbiAgaWYgKHNwYXduZWRMYW5lICE9PSBOb0xhbmUpIHtcbiAgICBtYXJrU3Bhd25lZERlZmVycmVkTGFuZShyb290LCBzcGF3bmVkTGFuZSwgc3VzcGVuZGVkTGFuZXMpO1xuICB9XG59XG5mdW5jdGlvbiBtYXJrUm9vdFBpbmdlZCQxKHJvb3QsIHBpbmdlZExhbmVzKSB7XG4gIHJvb3QucGluZ2VkTGFuZXMgfD0gcm9vdC5zdXNwZW5kZWRMYW5lcyAmIHBpbmdlZExhbmVzO1xufVxuZnVuY3Rpb24gbWFya1Jvb3RGaW5pc2hlZChyb290LCByZW1haW5pbmdMYW5lcywgc3Bhd25lZExhbmUpIHtcbiAgdmFyIG5vTG9uZ2VyUGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXMgJiB+cmVtYWluaW5nTGFuZXM7XG4gIHJvb3QucGVuZGluZ0xhbmVzID0gcmVtYWluaW5nTGFuZXM7IC8vIExldCdzIHRyeSBldmVyeXRoaW5nIGFnYWluXG5cbiAgcm9vdC5zdXNwZW5kZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHJvb3QucGluZ2VkTGFuZXMgPSBOb0xhbmVzO1xuICByb290LmV4cGlyZWRMYW5lcyAmPSByZW1haW5pbmdMYW5lcztcbiAgcm9vdC5lbnRhbmdsZWRMYW5lcyAmPSByZW1haW5pbmdMYW5lcztcbiAgcm9vdC5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyAmPSByZW1haW5pbmdMYW5lcztcbiAgcm9vdC5zaGVsbFN1c3BlbmRDb3VudGVyID0gMDtcbiAgdmFyIGVudGFuZ2xlbWVudHMgPSByb290LmVudGFuZ2xlbWVudHM7XG4gIHZhciBleHBpcmF0aW9uVGltZXMgPSByb290LmV4cGlyYXRpb25UaW1lcztcbiAgdmFyIGhpZGRlblVwZGF0ZXMgPSByb290LmhpZGRlblVwZGF0ZXM7IC8vIENsZWFyIHRoZSBsYW5lcyB0aGF0IG5vIGxvbmdlciBoYXZlIHBlbmRpbmcgd29ya1xuXG4gIHZhciBsYW5lcyA9IG5vTG9uZ2VyUGVuZGluZ0xhbmVzO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgZW50YW5nbGVtZW50c1tpbmRleF0gPSBOb0xhbmVzO1xuICAgIGV4cGlyYXRpb25UaW1lc1tpbmRleF0gPSBOb1RpbWVzdGFtcDtcbiAgICB2YXIgaGlkZGVuVXBkYXRlc0ZvckxhbmUgPSBoaWRkZW5VcGRhdGVzW2luZGV4XTtcblxuICAgIGlmIChoaWRkZW5VcGRhdGVzRm9yTGFuZSAhPT0gbnVsbCkge1xuICAgICAgaGlkZGVuVXBkYXRlc1tpbmRleF0gPSBudWxsOyAvLyBcIkhpZGRlblwiIHVwZGF0ZXMgYXJlIHVwZGF0ZXMgdGhhdCB3ZXJlIG1hZGUgdG8gYSBoaWRkZW4gY29tcG9uZW50LiBUaGV5XG4gICAgICAvLyBoYXZlIHNwZWNpYWwgbG9naWMgYXNzb2NpYXRlZCB3aXRoIHRoZW0gYmVjYXVzZSB0aGV5IG1heSBiZSBlbnRhbmdsZWRcbiAgICAgIC8vIHdpdGggdXBkYXRlcyB0aGF0IG9jY3VyIG91dHNpZGUgdGhhdCB0cmVlLiBCdXQgb25jZSB0aGUgb3V0ZXIgdHJlZVxuICAgICAgLy8gY29tbWl0cywgdGhleSBiZWhhdmUgbGlrZSByZWd1bGFyIHVwZGF0ZXMuXG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGlkZGVuVXBkYXRlc0ZvckxhbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IGhpZGRlblVwZGF0ZXNGb3JMYW5lW2ldO1xuXG4gICAgICAgIGlmICh1cGRhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICB1cGRhdGUubGFuZSAmPSB+T2Zmc2NyZWVuTGFuZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG5cbiAgaWYgKHNwYXduZWRMYW5lICE9PSBOb0xhbmUpIHtcbiAgICBtYXJrU3Bhd25lZERlZmVycmVkTGFuZShyb290LCBzcGF3bmVkTGFuZSwgLy8gVGhpcyByZW5kZXIgZmluaXNoZWQgc3VjY2Vzc2Z1bGx5IHdpdGhvdXQgc3VzcGVuZGluZywgc28gd2UgZG9uJ3QgbmVlZFxuICAgIC8vIHRvIGVudGFuZ2xlIHRoZSBzcGF3bmVkIHRhc2sgd2l0aCB0aGUgcGFyZW50IHRhc2suXG4gICAgTm9MYW5lcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1NwYXduZWREZWZlcnJlZExhbmUocm9vdCwgc3Bhd25lZExhbmUsIGVudGFuZ2xlZExhbmVzKSB7XG4gIC8vIFRoaXMgcmVuZGVyIHNwYXduZWQgYSBkZWZlcnJlZCB0YXNrLiBNYXJrIGl0IGFzIHBlbmRpbmcuXG4gIHJvb3QucGVuZGluZ0xhbmVzIHw9IHNwYXduZWRMYW5lO1xuICByb290LnN1c3BlbmRlZExhbmVzICY9IH5zcGF3bmVkTGFuZTsgLy8gRW50YW5nbGUgdGhlIHNwYXduZWQgbGFuZSB3aXRoIHRoZSBEZWZlcnJlZExhbmUgYml0IHNvIHRoYXQgd2Uga25vdyBpdFxuICAvLyB3YXMgdGhlIHJlc3VsdCBvZiBhbm90aGVyIHJlbmRlci4gVGhpcyBsZXRzIHVzIGF2b2lkIGEgdXNlRGVmZXJyZWRWYWx1ZVxuICAvLyB3YXRlcmZhbGwg4oCUIG9ubHkgdGhlIGZpcnN0IGxldmVsIHdpbGwgZGVmZXIuXG5cbiAgdmFyIHNwYXduZWRMYW5lSW5kZXggPSBsYW5lVG9JbmRleChzcGF3bmVkTGFuZSk7XG4gIHJvb3QuZW50YW5nbGVkTGFuZXMgfD0gc3Bhd25lZExhbmU7XG4gIHJvb3QuZW50YW5nbGVtZW50c1tzcGF3bmVkTGFuZUluZGV4XSB8PSBEZWZlcnJlZExhbmUgfCAvLyBJZiB0aGUgcGFyZW50IHJlbmRlciB0YXNrIHN1c3BlbmRlZCwgd2UgbXVzdCBhbHNvIGVudGFuZ2xlIHRob3NlIGxhbmVzXG4gIC8vIHdpdGggdGhlIHNwYXduZWQgdGFzaywgc28gdGhhdCB0aGUgZGVmZXJyZWQgdGFzayBpbmNsdWRlcyBhbGwgdGhlIHNhbWVcbiAgLy8gdXBkYXRlcyB0aGF0IHRoZSBwYXJlbnQgdGFzayBkaWQuIFdlIGNhbiBleGNsdWRlIGFueSBsYW5lIHRoYXQgaXMgbm90XG4gIC8vIHVzZWQgZm9yIHVwZGF0ZXMgKGUuZy4gT2Zmc2NyZWVuKS5cbiAgZW50YW5nbGVkTGFuZXMgJiBVcGRhdGVMYW5lcztcbn1cblxuZnVuY3Rpb24gbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgZW50YW5nbGVkTGFuZXMpIHtcbiAgLy8gSW4gYWRkaXRpb24gdG8gZW50YW5nbGluZyBlYWNoIG9mIHRoZSBnaXZlbiBsYW5lcyB3aXRoIGVhY2ggb3RoZXIsIHdlIGFsc29cbiAgLy8gaGF2ZSB0byBjb25zaWRlciBfdHJhbnNpdGl2ZV8gZW50YW5nbGVtZW50cy4gRm9yIGVhY2ggbGFuZSB0aGF0IGlzIGFscmVhZHlcbiAgLy8gZW50YW5nbGVkIHdpdGggKmFueSogb2YgdGhlIGdpdmVuIGxhbmVzLCB0aGF0IGxhbmUgaXMgbm93IHRyYW5zaXRpdmVseVxuICAvLyBlbnRhbmdsZWQgd2l0aCAqYWxsKiB0aGUgZ2l2ZW4gbGFuZXMuXG4gIC8vXG4gIC8vIFRyYW5zbGF0ZWQ6IElmIEMgaXMgZW50YW5nbGVkIHdpdGggQSwgdGhlbiBlbnRhbmdsaW5nIEEgd2l0aCBCIGFsc29cbiAgLy8gZW50YW5nbGVzIEMgd2l0aCBCLlxuICAvL1xuICAvLyBJZiB0aGlzIGlzIGhhcmQgdG8gZ3Jhc3AsIGl0IG1pZ2h0IGhlbHAgdG8gaW50ZW50aW9uYWxseSBicmVhayB0aGlzXG4gIC8vIGZ1bmN0aW9uIGFuZCBsb29rIGF0IHRoZSB0ZXN0cyB0aGF0IGZhaWwgaW4gUmVhY3RUcmFuc2l0aW9uLXRlc3QuanMuIFRyeVxuICAvLyBjb21tZW50aW5nIG91dCBvbmUgb2YgdGhlIGNvbmRpdGlvbnMgYmVsb3cuXG4gIHZhciByb290RW50YW5nbGVkTGFuZXMgPSByb290LmVudGFuZ2xlZExhbmVzIHw9IGVudGFuZ2xlZExhbmVzO1xuICB2YXIgZW50YW5nbGVtZW50cyA9IHJvb3QuZW50YW5nbGVtZW50cztcbiAgdmFyIGxhbmVzID0gcm9vdEVudGFuZ2xlZExhbmVzO1xuXG4gIHdoaWxlIChsYW5lcykge1xuICAgIHZhciBpbmRleCA9IHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO1xuICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcblxuICAgIGlmICggLy8gSXMgdGhpcyBvbmUgb2YgdGhlIG5ld2x5IGVudGFuZ2xlZCBsYW5lcz9cbiAgICBsYW5lICYgZW50YW5nbGVkTGFuZXMgfCAvLyBJcyB0aGlzIGxhbmUgdHJhbnNpdGl2ZWx5IGVudGFuZ2xlZCB3aXRoIHRoZSBuZXdseSBlbnRhbmdsZWQgbGFuZXM/XG4gICAgZW50YW5nbGVtZW50c1tpbmRleF0gJiBlbnRhbmdsZWRMYW5lcykge1xuICAgICAgZW50YW5nbGVtZW50c1tpbmRleF0gfD0gZW50YW5nbGVkTGFuZXM7XG4gICAgfVxuXG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cbn1cbmZ1bmN0aW9uIHVwZ3JhZGVQZW5kaW5nTGFuZVRvU3luYyhyb290LCBsYW5lKSB7XG4gIC8vIFNpbmNlIHdlJ3JlIHVwZ3JhZGluZyB0aGUgcHJpb3JpdHkgb2YgdGhlIGdpdmVuIGxhbmUsIHRoZXJlIGlzIG5vdyBwZW5kaW5nXG4gIC8vIHN5bmMgd29yay5cbiAgcm9vdC5wZW5kaW5nTGFuZXMgfD0gU3luY0xhbmU7IC8vIEVudGFuZ2xlIHRoZSBzeW5jIGxhbmUgd2l0aCB0aGUgbGFuZSB3ZSdyZSB1cGdyYWRpbmcuIFRoaXMgbWVhbnMgU3luY0xhbmVcbiAgLy8gd2lsbCBub3QgYmUgYWxsb3dlZCB0byBmaW5pc2ggd2l0aG91dCBhbHNvIGZpbmlzaGluZyB0aGUgZ2l2ZW4gbGFuZS5cblxuICByb290LmVudGFuZ2xlZExhbmVzIHw9IFN5bmNMYW5lO1xuICByb290LmVudGFuZ2xlbWVudHNbU3luY0xhbmVJbmRleF0gfD0gbGFuZTtcbn1cbmZ1bmN0aW9uIHVwZ3JhZGVQZW5kaW5nTGFuZXNUb1N5bmMocm9vdCwgbGFuZXNUb1VwZ3JhZGUpIHtcbiAgLy8gU2FtZSBhcyB1cGdyYWRlUGVuZGluZ0xhbmVUb1N5bmMgYnV0IGFjY2VwdHMgbXVsdGlwbGUgbGFuZXMsIHNvIGl0J3MgYVxuICAvLyBiaXQgc2xvd2VyLlxuICByb290LnBlbmRpbmdMYW5lcyB8PSBTeW5jTGFuZTtcbiAgcm9vdC5lbnRhbmdsZWRMYW5lcyB8PSBTeW5jTGFuZTtcbiAgdmFyIGxhbmVzID0gbGFuZXNUb1VwZ3JhZGU7XG5cbiAgd2hpbGUgKGxhbmVzKSB7XG4gICAgdmFyIGluZGV4ID0gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7XG4gICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgIHJvb3QuZW50YW5nbGVtZW50c1tTeW5jTGFuZUluZGV4XSB8PSBsYW5lO1xuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG59XG5mdW5jdGlvbiBtYXJrSGlkZGVuVXBkYXRlKHJvb3QsIHVwZGF0ZSwgbGFuZSkge1xuICB2YXIgaW5kZXggPSBsYW5lVG9JbmRleChsYW5lKTtcbiAgdmFyIGhpZGRlblVwZGF0ZXMgPSByb290LmhpZGRlblVwZGF0ZXM7XG4gIHZhciBoaWRkZW5VcGRhdGVzRm9yTGFuZSA9IGhpZGRlblVwZGF0ZXNbaW5kZXhdO1xuXG4gIGlmIChoaWRkZW5VcGRhdGVzRm9yTGFuZSA9PT0gbnVsbCkge1xuICAgIGhpZGRlblVwZGF0ZXNbaW5kZXhdID0gW3VwZGF0ZV07XG4gIH0gZWxzZSB7XG4gICAgaGlkZGVuVXBkYXRlc0ZvckxhbmUucHVzaCh1cGRhdGUpO1xuICB9XG5cbiAgdXBkYXRlLmxhbmUgPSBsYW5lIHwgT2Zmc2NyZWVuTGFuZTtcbn1cbmZ1bmN0aW9uIGdldEJ1bXBlZExhbmVGb3JIeWRyYXRpb24ocm9vdCwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIHJlbmRlckxhbmUgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKHJlbmRlckxhbmVzKTtcbiAgdmFyIGxhbmU7XG5cbiAgaWYgKChyZW5kZXJMYW5lICYgU3luY1VwZGF0ZUxhbmVzKSAhPT0gTm9MYW5lKSB7XG4gICAgbGFuZSA9IFN5bmNIeWRyYXRpb25MYW5lO1xuICB9IGVsc2Uge1xuICAgIHN3aXRjaCAocmVuZGVyTGFuZSkge1xuICAgICAgY2FzZSBTeW5jTGFuZTpcbiAgICAgICAgbGFuZSA9IFN5bmNIeWRyYXRpb25MYW5lO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBJbnB1dENvbnRpbnVvdXNMYW5lOlxuICAgICAgICBsYW5lID0gSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRGVmYXVsdExhbmU6XG4gICAgICAgIGxhbmUgPSBEZWZhdWx0SHlkcmF0aW9uTGFuZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxOlxuICAgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTI6XG4gICAgICBjYXNlIFRyYW5zaXRpb25MYW5lMzpcbiAgICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU0OlxuICAgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTU6XG4gICAgICBjYXNlIFRyYW5zaXRpb25MYW5lNjpcbiAgICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU3OlxuICAgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTg6XG4gICAgICBjYXNlIFRyYW5zaXRpb25MYW5lOTpcbiAgICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMDpcbiAgICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMTpcbiAgICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMjpcbiAgICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMzpcbiAgICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxNDpcbiAgICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxNTpcbiAgICAgIGNhc2UgUmV0cnlMYW5lMTpcbiAgICAgIGNhc2UgUmV0cnlMYW5lMjpcbiAgICAgIGNhc2UgUmV0cnlMYW5lMzpcbiAgICAgIGNhc2UgUmV0cnlMYW5lNDpcbiAgICAgICAgbGFuZSA9IFRyYW5zaXRpb25IeWRyYXRpb25MYW5lO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBJZGxlTGFuZTpcbiAgICAgICAgbGFuZSA9IElkbGVIeWRyYXRpb25MYW5lO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgLy8gRXZlcnl0aGluZyBlbHNlIGlzIGFscmVhZHkgZWl0aGVyIGEgaHlkcmF0aW9uIGxhbmUsIG9yIHNob3VsZG4ndFxuICAgICAgICAvLyBiZSByZXRyaWVkIGF0IGEgaHlkcmF0aW9uIGxhbmUuXG4gICAgICAgIGxhbmUgPSBOb0xhbmU7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfSAvLyBDaGVjayBpZiB0aGUgbGFuZSB3ZSBjaG9zZSBpcyBzdXNwZW5kZWQuIElmIHNvLCB0aGF0IGluZGljYXRlcyB0aGF0IHdlXG4gIC8vIGFscmVhZHkgYXR0ZW1wdGVkIGFuZCBmYWlsZWQgdG8gaHlkcmF0ZSBhdCB0aGF0IGxldmVsLiBBbHNvIGNoZWNrIGlmIHdlJ3JlXG4gIC8vIGFscmVhZHkgcmVuZGVyaW5nIHRoYXQgbGFuZSwgd2hpY2ggaXMgcmFyZSBidXQgY291bGQgaGFwcGVuLlxuXG5cbiAgaWYgKChsYW5lICYgKHJvb3Quc3VzcGVuZGVkTGFuZXMgfCByZW5kZXJMYW5lcykpICE9PSBOb0xhbmUpIHtcbiAgICAvLyBHaXZlIHVwIHRyeWluZyB0byBoeWRyYXRlIGFuZCBmYWxsIGJhY2sgdG8gY2xpZW50IHJlbmRlci5cbiAgICByZXR1cm4gTm9MYW5lO1xuICB9XG5cbiAgcmV0dXJuIGxhbmU7XG59XG5mdW5jdGlvbiBhZGRGaWJlclRvTGFuZXNNYXAocm9vdCwgZmliZXIsIGxhbmVzKSB7XG5cbiAgaWYgKCFpc0RldlRvb2xzUHJlc2VudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwZW5kaW5nVXBkYXRlcnNMYW5lTWFwID0gcm9vdC5wZW5kaW5nVXBkYXRlcnNMYW5lTWFwO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBsYW5lVG9JbmRleChsYW5lcyk7XG4gICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgIHZhciB1cGRhdGVycyA9IHBlbmRpbmdVcGRhdGVyc0xhbmVNYXBbaW5kZXhdO1xuICAgIHVwZGF0ZXJzLmFkZChmaWJlcik7XG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cbn1cbmZ1bmN0aW9uIG1vdmVQZW5kaW5nRmliZXJzVG9NZW1vaXplZChyb290LCBsYW5lcykge1xuXG4gIGlmICghaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCA9IHJvb3QucGVuZGluZ1VwZGF0ZXJzTGFuZU1hcDtcbiAgdmFyIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG5cbiAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgIHZhciBpbmRleCA9IGxhbmVUb0luZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgdmFyIHVwZGF0ZXJzID0gcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcFtpbmRleF07XG5cbiAgICBpZiAodXBkYXRlcnMuc2l6ZSA+IDApIHtcbiAgICAgIHVwZGF0ZXJzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgICAgaWYgKGFsdGVybmF0ZSA9PT0gbnVsbCB8fCAhbWVtb2l6ZWRVcGRhdGVycy5oYXMoYWx0ZXJuYXRlKSkge1xuICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMuYWRkKGZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB1cGRhdGVycy5jbGVhcigpO1xuICAgIH1cblxuICAgIGxhbmVzICY9IH5sYW5lO1xuICB9XG59XG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uc0ZvckxhbmVzKHJvb3QsIGxhbmVzKSB7XG4gIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG52YXIgRGlzY3JldGVFdmVudFByaW9yaXR5ID0gU3luY0xhbmU7XG52YXIgQ29udGludW91c0V2ZW50UHJpb3JpdHkgPSBJbnB1dENvbnRpbnVvdXNMYW5lO1xudmFyIERlZmF1bHRFdmVudFByaW9yaXR5ID0gRGVmYXVsdExhbmU7XG52YXIgSWRsZUV2ZW50UHJpb3JpdHkgPSBJZGxlTGFuZTtcbmZ1bmN0aW9uIGhpZ2hlckV2ZW50UHJpb3JpdHkoYSwgYikge1xuICByZXR1cm4gYSAhPT0gMCAmJiBhIDwgYiA/IGEgOiBiO1xufVxuZnVuY3Rpb24gbG93ZXJFdmVudFByaW9yaXR5KGEsIGIpIHtcbiAgcmV0dXJuIGEgPT09IDAgfHwgYSA+IGIgPyBhIDogYjtcbn1cbmZ1bmN0aW9uIGlzSGlnaGVyRXZlbnRQcmlvcml0eShhLCBiKSB7XG4gIHJldHVybiBhICE9PSAwICYmIGEgPCBiO1xufVxuZnVuY3Rpb24gZXZlbnRQcmlvcml0eVRvTGFuZSh1cGRhdGVQcmlvcml0eSkge1xuICByZXR1cm4gdXBkYXRlUHJpb3JpdHk7XG59XG5mdW5jdGlvbiBsYW5lc1RvRXZlbnRQcmlvcml0eShsYW5lcykge1xuICB2YXIgbGFuZSA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmUobGFuZXMpO1xuXG4gIGlmICghaXNIaWdoZXJFdmVudFByaW9yaXR5KERpc2NyZXRlRXZlbnRQcmlvcml0eSwgbGFuZSkpIHtcbiAgICByZXR1cm4gRGlzY3JldGVFdmVudFByaW9yaXR5O1xuICB9XG5cbiAgaWYgKCFpc0hpZ2hlckV2ZW50UHJpb3JpdHkoQ29udGludW91c0V2ZW50UHJpb3JpdHksIGxhbmUpKSB7XG4gICAgcmV0dXJuIENvbnRpbnVvdXNFdmVudFByaW9yaXR5O1xuICB9XG5cbiAgaWYgKGluY2x1ZGVzTm9uSWRsZVdvcmsobGFuZSkpIHtcbiAgICByZXR1cm4gRGVmYXVsdEV2ZW50UHJpb3JpdHk7XG4gIH1cblxuICByZXR1cm4gSWRsZUV2ZW50UHJpb3JpdHk7XG59XG5cbi8vIFRoaXMgbW9kdWxlIG9ubHkgZXhpc3RzIGFzIGFuIEVTTSB3cmFwcGVyIGFyb3VuZCB0aGUgZXh0ZXJuYWwgQ29tbW9uSlNcbnZhciBzY2hlZHVsZUNhbGxiYWNrJDMgPSBTY2hlZHVsZXIudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjaztcbnZhciBjYW5jZWxDYWxsYmFjayQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrO1xudmFyIHNob3VsZFlpZWxkID0gU2NoZWR1bGVyLnVuc3RhYmxlX3Nob3VsZFlpZWxkO1xudmFyIHJlcXVlc3RQYWludCA9IFNjaGVkdWxlci51bnN0YWJsZV9yZXF1ZXN0UGFpbnQ7XG52YXIgbm93JDEgPSBTY2hlZHVsZXIudW5zdGFibGVfbm93O1xudmFyIEltbWVkaWF0ZVByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5O1xudmFyIFVzZXJCbG9ja2luZ1ByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5O1xudmFyIE5vcm1hbFByaW9yaXR5JDEgPSBTY2hlZHVsZXIudW5zdGFibGVfTm9ybWFsUHJpb3JpdHk7XG52YXIgSWRsZVByaW9yaXR5ID0gU2NoZWR1bGVyLnVuc3RhYmxlX0lkbGVQcmlvcml0eTsgLy8gdGhpcyBkb2Vzbid0IGFjdHVhbGx5IGV4aXN0IG9uIHRoZSBzY2hlZHVsZXIsIGJ1dCBpdCAqZG9lcypcbi8vIG9uIHNjaGVkdWxlci91bnN0YWJsZV9tb2NrLCB3aGljaCB3ZSdsbCBuZWVkIGZvciBpbnRlcm5hbCB0ZXN0aW5nXG5cbnZhciBsb2cgPSBTY2hlZHVsZXIubG9nO1xudmFyIHVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlID0gU2NoZWR1bGVyLnVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlO1xuXG52YXIgcmVuZGVyZXJJRCA9IG51bGw7XG52YXIgaW5qZWN0ZWRIb29rID0gbnVsbDtcbnZhciBpbmplY3RlZFByb2ZpbGluZ0hvb2tzID0gbnVsbDtcbnZhciBoYXNMb2dnZWRFcnJvciA9IGZhbHNlO1xudmFyIGlzRGV2VG9vbHNQcmVzZW50ID0gdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCc7XG5mdW5jdGlvbiBpbmplY3RJbnRlcm5hbHMoaW50ZXJuYWxzKSB7XG4gIGlmICh0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vIE5vIERldlRvb2xzXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGhvb2sgPSBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX187XG5cbiAgaWYgKGhvb2suaXNEaXNhYmxlZCkge1xuICAgIC8vIFRoaXMgaXNuJ3QgYSByZWFsIHByb3BlcnR5IG9uIHRoZSBob29rLCBidXQgaXQgY2FuIGJlIHNldCB0byBvcHQgb3V0XG4gICAgLy8gb2YgRGV2VG9vbHMgaW50ZWdyYXRpb24gYW5kIGFzc29jaWF0ZWQgd2FybmluZ3MgYW5kIGxvZ3MuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8zODc3XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAoIWhvb2suc3VwcG9ydHNGaWJlcikge1xuICAgIHtcbiAgICAgIGVycm9yKCdUaGUgaW5zdGFsbGVkIHZlcnNpb24gb2YgUmVhY3QgRGV2VG9vbHMgaXMgdG9vIG9sZCBhbmQgd2lsbCBub3Qgd29yayAnICsgJ3dpdGggdGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBSZWFjdC4gUGxlYXNlIHVwZGF0ZSBSZWFjdCBEZXZUb29scy4gJyArICdodHRwczovL3JlYWN0LmRldi9saW5rL3JlYWN0LWRldnRvb2xzJyk7XG4gICAgfSAvLyBEZXZUb29scyBleGlzdHMsIGV2ZW4gdGhvdWdoIGl0IGRvZXNuJ3Qgc3VwcG9ydCBGaWJlci5cblxuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICB0cnkge1xuICAgIGlmIChlbmFibGVTY2hlZHVsaW5nUHJvZmlsZXIpIHtcbiAgICAgIC8vIENvbmRpdGlvbmFsbHkgaW5qZWN0IHRoZXNlIGhvb2tzIG9ubHkgaWYgVGltZWxpbmUgcHJvZmlsZXIgaXMgc3VwcG9ydGVkIGJ5IHRoaXMgYnVpbGQuXG4gICAgICAvLyBUaGlzIGdpdmVzIERldlRvb2xzIGEgd2F5IHRvIGZlYXR1cmUgZGV0ZWN0IHRoYXQgaXNuJ3QgdGllZCB0byB2ZXJzaW9uIG51bWJlclxuICAgICAgLy8gKHNpbmNlIHByb2ZpbGluZyBhbmQgdGltZWxpbmUgYXJlIGNvbnRyb2xsZWQgYnkgZGlmZmVyZW50IGZlYXR1cmUgZmxhZ3MpLlxuICAgICAgaW50ZXJuYWxzID0gYXNzaWduKHt9LCBpbnRlcm5hbHMsIHtcbiAgICAgICAgZ2V0TGFuZUxhYmVsTWFwOiBnZXRMYW5lTGFiZWxNYXAsXG4gICAgICAgIGluamVjdFByb2ZpbGluZ0hvb2tzOiBpbmplY3RQcm9maWxpbmdIb29rc1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmVuZGVyZXJJRCA9IGhvb2suaW5qZWN0KGludGVybmFscyk7IC8vIFdlIGhhdmUgc3VjY2Vzc2Z1bGx5IGluamVjdGVkLCBzbyBub3cgaXQgaXMgc2FmZSB0byBzZXQgdXAgaG9va3MuXG5cbiAgICBpbmplY3RlZEhvb2sgPSBob29rO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvLyBDYXRjaCBhbGwgZXJyb3JzIGJlY2F1c2UgaXQgaXMgdW5zYWZlIHRvIHRocm93IGR1cmluZyBpbml0aWFsaXphdGlvbi5cbiAgICB7XG4gICAgICBlcnJvcignUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcy4nLCBlcnIpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChob29rLmNoZWNrRENFKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgcmVhbCBEZXZUb29scy5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIGxpa2VseSBhIGhvb2sgaW5zdGFsbGVkIGJ5IEZhc3QgUmVmcmVzaCBydW50aW1lLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gb25TY2hlZHVsZVJvb3Qocm9vdCwgY2hpbGRyZW4pIHtcbiAge1xuICAgIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5vblNjaGVkdWxlRmliZXJSb290ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpbmplY3RlZEhvb2sub25TY2hlZHVsZUZpYmVyUm9vdChyZW5kZXJlcklELCByb290LCBjaGlsZHJlbik7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgaWYgKCFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gb25Db21taXRSb290JDEocm9vdCwgZXZlbnRQcmlvcml0eSkge1xuICBpZiAoaW5qZWN0ZWRIb29rICYmIHR5cGVvZiBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclJvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGRpZEVycm9yID0gKHJvb3QuY3VycmVudC5mbGFncyAmIERpZENhcHR1cmUpID09PSBEaWRDYXB0dXJlO1xuXG4gICAgICBpZiAoZW5hYmxlUHJvZmlsZXJUaW1lcikge1xuICAgICAgICB2YXIgc2NoZWR1bGVyUHJpb3JpdHk7XG5cbiAgICAgICAgc3dpdGNoIChldmVudFByaW9yaXR5KSB7XG4gICAgICAgICAgY2FzZSBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk6XG4gICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSA9IEltbWVkaWF0ZVByaW9yaXR5O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIENvbnRpbnVvdXNFdmVudFByaW9yaXR5OlxuICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBVc2VyQmxvY2tpbmdQcmlvcml0eTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBEZWZhdWx0RXZlbnRQcmlvcml0eTpcbiAgICAgICAgICAgIHNjaGVkdWxlclByaW9yaXR5ID0gTm9ybWFsUHJpb3JpdHkkMTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBJZGxlRXZlbnRQcmlvcml0eTpcbiAgICAgICAgICAgIHNjaGVkdWxlclByaW9yaXR5ID0gSWRsZVByaW9yaXR5O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBOb3JtYWxQcmlvcml0eSQxO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclJvb3QocmVuZGVyZXJJRCwgcm9vdCwgc2NoZWR1bGVyUHJpb3JpdHksIGRpZEVycm9yKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gb25Qb3N0Q29tbWl0Um9vdChyb290KSB7XG4gIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5vblBvc3RDb21taXRGaWJlclJvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0cnkge1xuICAgICAgaW5qZWN0ZWRIb29rLm9uUG9zdENvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHtcbiAgICAgICAgaWYgKCFoYXNMb2dnZWRFcnJvcikge1xuICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gb25Db21taXRVbm1vdW50KGZpYmVyKSB7XG4gIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICBpbmplY3RlZEhvb2sub25Db21taXRGaWJlclVubW91bnQocmVuZGVyZXJJRCwgZmliZXIpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAge1xuICAgICAgICBpZiAoIWhhc0xvZ2dlZEVycm9yKSB7XG4gICAgICAgICAgaGFzTG9nZ2VkRXJyb3IgPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJ1JlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLCBlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhuZXdJc1N0cmljdE1vZGUpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgbG9nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBXZSdyZSBpbiBhIHRlc3QgYmVjYXVzZSBTY2hlZHVsZXIubG9nIG9ubHkgZXhpc3RzXG4gICAgICAvLyBpbiBTY2hlZHVsZXJNb2NrLiBUbyByZWR1Y2UgdGhlIG5vaXNlIGluIHN0cmljdCBtb2RlIHRlc3RzLFxuICAgICAgLy8gc3VwcHJlc3Mgd2FybmluZ3MgYW5kIGRpc2FibGUgc2NoZWR1bGVyIHlpZWxkaW5nIGR1cmluZyB0aGUgZG91YmxlIHJlbmRlclxuICAgICAgdW5zdGFibGVfc2V0RGlzYWJsZVlpZWxkVmFsdWUobmV3SXNTdHJpY3RNb2RlKTtcbiAgICAgIHNldFN1cHByZXNzV2FybmluZyhuZXdJc1N0cmljdE1vZGUpO1xuICAgIH1cblxuICAgIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5zZXRTdHJpY3RNb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpbmplY3RlZEhvb2suc2V0U3RyaWN0TW9kZShyZW5kZXJlcklELCBuZXdJc1N0cmljdE1vZGUpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoIWhhc0xvZ2dlZEVycm9yKSB7XG4gICAgICAgICAgICBoYXNMb2dnZWRFcnJvciA9IHRydWU7XG5cbiAgICAgICAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzJywgZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0gLy8gUHJvZmlsZXIgQVBJIGhvb2tzXG5cbmZ1bmN0aW9uIGluamVjdFByb2ZpbGluZ0hvb2tzKHByb2ZpbGluZ0hvb2tzKSB7XG4gIGluamVjdGVkUHJvZmlsaW5nSG9va3MgPSBwcm9maWxpbmdIb29rcztcbn1cblxuZnVuY3Rpb24gZ2V0TGFuZUxhYmVsTWFwKCkge1xuICB7XG4gICAgdmFyIG1hcCA9IG5ldyBNYXAoKTtcbiAgICB2YXIgbGFuZSA9IDE7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgVG90YWxMYW5lczsgaW5kZXgrKykge1xuICAgICAgdmFyIGxhYmVsID0gZ2V0TGFiZWxGb3JMYW5lKGxhbmUpO1xuICAgICAgbWFwLnNldChsYW5lLCBsYWJlbCk7XG4gICAgICBsYW5lICo9IDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcDtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrQ29tbWl0U3RhcnRlZChsYW5lcykge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbW1pdFN0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbW1pdFN0YXJ0ZWQobGFuZXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbW1pdFN0b3BwZWQoKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RvcHBlZCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQoZmliZXIpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKGZpYmVyKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RhcnRlZChmaWJlcik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdGFydGVkKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdGFydGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQoZmliZXIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0b3BwZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RvcHBlZCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RhcnRlZChmaWJlcikge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkKGZpYmVyKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQoKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZChmaWJlcikge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZChmaWJlcik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQoKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdG9wcGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50RXJyb3JlZChmaWJlciwgdGhyb3duVmFsdWUsIGxhbmVzKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50RXJyb3JlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50RXJyb3JlZChmaWJlciwgdGhyb3duVmFsdWUsIGxhbmVzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRTdXNwZW5kZWQoZmliZXIsIHdha2VhYmxlLCBsYW5lcykge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFN1c3BlbmRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50U3VzcGVuZGVkKGZpYmVyLCB3YWtlYWJsZSwgbGFuZXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0xheW91dEVmZmVjdHNTdGFydGVkKGxhbmVzKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0xheW91dEVmZmVjdHNTdGFydGVkKGxhbmVzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0b3BwZWQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtQYXNzaXZlRWZmZWN0c1N0YXJ0ZWQobGFuZXMpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtQYXNzaXZlRWZmZWN0c1N0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZChsYW5lcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrUGFzc2l2ZUVmZmVjdHNTdG9wcGVkKCkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUGFzc2l2ZUVmZmVjdHNTdG9wcGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrUmVuZGVyU3RhcnRlZChsYW5lcykge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclN0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclN0YXJ0ZWQobGFuZXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya1JlbmRlcllpZWxkZWQoKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyWWllbGRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyWWllbGRlZCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya1JlbmRlclN0b3BwZWQoKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RvcHBlZCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya1JlbmRlclNjaGVkdWxlZChsYW5lKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU2NoZWR1bGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTY2hlZHVsZWQobGFuZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrRm9yY2VVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrRm9yY2VVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCBsYW5lKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCBsYW5lKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBpbmxpbmVkIE9iamVjdC5pcyBwb2x5ZmlsbCB0byBhdm9pZCByZXF1aXJpbmcgY29uc3VtZXJzIHNoaXAgdGhlaXIgb3duXG4gKiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvaXNcbiAqL1xuZnVuY3Rpb24gaXMoeCwgeSkge1xuICByZXR1cm4geCA9PT0geSAmJiAoeCAhPT0gMCB8fCAxIC8geCA9PT0gMSAvIHkpIHx8IHggIT09IHggJiYgeSAhPT0geSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxuICA7XG59XG5cbnZhciBvYmplY3RJcyA9IC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbnR5cGVvZiBPYmplY3QuaXMgPT09ICdmdW5jdGlvbicgPyBPYmplY3QuaXMgOiBpcztcblxuLy8gVGhpcyBpcyBpbXBvcnRlZCBieSB0aGUgZXZlbnQgcmVwbGF5aW5nIGltcGxlbWVudGF0aW9uIGluIFJlYWN0IERPTS4gSXQnc1xuLy8gaW4gYSBzZXBhcmF0ZSBmaWxlIHRvIGJyZWFrIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSBiZXR3ZWVuIHRoZSByZW5kZXJlciBhbmRcbi8vIHRoZSByZWNvbmNpbGVyLlxuZnVuY3Rpb24gaXNSb290RGVoeWRyYXRlZChyb290KSB7XG4gIHZhciBjdXJyZW50U3RhdGUgPSByb290LmN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgcmV0dXJuIGN1cnJlbnRTdGF0ZS5pc0RlaHlkcmF0ZWQ7XG59XG5cbnZhciBDYXB0dXJlZFN0YWNrcyA9IG5ldyBXZWFrTWFwKCk7XG5mdW5jdGlvbiBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih2YWx1ZSwgc291cmNlKSB7XG4gIC8vIElmIHRoZSB2YWx1ZSBpcyBhbiBlcnJvciwgY2FsbCB0aGlzIGZ1bmN0aW9uIGltbWVkaWF0ZWx5IGFmdGVyIGl0IGlzIHRocm93blxuICAvLyBzbyB0aGUgc3RhY2sgaXMgYWNjdXJhdGUuXG4gIHZhciBzdGFjaztcblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgIHZhciBjYXB0dXJlZFN0YWNrID0gQ2FwdHVyZWRTdGFja3MuZ2V0KHZhbHVlKTtcblxuICAgIGlmICh0eXBlb2YgY2FwdHVyZWRTdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHN0YWNrID0gY2FwdHVyZWRTdGFjaztcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhY2sgPSBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2Qoc291cmNlKTtcbiAgICAgIENhcHR1cmVkU3RhY2tzLnNldCh2YWx1ZSwgc3RhY2spO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBzdGFjayA9IGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChzb3VyY2UpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgc291cmNlOiBzb3VyY2UsXG4gICAgc3RhY2s6IHN0YWNrXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVDYXB0dXJlZFZhbHVlRnJvbUVycm9yKHZhbHVlLCBzdGFjaykge1xuICBpZiAodHlwZW9mIHN0YWNrID09PSAnc3RyaW5nJykge1xuICAgIENhcHR1cmVkU3RhY2tzLnNldCh2YWx1ZSwgc3RhY2spO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgc291cmNlOiBudWxsLFxuICAgIHN0YWNrOiBzdGFja1xuICB9O1xufVxuXG4vLyBJbnRlbnRpb25hbGx5IG5vdCB1c2luZyBpdCB5ZXQgdG8gZGVyaXNrIHRoZSBpbml0aWFsIGltcGxlbWVudGF0aW9uLCBiZWNhdXNlXG4vLyB0aGUgd2F5IHdlIHB1c2gvcG9wIHRoZXNlIHZhbHVlcyBpcyBhIGJpdCB1bnVzdWFsLiBJZiB0aGVyZSdzIGEgbWlzdGFrZSwgSSdkXG4vLyByYXRoZXIgdGhlIGlkcyBiZSB3cm9uZyB0aGFuIGNyYXNoIHRoZSB3aG9sZSByZWNvbmNpbGVyLlxuXG52YXIgZm9ya1N0YWNrID0gW107XG52YXIgZm9ya1N0YWNrSW5kZXggPSAwO1xudmFyIHRyZWVGb3JrUHJvdmlkZXIgPSBudWxsO1xudmFyIHRyZWVGb3JrQ291bnQgPSAwO1xudmFyIGlkU3RhY2sgPSBbXTtcbnZhciBpZFN0YWNrSW5kZXggPSAwO1xudmFyIHRyZWVDb250ZXh0UHJvdmlkZXIgPSBudWxsO1xudmFyIHRyZWVDb250ZXh0SWQgPSAxO1xudmFyIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSAnJztcbmZ1bmN0aW9uIGlzRm9ya2VkQ2hpbGQod29ya0luUHJvZ3Jlc3MpIHtcbiAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gIHJldHVybiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBGb3JrZWQpICE9PSBOb0ZsYWdzJDE7XG59XG5mdW5jdGlvbiBnZXRGb3Jrc0F0TGV2ZWwod29ya0luUHJvZ3Jlc3MpIHtcbiAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gIHJldHVybiB0cmVlRm9ya0NvdW50O1xufVxuZnVuY3Rpb24gZ2V0VHJlZUlkKCkge1xuICB2YXIgb3ZlcmZsb3cgPSB0cmVlQ29udGV4dE92ZXJmbG93O1xuICB2YXIgaWRXaXRoTGVhZGluZ0JpdCA9IHRyZWVDb250ZXh0SWQ7XG4gIHZhciBpZCA9IGlkV2l0aExlYWRpbmdCaXQgJiB+Z2V0TGVhZGluZ0JpdChpZFdpdGhMZWFkaW5nQml0KTtcbiAgcmV0dXJuIGlkLnRvU3RyaW5nKDMyKSArIG92ZXJmbG93O1xufVxuZnVuY3Rpb24gcHVzaFRyZWVGb3JrKHdvcmtJblByb2dyZXNzLCB0b3RhbENoaWxkcmVuKSB7XG4gIC8vIFRoaXMgaXMgY2FsbGVkIHJpZ2h0IGFmdGVyIHdlIHJlY29uY2lsZSBhbiBhcnJheSAob3IgaXRlcmF0b3IpIG9mIGNoaWxkXG4gIC8vIGZpYmVycywgYmVjYXVzZSB0aGF0J3MgdGhlIG9ubHkgcGxhY2Ugd2hlcmUgd2Uga25vdyBob3cgbWFueSBjaGlsZHJlbiBpblxuICAvLyB0aGUgd2hvbGUgc2V0IHdpdGhvdXQgZG9pbmcgZXh0cmEgd29yayBsYXRlciwgb3Igc3RvcmluZyBhZGR0aW9uYWxcbiAgLy8gaW5mb3JtYXRpb24gb24gdGhlIGZpYmVyLlxuICAvL1xuICAvLyBUaGF0J3Mgd2h5IHRoaXMgZnVuY3Rpb24gaXMgc2VwYXJhdGUgZnJvbSBwdXNoVHJlZUlkIOKAlCBpdCdzIGNhbGxlZCBkdXJpbmdcbiAgLy8gdGhlIHJlbmRlciBwaGFzZSBvZiB0aGUgZm9yayBwYXJlbnQsIG5vdCB0aGUgY2hpbGQsIHdoaWNoIGlzIHdoZXJlIHdlIHB1c2hcbiAgLy8gdGhlIG90aGVyIGNvbnRleHQgdmFsdWVzLlxuICAvL1xuICAvLyBJbiB0aGUgRml6eiBpbXBsZW1lbnRhdGlvbiB0aGlzIGlzIG11Y2ggc2ltcGxlciBiZWNhdXNlIHRoZSBjaGlsZCBpc1xuICAvLyByZW5kZXJlZCBpbiB0aGUgc2FtZSBjYWxsc3RhY2sgYXMgdGhlIHBhcmVudC5cbiAgLy9cbiAgLy8gSXQgbWlnaHQgYmUgYmV0dGVyIHRvIGp1c3QgYWRkIGEgYGZvcmtzYCBmaWVsZCB0byB0aGUgRmliZXIgdHlwZS4gSXQgd291bGRcbiAgLy8gbWFrZSB0aGlzIG1vZHVsZSBzaW1wbGVyLlxuICB3YXJuSWZOb3RIeWRyYXRpbmcoKTtcbiAgZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4KytdID0gdHJlZUZvcmtDb3VudDtcbiAgZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4KytdID0gdHJlZUZvcmtQcm92aWRlcjtcbiAgdHJlZUZvcmtQcm92aWRlciA9IHdvcmtJblByb2dyZXNzO1xuICB0cmVlRm9ya0NvdW50ID0gdG90YWxDaGlsZHJlbjtcbn1cbmZ1bmN0aW9uIHB1c2hUcmVlSWQod29ya0luUHJvZ3Jlc3MsIHRvdGFsQ2hpbGRyZW4sIGluZGV4KSB7XG4gIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0SWQ7XG4gIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRPdmVyZmxvdztcbiAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dFByb3ZpZGVyO1xuICB0cmVlQ29udGV4dFByb3ZpZGVyID0gd29ya0luUHJvZ3Jlc3M7XG4gIHZhciBiYXNlSWRXaXRoTGVhZGluZ0JpdCA9IHRyZWVDb250ZXh0SWQ7XG4gIHZhciBiYXNlT3ZlcmZsb3cgPSB0cmVlQ29udGV4dE92ZXJmbG93OyAvLyBUaGUgbGVmdG1vc3QgMSBtYXJrcyB0aGUgZW5kIG9mIHRoZSBzZXF1ZW5jZSwgbm9uLWluY2x1c2l2ZS4gSXQncyBub3QgcGFydFxuICAvLyBvZiB0aGUgaWQ7IHdlIHVzZSBpdCB0byBhY2NvdW50IGZvciBsZWFkaW5nIDBzLlxuXG4gIHZhciBiYXNlTGVuZ3RoID0gZ2V0Qml0TGVuZ3RoKGJhc2VJZFdpdGhMZWFkaW5nQml0KSAtIDE7XG4gIHZhciBiYXNlSWQgPSBiYXNlSWRXaXRoTGVhZGluZ0JpdCAmIH4oMSA8PCBiYXNlTGVuZ3RoKTtcbiAgdmFyIHNsb3QgPSBpbmRleCArIDE7XG4gIHZhciBsZW5ndGggPSBnZXRCaXRMZW5ndGgodG90YWxDaGlsZHJlbikgKyBiYXNlTGVuZ3RoOyAvLyAzMCBpcyB0aGUgbWF4IGxlbmd0aCB3ZSBjYW4gc3RvcmUgd2l0aG91dCBvdmVyZmxvd2luZywgdGFraW5nIGludG9cbiAgLy8gY29uc2lkZXJhdGlvbiB0aGUgbGVhZGluZyAxIHdlIHVzZSB0byBtYXJrIHRoZSBlbmQgb2YgdGhlIHNlcXVlbmNlLlxuXG4gIGlmIChsZW5ndGggPiAzMCkge1xuICAgIC8vIFdlIG92ZXJmbG93ZWQgdGhlIGJpdHdpc2Utc2FmZSByYW5nZS4gRmFsbCBiYWNrIHRvIHNsb3dlciBhbGdvcml0aG0uXG4gICAgLy8gVGhpcyBicmFuY2ggYXNzdW1lcyB0aGUgbGVuZ3RoIG9mIHRoZSBiYXNlIGlkIGlzIGdyZWF0ZXIgdGhhbiA1OyBpdCB3b24ndFxuICAgIC8vIHdvcmsgZm9yIHNtYWxsZXIgaWRzLCBiZWNhdXNlIHlvdSBuZWVkIDUgYml0cyBwZXIgY2hhcmFjdGVyLlxuICAgIC8vXG4gICAgLy8gV2UgZW5jb2RlIHRoZSBpZCBpbiBtdWx0aXBsZSBzdGVwczogZmlyc3QgdGhlIGJhc2UgaWQsIHRoZW4gdGhlXG4gICAgLy8gcmVtYWluaW5nIGRpZ2l0cy5cbiAgICAvL1xuICAgIC8vIEVhY2ggNSBiaXQgc2VxdWVuY2UgY29ycmVzcG9uZHMgdG8gYSBzaW5nbGUgYmFzZSAzMiBjaGFyYWN0ZXIuIFNvIGZvclxuICAgIC8vIGV4YW1wbGUsIGlmIHRoZSBjdXJyZW50IGlkIGlzIDIzIGJpdHMgbG9uZywgd2UgY2FuIGNvbnZlcnQgMjAgb2YgdGhvc2VcbiAgICAvLyBiaXRzIGludG8gYSBzdHJpbmcgb2YgNCBjaGFyYWN0ZXJzLCB3aXRoIDMgYml0cyBsZWZ0IG92ZXIuXG4gICAgLy9cbiAgICAvLyBGaXJzdCBjYWxjdWxhdGUgaG93IG1hbnkgYml0cyBpbiB0aGUgYmFzZSBpZCByZXByZXNlbnQgYSBjb21wbGV0ZVxuICAgIC8vIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMuXG4gICAgdmFyIG51bWJlck9mT3ZlcmZsb3dCaXRzID0gYmFzZUxlbmd0aCAtIGJhc2VMZW5ndGggJSA1OyAvLyBUaGVuIGNyZWF0ZSBhIGJpdG1hc2sgdGhhdCBzZWxlY3RzIG9ubHkgdGhvc2UgYml0cy5cblxuICAgIHZhciBuZXdPdmVyZmxvd0JpdHMgPSAoMSA8PCBudW1iZXJPZk92ZXJmbG93Qml0cykgLSAxOyAvLyBTZWxlY3QgdGhlIGJpdHMsIGFuZCBjb252ZXJ0IHRoZW0gdG8gYSBiYXNlIDMyIHN0cmluZy5cblxuICAgIHZhciBuZXdPdmVyZmxvdyA9IChiYXNlSWQgJiBuZXdPdmVyZmxvd0JpdHMpLnRvU3RyaW5nKDMyKTsgLy8gTm93IHdlIGNhbiByZW1vdmUgdGhvc2UgYml0cyBmcm9tIHRoZSBiYXNlIGlkLlxuXG4gICAgdmFyIHJlc3RPZkJhc2VJZCA9IGJhc2VJZCA+PiBudW1iZXJPZk92ZXJmbG93Qml0cztcbiAgICB2YXIgcmVzdE9mQmFzZUxlbmd0aCA9IGJhc2VMZW5ndGggLSBudW1iZXJPZk92ZXJmbG93Qml0czsgLy8gRmluYWxseSwgZW5jb2RlIHRoZSByZXN0IG9mIHRoZSBiaXRzIHVzaW5nIHRoZSBub3JtYWwgYWxnb3JpdGhtLiBCZWNhdXNlXG4gICAgLy8gd2UgbWFkZSBtb3JlIHJvb20sIHRoaXMgdGltZSBpdCB3b24ndCBvdmVyZmxvdy5cblxuICAgIHZhciByZXN0T2ZMZW5ndGggPSBnZXRCaXRMZW5ndGgodG90YWxDaGlsZHJlbikgKyByZXN0T2ZCYXNlTGVuZ3RoO1xuICAgIHZhciByZXN0T2ZOZXdCaXRzID0gc2xvdCA8PCByZXN0T2ZCYXNlTGVuZ3RoO1xuICAgIHZhciBpZCA9IHJlc3RPZk5ld0JpdHMgfCByZXN0T2ZCYXNlSWQ7XG4gICAgdmFyIG92ZXJmbG93ID0gbmV3T3ZlcmZsb3cgKyBiYXNlT3ZlcmZsb3c7XG4gICAgdHJlZUNvbnRleHRJZCA9IDEgPDwgcmVzdE9mTGVuZ3RoIHwgaWQ7XG4gICAgdHJlZUNvbnRleHRPdmVyZmxvdyA9IG92ZXJmbG93O1xuICB9IGVsc2Uge1xuICAgIC8vIE5vcm1hbCBwYXRoXG4gICAgdmFyIG5ld0JpdHMgPSBzbG90IDw8IGJhc2VMZW5ndGg7XG5cbiAgICB2YXIgX2lkID0gbmV3Qml0cyB8IGJhc2VJZDtcblxuICAgIHZhciBfb3ZlcmZsb3cgPSBiYXNlT3ZlcmZsb3c7XG4gICAgdHJlZUNvbnRleHRJZCA9IDEgPDwgbGVuZ3RoIHwgX2lkO1xuICAgIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBfb3ZlcmZsb3c7XG4gIH1cbn1cbmZ1bmN0aW9uIHB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQod29ya0luUHJvZ3Jlc3MpIHtcbiAgd2FybklmTm90SHlkcmF0aW5nKCk7IC8vIFRoaXMgY29tcG9uZW50IG1hdGVyaWFsaXplZCBhbiBpZC4gVGhpcyB3aWxsIGFmZmVjdCBhbnkgaWRzIHRoYXQgYXBwZWFyXG4gIC8vIGluIGl0cyBjaGlsZHJlbi5cblxuICB2YXIgcmV0dXJuRmliZXIgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG5cbiAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgdmFyIG51bWJlck9mRm9ya3MgPSAxO1xuICAgIHZhciBzbG90SW5kZXggPSAwO1xuICAgIHB1c2hUcmVlRm9yayh3b3JrSW5Qcm9ncmVzcywgbnVtYmVyT2ZGb3Jrcyk7XG4gICAgcHVzaFRyZWVJZCh3b3JrSW5Qcm9ncmVzcywgbnVtYmVyT2ZGb3Jrcywgc2xvdEluZGV4KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRCaXRMZW5ndGgobnVtYmVyKSB7XG4gIHJldHVybiAzMiAtIGNsejMyKG51bWJlcik7XG59XG5cbmZ1bmN0aW9uIGdldExlYWRpbmdCaXQoaWQpIHtcbiAgcmV0dXJuIDEgPDwgZ2V0Qml0TGVuZ3RoKGlkKSAtIDE7XG59XG5cbmZ1bmN0aW9uIHBvcFRyZWVDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gIC8vIFJlc3RvcmUgdGhlIHByZXZpb3VzIHZhbHVlcy5cbiAgLy8gVGhpcyBpcyBhIGJpdCBtb3JlIGNvbXBsaWNhdGVkIHRoYW4gb3RoZXIgY29udGV4dC1saWtlIG1vZHVsZXMgaW4gRmliZXJcbiAgLy8gYmVjYXVzZSB0aGUgc2FtZSBGaWJlciBtYXkgYXBwZWFyIG9uIHRoZSBzdGFjayBtdWx0aXBsZSB0aW1lcyBhbmQgZm9yXG4gIC8vIGRpZmZlcmVudCByZWFzb25zLiBXZSBoYXZlIHRvIGtlZXAgcG9wcGluZyB1bnRpbCB0aGUgd29yay1pbi1wcm9ncmVzcyBpc1xuICAvLyBubyBsb25nZXIgYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2suXG4gIHdoaWxlICh3b3JrSW5Qcm9ncmVzcyA9PT0gdHJlZUZvcmtQcm92aWRlcikge1xuICAgIHRyZWVGb3JrUHJvdmlkZXIgPSBmb3JrU3RhY2tbLS1mb3JrU3RhY2tJbmRleF07XG4gICAgZm9ya1N0YWNrW2ZvcmtTdGFja0luZGV4XSA9IG51bGw7XG4gICAgdHJlZUZvcmtDb3VudCA9IGZvcmtTdGFja1stLWZvcmtTdGFja0luZGV4XTtcbiAgICBmb3JrU3RhY2tbZm9ya1N0YWNrSW5kZXhdID0gbnVsbDtcbiAgfVxuXG4gIHdoaWxlICh3b3JrSW5Qcm9ncmVzcyA9PT0gdHJlZUNvbnRleHRQcm92aWRlcikge1xuICAgIHRyZWVDb250ZXh0UHJvdmlkZXIgPSBpZFN0YWNrWy0taWRTdGFja0luZGV4XTtcbiAgICBpZFN0YWNrW2lkU3RhY2tJbmRleF0gPSBudWxsO1xuICAgIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBpZFN0YWNrWy0taWRTdGFja0luZGV4XTtcbiAgICBpZFN0YWNrW2lkU3RhY2tJbmRleF0gPSBudWxsO1xuICAgIHRyZWVDb250ZXh0SWQgPSBpZFN0YWNrWy0taWRTdGFja0luZGV4XTtcbiAgICBpZFN0YWNrW2lkU3RhY2tJbmRleF0gPSBudWxsO1xuICB9XG59XG5mdW5jdGlvbiBnZXRTdXNwZW5kZWRUcmVlQ29udGV4dCgpIHtcbiAgd2FybklmTm90SHlkcmF0aW5nKCk7XG5cbiAgaWYgKHRyZWVDb250ZXh0UHJvdmlkZXIgIT09IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgaWQ6IHRyZWVDb250ZXh0SWQsXG4gICAgICBvdmVyZmxvdzogdHJlZUNvbnRleHRPdmVyZmxvd1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc3RvcmVTdXNwZW5kZWRUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuZGVkQ29udGV4dCkge1xuICB3YXJuSWZOb3RIeWRyYXRpbmcoKTtcbiAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dElkO1xuICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0T3ZlcmZsb3c7XG4gIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRQcm92aWRlcjtcbiAgdHJlZUNvbnRleHRJZCA9IHN1c3BlbmRlZENvbnRleHQuaWQ7XG4gIHRyZWVDb250ZXh0T3ZlcmZsb3cgPSBzdXNwZW5kZWRDb250ZXh0Lm92ZXJmbG93O1xuICB0cmVlQ29udGV4dFByb3ZpZGVyID0gd29ya0luUHJvZ3Jlc3M7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZk5vdEh5ZHJhdGluZygpIHtcbiAge1xuICAgIGlmICghZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIHRvIGJlIGh5ZHJhdGluZy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgJyArICdhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGNvbnRleHRTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKTtcbnZhciBjb250ZXh0RmliZXJTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKTtcbnZhciByb290SW5zdGFuY2VTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKTsgLy8gUmVwcmVzZW50cyB0aGUgbmVhcmVzdCBob3N0IHRyYW5zaXRpb24gcHJvdmlkZXIgKGluIFJlYWN0IERPTSwgYSA8Zm9ybSAvPilcbi8vIE5PVEU6IFNpbmNlIGZvcm1zIGNhbm5vdCBiZSBuZXN0ZWQsIGFuZCB0aGlzIGZlYXR1cmUgaXMgb25seSBpbXBsZW1lbnRlZCBieVxuLy8gUmVhY3QgRE9NLCB3ZSBkb24ndCB0ZWNobmljYWxseSBuZWVkIHRoaXMgdG8gYmUgYSBzdGFjay4gSXQgY291bGQgYmUgYSBzaW5nbGVcbi8vIG1vZHVsZSB2YXJpYWJsZSBpbnN0ZWFkLlxuXG52YXIgaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKTsgLy8gVE9ETzogVGhpcyBzaG91bGQgaW5pdGlhbGl6ZSB0byBOb3RQZW5kaW5nVHJhbnNpdGlvbiwgYSBjb25zdGFudFxuLy8gaW1wb3J0ZWQgZnJvbSB0aGUgZmliZXIgY29uZmlnLiBIb3dldmVyLCBiZWNhdXNlIG9mIGEgY3ljbGUgaW4gdGhlIG1vZHVsZVxuLy8gZ3JhcGgsIHRoYXQgdmFsdWUgaXNuJ3QgZGVmaW5lZCBkdXJpbmcgdGhpcyBtb2R1bGUncyBpbml0aWFsaXphdGlvbi4gSSBjYW4ndFxuLy8gdGhpbmsgb2YgYSB3YXkgdG8gd29yayBhcm91bmQgdGhpcyB3aXRob3V0IG1vdmluZyB0aGF0IHZhbHVlIG91dCBvZiB0aGVcbi8vIGZpYmVyIGNvbmZpZy4gRm9yIG5vdywgdGhlIFwibm8gcHJvdmlkZXJcIiBjYXNlIGlzIGhhbmRsZWQgd2hlbiByZWFkaW5nLFxuLy8gaW5zaWRlIHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzLlxuXG52YXIgSG9zdFRyYW5zaXRpb25Db250ZXh0ID0ge1xuICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICBQcm92aWRlcjogbnVsbCxcbiAgQ29uc3VtZXI6IG51bGwsXG4gIF9jdXJyZW50VmFsdWU6IG51bGwsXG4gIF9jdXJyZW50VmFsdWUyOiBudWxsLFxuICBfdGhyZWFkQ291bnQ6IDBcbn07XG5cbmZ1bmN0aW9uIHJlcXVpcmVkQ29udGV4dChjKSB7XG4gIHtcbiAgICBpZiAoYyA9PT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIGhvc3QgY29udGV4dCB0byBleGlzdC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnICcgKyAnaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjO1xufVxuXG5mdW5jdGlvbiBnZXRSb290SG9zdENvbnRhaW5lcigpIHtcbiAgdmFyIHJvb3RJbnN0YW5jZSA9IHJlcXVpcmVkQ29udGV4dChyb290SW5zdGFuY2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgcmV0dXJuIHJvb3RJbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gcHVzaEhvc3RDb250YWluZXIoZmliZXIsIG5leHRSb290SW5zdGFuY2UpIHtcbiAgLy8gUHVzaCBjdXJyZW50IHJvb3QgaW5zdGFuY2Ugb250byB0aGUgc3RhY2s7XG4gIC8vIFRoaXMgYWxsb3dzIHVzIHRvIHJlc2V0IHJvb3Qgd2hlbiBwb3J0YWxzIGFyZSBwb3BwZWQuXG4gIHB1c2gocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsIG5leHRSb290SW5zdGFuY2UsIGZpYmVyKTsgLy8gVHJhY2sgdGhlIGNvbnRleHQgYW5kIHRoZSBGaWJlciB0aGF0IHByb3ZpZGVkIGl0LlxuICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gcG9wIG9ubHkgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG5cbiAgcHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKTsgLy8gRmluYWxseSwgd2UgbmVlZCB0byBwdXNoIHRoZSBob3N0IGNvbnRleHQgdG8gdGhlIHN0YWNrLlxuICAvLyBIb3dldmVyLCB3ZSBjYW4ndCBqdXN0IGNhbGwgZ2V0Um9vdEhvc3RDb250ZXh0KCkgYW5kIHB1c2ggaXQgYmVjYXVzZVxuICAvLyB3ZSdkIGhhdmUgYSBkaWZmZXJlbnQgbnVtYmVyIG9mIGVudHJpZXMgb24gdGhlIHN0YWNrIGRlcGVuZGluZyBvblxuICAvLyB3aGV0aGVyIGdldFJvb3RIb3N0Q29udGV4dCgpIHRocm93cyBzb21ld2hlcmUgaW4gcmVuZGVyZXIgY29kZSBvciBub3QuXG4gIC8vIFNvIHdlIHB1c2ggYW4gZW1wdHkgdmFsdWUgZmlyc3QuIFRoaXMgbGV0cyB1cyBzYWZlbHkgdW53aW5kIG9uIGVycm9ycy5cblxuICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbnVsbCwgZmliZXIpO1xuICB2YXIgbmV4dFJvb3RDb250ZXh0ID0gZ2V0Um9vdEhvc3RDb250ZXh0KG5leHRSb290SW5zdGFuY2UpOyAvLyBOb3cgdGhhdCB3ZSBrbm93IHRoaXMgZnVuY3Rpb24gZG9lc24ndCB0aHJvdywgcmVwbGFjZSBpdC5cblxuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBuZXh0Um9vdENvbnRleHQsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcG9wSG9zdENvbnRhaW5lcihmaWJlcikge1xuICBwb3AoY29udGV4dFN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICBwb3Aocm9vdEluc3RhbmNlU3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxuZnVuY3Rpb24gZ2V0SG9zdENvbnRleHQoKSB7XG4gIHZhciBjb250ZXh0ID0gcmVxdWlyZWRDb250ZXh0KGNvbnRleHRTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIHB1c2hIb3N0Q29udGV4dChmaWJlcikge1xuICB7XG4gICAgdmFyIHN0YXRlSG9vayA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG5cbiAgICBpZiAoc3RhdGVIb29rICE9PSBudWxsKSB7XG4gICAgICAvLyBPbmx5IHByb3ZpZGUgY29udGV4dCBpZiB0aGlzIGZpYmVyIGhhcyBiZWVuIHVwZ3JhZGVkIGJ5IGEgaG9zdFxuICAgICAgLy8gdHJhbnNpdGlvbi4gV2UgdXNlIHRoZSBzYW1lIG9wdGltaXphdGlvbiBmb3IgcmVndWxhciBob3N0IGNvbnRleHQgYmVsb3cuXG4gICAgICBwdXNoKGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICB2YXIgbmV4dENvbnRleHQgPSBnZXRDaGlsZEhvc3RDb250ZXh0KGNvbnRleHQsIGZpYmVyLnR5cGUpOyAvLyBEb24ndCBwdXNoIHRoaXMgRmliZXIncyBjb250ZXh0IHVubGVzcyBpdCdzIHVuaXF1ZS5cblxuICBpZiAoY29udGV4dCAhPT0gbmV4dENvbnRleHQpIHtcbiAgICAvLyBUcmFjayB0aGUgY29udGV4dCBhbmQgdGhlIEZpYmVyIHRoYXQgcHJvdmlkZWQgaXQuXG4gICAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIHBvcCBvbmx5IEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuICAgIHB1c2goY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyLCBmaWJlcik7XG4gICAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG5leHRDb250ZXh0LCBmaWJlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wSG9zdENvbnRleHQoZmliZXIpIHtcbiAgaWYgKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLmN1cnJlbnQgPT09IGZpYmVyKSB7XG4gICAgLy8gRG8gbm90IHBvcCB1bmxlc3MgdGhpcyBGaWJlciBwcm92aWRlZCB0aGUgY3VycmVudCBjb250ZXh0LlxuICAgIC8vIHB1c2hIb3N0Q29udGV4dCgpIG9ubHkgcHVzaGVzIEZpYmVycyB0aGF0IHByb3ZpZGUgdW5pcXVlIGNvbnRleHRzLlxuICAgIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgICBwb3AoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAoaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvci5jdXJyZW50ID09PSBmaWJlcikge1xuICAgICAgLy8gRG8gbm90IHBvcCB1bmxlc3MgdGhpcyBGaWJlciBwcm92aWRlZCB0aGUgY3VycmVudCBjb250ZXh0LiBUaGlzIGlzIG1vc3RseVxuICAgICAgLy8gYSBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24sIGJ1dCBjb252ZW5pZW50bHkgaXQgYWxzbyBwcmV2ZW50cyBhIHBvdGVudGlhbFxuICAgICAgLy8gZGF0YSByYWNlIHdoZXJlIGEgaG9zdCBwcm92aWRlciBpcyB1cGdyYWRlZCAoaS5lLiBtZW1vaXplZFN0YXRlIGJlY29tZXNcbiAgICAgIC8vIG5vbi1udWxsKSBkdXJpbmcgYSBjb25jdXJyZW50IGV2ZW50LiBUaGlzIGlzIGEgYml0IG9mIGEgZmxhdyBpbiB0aGUgd2F5XG4gICAgICAvLyB3ZSB1cGdyYWRlIGhvc3QgY29tcG9uZW50cywgYnV0IGJlY2F1c2Ugd2UncmUgYWNjb3VudGluZyBmb3IgaXQgaGVyZSwgaXRcbiAgICAgIC8vIHNob3VsZCBiZSBmaW5lLlxuICAgICAgcG9wKGhvc3RUcmFuc2l0aW9uUHJvdmlkZXJDdXJzb3IsIGZpYmVyKTsgLy8gV2hlbiBwb3BwaW5nIHRoZSB0cmFuc2l0aW9uIHByb3ZpZGVyLCB3ZSByZXNldCB0aGUgY29udGV4dCB2YWx1ZSBiYWNrXG4gICAgICAvLyB0byBgbnVsbGAuIFdlIGNhbiBkbyB0aGlzIGJlY2F1c2UgeW91J3JlIG5vdCBhbGxvd2QgdG8gbmVzdCBmb3Jtcy4gSWZcbiAgICAgIC8vIHdlIGFsbG93ZWQgZm9yIG11bHRpcGxlIG5lc3RlZCBob3N0IHRyYW5zaXRpb24gcHJvdmlkZXJzLCB0aGVuIHdlJ2RcbiAgICAgIC8vIG5lZWQgdG8gcmVzZXQgdGhpcyB0byB0aGUgcGFyZW50IHByb3ZpZGVyJ3Mgc3RhdHVzLlxuXG4gICAgICBpZiAoaXNQcmltYXJ5UmVuZGVyZXIpIHtcbiAgICAgICAgSG9zdFRyYW5zaXRpb25Db250ZXh0Ll9jdXJyZW50VmFsdWUgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgSG9zdFRyYW5zaXRpb25Db250ZXh0Ll9jdXJyZW50VmFsdWUyID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIG1heFJvd0xlbmd0aCA9IDEyMDtcbnZhciBpZGVhbERlcHRoID0gMTU7XG5cbmZ1bmN0aW9uIGZpbmROb3RhYmxlTm9kZShub2RlLCBpbmRlbnQpIHtcbiAgaWYgKG5vZGUuc2VydmVyUHJvcHMgPT09IHVuZGVmaW5lZCAmJiBub2RlLnNlcnZlclRhaWwubGVuZ3RoID09PSAwICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmIG5vZGUuZGlzdGFuY2VGcm9tTGVhZiA+IDMgJiYgbm9kZS5kaXN0YW5jZUZyb21MZWFmID4gaWRlYWxEZXB0aCAtIGluZGVudCkge1xuICAgIC8vIFRoaXMgaXMgbm90IGFuIGludGVyZXN0aW5nIG5vZGUgZm9yIGNvbnRleHR1YWwgcHVycG9zZXMgc28gd2UgY2FuIHNraXAgaXQuXG4gICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZHJlblswXTtcbiAgICByZXR1cm4gZmluZE5vdGFibGVOb2RlKGNoaWxkLCBpbmRlbnQpO1xuICB9XG5cbiAgcmV0dXJuIG5vZGU7XG59XG5cbmZ1bmN0aW9uIGluZGVudGF0aW9uKGluZGVudCkge1xuICByZXR1cm4gJyAgJyArICcgICcucmVwZWF0KGluZGVudCk7XG59XG5cbmZ1bmN0aW9uIGFkZGVkKGluZGVudCkge1xuICByZXR1cm4gJysgJyArICcgICcucmVwZWF0KGluZGVudCk7XG59XG5cbmZ1bmN0aW9uIHJlbW92ZWQoaW5kZW50KSB7XG4gIHJldHVybiAnLSAnICsgJyAgJy5yZXBlYXQoaW5kZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVGaWJlclR5cGUoZmliZXIpIHtcbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RIb2lzdGFibGU6XG4gICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHJldHVybiBmaWJlci50eXBlO1xuXG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgICAgcmV0dXJuICdMYXp5JztcblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuXG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICB2YXIgZm4gPSBmaWJlci50eXBlO1xuICAgICAgcmV0dXJuIGZuLmRpc3BsYXlOYW1lIHx8IGZuLm5hbWUgfHwgbnVsbDtcblxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIHZhciByZW5kZXIgPSBmaWJlci50eXBlLnJlbmRlcjtcbiAgICAgIHJldHVybiByZW5kZXIuZGlzcGxheU5hbWUgfHwgcmVuZGVyLm5hbWUgfHwgbnVsbDtcblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB2YXIgY3RyID0gZmliZXIudHlwZTtcbiAgICAgIHJldHVybiBjdHIuZGlzcGxheU5hbWUgfHwgY3RyLm5hbWUgfHwgbnVsbDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICAvLyBTa2lwXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG52YXIgbmVlZHNFc2NhcGluZyA9IC9bXCInJjw+XFxuXFx0XS87XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVGV4dE5vZGUoY29udGVudCwgbWF4TGVuZ3RoKSB7XG4gIGlmIChuZWVkc0VzY2FwaW5nLnRlc3QoY29udGVudCkpIHtcbiAgICB2YXIgZW5jb2RlZCA9IEpTT04uc3RyaW5naWZ5KGNvbnRlbnQpO1xuXG4gICAgaWYgKGVuY29kZWQubGVuZ3RoID4gbWF4TGVuZ3RoIC0gMikge1xuICAgICAgaWYgKG1heExlbmd0aCA8IDgpIHtcbiAgICAgICAgcmV0dXJuICd7XCIuLi5cIn0nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ3snICsgZW5jb2RlZC5zbGljZSgwLCBtYXhMZW5ndGggLSA3KSArICcuLi5cIn0nO1xuICAgIH1cblxuICAgIHJldHVybiAneycgKyBlbmNvZGVkICsgJ30nO1xuICB9IGVsc2Uge1xuICAgIGlmIChjb250ZW50Lmxlbmd0aCA+IG1heExlbmd0aCkge1xuICAgICAgaWYgKG1heExlbmd0aCA8IDUpIHtcbiAgICAgICAgcmV0dXJuICd7XCIuLi5cIn0nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udGVudC5zbGljZSgwLCBtYXhMZW5ndGggLSAzKSArICcuLi4nO1xuICAgIH1cblxuICAgIHJldHVybiBjb250ZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlVGV4dERpZmYoY2xpZW50VGV4dCwgc2VydmVyUHJvcHMsIGluZGVudCkge1xuICB2YXIgbWF4TGVuZ3RoID0gbWF4Um93TGVuZ3RoIC0gaW5kZW50ICogMjtcblxuICBpZiAoc2VydmVyUHJvcHMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gYWRkZWQoaW5kZW50KSArIGRlc2NyaWJlVGV4dE5vZGUoY2xpZW50VGV4dCwgbWF4TGVuZ3RoKSArICdcXG4nO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBzZXJ2ZXJQcm9wcyA9PT0gJ3N0cmluZycpIHtcbiAgICB2YXIgc2VydmVyVGV4dCA9IHNlcnZlclByb3BzO1xuICAgIHZhciBmaXJzdERpZmYgPSAwO1xuXG4gICAgZm9yICg7IGZpcnN0RGlmZiA8IHNlcnZlclRleHQubGVuZ3RoICYmIGZpcnN0RGlmZiA8IGNsaWVudFRleHQubGVuZ3RoOyBmaXJzdERpZmYrKykge1xuICAgICAgaWYgKHNlcnZlclRleHQuY2hhckNvZGVBdChmaXJzdERpZmYpICE9PSBjbGllbnRUZXh0LmNoYXJDb2RlQXQoZmlyc3REaWZmKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZmlyc3REaWZmID4gbWF4TGVuZ3RoIC0gOCAmJiBmaXJzdERpZmYgPiAxMCkge1xuICAgICAgLy8gVGhlIGZpcnN0IGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgdHdvIHN0cmluZ3Mgd291bGQgYmUgY3V0IG9mZiwgc28gY3V0IG9mZiBpblxuICAgICAgLy8gdGhlIGJlZ2lubmluZyBpbnN0ZWFkLlxuICAgICAgY2xpZW50VGV4dCA9ICcuLi4nICsgY2xpZW50VGV4dC5zbGljZShmaXJzdERpZmYgLSA4KTtcbiAgICAgIHNlcnZlclRleHQgPSAnLi4uJyArIHNlcnZlclRleHQuc2xpY2UoZmlyc3REaWZmIC0gOCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFkZGVkKGluZGVudCkgKyBkZXNjcmliZVRleHROb2RlKGNsaWVudFRleHQsIG1heExlbmd0aCkgKyAnXFxuJyArIHJlbW92ZWQoaW5kZW50KSArIGRlc2NyaWJlVGV4dE5vZGUoc2VydmVyVGV4dCwgbWF4TGVuZ3RoKSArICdcXG4nO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBpbmRlbnRhdGlvbihpbmRlbnQpICsgZGVzY3JpYmVUZXh0Tm9kZShjbGllbnRUZXh0LCBtYXhMZW5ndGgpICsgJ1xcbic7XG4gIH1cbn1cblxuZnVuY3Rpb24gb2JqZWN0TmFtZShvYmplY3QpIHtcbiAgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICB2YXIgbmFtZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpO1xuICByZXR1cm4gbmFtZS5yZXBsYWNlKC9eXFxbb2JqZWN0ICguKilcXF0kLywgZnVuY3Rpb24gKG0sIHAwKSB7XG4gICAgcmV0dXJuIHAwO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVWYWx1ZSh2YWx1ZSwgbWF4TGVuZ3RoKSB7XG4gIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIGVuY29kZWQgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKGVuY29kZWQubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG1heExlbmd0aCA8IDUpIHtcbiAgICAgICAgICAgIHJldHVybiAnXCIuLi5cIic7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIGVuY29kZWQuc2xpY2UoMCwgbWF4TGVuZ3RoIC0gNCkgKyAnLi4uXCInO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVuY29kZWQ7XG4gICAgICB9XG5cbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAge1xuICAgICAgICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gJ251bGwnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuICdbLi4uXSc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodmFsdWUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICAgIHZhciB0eXBlID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHZhbHVlLnR5cGUpO1xuICAgICAgICAgIHJldHVybiB0eXBlID8gJzwnICsgdHlwZSArICc+JyA6ICc8Li4uPic7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmFtZSA9IG9iamVjdE5hbWUodmFsdWUpO1xuXG4gICAgICAgIGlmIChuYW1lID09PSAnT2JqZWN0Jykge1xuICAgICAgICAgIHZhciBwcm9wZXJ0aWVzID0gJyc7XG4gICAgICAgICAgbWF4TGVuZ3RoIC09IDI7XG5cbiAgICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiB2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCF2YWx1ZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBqc29uUHJvcE5hbWUgPSBKU09OLnN0cmluZ2lmeShwcm9wTmFtZSk7XG5cbiAgICAgICAgICAgIGlmIChqc29uUHJvcE5hbWUgIT09ICdcIicgKyBwcm9wTmFtZSArICdcIicpIHtcbiAgICAgICAgICAgICAgcHJvcE5hbWUgPSBqc29uUHJvcE5hbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1heExlbmd0aCAtPSBwcm9wTmFtZS5sZW5ndGggLSAyO1xuICAgICAgICAgICAgdmFyIHByb3BWYWx1ZSA9IGRlc2NyaWJlVmFsdWUodmFsdWVbcHJvcE5hbWVdLCBtYXhMZW5ndGggPCAxNSA/IG1heExlbmd0aCA6IDE1KTtcbiAgICAgICAgICAgIG1heExlbmd0aCAtPSBwcm9wVmFsdWUubGVuZ3RoO1xuXG4gICAgICAgICAgICBpZiAobWF4TGVuZ3RoIDwgMCkge1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzICs9IHByb3BlcnRpZXMgPT09ICcnID8gJy4uLicgOiAnLCAuLi4nO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvcGVydGllcyArPSAocHJvcGVydGllcyA9PT0gJycgPyAnJyA6ICcsJykgKyBwcm9wTmFtZSArICc6JyArIHByb3BWYWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gJ3snICsgcHJvcGVydGllcyArICd9JztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgfVxuXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAge1xuICAgICAgICB2YXIgX25hbWUgPSB2YWx1ZS5kaXNwbGF5TmFtZSB8fCB2YWx1ZS5uYW1lO1xuXG4gICAgICAgIHJldHVybiBfbmFtZSA/ICdmdW5jdGlvbiAnICsgX25hbWUgOiAnZnVuY3Rpb24nO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgICAgcmV0dXJuIFN0cmluZyh2YWx1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVQcm9wVmFsdWUodmFsdWUsIG1heExlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyAmJiAhbmVlZHNFc2NhcGluZy50ZXN0KHZhbHVlKSkge1xuICAgIGlmICh2YWx1ZS5sZW5ndGggPiBtYXhMZW5ndGggLSAyKSB7XG4gICAgICBpZiAobWF4TGVuZ3RoIDwgNSkge1xuICAgICAgICByZXR1cm4gJ1wiLi4uXCInO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gJ1wiJyArIHZhbHVlLnNsaWNlKDAsIG1heExlbmd0aCAtIDUpICsgJy4uLlwiJztcbiAgICB9XG5cbiAgICByZXR1cm4gJ1wiJyArIHZhbHVlICsgJ1wiJztcbiAgfVxuXG4gIHJldHVybiAneycgKyBkZXNjcmliZVZhbHVlKHZhbHVlLCBtYXhMZW5ndGggLSAyKSArICd9Jztcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVDb2xsYXBzZWRFbGVtZW50KHR5cGUsIHByb3BzLCBpbmRlbnQpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiB0cmllcyB0byBmaXQgdGhlIHByb3BzIGludG8gYSBzaW5nbGUgbGluZSBmb3Igbm9uLWVzc2VudGlhbCBlbGVtZW50cy5cbiAgLy8gV2UgYWxzbyBpZ25vcmUgY2hpbGRyZW4gYmVjYXVzZSB3ZSdyZSBub3QgZ29pbmcgZGVlcGVyLlxuICB2YXIgbWF4TGVuZ3RoID0gbWF4Um93TGVuZ3RoIC0gaW5kZW50ICogMiAtIHR5cGUubGVuZ3RoIC0gMjtcbiAgdmFyIGNvbnRlbnQgPSAnJztcblxuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wcykge1xuICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAocHJvcE5hbWUgPT09ICdjaGlsZHJlbicpIHtcbiAgICAgIC8vIElnbm9yZWQuXG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgcHJvcFZhbHVlID0gZGVzY3JpYmVQcm9wVmFsdWUocHJvcHNbcHJvcE5hbWVdLCAxNSk7XG4gICAgbWF4TGVuZ3RoIC09IHByb3BOYW1lLmxlbmd0aCArIHByb3BWYWx1ZS5sZW5ndGggKyAyO1xuXG4gICAgaWYgKG1heExlbmd0aCA8IDApIHtcbiAgICAgIGNvbnRlbnQgKz0gJyAuLi4nO1xuICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgY29udGVudCArPSAnICcgKyBwcm9wTmFtZSArICc9JyArIHByb3BWYWx1ZTtcbiAgfVxuXG4gIHJldHVybiBpbmRlbnRhdGlvbihpbmRlbnQpICsgJzwnICsgdHlwZSArIGNvbnRlbnQgKyAnPlxcbic7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlRXhwYW5kZWRFbGVtZW50KHR5cGUsIHByb3BzLCByb3dQcmVmaXgpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiB0cmllcyB0byBmaXQgdGhlIHByb3BzIGludG8gYSBzaW5nbGUgbGluZSBmb3Igbm9uLWVzc2VudGlhbCBlbGVtZW50cy5cbiAgLy8gV2UgYWxzbyBpZ25vcmUgY2hpbGRyZW4gYmVjYXVzZSB3ZSdyZSBub3QgZ29pbmcgZGVlcGVyLlxuICB2YXIgcmVtYWluaW5nUm93TGVuZ3RoID0gbWF4Um93TGVuZ3RoIC0gcm93UHJlZml4Lmxlbmd0aCAtIHR5cGUubGVuZ3RoOyAvLyBXZSBhZGQgdGhlIHByb3BlcnRpZXMgdG8gYSBzZXQgc28gd2UgY2FuIGNob29zZSBsYXRlciB3aGV0aGVyIHdlJ2xsIHB1dCBpdCBvbiBvbmVcbiAgLy8gbGluZSBvciBtdWx0aXBsZSBsaW5lcy5cblxuICB2YXIgcHJvcGVydGllcyA9IFtdO1xuXG4gIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChwcm9wTmFtZSA9PT0gJ2NoaWxkcmVuJykge1xuICAgICAgLy8gSWdub3JlZC5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBtYXhMZW5ndGggPSBtYXhSb3dMZW5ndGggLSByb3dQcmVmaXgubGVuZ3RoIC0gcHJvcE5hbWUubGVuZ3RoIC0gMTtcbiAgICB2YXIgcHJvcFZhbHVlID0gZGVzY3JpYmVQcm9wVmFsdWUocHJvcHNbcHJvcE5hbWVdLCBtYXhMZW5ndGgpO1xuICAgIHJlbWFpbmluZ1Jvd0xlbmd0aCAtPSBwcm9wTmFtZS5sZW5ndGggKyBwcm9wVmFsdWUubGVuZ3RoICsgMjtcbiAgICBwcm9wZXJ0aWVzLnB1c2gocHJvcE5hbWUgKyAnPScgKyBwcm9wVmFsdWUpO1xuICB9XG5cbiAgaWYgKHByb3BlcnRpZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHJvd1ByZWZpeCArICc8JyArIHR5cGUgKyAnPlxcbic7XG4gIH0gZWxzZSBpZiAocmVtYWluaW5nUm93TGVuZ3RoID4gMCkge1xuICAgIC8vIFdlIGNhbiBmaXQgYWxsIG9uIG9uZSByb3cuXG4gICAgcmV0dXJuIHJvd1ByZWZpeCArICc8JyArIHR5cGUgKyAnICcgKyBwcm9wZXJ0aWVzLmpvaW4oJyAnKSArICc+XFxuJztcbiAgfSBlbHNlIHtcbiAgICAvLyBTcGxpdCBpbnRvIG9uZSByb3cgcGVyIHByb3BlcnR5OlxuICAgIHJldHVybiByb3dQcmVmaXggKyAnPCcgKyB0eXBlICsgJ1xcbicgKyByb3dQcmVmaXggKyAnICAnICsgcHJvcGVydGllcy5qb2luKCdcXG4nICsgcm93UHJlZml4ICsgJyAgJykgKyAnXFxuJyArIHJvd1ByZWZpeCArICc+XFxuJztcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXNjcmliZVByb3BlcnRpZXNEaWZmKGNsaWVudE9iamVjdCwgc2VydmVyT2JqZWN0LCBpbmRlbnQpIHtcbiAgdmFyIHByb3BlcnRpZXMgPSAnJztcbiAgdmFyIHJlbWFpbmluZ1NlcnZlclByb3BlcnRpZXMgPSBhc3NpZ24oe30sIHNlcnZlck9iamVjdCk7XG5cbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gY2xpZW50T2JqZWN0KSB7XG4gICAgaWYgKCFjbGllbnRPYmplY3QuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBkZWxldGUgcmVtYWluaW5nU2VydmVyUHJvcGVydGllc1twcm9wTmFtZV07XG4gICAgdmFyIG1heExlbmd0aCA9IG1heFJvd0xlbmd0aCAtIGluZGVudCAqIDIgLSBwcm9wTmFtZS5sZW5ndGggLSAyO1xuICAgIHZhciBjbGllbnRWYWx1ZSA9IGNsaWVudE9iamVjdFtwcm9wTmFtZV07XG4gICAgdmFyIGNsaWVudFByb3BWYWx1ZSA9IGRlc2NyaWJlVmFsdWUoY2xpZW50VmFsdWUsIG1heExlbmd0aCk7XG5cbiAgICBpZiAoc2VydmVyT2JqZWN0Lmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgdmFyIHNlcnZlclZhbHVlID0gc2VydmVyT2JqZWN0W3Byb3BOYW1lXTtcbiAgICAgIHZhciBzZXJ2ZXJQcm9wVmFsdWUgPSBkZXNjcmliZVZhbHVlKHNlcnZlclZhbHVlLCBtYXhMZW5ndGgpO1xuICAgICAgcHJvcGVydGllcyArPSBhZGRlZChpbmRlbnQpICsgcHJvcE5hbWUgKyAnOiAnICsgY2xpZW50UHJvcFZhbHVlICsgJ1xcbic7XG4gICAgICBwcm9wZXJ0aWVzICs9IHJlbW92ZWQoaW5kZW50KSArIHByb3BOYW1lICsgJzogJyArIHNlcnZlclByb3BWYWx1ZSArICdcXG4nO1xuICAgIH0gZWxzZSB7XG4gICAgICBwcm9wZXJ0aWVzICs9IGFkZGVkKGluZGVudCkgKyBwcm9wTmFtZSArICc6ICcgKyBjbGllbnRQcm9wVmFsdWUgKyAnXFxuJztcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBfcHJvcE5hbWUgaW4gcmVtYWluaW5nU2VydmVyUHJvcGVydGllcykge1xuICAgIGlmICghcmVtYWluaW5nU2VydmVyUHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShfcHJvcE5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgX21heExlbmd0aCA9IG1heFJvd0xlbmd0aCAtIGluZGVudCAqIDIgLSBfcHJvcE5hbWUubGVuZ3RoIC0gMjtcblxuICAgIHZhciBfc2VydmVyVmFsdWUgPSByZW1haW5pbmdTZXJ2ZXJQcm9wZXJ0aWVzW19wcm9wTmFtZV07XG5cbiAgICB2YXIgX3NlcnZlclByb3BWYWx1ZSA9IGRlc2NyaWJlVmFsdWUoX3NlcnZlclZhbHVlLCBfbWF4TGVuZ3RoKTtcblxuICAgIHByb3BlcnRpZXMgKz0gcmVtb3ZlZChpbmRlbnQpICsgX3Byb3BOYW1lICsgJzogJyArIF9zZXJ2ZXJQcm9wVmFsdWUgKyAnXFxuJztcbiAgfVxuXG4gIHJldHVybiBwcm9wZXJ0aWVzO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZUVsZW1lbnREaWZmKHR5cGUsIGNsaWVudFByb3BzLCBzZXJ2ZXJQcm9wcywgaW5kZW50KSB7XG4gIHZhciBjb250ZW50ID0gJyc7IC8vIE1hcHMgYW55IHByZXZpb3VzbHkgdW5tYXRjaGVkIGxvd2VyIGNhc2Ugc2VydmVyIHByb3AgbmFtZSB0byBpdHMgZnVsbCBwcm9wIG5hbWVcblxuICB2YXIgc2VydmVyUHJvcE5hbWVzID0gbmV3IE1hcCgpO1xuXG4gIGZvciAodmFyIHByb3BOYW1lIGluIHNlcnZlclByb3BzKSB7XG4gICAgaWYgKCFzZXJ2ZXJQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHNlcnZlclByb3BOYW1lcy5zZXQocHJvcE5hbWUudG9Mb3dlckNhc2UoKSwgcHJvcE5hbWUpO1xuICB9XG5cbiAgaWYgKHNlcnZlclByb3BOYW1lcy5zaXplID09PSAxICYmIHNlcnZlclByb3BOYW1lcy5oYXMoJ2NoaWxkcmVuJykpIHtcbiAgICBjb250ZW50ICs9IGRlc2NyaWJlRXhwYW5kZWRFbGVtZW50KHR5cGUsIGNsaWVudFByb3BzLCBpbmRlbnRhdGlvbihpbmRlbnQpKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBfcHJvcE5hbWUyIGluIGNsaWVudFByb3BzKSB7XG4gICAgICBpZiAoIWNsaWVudFByb3BzLmhhc093blByb3BlcnR5KF9wcm9wTmFtZTIpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoX3Byb3BOYW1lMiA9PT0gJ2NoaWxkcmVuJykge1xuICAgICAgICAvLyBIYW5kbGVkIGJlbG93LlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIG1heExlbmd0aCA9IG1heFJvd0xlbmd0aCAtIChpbmRlbnQgKyAxKSAqIDIgLSBfcHJvcE5hbWUyLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgc2VydmVyUHJvcE5hbWUgPSBzZXJ2ZXJQcm9wTmFtZXMuZ2V0KF9wcm9wTmFtZTIudG9Mb3dlckNhc2UoKSk7XG5cbiAgICAgIGlmIChzZXJ2ZXJQcm9wTmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHNlcnZlclByb3BOYW1lcy5kZWxldGUoX3Byb3BOYW1lMi50b0xvd2VyQ2FzZSgpKTsgLy8gVGhlcmUncyBhIGRpZmYgaGVyZS5cblxuICAgICAgICB2YXIgY2xpZW50VmFsdWUgPSBjbGllbnRQcm9wc1tfcHJvcE5hbWUyXTtcbiAgICAgICAgdmFyIHNlcnZlclZhbHVlID0gc2VydmVyUHJvcHNbc2VydmVyUHJvcE5hbWVdO1xuICAgICAgICB2YXIgY2xpZW50UHJvcFZhbHVlID0gZGVzY3JpYmVQcm9wVmFsdWUoY2xpZW50VmFsdWUsIG1heExlbmd0aCk7XG4gICAgICAgIHZhciBzZXJ2ZXJQcm9wVmFsdWUgPSBkZXNjcmliZVByb3BWYWx1ZShzZXJ2ZXJWYWx1ZSwgbWF4TGVuZ3RoKTtcblxuICAgICAgICBpZiAodHlwZW9mIGNsaWVudFZhbHVlID09PSAnb2JqZWN0JyAmJiBjbGllbnRWYWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2Ygc2VydmVyVmFsdWUgPT09ICdvYmplY3QnICYmIHNlcnZlclZhbHVlICE9PSBudWxsICYmIG9iamVjdE5hbWUoY2xpZW50VmFsdWUpID09PSAnT2JqZWN0JyAmJiBvYmplY3ROYW1lKHNlcnZlclZhbHVlKSA9PT0gJ09iamVjdCcgJiYgKCAvLyBPbmx5IGRvIHRoZSBkaWZmIGlmIHRoZSBvYmplY3QgaGFzIGEgbG90IG9mIGtleXMgb3Igd2FzIHNob3J0ZW5lZC5cbiAgICAgICAgT2JqZWN0LmtleXMoY2xpZW50VmFsdWUpLmxlbmd0aCA+IDIgfHwgT2JqZWN0LmtleXMoc2VydmVyVmFsdWUpLmxlbmd0aCA+IDIgfHwgY2xpZW50UHJvcFZhbHVlLmluZGV4T2YoJy4uLicpID4gLTEgfHwgc2VydmVyUHJvcFZhbHVlLmluZGV4T2YoJy4uLicpID4gLTEpKSB7XG4gICAgICAgICAgLy8gV2UncmUgY29tcGFyaW5nIHR3byBwbGFpbiBvYmplY3RzLiBXZSBjYW4gZGlmZiB0aGUgbmVzdGVkIG9iamVjdHMgaW5zdGVhZC5cbiAgICAgICAgICBjb250ZW50ICs9IGluZGVudGF0aW9uKGluZGVudCArIDEpICsgX3Byb3BOYW1lMiArICc9e3tcXG4nICsgZGVzY3JpYmVQcm9wZXJ0aWVzRGlmZihjbGllbnRWYWx1ZSwgc2VydmVyVmFsdWUsIGluZGVudCArIDIpICsgaW5kZW50YXRpb24oaW5kZW50ICsgMSkgKyAnfX1cXG4nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRlbnQgKz0gYWRkZWQoaW5kZW50ICsgMSkgKyBfcHJvcE5hbWUyICsgJz0nICsgY2xpZW50UHJvcFZhbHVlICsgJ1xcbic7XG4gICAgICAgICAgY29udGVudCArPSByZW1vdmVkKGluZGVudCArIDEpICsgX3Byb3BOYW1lMiArICc9JyArIHNlcnZlclByb3BWYWx1ZSArICdcXG4nO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBDb25zaWRlcmVkIGVxdWFsLlxuICAgICAgICBjb250ZW50ICs9IGluZGVudGF0aW9uKGluZGVudCArIDEpICsgX3Byb3BOYW1lMiArICc9JyArIGRlc2NyaWJlUHJvcFZhbHVlKGNsaWVudFByb3BzW19wcm9wTmFtZTJdLCBtYXhMZW5ndGgpICsgJ1xcbic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc2VydmVyUHJvcE5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHByb3BOYW1lKSB7XG4gICAgICBpZiAocHJvcE5hbWUgPT09ICdjaGlsZHJlbicpIHtcbiAgICAgICAgLy8gSGFuZGxlZCBiZWxvdy5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF4TGVuZ3RoID0gbWF4Um93TGVuZ3RoIC0gKGluZGVudCArIDEpICogMiAtIHByb3BOYW1lLmxlbmd0aCAtIDE7XG4gICAgICBjb250ZW50ICs9IHJlbW92ZWQoaW5kZW50ICsgMSkgKyBwcm9wTmFtZSArICc9JyArIGRlc2NyaWJlUHJvcFZhbHVlKHNlcnZlclByb3BzW3Byb3BOYW1lXSwgbWF4TGVuZ3RoKSArICdcXG4nO1xuICAgIH0pO1xuXG4gICAgaWYgKGNvbnRlbnQgPT09ICcnKSB7XG4gICAgICAvLyBObyBwcm9wZXJ0aWVzXG4gICAgICBjb250ZW50ID0gaW5kZW50YXRpb24oaW5kZW50KSArICc8JyArIHR5cGUgKyAnPlxcbic7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEhhZCBwcm9wZXJ0aWVzXG4gICAgICBjb250ZW50ID0gaW5kZW50YXRpb24oaW5kZW50KSArICc8JyArIHR5cGUgKyAnXFxuJyArIGNvbnRlbnQgKyBpbmRlbnRhdGlvbihpbmRlbnQpICsgJz5cXG4nO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzZXJ2ZXJDaGlsZHJlbiA9IHNlcnZlclByb3BzLmNoaWxkcmVuO1xuICB2YXIgY2xpZW50Q2hpbGRyZW4gPSBjbGllbnRQcm9wcy5jaGlsZHJlbjtcblxuICBpZiAodHlwZW9mIHNlcnZlckNoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2Ygc2VydmVyQ2hpbGRyZW4gPT09ICdudW1iZXInIHx8IHR5cGVvZiBzZXJ2ZXJDaGlsZHJlbiA9PT0gJ2JpZ2ludCcpIHtcbiAgICAvLyBUaGVyZSdzIGEgZGlmZiBvZiB0aGUgY2hpbGRyZW4uXG4gICAgLy8gJEZsb3dGaXhNZVt1bnNhZmUtYWRkaXRpb25dXG4gICAgdmFyIHNlcnZlclRleHQgPSAnJyArIHNlcnZlckNoaWxkcmVuO1xuICAgIHZhciBjbGllbnRUZXh0ID0gJyc7XG5cbiAgICBpZiAodHlwZW9mIGNsaWVudENoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2xpZW50Q2hpbGRyZW4gPT09ICdudW1iZXInIHx8IHR5cGVvZiBjbGllbnRDaGlsZHJlbiA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgIC8vICRGbG93Rml4TWVbdW5zYWZlLWFkZGl0aW9uXVxuICAgICAgY2xpZW50VGV4dCA9ICcnICsgY2xpZW50Q2hpbGRyZW47XG4gICAgfVxuXG4gICAgY29udGVudCArPSBkZXNjcmliZVRleHREaWZmKGNsaWVudFRleHQsIHNlcnZlclRleHQsIGluZGVudCArIDEpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjbGllbnRDaGlsZHJlbiA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNsaWVudENoaWxkcmVuID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgY2xpZW50Q2hpbGRyZW4gPT09ICdiaWdpbnQnKSB7XG4gICAgLy8gVGhlIGNsaWVudCBoYXMgY2hpbGRyZW4gYnV0IGl0J3Mgbm90IGNvbnNpZGVyZWQgYSBkaWZmZXJlbmNlIGZyb20gdGhlIHNlcnZlci5cbiAgICAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hZGRpdGlvbl1cbiAgICBjb250ZW50ICs9IGRlc2NyaWJlVGV4dERpZmYoJycgKyBjbGllbnRDaGlsZHJlbiwgdW5kZWZpbmVkLCBpbmRlbnQgKyAxKTtcbiAgfVxuXG4gIHJldHVybiBjb250ZW50O1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVNpYmxpbmdGaWJlcihmaWJlciwgaW5kZW50KSB7XG4gIHZhciB0eXBlID0gZGVzY3JpYmVGaWJlclR5cGUoZmliZXIpO1xuXG4gIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgLy8gU2tpcCB0aGlzIHR5cGUgb2YgZmliZXIuIFdlIGN1cnJlbnRseSB0cmVhdCB0aGlzIGFzIGEgZnJhZ21lbnRcbiAgICAvLyBzbyBpdCdzIGp1c3QgcGFydCBvZiB0aGUgcGFyZW50J3MgY2hpbGRyZW4uXG4gICAgdmFyIGZsYXRDb250ZW50ID0gJyc7XG4gICAgdmFyIGNoaWxkRmliZXIgPSBmaWJlci5jaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZEZpYmVyKSB7XG4gICAgICBmbGF0Q29udGVudCArPSBkZXNjcmliZVNpYmxpbmdGaWJlcihjaGlsZEZpYmVyLCBpbmRlbnQpO1xuICAgICAgY2hpbGRGaWJlciA9IGNoaWxkRmliZXIuc2libGluZztcbiAgICB9XG5cbiAgICByZXR1cm4gZmxhdENvbnRlbnQ7XG4gIH1cblxuICByZXR1cm4gaW5kZW50YXRpb24oaW5kZW50KSArICc8JyArIHR5cGUgKyAnPicgKyAnXFxuJztcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOb2RlKG5vZGUsIGluZGVudCkge1xuICB2YXIgc2tpcFRvTm9kZSA9IGZpbmROb3RhYmxlTm9kZShub2RlLCBpbmRlbnQpO1xuXG4gIGlmIChza2lwVG9Ob2RlICE9PSBub2RlICYmIChub2RlLmNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBub2RlLmNoaWxkcmVuWzBdICE9PSBza2lwVG9Ob2RlKSkge1xuICAgIHJldHVybiBpbmRlbnRhdGlvbihpbmRlbnQpICsgJy4uLlxcbicgKyBkZXNjcmliZU5vZGUoc2tpcFRvTm9kZSwgaW5kZW50ICsgMSk7XG4gIH0gLy8gUHJlZml4IHdpdGggYW55IHNlcnZlciBjb21wb25lbnRzIGZvciBjb250ZXh0XG5cblxuICB2YXIgcGFyZW50Q29udGVudCA9ICcnO1xuICB2YXIgZGVidWdJbmZvID0gbm9kZS5maWJlci5fZGVidWdJbmZvO1xuXG4gIGlmIChkZWJ1Z0luZm8pIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlYnVnSW5mby5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHNlcnZlckNvbXBvbmVudE5hbWUgPSBkZWJ1Z0luZm9baV0ubmFtZTtcblxuICAgICAgaWYgKHR5cGVvZiBzZXJ2ZXJDb21wb25lbnROYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICBwYXJlbnRDb250ZW50ICs9IGluZGVudGF0aW9uKGluZGVudCkgKyAnPCcgKyBzZXJ2ZXJDb21wb25lbnROYW1lICsgJz4nICsgJ1xcbic7XG4gICAgICAgIGluZGVudCsrO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBTZWxmXG5cblxuICB2YXIgc2VsZkNvbnRlbnQgPSAnJzsgLy8gV2UgdXNlIHRoZSBwZW5kaW5nIHByb3BzIHNpbmNlIHdlIG1pZ2h0IGJlIGdlbmVyYXRpbmcgYSBkaWZmIGJlZm9yZSB0aGUgY29tcGxldGUgcGhhc2VcbiAgLy8gd2hlbiBzb21ldGhpbmcgdGhyb3dzLlxuXG4gIHZhciBjbGllbnRQcm9wcyA9IG5vZGUuZmliZXIucGVuZGluZ1Byb3BzO1xuXG4gIGlmIChub2RlLmZpYmVyLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAvLyBUZXh0IE5vZGVcbiAgICBzZWxmQ29udGVudCA9IGRlc2NyaWJlVGV4dERpZmYoY2xpZW50UHJvcHMsIG5vZGUuc2VydmVyUHJvcHMsIGluZGVudCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHR5cGUgPSBkZXNjcmliZUZpYmVyVHlwZShub2RlLmZpYmVyKTtcblxuICAgIGlmICh0eXBlICE9PSBudWxsKSB7XG4gICAgICAvLyBFbGVtZW50IE5vZGVcbiAgICAgIGlmIChub2RlLnNlcnZlclByb3BzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gSnVzdCBhIHJlZmVyZW5jZSBub2RlIGZvciBjb250ZXh0LlxuICAgICAgICBzZWxmQ29udGVudCA9IGRlc2NyaWJlQ29sbGFwc2VkRWxlbWVudCh0eXBlLCBjbGllbnRQcm9wcywgaW5kZW50KTtcbiAgICAgICAgaW5kZW50Kys7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUuc2VydmVyUHJvcHMgPT09IG51bGwpIHtcbiAgICAgICAgc2VsZkNvbnRlbnQgPSBkZXNjcmliZUV4cGFuZGVkRWxlbWVudCh0eXBlLCBjbGllbnRQcm9wcywgYWRkZWQoaW5kZW50KSk7IC8vIElmIHRoaXMgd2FzIGFuIGluc2VydGlvbiB3ZSB3b24ndCBzdGVwIGRvd24gZnVydGhlci4gQW55IHRhaWxcbiAgICAgICAgLy8gYXJlIGNvbnNpZGVyZWQgc2libGluZ3Mgc28gd2UgZG9uJ3QgaW5kZW50LlxuICAgICAgICAvLyBUT0RPOiBNb2RlbCB0aGlzIGEgbGl0dGxlIGJldHRlci5cbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUuc2VydmVyUHJvcHMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBlcnJvcignU2hvdWxkIG5vdCBoYXZlIG1hdGNoZWQgYSBub24gSG9zdFRleHQgZmliZXIgdG8gYSBUZXh0IG5vZGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlbGZDb250ZW50ID0gZGVzY3JpYmVFbGVtZW50RGlmZih0eXBlLCBjbGllbnRQcm9wcywgbm9kZS5zZXJ2ZXJQcm9wcywgaW5kZW50KTtcbiAgICAgICAgaW5kZW50Kys7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENvbXB1dGUgY2hpbGRyZW5cblxuXG4gIHZhciBjaGlsZENvbnRlbnQgPSAnJztcbiAgdmFyIGNoaWxkRmliZXIgPSBub2RlLmZpYmVyLmNoaWxkO1xuICB2YXIgZGlmZklkeCA9IDA7XG5cbiAgd2hpbGUgKGNoaWxkRmliZXIgJiYgZGlmZklkeCA8IG5vZGUuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgdmFyIGNoaWxkTm9kZSA9IG5vZGUuY2hpbGRyZW5bZGlmZklkeF07XG5cbiAgICBpZiAoY2hpbGROb2RlLmZpYmVyID09PSBjaGlsZEZpYmVyKSB7XG4gICAgICAvLyBUaGlzIHdhcyBhIG1hdGNoIGluIHRoZSBkaWZmLlxuICAgICAgY2hpbGRDb250ZW50ICs9IGRlc2NyaWJlTm9kZShjaGlsZE5vZGUsIGluZGVudCk7XG4gICAgICBkaWZmSWR4Kys7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYW4gdW5yZWxhdGVkIHByZXZpb3VzIHNpYmxpbmcuXG4gICAgICBjaGlsZENvbnRlbnQgKz0gZGVzY3JpYmVTaWJsaW5nRmliZXIoY2hpbGRGaWJlciwgaW5kZW50KTtcbiAgICB9XG5cbiAgICBjaGlsZEZpYmVyID0gY2hpbGRGaWJlci5zaWJsaW5nO1xuICB9XG5cbiAgaWYgKGNoaWxkRmliZXIgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgLy8gSWYgd2UgaGFkIGFueSBmdXJ0aGVyIHNpYmxpbmdzIGFmdGVyIHRoZSBsYXN0IG1pc21hdGNoLCB3ZSBjYW4ndCBiZSBzdXJlIGlmIGl0J3NcbiAgICAvLyBhY3R1YWxseSBhIHZhbGlkIG1hdGNoIHNpbmNlIGl0IG1pZ2h0IG5vdCBoYXZlIGZvdW5kIGEgbWF0Y2guIFNvIHdlIGV4Y2x1ZGUgbmV4dFxuICAgIC8vIHNpYmxpbmdzIHRvIGF2b2lkIGNvbmZ1c2lvbi5cbiAgICBjaGlsZENvbnRlbnQgKz0gaW5kZW50YXRpb24oaW5kZW50KSArICcuLi4nICsgJ1xcbic7XG4gIH0gLy8gRGVsZXRlZCB0YWlsIG5vZGVzXG5cblxuICB2YXIgc2VydmVyVGFpbCA9IG5vZGUuc2VydmVyVGFpbDtcblxuICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgc2VydmVyVGFpbC5sZW5ndGg7IF9pKyspIHtcbiAgICB2YXIgdGFpbE5vZGUgPSBzZXJ2ZXJUYWlsW19pXTtcblxuICAgIGlmICh0eXBlb2YgdGFpbE5vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBSZW1vdmVkIHRleHQgbm9kZVxuICAgICAgY2hpbGRDb250ZW50ICs9IHJlbW92ZWQoaW5kZW50KSArIGRlc2NyaWJlVGV4dE5vZGUodGFpbE5vZGUsIG1heFJvd0xlbmd0aCAtIGluZGVudCAqIDIpICsgJ1xcbic7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbW92ZWQgZWxlbWVudFxuICAgICAgY2hpbGRDb250ZW50ICs9IGRlc2NyaWJlRXhwYW5kZWRFbGVtZW50KHRhaWxOb2RlLnR5cGUsIHRhaWxOb2RlLnByb3BzLCByZW1vdmVkKGluZGVudCkpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJlbnRDb250ZW50ICsgc2VsZkNvbnRlbnQgKyBjaGlsZENvbnRlbnQ7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlRGlmZihyb290Tm9kZSkge1xuICB0cnkge1xuICAgIHJldHVybiAnXFxuXFxuJyArIGRlc2NyaWJlTm9kZShyb290Tm9kZSwgMCk7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cbn1cblxuLy8gVGhpcyBtYXkgaGF2ZSBiZWVuIGFuIGluc2VydGlvbiBvciBhIGh5ZHJhdGlvbi5cblxudmFyIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gbnVsbDtcbnZhciBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbnZhciBpc0h5ZHJhdGluZyA9IGZhbHNlOyAvLyBUaGlzIGZsYWcgYWxsb3dzIGZvciB3YXJuaW5nIHN1cHJlc3Npb24gd2hlbiB3ZSBleHBlY3QgdGhlcmUgdG8gYmUgbWlzbWF0Y2hlc1xuLy8gZHVlIHRvIGVhcmxpZXIgbWlzbWF0Y2hlcyBvciBhIHN1c3BlbmRlZCBmaWJlci5cblxudmFyIGRpZFN1c3BlbmRPckVycm9yREVWID0gZmFsc2U7IC8vIEh5ZHJhdGlvbiBkaWZmZXJlbmNlcyBmb3VuZCB0aGF0IGhhdmVuJ3QgeWV0IGJlZW4gbG9nZ2VkLlxuXG52YXIgaHlkcmF0aW9uRGlmZlJvb3RERVYgPSBudWxsOyAvLyBIeWRyYXRpb24gZXJyb3JzIHRoYXQgd2VyZSB0aHJvd24gaW5zaWRlIHRoaXMgYm91bmRhcnlcblxudmFyIGh5ZHJhdGlvbkVycm9ycyA9IG51bGw7XG52YXIgcm9vdE9yU2luZ2xldG9uQ29udGV4dCA9IGZhbHNlOyAvLyBCdWlsZHMgYSBjb21tb24gYW5jZXN0b3IgdHJlZSBmcm9tIHRoZSByb290IGRvd24gZm9yIGNvbGxlY3RpbmcgZGlmZnMuXG5cbmZ1bmN0aW9uIGJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUoZmliZXIsIGRpc3RhbmNlRnJvbUxlYWYpIHtcbiAgaWYgKGZpYmVyLnJldHVybiA9PT0gbnVsbCkge1xuICAgIC8vIFdlJ3JlIGF0IHRoZSByb290LlxuICAgIGlmIChoeWRyYXRpb25EaWZmUm9vdERFViA9PT0gbnVsbCkge1xuICAgICAgaHlkcmF0aW9uRGlmZlJvb3RERVYgPSB7XG4gICAgICAgIGZpYmVyOiBmaWJlcixcbiAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICBzZXJ2ZXJQcm9wczogdW5kZWZpbmVkLFxuICAgICAgICBzZXJ2ZXJUYWlsOiBbXSxcbiAgICAgICAgZGlzdGFuY2VGcm9tTGVhZjogZGlzdGFuY2VGcm9tTGVhZlxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGh5ZHJhdGlvbkRpZmZSb290REVWLmZpYmVyICE9PSBmaWJlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTYXcgbXVsdGlwbGUgaHlkcmF0aW9uIGRpZmYgcm9vdHMgaW4gYSBwYXNzLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgIH0gZWxzZSBpZiAoaHlkcmF0aW9uRGlmZlJvb3RERVYuZGlzdGFuY2VGcm9tTGVhZiA+IGRpc3RhbmNlRnJvbUxlYWYpIHtcbiAgICAgIGh5ZHJhdGlvbkRpZmZSb290REVWLmRpc3RhbmNlRnJvbUxlYWYgPSBkaXN0YW5jZUZyb21MZWFmO1xuICAgIH1cblxuICAgIHJldHVybiBoeWRyYXRpb25EaWZmUm9vdERFVjtcbiAgfVxuXG4gIHZhciBzaWJsaW5ncyA9IGJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUoZmliZXIucmV0dXJuLCBkaXN0YW5jZUZyb21MZWFmICsgMSkuY2hpbGRyZW47IC8vIFRoZSBzYW1lIG5vZGUgbWF5IGFscmVhZHkgZXhpc3QgaW4gdGhlIHBhcmVudC4gU2luY2Ugd2UgY3VycmVudGx5IGFsd2F5cyByZW5kZXIgZGVwdGggZmlyc3RcbiAgLy8gYW5kIHJlcmVuZGVyIGlmIHdlIHN1c3BlbmQgb3IgdGVybWluYXRlIGVhcmx5LCBpZiBhIHNoYXJlZCBhbmNlc3RvciB3YXMgYWRkZWQgd2Ugc2hvdWxkIHN0aWxsXG4gIC8vIGJlIGluc2lkZSBvZiB0aGF0IHNoYXJlZCBhbmNlc3RvciB3aGljaCBtZWFucyBpdCB3YXMgdGhlIGxhc3Qgb25lIHRvIGJlIGFkZGVkLiBJZiB0aGlzIGNoYW5nZXNcbiAgLy8gd2UgbWF5IGhhdmUgdG8gc2NhbiB0aGUgd2hvbGUgc2V0LlxuXG4gIGlmIChzaWJsaW5ncy5sZW5ndGggPiAwICYmIHNpYmxpbmdzW3NpYmxpbmdzLmxlbmd0aCAtIDFdLmZpYmVyID09PSBmaWJlcikge1xuICAgIHZhciBleGlzdGluZyA9IHNpYmxpbmdzW3NpYmxpbmdzLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGV4aXN0aW5nLmRpc3RhbmNlRnJvbUxlYWYgPiBkaXN0YW5jZUZyb21MZWFmKSB7XG4gICAgICBleGlzdGluZy5kaXN0YW5jZUZyb21MZWFmID0gZGlzdGFuY2VGcm9tTGVhZjtcbiAgICB9XG5cbiAgICByZXR1cm4gZXhpc3Rpbmc7XG4gIH1cblxuICB2YXIgbmV3Tm9kZSA9IHtcbiAgICBmaWJlcjogZmliZXIsXG4gICAgY2hpbGRyZW46IFtdLFxuICAgIHNlcnZlclByb3BzOiB1bmRlZmluZWQsXG4gICAgc2VydmVyVGFpbDogW10sXG4gICAgZGlzdGFuY2VGcm9tTGVhZjogZGlzdGFuY2VGcm9tTGVhZlxuICB9O1xuICBzaWJsaW5ncy5wdXNoKG5ld05vZGUpO1xuICByZXR1cm4gbmV3Tm9kZTtcbn1cblxuZnVuY3Rpb24gd2FybklmSHlkcmF0aW5nKCkge1xuICB7XG4gICAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgICBlcnJvcignV2Ugc2hvdWxkIG5vdCBiZSBoeWRyYXRpbmcgaGVyZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYSBidWcuJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtEaWRUaHJvd1doaWxlSHlkcmF0aW5nREVWKCkge1xuICB7XG4gICAgZGlkU3VzcGVuZE9yRXJyb3JERVYgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVudGVySHlkcmF0aW9uU3RhdGUoZmliZXIpIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwYXJlbnRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXIocGFyZW50SW5zdGFuY2UpO1xuICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gIGh5ZHJhdGlvbkVycm9ycyA9IG51bGw7XG4gIGRpZFN1c3BlbmRPckVycm9yREVWID0gZmFsc2U7XG4gIGh5ZHJhdGlvbkRpZmZSb290REVWID0gbnVsbDtcbiAgcm9vdE9yU2luZ2xldG9uQ29udGV4dCA9IHRydWU7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZWVudGVySHlkcmF0aW9uU3RhdGVGcm9tRGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UoZmliZXIsIHN1c3BlbnNlSW5zdGFuY2UsIHRyZWVDb250ZXh0KSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5TdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpO1xuICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyO1xuICBpc0h5ZHJhdGluZyA9IHRydWU7XG4gIGh5ZHJhdGlvbkVycm9ycyA9IG51bGw7XG4gIGRpZFN1c3BlbmRPckVycm9yREVWID0gZmFsc2U7XG4gIGh5ZHJhdGlvbkRpZmZSb290REVWID0gbnVsbDtcbiAgcm9vdE9yU2luZ2xldG9uQ29udGV4dCA9IGZhbHNlO1xuXG4gIGlmICh0cmVlQ29udGV4dCAhPT0gbnVsbCkge1xuICAgIHJlc3RvcmVTdXNwZW5kZWRUcmVlQ29udGV4dChmaWJlciwgdHJlZUNvbnRleHQpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdhcm5Ob25IeWRyYXRlZEluc3RhbmNlKGZpYmVyLCByZWplY3RlZENhbmRpZGF0ZSkge1xuICB7XG4gICAgaWYgKGRpZFN1c3BlbmRPckVycm9yREVWKSB7XG4gICAgICAvLyBJbnNpZGUgYSBib3VuZGFyeSB0aGF0IGFscmVhZHkgc3VzcGVuZGVkLiBXZSdyZSBjdXJyZW50bHkgcmVuZGVyaW5nIHRoZVxuICAgICAgLy8gc2libGluZ3Mgb2YgYSBzdXNwZW5kZWQgbm9kZS4gVGhlIG1pc21hdGNoIG1heSBiZSBkdWUgdG8gdGhlIG1pc3NpbmdcbiAgICAgIC8vIGRhdGEsIHNvIGl0J3MgcHJvYmFibHkgYSBmYWxzZSBwb3NpdGl2ZS5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEFkZCB0aGlzIGZpYmVyIHRvIHRoZSBkaWZmIHRyZWUuXG5cblxuICAgIHZhciBkaWZmTm9kZSA9IGJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUoZmliZXIsIDApOyAvLyBXZSB1c2UgbnVsbCBhcyBhIHNpZ25hbCB0aGF0IHRoZXJlIHdhcyBubyBub2RlIHRvIG1hdGNoLlxuXG4gICAgZGlmZk5vZGUuc2VydmVyUHJvcHMgPSBudWxsO1xuXG4gICAgaWYgKHJlamVjdGVkQ2FuZGlkYXRlICE9PSBudWxsKSB7XG4gICAgICB2YXIgZGVzY3JpcHRpb24gPSBkZXNjcmliZUh5ZHJhdGFibGVJbnN0YW5jZUZvckRldldhcm5pbmdzKHJlamVjdGVkQ2FuZGlkYXRlKTtcbiAgICAgIGRpZmZOb2RlLnNlcnZlclRhaWwucHVzaChkZXNjcmlwdGlvbik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRyeUh5ZHJhdGVJbnN0YW5jZShmaWJlciwgbmV4dEluc3RhbmNlLCBob3N0Q29udGV4dCkge1xuICAvLyBmaWJlciBpcyBhIEhvc3RDb21wb25lbnQgRmliZXJcbiAgdmFyIGluc3RhbmNlID0gY2FuSHlkcmF0ZUluc3RhbmNlKG5leHRJbnN0YW5jZSwgZmliZXIudHlwZSwgZmliZXIucGVuZGluZ1Byb3BzLCByb290T3JTaW5nbGV0b25Db250ZXh0KTtcblxuICBpZiAoaW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICBmaWJlci5zdGF0ZU5vZGUgPSBpbnN0YW5jZTtcblxuICAgIHtcbiAgICAgIGlmICghZGlkU3VzcGVuZE9yRXJyb3JERVYpIHtcbiAgICAgICAgdmFyIGRpZmZlcmVuY2VzID0gZGlmZkh5ZHJhdGVkUHJvcHNGb3JEZXZXYXJuaW5ncyhpbnN0YW5jZSwgZmliZXIudHlwZSwgZmliZXIucGVuZGluZ1Byb3BzLCBob3N0Q29udGV4dCk7XG5cbiAgICAgICAgaWYgKGRpZmZlcmVuY2VzICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGRpZmZOb2RlID0gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShmaWJlciwgMCk7XG4gICAgICAgICAgZGlmZk5vZGUuc2VydmVyUHJvcHMgPSBkaWZmZXJlbmNlcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKGluc3RhbmNlKTtcbiAgICByb290T3JTaW5nbGV0b25Db250ZXh0ID0gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHRyeUh5ZHJhdGVUZXh0KGZpYmVyLCBuZXh0SW5zdGFuY2UpIHtcbiAgLy8gZmliZXIgaXMgYSBIb3N0VGV4dCBGaWJlclxuICB2YXIgdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgdmFyIHRleHRJbnN0YW5jZSA9IGNhbkh5ZHJhdGVUZXh0SW5zdGFuY2UobmV4dEluc3RhbmNlLCB0ZXh0LCByb290T3JTaW5nbGV0b25Db250ZXh0KTtcblxuICBpZiAodGV4dEluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgZmliZXIuc3RhdGVOb2RlID0gdGV4dEluc3RhbmNlO1xuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7IC8vIFRleHQgSW5zdGFuY2VzIGRvbid0IGhhdmUgY2hpbGRyZW4gc28gdGhlcmUncyBub3RoaW5nIHRvIGh5ZHJhdGUuXG5cbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gdHJ5SHlkcmF0ZVN1c3BlbnNlKGZpYmVyLCBuZXh0SW5zdGFuY2UpIHtcbiAgLy8gZmliZXIgaXMgYSBTdXNwZW5zZUNvbXBvbmVudCBGaWJlclxuICB2YXIgc3VzcGVuc2VJbnN0YW5jZSA9IGNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlKG5leHRJbnN0YW5jZSwgcm9vdE9yU2luZ2xldG9uQ29udGV4dCk7XG5cbiAgaWYgKHN1c3BlbnNlSW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IHtcbiAgICAgIGRlaHlkcmF0ZWQ6IHN1c3BlbnNlSW5zdGFuY2UsXG4gICAgICB0cmVlQ29udGV4dDogZ2V0U3VzcGVuZGVkVHJlZUNvbnRleHQoKSxcbiAgICAgIHJldHJ5TGFuZTogT2Zmc2NyZWVuTGFuZVxuICAgIH07XG4gICAgZmliZXIubWVtb2l6ZWRTdGF0ZSA9IHN1c3BlbnNlU3RhdGU7IC8vIFN0b3JlIHRoZSBkZWh5ZHJhdGVkIGZyYWdtZW50IGFzIGEgY2hpbGQgZmliZXIuXG4gICAgLy8gVGhpcyBzaW1wbGlmaWVzIHRoZSBjb2RlIGZvciBnZXRIb3N0U2libGluZyBhbmQgZGVsZXRpbmcgbm9kZXMsXG4gICAgLy8gc2luY2UgaXQgZG9lc24ndCBoYXZlIHRvIGNvbnNpZGVyIGFsbCBTdXNwZW5zZSBib3VuZGFyaWVzIGFuZFxuICAgIC8vIGNoZWNrIGlmIHRoZXkncmUgZGVoeWRyYXRlZCBvbmVzIG9yIG5vdC5cblxuICAgIHZhciBkZWh5ZHJhdGVkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21EZWh5ZHJhdGVkRnJhZ21lbnQoc3VzcGVuc2VJbnN0YW5jZSk7XG4gICAgZGVoeWRyYXRlZEZyYWdtZW50LnJldHVybiA9IGZpYmVyO1xuICAgIGZpYmVyLmNoaWxkID0gZGVoeWRyYXRlZEZyYWdtZW50O1xuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7IC8vIFdoaWxlIGEgU3VzcGVuc2UgSW5zdGFuY2UgZG9lcyBoYXZlIGNoaWxkcmVuLCB3ZSB3b24ndCBzdGVwIGludG9cbiAgICAvLyBpdCBkdXJpbmcgdGhlIGZpcnN0IHBhc3MuIEluc3RlYWQsIHdlJ2xsIHJlZW50ZXIgaXQgbGF0ZXIuXG5cbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIEh5ZHJhdGlvbk1pc21hdGNoRXhjZXB0aW9uID0gbmV3IEVycm9yKCdIeWRyYXRpb24gTWlzbWF0Y2ggRXhjZXB0aW9uOiBUaGlzIGlzIG5vdCBhIHJlYWwgZXJyb3IsIGFuZCBzaG91bGQgbm90IGxlYWsgaW50byAnICsgXCJ1c2Vyc3BhY2UuIElmIHlvdSdyZSBzZWVpbmcgdGhpcywgaXQncyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuXCIpO1xuXG5mdW5jdGlvbiB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goZmliZXIpIHtcbiAgdmFyIGRpZmYgPSAnJztcblxuICB7XG4gICAgLy8gQ29uc3VtZSB0aGUgZGlmZiByb290IGZvciB0aGlzIG1pc21hdGNoLlxuICAgIC8vIEFueSBvdGhlciBlcnJvcnMgd2lsbCBnZXQgdGhlaXIgb3duIGRpZmZzLlxuICAgIHZhciBkaWZmUm9vdCA9IGh5ZHJhdGlvbkRpZmZSb290REVWO1xuXG4gICAgaWYgKGRpZmZSb290ICE9PSBudWxsKSB7XG4gICAgICBoeWRyYXRpb25EaWZmUm9vdERFViA9IG51bGw7XG4gICAgICBkaWZmID0gZGVzY3JpYmVEaWZmKGRpZmZSb290KTtcbiAgICB9XG4gIH1cblxuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IoXCJIeWRyYXRpb24gZmFpbGVkIGJlY2F1c2UgdGhlIHNlcnZlciByZW5kZXJlZCBIVE1MIGRpZG4ndCBtYXRjaCB0aGUgY2xpZW50LiBBcyBhIHJlc3VsdCB0aGlzIHRyZWUgd2lsbCBiZSByZWdlbmVyYXRlZCBvbiB0aGUgY2xpZW50LiBUaGlzIGNhbiBoYXBwZW4gaWYgYSBTU1ItZWQgQ2xpZW50IENvbXBvbmVudCB1c2VkOlxcblwiICsgJ1xcbicgKyBcIi0gQSBzZXJ2ZXIvY2xpZW50IGJyYW5jaCBgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKWAuXFxuXCIgKyBcIi0gVmFyaWFibGUgaW5wdXQgc3VjaCBhcyBgRGF0ZS5ub3coKWAgb3IgYE1hdGgucmFuZG9tKClgIHdoaWNoIGNoYW5nZXMgZWFjaCB0aW1lIGl0J3MgY2FsbGVkLlxcblwiICsgXCItIERhdGUgZm9ybWF0dGluZyBpbiBhIHVzZXIncyBsb2NhbGUgd2hpY2ggZG9lc24ndCBtYXRjaCB0aGUgc2VydmVyLlxcblwiICsgJy0gRXh0ZXJuYWwgY2hhbmdpbmcgZGF0YSB3aXRob3V0IHNlbmRpbmcgYSBzbmFwc2hvdCBvZiBpdCBhbG9uZyB3aXRoIHRoZSBIVE1MLlxcbicgKyAnLSBJbnZhbGlkIEhUTUwgdGFnIG5lc3RpbmcuXFxuJyArICdcXG4nICsgJ0l0IGNhbiBhbHNvIGhhcHBlbiBpZiB0aGUgY2xpZW50IGhhcyBhIGJyb3dzZXIgZXh0ZW5zaW9uIGluc3RhbGxlZCB3aGljaCBtZXNzZXMgd2l0aCB0aGUgSFRNTCBiZWZvcmUgUmVhY3QgbG9hZGVkLlxcbicgKyAnXFxuJyArICdodHRwczovL3JlYWN0LmRldi9saW5rL2h5ZHJhdGlvbi1taXNtYXRjaCcgKyBkaWZmKTtcbiAgcXVldWVIeWRyYXRpb25FcnJvcihjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihlcnJvciwgZmliZXIpKTtcbiAgdGhyb3cgSHlkcmF0aW9uTWlzbWF0Y2hFeGNlcHRpb247XG59XG5cbmZ1bmN0aW9uIGNsYWltSHlkcmF0YWJsZVNpbmdsZXRvbihmaWJlcikge1xuICBpZiAoc3VwcG9ydHNTaW5nbGV0b25zKSB7XG4gICAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50Um9vdENvbnRhaW5lciA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG4gICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlID0gcmVzb2x2ZVNpbmdsZXRvbkluc3RhbmNlKGZpYmVyLnR5cGUsIGZpYmVyLnBlbmRpbmdQcm9wcywgY3VycmVudFJvb3RDb250YWluZXIsIGN1cnJlbnRIb3N0Q29udGV4dCwgZmFsc2UpO1xuXG4gICAge1xuICAgICAgaWYgKCFkaWRTdXNwZW5kT3JFcnJvckRFVikge1xuICAgICAgICB2YXIgZGlmZmVyZW5jZXMgPSBkaWZmSHlkcmF0ZWRQcm9wc0ZvckRldldhcm5pbmdzKGluc3RhbmNlLCBmaWJlci50eXBlLCBmaWJlci5wZW5kaW5nUHJvcHMsIGN1cnJlbnRIb3N0Q29udGV4dCk7XG5cbiAgICAgICAgaWYgKGRpZmZlcmVuY2VzICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGRpZmZOb2RlID0gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShmaWJlciwgMCk7XG4gICAgICAgICAgZGlmZk5vZGUuc2VydmVyUHJvcHMgPSBkaWZmZXJlbmNlcztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dCA9IHRydWU7XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldEZpcnN0SHlkcmF0YWJsZUNoaWxkKGluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZShmaWJlcikge1xuICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgcmV0dXJuO1xuICB9IC8vIFZhbGlkYXRlIHRoYXQgdGhpcyBpcyBvayB0byByZW5kZXIgaGVyZSBiZWZvcmUgYW55IG1pc21hdGNoZXMuXG5cblxuICB2YXIgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgdmFyIHNob3VsZEtlZXBXYXJuaW5nID0gdmFsaWRhdGVIeWRyYXRhYmxlSW5zdGFuY2UoZmliZXIudHlwZSwgZmliZXIucGVuZGluZ1Byb3BzLCBjdXJyZW50SG9zdENvbnRleHQpO1xuICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcblxuICBpZiAoIW5leHRJbnN0YW5jZSB8fCAhdHJ5SHlkcmF0ZUluc3RhbmNlKGZpYmVyLCBuZXh0SW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCkpIHtcbiAgICBpZiAoc2hvdWxkS2VlcFdhcm5pbmcpIHtcbiAgICAgIHdhcm5Ob25IeWRyYXRlZEluc3RhbmNlKGZpYmVyLCBuZXh0SW5zdGFuY2UpO1xuICAgIH1cblxuICAgIHRocm93T25IeWRyYXRpb25NaXNtYXRjaChmaWJlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlVGV4dEluc3RhbmNlKGZpYmVyKSB7XG4gIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgdGV4dCA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgdmFyIHNob3VsZEtlZXBXYXJuaW5nID0gdHJ1ZTsgLy8gVmFsaWRhdGUgdGhhdCB0aGlzIGlzIG9rIHRvIHJlbmRlciBoZXJlIGJlZm9yZSBhbnkgbWlzbWF0Y2hlcy5cblxuICB2YXIgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgc2hvdWxkS2VlcFdhcm5pbmcgPSB2YWxpZGF0ZUh5ZHJhdGFibGVUZXh0SW5zdGFuY2UodGV4dCwgY3VycmVudEhvc3RDb250ZXh0KTtcbiAgdmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG5cbiAgaWYgKCFuZXh0SW5zdGFuY2UgfHwgIXRyeUh5ZHJhdGVUZXh0KGZpYmVyLCBuZXh0SW5zdGFuY2UpKSB7XG4gICAgaWYgKHNob3VsZEtlZXBXYXJuaW5nKSB7XG4gICAgICB3YXJuTm9uSHlkcmF0ZWRJbnN0YW5jZShmaWJlciwgbmV4dEluc3RhbmNlKTtcbiAgICB9XG5cbiAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZVN1c3BlbnNlSW5zdGFuY2UoZmliZXIpIHtcbiAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuXG4gIGlmICghbmV4dEluc3RhbmNlIHx8ICF0cnlIeWRyYXRlU3VzcGVuc2UoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcbiAgICB3YXJuTm9uSHlkcmF0ZWRJbnN0YW5jZShmaWJlciwgbmV4dEluc3RhbmNlKTtcbiAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUZvcm1NYXJrZXJJbnN0YW5jZShmaWJlcikge1xuICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UpIHtcbiAgICB2YXIgbWFya2VySW5zdGFuY2UgPSBjYW5IeWRyYXRlRm9ybVN0YXRlTWFya2VyKG5leHRIeWRyYXRhYmxlSW5zdGFuY2UsIHJvb3RPclNpbmdsZXRvbkNvbnRleHQpO1xuXG4gICAgaWYgKG1hcmtlckluc3RhbmNlKSB7XG4gICAgICAvLyBGb3VuZCB0aGUgbWFya2VyIGluc3RhbmNlLlxuICAgICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhtYXJrZXJJbnN0YW5jZSk7IC8vIFJldHVybiB0cnVlIGlmIHRoaXMgbWFya2VyIGluc3RhbmNlIHNob3VsZCB1c2UgdGhlIHN0YXRlIHBhc3NlZFxuICAgICAgLy8gdG8gaHlkcmF0ZVJvb3QuXG4gICAgICAvLyBUT0RPOiBBcyBhbiBvcHRpbWl6YXRpb24sIEZpenogc2hvdWxkIG9ubHkgZW1pdCB0aGVzZSBtYXJrZXJzIGlmIGZvcm1cbiAgICAgIC8vIHN0YXRlIGlzIHBhc3NlZCBhdCB0aGUgcm9vdC5cblxuICAgICAgcmV0dXJuIGlzRm9ybVN0YXRlTWFya2VyTWF0Y2hpbmcobWFya2VySW5zdGFuY2UpO1xuICAgIH1cbiAgfSAvLyBTaG91bGQgaGF2ZSBmb3VuZCBhIG1hcmtlciBpbnN0YW5jZS4gVGhyb3cgYW4gZXJyb3IgdG8gdHJpZ2dlciBjbGllbnRcbiAgLy8gcmVuZGVyaW5nLiBXZSBkb24ndCBib3RoZXIgdG8gY2hlY2sgaWYgd2UncmUgaW4gYSBjb25jdXJyZW50IHJvb3QgYmVjYXVzZVxuICAvLyB1c2VBY3Rpb25TdGF0ZSBpcyBhIG5ldyBBUEksIHNvIGJhY2t3YXJkcyBjb21wYXQgaXMgbm90IGFuIGlzc3VlLlxuXG5cbiAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGZpYmVyKTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKGZpYmVyLCBob3N0Q29udGV4dCkge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gIHZhciBkaWRIeWRyYXRlID0gaHlkcmF0ZUluc3RhbmNlKGluc3RhbmNlLCBmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzLCBob3N0Q29udGV4dCwgZmliZXIpO1xuXG4gIGlmICghZGlkSHlkcmF0ZSAmJiBmYXZvclNhZmV0eU92ZXJIeWRyYXRpb25QZXJmKSB7XG4gICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGZpYmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZShmaWJlcikge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG5cbiAgdmFyIHRleHRJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgdmFyIHRleHRDb250ZW50ID0gZmliZXIubWVtb2l6ZWRQcm9wcztcbiAgdmFyIHNob3VsZFdhcm5JZk1pc21hdGNoRGV2ID0gIWRpZFN1c3BlbmRPckVycm9yREVWO1xuICB2YXIgcGFyZW50UHJvcHMgPSBudWxsOyAvLyBXZSBhc3N1bWUgdGhhdCBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSBpcyBjYWxsZWQgaW4gYSBjb250ZXh0IHdoZXJlIHRoZVxuICAvLyBoeWRyYXRpb24gcGFyZW50IGlzIHRoZSBwYXJlbnQgaG9zdCBjb21wb25lbnQgb2YgdGhpcyBob3N0IHRleHQuXG5cbiAgdmFyIHJldHVybkZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXI7XG5cbiAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgc3dpdGNoIChyZXR1cm5GaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkV2FybklmTWlzbWF0Y2hEZXYpIHtcbiAgICAgICAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSBkaWZmSHlkcmF0ZWRUZXh0Rm9yRGV2V2FybmluZ3ModGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCwgcGFyZW50UHJvcHMpO1xuXG4gICAgICAgICAgICAgIGlmIChkaWZmZXJlbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpZmZOb2RlID0gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShmaWJlciwgMCk7XG4gICAgICAgICAgICAgICAgZGlmZk5vZGUuc2VydmVyUHJvcHMgPSBkaWZmZXJlbmNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgcGFyZW50UHJvcHMgPSByZXR1cm5GaWJlci5tZW1vaXplZFByb3BzO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKHNob3VsZFdhcm5JZk1pc21hdGNoRGV2KSB7XG4gICAgICAgICAgICAgIHZhciBfZGlmZmVyZW5jZSA9IGRpZmZIeWRyYXRlZFRleHRGb3JEZXZXYXJuaW5ncyh0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50LCBwYXJlbnRQcm9wcyk7XG5cbiAgICAgICAgICAgICAgaWYgKF9kaWZmZXJlbmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9kaWZmTm9kZSA9IGJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUoZmliZXIsIDApO1xuXG4gICAgICAgICAgICAgICAgX2RpZmZOb2RlLnNlcnZlclByb3BzID0gX2RpZmZlcmVuY2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0gLy8gVE9ETzogV2hhdCBpZiBpdCdzIGEgU3VzcGVuc2VJbnN0YW5jZT9cblxuICB9XG5cbiAgdmFyIGRpZEh5ZHJhdGUgPSBoeWRyYXRlVGV4dEluc3RhbmNlKHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQsIGZpYmVyLCBwYXJlbnRQcm9wcyk7XG5cbiAgaWYgKCFkaWRIeWRyYXRlICYmIGZhdm9yU2FmZXR5T3Zlckh5ZHJhdGlvblBlcmYpIHtcbiAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0U3VzcGVuc2VJbnN0YW5jZShmaWJlcikge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBwcmVwYXJlVG9IeWRyYXRlSG9zdFN1c3BlbnNlSW5zdGFuY2UoKSB0byBuZXZlciBiZSBjYWxsZWQuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHZhciBzdXNwZW5zZVN0YXRlID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIHN1c3BlbnNlSW5zdGFuY2UgPSBzdXNwZW5zZVN0YXRlICE9PSBudWxsID8gc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkIDogbnVsbDtcblxuICBpZiAoIXN1c3BlbnNlSW5zdGFuY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGhhdmUgYSBoeWRyYXRlZCBzdXNwZW5zZSBpbnN0YW5jZS4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG5cbiAgaHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBza2lwUGFzdERlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKGZpYmVyKSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UoKSB0byBuZXZlciBiZSBjYWxsZWQuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHZhciBzdXNwZW5zZVN0YXRlID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIHN1c3BlbnNlSW5zdGFuY2UgPSBzdXNwZW5zZVN0YXRlICE9PSBudWxsID8gc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkIDogbnVsbDtcblxuICBpZiAoIXN1c3BlbnNlSW5zdGFuY2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGhhdmUgYSBoeWRyYXRlZCBzdXNwZW5zZSBpbnN0YW5jZS4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG5cbiAgcmV0dXJuIGdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpIHtcbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlci5yZXR1cm47XG5cbiAgd2hpbGUgKGh5ZHJhdGlvblBhcmVudEZpYmVyKSB7XG4gICAgc3dpdGNoIChoeWRyYXRpb25QYXJlbnRGaWJlci50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICBjYXNlIEhvc3RTaW5nbGV0b246XG4gICAgICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGh5ZHJhdGlvblBhcmVudEZpYmVyLnJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wSHlkcmF0aW9uU3RhdGUoZmliZXIpIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmIChmaWJlciAhPT0gaHlkcmF0aW9uUGFyZW50RmliZXIpIHtcbiAgICAvLyBXZSdyZSBkZWVwZXIgdGhhbiB0aGUgY3VycmVudCBoeWRyYXRpb24gY29udGV4dCwgaW5zaWRlIGFuIGluc2VydGVkXG4gICAgLy8gdHJlZS5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgLy8gSWYgd2UncmUgbm90IGN1cnJlbnRseSBoeWRyYXRpbmcgYnV0IHdlJ3JlIGluIGEgaHlkcmF0aW9uIGNvbnRleHQsIHRoZW5cbiAgICAvLyB3ZSB3ZXJlIGFuIGluc2VydGlvbiBhbmQgbm93IG5lZWQgdG8gcG9wIHVwIHJlZW50ZXIgaHlkcmF0aW9uIG9mIG91clxuICAgIC8vIHNpYmxpbmdzLlxuICAgIHBvcFRvTmV4dEhvc3RQYXJlbnQoZmliZXIpO1xuICAgIGlzSHlkcmF0aW5nID0gdHJ1ZTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgc2hvdWxkQ2xlYXIgPSBmYWxzZTtcblxuICBpZiAoc3VwcG9ydHNTaW5nbGV0b25zKSB7XG4gICAgLy8gV2l0aCBmbG9hdCB3ZSBuZXZlciBjbGVhciB0aGUgUm9vdCwgb3IgU2luZ2xldG9uIGluc3RhbmNlcy4gV2UgYWxzbyBkbyBub3QgY2xlYXIgSW5zdGFuY2VzXG4gICAgLy8gdGhhdCBoYXZlIHNpbmdsZXRvbiB0ZXh0IGNvbnRlbnRcbiAgICBpZiAoZmliZXIudGFnICE9PSBIb3N0Um9vdCAmJiBmaWJlci50YWcgIT09IEhvc3RTaW5nbGV0b24gJiYgIShmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQgJiYgKCFzaG91bGREZWxldGVVbmh5ZHJhdGVkVGFpbEluc3RhbmNlcyhmaWJlci50eXBlKSB8fCBzaG91bGRTZXRUZXh0Q29udGVudChmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzKSkpKSB7XG4gICAgICBzaG91bGRDbGVhciA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElmIHdlIGhhdmUgYW55IHJlbWFpbmluZyBoeWRyYXRhYmxlIG5vZGVzLCB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGVtIG5vdy5cbiAgICAvLyBXZSBvbmx5IGRvIHRoaXMgZGVlcGVyIHRoYW4gaGVhZCBhbmQgYm9keSBzaW5jZSB0aGV5IHRlbmQgdG8gaGF2ZSByYW5kb21cbiAgICAvLyBvdGhlciBub2RlcyBpbiB0aGVtLiBXZSBhbHNvIGlnbm9yZSBjb21wb25lbnRzIHdpdGggcHVyZSB0ZXh0IGNvbnRlbnQgaW5cbiAgICAvLyBzaWRlIG9mIHRoZW0uIFdlIGFsc28gZG9uJ3QgZGVsZXRlIGFueXRoaW5nIGluc2lkZSB0aGUgcm9vdCBjb250YWluZXIuXG4gICAgaWYgKGZpYmVyLnRhZyAhPT0gSG9zdFJvb3QgJiYgKGZpYmVyLnRhZyAhPT0gSG9zdENvbXBvbmVudCB8fCBzaG91bGREZWxldGVVbmh5ZHJhdGVkVGFpbEluc3RhbmNlcyhmaWJlci50eXBlKSAmJiAhc2hvdWxkU2V0VGV4dENvbnRlbnQoZmliZXIudHlwZSwgZmliZXIubWVtb2l6ZWRQcm9wcykpKSB7XG4gICAgICBzaG91bGRDbGVhciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKHNob3VsZENsZWFyKSB7XG4gICAgdmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG5cbiAgICBpZiAobmV4dEluc3RhbmNlKSB7XG4gICAgICB3YXJuSWZVbmh5ZHJhdGVkVGFpbE5vZGVzKGZpYmVyKTtcbiAgICAgIHRocm93T25IeWRyYXRpb25NaXNtYXRjaChmaWJlcik7XG4gICAgfVxuICB9XG5cbiAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG5cbiAgaWYgKGZpYmVyLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gc2tpcFBhc3REZWh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShmaWJlcik7XG4gIH0gZWxzZSB7XG4gICAgbmV4dEh5ZHJhdGFibGVJbnN0YW5jZSA9IGh5ZHJhdGlvblBhcmVudEZpYmVyID8gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKGZpYmVyLnN0YXRlTm9kZSkgOiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlVuaHlkcmF0ZWRUYWlsTm9kZXMoZmliZXIpIHtcbiAge1xuICAgIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuXG4gICAgd2hpbGUgKG5leHRJbnN0YW5jZSkge1xuICAgICAgdmFyIGRpZmZOb2RlID0gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShmaWJlciwgMCk7XG4gICAgICB2YXIgZGVzY3JpcHRpb24gPSBkZXNjcmliZUh5ZHJhdGFibGVJbnN0YW5jZUZvckRldldhcm5pbmdzKG5leHRJbnN0YW5jZSk7XG4gICAgICBkaWZmTm9kZS5zZXJ2ZXJUYWlsLnB1c2goZGVzY3JpcHRpb24pO1xuXG4gICAgICBpZiAoZGVzY3JpcHRpb24udHlwZSA9PT0gJ1N1c3BlbnNlJykge1xuICAgICAgICB2YXIgc3VzcGVuc2VJbnN0YW5jZSA9IG5leHRJbnN0YW5jZTtcbiAgICAgICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHRJbnN0YW5jZSA9IGdldE5leHRIeWRyYXRhYmxlU2libGluZyhuZXh0SW5zdGFuY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldEh5ZHJhdGlvblN0YXRlKCkge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xuICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gbnVsbDtcbiAgaXNIeWRyYXRpbmcgPSBmYWxzZTtcbiAgZGlkU3VzcGVuZE9yRXJyb3JERVYgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gdXBncmFkZUh5ZHJhdGlvbkVycm9yc1RvUmVjb3ZlcmFibGUoKSB7XG4gIGlmIChoeWRyYXRpb25FcnJvcnMgIT09IG51bGwpIHtcbiAgICAvLyBTdWNjZXNzZnVsbHkgY29tcGxldGVkIGEgZm9yY2VkIGNsaWVudCByZW5kZXIuIFRoZSBlcnJvcnMgdGhhdCBvY2N1cnJlZFxuICAgIC8vIGR1cmluZyB0aGUgaHlkcmF0aW9uIGF0dGVtcHQgYXJlIG5vdyByZWNvdmVyZWQuIFdlIHdpbGwgbG9nIHRoZW0gaW5cbiAgICAvLyBjb21taXQgcGhhc2UsIG9uY2UgdGhlIGVudGlyZSB0cmVlIGhhcyBmaW5pc2hlZC5cbiAgICBxdWV1ZVJlY292ZXJhYmxlRXJyb3JzKGh5ZHJhdGlvbkVycm9ycyk7XG4gICAgaHlkcmF0aW9uRXJyb3JzID0gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRJc0h5ZHJhdGluZygpIHtcbiAgcmV0dXJuIGlzSHlkcmF0aW5nO1xufVxuXG5mdW5jdGlvbiBxdWV1ZUh5ZHJhdGlvbkVycm9yKGVycm9yKSB7XG4gIGlmIChoeWRyYXRpb25FcnJvcnMgPT09IG51bGwpIHtcbiAgICBoeWRyYXRpb25FcnJvcnMgPSBbZXJyb3JdO1xuICB9IGVsc2Uge1xuICAgIGh5ZHJhdGlvbkVycm9ycy5wdXNoKGVycm9yKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdFBlbmRpbmdIeWRyYXRpb25XYXJuaW5ncygpIHtcbiAge1xuICAgIC8vIElmIHdlIGhhdmVuJ3QgeWV0IHRocm93biBhbnkgaHlkcmF0aW9uIGVycm9ycyBieSB0aGUgdGltZSB3ZSByZWFjaCB0aGUgZW5kIHdlJ3ZlIHN1Y2Nlc3NmdWxseVxuICAgIC8vIGh5ZHJhdGVkLCBob3dldmVyLCB3ZSBtaWdodCBzdGlsbCBoYXZlIERFVi1vbmx5IG1pc21hdGNoZXMgdGhhdCB3ZSBsb2cgbm93LlxuICAgIHZhciBkaWZmUm9vdCA9IGh5ZHJhdGlvbkRpZmZSb290REVWO1xuXG4gICAgaWYgKGRpZmZSb290ICE9PSBudWxsKSB7XG4gICAgICBoeWRyYXRpb25EaWZmUm9vdERFViA9IG51bGw7XG4gICAgICB2YXIgZGlmZiA9IGRlc2NyaWJlRGlmZihkaWZmUm9vdCk7XG5cbiAgICAgIGVycm9yKFwiQSB0cmVlIGh5ZHJhdGVkIGJ1dCBzb21lIGF0dHJpYnV0ZXMgb2YgdGhlIHNlcnZlciByZW5kZXJlZCBIVE1MIGRpZG4ndCBtYXRjaCB0aGUgY2xpZW50IHByb3BlcnRpZXMuIFRoaXMgd29uJ3QgYmUgcGF0Y2hlZCB1cC4gXCIgKyAnVGhpcyBjYW4gaGFwcGVuIGlmIGEgU1NSLWVkIENsaWVudCBDb21wb25lbnQgdXNlZDpcXG4nICsgJ1xcbicgKyBcIi0gQSBzZXJ2ZXIvY2xpZW50IGJyYW5jaCBgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKWAuXFxuXCIgKyBcIi0gVmFyaWFibGUgaW5wdXQgc3VjaCBhcyBgRGF0ZS5ub3coKWAgb3IgYE1hdGgucmFuZG9tKClgIHdoaWNoIGNoYW5nZXMgZWFjaCB0aW1lIGl0J3MgY2FsbGVkLlxcblwiICsgXCItIERhdGUgZm9ybWF0dGluZyBpbiBhIHVzZXIncyBsb2NhbGUgd2hpY2ggZG9lc24ndCBtYXRjaCB0aGUgc2VydmVyLlxcblwiICsgJy0gRXh0ZXJuYWwgY2hhbmdpbmcgZGF0YSB3aXRob3V0IHNlbmRpbmcgYSBzbmFwc2hvdCBvZiBpdCBhbG9uZyB3aXRoIHRoZSBIVE1MLlxcbicgKyAnLSBJbnZhbGlkIEhUTUwgdGFnIG5lc3RpbmcuXFxuJyArICdcXG4nICsgJ0l0IGNhbiBhbHNvIGhhcHBlbiBpZiB0aGUgY2xpZW50IGhhcyBhIGJyb3dzZXIgZXh0ZW5zaW9uIGluc3RhbGxlZCB3aGljaCBtZXNzZXMgd2l0aCB0aGUgSFRNTCBiZWZvcmUgUmVhY3QgbG9hZGVkLlxcbicgKyAnXFxuJyArICclcyVzJywgJ2h0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaHlkcmF0aW9uLW1pc21hdGNoJywgZGlmZik7XG4gICAgfVxuICB9XG59XG5cbi8vIHdlIHdhaXQgdW50aWwgdGhlIGN1cnJlbnQgcmVuZGVyIGlzIG92ZXIgKGVpdGhlciBmaW5pc2hlZCBvciBpbnRlcnJ1cHRlZClcbi8vIGJlZm9yZSBhZGRpbmcgaXQgdG8gdGhlIGZpYmVyL2hvb2sgcXVldWUuIFB1c2ggdG8gdGhpcyBhcnJheSBzbyB3ZSBjYW5cbi8vIGFjY2VzcyB0aGUgcXVldWUsIGZpYmVyLCB1cGRhdGUsIGV0IGFsIGxhdGVyLlxuXG52YXIgY29uY3VycmVudFF1ZXVlcyA9IFtdO1xudmFyIGNvbmN1cnJlbnRRdWV1ZXNJbmRleCA9IDA7XG52YXIgY29uY3VycmVudGx5VXBkYXRlZExhbmVzID0gTm9MYW5lcztcbmZ1bmN0aW9uIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKSB7XG4gIHZhciBlbmRJbmRleCA9IGNvbmN1cnJlbnRRdWV1ZXNJbmRleDtcbiAgY29uY3VycmVudFF1ZXVlc0luZGV4ID0gMDtcbiAgY29uY3VycmVudGx5VXBkYXRlZExhbmVzID0gTm9MYW5lcztcbiAgdmFyIGkgPSAwO1xuXG4gIHdoaWxlIChpIDwgZW5kSW5kZXgpIHtcbiAgICB2YXIgZmliZXIgPSBjb25jdXJyZW50UXVldWVzW2ldO1xuICAgIGNvbmN1cnJlbnRRdWV1ZXNbaSsrXSA9IG51bGw7XG4gICAgdmFyIHF1ZXVlID0gY29uY3VycmVudFF1ZXVlc1tpXTtcbiAgICBjb25jdXJyZW50UXVldWVzW2krK10gPSBudWxsO1xuICAgIHZhciB1cGRhdGUgPSBjb25jdXJyZW50UXVldWVzW2ldO1xuICAgIGNvbmN1cnJlbnRRdWV1ZXNbaSsrXSA9IG51bGw7XG4gICAgdmFyIGxhbmUgPSBjb25jdXJyZW50UXVldWVzW2ldO1xuICAgIGNvbmN1cnJlbnRRdWV1ZXNbaSsrXSA9IG51bGw7XG5cbiAgICBpZiAocXVldWUgIT09IG51bGwgJiYgdXBkYXRlICE9PSBudWxsKSB7XG4gICAgICB2YXIgcGVuZGluZyA9IHF1ZXVlLnBlbmRpbmc7XG5cbiAgICAgIGlmIChwZW5kaW5nID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbiAgICAgICAgdXBkYXRlLm5leHQgPSB1cGRhdGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dDtcbiAgICAgICAgcGVuZGluZy5uZXh0ID0gdXBkYXRlO1xuICAgICAgfVxuXG4gICAgICBxdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICAgIH1cblxuICAgIGlmIChsYW5lICE9PSBOb0xhbmUpIHtcbiAgICAgIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KGZpYmVyLCB1cGRhdGUsIGxhbmUpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0Q29uY3VycmVudGx5VXBkYXRlZExhbmVzKCkge1xuICByZXR1cm4gY29uY3VycmVudGx5VXBkYXRlZExhbmVzO1xufVxuXG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpIHtcbiAgLy8gRG9uJ3QgdXBkYXRlIHRoZSBgY2hpbGRMYW5lc2Agb24gdGhlIHJldHVybiBwYXRoIHlldC4gSWYgd2UgYWxyZWFkeSBpblxuICAvLyB0aGUgbWlkZGxlIG9mIHJlbmRlcmluZywgd2FpdCB1bnRpbCBhZnRlciBpdCBoYXMgY29tcGxldGVkLlxuICBjb25jdXJyZW50UXVldWVzW2NvbmN1cnJlbnRRdWV1ZXNJbmRleCsrXSA9IGZpYmVyO1xuICBjb25jdXJyZW50UXVldWVzW2NvbmN1cnJlbnRRdWV1ZXNJbmRleCsrXSA9IHF1ZXVlO1xuICBjb25jdXJyZW50UXVldWVzW2NvbmN1cnJlbnRRdWV1ZXNJbmRleCsrXSA9IHVwZGF0ZTtcbiAgY29uY3VycmVudFF1ZXVlc1tjb25jdXJyZW50UXVldWVzSW5kZXgrK10gPSBsYW5lO1xuICBjb25jdXJyZW50bHlVcGRhdGVkTGFuZXMgPSBtZXJnZUxhbmVzKGNvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcywgbGFuZSk7IC8vIFRoZSBmaWJlcidzIGBsYW5lYCBmaWVsZCBpcyB1c2VkIGluIHNvbWUgcGxhY2VzIHRvIGNoZWNrIGlmIGFueSB3b3JrIGlzXG4gIC8vIHNjaGVkdWxlZCwgdG8gcGVyZm9ybSBhbiBlYWdlciBiYWlsb3V0LCBzbyB3ZSBuZWVkIHRvIHVwZGF0ZSBpdCBpbW1lZGlhdGVseS5cbiAgLy8gVE9ETzogV2Ugc2hvdWxkIHByb2JhYmx5IG1vdmUgdGhpcyB0byB0aGUgXCJzaGFyZWRcIiBxdWV1ZSBpbnN0ZWFkLlxuXG4gIGZpYmVyLmxhbmVzID0gbWVyZ2VMYW5lcyhmaWJlci5sYW5lcywgbGFuZSk7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgIGFsdGVybmF0ZS5sYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmxhbmVzLCBsYW5lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIGxhbmUpIHtcbiAgdmFyIGNvbmN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICB2YXIgY29uY3VycmVudFVwZGF0ZSA9IHVwZGF0ZTtcbiAgZW5xdWV1ZVVwZGF0ZSQxKGZpYmVyLCBjb25jdXJyZW50UXVldWUsIGNvbmN1cnJlbnRVcGRhdGUsIGxhbmUpO1xuICByZXR1cm4gZ2V0Um9vdEZvclVwZGF0ZWRGaWJlcihmaWJlcik7XG59XG5mdW5jdGlvbiBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGVBbmRFYWdlcmx5QmFpbG91dChmaWJlciwgcXVldWUsIHVwZGF0ZSkge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcXVldWUgYW4gdXBkYXRlIHRoYXQgZG9lc24ndCBuZWVkIGEgcmVyZW5kZXIuIFRoZVxuICAvLyBvbmx5IHJlYXNvbiB3ZSBxdWV1ZSBpdCBpcyBpbiBjYXNlIHRoZXJlJ3MgYSBzdWJzZXF1ZW50IGhpZ2hlciBwcmlvcml0eVxuICAvLyB1cGRhdGUgdGhhdCBjYXVzZXMgaXQgdG8gYmUgcmViYXNlZC5cbiAgdmFyIGxhbmUgPSBOb0xhbmU7XG4gIHZhciBjb25jdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgdmFyIGNvbmN1cnJlbnRVcGRhdGUgPSB1cGRhdGU7XG4gIGVucXVldWVVcGRhdGUkMShmaWJlciwgY29uY3VycmVudFF1ZXVlLCBjb25jdXJyZW50VXBkYXRlLCBsYW5lKTsgLy8gVXN1YWxseSB3ZSBjYW4gcmVseSBvbiB0aGUgdXBjb21pbmcgcmVuZGVyIHBoYXNlIHRvIHByb2Nlc3MgdGhlIGNvbmN1cnJlbnRcbiAgLy8gcXVldWUuIEhvd2V2ZXIsIHNpbmNlIHRoaXMgaXMgYSBiYWlsIG91dCwgd2UncmUgbm90IHNjaGVkdWxpbmcgYW55IHdvcmtcbiAgLy8gaGVyZS4gU28gdGhlIHVwZGF0ZSB3ZSBqdXN0IHF1ZXVlZCB3aWxsIGxlYWsgdW50aWwgc29tZXRoaW5nIGVsc2UgaGFwcGVuc1xuICAvLyB0byBzY2hlZHVsZSB3b3JrIChpZiBldmVyKS5cbiAgLy9cbiAgLy8gQ2hlY2sgaWYgd2UncmUgY3VycmVudGx5IGluIHRoZSBtaWRkbGUgb2YgcmVuZGVyaW5nIGEgdHJlZSwgYW5kIGlmIG5vdCxcbiAgLy8gcHJvY2VzcyB0aGUgcXVldWUgaW1tZWRpYXRlbHkgdG8gcHJldmVudCBhIGxlYWsuXG5cbiAgdmFyIGlzQ29uY3VycmVudGx5UmVuZGVyaW5nID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCkgIT09IG51bGw7XG5cbiAgaWYgKCFpc0NvbmN1cnJlbnRseVJlbmRlcmluZykge1xuICAgIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKTtcbiAgfVxufVxuZnVuY3Rpb24gZW5xdWV1ZUNvbmN1cnJlbnRDbGFzc1VwZGF0ZShmaWJlciwgcXVldWUsIHVwZGF0ZSwgbGFuZSkge1xuICB2YXIgY29uY3VycmVudFF1ZXVlID0gcXVldWU7XG4gIHZhciBjb25jdXJyZW50VXBkYXRlID0gdXBkYXRlO1xuICBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIGNvbmN1cnJlbnRRdWV1ZSwgY29uY3VycmVudFVwZGF0ZSwgbGFuZSk7XG4gIHJldHVybiBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKGZpYmVyKTtcbn1cbmZ1bmN0aW9uIGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgbGFuZSkge1xuICBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIG51bGwsIG51bGwsIGxhbmUpO1xuICByZXR1cm4gZ2V0Um9vdEZvclVwZGF0ZWRGaWJlcihmaWJlcik7XG59IC8vIENhbGxpbmcgdGhpcyBmdW5jdGlvbiBvdXRzaWRlIHRoaXMgbW9kdWxlIHNob3VsZCBvbmx5IGJlIGRvbmUgZm9yIGJhY2t3YXJkc1xuLy8gY29tcGF0aWJpbGl0eSBhbmQgc2hvdWxkIGFsd2F5cyBiZSBhY2NvbXBhbmllZCBieSBhIHdhcm5pbmcuXG5cbmZ1bmN0aW9uIHVuc2FmZV9tYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChzb3VyY2VGaWJlciwgbGFuZSkge1xuICAvLyBOT1RFOiBGb3IgSHlydW0ncyBMYXcgcmVhc29ucywgaWYgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AgaXMgZGV0ZWN0ZWQsIGl0XG4gIC8vIHNob3VsZCB0aHJvdyBiZWZvcmUgYG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290YCBpcyBjYWxsZWQuIEJ1dCB0aGlzIGlzXG4gIC8vIHVuZGVmaW5lZCBiZWhhdmlvciBhbmQgd2UgY2FuIGNoYW5nZSBpdCBpZiB3ZSBuZWVkIHRvOyBpdCBqdXN0IHNvIGhhcHBlbnNcbiAgLy8gdGhhdCwgYXQgdGhlIHRpbWUgb2YgdGhpcyB3cml0aW5nLCB0aGVyZSdzIGFuIGludGVybmFsIHByb2R1Y3QgdGVzdCB0aGF0XG4gIC8vIGhhcHBlbnMgdG8gcmVseSBvbiB0aGlzLlxuICB2YXIgcm9vdCA9IGdldFJvb3RGb3JVcGRhdGVkRmliZXIoc291cmNlRmliZXIpO1xuICBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChzb3VyY2VGaWJlciwgbnVsbCwgbGFuZSk7XG4gIHJldHVybiByb290O1xufVxuXG5mdW5jdGlvbiBtYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChzb3VyY2VGaWJlciwgdXBkYXRlLCBsYW5lKSB7XG4gIC8vIFVwZGF0ZSB0aGUgc291cmNlIGZpYmVyJ3MgbGFuZXNcbiAgc291cmNlRmliZXIubGFuZXMgPSBtZXJnZUxhbmVzKHNvdXJjZUZpYmVyLmxhbmVzLCBsYW5lKTtcbiAgdmFyIGFsdGVybmF0ZSA9IHNvdXJjZUZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgYWx0ZXJuYXRlLmxhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUubGFuZXMsIGxhbmUpO1xuICB9IC8vIFdhbGsgdGhlIHBhcmVudCBwYXRoIHRvIHRoZSByb290IGFuZCB1cGRhdGUgdGhlIGNoaWxkIGxhbmVzLlxuXG5cbiAgdmFyIGlzSGlkZGVuID0gZmFsc2U7XG4gIHZhciBwYXJlbnQgPSBzb3VyY2VGaWJlci5yZXR1cm47XG4gIHZhciBub2RlID0gc291cmNlRmliZXI7XG5cbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgIHBhcmVudC5jaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhwYXJlbnQuY2hpbGRMYW5lcywgbGFuZSk7XG4gICAgYWx0ZXJuYXRlID0gcGFyZW50LmFsdGVybmF0ZTtcblxuICAgIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgIGFsdGVybmF0ZS5jaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUuY2hpbGRMYW5lcywgbGFuZSk7XG4gICAgfVxuXG4gICAgaWYgKHBhcmVudC50YWcgPT09IE9mZnNjcmVlbkNvbXBvbmVudCkge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBvZmZzY3JlZW4gYm91bmRhcnkgaXMgY3VycmVudGx5IGhpZGRlbi5cbiAgICAgIC8vXG4gICAgICAvLyBUaGUgaW5zdGFuY2UgbWF5IGJlIG51bGwgaWYgdGhlIE9mZnNjcmVlbiBwYXJlbnQgd2FzIHVubW91bnRlZC4gVXN1YWxseVxuICAgICAgLy8gdGhlIHBhcmVudCB3b3VsZG4ndCBiZSByZWFjaGFibGUgaW4gdGhhdCBjYXNlIGJlY2F1c2Ugd2UgZGlzY29ubmVjdFxuICAgICAgLy8gZmliZXJzIGZyb20gdGhlIHRyZWUgd2hlbiB0aGV5IGFyZSBkZWxldGVkLiBIb3dldmVyLCB0aGVyZSdzIGEgd2VpcmRcbiAgICAgIC8vIGVkZ2UgY2FzZSB3aGVyZSBzZXRTdGF0ZSBpcyBjYWxsZWQgb24gYSBmaWJlciB0aGF0IHdhcyBpbnRlcnJ1cHRlZFxuICAgICAgLy8gYmVmb3JlIGl0IGV2ZXIgbW91bnRlZC4gQmVjYXVzZSBpdCBuZXZlciBtb3VudHMsIGl0IGFsc28gbmV2ZXIgZ2V0c1xuICAgICAgLy8gZGVsZXRlZC4gQmVjYXVzZSBpdCBuZXZlciBnZXRzIGRlbGV0ZWQsIGl0cyByZXR1cm4gcG9pbnRlciBuZXZlciBnZXRzXG4gICAgICAvLyBkaXNjb25uZWN0ZWQuIFdoaWNoIG1lYW5zIGl0IG1heSBiZSBhdHRhY2hlZCB0byBhIGRlbGV0ZWQgT2Zmc2NyZWVuXG4gICAgICAvLyBwYXJlbnQgbm9kZS4gKFRoaXMgZGlzY292ZXJ5IHN1Z2dlc3RzIGl0IG1heSBiZSBiZXR0ZXIgZm9yIG1lbW9yeSB1c2FnZVxuICAgICAgLy8gaWYgd2UgZG9uJ3QgYXR0YWNoIHRoZSBgcmV0dXJuYCBwb2ludGVyIHVudGlsIHRoZSBjb21taXQgcGhhc2UsIHRob3VnaFxuICAgICAgLy8gaW4gb3JkZXIgdG8gZG8gdGhhdCB3ZSdkIG5lZWQgc29tZSBvdGhlciB3YXkgdG8gdHJhY2sgdGhlIHJldHVyblxuICAgICAgLy8gcG9pbnRlciBkdXJpbmcgdGhlIGluaXRpYWwgcmVuZGVyLCBsaWtlIG9uIHRoZSBzdGFjay4pXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBjYXNlIGlzIGFsd2F5cyBhY2NvbXBhbmllZCBieSBhIHdhcm5pbmcsIGJ1dCB3ZSBzdGlsbCBuZWVkIHRvXG4gICAgICAvLyBhY2NvdW50IGZvciBpdC4gKFRoZXJlIG1heSBiZSBvdGhlciBjYXNlcyB0aGF0IHdlIGhhdmVuJ3QgZGlzY292ZXJlZCxcbiAgICAgIC8vIHRvby4pXG4gICAgICB2YXIgb2Zmc2NyZWVuSW5zdGFuY2UgPSBwYXJlbnQuc3RhdGVOb2RlO1xuXG4gICAgICBpZiAob2Zmc2NyZWVuSW5zdGFuY2UgIT09IG51bGwgJiYgIShvZmZzY3JlZW5JbnN0YW5jZS5fdmlzaWJpbGl0eSAmIE9mZnNjcmVlblZpc2libGUpKSB7XG4gICAgICAgIGlzSGlkZGVuID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlID0gcGFyZW50O1xuICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gIH1cblxuICBpZiAoaXNIaWRkZW4gJiYgdXBkYXRlICE9PSBudWxsICYmIG5vZGUudGFnID09PSBIb3N0Um9vdCkge1xuICAgIHZhciByb290ID0gbm9kZS5zdGF0ZU5vZGU7XG4gICAgbWFya0hpZGRlblVwZGF0ZShyb290LCB1cGRhdGUsIGxhbmUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFJvb3RGb3JVcGRhdGVkRmliZXIoc291cmNlRmliZXIpIHtcbiAgLy8gVE9ETzogV2Ugd2lsbCBkZXRlY3QgYW5kIGluZmluaXRlIHVwZGF0ZSBsb29wIGFuZCB0aHJvdyBldmVuIGlmIHRoaXMgZmliZXJcbiAgLy8gaGFzIGFscmVhZHkgdW5tb3VudGVkLiBUaGlzIGlzbid0IHJlYWxseSBuZWNlc3NhcnkgYnV0IGl0IGhhcHBlbnMgdG8gYmUgdGhlXG4gIC8vIGN1cnJlbnQgYmVoYXZpb3Igd2UndmUgdXNlZCBmb3Igc2V2ZXJhbCByZWxlYXNlIGN5Y2xlcy4gQ29uc2lkZXIgbm90XG4gIC8vIHBlcmZvcm1pbmcgdGhpcyBjaGVjayBpZiB0aGUgdXBkYXRlZCBmaWJlciBhbHJlYWR5IHVubW91bnRlZCwgc2luY2UgaXQnc1xuICAvLyBub3QgcG9zc2libGUgZm9yIHRoYXQgdG8gY2F1c2UgYW4gaW5maW5pdGUgdXBkYXRlIGxvb3AuXG4gIHRocm93SWZJbmZpbml0ZVVwZGF0ZUxvb3BEZXRlY3RlZCgpOyAvLyBXaGVuIGEgc2V0U3RhdGUgaGFwcGVucywgd2UgbXVzdCBlbnN1cmUgdGhlIHJvb3QgaXMgc2NoZWR1bGVkLiBCZWNhdXNlXG4gIC8vIHVwZGF0ZSBxdWV1ZXMgZG8gbm90IGhhdmUgYSBiYWNrcG9pbnRlciB0byB0aGUgcm9vdCwgdGhlIG9ubHkgd2F5IHRvIGRvXG4gIC8vIHRoaXMgY3VycmVudGx5IGlzIHRvIHdhbGsgdXAgdGhlIHJldHVybiBwYXRoLiBUaGlzIHVzZWQgdG8gbm90IGJlIGEgYmlnXG4gIC8vIGRlYWwgYmVjYXVzZSB3ZSB3b3VsZCBoYXZlIHRvIHdhbGsgdXAgdGhlIHJldHVybiBwYXRoIHRvIHNldFxuICAvLyB0aGUgYGNoaWxkTGFuZXNgLCBhbnl3YXksIGJ1dCBub3cgdGhvc2UgdHdvIHRyYXZlcnNhbHMgaGFwcGVuIGF0XG4gIC8vIGRpZmZlcmVudCB0aW1lcy5cbiAgLy8gVE9ETzogQ29uc2lkZXIgYWRkaW5nIGEgYHJvb3RgIGJhY2twb2ludGVyIG9uIHRoZSB1cGRhdGUgcXVldWUuXG5cbiAgZGV0ZWN0VXBkYXRlT25Vbm1vdW50ZWRGaWJlcihzb3VyY2VGaWJlciwgc291cmNlRmliZXIpO1xuICB2YXIgbm9kZSA9IHNvdXJjZUZpYmVyO1xuICB2YXIgcGFyZW50ID0gbm9kZS5yZXR1cm47XG5cbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgIGRldGVjdFVwZGF0ZU9uVW5tb3VudGVkRmliZXIoc291cmNlRmliZXIsIG5vZGUpO1xuICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgcGFyZW50ID0gbm9kZS5yZXR1cm47XG4gIH1cblxuICByZXR1cm4gbm9kZS50YWcgPT09IEhvc3RSb290ID8gbm9kZS5zdGF0ZU5vZGUgOiBudWxsO1xufVxuXG5mdW5jdGlvbiBkZXRlY3RVcGRhdGVPblVubW91bnRlZEZpYmVyKHNvdXJjZUZpYmVyLCBwYXJlbnQpIHtcbiAge1xuICAgIHZhciBhbHRlcm5hdGUgPSBwYXJlbnQuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGFsdGVybmF0ZSA9PT0gbnVsbCAmJiAocGFyZW50LmZsYWdzICYgKFBsYWNlbWVudCB8IEh5ZHJhdGluZykpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgIHdhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYoc291cmNlRmliZXIpO1xuICAgIH1cbiAgfVxufVxuXG4vLyB0aGVyZSdzIG9ubHkgYSBzaW5nbGUgcm9vdCwgYnV0IHdlIGRvIHN1cHBvcnQgbXVsdGkgcm9vdCBhcHBzLCBoZW5jZSB0aGlzXG4vLyBleHRyYSBjb21wbGV4aXR5LiBCdXQgdGhpcyBtb2R1bGUgaXMgb3B0aW1pemVkIGZvciB0aGUgc2luZ2xlIHJvb3QgY2FzZS5cblxudmFyIGZpcnN0U2NoZWR1bGVkUm9vdCA9IG51bGw7XG52YXIgbGFzdFNjaGVkdWxlZFJvb3QgPSBudWxsOyAvLyBVc2VkIHRvIHByZXZlbnQgcmVkdW5kYW50IG1pcmNvdGFza3MgZnJvbSBiZWluZyBzY2hlZHVsZWQuXG5cbnZhciBkaWRTY2hlZHVsZU1pY3JvdGFzayA9IGZhbHNlOyAvLyBgYWN0YCBcIm1pY3JvdGFza3NcIiBhcmUgc2NoZWR1bGVkIG9uIHRoZSBgYWN0YCBxdWV1ZSBpbnN0ZWFkIG9mIGFuIGFjdHVhbFxuLy8gbWljcm90YXNrLCBzbyB3ZSBoYXZlIHRvIGRlZHVwZSB0aG9zZSBzZXBhcmF0ZWx5LiBUaGlzIHdvdWxkbid0IGJlIGFuIGlzc3VlXG4vLyBpZiB3ZSByZXF1aXJlZCBhbGwgYGFjdGAgY2FsbHMgdG8gYmUgYXdhaXRlZCwgd2hpY2ggd2UgbWlnaHQgaW4gdGhlIGZ1dHVyZS5cblxudmFyIGRpZFNjaGVkdWxlTWljcm90YXNrX2FjdCA9IGZhbHNlOyAvLyBVc2VkIHRvIHF1aWNrbHkgYmFpbCBvdXQgb2YgZmx1c2hTeW5jIGlmIHRoZXJlJ3Mgbm8gc3luYyB3b3JrIHRvIGRvLlxuXG52YXIgbWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrID0gZmFsc2U7XG52YXIgaXNGbHVzaGluZ1dvcmsgPSBmYWxzZTtcbnZhciBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSA9IE5vTGFuZTtcbmZ1bmN0aW9uIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdoZW5ldmVyIGEgcm9vdCByZWNlaXZlcyBhbiB1cGRhdGUuIEl0IGRvZXMgdHdvXG4gIC8vIHRoaW5ncyAxKSBpdCBlbnN1cmVzIHRoZSByb290IGlzIGluIHRoZSByb290IHNjaGVkdWxlLCBhbmQgMikgaXQgZW5zdXJlc1xuICAvLyB0aGVyZSdzIGEgcGVuZGluZyBtaWNyb3Rhc2sgdG8gcHJvY2VzcyB0aGUgcm9vdCBzY2hlZHVsZS5cbiAgLy9cbiAgLy8gTW9zdCBvZiB0aGUgYWN0dWFsIHNjaGVkdWxpbmcgbG9naWMgZG9lcyBub3QgaGFwcGVuIHVudGlsXG4gIC8vIGBzY2hlZHVsZVRhc2tGb3JSb290RHVyaW5nTWljcm90YXNrYCBydW5zLlxuICAvLyBBZGQgdGhlIHJvb3QgdG8gdGhlIHNjaGVkdWxlXG4gIGlmIChyb290ID09PSBsYXN0U2NoZWR1bGVkUm9vdCB8fCByb290Lm5leHQgIT09IG51bGwpIDsgZWxzZSB7XG4gICAgaWYgKGxhc3RTY2hlZHVsZWRSb290ID09PSBudWxsKSB7XG4gICAgICBmaXJzdFNjaGVkdWxlZFJvb3QgPSBsYXN0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3RTY2hlZHVsZWRSb290Lm5leHQgPSByb290O1xuICAgICAgbGFzdFNjaGVkdWxlZFJvb3QgPSByb290O1xuICAgIH1cbiAgfSAvLyBBbnkgdGltZSBhIHJvb3QgcmVjZWl2ZWQgYW4gdXBkYXRlLCB3ZSBzZXQgdGhpcyB0byB0cnVlIHVudGlsIHRoZSBuZXh0IHRpbWVcbiAgLy8gd2UgcHJvY2VzcyB0aGUgc2NoZWR1bGUuIElmIGl0J3MgZmFsc2UsIHRoZW4gd2UgY2FuIHF1aWNrbHkgZXhpdCBmbHVzaFN5bmNcbiAgLy8gd2l0aG91dCBjb25zdWx0aW5nIHRoZSBzY2hlZHVsZS5cblxuXG4gIG1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yayA9IHRydWU7IC8vIEF0IHRoZSBlbmQgb2YgdGhlIGN1cnJlbnQgZXZlbnQsIGdvIHRocm91Z2ggZWFjaCBvZiB0aGUgcm9vdHMgYW5kIGVuc3VyZVxuICAvLyB0aGVyZSdzIGEgdGFzayBzY2hlZHVsZWQgZm9yIGVhY2ggb25lIGF0IHRoZSBjb3JyZWN0IHByaW9yaXR5LlxuXG4gIGlmIChSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSAhPT0gbnVsbCkge1xuICAgIC8vIFdlJ3JlIGluc2lkZSBhbiBgYWN0YCBzY29wZS5cbiAgICBpZiAoIWRpZFNjaGVkdWxlTWljcm90YXNrX2FjdCkge1xuICAgICAgZGlkU2NoZWR1bGVNaWNyb3Rhc2tfYWN0ID0gdHJ1ZTtcbiAgICAgIHNjaGVkdWxlSW1tZWRpYXRlVGFzayhwcm9jZXNzUm9vdFNjaGVkdWxlSW5NaWNyb3Rhc2spO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoIWRpZFNjaGVkdWxlTWljcm90YXNrKSB7XG4gICAgICBkaWRTY2hlZHVsZU1pY3JvdGFzayA9IHRydWU7XG4gICAgICBzY2hlZHVsZUltbWVkaWF0ZVRhc2socHJvY2Vzc1Jvb3RTY2hlZHVsZUluTWljcm90YXNrKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGZsdXNoU3luY1dvcmtPbkFsbFJvb3RzKCkge1xuICAvLyBUaGlzIGlzIGFsbG93ZWQgdG8gYmUgY2FsbGVkIHN5bmNocm9ub3VzbHksIGJ1dCB0aGUgY2FsbGVyIHNob3VsZCBjaGVja1xuICAvLyB0aGUgZXhlY3V0aW9uIGNvbnRleHQgZmlyc3QuXG4gIGZsdXNoU3luY1dvcmtBY3Jvc3NSb290c19pbXBsKGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwob25seUxlZ2FjeSkge1xuICBpZiAoaXNGbHVzaGluZ1dvcmspIHtcbiAgICAvLyBQcmV2ZW50IHJlZW50cmFuY3kuXG4gICAgLy8gVE9ETzogSXMgdGhpcyBvdmVybHkgZGVmZW5zaXZlPyBUaGUgY2FsbGVycyBtdXN0IGNoZWNrIHRoZSBleGVjdXRpb25cbiAgICAvLyBjb250ZXh0IGZpcnN0IHJlZ2FyZGxlc3MuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKCFtaWdodEhhdmVQZW5kaW5nU3luY1dvcmspIHtcbiAgICAvLyBGYXN0IHBhdGguIFRoZXJlJ3Mgbm8gc3luYyB3b3JrIHRvIGRvLlxuICAgIHJldHVybjtcbiAgfSAvLyBUaGVyZSBtYXkgb3IgbWF5IG5vdCBiZSBzeW5jaHJvbm91cyB3b3JrIHNjaGVkdWxlZC4gTGV0J3MgY2hlY2suXG5cblxuICB2YXIgZGlkUGVyZm9ybVNvbWVXb3JrO1xuICBpc0ZsdXNoaW5nV29yayA9IHRydWU7XG5cbiAgZG8ge1xuICAgIGRpZFBlcmZvcm1Tb21lV29yayA9IGZhbHNlO1xuICAgIHZhciByb290ID0gZmlyc3RTY2hlZHVsZWRSb290O1xuXG4gICAgd2hpbGUgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIGlmIChvbmx5TGVnYWN5ICYmIChkaXNhYmxlTGVnYWN5TW9kZSApKSA7IGVsc2Uge1xuICAgICAgICB2YXIgd29ya0luUHJvZ3Jlc3NSb290ID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCk7XG4gICAgICAgIHZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IGdldFdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKCk7XG4gICAgICAgIHZhciBuZXh0TGFuZXMgPSBnZXROZXh0TGFuZXMocm9vdCwgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ID8gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgOiBOb0xhbmVzKTtcblxuICAgICAgICBpZiAoaW5jbHVkZXNTeW5jTGFuZShuZXh0TGFuZXMpKSB7XG4gICAgICAgICAgLy8gVGhpcyByb290IGhhcyBwZW5kaW5nIHN5bmMgd29yay4gRmx1c2ggaXQgbm93LlxuICAgICAgICAgIGRpZFBlcmZvcm1Tb21lV29yayA9IHRydWU7XG4gICAgICAgICAgcGVyZm9ybVN5bmNXb3JrT25Sb290KHJvb3QsIG5leHRMYW5lcyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcm9vdCA9IHJvb3QubmV4dDtcbiAgICB9XG4gIH0gd2hpbGUgKGRpZFBlcmZvcm1Tb21lV29yayk7XG5cbiAgaXNGbHVzaGluZ1dvcmsgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Jvb3RTY2hlZHVsZUluTWljcm90YXNrKCkge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGFsd2F5cyBjYWxsZWQgaW5zaWRlIGEgbWljcm90YXNrLiBJdCBzaG91bGQgbmV2ZXIgYmVcbiAgLy8gY2FsbGVkIHN5bmNocm9ub3VzbHkuXG4gIGRpZFNjaGVkdWxlTWljcm90YXNrID0gZmFsc2U7XG5cbiAge1xuICAgIGRpZFNjaGVkdWxlTWljcm90YXNrX2FjdCA9IGZhbHNlO1xuICB9IC8vIFdlJ2xsIHJlY29tcHV0ZSB0aGlzIGFzIHdlIGl0ZXJhdGUgdGhyb3VnaCBhbGwgdGhlIHJvb3RzIGFuZCBzY2hlZHVsZSB0aGVtLlxuXG5cbiAgbWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrID0gZmFsc2U7XG4gIHZhciBjdXJyZW50VGltZSA9IG5vdyQxKCk7XG4gIHZhciBwcmV2ID0gbnVsbDtcbiAgdmFyIHJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG5cbiAgd2hpbGUgKHJvb3QgIT09IG51bGwpIHtcbiAgICB2YXIgbmV4dCA9IHJvb3QubmV4dDtcblxuICAgIGlmIChjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSAhPT0gTm9MYW5lICYmIHNob3VsZEF0dGVtcHRFYWdlclRyYW5zaXRpb24oKSkge1xuICAgICAgLy8gQSB0cmFuc2l0aW9uIHdhcyBzY2hlZHVsZWQgZHVyaW5nIGFuIGV2ZW50LCBidXQgd2UncmUgZ29pbmcgdG8gdHJ5IHRvXG4gICAgICAvLyByZW5kZXIgaXQgc3luY2hyb25vdXNseSBhbnl3YXkuIFdlIGRvIHRoaXMgZHVyaW5nIGEgcG9wc3RhdGUgZXZlbnQgdG9cbiAgICAgIC8vIHByZXNlcnZlIHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIHByZXZpb3VzIHBhZ2UuXG4gICAgICB1cGdyYWRlUGVuZGluZ0xhbmVUb1N5bmMocm9vdCwgY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUpO1xuICAgIH1cblxuICAgIHZhciBuZXh0TGFuZXMgPSBzY2hlZHVsZVRhc2tGb3JSb290RHVyaW5nTWljcm90YXNrKHJvb3QsIGN1cnJlbnRUaW1lKTtcblxuICAgIGlmIChuZXh0TGFuZXMgPT09IE5vTGFuZSkge1xuICAgICAgLy8gVGhpcyByb290IGhhcyBubyBtb3JlIHBlbmRpbmcgd29yay4gUmVtb3ZlIGl0IGZyb20gdGhlIHNjaGVkdWxlLiBUb1xuICAgICAgLy8gZ3VhcmQgYWdhaW5zdCBzdWJ0bGUgcmVlbnRyYW5jeSBidWdzLCB0aGlzIG1pY3JvdGFzayBpcyB0aGUgb25seSBwbGFjZVxuICAgICAgLy8gd2UgZG8gdGhpcyDigJQgeW91IGNhbiBhZGQgcm9vdHMgdG8gdGhlIHNjaGVkdWxlIHdoZW5ldmVyLCBidXQgeW91IGNhblxuICAgICAgLy8gb25seSByZW1vdmUgdGhlbSBoZXJlLlxuICAgICAgLy8gTnVsbCB0aGlzIG91dCBzbyB3ZSBrbm93IGl0J3MgYmVlbiByZW1vdmVkIGZyb20gdGhlIHNjaGVkdWxlLlxuICAgICAgcm9vdC5uZXh0ID0gbnVsbDtcblxuICAgICAgaWYgKHByZXYgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgbmV3IGhlYWQgb2YgdGhlIGxpc3RcbiAgICAgICAgZmlyc3RTY2hlZHVsZWRSb290ID0gbmV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByZXYubmV4dCA9IG5leHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIG5ldyB0YWlsIG9mIHRoZSBsaXN0XG4gICAgICAgIGxhc3RTY2hlZHVsZWRSb290ID0gcHJldjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyByb290IHN0aWxsIGhhcyB3b3JrLiBLZWVwIGl0IGluIHRoZSBsaXN0LlxuICAgICAgcHJldiA9IHJvb3Q7XG5cbiAgICAgIGlmIChpbmNsdWRlc1N5bmNMYW5lKG5leHRMYW5lcykpIHtcbiAgICAgICAgbWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByb290ID0gbmV4dDtcbiAgfVxuXG4gIGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lID0gTm9MYW5lOyAvLyBBdCB0aGUgZW5kIG9mIHRoZSBtaWNyb3Rhc2ssIGZsdXNoIGFueSBwZW5kaW5nIHN5bmNocm9ub3VzIHdvcmsuIFRoaXMgaGFzXG4gIC8vIHRvIGNvbWUgYXQgdGhlIGVuZCwgYmVjYXVzZSBpdCBkb2VzIGFjdHVhbCByZW5kZXJpbmcgd29yayB0aGF0IG1pZ2h0IHRocm93LlxuXG4gIGZsdXNoU3luY1dvcmtPbkFsbFJvb3RzKCk7XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlVGFza0ZvclJvb3REdXJpbmdNaWNyb3Rhc2socm9vdCwgY3VycmVudFRpbWUpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyBhbHdheXMgY2FsbGVkIGluc2lkZSBhIG1pY3JvdGFzaywgb3IgYXQgdGhlIHZlcnkgZW5kIG9mIGFcbiAgLy8gcmVuZGVyaW5nIHRhc2sgcmlnaHQgYmVmb3JlIHdlIHlpZWxkIHRvIHRoZSBtYWluIHRocmVhZC4gSXQgc2hvdWxkIG5ldmVyIGJlXG4gIC8vIGNhbGxlZCBzeW5jaHJvbm91c2x5LlxuICAvL1xuICAvLyBUT0RPOiBVbmxlc3MgZW5hYmxlRGVmZXJSb290U2NoZWR1bGluZ1RvTWljcm90YXNrIGlzIG9mZi4gV2UgbmVlZCB0byBsYW5kXG4gIC8vIHRoYXQgQVNBUCB0byB1bmJsb2NrIGFkZGl0aW9uYWwgZmVhdHVyZXMgd2UgaGF2ZSBwbGFubmVkLlxuICAvL1xuICAvLyBUaGlzIGZ1bmN0aW9uIGFsc28gbmV2ZXIgcGVyZm9ybXMgUmVhY3Qgd29yayBzeW5jaHJvbm91c2x5OyBpdCBzaG91bGRcbiAgLy8gb25seSBzY2hlZHVsZSB3b3JrIHRvIGJlIHBlcmZvcm1lZCBsYXRlciwgaW4gYSBzZXBhcmF0ZSB0YXNrIG9yIG1pY3JvdGFzay5cbiAgLy8gQ2hlY2sgaWYgYW55IGxhbmVzIGFyZSBiZWluZyBzdGFydmVkIGJ5IG90aGVyIHdvcmsuIElmIHNvLCBtYXJrIHRoZW0gYXNcbiAgLy8gZXhwaXJlZCBzbyB3ZSBrbm93IHRvIHdvcmsgb24gdGhvc2UgbmV4dC5cbiAgbWFya1N0YXJ2ZWRMYW5lc0FzRXhwaXJlZChyb290LCBjdXJyZW50VGltZSk7IC8vIERldGVybWluZSB0aGUgbmV4dCBsYW5lcyB0byB3b3JrIG9uLCBhbmQgdGhlaXIgcHJpb3JpdHkuXG5cbiAgdmFyIHdvcmtJblByb2dyZXNzUm9vdCA9IGdldFdvcmtJblByb2dyZXNzUm9vdCgpO1xuICB2YXIgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcygpO1xuICB2YXIgbmV4dExhbmVzID0gZ2V0TmV4dExhbmVzKHJvb3QsIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCA/IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzIDogTm9MYW5lcyk7XG4gIHZhciBleGlzdGluZ0NhbGxiYWNrTm9kZSA9IHJvb3QuY2FsbGJhY2tOb2RlO1xuXG4gIGlmICggLy8gQ2hlY2sgaWYgdGhlcmUncyBub3RoaW5nIHRvIHdvcmsgb25cbiAgbmV4dExhbmVzID09PSBOb0xhbmVzIHx8IC8vIElmIHRoaXMgcm9vdCBpcyBjdXJyZW50bHkgc3VzcGVuZGVkIGFuZCB3YWl0aW5nIGZvciBkYXRhIHRvIHJlc29sdmUsIGRvbid0XG4gIC8vIHNjaGVkdWxlIGEgdGFzayB0byByZW5kZXIgaXQuIFdlJ2xsIGVpdGhlciB3YWl0IGZvciBhIHBpbmcsIG9yIHdhaXQgdG9cbiAgLy8gcmVjZWl2ZSBhbiB1cGRhdGUuXG4gIC8vXG4gIC8vIFN1c3BlbmRlZCByZW5kZXIgcGhhc2VcbiAgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ICYmIGlzV29ya0xvb3BTdXNwZW5kZWRPbkRhdGEoKSB8fCAvLyBTdXNwZW5kZWQgY29tbWl0IHBoYXNlXG4gIHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdCAhPT0gbnVsbCkge1xuICAgIC8vIEZhc3QgcGF0aDogVGhlcmUncyBub3RoaW5nIHRvIHdvcmsgb24uXG4gICAgaWYgKGV4aXN0aW5nQ2FsbGJhY2tOb2RlICE9PSBudWxsKSB7XG4gICAgICBjYW5jZWxDYWxsYmFjayhleGlzdGluZ0NhbGxiYWNrTm9kZSk7XG4gICAgfVxuXG4gICAgcm9vdC5jYWxsYmFja05vZGUgPSBudWxsO1xuICAgIHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IE5vTGFuZTtcbiAgICByZXR1cm4gTm9MYW5lO1xuICB9IC8vIFNjaGVkdWxlIGEgbmV3IGNhbGxiYWNrIGluIHRoZSBob3N0IGVudmlyb25tZW50LlxuXG5cbiAgaWYgKGluY2x1ZGVzU3luY0xhbmUobmV4dExhbmVzKSkge1xuICAgIC8vIFN5bmNocm9ub3VzIHdvcmsgaXMgYWx3YXlzIGZsdXNoZWQgYXQgdGhlIGVuZCBvZiB0aGUgbWljcm90YXNrLCBzbyB3ZVxuICAgIC8vIGRvbid0IG5lZWQgdG8gc2NoZWR1bGUgYW4gYWRkaXRpb25hbCB0YXNrLlxuICAgIGlmIChleGlzdGluZ0NhbGxiYWNrTm9kZSAhPT0gbnVsbCkge1xuICAgICAgY2FuY2VsQ2FsbGJhY2soZXhpc3RpbmdDYWxsYmFja05vZGUpO1xuICAgIH1cblxuICAgIHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IFN5bmNMYW5lO1xuICAgIHJvb3QuY2FsbGJhY2tOb2RlID0gbnVsbDtcbiAgICByZXR1cm4gU3luY0xhbmU7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgdXNlIHRoZSBoaWdoZXN0IHByaW9yaXR5IGxhbmUgdG8gcmVwcmVzZW50IHRoZSBwcmlvcml0eSBvZiB0aGUgY2FsbGJhY2suXG4gICAgdmFyIGV4aXN0aW5nQ2FsbGJhY2tQcmlvcml0eSA9IHJvb3QuY2FsbGJhY2tQcmlvcml0eTtcbiAgICB2YXIgbmV3Q2FsbGJhY2tQcmlvcml0eSA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmUobmV4dExhbmVzKTtcblxuICAgIGlmIChuZXdDYWxsYmFja1ByaW9yaXR5ID09PSBleGlzdGluZ0NhbGxiYWNrUHJpb3JpdHkgJiYgLy8gU3BlY2lhbCBjYXNlIHJlbGF0ZWQgdG8gYGFjdGAuIElmIHRoZSBjdXJyZW50bHkgc2NoZWR1bGVkIHRhc2sgaXMgYVxuICAgIC8vIFNjaGVkdWxlciB0YXNrLCByYXRoZXIgdGhhbiBhbiBgYWN0YCB0YXNrLCBjYW5jZWwgaXQgYW5kIHJlLXNjaGVkdWxlXG4gICAgLy8gb24gdGhlIGBhY3RgIHF1ZXVlLlxuICAgICEoUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgIT09IG51bGwgJiYgZXhpc3RpbmdDYWxsYmFja05vZGUgIT09IGZha2VBY3RDYWxsYmFja05vZGUkMSkpIHtcbiAgICAgIC8vIFRoZSBwcmlvcml0eSBoYXNuJ3QgY2hhbmdlZC4gV2UgY2FuIHJldXNlIHRoZSBleGlzdGluZyB0YXNrLlxuICAgICAgcmV0dXJuIG5ld0NhbGxiYWNrUHJpb3JpdHk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENhbmNlbCB0aGUgZXhpc3RpbmcgY2FsbGJhY2suIFdlJ2xsIHNjaGVkdWxlIGEgbmV3IG9uZSBiZWxvdy5cbiAgICAgIGNhbmNlbENhbGxiYWNrKGV4aXN0aW5nQ2FsbGJhY2tOb2RlKTtcbiAgICB9XG5cbiAgICB2YXIgc2NoZWR1bGVyUHJpb3JpdHlMZXZlbDtcblxuICAgIHN3aXRjaCAobGFuZXNUb0V2ZW50UHJpb3JpdHkobmV4dExhbmVzKSkge1xuICAgICAgY2FzZSBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk6XG4gICAgICAgIHNjaGVkdWxlclByaW9yaXR5TGV2ZWwgPSBJbW1lZGlhdGVQcmlvcml0eTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ29udGludW91c0V2ZW50UHJpb3JpdHk6XG4gICAgICAgIHNjaGVkdWxlclByaW9yaXR5TGV2ZWwgPSBVc2VyQmxvY2tpbmdQcmlvcml0eTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRGVmYXVsdEV2ZW50UHJpb3JpdHk6XG4gICAgICAgIHNjaGVkdWxlclByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eSQxO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBJZGxlRXZlbnRQcmlvcml0eTpcbiAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHlMZXZlbCA9IElkbGVQcmlvcml0eTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHNjaGVkdWxlclByaW9yaXR5TGV2ZWwgPSBOb3JtYWxQcmlvcml0eSQxO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgbmV3Q2FsbGJhY2tOb2RlID0gc2NoZWR1bGVDYWxsYmFjayQyKHNjaGVkdWxlclByaW9yaXR5TGV2ZWwsIHBlcmZvcm1Db25jdXJyZW50V29ya09uUm9vdC5iaW5kKG51bGwsIHJvb3QpKTtcbiAgICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSBuZXdDYWxsYmFja1ByaW9yaXR5O1xuICAgIHJvb3QuY2FsbGJhY2tOb2RlID0gbmV3Q2FsbGJhY2tOb2RlO1xuICAgIHJldHVybiBuZXdDYWxsYmFja1ByaW9yaXR5O1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldENvbnRpbnVhdGlvbkZvclJvb3Qocm9vdCwgb3JpZ2luYWxDYWxsYmFja05vZGUpIHtcbiAgLy8gVGhpcyBpcyBjYWxsZWQgYXQgdGhlIGVuZCBvZiBgcGVyZm9ybUNvbmN1cnJlbnRXb3JrT25Sb290YCB0byBkZXRlcm1pbmVcbiAgLy8gaWYgd2UgbmVlZCB0byBzY2hlZHVsZSBhIGNvbnRpbnVhdGlvbiB0YXNrLlxuICAvL1xuICAvLyBVc3VhbGx5IGBzY2hlZHVsZVRhc2tGb3JSb290RHVyaW5nTWljcm90YXNrYCBvbmx5IHJ1bnMgaW5zaWRlIGEgbWljcm90YXNrO1xuICAvLyBob3dldmVyLCBzaW5jZSBtb3N0IG9mIHRoZSBsb2dpYyBmb3IgZGV0ZXJtaW5pbmcgaWYgd2UgbmVlZCBhIGNvbnRpbnVhdGlvblxuICAvLyB2ZXJzdXMgYSBuZXcgdGFzayBpcyB0aGUgc2FtZSwgd2UgY2hlYXQgYSBiaXQgYW5kIGNhbGwgaXQgaGVyZS4gVGhpcyBpc1xuICAvLyBvbmx5IHNhZmUgdG8gZG8gYmVjYXVzZSB3ZSBrbm93IHdlJ3JlIGF0IHRoZSBlbmQgb2YgdGhlIGJyb3dzZXIgdGFzay5cbiAgLy8gU28gYWx0aG91Z2ggaXQncyBub3QgYW4gYWN0dWFsIG1pY3JvdGFzaywgaXQgbWlnaHQgYXMgd2VsbCBiZS5cbiAgc2NoZWR1bGVUYXNrRm9yUm9vdER1cmluZ01pY3JvdGFzayhyb290LCBub3ckMSgpKTtcblxuICBpZiAocm9vdC5jYWxsYmFja05vZGUgPT09IG9yaWdpbmFsQ2FsbGJhY2tOb2RlKSB7XG4gICAgLy8gVGhlIHRhc2sgbm9kZSBzY2hlZHVsZWQgZm9yIHRoaXMgcm9vdCBpcyB0aGUgc2FtZSBvbmUgdGhhdCdzXG4gICAgLy8gY3VycmVudGx5IGV4ZWN1dGVkLiBOZWVkIHRvIHJldHVybiBhIGNvbnRpbnVhdGlvbi5cbiAgICByZXR1cm4gcGVyZm9ybUNvbmN1cnJlbnRXb3JrT25Sb290LmJpbmQobnVsbCwgcm9vdCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cbnZhciBmYWtlQWN0Q2FsbGJhY2tOb2RlJDEgPSB7fTtcblxuZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFjayQyKHByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrKSB7XG4gIGlmIChSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSAhPT0gbnVsbCkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogV2UncmUgaW5zaWRlIGFuIGBhY3RgIHNjb3BlIChhIHRlc3RpbmcgdXRpbGl0eSkuXG4gICAgLy8gSW5zdGVhZCBvZiBzY2hlZHVsaW5nIHdvcmsgaW4gdGhlIGhvc3QgZW52aXJvbm1lbnQsIGFkZCBpdCB0byBhXG4gICAgLy8gZmFrZSBpbnRlcm5hbCBxdWV1ZSB0aGF0J3MgbWFuYWdlZCBieSB0aGUgYGFjdGAgaW1wbGVtZW50YXRpb24uXG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUucHVzaChjYWxsYmFjayk7XG4gICAgcmV0dXJuIGZha2VBY3RDYWxsYmFja05vZGUkMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc2NoZWR1bGVDYWxsYmFjayQzKHByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYW5jZWxDYWxsYmFjayhjYWxsYmFja05vZGUpIHtcbiAgaWYgKGNhbGxiYWNrTm9kZSA9PT0gZmFrZUFjdENhbGxiYWNrTm9kZSQxKSA7IGVsc2UgaWYgKGNhbGxiYWNrTm9kZSAhPT0gbnVsbCkge1xuICAgIGNhbmNlbENhbGxiYWNrJDEoY2FsbGJhY2tOb2RlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzY2hlZHVsZUltbWVkaWF0ZVRhc2soY2IpIHtcbiAgaWYgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlICE9PSBudWxsKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBJbnNpZGUgYW4gYGFjdGAgc2NvcGUsIHdlIHB1c2ggbWljcm90YXNrcyB0byB0aGUgZmFrZSBgYWN0YFxuICAgIC8vIGNhbGxiYWNrIHF1ZXVlLiBUaGlzIGlzIGJlY2F1c2Ugd2UgY3VycmVudGx5IHN1cHBvcnQgY2FsbGluZyBgYWN0YFxuICAgIC8vIHdpdGhvdXQgYXdhaXRpbmcgdGhlIHJlc3VsdC4gVGhlIHBsYW4gaXMgdG8gZGVwcmVjYXRlIHRoYXQsIGFuZCByZXF1aXJlXG4gICAgLy8gdGhhdCB5b3UgYWx3YXlzIGF3YWl0IHRoZSByZXN1bHQgc28gdGhhdCB0aGUgbWljcm90YXNrcyBoYXZlIGEgY2hhbmNlIHRvXG4gICAgLy8gcnVuLiBCdXQgaXQgaGFzbid0IGhhcHBlbmVkIHlldC5cbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZS5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNiKCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9KTtcbiAgfSAvLyBUT0RPOiBDYW4gd2UgbGFuZCBzdXBwb3J0c01pY3JvdGFza3M/IFdoaWNoIGVudmlyb25tZW50cyBkb24ndCBzdXBwb3J0IGl0P1xuICAvLyBBbHRlcm5hdGl2ZWx5LCBjYW4gd2UgbW92ZSB0aGlzIGNoZWNrIHRvIHRoZSBob3N0IGNvbmZpZz9cblxuXG4gIGlmIChzdXBwb3J0c01pY3JvdGFza3MpIHtcbiAgICBzY2hlZHVsZU1pY3JvdGFzayhmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBJbiBTYWZhcmksIGFwcGVuZGluZyBhbiBpZnJhbWUgZm9yY2VzIG1pY3JvdGFza3MgdG8gcnVuLlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMjQ1OVxuICAgICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCBydW5uaW5nIGNhbGxiYWNrcyBpbiB0aGUgbWlkZGxlIG9mIHJlbmRlclxuICAgICAgLy8gb3IgY29tbWl0IHNvIHdlIG5lZWQgdG8gY2hlY2sgYWdhaW5zdCB0aGF0LlxuICAgICAgdmFyIGV4ZWN1dGlvbkNvbnRleHQgPSBnZXRFeGVjdXRpb25Db250ZXh0KCk7XG5cbiAgICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpICE9PSBOb0NvbnRleHQpIHtcbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgd291bGQgc3RpbGwgcHJlbWF0dXJlbHkgZmx1c2ggdGhlIGNhbGxiYWNrc1xuICAgICAgICAvLyBpZiB0aGlzIGhhcHBlbnMgb3V0c2lkZSByZW5kZXIgb3IgY29tbWl0IHBoYXNlIChlLmcuIGluIGFuIGV2ZW50KS5cbiAgICAgICAgLy8gSW50ZW50aW9uYWxseSB1c2luZyBhIG1hY3JvdGFzayBpbnN0ZWFkIG9mIGEgbWljcm90YXNrIGhlcmUuIFRoaXMgaXNcbiAgICAgICAgLy8gd3Jvbmcgc2VtYW50aWNhbGx5IGJ1dCBpdCBwcmV2ZW50cyBhbiBpbmZpbml0ZSBsb29wLiBUaGUgYnVnIGlzXG4gICAgICAgIC8vIFNhZmFyaSdzLCBub3Qgb3Vycywgc28gd2UganVzdCBkbyBvdXIgYmVzdCB0byBub3QgY3Jhc2ggZXZlbiB0aG91Z2hcbiAgICAgICAgLy8gdGhlIGJlaGF2aW9yIGlzbid0IGNvbXBsZXRlbHkgY29ycmVjdC5cbiAgICAgICAgc2NoZWR1bGVDYWxsYmFjayQzKEltbWVkaWF0ZVByaW9yaXR5LCBjYik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY2IoKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiBtaWNyb3Rhc2tzIGFyZSBub3Qgc3VwcG9ydGVkLCB1c2UgU2NoZWR1bGVyLlxuICAgIHNjaGVkdWxlQ2FsbGJhY2skMyhJbW1lZGlhdGVQcmlvcml0eSwgY2IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RUcmFuc2l0aW9uTGFuZSggLy8gVGhpcyBhcmd1bWVudCBpc24ndCB1c2VkLCBpdCdzIG9ubHkgaGVyZSB0byBlbmNvdXJhZ2UgdGhlIGNhbGxlciB0b1xuLy8gY2hlY2sgdGhhdCBpdCdzIGluc2lkZSBhIHRyYW5zaXRpb24gYmVmb3JlIGNhbGxpbmcgdGhpcyBmdW5jdGlvbi5cbi8vIFRPRE86IE1ha2UgdGhpcyBub24tbnVsbGFibGUuIFJlcXVpcmVzIGEgdHdlYWsgdG8gdXNlT3B0aW1pc3RpYy5cbnRyYW5zaXRpb24pIHtcbiAgLy8gVGhlIGFsZ29yaXRobSBmb3IgYXNzaWduaW5nIGFuIHVwZGF0ZSB0byBhIGxhbmUgc2hvdWxkIGJlIHN0YWJsZSBmb3IgYWxsXG4gIC8vIHVwZGF0ZXMgYXQgdGhlIHNhbWUgcHJpb3JpdHkgd2l0aGluIHRoZSBzYW1lIGV2ZW50LiBUbyBkbyB0aGlzLCB0aGVcbiAgLy8gaW5wdXRzIHRvIHRoZSBhbGdvcml0aG0gbXVzdCBiZSB0aGUgc2FtZS5cbiAgLy9cbiAgLy8gVGhlIHRyaWNrIHdlIHVzZSBpcyB0byBjYWNoZSB0aGUgZmlyc3Qgb2YgZWFjaCBvZiB0aGVzZSBpbnB1dHMgd2l0aGluIGFuXG4gIC8vIGV2ZW50LiBUaGVuIHJlc2V0IHRoZSBjYWNoZWQgdmFsdWVzIG9uY2Ugd2UgY2FuIGJlIHN1cmUgdGhlIGV2ZW50IGlzXG4gIC8vIG92ZXIuIE91ciBoZXVyaXN0aWMgZm9yIHRoYXQgaXMgd2hlbmV2ZXIgd2UgZW50ZXIgYSBjb25jdXJyZW50IHdvcmsgbG9vcC5cbiAgaWYgKGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lID09PSBOb0xhbmUpIHtcbiAgICAvLyBBbGwgdHJhbnNpdGlvbnMgd2l0aGluIHRoZSBzYW1lIGV2ZW50IGFyZSBhc3NpZ25lZCB0aGUgc2FtZSBsYW5lLlxuICAgIGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lID0gY2xhaW1OZXh0VHJhbnNpdGlvbkxhbmUoKTtcbiAgfVxuXG4gIHJldHVybiBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZTtcbn1cblxuLy8gdHJhbnNpdGlvbiB1cGRhdGVzIHRoYXQgb2NjdXIgd2hpbGUgdGhlIGFzeW5jIGFjdGlvbiBpcyBzdGlsbCBpbiBwcm9ncmVzc1xuLy8gYXJlIHRyZWF0ZWQgYXMgcGFydCBvZiB0aGUgYWN0aW9uLlxuLy9cbi8vIFRoZSBpZGVhbCBiZWhhdmlvciB3b3VsZCBiZSB0byB0cmVhdCBlYWNoIGFzeW5jIGZ1bmN0aW9uIGFzIGFuIGluZGVwZW5kZW50XG4vLyBhY3Rpb24uIEhvd2V2ZXIsIHdpdGhvdXQgYSBtZWNoYW5pc20gbGlrZSBBc3luY0NvbnRleHQsIHdlIGNhbid0IHRlbGwgd2hpY2hcbi8vIGFjdGlvbiBhbiB1cGRhdGUgY29ycmVzcG9uZHMgdG8uIFNvIGluc3RlYWQsIHdlIGVudGFuZ2xlIHRoZW0gYWxsIGludG8gb25lLlxuLy8gVGhlIGxpc3RlbmVycyB0byBub3RpZnkgb25jZSB0aGUgZW50YW5nbGVkIHNjb3BlIGNvbXBsZXRlcy5cblxudmFyIGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMgPSBudWxsOyAvLyBUaGUgbnVtYmVyIG9mIHBlbmRpbmcgYXN5bmMgYWN0aW9ucyBpbiB0aGUgZW50YW5nbGVkIHNjb3BlLlxuXG52YXIgY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCA9IDA7IC8vIFRoZSB0cmFuc2l0aW9uIGxhbmUgc2hhcmVkIGJ5IGFsbCB1cGRhdGVzIGluIHRoZSBlbnRhbmdsZWQgc2NvcGUuXG5cbnZhciBjdXJyZW50RW50YW5nbGVkTGFuZSA9IE5vTGFuZTsgLy8gQSB0aGVuYWJsZSB0aGF0IHJlc29sdmVzIHdoZW4gdGhlIGVudGFuZ2xlZCBzY29wZSBjb21wbGV0ZXMuIEl0IGRvZXMgbm90XG4vLyByZXNvbHZlIHRvIGEgcGFydGljdWxhciB2YWx1ZSBiZWNhdXNlIGl0J3Mgb25seSB1c2VkIGZvciBzdXNwZW5kaW5nIHRoZSBVSVxuLy8gdW50aWwgdGhlIGFzeW5jIGFjdGlvbiBzY29wZSBoYXMgY29tcGxldGVkLlxuXG52YXIgY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlID0gbnVsbDtcbmZ1bmN0aW9uIGVudGFuZ2xlQXN5bmNBY3Rpb24odHJhbnNpdGlvbiwgdGhlbmFibGUpIHtcbiAgLy8gYHRoZW5hYmxlYCBpcyB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBhc3luYyBhY3Rpb24gc2NvcGUgZnVuY3Rpb24uIENyZWF0ZVxuICAvLyBhIGNvbWJpbmVkIHRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgb25jZSBldmVyeSBlbnRhbmdsZWQgc2NvcGUgZnVuY3Rpb25cbiAgLy8gaGFzIGZpbmlzaGVkLlxuICBpZiAoY3VycmVudEVudGFuZ2xlZExpc3RlbmVycyA9PT0gbnVsbCkge1xuICAgIC8vIFRoZXJlJ3Mgbm8gb3V0ZXIgYXN5bmMgYWN0aW9uIHNjb3BlLiBDcmVhdGUgYSBuZXcgb25lLlxuICAgIHZhciBlbnRhbmdsZWRMaXN0ZW5lcnMgPSBjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzID0gW107XG4gICAgY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCA9IDA7XG4gICAgY3VycmVudEVudGFuZ2xlZExhbmUgPSByZXF1ZXN0VHJhbnNpdGlvbkxhbmUoKTtcbiAgICB2YXIgZW50YW5nbGVkVGhlbmFibGUgPSB7XG4gICAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICB0aGVuOiBmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBlbnRhbmdsZWRMaXN0ZW5lcnMucHVzaChyZXNvbHZlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSA9IGVudGFuZ2xlZFRoZW5hYmxlO1xuICB9XG5cbiAgY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCsrO1xuICB0aGVuYWJsZS50aGVuKHBpbmdFbmd0YW5nbGVkQWN0aW9uU2NvcGUsIHBpbmdFbmd0YW5nbGVkQWN0aW9uU2NvcGUpO1xuICByZXR1cm4gdGhlbmFibGU7XG59XG5cbmZ1bmN0aW9uIHBpbmdFbmd0YW5nbGVkQWN0aW9uU2NvcGUoKSB7XG4gIGlmIChjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzICE9PSBudWxsICYmIC0tY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCA9PT0gMCkge1xuICAgIC8vIEFsbCB0aGUgYWN0aW9ucyBoYXZlIGZpbmlzaGVkLiBDbG9zZSB0aGUgZW50YW5nbGVkIGFzeW5jIGFjdGlvbiBzY29wZVxuICAgIC8vIGFuZCBub3RpZnkgYWxsIHRoZSBsaXN0ZW5lcnMuXG4gICAgaWYgKGN1cnJlbnRFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIGZ1bGZpbGxlZFRoZW5hYmxlID0gY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlO1xuICAgICAgZnVsZmlsbGVkVGhlbmFibGUuc3RhdHVzID0gJ2Z1bGZpbGxlZCc7XG4gICAgfVxuXG4gICAgdmFyIGxpc3RlbmVycyA9IGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnM7XG4gICAgY3VycmVudEVudGFuZ2xlZExpc3RlbmVycyA9IG51bGw7XG4gICAgY3VycmVudEVudGFuZ2xlZExhbmUgPSBOb0xhbmU7XG4gICAgY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlID0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG4gICAgICBsaXN0ZW5lcigpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGFpblRoZW5hYmxlVmFsdWUodGhlbmFibGUsIHJlc3VsdCkge1xuICAvLyBFcXVpdmFsZW50IHRvOiBQcm9taXNlLnJlc29sdmUodGhlbmFibGUpLnRoZW4oKCkgPT4gcmVzdWx0KSwgZXhjZXB0IHdlIGNhblxuICAvLyBjaGVhdCBhIGJpdCBzaW5jZSB3ZSBrbm93IHRoYXQgdGhhdCB0aGlzIHRoZW5hYmxlIGlzIG9ubHkgZXZlciBjb25zdW1lZFxuICAvLyBieSBSZWFjdC5cbiAgLy9cbiAgLy8gV2UgZG9uJ3QgdGVjaG5pY2FsbHkgcmVxdWlyZSBwcm9taXNlIHN1cHBvcnQgb24gdGhlIGNsaWVudCB5ZXQsIGhlbmNlIHRoaXNcbiAgLy8gZXh0cmEgY29kZS5cbiAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICB2YXIgdGhlbmFibGVXaXRoT3ZlcnJpZGUgPSB7XG4gICAgc3RhdHVzOiAncGVuZGluZycsXG4gICAgdmFsdWU6IG51bGwsXG4gICAgcmVhc29uOiBudWxsLFxuICAgIHRoZW46IGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBsaXN0ZW5lcnMucHVzaChyZXNvbHZlKTtcbiAgICB9XG4gIH07XG4gIHRoZW5hYmxlLnRoZW4oZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdmFyIGZ1bGZpbGxlZFRoZW5hYmxlID0gdGhlbmFibGVXaXRoT3ZlcnJpZGU7XG4gICAgZnVsZmlsbGVkVGhlbmFibGUuc3RhdHVzID0gJ2Z1bGZpbGxlZCc7XG4gICAgZnVsZmlsbGVkVGhlbmFibGUudmFsdWUgPSByZXN1bHQ7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldO1xuICAgICAgbGlzdGVuZXIocmVzdWx0KTtcbiAgICB9XG4gIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgIHZhciByZWplY3RlZFRoZW5hYmxlID0gdGhlbmFibGVXaXRoT3ZlcnJpZGU7XG4gICAgcmVqZWN0ZWRUaGVuYWJsZS5zdGF0dXMgPSAncmVqZWN0ZWQnO1xuICAgIHJlamVjdGVkVGhlbmFibGUucmVhc29uID0gZXJyb3I7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGxpc3RlbmVyID0gbGlzdGVuZXJzW2ldOyAvLyBUaGlzIGlzIGEgcGVyZiBoYWNrIHdoZXJlIHdlIGNhbGwgdGhlIGBvbkZ1bGZpbGxgIHBpbmcgZnVuY3Rpb25cbiAgICAgIC8vIGluc3RlYWQgb2YgYG9uUmVqZWN0YCwgYmVjYXVzZSB3ZSBrbm93IHRoYXQgUmVhY3QgaXMgdGhlIG9ubHlcbiAgICAgIC8vIGNvbnN1bWVyIG9mIHRoZXNlIHByb21pc2VzLCBhbmQgaXQgcGFzc2VzIHRoZSBzYW1lIGxpc3RlbmVyIHRvIGJvdGguXG4gICAgICAvLyBXZSBhbHNvIGtub3cgdGhhdCBpdCB3aWxsIHJlYWQgdGhlIGVycm9yIGRpcmVjdGx5IG9mZiB0aGVcbiAgICAgIC8vIGAucmVhc29uYCBmaWVsZC5cblxuICAgICAgbGlzdGVuZXIodW5kZWZpbmVkKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gdGhlbmFibGVXaXRoT3ZlcnJpZGU7XG59XG5mdW5jdGlvbiBwZWVrRW50YW5nbGVkQWN0aW9uTGFuZSgpIHtcbiAgcmV0dXJuIGN1cnJlbnRFbnRhbmdsZWRMYW5lO1xufVxuZnVuY3Rpb24gcGVla0VudGFuZ2xlZEFjdGlvblRoZW5hYmxlKCkge1xuICByZXR1cm4gY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlO1xufVxuXG52YXIgVXBkYXRlU3RhdGUgPSAwO1xudmFyIFJlcGxhY2VTdGF0ZSA9IDE7XG52YXIgRm9yY2VVcGRhdGUgPSAyO1xudmFyIENhcHR1cmVVcGRhdGUgPSAzOyAvLyBHbG9iYWwgc3RhdGUgdGhhdCBpcyByZXNldCBhdCB0aGUgYmVnaW5uaW5nIG9mIGNhbGxpbmcgYHByb2Nlc3NVcGRhdGVRdWV1ZWAuXG4vLyBJdCBzaG91bGQgb25seSBiZSByZWFkIHJpZ2h0IGFmdGVyIGNhbGxpbmcgYHByb2Nlc3NVcGRhdGVRdWV1ZWAsIHZpYVxuLy8gYGNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmdgLlxuXG52YXIgaGFzRm9yY2VVcGRhdGUgPSBmYWxzZTtcbnZhciBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlO1xudmFyIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZTtcblxue1xuICBkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlID0gZmFsc2U7XG4gIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVVcGRhdGVRdWV1ZShmaWJlcikge1xuICB2YXIgcXVldWUgPSB7XG4gICAgYmFzZVN0YXRlOiBmaWJlci5tZW1vaXplZFN0YXRlLFxuICAgIGZpcnN0QmFzZVVwZGF0ZTogbnVsbCxcbiAgICBsYXN0QmFzZVVwZGF0ZTogbnVsbCxcbiAgICBzaGFyZWQ6IHtcbiAgICAgIHBlbmRpbmc6IG51bGwsXG4gICAgICBsYW5lczogTm9MYW5lcyxcbiAgICAgIGhpZGRlbkNhbGxiYWNrczogbnVsbFxuICAgIH0sXG4gICAgY2FsbGJhY2tzOiBudWxsXG4gIH07XG4gIGZpYmVyLnVwZGF0ZVF1ZXVlID0gcXVldWU7XG59XG5mdW5jdGlvbiBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIC8vIENsb25lIHRoZSB1cGRhdGUgcXVldWUgZnJvbSBjdXJyZW50LiBVbmxlc3MgaXQncyBhbHJlYWR5IGEgY2xvbmUuXG4gIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICB2YXIgY3VycmVudFF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcblxuICBpZiAocXVldWUgPT09IGN1cnJlbnRRdWV1ZSkge1xuICAgIHZhciBjbG9uZSA9IHtcbiAgICAgIGJhc2VTdGF0ZTogY3VycmVudFF1ZXVlLmJhc2VTdGF0ZSxcbiAgICAgIGZpcnN0QmFzZVVwZGF0ZTogY3VycmVudFF1ZXVlLmZpcnN0QmFzZVVwZGF0ZSxcbiAgICAgIGxhc3RCYXNlVXBkYXRlOiBjdXJyZW50UXVldWUubGFzdEJhc2VVcGRhdGUsXG4gICAgICBzaGFyZWQ6IGN1cnJlbnRRdWV1ZS5zaGFyZWQsXG4gICAgICBjYWxsYmFja3M6IG51bGxcbiAgICB9O1xuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY2xvbmU7XG4gIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVVwZGF0ZShsYW5lKSB7XG4gIHZhciB1cGRhdGUgPSB7XG4gICAgbGFuZTogbGFuZSxcbiAgICB0YWc6IFVwZGF0ZVN0YXRlLFxuICAgIHBheWxvYWQ6IG51bGwsXG4gICAgY2FsbGJhY2s6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuICByZXR1cm4gdXBkYXRlO1xufVxuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlLCBsYW5lKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuXG4gIGlmICh1cGRhdGVRdWV1ZSA9PT0gbnVsbCkge1xuICAgIC8vIE9ubHkgb2NjdXJzIGlmIHRoZSBmaWJlciBoYXMgYmVlbiB1bm1vdW50ZWQuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgc2hhcmVkUXVldWUgPSB1cGRhdGVRdWV1ZS5zaGFyZWQ7XG5cbiAge1xuICAgIGlmIChjdXJyZW50bHlQcm9jZXNzaW5nUXVldWUgPT09IHNoYXJlZFF1ZXVlICYmICFkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpO1xuXG4gICAgICBlcnJvcignQW4gdXBkYXRlIChzZXRTdGF0ZSwgcmVwbGFjZVN0YXRlLCBvciBmb3JjZVVwZGF0ZSkgd2FzIHNjaGVkdWxlZCAnICsgJ2Zyb20gaW5zaWRlIGFuIHVwZGF0ZSBmdW5jdGlvbi4gVXBkYXRlIGZ1bmN0aW9ucyBzaG91bGQgYmUgcHVyZSwgJyArICd3aXRoIHplcm8gc2lkZS1lZmZlY3RzLiBDb25zaWRlciB1c2luZyBjb21wb25lbnREaWRVcGRhdGUgb3IgYSAnICsgJ2NhbGxiYWNrLlxcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnQ6ICVzJywgY29tcG9uZW50TmFtZSk7XG5cbiAgICAgIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc1Vuc2FmZUNsYXNzUmVuZGVyUGhhc2VVcGRhdGUoKSkge1xuICAgIC8vIFRoaXMgaXMgYW4gdW5zYWZlIHJlbmRlciBwaGFzZSB1cGRhdGUuIEFkZCBkaXJlY3RseSB0byB0aGUgdXBkYXRlXG4gICAgLy8gcXVldWUgc28gd2UgY2FuIHByb2Nlc3MgaXQgaW1tZWRpYXRlbHkgZHVyaW5nIHRoZSBjdXJyZW50IHJlbmRlci5cbiAgICB2YXIgcGVuZGluZyA9IHNoYXJlZFF1ZXVlLnBlbmRpbmc7XG5cbiAgICBpZiAocGVuZGluZyA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlLiBDcmVhdGUgYSBjaXJjdWxhciBsaXN0LlxuICAgICAgdXBkYXRlLm5leHQgPSB1cGRhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZS5uZXh0ID0gcGVuZGluZy5uZXh0O1xuICAgICAgcGVuZGluZy5uZXh0ID0gdXBkYXRlO1xuICAgIH1cblxuICAgIHNoYXJlZFF1ZXVlLnBlbmRpbmcgPSB1cGRhdGU7IC8vIFVwZGF0ZSB0aGUgY2hpbGRMYW5lcyBldmVuIHRob3VnaCB3ZSdyZSBtb3N0IGxpa2VseSBhbHJlYWR5IHJlbmRlcmluZ1xuICAgIC8vIHRoaXMgZmliZXIuIFRoaXMgaXMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IGluIHRoZSBjYXNlIHdoZXJlIHlvdVxuICAgIC8vIHVwZGF0ZSBhIGRpZmZlcmVudCBjb21wb25lbnQgZHVyaW5nIHJlbmRlciBwaGFzZSB0aGFuIHRoZSBvbmUgdGhhdCBpc1xuICAgIC8vIGN1cnJlbnRseSByZW5kZXJpbmdzIChhIHBhdHRlcm4gdGhhdCBpcyBhY2NvbXBhbmllZCBieSBhIHdhcm5pbmcpLlxuXG4gICAgcmV0dXJuIHVuc2FmZV9tYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdChmaWJlciwgbGFuZSk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGVucXVldWVDb25jdXJyZW50Q2xhc3NVcGRhdGUoZmliZXIsIHNoYXJlZFF1ZXVlLCB1cGRhdGUsIGxhbmUpO1xuICB9XG59XG5mdW5jdGlvbiBlbnRhbmdsZVRyYW5zaXRpb25zKHJvb3QsIGZpYmVyLCBsYW5lKSB7XG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpYmVyLnVwZGF0ZVF1ZXVlO1xuXG4gIGlmICh1cGRhdGVRdWV1ZSA9PT0gbnVsbCkge1xuICAgIC8vIE9ubHkgb2NjdXJzIGlmIHRoZSBmaWJlciBoYXMgYmVlbiB1bm1vdW50ZWQuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHNoYXJlZFF1ZXVlID0gdXBkYXRlUXVldWUuc2hhcmVkO1xuXG4gIGlmIChpc1RyYW5zaXRpb25MYW5lKGxhbmUpKSB7XG4gICAgdmFyIHF1ZXVlTGFuZXMgPSBzaGFyZWRRdWV1ZS5sYW5lczsgLy8gSWYgYW55IGVudGFuZ2xlZCBsYW5lcyBhcmUgbm8gbG9uZ2VyIHBlbmRpbmcgb24gdGhlIHJvb3QsIHRoZW4gdGhleSBtdXN0XG4gICAgLy8gaGF2ZSBmaW5pc2hlZC4gV2UgY2FuIHJlbW92ZSB0aGVtIGZyb20gdGhlIHNoYXJlZCBxdWV1ZSwgd2hpY2ggcmVwcmVzZW50c1xuICAgIC8vIGEgc3VwZXJzZXQgb2YgdGhlIGFjdHVhbGx5IHBlbmRpbmcgbGFuZXMuIEluIHNvbWUgY2FzZXMgd2UgbWF5IGVudGFuZ2xlXG4gICAgLy8gbW9yZSB0aGFuIHdlIG5lZWQgdG8sIGJ1dCB0aGF0J3MgT0suIEluIGZhY3QgaXQncyB3b3JzZSBpZiB3ZSAqZG9uJ3QqXG4gICAgLy8gZW50YW5nbGUgd2hlbiB3ZSBzaG91bGQuXG5cbiAgICBxdWV1ZUxhbmVzID0gaW50ZXJzZWN0TGFuZXMocXVldWVMYW5lcywgcm9vdC5wZW5kaW5nTGFuZXMpOyAvLyBFbnRhbmdsZSB0aGUgbmV3IHRyYW5zaXRpb24gbGFuZSB3aXRoIHRoZSBvdGhlciB0cmFuc2l0aW9uIGxhbmVzLlxuXG4gICAgdmFyIG5ld1F1ZXVlTGFuZXMgPSBtZXJnZUxhbmVzKHF1ZXVlTGFuZXMsIGxhbmUpO1xuICAgIHNoYXJlZFF1ZXVlLmxhbmVzID0gbmV3UXVldWVMYW5lczsgLy8gRXZlbiBpZiBxdWV1ZS5sYW5lcyBhbHJlYWR5IGluY2x1ZGUgbGFuZSwgd2UgZG9uJ3Qga25vdyBmb3IgY2VydGFpbiBpZlxuICAgIC8vIHRoZSBsYW5lIGZpbmlzaGVkIHNpbmNlIHRoZSBsYXN0IHRpbWUgd2UgZW50YW5nbGVkIGl0LiBTbyB3ZSBuZWVkIHRvXG4gICAgLy8gZW50YW5nbGUgaXQgYWdhaW4sIGp1c3QgdG8gYmUgc3VyZS5cblxuICAgIG1hcmtSb290RW50YW5nbGVkKHJvb3QsIG5ld1F1ZXVlTGFuZXMpO1xuICB9XG59XG5mdW5jdGlvbiBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGNhcHR1cmVkVXBkYXRlKSB7XG4gIC8vIENhcHR1cmVkIHVwZGF0ZXMgYXJlIHVwZGF0ZXMgdGhhdCBhcmUgdGhyb3duIGJ5IGEgY2hpbGQgZHVyaW5nIHRoZSByZW5kZXJcbiAgLy8gcGhhc2UuIFRoZXkgc2hvdWxkIGJlIGRpc2NhcmRlZCBpZiB0aGUgcmVuZGVyIGlzIGFib3J0ZWQuIFRoZXJlZm9yZSxcbiAgLy8gd2Ugc2hvdWxkIG9ubHkgcHV0IHRoZW0gb24gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUsIG5vdCB0aGUgY3VycmVudCBvbmUuXG4gIHZhciBxdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlOyAvLyBDaGVjayBpZiB0aGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSBpcyBhIGNsb25lLlxuXG4gIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnRRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG5cbiAgICBpZiAocXVldWUgPT09IGN1cnJlbnRRdWV1ZSkge1xuICAgICAgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgaXMgdGhlIHNhbWUgYXMgY3VycmVudC4gVGhpcyBoYXBwZW5zIHdoZW5cbiAgICAgIC8vIHdlIGJhaWwgb3V0IG9uIGEgcGFyZW50IGZpYmVyIHRoYXQgdGhlbiBjYXB0dXJlcyBhbiBlcnJvciB0aHJvd24gYnlcbiAgICAgIC8vIGEgY2hpbGQuIFNpbmNlIHdlIHdhbnQgdG8gYXBwZW5kIHRoZSB1cGRhdGUgb25seSB0byB0aGUgd29yay1pblxuICAgICAgLy8gLXByb2dyZXNzIHF1ZXVlLCB3ZSBuZWVkIHRvIGNsb25lIHRoZSB1cGRhdGVzLiBXZSB1c3VhbGx5IGNsb25lIGR1cmluZ1xuICAgICAgLy8gcHJvY2Vzc1VwZGF0ZVF1ZXVlLCBidXQgdGhhdCBkaWRuJ3QgaGFwcGVuIGluIHRoaXMgY2FzZSBiZWNhdXNlIHdlXG4gICAgICAvLyBza2lwcGVkIG92ZXIgdGhlIHBhcmVudCB3aGVuIHdlIGJhaWxlZCBvdXQuXG4gICAgICB2YXIgbmV3Rmlyc3QgPSBudWxsO1xuICAgICAgdmFyIG5ld0xhc3QgPSBudWxsO1xuICAgICAgdmFyIGZpcnN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZTtcblxuICAgICAgaWYgKGZpcnN0QmFzZVVwZGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBMb29wIHRocm91Z2ggdGhlIHVwZGF0ZXMgYW5kIGNsb25lIHRoZW0uXG4gICAgICAgIHZhciB1cGRhdGUgPSBmaXJzdEJhc2VVcGRhdGU7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIHZhciBjbG9uZSA9IHtcbiAgICAgICAgICAgIGxhbmU6IHVwZGF0ZS5sYW5lLFxuICAgICAgICAgICAgdGFnOiB1cGRhdGUudGFnLFxuICAgICAgICAgICAgcGF5bG9hZDogdXBkYXRlLnBheWxvYWQsXG4gICAgICAgICAgICAvLyBXaGVuIHRoaXMgdXBkYXRlIGlzIHJlYmFzZWQsIHdlIHNob3VsZCBub3QgZmlyZSBpdHNcbiAgICAgICAgICAgIC8vIGNhbGxiYWNrIGFnYWluLlxuICAgICAgICAgICAgY2FsbGJhY2s6IG51bGwsXG4gICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmIChuZXdMYXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBuZXdGaXJzdCA9IG5ld0xhc3QgPSBjbG9uZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmV3TGFzdC5uZXh0ID0gY2xvbmU7XG4gICAgICAgICAgICBuZXdMYXN0ID0gY2xvbmU7XG4gICAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSB3ZSBiYWlsIG91dCB3aGVuIHdlIGdldCBhIG51bGxcblxuXG4gICAgICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgICAgIH0gd2hpbGUgKHVwZGF0ZSAhPT0gbnVsbCk7IC8vIEFwcGVuZCB0aGUgY2FwdHVyZWQgdXBkYXRlIHRoZSBlbmQgb2YgdGhlIGNsb25lZCBsaXN0LlxuXG5cbiAgICAgICAgaWYgKG5ld0xhc3QgPT09IG51bGwpIHtcbiAgICAgICAgICBuZXdGaXJzdCA9IG5ld0xhc3QgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdMYXN0Lm5leHQgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgICAgICAgICBuZXdMYXN0ID0gY2FwdHVyZWRVcGRhdGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZXJlIGFyZSBubyBiYXNlIHVwZGF0ZXMuXG4gICAgICAgIG5ld0ZpcnN0ID0gbmV3TGFzdCA9IGNhcHR1cmVkVXBkYXRlO1xuICAgICAgfVxuXG4gICAgICBxdWV1ZSA9IHtcbiAgICAgICAgYmFzZVN0YXRlOiBjdXJyZW50UXVldWUuYmFzZVN0YXRlLFxuICAgICAgICBmaXJzdEJhc2VVcGRhdGU6IG5ld0ZpcnN0LFxuICAgICAgICBsYXN0QmFzZVVwZGF0ZTogbmV3TGFzdCxcbiAgICAgICAgc2hhcmVkOiBjdXJyZW50UXVldWUuc2hhcmVkLFxuICAgICAgICBjYWxsYmFja3M6IGN1cnJlbnRRdWV1ZS5jYWxsYmFja3NcbiAgICAgIH07XG4gICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IHF1ZXVlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSAvLyBBcHBlbmQgdGhlIHVwZGF0ZSB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuXG5cbiAgdmFyIGxhc3RCYXNlVXBkYXRlID0gcXVldWUubGFzdEJhc2VVcGRhdGU7XG5cbiAgaWYgKGxhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgcXVldWUuZmlyc3RCYXNlVXBkYXRlID0gY2FwdHVyZWRVcGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgbGFzdEJhc2VVcGRhdGUubmV4dCA9IGNhcHR1cmVkVXBkYXRlO1xuICB9XG5cbiAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBjYXB0dXJlZFVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gZ2V0U3RhdGVGcm9tVXBkYXRlKHdvcmtJblByb2dyZXNzLCBxdWV1ZSwgdXBkYXRlLCBwcmV2U3RhdGUsIG5leHRQcm9wcywgaW5zdGFuY2UpIHtcbiAgc3dpdGNoICh1cGRhdGUudGFnKSB7XG4gICAgY2FzZSBSZXBsYWNlU3RhdGU6XG4gICAgICB7XG4gICAgICAgIHZhciBwYXlsb2FkID0gdXBkYXRlLnBheWxvYWQ7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBwYXlsb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gVXBkYXRlciBmdW5jdGlvblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVudGVyRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgbmV4dFN0YXRlID0gcGF5bG9hZC5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7XG5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIG5leHRTdGF0ZTtcbiAgICAgICAgfSAvLyBTdGF0ZSBvYmplY3RcblxuXG4gICAgICAgIHJldHVybiBwYXlsb2FkO1xuICAgICAgfVxuXG4gICAgY2FzZSBDYXB0dXJlVXBkYXRlOlxuICAgICAge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IHdvcmtJblByb2dyZXNzLmZsYWdzICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuICAgICAgfVxuICAgIC8vIEludGVudGlvbmFsIGZhbGx0aHJvdWdoXG5cbiAgICBjYXNlIFVwZGF0ZVN0YXRlOlxuICAgICAge1xuICAgICAgICB2YXIgX3BheWxvYWQgPSB1cGRhdGUucGF5bG9hZDtcbiAgICAgICAgdmFyIHBhcnRpYWxTdGF0ZTtcblxuICAgICAgICBpZiAodHlwZW9mIF9wYXlsb2FkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gVXBkYXRlciBmdW5jdGlvblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGVudGVyRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJ0aWFsU3RhdGUgPSBfcGF5bG9hZC5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7XG5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBfcGF5bG9hZC5jYWxsKGluc3RhbmNlLCBwcmV2U3RhdGUsIG5leHRQcm9wcyk7XG4gICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGV4aXREaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBQYXJ0aWFsIHN0YXRlIG9iamVjdFxuICAgICAgICAgIHBhcnRpYWxTdGF0ZSA9IF9wYXlsb2FkO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcnRpYWxTdGF0ZSA9PT0gbnVsbCB8fCBwYXJ0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIC8vIE51bGwgYW5kIHVuZGVmaW5lZCBhcmUgdHJlYXRlZCBhcyBuby1vcHMuXG4gICAgICAgICAgcmV0dXJuIHByZXZTdGF0ZTtcbiAgICAgICAgfSAvLyBNZXJnZSB0aGUgcGFydGlhbCBzdGF0ZSBhbmQgdGhlIHByZXZpb3VzIHN0YXRlLlxuXG5cbiAgICAgICAgcmV0dXJuIGFzc2lnbih7fSwgcHJldlN0YXRlLCBwYXJ0aWFsU3RhdGUpO1xuICAgICAgfVxuXG4gICAgY2FzZSBGb3JjZVVwZGF0ZTpcbiAgICAgIHtcbiAgICAgICAgaGFzRm9yY2VVcGRhdGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIHByZXZTdGF0ZTtcbn1cblxudmFyIGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gPSBmYWxzZTsgLy8gRWFjaCBjYWxsIHRvIHByb2Nlc3NVcGRhdGVRdWV1ZSBzaG91bGQgYmUgYWNjb21wYW5pZWQgYnkgYSBjYWxsIHRvIHRoaXMuIEl0J3Ncbi8vIG9ubHkgaW4gYSBzZXBhcmF0ZSBmdW5jdGlvbiBiZWNhdXNlIGluIHVwZGF0ZUhvc3RSb290LCBpdCBtdXN0IGhhcHBlbiBhZnRlclxuLy8gYWxsIHRoZSBjb250ZXh0IHN0YWNrcyBoYXZlIGJlZW4gcHVzaGVkIHRvLCB0byBwcmV2ZW50IGEgc3RhY2sgbWlzbWF0Y2guIEFcbi8vIGJpdCB1bmZvcnR1bmF0ZS5cblxuZnVuY3Rpb24gc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpIHtcbiAgLy8gQ2hlY2sgaWYgdGhpcyB1cGRhdGUgaXMgcGFydCBvZiBhIHBlbmRpbmcgYXN5bmMgYWN0aW9uLiBJZiBzbywgd2UnbGxcbiAgLy8gbmVlZCB0byBzdXNwZW5kIHVudGlsIHRoZSBhY3Rpb24gaGFzIGZpbmlzaGVkLCBzbyB0aGF0IGl0J3MgYmF0Y2hlZFxuICAvLyB0b2dldGhlciB3aXRoIGZ1dHVyZSB1cGRhdGVzIGluIHRoZSBzYW1lIGFjdGlvbi5cbiAgLy8gVE9ETzogT25jZSB3ZSBzdXBwb3J0IGhvb2tzIGluc2lkZSB1c2VNZW1vIChvciBhbiBlcXVpdmFsZW50XG4gIC8vIG1lbW9pemF0aW9uIGJvdW5kYXJ5IGxpa2UgRm9yZ2V0KSwgaG9pc3QgdGhpcyBsb2dpYyBzbyB0aGF0IGl0IG9ubHlcbiAgLy8gc3VzcGVuZHMgaWYgdGhlIG1lbW8gYm91bmRhcnkgcHJvZHVjZXMgYSBuZXcgdmFsdWUuXG4gIGlmIChkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKSB7XG4gICAgdmFyIGVudGFuZ2xlZEFjdGlvblRoZW5hYmxlID0gcGVla0VudGFuZ2xlZEFjdGlvblRoZW5hYmxlKCk7XG5cbiAgICBpZiAoZW50YW5nbGVkQWN0aW9uVGhlbmFibGUgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IEluc3RlYWQgb2YgdGhlIHRocm93aW5nIHRoZSB0aGVuYWJsZSBkaXJlY3RseSwgdGhyb3cgYVxuICAgICAgLy8gc3BlY2lhbCBvYmplY3QgbGlrZSBgdXNlYCBkb2VzIHNvIHdlIGNhbiBkZXRlY3QgaWYgaXQncyBjYXB0dXJlZFxuICAgICAgLy8gYnkgdXNlcnNwYWNlLlxuICAgICAgdGhyb3cgZW50YW5nbGVkQWN0aW9uVGhlbmFibGU7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIHByb3BzLCBpbnN0YW5jZSwgcmVuZGVyTGFuZXMpIHtcbiAgZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiA9IGZhbHNlOyAvLyBUaGlzIGlzIGFsd2F5cyBub24tbnVsbCBvbiBhIENsYXNzQ29tcG9uZW50IG9yIEhvc3RSb290XG5cbiAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIGhhc0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbiAge1xuICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IHF1ZXVlLnNoYXJlZDtcbiAgfVxuXG4gIHZhciBmaXJzdEJhc2VVcGRhdGUgPSBxdWV1ZS5maXJzdEJhc2VVcGRhdGU7XG4gIHZhciBsYXN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmxhc3RCYXNlVXBkYXRlOyAvLyBDaGVjayBpZiB0aGVyZSBhcmUgcGVuZGluZyB1cGRhdGVzLiBJZiBzbywgdHJhbnNmZXIgdGhlbSB0byB0aGUgYmFzZSBxdWV1ZS5cblxuICB2YXIgcGVuZGluZ1F1ZXVlID0gcXVldWUuc2hhcmVkLnBlbmRpbmc7XG5cbiAgaWYgKHBlbmRpbmdRdWV1ZSAhPT0gbnVsbCkge1xuICAgIHF1ZXVlLnNoYXJlZC5wZW5kaW5nID0gbnVsbDsgLy8gVGhlIHBlbmRpbmcgcXVldWUgaXMgY2lyY3VsYXIuIERpc2Nvbm5lY3QgdGhlIHBvaW50ZXIgYmV0d2VlbiBmaXJzdFxuICAgIC8vIGFuZCBsYXN0IHNvIHRoYXQgaXQncyBub24tY2lyY3VsYXIuXG5cbiAgICB2YXIgbGFzdFBlbmRpbmdVcGRhdGUgPSBwZW5kaW5nUXVldWU7XG4gICAgdmFyIGZpcnN0UGVuZGluZ1VwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlLm5leHQ7XG4gICAgbGFzdFBlbmRpbmdVcGRhdGUubmV4dCA9IG51bGw7IC8vIEFwcGVuZCBwZW5kaW5nIHVwZGF0ZXMgdG8gYmFzZSBxdWV1ZVxuXG4gICAgaWYgKGxhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgICBmaXJzdEJhc2VVcGRhdGUgPSBmaXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxhc3RCYXNlVXBkYXRlLm5leHQgPSBmaXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgfVxuXG4gICAgbGFzdEJhc2VVcGRhdGUgPSBsYXN0UGVuZGluZ1VwZGF0ZTsgLy8gSWYgdGhlcmUncyBhIGN1cnJlbnQgcXVldWUsIGFuZCBpdCdzIGRpZmZlcmVudCBmcm9tIHRoZSBiYXNlIHF1ZXVlLCB0aGVuXG4gICAgLy8gd2UgbmVlZCB0byB0cmFuc2ZlciB0aGUgdXBkYXRlcyB0byB0aGF0IHF1ZXVlLCB0b28uIEJlY2F1c2UgdGhlIGJhc2VcbiAgICAvLyBxdWV1ZSBpcyBhIHNpbmdseS1saW5rZWQgbGlzdCB3aXRoIG5vIGN5Y2xlcywgd2UgY2FuIGFwcGVuZCB0byBib3RoXG4gICAgLy8gbGlzdHMgYW5kIHRha2UgYWR2YW50YWdlIG9mIHN0cnVjdHVyYWwgc2hhcmluZy5cbiAgICAvLyBUT0RPOiBQYXNzIGBjdXJyZW50YCBhcyBhcmd1bWVudFxuXG4gICAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBpcyBhbHdheXMgbm9uLW51bGwgb24gYSBDbGFzc0NvbXBvbmVudCBvciBIb3N0Um9vdFxuICAgICAgdmFyIGN1cnJlbnRRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG4gICAgICB2YXIgY3VycmVudExhc3RCYXNlVXBkYXRlID0gY3VycmVudFF1ZXVlLmxhc3RCYXNlVXBkYXRlO1xuXG4gICAgICBpZiAoY3VycmVudExhc3RCYXNlVXBkYXRlICE9PSBsYXN0QmFzZVVwZGF0ZSkge1xuICAgICAgICBpZiAoY3VycmVudExhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgY3VycmVudFF1ZXVlLmZpcnN0QmFzZVVwZGF0ZSA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdXJyZW50TGFzdEJhc2VVcGRhdGUubmV4dCA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRRdWV1ZS5sYXN0QmFzZVVwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBUaGVzZSB2YWx1ZXMgbWF5IGNoYW5nZSBhcyB3ZSBwcm9jZXNzIHRoZSBxdWV1ZS5cblxuXG4gIGlmIChmaXJzdEJhc2VVcGRhdGUgIT09IG51bGwpIHtcbiAgICAvLyBJdGVyYXRlIHRocm91Z2ggdGhlIGxpc3Qgb2YgdXBkYXRlcyB0byBjb21wdXRlIHRoZSByZXN1bHQuXG4gICAgdmFyIG5ld1N0YXRlID0gcXVldWUuYmFzZVN0YXRlOyAvLyBUT0RPOiBEb24ndCBuZWVkIHRvIGFjY3VtdWxhdGUgdGhpcy4gSW5zdGVhZCwgd2UgY2FuIHJlbW92ZSByZW5kZXJMYW5lc1xuICAgIC8vIGZyb20gdGhlIG9yaWdpbmFsIGxhbmVzLlxuXG4gICAgdmFyIG5ld0xhbmVzID0gTm9MYW5lcztcbiAgICB2YXIgbmV3QmFzZVN0YXRlID0gbnVsbDtcbiAgICB2YXIgbmV3Rmlyc3RCYXNlVXBkYXRlID0gbnVsbDtcbiAgICB2YXIgbmV3TGFzdEJhc2VVcGRhdGUgPSBudWxsO1xuICAgIHZhciB1cGRhdGUgPSBmaXJzdEJhc2VVcGRhdGU7XG5cbiAgICBkbyB7XG4gICAgICAvLyBBbiBleHRyYSBPZmZzY3JlZW5MYW5lIGJpdCBpcyBhZGRlZCB0byB1cGRhdGVzIHRoYXQgd2VyZSBtYWRlIHRvXG4gICAgICAvLyBhIGhpZGRlbiB0cmVlLCBzbyB0aGF0IHdlIGNhbiBkaXN0aW5ndWlzaCB0aGVtIGZyb20gdXBkYXRlcyB0aGF0IHdlcmVcbiAgICAgIC8vIGFscmVhZHkgdGhlcmUgd2hlbiB0aGUgdHJlZSB3YXMgaGlkZGVuLlxuICAgICAgdmFyIHVwZGF0ZUxhbmUgPSByZW1vdmVMYW5lcyh1cGRhdGUubGFuZSwgT2Zmc2NyZWVuTGFuZSk7XG4gICAgICB2YXIgaXNIaWRkZW5VcGRhdGUgPSB1cGRhdGVMYW5lICE9PSB1cGRhdGUubGFuZTsgLy8gQ2hlY2sgaWYgdGhpcyB1cGRhdGUgd2FzIG1hZGUgd2hpbGUgdGhlIHRyZWUgd2FzIGhpZGRlbi4gSWYgc28sIHRoZW5cbiAgICAgIC8vIGl0J3Mgbm90IGEgXCJiYXNlXCIgdXBkYXRlIGFuZCB3ZSBzaG91bGQgZGlzcmVnYXJkIHRoZSBleHRyYSBiYXNlIGxhbmVzXG4gICAgICAvLyB0aGF0IHdlcmUgYWRkZWQgdG8gcmVuZGVyTGFuZXMgd2hlbiB3ZSBlbnRlcmVkIHRoZSBPZmZzY3JlZW4gdHJlZS5cblxuICAgICAgdmFyIHNob3VsZFNraXBVcGRhdGUgPSBpc0hpZGRlblVwZGF0ZSA/ICFpc1N1YnNldE9mTGFuZXMoZ2V0V29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMoKSwgdXBkYXRlTGFuZSkgOiAhaXNTdWJzZXRPZkxhbmVzKHJlbmRlckxhbmVzLCB1cGRhdGVMYW5lKTtcblxuICAgICAgaWYgKHNob3VsZFNraXBVcGRhdGUpIHtcbiAgICAgICAgLy8gUHJpb3JpdHkgaXMgaW5zdWZmaWNpZW50LiBTa2lwIHRoaXMgdXBkYXRlLiBJZiB0aGlzIGlzIHRoZSBmaXJzdFxuICAgICAgICAvLyBza2lwcGVkIHVwZGF0ZSwgdGhlIHByZXZpb3VzIHVwZGF0ZS9zdGF0ZSBpcyB0aGUgbmV3IGJhc2VcbiAgICAgICAgLy8gdXBkYXRlL3N0YXRlLlxuICAgICAgICB2YXIgY2xvbmUgPSB7XG4gICAgICAgICAgbGFuZTogdXBkYXRlTGFuZSxcbiAgICAgICAgICB0YWc6IHVwZGF0ZS50YWcsXG4gICAgICAgICAgcGF5bG9hZDogdXBkYXRlLnBheWxvYWQsXG4gICAgICAgICAgY2FsbGJhY2s6IHVwZGF0ZS5jYWxsYmFjayxcbiAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKG5ld0xhc3RCYXNlVXBkYXRlID09PSBudWxsKSB7XG4gICAgICAgICAgbmV3Rmlyc3RCYXNlVXBkYXRlID0gbmV3TGFzdEJhc2VVcGRhdGUgPSBjbG9uZTtcbiAgICAgICAgICBuZXdCYXNlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdMYXN0QmFzZVVwZGF0ZSA9IG5ld0xhc3RCYXNlVXBkYXRlLm5leHQgPSBjbG9uZTtcbiAgICAgICAgfSAvLyBVcGRhdGUgdGhlIHJlbWFpbmluZyBwcmlvcml0eSBpbiB0aGUgcXVldWUuXG5cblxuICAgICAgICBuZXdMYW5lcyA9IG1lcmdlTGFuZXMobmV3TGFuZXMsIHVwZGF0ZUxhbmUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyB1cGRhdGUgZG9lcyBoYXZlIHN1ZmZpY2llbnQgcHJpb3JpdHkuXG4gICAgICAgIC8vIENoZWNrIGlmIHRoaXMgdXBkYXRlIGlzIHBhcnQgb2YgYSBwZW5kaW5nIGFzeW5jIGFjdGlvbi4gSWYgc28sXG4gICAgICAgIC8vIHdlJ2xsIG5lZWQgdG8gc3VzcGVuZCB1bnRpbCB0aGUgYWN0aW9uIGhhcyBmaW5pc2hlZCwgc28gdGhhdCBpdCdzXG4gICAgICAgIC8vIGJhdGNoZWQgdG9nZXRoZXIgd2l0aCBmdXR1cmUgdXBkYXRlcyBpbiB0aGUgc2FtZSBhY3Rpb24uXG4gICAgICAgIGlmICh1cGRhdGVMYW5lICE9PSBOb0xhbmUgJiYgdXBkYXRlTGFuZSA9PT0gcGVla0VudGFuZ2xlZEFjdGlvbkxhbmUoKSkge1xuICAgICAgICAgIGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5ld0xhc3RCYXNlVXBkYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9jbG9uZSA9IHtcbiAgICAgICAgICAgIC8vIFRoaXMgdXBkYXRlIGlzIGdvaW5nIHRvIGJlIGNvbW1pdHRlZCBzbyB3ZSBuZXZlciB3YW50IHVuY29tbWl0XG4gICAgICAgICAgICAvLyBpdC4gVXNpbmcgTm9MYW5lIHdvcmtzIGJlY2F1c2UgMCBpcyBhIHN1YnNldCBvZiBhbGwgYml0bWFza3MsIHNvXG4gICAgICAgICAgICAvLyB0aGlzIHdpbGwgbmV2ZXIgYmUgc2tpcHBlZCBieSB0aGUgY2hlY2sgYWJvdmUuXG4gICAgICAgICAgICBsYW5lOiBOb0xhbmUsXG4gICAgICAgICAgICB0YWc6IHVwZGF0ZS50YWcsXG4gICAgICAgICAgICBwYXlsb2FkOiB1cGRhdGUucGF5bG9hZCxcbiAgICAgICAgICAgIC8vIFdoZW4gdGhpcyB1cGRhdGUgaXMgcmViYXNlZCwgd2Ugc2hvdWxkIG5vdCBmaXJlIGl0c1xuICAgICAgICAgICAgLy8gY2FsbGJhY2sgYWdhaW4uXG4gICAgICAgICAgICBjYWxsYmFjazogbnVsbCxcbiAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICB9O1xuICAgICAgICAgIG5ld0xhc3RCYXNlVXBkYXRlID0gbmV3TGFzdEJhc2VVcGRhdGUubmV4dCA9IF9jbG9uZTtcbiAgICAgICAgfSAvLyBQcm9jZXNzIHRoaXMgdXBkYXRlLlxuXG5cbiAgICAgICAgbmV3U3RhdGUgPSBnZXRTdGF0ZUZyb21VcGRhdGUod29ya0luUHJvZ3Jlc3MsIHF1ZXVlLCB1cGRhdGUsIG5ld1N0YXRlLCBwcm9wcywgaW5zdGFuY2UpO1xuICAgICAgICB2YXIgY2FsbGJhY2sgPSB1cGRhdGUuY2FsbGJhY2s7XG5cbiAgICAgICAgaWYgKGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gQ2FsbGJhY2s7XG5cbiAgICAgICAgICBpZiAoaXNIaWRkZW5VcGRhdGUpIHtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFZpc2liaWxpdHk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGNhbGxiYWNrcyA9IHF1ZXVlLmNhbGxiYWNrcztcblxuICAgICAgICAgIGlmIChjYWxsYmFja3MgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHF1ZXVlLmNhbGxiYWNrcyA9IFtjYWxsYmFja107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gd2UgYmFpbCBvdXQgd2hlbiB3ZSBnZXQgYSBudWxsXG5cblxuICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG5cbiAgICAgIGlmICh1cGRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgcGVuZGluZ1F1ZXVlID0gcXVldWUuc2hhcmVkLnBlbmRpbmc7XG5cbiAgICAgICAgaWYgKHBlbmRpbmdRdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIGZyb20gaW5zaWRlIGEgcmVkdWNlci4gQWRkIHRoZSBuZXdcbiAgICAgICAgICAvLyBwZW5kaW5nIHVwZGF0ZXMgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdCBhbmQga2VlcCBwcm9jZXNzaW5nLlxuICAgICAgICAgIHZhciBfbGFzdFBlbmRpbmdVcGRhdGUgPSBwZW5kaW5nUXVldWU7IC8vIEludGVudGlvbmFsbHkgdW5zb3VuZC4gUGVuZGluZyB1cGRhdGVzIGZvcm0gYSBjaXJjdWxhciBsaXN0LCBidXQgd2VcbiAgICAgICAgICAvLyB1bnJhdmVsIHRoZW0gd2hlbiB0cmFuc2ZlcnJpbmcgdGhlbSB0byB0aGUgYmFzZSBxdWV1ZS5cblxuICAgICAgICAgIHZhciBfZmlyc3RQZW5kaW5nVXBkYXRlID0gX2xhc3RQZW5kaW5nVXBkYXRlLm5leHQ7XG4gICAgICAgICAgX2xhc3RQZW5kaW5nVXBkYXRlLm5leHQgPSBudWxsO1xuICAgICAgICAgIHVwZGF0ZSA9IF9maXJzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgICAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBfbGFzdFBlbmRpbmdVcGRhdGU7XG4gICAgICAgICAgcXVldWUuc2hhcmVkLnBlbmRpbmcgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgICBpZiAobmV3TGFzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgIG5ld0Jhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIH1cblxuICAgIHF1ZXVlLmJhc2VTdGF0ZSA9IG5ld0Jhc2VTdGF0ZTtcbiAgICBxdWV1ZS5maXJzdEJhc2VVcGRhdGUgPSBuZXdGaXJzdEJhc2VVcGRhdGU7XG4gICAgcXVldWUubGFzdEJhc2VVcGRhdGUgPSBuZXdMYXN0QmFzZVVwZGF0ZTtcblxuICAgIGlmIChmaXJzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgIC8vIGBxdWV1ZS5sYW5lc2AgaXMgdXNlZCBmb3IgZW50YW5nbGluZyB0cmFuc2l0aW9ucy4gV2UgY2FuIHNldCBpdCBiYWNrIHRvXG4gICAgICAvLyB6ZXJvIG9uY2UgdGhlIHF1ZXVlIGlzIGVtcHR5LlxuICAgICAgcXVldWUuc2hhcmVkLmxhbmVzID0gTm9MYW5lcztcbiAgICB9IC8vIFNldCB0aGUgcmVtYWluaW5nIGV4cGlyYXRpb24gdGltZSB0byBiZSB3aGF0ZXZlciBpcyByZW1haW5pbmcgaW4gdGhlIHF1ZXVlLlxuICAgIC8vIFRoaXMgc2hvdWxkIGJlIGZpbmUgYmVjYXVzZSB0aGUgb25seSB0d28gb3RoZXIgdGhpbmdzIHRoYXQgY29udHJpYnV0ZSB0b1xuICAgIC8vIGV4cGlyYXRpb24gdGltZSBhcmUgcHJvcHMgYW5kIGNvbnRleHQuIFdlJ3JlIGFscmVhZHkgaW4gdGhlIG1pZGRsZSBvZiB0aGVcbiAgICAvLyBiZWdpbiBwaGFzZSBieSB0aGUgdGltZSB3ZSBzdGFydCBwcm9jZXNzaW5nIHRoZSBxdWV1ZSwgc28gd2UndmUgYWxyZWFkeVxuICAgIC8vIGRlYWx0IHdpdGggdGhlIHByb3BzLiBDb250ZXh0IGluIGNvbXBvbmVudHMgdGhhdCBzcGVjaWZ5XG4gICAgLy8gc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHRyaWNreTsgYnV0IHdlJ2xsIGhhdmUgdG8gYWNjb3VudCBmb3JcbiAgICAvLyB0aGF0IHJlZ2FyZGxlc3MuXG5cblxuICAgIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXMobmV3TGFuZXMpO1xuICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbmV3TGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG5cbiAge1xuICAgIGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9IG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsbENhbGxiYWNrKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQgcGFzc2VkIGFzIGNhbGxiYWNrLiBFeHBlY3RlZCBhIGZ1bmN0aW9uLiBJbnN0ZWFkICcgKyAoXCJyZWNlaXZlZDogXCIgKyBjYWxsYmFjaykpO1xuICB9XG5cbiAgY2FsbGJhY2suY2FsbChjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKSB7XG4gIGhhc0ZvcmNlVXBkYXRlID0gZmFsc2U7XG59XG5mdW5jdGlvbiBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkge1xuICByZXR1cm4gaGFzRm9yY2VVcGRhdGU7XG59XG5mdW5jdGlvbiBkZWZlckhpZGRlbkNhbGxiYWNrcyh1cGRhdGVRdWV1ZSkge1xuICAvLyBXaGVuIGFuIHVwZGF0ZSBmaW5pc2hlcyBvbiBhIGhpZGRlbiBjb21wb25lbnQsIGl0cyBjYWxsYmFjayBzaG91bGQgbm90XG4gIC8vIGJlIGZpcmVkIHVudGlsL3VubGVzcyB0aGUgY29tcG9uZW50IGlzIG1hZGUgdmlzaWJsZSBhZ2Fpbi4gU3Rhc2ggdGhlXG4gIC8vIGNhbGxiYWNrIG9uIHRoZSBzaGFyZWQgcXVldWUgb2JqZWN0IHNvIGl0IGNhbiBiZSBmaXJlZCBsYXRlci5cbiAgdmFyIG5ld0hpZGRlbkNhbGxiYWNrcyA9IHVwZGF0ZVF1ZXVlLmNhbGxiYWNrcztcblxuICBpZiAobmV3SGlkZGVuQ2FsbGJhY2tzICE9PSBudWxsKSB7XG4gICAgdmFyIGV4aXN0aW5nSGlkZGVuQ2FsbGJhY2tzID0gdXBkYXRlUXVldWUuc2hhcmVkLmhpZGRlbkNhbGxiYWNrcztcblxuICAgIGlmIChleGlzdGluZ0hpZGRlbkNhbGxiYWNrcyA9PT0gbnVsbCkge1xuICAgICAgdXBkYXRlUXVldWUuc2hhcmVkLmhpZGRlbkNhbGxiYWNrcyA9IG5ld0hpZGRlbkNhbGxiYWNrcztcbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlUXVldWUuc2hhcmVkLmhpZGRlbkNhbGxiYWNrcyA9IGV4aXN0aW5nSGlkZGVuQ2FsbGJhY2tzLmNvbmNhdChuZXdIaWRkZW5DYWxsYmFja3MpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gY29tbWl0SGlkZGVuQ2FsbGJhY2tzKHVwZGF0ZVF1ZXVlLCBjb250ZXh0KSB7XG4gIC8vIFRoaXMgY29tcG9uZW50IGlzIHN3aXRjaGluZyBmcm9tIGhpZGRlbiAtPiB2aXNpYmxlLiBDb21taXQgYW55IGNhbGxiYWNrc1xuICAvLyB0aGF0IHdlcmUgcHJldmlvdXNseSBkZWZlcnJlZC5cbiAgdmFyIGhpZGRlbkNhbGxiYWNrcyA9IHVwZGF0ZVF1ZXVlLnNoYXJlZC5oaWRkZW5DYWxsYmFja3M7XG5cbiAgaWYgKGhpZGRlbkNhbGxiYWNrcyAhPT0gbnVsbCkge1xuICAgIHVwZGF0ZVF1ZXVlLnNoYXJlZC5oaWRkZW5DYWxsYmFja3MgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaWRkZW5DYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjYWxsYmFjayA9IGhpZGRlbkNhbGxiYWNrc1tpXTtcbiAgICAgIGNhbGxDYWxsYmFjayhjYWxsYmFjaywgY29udGV4dCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjb21taXRDYWxsYmFja3ModXBkYXRlUXVldWUsIGNvbnRleHQpIHtcbiAgdmFyIGNhbGxiYWNrcyA9IHVwZGF0ZVF1ZXVlLmNhbGxiYWNrcztcblxuICBpZiAoY2FsbGJhY2tzICE9PSBudWxsKSB7XG4gICAgdXBkYXRlUXVldWUuY2FsbGJhY2tzID0gbnVsbDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFja3NbaV07XG4gICAgICBjYWxsQ2FsbGJhY2soY2FsbGJhY2ssIGNvbnRleHQpO1xuICAgIH1cbiAgfVxufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIFBlcmZvcm1zIGVxdWFsaXR5IGJ5IGl0ZXJhdGluZyB0aHJvdWdoIGtleXMgb24gYW4gb2JqZWN0IGFuZCByZXR1cm5pbmcgZmFsc2VcbiAqIHdoZW4gYW55IGtleSBoYXMgdmFsdWVzIHdoaWNoIGFyZSBub3Qgc3RyaWN0bHkgZXF1YWwgYmV0d2VlbiB0aGUgYXJndW1lbnRzLlxuICogUmV0dXJucyB0cnVlIHdoZW4gdGhlIHZhbHVlcyBvZiBhbGwga2V5cyBhcmUgc3RyaWN0bHkgZXF1YWwuXG4gKi9cblxuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKG9iamVjdElzKG9iakEsIG9iakIpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iakEgIT09ICdvYmplY3QnIHx8IG9iakEgPT09IG51bGwgfHwgdHlwZW9mIG9iakIgIT09ICdvYmplY3QnIHx8IG9iakIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIga2V5c0EgPSBPYmplY3Qua2V5cyhvYmpBKTtcbiAgdmFyIGtleXNCID0gT2JqZWN0LmtleXMob2JqQik7XG5cbiAgaWYgKGtleXNBLmxlbmd0aCAhPT0ga2V5c0IubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIFRlc3QgZm9yIEEncyBrZXlzIGRpZmZlcmVudCBmcm9tIEIuXG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXNBLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzQVtpXTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChvYmpCLCBjdXJyZW50S2V5KSB8fCAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGxvc3QgcmVmaW5lbWVudCBvZiBgb2JqQmBcbiAgICAhb2JqZWN0SXMob2JqQVtjdXJyZW50S2V5XSwgb2JqQltjdXJyZW50S2V5XSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzID0ge1xuICByZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5nczogZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge30sXG4gIGZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBmdW5jdGlvbiAoKSB7fSxcbiAgcmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmc6IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHt9LFxuICBmbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nOiBmdW5jdGlvbiAoKSB7fSxcbiAgZGlzY2FyZFBlbmRpbmdXYXJuaW5nczogZnVuY3Rpb24gKCkge31cbn07XG5cbntcbiAgdmFyIGZpbmRTdHJpY3RSb290ID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgdmFyIG1heWJlU3RyaWN0Um9vdCA9IG51bGw7XG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcblxuICAgIHdoaWxlIChub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgICBtYXliZVN0cmljdFJvb3QgPSBub2RlO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heWJlU3RyaWN0Um9vdDtcbiAgfTtcblxuICB2YXIgc2V0VG9Tb3J0ZWRTdHJpbmcgPSBmdW5jdGlvbiAoc2V0KSB7XG4gICAgdmFyIGFycmF5ID0gW107XG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICBhcnJheS5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYXJyYXkuc29ydCgpLmpvaW4oJywgJyk7XG4gIH07XG5cbiAgdmFyIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgdmFyIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgdmFyIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107IC8vIFRyYWNrcyBjb21wb25lbnRzIHdlIGhhdmUgYWxyZWFkeSB3YXJuZWQgYWJvdXQuXG5cbiAgdmFyIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMgPSBuZXcgU2V0KCk7XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7XG4gICAgLy8gRGVkdXBlIHN0cmF0ZWd5OiBXYXJuIG9uY2UgcGVyIGNvbXBvbmVudC5cbiAgICBpZiAoZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5oYXMoZmliZXIudHlwZSkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyAmJiAvLyBEb24ndCB3YXJuIGFib3V0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cy5cbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cblxuICAgIGlmIChmaWJlci5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSAmJiB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcy5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cblxuICAgIGlmIChmaWJlci5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSAmJiB0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlICYmIHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFdlIGRvIGFuIGluaXRpYWwgcGFzcyB0byBnYXRoZXIgY29tcG9uZW50IG5hbWVzXG4gICAgdmFyIGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgIH1cblxuICAgIHZhciBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyKSB7XG4gICAgICAgIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICB9IC8vIEZpbmFsbHksIHdlIGZsdXNoIGFsbCB0aGUgd2FybmluZ3NcbiAgICAvLyBVTlNBRkVfIG9uZXMgYmVmb3JlIHRoZSBkZXByZWNhdGVkIG9uZXMsIHNpbmNlIHRoZXknbGwgYmUgJ2xvdWRlcidcblxuXG4gICAgaWYgKFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcoVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzKTtcblxuICAgICAgZXJyb3IoJ1VzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkIGFuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGNvZGUgd2l0aCBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkTW91bnQsIGFuZCBzZXQgaW5pdGlhbCBzdGF0ZSBpbiB0aGUgY29uc3RydWN0b3IuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBzb3J0ZWROYW1lcyk7XG4gICAgfVxuXG4gICAgaWYgKFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBfc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzKTtcblxuICAgICAgZXJyb3IoJ1VzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGluIHN0cmljdCBtb2RlIGlzIG5vdCByZWNvbW1lbmRlZCAnICsgJ2FuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbicgKyBcIiogSWYgeW91J3JlIHVwZGF0aW5nIHN0YXRlIHdoZW5ldmVyIHByb3BzIGNoYW5nZSwgXCIgKyAncmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBtZW1vaXphdGlvbiB0ZWNobmlxdWVzIG9yIG1vdmUgaXQgdG8gJyArICdzdGF0aWMgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiBMZWFybiBtb3JlIGF0OiBodHRwczovL3JlYWN0LmRldi9saW5rL2Rlcml2ZWQtc3RhdGVcXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9zb3J0ZWROYW1lcyk7XG4gICAgfVxuXG4gICAgaWYgKFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuc2l6ZSA+IDApIHtcbiAgICAgIHZhciBfc29ydGVkTmFtZXMyID0gc2V0VG9Tb3J0ZWRTdHJpbmcoVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyk7XG5cbiAgICAgIGVycm9yKCdVc2luZyBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSBpbiBzdHJpY3QgbW9kZSBpcyBub3QgcmVjb21tZW5kZWQgJyArICdhbmQgbWF5IGluZGljYXRlIGJ1Z3MgaW4geW91ciBjb2RlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9zb3J0ZWROYW1lczIpO1xuICAgIH1cblxuICAgIGlmIChjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIF9zb3J0ZWROYW1lczMgPSBzZXRUb1NvcnRlZFN0cmluZyhjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyk7XG5cbiAgICAgIHdhcm4oJ2NvbXBvbmVudFdpbGxNb3VudCBoYXMgYmVlbiByZW5hbWVkLCBhbmQgaXMgbm90IHJlY29tbWVuZGVkIGZvciB1c2UuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGNvZGUgd2l0aCBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkTW91bnQsIGFuZCBzZXQgaW5pdGlhbCBzdGF0ZSBpbiB0aGUgY29uc3RydWN0b3IuXFxuJyArICcqIFJlbmFtZSBjb21wb25lbnRXaWxsTW91bnQgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCB0byBzdXBwcmVzcyAnICsgJ3RoaXMgd2FybmluZyBpbiBub24tc3RyaWN0IG1vZGUuIEluIFJlYWN0IDE4LngsIG9ubHkgdGhlIFVOU0FGRV8gbmFtZSB3aWxsIHdvcmsuICcgKyAnVG8gcmVuYW1lIGFsbCBkZXByZWNhdGVkIGxpZmVjeWNsZXMgdG8gdGhlaXIgbmV3IG5hbWVzLCB5b3UgY2FuIHJ1biAnICsgJ2BucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX3NvcnRlZE5hbWVzMyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIF9zb3J0ZWROYW1lczQgPSBzZXRUb1NvcnRlZFN0cmluZyhjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMpO1xuXG4gICAgICB3YXJuKCdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuJyArIFwiKiBJZiB5b3UncmUgdXBkYXRpbmcgc3RhdGUgd2hlbmV2ZXIgcHJvcHMgY2hhbmdlLCByZWZhY3RvciB5b3VyIFwiICsgJ2NvZGUgdG8gdXNlIG1lbW9pemF0aW9uIHRlY2huaXF1ZXMgb3IgbW92ZSBpdCB0byAnICsgJ3N0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuIExlYXJuIG1vcmUgYXQ6IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvZGVyaXZlZC1zdGF0ZVxcbicgKyAnKiBSZW5hbWUgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyB0byBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyB0byBzdXBwcmVzcyAnICsgJ3RoaXMgd2FybmluZyBpbiBub24tc3RyaWN0IG1vZGUuIEluIFJlYWN0IDE4LngsIG9ubHkgdGhlIFVOU0FGRV8gbmFtZSB3aWxsIHdvcmsuICcgKyAnVG8gcmVuYW1lIGFsbCBkZXByZWNhdGVkIGxpZmVjeWNsZXMgdG8gdGhlaXIgbmV3IG5hbWVzLCB5b3UgY2FuIHJ1biAnICsgJ2BucHggcmVhY3QtY29kZW1vZCByZW5hbWUtdW5zYWZlLWxpZmVjeWNsZXNgIGluIHlvdXIgcHJvamVjdCBzb3VyY2UgZm9sZGVyLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX3NvcnRlZE5hbWVzNCk7XG4gICAgfVxuXG4gICAgaWYgKGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIF9zb3J0ZWROYW1lczUgPSBzZXRUb1NvcnRlZFN0cmluZyhjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMpO1xuXG4gICAgICB3YXJuKCdjb21wb25lbnRXaWxsVXBkYXRlIGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuJyArICcqIFJlbmFtZSBjb21wb25lbnRXaWxsVXBkYXRlIHRvIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIHRvIHN1cHByZXNzICcgKyAndGhpcyB3YXJuaW5nIGluIG5vbi1zdHJpY3QgbW9kZS4gSW4gUmVhY3QgMTgueCwgb25seSB0aGUgVU5TQUZFXyBuYW1lIHdpbGwgd29yay4gJyArICdUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuICcgKyAnYG5weCByZWFjdC1jb2RlbW9kIHJlbmFtZS11bnNhZmUtbGlmZWN5Y2xlc2AgaW4geW91ciBwcm9qZWN0IHNvdXJjZSBmb2xkZXIuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBfc29ydGVkTmFtZXM1KTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyA9IG5ldyBNYXAoKTsgLy8gVHJhY2tzIGNvbXBvbmVudHMgd2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBhYm91dC5cblxuICB2YXIgZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dCA9IG5ldyBTZXQoKTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyA9IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHtcbiAgICB2YXIgc3RyaWN0Um9vdCA9IGZpbmRTdHJpY3RSb290KGZpYmVyKTtcblxuICAgIGlmIChzdHJpY3RSb290ID09PSBudWxsKSB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgdG8gZmluZCBhIFN0cmljdE1vZGUgY29tcG9uZW50IGluIGEgc3RyaWN0IG1vZGUgdHJlZS4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBEZWR1cCBzdHJhdGVneTogV2FybiBvbmNlIHBlciBjb21wb25lbnQuXG5cblxuICAgIGlmIChkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmhhcyhmaWJlci50eXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB3YXJuaW5nc0ZvclJvb3QgPSBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuZ2V0KHN0cmljdFJvb3QpO1xuXG4gICAgaWYgKGZpYmVyLnR5cGUuY29udGV4dFR5cGVzICE9IG51bGwgfHwgZmliZXIudHlwZS5jaGlsZENvbnRleHRUeXBlcyAhPSBudWxsIHx8IGluc3RhbmNlICE9PSBudWxsICYmIHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh3YXJuaW5nc0ZvclJvb3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB3YXJuaW5nc0ZvclJvb3QgPSBbXTtcbiAgICAgICAgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLnNldChzdHJpY3RSb290LCB3YXJuaW5nc0ZvclJvb3QpO1xuICAgICAgfVxuXG4gICAgICB3YXJuaW5nc0ZvclJvb3QucHVzaChmaWJlcik7XG4gICAgfVxuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nLmZvckVhY2goZnVuY3Rpb24gKGZpYmVyQXJyYXksIHN0cmljdFJvb3QpIHtcbiAgICAgIGlmIChmaWJlckFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBmaXJzdEZpYmVyID0gZmliZXJBcnJheVswXTtcbiAgICAgIHZhciB1bmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcbiAgICAgIGZpYmVyQXJyYXkuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgdW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0TGVnYWN5Q29udGV4dC5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHZhciBzb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKHVuaXF1ZU5hbWVzKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihmaXJzdEZpYmVyKTtcblxuICAgICAgICBlcnJvcignTGVnYWN5IGNvbnRleHQgQVBJIGhhcyBiZWVuIGRldGVjdGVkIHdpdGhpbiBhIHN0cmljdC1tb2RlIHRyZWUuJyArICdcXG5cXG5UaGUgb2xkIEFQSSB3aWxsIGJlIHN1cHBvcnRlZCBpbiBhbGwgMTYueCByZWxlYXNlcywgYnV0IGFwcGxpY2F0aW9ucyAnICsgJ3VzaW5nIGl0IHNob3VsZCBtaWdyYXRlIHRvIHRoZSBuZXcgdmVyc2lvbi4nICsgJ1xcblxcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycgKyAnXFxuXFxuTGVhcm4gbW9yZSBhYm91dCB0aGlzIHdhcm5pbmcgaGVyZTogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9sZWdhY3ktY29udGV4dCcsIHNvcnRlZE5hbWVzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHJlc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmRpc2NhcmRQZW5kaW5nV2FybmluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyA9IG5ldyBNYXAoKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0VGhlbmFibGVzRnJvbVN0YXRlKHN0YXRlKSB7XG4gIHtcbiAgICB2YXIgZGV2U3RhdGUgPSBzdGF0ZTtcbiAgICByZXR1cm4gZGV2U3RhdGUudGhlbmFibGVzO1xuICB9XG59IC8vIEFuIGVycm9yIHRoYXQgaXMgdGhyb3duIChlLmcuIGJ5IGB1c2VgKSB0byB0cmlnZ2VyIFN1c3BlbnNlLiBJZiB3ZVxuLy8gZGV0ZWN0IHRoaXMgaXMgY2F1Z2h0IGJ5IHVzZXJzcGFjZSwgd2UnbGwgbG9nIGEgd2FybmluZyBpbiBkZXZlbG9wbWVudC5cblxuXG52YXIgU3VzcGVuc2VFeGNlcHRpb24gPSBuZXcgRXJyb3IoXCJTdXNwZW5zZSBFeGNlcHRpb246IFRoaXMgaXMgbm90IGEgcmVhbCBlcnJvciEgSXQncyBhbiBpbXBsZW1lbnRhdGlvbiBcIiArICdkZXRhaWwgb2YgYHVzZWAgdG8gaW50ZXJydXB0IHRoZSBjdXJyZW50IHJlbmRlci4gWW91IG11c3QgZWl0aGVyICcgKyAncmV0aHJvdyBpdCBpbW1lZGlhdGVseSwgb3IgbW92ZSB0aGUgYHVzZWAgY2FsbCBvdXRzaWRlIG9mIHRoZSAnICsgJ2B0cnkvY2F0Y2hgIGJsb2NrLiBDYXB0dXJpbmcgd2l0aG91dCByZXRocm93aW5nIHdpbGwgbGVhZCB0byAnICsgJ3VuZXhwZWN0ZWQgYmVoYXZpb3IuXFxuXFxuJyArICdUbyBoYW5kbGUgYXN5bmMgZXJyb3JzLCB3cmFwIHlvdXIgY29tcG9uZW50IGluIGFuIGVycm9yIGJvdW5kYXJ5LCBvciAnICsgXCJjYWxsIHRoZSBwcm9taXNlJ3MgYC5jYXRjaGAgbWV0aG9kIGFuZCBwYXNzIHRoZSByZXN1bHQgdG8gYHVzZWBcIik7XG52YXIgU3VzcGVuc2V5Q29tbWl0RXhjZXB0aW9uID0gbmV3IEVycm9yKCdTdXNwZW5zZSBFeGNlcHRpb246IFRoaXMgaXMgbm90IGEgcmVhbCBlcnJvciwgYW5kIHNob3VsZCBub3QgbGVhayBpbnRvICcgKyBcInVzZXJzcGFjZS4gSWYgeW91J3JlIHNlZWluZyB0aGlzLCBpdCdzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC5cIik7IC8vIFRoaXMgaXMgYSBub29wIHRoZW5hYmxlIHRoYXQgd2UgdXNlIHRvIHRyaWdnZXIgYSBmYWxsYmFjayBpbiB0aHJvd0V4Y2VwdGlvbi5cbi8vIFRPRE86IEl0IHdvdWxkIGJlIGJldHRlciB0byByZWZhY3RvciB0aHJvd0V4Y2VwdGlvbiBpbnRvIG11bHRpcGxlIGZ1bmN0aW9uc1xuLy8gc28gd2UgY2FuIHRyaWdnZXIgYSBmYWxsYmFjayBkaXJlY3RseSB3aXRob3V0IGhhdmluZyB0byBjaGVjayB0aGUgdHlwZS4gQnV0XG4vLyBmb3Igbm93IHRoaXMgd2lsbCBkby5cblxudmFyIG5vb3BTdXNwZW5zZXlDb21taXRUaGVuYWJsZSA9IHtcbiAgdGhlbjogZnVuY3Rpb24gKCkge1xuICAgIHtcbiAgICAgIGVycm9yKCdJbnRlcm5hbCBSZWFjdCBlcnJvcjogQSBsaXN0ZW5lciB3YXMgdW5leHBlY3RlZGx5IGF0dGFjaGVkIHRvIGEgJyArICdcIm5vb3BcIiB0aGVuYWJsZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59O1xuZnVuY3Rpb24gY3JlYXRlVGhlbmFibGVTdGF0ZSgpIHtcbiAgLy8gVGhlIFRoZW5hYmxlU3RhdGUgaXMgY3JlYXRlZCB0aGUgZmlyc3QgdGltZSBhIGNvbXBvbmVudCBzdXNwZW5kcy4gSWYgaXRcbiAgLy8gc3VzcGVuZHMgYWdhaW4sIHdlJ2xsIHJldXNlIHRoZSBzYW1lIHN0YXRlLlxuICB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGRpZFdhcm5BYm91dFVuY2FjaGVkUHJvbWlzZTogZmFsc2UsXG4gICAgICB0aGVuYWJsZXM6IFtdXG4gICAgfTtcbiAgfVxufVxuZnVuY3Rpb24gaXNUaGVuYWJsZVJlc29sdmVkKHRoZW5hYmxlKSB7XG4gIHZhciBzdGF0dXMgPSB0aGVuYWJsZS5zdGF0dXM7XG4gIHJldHVybiBzdGF0dXMgPT09ICdmdWxmaWxsZWQnIHx8IHN0YXR1cyA9PT0gJ3JlamVjdGVkJztcbn1cblxuZnVuY3Rpb24gbm9vcCQxKCkge31cblxuZnVuY3Rpb24gdHJhY2tVc2VkVGhlbmFibGUodGhlbmFibGVTdGF0ZSwgdGhlbmFibGUsIGluZGV4KSB7XG4gIGlmIChSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSAhPT0gbnVsbCkge1xuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmRpZFVzZVByb21pc2UgPSB0cnVlO1xuICB9XG5cbiAgdmFyIHRyYWNrZWRUaGVuYWJsZXMgPSBnZXRUaGVuYWJsZXNGcm9tU3RhdGUodGhlbmFibGVTdGF0ZSk7XG4gIHZhciBwcmV2aW91cyA9IHRyYWNrZWRUaGVuYWJsZXNbaW5kZXhdO1xuXG4gIGlmIChwcmV2aW91cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdHJhY2tlZFRoZW5hYmxlcy5wdXNoKHRoZW5hYmxlKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAocHJldmlvdXMgIT09IHRoZW5hYmxlKSB7XG4gICAgICAvLyBSZXVzZSB0aGUgcHJldmlvdXMgdGhlbmFibGUsIGFuZCBkcm9wIHRoZSBuZXcgb25lLiBXZSBjYW4gYXNzdW1lXG4gICAgICAvLyB0aGV5IHJlcHJlc2VudCB0aGUgc2FtZSB2YWx1ZSwgYmVjYXVzZSBjb21wb25lbnRzIGFyZSBpZGVtcG90ZW50LlxuICAgICAge1xuICAgICAgICB2YXIgdGhlbmFibGVTdGF0ZURldiA9IHRoZW5hYmxlU3RhdGU7XG5cbiAgICAgICAgaWYgKCF0aGVuYWJsZVN0YXRlRGV2LmRpZFdhcm5BYm91dFVuY2FjaGVkUHJvbWlzZSkge1xuICAgICAgICAgIC8vIFdlIHNob3VsZCBvbmx5IHdhcm4gdGhlIGZpcnN0IHRpbWUgYW4gdW5jYWNoZWQgdGhlbmFibGUgaXNcbiAgICAgICAgICAvLyBkaXNjb3ZlcmVkIHBlciBjb21wb25lbnQsIGJlY2F1c2UgaWYgdGhlcmUgYXJlIG11bHRpcGxlLCB0aGVcbiAgICAgICAgICAvLyBzdWJzZXF1ZW50IG9uZXMgYXJlIGxpa2VseSBkZXJpdmVkIGZyb20gdGhlIGZpcnN0LlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gV2UgdHJhY2sgdGhpcyBvbiB0aGUgdGhlbmFibGVTdGF0ZSBpbnN0ZWFkIG9mIGRlZHVwaW5nIHVzaW5nIHRoZVxuICAgICAgICAgIC8vIGNvbXBvbmVudCBuYW1lIGxpa2Ugd2UgdXN1YWxseSBkbywgYmVjYXVzZSBpbiB0aGUgY2FzZSBvZiBhXG4gICAgICAgICAgLy8gcHJvbWlzZS1hcy1SZWFjdC1ub2RlLCB0aGUgb3duZXIgY29tcG9uZW50IGlzIGxpa2VseSBkaWZmZXJlbnQgZnJvbVxuICAgICAgICAgIC8vIHRoZSBwYXJlbnQgdGhhdCdzIGN1cnJlbnRseSBiZWluZyByZWNvbmNpbGVkLiBXZSdkIGhhdmUgdG8gdHJhY2tcbiAgICAgICAgICAvLyB0aGUgb3duZXIgdXNpbmcgc3RhdGUsIHdoaWNoIHdlJ3JlIHRyeWluZyB0byBtb3ZlIGF3YXkgZnJvbS4gVGhvdWdoXG4gICAgICAgICAgLy8gc2luY2UgdGhpcyBpcyBkZXYtb25seSwgbWF5YmUgdGhhdCdkIGJlIE9LLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gSG93ZXZlciwgYW5vdGhlciBiZW5lZml0IG9mIGRvaW5nIGl0IHRoaXMgd2F5IGlzIHdlIG1pZ2h0XG4gICAgICAgICAgLy8gZXZlbnR1YWxseSBoYXZlIGEgdGhlbmFibGVTdGF0ZSBwZXIgbWVtby9Gb3JnZXQgYm91bmRhcnkgaW5zdGVhZFxuICAgICAgICAgIC8vIG9mIHBlciBjb21wb25lbnQsIHNvIHRoaXMgd291bGQgYWxsb3cgdXMgdG8gaGF2ZSBtb3JlXG4gICAgICAgICAgLy8gZ3JhbnVsYXIgd2FybmluZ3MuXG4gICAgICAgICAgdGhlbmFibGVTdGF0ZURldi5kaWRXYXJuQWJvdXRVbmNhY2hlZFByb21pc2UgPSB0cnVlOyAvLyBUT0RPOiBUaGlzIHdhcm5pbmcgc2hvdWxkIGxpbmsgdG8gYSBjb3JyZXNwb25kaW5nIGRvY3MgcGFnZS5cblxuICAgICAgICAgIGVycm9yKCdBIGNvbXBvbmVudCB3YXMgc3VzcGVuZGVkIGJ5IGFuIHVuY2FjaGVkIHByb21pc2UuIENyZWF0aW5nICcgKyAncHJvbWlzZXMgaW5zaWRlIGEgQ2xpZW50IENvbXBvbmVudCBvciBob29rIGlzIG5vdCB5ZXQgJyArICdzdXBwb3J0ZWQsIGV4Y2VwdCB2aWEgYSBTdXNwZW5zZS1jb21wYXRpYmxlIGxpYnJhcnkgb3IgZnJhbWV3b3JrLicpO1xuICAgICAgICB9XG4gICAgICB9IC8vIEF2b2lkIGFuIHVuaGFuZGxlZCByZWplY3Rpb24gZXJyb3JzIGZvciB0aGUgUHJvbWlzZXMgdGhhdCB3ZSdsbFxuICAgICAgLy8gaW50ZW50aW9uYWxseSBpZ25vcmUuXG5cblxuICAgICAgdGhlbmFibGUudGhlbihub29wJDEsIG5vb3AkMSk7XG4gICAgICB0aGVuYWJsZSA9IHByZXZpb3VzO1xuICAgIH1cbiAgfSAvLyBXZSB1c2UgYW4gZXhwYW5kbyB0byB0cmFjayB0aGUgc3RhdHVzIGFuZCByZXN1bHQgb2YgYSB0aGVuYWJsZSBzbyB0aGF0IHdlXG4gIC8vIGNhbiBzeW5jaHJvbm91c2x5IHVud3JhcCB0aGUgdmFsdWUuIFRoaW5rIG9mIHRoaXMgYXMgYW4gZXh0ZW5zaW9uIG9mIHRoZVxuICAvLyBQcm9taXNlIEFQSSwgb3IgYSBjdXN0b20gaW50ZXJmYWNlIHRoYXQgaXMgYSBzdXBlcnNldCBvZiBUaGVuYWJsZS5cbiAgLy9cbiAgLy8gSWYgdGhlIHRoZW5hYmxlIGRvZXNuJ3QgaGF2ZSBhIHN0YXR1cywgc2V0IGl0IHRvIFwicGVuZGluZ1wiIGFuZCBhdHRhY2hcbiAgLy8gYSBsaXN0ZW5lciB0aGF0IHdpbGwgdXBkYXRlIGl0cyBzdGF0dXMgYW5kIHJlc3VsdCB3aGVuIGl0IHJlc29sdmVzLlxuXG5cbiAgc3dpdGNoICh0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICBjYXNlICdmdWxmaWxsZWQnOlxuICAgICAge1xuICAgICAgICB2YXIgZnVsZmlsbGVkVmFsdWUgPSB0aGVuYWJsZS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIGZ1bGZpbGxlZFZhbHVlO1xuICAgICAgfVxuXG4gICAgY2FzZSAncmVqZWN0ZWQnOlxuICAgICAge1xuICAgICAgICB2YXIgcmVqZWN0ZWRFcnJvciA9IHRoZW5hYmxlLnJlYXNvbjtcbiAgICAgICAgY2hlY2tJZlVzZVdyYXBwZWRJbkFzeW5jQ2F0Y2gocmVqZWN0ZWRFcnJvcik7XG4gICAgICAgIHRocm93IHJlamVjdGVkRXJyb3I7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIHRoZW5hYmxlLnN0YXR1cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyBPbmx5IGluc3RydW1lbnQgdGhlIHRoZW5hYmxlIGlmIHRoZSBzdGF0dXMgaWYgbm90IGRlZmluZWQuIElmXG4gICAgICAgICAgLy8gaXQncyBkZWZpbmVkLCBidXQgYW4gdW5rbm93biB2YWx1ZSwgYXNzdW1lIGl0J3MgYmVlbiBpbnN0cnVtZW50ZWQgYnlcbiAgICAgICAgICAvLyBzb21lIGN1c3RvbSB1c2Vyc3BhY2UgaW1wbGVtZW50YXRpb24uIFdlIHRyZWF0IGl0IGFzIFwicGVuZGluZ1wiLlxuICAgICAgICAgIC8vIEF0dGFjaCBhIGR1bW15IGxpc3RlbmVyLCB0byBlbnN1cmUgdGhhdCBhbnkgbGF6eSBpbml0aWFsaXphdGlvbiBjYW5cbiAgICAgICAgICAvLyBoYXBwZW4uIEZsaWdodCBsYXppbHkgcGFyc2VzIEpTT04gd2hlbiB0aGUgdmFsdWUgaXMgYWN0dWFsbHkgYXdhaXRlZC5cbiAgICAgICAgICB0aGVuYWJsZS50aGVuKG5vb3AkMSwgbm9vcCQxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGFuIHVuY2FjaGVkIHRoZW5hYmxlIHRoYXQgd2UgaGF2ZW4ndCBzZWVuIGJlZm9yZS5cbiAgICAgICAgICAvLyBEZXRlY3QgaW5maW5pdGUgcGluZyBsb29wcyBjYXVzZWQgYnkgdW5jYWNoZWQgcHJvbWlzZXMuXG4gICAgICAgICAgdmFyIHJvb3QgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTtcblxuICAgICAgICAgIGlmIChyb290ICE9PSBudWxsICYmIHJvb3Quc2hlbGxTdXNwZW5kQ291bnRlciA+IDEwMCkge1xuICAgICAgICAgICAgLy8gVGhpcyByb290IGhhcyBzdXNwZW5kZWQgcmVwZWF0ZWRseSBpbiB0aGUgc2hlbGwgd2l0aG91dCBtYWtpbmcgYW55XG4gICAgICAgICAgICAvLyBwcm9ncmVzcyAoaS5lLiBjb21taXR0aW5nIHNvbWV0aGluZykuIFRoaXMgaXMgaGlnaGx5IHN1Z2dlc3RpdmUgb2ZcbiAgICAgICAgICAgIC8vIGFuIGluZmluaXRlIHBpbmcgbG9vcCwgb2Z0ZW4gY2F1c2VkIGJ5IGFuIGFjY2lkZW50YWwgQXN5bmMgQ2xpZW50XG4gICAgICAgICAgICAvLyBDb21wb25lbnQuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gRHVyaW5nIGEgdHJhbnNpdGlvbiwgd2UgY2FuIHN1c3BlbmQgdGhlIHdvcmsgbG9vcCB1bnRpbCB0aGUgcHJvbWlzZVxuICAgICAgICAgICAgLy8gdG8gcmVzb2x2ZSwgYnV0IHRoaXMgaXMgYSBzeW5jIHJlbmRlciwgc28gdGhhdCdzIG5vdCBhbiBvcHRpb24uIFdlXG4gICAgICAgICAgICAvLyBhbHNvIGNhbid0IHNob3cgYSBmYWxsYmFjaywgYmVjYXVzZSBub25lIHdhcyBwcm92aWRlZC4gU28gb3VyIGxhc3RcbiAgICAgICAgICAgIC8vIHJlc29ydCBpcyB0byB0aHJvdyBhbiBlcnJvci5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBlcnJvciBpbiBhIGZ1dHVyZSByZWxlYXNlLiBPdGhlciB3YXlzIG9mIGhhbmRsaW5nXG4gICAgICAgICAgICAvLyB0aGlzIGNhc2UgaW5jbHVkZSBmb3JjaW5nIGEgY29uY3VycmVudCByZW5kZXIsIG9yIHB1dHRpbmcgdGhlIHdob2xlXG4gICAgICAgICAgICAvLyByb290IGludG8gb2Zmc2NyZWVuIG1vZGUuXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2FzeW5jL2F3YWl0IGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGluIENsaWVudCBDb21wb25lbnRzLCBvbmx5ICcgKyAnU2VydmVyIENvbXBvbmVudHMuIFRoaXMgZXJyb3IgaXMgb2Z0ZW4gY2F1c2VkIGJ5IGFjY2lkZW50YWxseSAnICsgXCJhZGRpbmcgYCd1c2UgY2xpZW50J2AgdG8gYSBtb2R1bGUgdGhhdCB3YXMgb3JpZ2luYWxseSB3cml0dGVuIFwiICsgJ2ZvciB0aGUgc2VydmVyLicpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwZW5kaW5nVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICBwZW5kaW5nVGhlbmFibGUuc3RhdHVzID0gJ3BlbmRpbmcnO1xuICAgICAgICAgIHBlbmRpbmdUaGVuYWJsZS50aGVuKGZ1bmN0aW9uIChmdWxmaWxsZWRWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKHRoZW5hYmxlLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgICAgICAgIHZhciBmdWxmaWxsZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgICBmdWxmaWxsZWRUaGVuYWJsZS5zdGF0dXMgPSAnZnVsZmlsbGVkJztcbiAgICAgICAgICAgICAgZnVsZmlsbGVkVGhlbmFibGUudmFsdWUgPSBmdWxmaWxsZWRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmICh0aGVuYWJsZS5zdGF0dXMgPT09ICdwZW5kaW5nJykge1xuICAgICAgICAgICAgICB2YXIgcmVqZWN0ZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgICByZWplY3RlZFRoZW5hYmxlLnN0YXR1cyA9ICdyZWplY3RlZCc7XG4gICAgICAgICAgICAgIHJlamVjdGVkVGhlbmFibGUucmVhc29uID0gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gLy8gQ2hlY2sgb25lIG1vcmUgdGltZSBpbiBjYXNlIHRoZSB0aGVuYWJsZSByZXNvbHZlZCBzeW5jaHJvbm91c2x5LlxuXG5cbiAgICAgICAgc3dpdGNoICh0aGVuYWJsZS5zdGF0dXMpIHtcbiAgICAgICAgICBjYXNlICdmdWxmaWxsZWQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgZnVsZmlsbGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bGZpbGxlZFRoZW5hYmxlLnZhbHVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSAncmVqZWN0ZWQnOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgcmVqZWN0ZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgICB2YXIgX3JlamVjdGVkRXJyb3IgPSByZWplY3RlZFRoZW5hYmxlLnJlYXNvbjtcbiAgICAgICAgICAgICAgY2hlY2tJZlVzZVdyYXBwZWRJbkFzeW5jQ2F0Y2goX3JlamVjdGVkRXJyb3IpO1xuICAgICAgICAgICAgICB0aHJvdyBfcmVqZWN0ZWRFcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBTdXNwZW5kLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaHJvd2luZyBoZXJlIGlzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCB0aGF0IGFsbG93cyB1cyB0byB1bndpbmQgdGhlXG4gICAgICAgIC8vIGNhbGwgc3RhY2suIEJ1dCB3ZSBzaG91bGRuJ3QgYWxsb3cgaXQgdG8gbGVhayBpbnRvIHVzZXJzcGFjZS4gVGhyb3cgYW5cbiAgICAgICAgLy8gb3BhcXVlIHBsYWNlaG9sZGVyIHZhbHVlIGluc3RlYWQgb2YgdGhlIGFjdHVhbCB0aGVuYWJsZS4gSWYgaXQgZG9lc24ndFxuICAgICAgICAvLyBnZXQgY2FwdHVyZWQgYnkgdGhlIHdvcmsgbG9vcCwgbG9nIGEgd2FybmluZywgYmVjYXVzZSB0aGF0IG1lYW5zXG4gICAgICAgIC8vIHNvbWV0aGluZyBpbiB1c2Vyc3BhY2UgbXVzdCBoYXZlIGNhdWdodCBpdC5cblxuXG4gICAgICAgIHN1c3BlbmRlZFRoZW5hYmxlID0gdGhlbmFibGU7XG5cbiAgICAgICAge1xuICAgICAgICAgIG5lZWRzVG9SZXNldFN1c3BlbmRlZFRoZW5hYmxlREVWID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IFN1c3BlbnNlRXhjZXB0aW9uO1xuICAgICAgfVxuICB9XG59XG5mdW5jdGlvbiBzdXNwZW5kQ29tbWl0KCkge1xuICAvLyBUaGlzIGV4dHJhIGluZGlyZWN0aW9uIG9ubHkgZXhpc3RzIHNvIGl0IGNhbiBoYW5kbGUgcGFzc2luZ1xuICAvLyBub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGUgdGhyb3VnaCB0byB0aHJvd0V4Y2VwdGlvbi5cbiAgLy8gVE9ETzogRmFjdG9yIHRoZSB0aGVuYWJsZSBjaGVjayBvdXQgb2YgdGhyb3dFeGNlcHRpb25cbiAgc3VzcGVuZGVkVGhlbmFibGUgPSBub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGU7XG4gIHRocm93IFN1c3BlbnNleUNvbW1pdEV4Y2VwdGlvbjtcbn0gLy8gVGhpcyBpcyB1c2VkIHRvIHRyYWNrIHRoZSBhY3R1YWwgdGhlbmFibGUgdGhhdCBzdXNwZW5kZWQgc28gaXQgY2FuIGJlXG4vLyBwYXNzZWQgdG8gdGhlIHJlc3Qgb2YgdGhlIFN1c3BlbnNlIGltcGxlbWVudGF0aW9uIOKAlCB3aGljaCwgZm9yIGhpc3RvcmljYWxcbi8vIHJlYXNvbnMsIGV4cGVjdHMgdG8gcmVjZWl2ZSBhIHRoZW5hYmxlLlxuXG52YXIgc3VzcGVuZGVkVGhlbmFibGUgPSBudWxsO1xudmFyIG5lZWRzVG9SZXNldFN1c3BlbmRlZFRoZW5hYmxlREVWID0gZmFsc2U7XG5mdW5jdGlvbiBnZXRTdXNwZW5kZWRUaGVuYWJsZSgpIHtcbiAgLy8gVGhpcyBpcyBjYWxsZWQgcmlnaHQgYWZ0ZXIgYHVzZWAgc3VzcGVuZHMgYnkgdGhyb3dpbmcgYW4gZXhjZXB0aW9uLiBgdXNlYFxuICAvLyB0aHJvd3MgYW4gb3BhcXVlIHZhbHVlIGluc3RlYWQgb2YgdGhlIHRoZW5hYmxlIGl0c2VsZiBzbyB0aGF0IGl0IGNhbid0IGJlXG4gIC8vIGNhdWdodCBpbiB1c2Vyc3BhY2UuIFRoZW4gdGhlIHdvcmsgbG9vcCBhY2Nlc3NlcyB0aGUgYWN0dWFsIHRoZW5hYmxlIHVzaW5nXG4gIC8vIHRoaXMgZnVuY3Rpb24uXG4gIGlmIChzdXNwZW5kZWRUaGVuYWJsZSA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYSBzdXNwZW5kZWQgdGhlbmFibGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlICcgKyAnYW4gaXNzdWUuJyk7XG4gIH1cblxuICB2YXIgdGhlbmFibGUgPSBzdXNwZW5kZWRUaGVuYWJsZTtcbiAgc3VzcGVuZGVkVGhlbmFibGUgPSBudWxsO1xuXG4gIHtcbiAgICBuZWVkc1RvUmVzZXRTdXNwZW5kZWRUaGVuYWJsZURFViA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRoZW5hYmxlO1xufVxuZnVuY3Rpb24gY2hlY2tJZlVzZVdyYXBwZWRJblRyeUNhdGNoKCkge1xuICB7XG4gICAgLy8gVGhpcyB3YXMgc2V0IHJpZ2h0IGJlZm9yZSBTdXNwZW5zZUV4Y2VwdGlvbiB3YXMgdGhyb3duLCBhbmQgaXQgc2hvdWxkXG4gICAgLy8gaGF2ZSBiZWVuIGNsZWFyZWQgd2hlbiB0aGUgZXhjZXB0aW9uIHdhcyBoYW5kbGVkLiBJZiBpdCB3YXNuJ3QsXG4gICAgLy8gaXQgbXVzdCBoYXZlIGJlZW4gY2F1Z2h0IGJ5IHVzZXJzcGFjZS5cbiAgICBpZiAobmVlZHNUb1Jlc2V0U3VzcGVuZGVkVGhlbmFibGVERVYpIHtcbiAgICAgIG5lZWRzVG9SZXNldFN1c3BlbmRlZFRoZW5hYmxlREVWID0gZmFsc2U7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjaGVja0lmVXNlV3JhcHBlZEluQXN5bmNDYXRjaChyZWplY3RlZFJlYXNvbikge1xuICAvLyBUaGlzIGNoZWNrIHJ1bnMgaW4gcHJvZCwgdG9vLCBiZWNhdXNlIGl0IHByZXZlbnRzIGEgbW9yZSBjb25mdXNpbmdcbiAgLy8gZG93bnN0cmVhbSBlcnJvciwgd2hlcmUgU3VzcGVuc2VFeGNlcHRpb24gaXMgY2F1Z2h0IGJ5IGEgcHJvbWlzZSBhbmRcbiAgLy8gdGhyb3duIGFzeW5jaHJvbm91c2x5LlxuICAvLyBUT0RPOiBBbm90aGVyIHdheSB0byBwcmV2ZW50IFN1c3BlbnNlRXhjZXB0aW9uIGZyb20gbGVha2luZyBpbnRvIGFuIGFzeW5jXG4gIC8vIGV4ZWN1dGlvbiBjb250ZXh0IGlzIHRvIGNoZWNrIHRoZSBkaXNwYXRjaGVyIGV2ZXJ5IHRpbWUgYHVzZWAgaXMgY2FsbGVkLFxuICAvLyBvciBzb21lIGVxdWl2YWxlbnQuIFRoYXQgbWlnaHQgYmUgcHJlZmVyYWJsZSBmb3Igb3RoZXIgcmVhc29ucywgdG9vLCBzaW5jZVxuICAvLyBpdCBtYXRjaGVzIGhvdyB3ZSBwcmV2ZW50IHNpbWlsYXIgbWlzdGFrZXMgZm9yIG90aGVyIGhvb2tzLlxuICBpZiAocmVqZWN0ZWRSZWFzb24gPT09IFN1c3BlbnNlRXhjZXB0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdIb29rcyBhcmUgbm90IHN1cHBvcnRlZCBpbnNpZGUgYW4gYXN5bmMgY29tcG9uZW50LiBUaGlzICcgKyBcImVycm9yIGlzIG9mdGVuIGNhdXNlZCBieSBhY2NpZGVudGFsbHkgYWRkaW5nIGAndXNlIGNsaWVudCdgIFwiICsgJ3RvIGEgbW9kdWxlIHRoYXQgd2FzIG9yaWdpbmFsbHkgd3JpdHRlbiBmb3IgdGhlIHNlcnZlci4nKTtcbiAgfVxufVxuXG52YXIgdGhlbmFibGVTdGF0ZSQxID0gbnVsbDtcbnZhciB0aGVuYWJsZUluZGV4Q291bnRlciQxID0gMDtcblxuZnVuY3Rpb24gbWVyZ2VEZWJ1Z0luZm8ob3V0ZXIsIGlubmVyKSB7XG5cbiAgaWYgKGlubmVyID09IG51bGwpIHtcbiAgICByZXR1cm4gb3V0ZXI7XG4gIH0gZWxzZSBpZiAob3V0ZXIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gaW5uZXI7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgd2UgaGF2ZSB0d28gZGVidWdJbmZvLCB3ZSBuZWVkIHRvIGNyZWF0ZSBhIG5ldyBvbmUuIFRoaXMgbWFrZXMgdGhlIGFycmF5IG5vIGxvbmdlclxuICAgIC8vIGxpdmUgc28gd2UnbGwgbWlzcyBhbnkgZnV0dXJlIHVwZGF0ZXMgaWYgd2UgcmVjZWl2ZWQgbW9yZSBzbyBpZGVhbGx5IHdlIHNob3VsZCBhbHdheXNcbiAgICAvLyBkbyB0aGlzIGFmdGVyIGJvdGggaGF2ZSBmdWxseSByZXNvbHZlZC91bnN1c3BlbmRlZC5cbiAgICByZXR1cm4gb3V0ZXIuY29uY2F0KGlubmVyKTtcbiAgfVxufVxuXG52YXIgZGlkV2FybkFib3V0TWFwcztcbnZhciBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzO1xudmFyIG93bmVySGFzS2V5VXNlV2FybmluZztcbnZhciBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmc7XG52YXIgb3duZXJIYXNTeW1ib2xUeXBlV2FybmluZztcblxudmFyIHdhcm5Gb3JNaXNzaW5nS2V5ID0gZnVuY3Rpb24gKGNoaWxkLCByZXR1cm5GaWJlcikge307XG5cbntcbiAgZGlkV2FybkFib3V0TWFwcyA9IGZhbHNlO1xuICBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID0gZmFsc2U7XG4gIC8qKlxuICAgKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gICAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICAgKiB1cGRhdGVzLlxuICAgKi9cblxuICBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcbiAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nID0ge307XG4gIG93bmVySGFzU3ltYm9sVHlwZVdhcm5pbmcgPSB7fTtcblxuICB3YXJuRm9yTWlzc2luZ0tleSA9IGZ1bmN0aW9uIChjaGlsZCwgcmV0dXJuRmliZXIpIHtcbiAgICBpZiAoY2hpbGQgPT09IG51bGwgfHwgdHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghY2hpbGQuX3N0b3JlIHx8IChjaGlsZC5fc3RvcmUudmFsaWRhdGVkIHx8IGNoaWxkLmtleSAhPSBudWxsKSAmJiBjaGlsZC5fc3RvcmUudmFsaWRhdGVkICE9PSAyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjaGlsZC5fc3RvcmUgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWN0IENvbXBvbmVudCBpbiB3YXJuRm9yTWlzc2luZ0tleSBzaG91bGQgaGF2ZSBhIF9zdG9yZS4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH0gLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIHVuYWJsZSB0byBuYXJyb3cgdHlwZSBmcm9tIG1peGVkIHRvIHdyaXRhYmxlIG9iamVjdFxuXG5cbiAgICBjaGlsZC5fc3RvcmUudmFsaWRhdGVkID0gMTtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpO1xuICAgIHZhciBjb21wb25lbnRLZXkgPSBjb21wb25lbnROYW1lIHx8ICdudWxsJztcblxuICAgIGlmIChvd25lckhhc0tleVVzZVdhcm5pbmdbY29tcG9uZW50S2V5XSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjb21wb25lbnRLZXldID0gdHJ1ZTtcbiAgICB2YXIgY2hpbGRPd25lciA9IGNoaWxkLl9vd25lcjtcbiAgICB2YXIgcGFyZW50T3duZXIgPSByZXR1cm5GaWJlci5fZGVidWdPd25lcjtcbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9ICcnO1xuXG4gICAgaWYgKHBhcmVudE93bmVyICYmIHR5cGVvZiBwYXJlbnRPd25lci50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocGFyZW50T3duZXIpO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKSB7XG4gICAgICBpZiAoY29tcG9uZW50TmFtZSkge1xuICAgICAgICBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gXCJcXG5cXG5DaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDxcIiArIGNvbXBvbmVudE5hbWUgKyBcIj4uXCI7XG4gICAgICB9XG4gICAgfSAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAgIC8vIHByb3BlcnR5LCBpdCBtYXkgYmUgdGhlIGNyZWF0b3Igb2YgdGhlIGNoaWxkIHRoYXQncyByZXNwb25zaWJsZSBmb3JcbiAgICAvLyBhc3NpZ25pbmcgaXQgYSBrZXkuXG5cblxuICAgIHZhciBjaGlsZE93bmVyQXBwZW5kaXggPSAnJztcblxuICAgIGlmIChjaGlsZE93bmVyICE9IG51bGwgJiYgcGFyZW50T3duZXIgIT09IGNoaWxkT3duZXIpIHtcbiAgICAgIHZhciBvd25lck5hbWUgPSBudWxsO1xuXG4gICAgICBpZiAodHlwZW9mIGNoaWxkT3duZXIudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBvd25lck5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGNoaWxkT3duZXIpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgY2hpbGRPd25lci5uYW1lID09PSAnc3RyaW5nJykge1xuICAgICAgICBvd25lck5hbWUgPSBjaGlsZE93bmVyLm5hbWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICAgIGNoaWxkT3duZXJBcHBlbmRpeCA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgb3duZXJOYW1lICsgXCIuXCI7XG4gICAgICB9XG4gICAgfSAvLyBXZSBjcmVhdGUgYSBmYWtlIEZpYmVyIGZvciB0aGUgY2hpbGQgdG8gbG9nIHRoZSBzdGFjayB0cmFjZSBmcm9tLlxuICAgIC8vIFRPRE86IFJlZmFjdG9yIHRoZSB3YXJuRm9yTWlzc2luZ0tleSBjYWxscyB0byBoYXBwZW4gYWZ0ZXIgZmliZXIgY3JlYXRpb25cbiAgICAvLyBzbyB0aGF0IHdlIGNhbiBnZXQgYWNjZXNzIHRvIHRoZSBmaWJlciB0aGF0IHdpbGwgZXZlbnR1YWxseSBiZSBjcmVhdGVkLlxuICAgIC8vIFRoYXQgd2F5IHRoZSBsb2cgY2FuIHNob3cgdXAgYXNzb2NpYXRlZCB3aXRoIHRoZSByaWdodCBpbnN0YW5jZSBpbiBEZXZUb29scy5cblxuXG4gICAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChjaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgMCk7XG4gICAgZmliZXIucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgdmFyIHByZXZEZWJ1Z0ZpYmVyID0gZ2V0Q3VycmVudEZpYmVyKCk7XG4gICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyQXBwZW5kaXgpO1xuXG4gICAgc2V0Q3VycmVudEZpYmVyKHByZXZEZWJ1Z0ZpYmVyKTtcbiAgfTtcbn0gLy8gR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4vLyBXZSBkbyB0aGlzIGhlcmUgaW5zdGVhZCBvZiBCZWdpbldvcmsgYmVjYXVzZSB0aGUgRnJhZ21lbnQgZmliZXIgZG9lc24ndCBoYXZlXG4vLyB0aGUgd2hvbGUgcHJvcHMgb2JqZWN0LCBvbmx5IHRoZSBjaGlsZHJlbiBhbmQgaXMgc2hhcmVkIHdpdGggYXJyYXlzLlxuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50LCBmaWJlciwgcmV0dXJuRmliZXIpIHtcbiAge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZWxlbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgaWYgKGZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gRm9yIHVua2V5ZWQgcm9vdCBmcmFnbWVudHMgdGhlcmUncyBubyBGaWJlci4gV2UgY3JlYXRlIGEgZmFrZSBvbmUganVzdCBmb3JcbiAgICAgICAgICAvLyBlcnJvciBzdGFjayBoYW5kbGluZy5cbiAgICAgICAgICBmaWJlciA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgcmV0dXJuRmliZXIubW9kZSwgMCk7XG4gICAgICAgICAgZmliZXIucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcHJldkRlYnVnRmliZXIgPSBnZXRDdXJyZW50RmliZXIoKTtcbiAgICAgICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudEZpYmVyKHByZXZEZWJ1Z0ZpYmVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVud3JhcFRoZW5hYmxlKHRoZW5hYmxlKSB7XG4gIHZhciBpbmRleCA9IHRoZW5hYmxlSW5kZXhDb3VudGVyJDE7XG4gIHRoZW5hYmxlSW5kZXhDb3VudGVyJDEgKz0gMTtcblxuICBpZiAodGhlbmFibGVTdGF0ZSQxID09PSBudWxsKSB7XG4gICAgdGhlbmFibGVTdGF0ZSQxID0gY3JlYXRlVGhlbmFibGVTdGF0ZSgpO1xuICB9XG5cbiAgcmV0dXJuIHRyYWNrVXNlZFRoZW5hYmxlKHRoZW5hYmxlU3RhdGUkMSwgdGhlbmFibGUsIGluZGV4KTtcbn1cblxuZnVuY3Rpb24gY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgZWxlbWVudCkge1xuICB2YXIgcmVmO1xuXG4gIHtcbiAgICAvLyBUT0RPOiBUaGlzIGlzIGEgdGVtcG9yYXJ5LCBpbnRlcm1lZGlhdGUgc3RlcC4gV2hlbiBlbmFibGVSZWZBc1Byb3AgaXMgb24sXG4gICAgLy8gd2Ugc2hvdWxkIHJlc29sdmUgdGhlIGByZWZgIHByb3AgZHVyaW5nIHRoZSBiZWdpbiBwaGFzZSBvZiB0aGUgY29tcG9uZW50XG4gICAgLy8gaXQncyBhdHRhY2hlZCB0byAoSG9zdENvbXBvbmVudCwgQ2xhc3NDb21wb25lbnQsIGV0YykuXG4gICAgdmFyIHJlZlByb3AgPSBlbGVtZW50LnByb3BzLnJlZjtcbiAgICByZWYgPSByZWZQcm9wICE9PSB1bmRlZmluZWQgPyByZWZQcm9wIDogbnVsbDtcbiAgfSAvLyBUT0RPOiBJZiBlbmFibGVSZWZBc1Byb3AgaXMgb24sIHdlIHNob3VsZG4ndCB1c2UgdGhlIGByZWZgIGZpZWxkLiBXZVxuICAvLyBzaG91bGQgYWx3YXlzIHJlYWQgdGhlIHJlZiBmcm9tIHRoZSBwcm9wLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MucmVmID0gcmVmO1xufVxuXG5mdW5jdGlvbiB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKSB7XG4gIGlmIChuZXdDaGlsZC4kJHR5cGVvZiA9PT0gUkVBQ1RfTEVHQUNZX0VMRU1FTlRfVFlQRSkge1xuICAgIHRocm93IG5ldyBFcnJvcignQSBSZWFjdCBFbGVtZW50IGZyb20gYW4gb2xkZXIgdmVyc2lvbiBvZiBSZWFjdCB3YXMgcmVuZGVyZWQuICcgKyAnVGhpcyBpcyBub3Qgc3VwcG9ydGVkLiBJdCBjYW4gaGFwcGVuIGlmOlxcbicgKyAnLSBNdWx0aXBsZSBjb3BpZXMgb2YgdGhlIFwicmVhY3RcIiBwYWNrYWdlIGlzIHVzZWQuXFxuJyArICctIEEgbGlicmFyeSBwcmUtYnVuZGxlZCBhbiBvbGQgY29weSBvZiBcInJlYWN0XCIgb3IgXCJyZWFjdC9qc3gtcnVudGltZVwiLlxcbicgKyAnLSBBIGNvbXBpbGVyIHRyaWVzIHRvIFwiaW5saW5lXCIgSlNYIGluc3RlYWQgb2YgdXNpbmcgdGhlIHJ1bnRpbWUuJyk7XG4gIH0gLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuXG5cbiAgdmFyIGNoaWxkU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkKTtcbiAgdGhyb3cgbmV3IEVycm9yKFwiT2JqZWN0cyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQgKGZvdW5kOiBcIiArIChjaGlsZFN0cmluZyA9PT0gJ1tvYmplY3QgT2JqZWN0XScgPyAnb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKG5ld0NoaWxkKS5qb2luKCcsICcpICsgJ30nIDogY2hpbGRTdHJpbmcpICsgXCIpLiBcIiArICdJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZC4nKTtcbn1cblxuZnVuY3Rpb24gd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyLCBpbnZhbGlkQ2hpbGQpIHtcbiAge1xuICAgIHZhciBwYXJlbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihyZXR1cm5GaWJlcikgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICBpZiAob3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW3BhcmVudE5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNGdW5jdGlvblR5cGVXYXJuaW5nW3BhcmVudE5hbWVdID0gdHJ1ZTtcbiAgICB2YXIgbmFtZSA9IGludmFsaWRDaGlsZC5kaXNwbGF5TmFtZSB8fCBpbnZhbGlkQ2hpbGQubmFtZSB8fCAnQ29tcG9uZW50JztcblxuICAgIGlmIChyZXR1cm5GaWJlci50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICBlcnJvcignRnVuY3Rpb25zIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC4gVGhpcyBtYXkgaGFwcGVuIGlmICcgKyAneW91IHJldHVybiAlcyBpbnN0ZWFkIG9mIDwlcyAvPiBmcm9tIHJlbmRlci4gJyArICdPciBtYXliZSB5b3UgbWVhbnQgdG8gY2FsbCB0aGlzIGZ1bmN0aW9uIHJhdGhlciB0aGFuIHJldHVybiBpdC5cXG4nICsgJyAgcm9vdC5yZW5kZXIoJXMpJywgbmFtZSwgbmFtZSwgbmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yKCdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJyArICd5b3UgcmV0dXJuICVzIGluc3RlYWQgb2YgPCVzIC8+IGZyb20gcmVuZGVyLiAnICsgJ09yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LlxcbicgKyAnICA8JXM+eyVzfTwvJXM+JywgbmFtZSwgbmFtZSwgcGFyZW50TmFtZSwgbmFtZSwgcGFyZW50TmFtZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5PblN5bWJvbFR5cGUocmV0dXJuRmliZXIsIGludmFsaWRDaGlsZCkge1xuICB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHJldHVybkZpYmVyKSB8fCAnQ29tcG9uZW50JztcblxuICAgIGlmIChvd25lckhhc1N5bWJvbFR5cGVXYXJuaW5nW3BhcmVudE5hbWVdKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNTeW1ib2xUeXBlV2FybmluZ1twYXJlbnROYW1lXSA9IHRydWU7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG4gICAgdmFyIG5hbWUgPSBTdHJpbmcoaW52YWxpZENoaWxkKTtcblxuICAgIGlmIChyZXR1cm5GaWJlci50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICBlcnJvcignU3ltYm9scyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuXFxuJyArICcgIHJvb3QucmVuZGVyKCVzKScsIG5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlcnJvcignU3ltYm9scyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuXFxuJyArICcgIDwlcz4lczwvJXM+JywgcGFyZW50TmFtZSwgbmFtZSwgcGFyZW50TmFtZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVMYXp5KGxhenlUeXBlKSB7XG4gIHZhciBwYXlsb2FkID0gbGF6eVR5cGUuX3BheWxvYWQ7XG4gIHZhciBpbml0ID0gbGF6eVR5cGUuX2luaXQ7XG4gIHJldHVybiBpbml0KHBheWxvYWQpO1xufSAvLyBUaGlzIHdyYXBwZXIgZnVuY3Rpb24gZXhpc3RzIGJlY2F1c2UgSSBleHBlY3QgdG8gY2xvbmUgdGhlIGNvZGUgaW4gZWFjaCBwYXRoXG4vLyB0byBiZSBhYmxlIHRvIG9wdGltaXplIGVhY2ggcGF0aCBpbmRpdmlkdWFsbHkgYnkgYnJhbmNoaW5nIGVhcmx5LiBUaGlzIG5lZWRzXG4vLyBhIGNvbXBpbGVyIG9yIHdlIGNhbiBkbyBpdCBtYW51YWxseS4gSGVscGVycyB0aGF0IGRvbid0IG5lZWQgdGhpcyBicmFuY2hpbmdcbi8vIGxpdmUgb3V0c2lkZSBvZiB0aGlzIGZ1bmN0aW9uLlxuXG5cbmZ1bmN0aW9uIGNyZWF0ZUNoaWxkUmVjb25jaWxlcihzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gIGZ1bmN0aW9uIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZFRvRGVsZXRlKSB7XG4gICAgaWYgKCFzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBOb29wLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBkZWxldGlvbnMgPSByZXR1cm5GaWJlci5kZWxldGlvbnM7XG5cbiAgICBpZiAoZGVsZXRpb25zID09PSBudWxsKSB7XG4gICAgICByZXR1cm5GaWJlci5kZWxldGlvbnMgPSBbY2hpbGRUb0RlbGV0ZV07XG4gICAgICByZXR1cm5GaWJlci5mbGFncyB8PSBDaGlsZERlbGV0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICBkZWxldGlvbnMucHVzaChjaGlsZFRvRGVsZXRlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IC8vIFRPRE86IEZvciB0aGUgc2hvdWxkQ2xvbmUgY2FzZSwgdGhpcyBjb3VsZCBiZSBtaWNyby1vcHRpbWl6ZWQgYSBiaXQgYnlcbiAgICAvLyBhc3N1bWluZyB0aGF0IGFmdGVyIHRoZSBmaXJzdCBjaGlsZCB3ZSd2ZSBhbHJlYWR5IGFkZGVkIGV2ZXJ5dGhpbmcuXG5cblxuICAgIHZhciBjaGlsZFRvRGVsZXRlID0gY3VycmVudEZpcnN0Q2hpbGQ7XG5cbiAgICB3aGlsZSAoY2hpbGRUb0RlbGV0ZSAhPT0gbnVsbCkge1xuICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpO1xuICAgICAgY2hpbGRUb0RlbGV0ZSA9IGNoaWxkVG9EZWxldGUuc2libGluZztcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hcFJlbWFpbmluZ0NoaWxkcmVuKGN1cnJlbnRGaXJzdENoaWxkKSB7XG4gICAgLy8gQWRkIHRoZSByZW1haW5pbmcgY2hpbGRyZW4gdG8gYSB0ZW1wb3JhcnkgbWFwIHNvIHRoYXQgd2UgY2FuIGZpbmQgdGhlbSBieVxuICAgIC8vIGtleXMgcXVpY2tseS4gSW1wbGljaXQgKG51bGwpIGtleXMgZ2V0IGFkZGVkIHRvIHRoaXMgc2V0IHdpdGggdGhlaXIgaW5kZXhcbiAgICAvLyBpbnN0ZWFkLlxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbmV3IE1hcCgpO1xuICAgIHZhciBleGlzdGluZ0NoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG5cbiAgICB3aGlsZSAoZXhpc3RpbmdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGV4aXN0aW5nQ2hpbGQua2V5ICE9PSBudWxsKSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQua2V5LCBleGlzdGluZ0NoaWxkKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uc2V0KGV4aXN0aW5nQ2hpbGQuaW5kZXgsIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBleGlzdGluZ0NoaWxkID0gZXhpc3RpbmdDaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHJldHVybiBleGlzdGluZ0NoaWxkcmVuO1xuICB9XG5cbiAgZnVuY3Rpb24gdXNlRmliZXIoZmliZXIsIHBlbmRpbmdQcm9wcykge1xuICAgIC8vIFdlIGN1cnJlbnRseSBzZXQgc2libGluZyB0byBudWxsIGFuZCBpbmRleCB0byAwIGhlcmUgYmVjYXVzZSBpdCBpcyBlYXN5XG4gICAgLy8gdG8gZm9yZ2V0IHRvIGRvIGJlZm9yZSByZXR1cm5pbmcgaXQuIEUuZy4gZm9yIHRoZSBzaW5nbGUgY2hpbGQgY2FzZS5cbiAgICB2YXIgY2xvbmUgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhmaWJlciwgcGVuZGluZ1Byb3BzKTtcbiAgICBjbG9uZS5pbmRleCA9IDA7XG4gICAgY2xvbmUuc2libGluZyA9IG51bGw7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VDaGlsZChuZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJbmRleCkge1xuICAgIG5ld0ZpYmVyLmluZGV4ID0gbmV3SW5kZXg7XG5cbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIER1cmluZyBoeWRyYXRpb24sIHRoZSB1c2VJZCBhbGdvcml0aG0gbmVlZHMgdG8ga25vdyB3aGljaCBmaWJlcnMgYXJlXG4gICAgICAvLyBwYXJ0IG9mIGEgbGlzdCBvZiBjaGlsZHJlbiAoYXJyYXlzLCBpdGVyYXRvcnMpLlxuICAgICAgbmV3RmliZXIuZmxhZ3MgfD0gRm9ya2VkO1xuICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudCA9IG5ld0ZpYmVyLmFsdGVybmF0ZTtcblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICB2YXIgb2xkSW5kZXggPSBjdXJyZW50LmluZGV4O1xuXG4gICAgICBpZiAob2xkSW5kZXggPCBsYXN0UGxhY2VkSW5kZXgpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIG1vdmUuXG4gICAgICAgIG5ld0ZpYmVyLmZsYWdzIHw9IFBsYWNlbWVudCB8IFBsYWNlbWVudERFVjtcbiAgICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXRlbSBjYW4gc3RheSBpbiBwbGFjZS5cbiAgICAgICAgcmV0dXJuIG9sZEluZGV4O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIGluc2VydGlvbi5cbiAgICAgIG5ld0ZpYmVyLmZsYWdzIHw9IFBsYWNlbWVudCB8IFBsYWNlbWVudERFVjtcbiAgICAgIHJldHVybiBsYXN0UGxhY2VkSW5kZXg7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGxhY2VTaW5nbGVDaGlsZChuZXdGaWJlcikge1xuICAgIC8vIFRoaXMgaXMgc2ltcGxlciBmb3IgdGhlIHNpbmdsZSBjaGlsZCBjYXNlLiBXZSBvbmx5IG5lZWQgdG8gZG8gYVxuICAgIC8vIHBsYWNlbWVudCBmb3IgaW5zZXJ0aW5nIG5ldyBjaGlsZHJlbi5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cyAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgIG5ld0ZpYmVyLmZsYWdzIHw9IFBsYWNlbWVudCB8IFBsYWNlbWVudERFVjtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3RmliZXI7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudCwgdGV4dENvbnRlbnQsIGxhbmVzLCBkZWJ1Z0luZm8pIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICB7XG4gICAgICAgIGNyZWF0ZWQuX2RlYnVnSW5mbyA9IGRlYnVnSW5mbztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgdGV4dENvbnRlbnQpO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgIHtcbiAgICAgICAgZXhpc3RpbmcuX2RlYnVnSW5mbyA9IGRlYnVnSW5mbztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGVsZW1lbnQsIGxhbmVzLCBkZWJ1Z0luZm8pIHtcbiAgICB2YXIgZWxlbWVudFR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAoZWxlbWVudFR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhciB1cGRhdGVkID0gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGVsZW1lbnQucHJvcHMuY2hpbGRyZW4sIGxhbmVzLCBlbGVtZW50LmtleSwgZGVidWdJbmZvKTtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50LCB1cGRhdGVkLCByZXR1cm5GaWJlcik7XG4gICAgICByZXR1cm4gdXBkYXRlZDtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGN1cnJlbnQuZWxlbWVudFR5cGUgPT09IGVsZW1lbnRUeXBlIHx8ICggLy8gS2VlcCB0aGlzIGNoZWNrIGlubGluZSBzbyBpdCBvbmx5IHJ1bnMgb24gdGhlIGZhbHNlIHBhdGg6XG4gICAgICBpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmcoY3VycmVudCwgZWxlbWVudCkgKSB8fCAvLyBMYXp5IHR5cGVzIHNob3VsZCByZWNvbmNpbGUgdGhlaXIgcmVzb2x2ZWQgdHlwZS5cbiAgICAgIC8vIFdlIG5lZWQgdG8gZG8gdGhpcyBhZnRlciB0aGUgSG90IFJlbG9hZGluZyBjaGVjayBhYm92ZSxcbiAgICAgIC8vIGJlY2F1c2UgaG90IHJlbG9hZGluZyBoYXMgZGlmZmVyZW50IHNlbWFudGljcyB0aGFuIHByb2QgYmVjYXVzZVxuICAgICAgLy8gaXQgZG9lc24ndCByZXN1c3BlbmQuIFNvIHdlIGNhbid0IGxldCB0aGUgY2FsbCBiZWxvdyBzdXNwZW5kLlxuICAgICAgdHlwZW9mIGVsZW1lbnRUeXBlID09PSAnb2JqZWN0JyAmJiBlbGVtZW50VHlwZSAhPT0gbnVsbCAmJiBlbGVtZW50VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFICYmIHJlc29sdmVMYXp5KGVsZW1lbnRUeXBlKSA9PT0gY3VycmVudC50eXBlKSB7XG4gICAgICAgIC8vIE1vdmUgYmFzZWQgb24gaW5kZXhcbiAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZWxlbWVudC5wcm9wcyk7XG4gICAgICAgIGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudCwgZXhpc3RpbmcsIGVsZW1lbnQpO1xuICAgICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgICAgICB7XG4gICAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICBleGlzdGluZy5fZGVidWdJbmZvID0gZGVidWdJbmZvO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgICAgfVxuICAgIH0gLy8gSW5zZXJ0XG5cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50LCBjcmVhdGVkLCBlbGVtZW50KTtcbiAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAge1xuICAgICAgY3JlYXRlZC5fZGVidWdJbmZvID0gZGVidWdJbmZvO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVkO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50LCBwb3J0YWwsIGxhbmVzLCBkZWJ1Z0luZm8pIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gSG9zdFBvcnRhbCB8fCBjdXJyZW50LnN0YXRlTm9kZS5jb250YWluZXJJbmZvICE9PSBwb3J0YWwuY29udGFpbmVySW5mbyB8fCBjdXJyZW50LnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiAhPT0gcG9ydGFsLmltcGxlbWVudGF0aW9uKSB7XG4gICAgICAvLyBJbnNlcnRcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgICAge1xuICAgICAgICBjcmVhdGVkLl9kZWJ1Z0luZm8gPSBkZWJ1Z0luZm87XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBVcGRhdGVcbiAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGN1cnJlbnQsIHBvcnRhbC5jaGlsZHJlbiB8fCBbXSk7XG4gICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgICAge1xuICAgICAgICBleGlzdGluZy5fZGVidWdJbmZvID0gZGVidWdJbmZvO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIGN1cnJlbnQsIGZyYWdtZW50LCBsYW5lcywga2V5LCBkZWJ1Z0luZm8pIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnRhZyAhPT0gRnJhZ21lbnQpIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChmcmFnbWVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMsIGtleSk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICB7XG4gICAgICAgIGNyZWF0ZWQuX2RlYnVnSW5mbyA9IGRlYnVnSW5mbztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgZnJhZ21lbnQpO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgIHtcbiAgICAgICAgZXhpc3RpbmcuX2RlYnVnSW5mbyA9IGRlYnVnSW5mbztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZCwgbGFuZXMsIGRlYnVnSW5mbykge1xuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnICYmIG5ld0NoaWxkICE9PSAnJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgIC8vIFRleHQgbm9kZXMgZG9uJ3QgaGF2ZSBrZXlzLiBJZiB0aGUgcHJldmlvdXMgbm9kZSBpcyBpbXBsaWNpdGx5IGtleWVkXG4gICAgICAvLyB3ZSBjYW4gY29udGludWUgdG8gcmVwbGFjZSBpdCB3aXRob3V0IGFib3J0aW5nIGV2ZW4gaWYgaXQgaXMgbm90IGEgdGV4dFxuICAgICAgLy8gbm9kZS5cbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCggLy8gJEZsb3dGaXhNZVt1bnNhZmUtYWRkaXRpb25dIEZsb3cgZG9lc24ndCB3YW50IHVzIHRvIHVzZSBgK2Agb3BlcmF0b3Igd2l0aCBzdHJpbmcgYW5kIGJpZ2ludFxuICAgICAgJycgKyBuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgICAge1xuICAgICAgICBjcmVhdGVkLl9kZWJ1Z0luZm8gPSBkZWJ1Z0luZm87XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcblxuICAgICAgICAgICAgY29lcmNlUmVmKHJldHVybkZpYmVyLCBudWxsLCBfY3JlYXRlZCwgbmV3Q2hpbGQpO1xuICAgICAgICAgICAgX2NyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgX2NyZWF0ZWQuX2RlYnVnSW5mbyA9IG1lcmdlRGVidWdJbmZvKGRlYnVnSW5mbywgbmV3Q2hpbGQuX2RlYnVnSW5mbyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfY3JlYXRlZDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX2NyZWF0ZWQyID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKG5ld0NoaWxkLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG5cbiAgICAgICAgICAgIF9jcmVhdGVkMi5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBfY3JlYXRlZDIuX2RlYnVnSW5mbyA9IGRlYnVnSW5mbztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkMjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBuZXdDaGlsZC5fcGF5bG9hZDtcbiAgICAgICAgICAgIHZhciBpbml0ID0gbmV3Q2hpbGQuX2luaXQ7XG4gICAgICAgICAgICByZXR1cm4gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIGluaXQocGF5bG9hZCksIGxhbmVzLCBtZXJnZURlYnVnSW5mbyhkZWJ1Z0luZm8sIG5ld0NoaWxkLl9kZWJ1Z0luZm8pIC8vIGNhbGwgbWVyZ2UgYWZ0ZXIgaW5pdFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSB8fCBlbmFibGVBc3luY0l0ZXJhYmxlQ2hpbGRyZW4gKSB7XG4gICAgICAgIHZhciBfY3JlYXRlZDMgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMsIG51bGwpO1xuXG4gICAgICAgIF9jcmVhdGVkMy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgICAgICB7XG4gICAgICAgICAgX2NyZWF0ZWQzLl9kZWJ1Z0luZm8gPSBtZXJnZURlYnVnSW5mbyhkZWJ1Z0luZm8sIG5ld0NoaWxkLl9kZWJ1Z0luZm8pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIF9jcmVhdGVkMztcbiAgICAgIH0gLy8gVXNhYmxlIG5vZGUgdHlwZXNcbiAgICAgIC8vXG4gICAgICAvLyBVbndyYXAgdGhlIGlubmVyIHZhbHVlIGFuZCByZWN1cnNpdmVseSBjYWxsIHRoaXMgZnVuY3Rpb24gYWdhaW4uXG5cblxuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciB0aGVuYWJsZSA9IG5ld0NoaWxkO1xuICAgICAgICByZXR1cm4gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIHVud3JhcFRoZW5hYmxlKHRoZW5hYmxlKSwgbGFuZXMsIG1lcmdlRGVidWdJbmZvKGRlYnVnSW5mbywgbmV3Q2hpbGQuX2RlYnVnSW5mbykpO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3Q2hpbGQuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IG5ld0NoaWxkO1xuICAgICAgICByZXR1cm4gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIHJlYWRDb250ZXh0RHVyaW5nUmVjb25jaWxpYXRpb24ocmV0dXJuRmliZXIsIGNvbnRleHQsIGxhbmVzKSwgbGFuZXMsIGRlYnVnSW5mbyk7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIHdhcm5PblN5bWJvbFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMsIGRlYnVnSW5mbykge1xuICAgIC8vIFVwZGF0ZSB0aGUgZmliZXIgaWYgdGhlIGtleXMgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gbnVsbC5cbiAgICB2YXIga2V5ID0gb2xkRmliZXIgIT09IG51bGwgPyBvbGRGaWJlci5rZXkgOiBudWxsO1xuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgJiYgbmV3Q2hpbGQgIT09ICcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnYmlnaW50Jykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbiAgICAgIC8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYSB0ZXh0XG4gICAgICAvLyBub2RlLlxuICAgICAgaWYgKGtleSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBvbGRGaWJlciwgLy8gJEZsb3dGaXhNZVt1bnNhZmUtYWRkaXRpb25dIEZsb3cgZG9lc24ndCB3YW50IHVzIHRvIHVzZSBgK2Agb3BlcmF0b3Igd2l0aCBzdHJpbmcgYW5kIGJpZ2ludFxuICAgICAgJycgKyBuZXdDaGlsZCwgbGFuZXMsIGRlYnVnSW5mbyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGxhbmVzLCBtZXJnZURlYnVnSW5mbyhkZWJ1Z0luZm8sIG5ld0NoaWxkLl9kZWJ1Z0luZm8pKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChuZXdDaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICAgICAgICByZXR1cm4gdXBkYXRlUG9ydGFsKHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGQsIGxhbmVzLCBkZWJ1Z0luZm8pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYXlsb2FkID0gbmV3Q2hpbGQuX3BheWxvYWQ7XG4gICAgICAgICAgICB2YXIgaW5pdCA9IG5ld0NoaWxkLl9pbml0O1xuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBpbml0KHBheWxvYWQpLCBsYW5lcywgbWVyZ2VEZWJ1Z0luZm8oZGVidWdJbmZvLCBuZXdDaGlsZC5fZGVidWdJbmZvKSk7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheShuZXdDaGlsZCkgfHwgZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkgfHwgZW5hYmxlQXN5bmNJdGVyYWJsZUNoaWxkcmVuICkge1xuICAgICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMsIG51bGwsIG1lcmdlRGVidWdJbmZvKGRlYnVnSW5mbywgbmV3Q2hpbGQuX2RlYnVnSW5mbykpO1xuICAgICAgfSAvLyBVc2FibGUgbm9kZSB0eXBlc1xuICAgICAgLy9cbiAgICAgIC8vIFVud3JhcCB0aGUgaW5uZXIgdmFsdWUgYW5kIHJlY3Vyc2l2ZWx5IGNhbGwgdGhpcyBmdW5jdGlvbiBhZ2Fpbi5cblxuXG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHRoZW5hYmxlID0gbmV3Q2hpbGQ7XG4gICAgICAgIHJldHVybiB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgdW53cmFwVGhlbmFibGUodGhlbmFibGUpLCBsYW5lcywgZGVidWdJbmZvKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld0NoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBuZXdDaGlsZDtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCByZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uKHJldHVybkZpYmVyLCBjb250ZXh0LCBsYW5lcyksIGxhbmVzLCBkZWJ1Z0luZm8pO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3ltYm9sJykge1xuICAgICAgICB3YXJuT25TeW1ib2xUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIG5ld0NoaWxkLCBsYW5lcywgZGVidWdJbmZvKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgJiYgbmV3Q2hpbGQgIT09ICcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnYmlnaW50Jykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMsIHNvIHdlIG5laXRoZXIgaGF2ZSB0byBjaGVjayB0aGUgb2xkIG5vclxuICAgICAgLy8gbmV3IG5vZGUgZm9yIHRoZSBrZXkuIElmIGJvdGggYXJlIHRleHQgbm9kZXMsIHRoZXkgbWF0Y2guXG4gICAgICB2YXIgbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBtYXRjaGVkRmliZXIsIC8vICRGbG93Rml4TWVbdW5zYWZlLWFkZGl0aW9uXSBGbG93IGRvZXNuJ3Qgd2FudCB1cyB0byB1c2UgYCtgIG9wZXJhdG9yIHdpdGggc3RyaW5nIGFuZCBiaWdpbnRcbiAgICAgICcnICsgbmV3Q2hpbGQsIGxhbmVzLCBkZWJ1Z0luZm8pO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3Q2hpbGQua2V5ID09PSBudWxsID8gbmV3SWR4IDogbmV3Q2hpbGQua2V5KSB8fCBudWxsO1xuXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlciwgbmV3Q2hpbGQsIGxhbmVzLCBtZXJnZURlYnVnSW5mbyhkZWJ1Z0luZm8sIG5ld0NoaWxkLl9kZWJ1Z0luZm8pKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgX21hdGNoZWRGaWJlcjIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdDaGlsZC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBuZXdDaGlsZC5rZXkpIHx8IG51bGw7XG5cbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIyLCBuZXdDaGlsZCwgbGFuZXMsIGRlYnVnSW5mbyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgIHZhciBwYXlsb2FkID0gbmV3Q2hpbGQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBuZXdDaGlsZC5faW5pdDtcbiAgICAgICAgICByZXR1cm4gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBpbml0KHBheWxvYWQpLCBsYW5lcywgbWVyZ2VEZWJ1Z0luZm8oZGVidWdJbmZvLCBuZXdDaGlsZC5fZGVidWdJbmZvKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSB8fCBlbmFibGVBc3luY0l0ZXJhYmxlQ2hpbGRyZW4gKSB7XG4gICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMyA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0lkeCkgfHwgbnVsbDtcblxuICAgICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQocmV0dXJuRmliZXIsIF9tYXRjaGVkRmliZXIzLCBuZXdDaGlsZCwgbGFuZXMsIG51bGwsIG1lcmdlRGVidWdJbmZvKGRlYnVnSW5mbywgbmV3Q2hpbGQuX2RlYnVnSW5mbykpO1xuICAgICAgfSAvLyBVc2FibGUgbm9kZSB0eXBlc1xuICAgICAgLy9cbiAgICAgIC8vIFVud3JhcCB0aGUgaW5uZXIgdmFsdWUgYW5kIHJlY3Vyc2l2ZWx5IGNhbGwgdGhpcyBmdW5jdGlvbiBhZ2Fpbi5cblxuXG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHRoZW5hYmxlID0gbmV3Q2hpbGQ7XG4gICAgICAgIHJldHVybiB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIHVud3JhcFRoZW5hYmxlKHRoZW5hYmxlKSwgbGFuZXMsIGRlYnVnSW5mbyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdDaGlsZC4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gbmV3Q2hpbGQ7XG4gICAgICAgIHJldHVybiB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIHJlYWRDb250ZXh0RHVyaW5nUmVjb25jaWxpYXRpb24ocmV0dXJuRmliZXIsIGNvbnRleHQsIGxhbmVzKSwgbGFuZXMsIGRlYnVnSW5mbyk7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIHdhcm5PblN5bWJvbFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICAvKipcbiAgICogV2FybnMgaWYgdGhlcmUgaXMgYSBkdXBsaWNhdGUgb3IgbWlzc2luZyBrZXlcbiAgICovXG5cblxuICBmdW5jdGlvbiB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMsIHJldHVybkZpYmVyKSB7XG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBjaGlsZCAhPT0gJ29iamVjdCcgfHwgY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGtub3duS2V5cztcbiAgICAgIH1cblxuICAgICAgc3dpdGNoIChjaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgICAgICB3YXJuRm9yTWlzc2luZ0tleShjaGlsZCwgcmV0dXJuRmliZXIpO1xuICAgICAgICAgIHZhciBrZXkgPSBjaGlsZC5rZXk7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChrbm93bktleXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGtub3duS2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmICgha25vd25LZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBrbm93bktleXMuYWRkKGtleSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvcignRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCBgJXNgLiAnICsgJ0tleXMgc2hvdWxkIGJlIHVuaXF1ZSBzbyB0aGF0IGNvbXBvbmVudHMgbWFpbnRhaW4gdGhlaXIgaWRlbnRpdHkgJyArICdhY3Jvc3MgdXBkYXRlcy4gTm9uLXVuaXF1ZSBrZXlzIG1heSBjYXVzZSBjaGlsZHJlbiB0byBiZSAnICsgJ2R1cGxpY2F0ZWQgYW5kL29yIG9taXR0ZWQg4oCUIHRoZSBiZWhhdmlvciBpcyB1bnN1cHBvcnRlZCBhbmQgJyArICdjb3VsZCBjaGFuZ2UgaW4gYSBmdXR1cmUgdmVyc2lvbi4nLCBrZXkpO1xuXG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBjaGlsZC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGNoaWxkLl9pbml0O1xuICAgICAgICAgIHdhcm5PbkludmFsaWRLZXkoaW5pdChwYXlsb2FkKSwga25vd25LZXlzLCByZXR1cm5GaWJlcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGtub3duS2V5cztcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbiwgbGFuZXMsIGRlYnVnSW5mbykge1xuICAgIC8vIFRoaXMgYWxnb3JpdGhtIGNhbid0IG9wdGltaXplIGJ5IHNlYXJjaGluZyBmcm9tIGJvdGggZW5kcyBzaW5jZSB3ZVxuICAgIC8vIGRvbid0IGhhdmUgYmFja3BvaW50ZXJzIG9uIGZpYmVycy4gSSdtIHRyeWluZyB0byBzZWUgaG93IGZhciB3ZSBjYW4gZ2V0XG4gICAgLy8gd2l0aCB0aGF0IG1vZGVsLiBJZiBpdCBlbmRzIHVwIG5vdCBiZWluZyB3b3J0aCB0aGUgdHJhZGVvZmZzLCB3ZSBjYW5cbiAgICAvLyBhZGQgaXQgbGF0ZXIuXG4gICAgLy8gRXZlbiB3aXRoIGEgdHdvIGVuZGVkIG9wdGltaXphdGlvbiwgd2UnZCB3YW50IHRvIG9wdGltaXplIGZvciB0aGUgY2FzZVxuICAgIC8vIHdoZXJlIHRoZXJlIGFyZSBmZXcgY2hhbmdlcyBhbmQgYnJ1dGUgZm9yY2UgdGhlIGNvbXBhcmlzb24gaW5zdGVhZCBvZlxuICAgIC8vIGdvaW5nIGZvciB0aGUgTWFwLiBJdCdkIGxpa2UgdG8gZXhwbG9yZSBoaXR0aW5nIHRoYXQgcGF0aCBmaXJzdCBpblxuICAgIC8vIGZvcndhcmQtb25seSBtb2RlIGFuZCBvbmx5IGdvIGZvciB0aGUgTWFwIG9uY2Ugd2Ugbm90aWNlIHRoYXQgd2UgbmVlZFxuICAgIC8vIGxvdHMgb2YgbG9vayBhaGVhZC4gVGhpcyBkb2Vzbid0IGhhbmRsZSByZXZlcnNhbCBhcyB3ZWxsIGFzIHR3byBlbmRlZFxuICAgIC8vIHNlYXJjaCBidXQgdGhhdCdzIHVudXN1YWwuIEJlc2lkZXMsIGZvciB0aGUgdHdvIGVuZGVkIG9wdGltaXphdGlvbiB0b1xuICAgIC8vIHdvcmsgb24gSXRlcmFibGVzLCB3ZSdkIG5lZWQgdG8gY29weSB0aGUgd2hvbGUgc2V0LlxuICAgIC8vIEluIHRoaXMgZmlyc3QgaXRlcmF0aW9uLCB3ZSdsbCBqdXN0IGxpdmUgd2l0aCBoaXR0aW5nIHRoZSBiYWQgY2FzZVxuICAgIC8vIChhZGRpbmcgZXZlcnl0aGluZyB0byBhIE1hcCkgaW4gZm9yIGV2ZXJ5IGluc2VydC9tb3ZlLlxuICAgIC8vIElmIHlvdSBjaGFuZ2UgdGhpcyBjb2RlLCBhbHNvIHVwZGF0ZSByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKCkgd2hpY2hcbiAgICAvLyB1c2VzIHRoZSBzYW1lIGFsZ29yaXRobS5cbiAgICB7XG4gICAgICAvLyBGaXJzdCwgdmFsaWRhdGUga2V5cy5cbiAgICAgIHZhciBrbm93bktleXMgPSBudWxsO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZCA9IG5ld0NoaWxkcmVuW2ldO1xuICAgICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KGNoaWxkLCBrbm93bktleXMsIHJldHVybkZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzTmV3RmliZXIgPSBudWxsO1xuICAgIHZhciBvbGRGaWJlciA9IGN1cnJlbnRGaXJzdENoaWxkO1xuICAgIHZhciBsYXN0UGxhY2VkSW5kZXggPSAwO1xuICAgIHZhciBuZXdJZHggPSAwO1xuICAgIHZhciBuZXh0T2xkRmliZXIgPSBudWxsO1xuXG4gICAgZm9yICg7IG9sZEZpYmVyICE9PSBudWxsICYmIG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGxhbmVzLCBkZWJ1Z0luZm8pO1xuXG4gICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3NcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbiAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogRGVmZXIgc2libGluZ3MgaWYgd2UncmUgbm90IGF0IHRoZSByaWdodCBpbmRleCBmb3IgdGhpcyBzbG90LlxuICAgICAgICAvLyBJLmUuIGlmIHdlIGhhZCBudWxsIHZhbHVlcyBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byBkZWZlciB0aGlzXG4gICAgICAgIC8vIGZvciBlYWNoIG51bGwgdmFsdWUuIEhvd2V2ZXIsIHdlIGFsc28gZG9uJ3Qgd2FudCB0byBjYWxsIHVwZGF0ZVNsb3RcbiAgICAgICAgLy8gd2l0aCB0aGUgcHJldmlvdXMgb25lLlxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcjtcbiAgICAgIH1cblxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKG5ld0lkeCA9PT0gbmV3Q2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG5ldyBjaGlsZHJlbi4gV2UgY2FuIGRlbGV0ZSB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG5cbiAgICAgIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgICAgIHZhciBudW1iZXJPZkZvcmtzID0gbmV3SWR4O1xuICAgICAgICBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIG51bWJlck9mRm9ya3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZXhpc3RpbmcgY2hpbGRyZW4gd2UgY2FuIGNob29zZSBhIGZhc3QgcGF0aFxuICAgICAgLy8gc2luY2UgdGhlIHJlc3Qgd2lsbCBhbGwgYmUgaW5zZXJ0aW9ucy5cbiAgICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgbGFuZXMsIGRlYnVnSW5mbyk7XG5cbiAgICAgICAgaWYgKF9uZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcblxuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI7XG4gICAgICB9XG5cbiAgICAgIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgICAgIHZhciBfbnVtYmVyT2ZGb3JrcyA9IG5ld0lkeDtcbiAgICAgICAgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBfbnVtYmVyT2ZGb3Jrcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH0gLy8gQWRkIGFsbCBjaGlsZHJlbiB0byBhIGtleSBtYXAgZm9yIHF1aWNrIGxvb2t1cHMuXG5cblxuICAgIHZhciBleGlzdGluZ0NoaWxkcmVuID0gbWFwUmVtYWluaW5nQ2hpbGRyZW4ob2xkRmliZXIpOyAvLyBLZWVwIHNjYW5uaW5nIGFuZCB1c2UgdGhlIG1hcCB0byByZXN0b3JlIGRlbGV0ZWQgaXRlbXMgYXMgbW92ZXMuXG5cbiAgICBmb3IgKDsgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgdmFyIF9uZXdGaWJlcjIgPSB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIG5ld0NoaWxkcmVuW25ld0lkeF0sIGxhbmVzLCBkZWJ1Z0luZm8pO1xuXG4gICAgICBpZiAoX25ld0ZpYmVyMiAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXIyLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZGVsZXRlKF9uZXdGaWJlcjIua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyMi5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyMiwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyMjtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXIyO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAgIHZhciBfbnVtYmVyT2ZGb3JrczIgPSBuZXdJZHg7XG4gICAgICBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIF9udW1iZXJPZkZvcmtzMik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdGFibGUocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbkl0ZXJhYmxlLCBsYW5lcywgZGVidWdJbmZvKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgc2FtZSBpbXBsZW1lbnRhdGlvbiBhcyByZWNvbmNpbGVDaGlsZHJlbkFycmF5KCksXG4gICAgLy8gYnV0IHVzaW5nIHRoZSBpdGVyYXRvciBpbnN0ZWFkLlxuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihuZXdDaGlsZHJlbkl0ZXJhYmxlKTtcblxuICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBvYmplY3QgaXMgbm90IGFuIGl0ZXJhYmxlLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gJyArICdSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuXG4gICAgdmFyIG5ld0NoaWxkcmVuID0gaXRlcmF0b3JGbi5jYWxsKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuXG4gICAge1xuICAgICAgaWYgKG5ld0NoaWxkcmVuID09PSBuZXdDaGlsZHJlbkl0ZXJhYmxlKSB7XG4gICAgICAgIC8vIFdlIGRvbid0IHN1cHBvcnQgcmVuZGVyaW5nIEdlbmVyYXRvcnMgYXMgcHJvcHMgYmVjYXVzZSBpdCdzIGEgbXV0YXRpb24uXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEyOTk1XG4gICAgICAgIC8vIFdlIGRvIHN1cHBvcnQgZ2VuZXJhdG9ycyBpZiB0aGV5IHdlcmUgY3JlYXRlZCBieSBhIEdlbmVyYXRvckZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAvLyBhcyBpdHMgZGlyZWN0IGNoaWxkIHNpbmNlIHdlIGNhbiByZWNyZWF0ZSB0aG9zZSBieSByZXJlbmRlcmluZyB0aGUgY29tcG9uZW50XG4gICAgICAgIC8vIGFzIG5lZWRlZC5cbiAgICAgICAgdmFyIGlzR2VuZXJhdG9yQ29tcG9uZW50ID0gcmV0dXJuRmliZXIudGFnID09PSBGdW5jdGlvbkNvbXBvbmVudCAmJiAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChyZXR1cm5GaWJlci50eXBlKSA9PT0gJ1tvYmplY3QgR2VuZXJhdG9yRnVuY3Rpb25dJyAmJiAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChuZXdDaGlsZHJlbikgPT09ICdbb2JqZWN0IEdlbmVyYXRvcl0nO1xuXG4gICAgICAgIGlmICghaXNHZW5lcmF0b3JDb21wb25lbnQpIHtcbiAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dEdlbmVyYXRvcnMpIHtcbiAgICAgICAgICAgIGVycm9yKCdVc2luZyBJdGVyYXRvcnMgYXMgY2hpbGRyZW4gaXMgdW5zdXBwb3J0ZWQgYW5kIHdpbGwgbGlrZWx5IHlpZWxkICcgKyAndW5leHBlY3RlZCByZXN1bHRzIGJlY2F1c2UgZW51bWVyYXRpbmcgYSBnZW5lcmF0b3IgbXV0YXRlcyBpdC4gJyArICdZb3UgbWF5IGNvbnZlcnQgaXQgdG8gYW4gYXJyYXkgd2l0aCBgQXJyYXkuZnJvbSgpYCBvciB0aGUgJyArICdgWy4uLnNwcmVhZF1gIG9wZXJhdG9yIGJlZm9yZSByZW5kZXJpbmcuIFlvdSBjYW4gYWxzbyB1c2UgYW4gJyArICdJdGVyYWJsZSB0aGF0IGNhbiBpdGVyYXRlIG11bHRpcGxlIHRpbWVzIG92ZXIgdGhlIHNhbWUgaXRlbXMuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZGlkV2FybkFib3V0R2VuZXJhdG9ycyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobmV3Q2hpbGRyZW5JdGVyYWJsZS5lbnRyaWVzID09PSBpdGVyYXRvckZuKSB7XG4gICAgICAgIC8vIFdhcm4gYWJvdXQgdXNpbmcgTWFwcyBhcyBjaGlsZHJlblxuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dE1hcHMpIHtcbiAgICAgICAgICBlcnJvcignVXNpbmcgTWFwcyBhcyBjaGlsZHJlbiBpcyBub3Qgc3VwcG9ydGVkLiAnICsgJ1VzZSBhbiBhcnJheSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJyk7XG5cbiAgICAgICAgICBkaWRXYXJuQWJvdXRNYXBzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGRyZW4sIGxhbmVzLCBkZWJ1Z0luZm8pO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvcihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkcmVuLCBsYW5lcywgZGVidWdJbmZvKSB7XG4gICAgaWYgKG5ld0NoaWxkcmVuID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQW4gaXRlcmFibGUgb2JqZWN0IHByb3ZpZGVkIG5vIGl0ZXJhdG9yLicpO1xuICAgIH1cblxuICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXNOZXdGaWJlciA9IG51bGw7XG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG4gICAgdmFyIGtub3duS2V5cyA9IG51bGw7XG4gICAgdmFyIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCk7XG5cbiAgICB7XG4gICAgICBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KHN0ZXAudmFsdWUsIGtub3duS2V5cywgcmV0dXJuRmliZXIpO1xuICAgIH1cblxuICAgIGZvciAoOyBvbGRGaWJlciAhPT0gbnVsbCAmJiAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSwga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShzdGVwLnZhbHVlLCBrbm93bktleXMsIHJldHVybkZpYmVyKSApIHtcbiAgICAgIGlmIChvbGRGaWJlci5pbmRleCA+IG5ld0lkeCkge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlcjtcbiAgICAgICAgb2xkRmliZXIgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dE9sZEZpYmVyID0gb2xkRmliZXIuc2libGluZztcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld0ZpYmVyID0gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIHN0ZXAudmFsdWUsIGxhbmVzLCBkZWJ1Z0luZm8pO1xuXG4gICAgICBpZiAobmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogVGhpcyBicmVha3Mgb24gZW1wdHkgc2xvdHMgbGlrZSBudWxsIGNoaWxkcmVuLiBUaGF0J3NcbiAgICAgICAgLy8gdW5mb3J0dW5hdGUgYmVjYXVzZSBpdCB0cmlnZ2VycyB0aGUgc2xvdyBwYXRoIGFsbCB0aGUgdGltZS4gV2UgbmVlZFxuICAgICAgICAvLyBhIGJldHRlciB3YXkgdG8gY29tbXVuaWNhdGUgd2hldGhlciB0aGlzIHdhcyBhIG1pc3Mgb3IgbnVsbCxcbiAgICAgICAgLy8gYm9vbGVhbiwgdW5kZWZpbmVkLCBldGMuXG4gICAgICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIG9sZEZpYmVyID0gbmV4dE9sZEZpYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgIGlmIChvbGRGaWJlciAmJiBuZXdGaWJlci5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBtYXRjaGVkIHRoZSBzbG90LCBidXQgd2UgZGlkbid0IHJldXNlIHRoZSBleGlzdGluZyBmaWJlciwgc28gd2VcbiAgICAgICAgICAvLyBuZWVkIHRvIGRlbGV0ZSB0aGUgZXhpc3RpbmcgY2hpbGQuXG4gICAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IG5ld0ZpYmVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVE9ETzogRGVmZXIgc2libGluZ3MgaWYgd2UncmUgbm90IGF0IHRoZSByaWdodCBpbmRleCBmb3IgdGhpcyBzbG90LlxuICAgICAgICAvLyBJLmUuIGlmIHdlIGhhZCBudWxsIHZhbHVlcyBiZWZvcmUsIHRoZW4gd2Ugd2FudCB0byBkZWZlciB0aGlzXG4gICAgICAgIC8vIGZvciBlYWNoIG51bGwgdmFsdWUuIEhvd2V2ZXIsIHdlIGFsc28gZG9uJ3Qgd2FudCB0byBjYWxsIHVwZGF0ZVNsb3RcbiAgICAgICAgLy8gd2l0aCB0aGUgcHJldmlvdXMgb25lLlxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBuZXdGaWJlcjtcbiAgICAgIH1cblxuICAgICAgcHJldmlvdXNOZXdGaWJlciA9IG5ld0ZpYmVyO1xuICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgfVxuXG4gICAgaWYgKHN0ZXAuZG9uZSkge1xuICAgICAgLy8gV2UndmUgcmVhY2hlZCB0aGUgZW5kIG9mIHRoZSBuZXcgY2hpbGRyZW4uIFdlIGNhbiBkZWxldGUgdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuXG4gICAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgICAgICB2YXIgbnVtYmVyT2ZGb3JrcyA9IG5ld0lkeDtcbiAgICAgICAgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBudW1iZXJPZkZvcmtzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfVxuXG4gICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGFueSBtb3JlIGV4aXN0aW5nIGNoaWxkcmVuIHdlIGNhbiBjaG9vc2UgYSBmYXN0IHBhdGhcbiAgICAgIC8vIHNpbmNlIHRoZSByZXN0IHdpbGwgYWxsIGJlIGluc2VydGlvbnMuXG4gICAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgbmV3SWR4KyssIHN0ZXAgPSBuZXdDaGlsZHJlbi5uZXh0KCksIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoc3RlcC52YWx1ZSwga25vd25LZXlzLCByZXR1cm5GaWJlcikgKSB7XG4gICAgICAgIHZhciBfbmV3RmliZXIzID0gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIHN0ZXAudmFsdWUsIGxhbmVzLCBkZWJ1Z0luZm8pO1xuXG4gICAgICAgIGlmIChfbmV3RmliZXIzID09PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjMsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcblxuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRPRE86IE1vdmUgb3V0IG9mIHRoZSBsb29wLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgdGhlIGZpcnN0IHJ1bi5cbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIzO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjM7XG4gICAgICB9XG5cbiAgICAgIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgICAgIHZhciBfbnVtYmVyT2ZGb3JrczMgPSBuZXdJZHg7XG4gICAgICAgIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgX251bWJlck9mRm9ya3MzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfSAvLyBBZGQgYWxsIGNoaWxkcmVuIHRvIGEga2V5IG1hcCBmb3IgcXVpY2sgbG9va3Vwcy5cblxuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBtYXBSZW1haW5pbmdDaGlsZHJlbihvbGRGaWJlcik7IC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cblxuICAgIGZvciAoOyAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSwga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShzdGVwLnZhbHVlLCBrbm93bktleXMsIHJldHVybkZpYmVyKSApIHtcbiAgICAgIHZhciBfbmV3RmliZXI0ID0gdXBkYXRlRnJvbU1hcChleGlzdGluZ0NoaWxkcmVuLCByZXR1cm5GaWJlciwgbmV3SWR4LCBzdGVwLnZhbHVlLCBsYW5lcywgZGVidWdJbmZvKTtcblxuICAgICAgaWYgKF9uZXdGaWJlcjQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgICBpZiAoX25ld0ZpYmVyNC5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZSBuZXcgZmliZXIgaXMgYSB3b3JrIGluIHByb2dyZXNzLCBidXQgaWYgdGhlcmUgZXhpc3RzIGFcbiAgICAgICAgICAgIC8vIGN1cnJlbnQsIHRoYXQgbWVhbnMgdGhhdCB3ZSByZXVzZWQgdGhlIGZpYmVyLiBXZSBuZWVkIHRvIGRlbGV0ZVxuICAgICAgICAgICAgLy8gaXQgZnJvbSB0aGUgY2hpbGQgbGlzdCBzbyB0aGF0IHdlIGRvbid0IGFkZCBpdCB0byB0aGUgZGVsZXRpb25cbiAgICAgICAgICAgIC8vIGxpc3QuXG4gICAgICAgICAgICBleGlzdGluZ0NoaWxkcmVuLmRlbGV0ZShfbmV3RmliZXI0LmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IF9uZXdGaWJlcjQua2V5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlcjQsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcblxuICAgICAgICBpZiAocHJldmlvdXNOZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXI0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjQ7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyNDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gQW55IGV4aXN0aW5nIGNoaWxkcmVuIHRoYXQgd2VyZW4ndCBjb25zdW1lZCBhYm92ZSB3ZXJlIGRlbGV0ZWQuIFdlIG5lZWRcbiAgICAgIC8vIHRvIGFkZCB0aGVtIHRvIHRoZSBkZWxldGlvbiBsaXN0LlxuICAgICAgZXhpc3RpbmdDaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICByZXR1cm4gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgICB2YXIgX251bWJlck9mRm9ya3M0ID0gbmV3SWR4O1xuICAgICAgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBfbnVtYmVyT2ZGb3JrczQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlVGV4dE5vZGUocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCB0ZXh0Q29udGVudCwgbGFuZXMpIHtcbiAgICAvLyBUaGVyZSdzIG5vIG5lZWQgdG8gY2hlY2sgZm9yIGtleXMgb24gdGV4dCBub2RlcyBzaW5jZSB3ZSBkb24ndCBoYXZlIGFcbiAgICAvLyB3YXkgdG8gZGVmaW5lIHRoZW0uXG4gICAgaWYgKGN1cnJlbnRGaXJzdENoaWxkICE9PSBudWxsICYmIGN1cnJlbnRGaXJzdENoaWxkLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgIC8vIFdlIGFscmVhZHkgaGF2ZSBhbiBleGlzdGluZyBub2RlIHNvIGxldCdzIGp1c3QgdXBkYXRlIGl0IGFuZCBkZWxldGVcbiAgICAgIC8vIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLnNpYmxpbmcpO1xuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudEZpcnN0Q2hpbGQsIHRleHRDb250ZW50KTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgcmV0dXJuIGV4aXN0aW5nO1xuICAgIH0gLy8gVGhlIGV4aXN0aW5nIGZpcnN0IGNoaWxkIGlzIG5vdCBhIHRleHQgbm9kZSBzbyB3ZSBuZWVkIHRvIGNyZWF0ZSBvbmVcbiAgICAvLyBhbmQgZGVsZXRlIHRoZSBleGlzdGluZyBvbmVzLlxuXG5cbiAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQpO1xuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tVGV4dCh0ZXh0Q29udGVudCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVFbGVtZW50KHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgZWxlbWVudCwgbGFuZXMsIGRlYnVnSW5mbykge1xuICAgIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIHZhciBlbGVtZW50VHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgICAgICBpZiAoZWxlbWVudFR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgICAgICBpZiAoY2hpbGQudGFnID09PSBGcmFnbWVudCkge1xuICAgICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY2hpbGQsIGVsZW1lbnQucHJvcHMuY2hpbGRyZW4pO1xuICAgICAgICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICAgICAgZXhpc3RpbmcuX2RlYnVnSW5mbyA9IGRlYnVnSW5mbztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQsIGV4aXN0aW5nLCByZXR1cm5GaWJlcik7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjaGlsZC5lbGVtZW50VHlwZSA9PT0gZWxlbWVudFR5cGUgfHwgKCAvLyBLZWVwIHRoaXMgY2hlY2sgaW5saW5lIHNvIGl0IG9ubHkgcnVucyBvbiB0aGUgZmFsc2UgcGF0aDpcbiAgICAgICAgICBpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmcoY2hpbGQsIGVsZW1lbnQpICkgfHwgLy8gTGF6eSB0eXBlcyBzaG91bGQgcmVjb25jaWxlIHRoZWlyIHJlc29sdmVkIHR5cGUuXG4gICAgICAgICAgLy8gV2UgbmVlZCB0byBkbyB0aGlzIGFmdGVyIHRoZSBIb3QgUmVsb2FkaW5nIGNoZWNrIGFib3ZlLFxuICAgICAgICAgIC8vIGJlY2F1c2UgaG90IHJlbG9hZGluZyBoYXMgZGlmZmVyZW50IHNlbWFudGljcyB0aGFuIHByb2QgYmVjYXVzZVxuICAgICAgICAgIC8vIGl0IGRvZXNuJ3QgcmVzdXNwZW5kLiBTbyB3ZSBjYW4ndCBsZXQgdGhlIGNhbGwgYmVsb3cgc3VzcGVuZC5cbiAgICAgICAgICB0eXBlb2YgZWxlbWVudFR5cGUgPT09ICdvYmplY3QnICYmIGVsZW1lbnRUeXBlICE9PSBudWxsICYmIGVsZW1lbnRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgJiYgcmVzb2x2ZUxhenkoZWxlbWVudFR5cGUpID09PSBjaGlsZC50eXBlKSB7XG4gICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQuc2libGluZyk7XG5cbiAgICAgICAgICAgIHZhciBfZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgZWxlbWVudC5wcm9wcyk7XG5cbiAgICAgICAgICAgIGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY2hpbGQsIF9leGlzdGluZywgZWxlbWVudCk7XG4gICAgICAgICAgICBfZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgX2V4aXN0aW5nLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICAgICAgICAgIF9leGlzdGluZy5fZGVidWdJbmZvID0gZGVidWdJbmZvO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2V4aXN0aW5nO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBEaWRuJ3QgbWF0Y2guXG5cblxuICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG5cbiAgICBpZiAoZWxlbWVudC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGVsZW1lbnQucHJvcHMuY2hpbGRyZW4sIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzLCBlbGVtZW50LmtleSk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICB7XG4gICAgICAgIGNyZWF0ZWQuX2RlYnVnSW5mbyA9IGRlYnVnSW5mbztcbiAgICAgIH1cblxuICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQsIGNyZWF0ZWQsIHJldHVybkZpYmVyKTtcbiAgICAgIHJldHVybiBjcmVhdGVkO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2NyZWF0ZWQ0ID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG5cbiAgICAgIGNvZXJjZVJlZihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIF9jcmVhdGVkNCwgZWxlbWVudCk7XG4gICAgICBfY3JlYXRlZDQucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgIHtcbiAgICAgICAgX2NyZWF0ZWQ0Ll9kZWJ1Z0luZm8gPSBkZWJ1Z0luZm87XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfY3JlYXRlZDQ7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlU2luZ2xlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgcG9ydGFsLCBsYW5lcywgZGVidWdJbmZvKSB7XG4gICAgdmFyIGtleSA9IHBvcnRhbC5rZXk7XG4gICAgdmFyIGNoaWxkID0gY3VycmVudEZpcnN0Q2hpbGQ7XG5cbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIC8vIFRPRE86IElmIGtleSA9PT0gbnVsbCBhbmQgY2hpbGQua2V5ID09PSBudWxsLCB0aGVuIHRoaXMgb25seSBhcHBsaWVzIHRvXG4gICAgICAvLyB0aGUgZmlyc3QgaXRlbSBpbiB0aGUgbGlzdC5cbiAgICAgIGlmIChjaGlsZC5rZXkgPT09IGtleSkge1xuICAgICAgICBpZiAoY2hpbGQudGFnID09PSBIb3N0UG9ydGFsICYmIGNoaWxkLnN0YXRlTm9kZS5jb250YWluZXJJbmZvID09PSBwb3J0YWwuY29udGFpbmVySW5mbyAmJiBjaGlsZC5zdGF0ZU5vZGUuaW1wbGVtZW50YXRpb24gPT09IHBvcnRhbC5pbXBsZW1lbnRhdGlvbikge1xuICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcbiAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgcG9ydGFsLmNoaWxkcmVuIHx8IFtdKTtcbiAgICAgICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH0gLy8gVGhpcyBBUEkgd2lsbCB0YWcgdGhlIGNoaWxkcmVuIHdpdGggdGhlIHNpZGUtZWZmZWN0IG9mIHRoZSByZWNvbmNpbGlhdGlvblxuICAvLyBpdHNlbGYuIFRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGUgc2lkZS1lZmZlY3QgbGlzdCBhcyB3ZSBwYXNzIHRocm91Z2ggdGhlXG4gIC8vIGNoaWxkcmVuIGFuZCB0aGUgcGFyZW50LlxuXG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRGaWJlcnNJbXBsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGxhbmVzLCBkZWJ1Z0luZm8pIHtcbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIG9ubHkgcmVjdXJzaXZlIGZvciBVc2FibGVzL0xhenkgYW5kIG5vdCBuZXN0ZWQgYXJyYXlzLlxuICAgIC8vIFRoYXQncyBzbyB0aGF0IHVzaW5nIGEgTGF6eSB3cmFwcGVyIGlzIHVub2JzZXJ2YWJsZSB0byB0aGUgRnJhZ21lbnRcbiAgICAvLyBjb252ZW50aW9uLlxuICAgIC8vIElmIHRoZSB0b3AgbGV2ZWwgaXRlbSBpcyBhbiBhcnJheSwgd2UgdHJlYXQgaXQgYXMgYSBzZXQgb2YgY2hpbGRyZW4sXG4gICAgLy8gbm90IGFzIGEgZnJhZ21lbnQuIE5lc3RlZCBhcnJheXMgb24gdGhlIG90aGVyIGhhbmQgd2lsbCBiZSB0cmVhdGVkIGFzXG4gICAgLy8gZnJhZ21lbnQgbm9kZXMuIFJlY3Vyc2lvbiBoYXBwZW5zIGF0IHRoZSBub3JtYWwgZmxvdy5cbiAgICAvLyBIYW5kbGUgdG9wIGxldmVsIHVua2V5ZWQgZnJhZ21lbnRzIGFzIGlmIHRoZXkgd2VyZSBhcnJheXMuXG4gICAgLy8gVGhpcyBsZWFkcyB0byBhbiBhbWJpZ3VpdHkgYmV0d2VlbiA8PntbLi4uXX08Lz4gYW5kIDw+Li4uPC8+LlxuICAgIC8vIFdlIHRyZWF0IHRoZSBhbWJpZ3VvdXMgY2FzZXMgYWJvdmUgdGhlIHNhbWUuXG4gICAgLy8gV2UgZG9uJ3QgdXNlIHJlY3Vyc2lvbiBoZXJlIGJlY2F1c2UgYSBmcmFnbWVudCBpbnNpZGUgYSBmcmFnbWVudFxuICAgIC8vIGlzIG5vIGxvbmdlciBjb25zaWRlcmVkIFwidG9wIGxldmVsXCIgZm9yIHRoZXNlIHB1cnBvc2VzLlxuICAgIHZhciBpc1Vua2V5ZWRUb3BMZXZlbEZyYWdtZW50ID0gdHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCAmJiBuZXdDaGlsZC50eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFICYmIG5ld0NoaWxkLmtleSA9PT0gbnVsbDtcblxuICAgIGlmIChpc1Vua2V5ZWRUb3BMZXZlbEZyYWdtZW50KSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMobmV3Q2hpbGQsIG51bGwsIHJldHVybkZpYmVyKTtcbiAgICAgIG5ld0NoaWxkID0gbmV3Q2hpbGQucHJvcHMuY2hpbGRyZW47XG4gICAgfSAvLyBIYW5kbGUgb2JqZWN0IHR5cGVzXG5cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKG5ld0NoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMsIG1lcmdlRGVidWdJbmZvKGRlYnVnSW5mbywgbmV3Q2hpbGQuX2RlYnVnSW5mbykpKTtcblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVBvcnRhbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcykpO1xuXG4gICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgIHZhciBwYXlsb2FkID0gbmV3Q2hpbGQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBuZXdDaGlsZC5faW5pdDtcbiAgICAgICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRGaWJlcnNJbXBsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgaW5pdChwYXlsb2FkKSwgbGFuZXMsIG1lcmdlRGVidWdJbmZvKGRlYnVnSW5mbywgbmV3Q2hpbGQuX2RlYnVnSW5mbykpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNBcnJheShuZXdDaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMsIG1lcmdlRGVidWdJbmZvKGRlYnVnSW5mbywgbmV3Q2hpbGQuX2RlYnVnSW5mbykpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2V0SXRlcmF0b3JGbihuZXdDaGlsZCkpIHtcbiAgICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0YWJsZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcywgbWVyZ2VEZWJ1Z0luZm8oZGVidWdJbmZvLCBuZXdDaGlsZC5fZGVidWdJbmZvKSk7XG4gICAgICB9XG4gICAgICAvLyBhIGNoaWxkIHBvc2l0aW9uLCBpdCB1bndyYXBzIGl0IHVzaW5nIHRoZSBzYW1lIGFsZ29yaXRobSBhcyBgdXNlYC4gRm9yXG4gICAgICAvLyBleGFtcGxlLCBmb3IgcHJvbWlzZXMsIFJlYWN0IHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIHRvIHVud2luZCB0aGVcbiAgICAgIC8vIHN0YWNrLCB0aGVuIHJlcGxheSB0aGUgY29tcG9uZW50IG9uY2UgdGhlIHByb21pc2UgcmVzb2x2ZXMuXG4gICAgICAvL1xuICAgICAgLy8gQSBkaWZmZXJlbmNlIGZyb20gYHVzZWAgaXMgdGhhdCBSZWFjdCB3aWxsIGtlZXAgdW53cmFwcGluZyB0aGUgdmFsdWVcbiAgICAgIC8vIHVudGlsIGl0IHJlYWNoZXMgYSBub24tVXNhYmxlIHR5cGUuXG4gICAgICAvL1xuICAgICAgLy8gZS5nLiBVc2FibGU8VXNhYmxlPFVzYWJsZTxUPj4+IHNob3VsZCByZXNvbHZlIHRvIFRcbiAgICAgIC8vXG4gICAgICAvLyBUaGUgc3RydWN0dXJlIGlzIGEgYml0IHVuZm9ydHVuYXRlLiBJZGVhbGx5LCB3ZSBzaG91bGRuJ3QgbmVlZCB0b1xuICAgICAgLy8gcmVwbGF5IHRoZSBlbnRpcmUgYmVnaW4gcGhhc2Ugb2YgdGhlIHBhcmVudCBmaWJlciBpbiBvcmRlciB0byByZWNvbmNpbGVcbiAgICAgIC8vIHRoZSBjaGlsZHJlbiBhZ2Fpbi4gVGhpcyB3b3VsZCByZXF1aXJlIGEgc29tZXdoYXQgc2lnbmlmaWNhbnQgcmVmYWN0b3IsXG4gICAgICAvLyBiZWNhdXNlIHJlY29uY2lsYXRpb24gaGFwcGVucyBkZWVwIHdpdGhpbiB0aGUgYmVnaW4gcGhhc2UsIGFuZFxuICAgICAgLy8gZGVwZW5kaW5nIG9uIHRoZSB0eXBlIG9mIHdvcmssIG5vdCBhbHdheXMgYXQgdGhlIGVuZC4gV2Ugc2hvdWxkXG4gICAgICAvLyBjb25zaWRlciBhcyBhbiBmdXR1cmUgaW1wcm92ZW1lbnQuXG5cblxuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZC50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciB0aGVuYWJsZSA9IG5ld0NoaWxkO1xuICAgICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRGaWJlcnNJbXBsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgdW53cmFwVGhlbmFibGUodGhlbmFibGUpLCBsYW5lcywgbWVyZ2VEZWJ1Z0luZm8oZGVidWdJbmZvLCB0aGVuYWJsZS5fZGVidWdJbmZvKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdDaGlsZC4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gbmV3Q2hpbGQ7XG4gICAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCByZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uKHJldHVybkZpYmVyLCBjb250ZXh0LCBsYW5lcyksIGxhbmVzLCBkZWJ1Z0luZm8pO1xuICAgICAgfVxuXG4gICAgICB0aHJvd09uSW52YWxpZE9iamVjdFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyAmJiBuZXdDaGlsZCAhPT0gJycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdiaWdpbnQnKSB7XG4gICAgICByZXR1cm4gcGxhY2VTaW5nbGVDaGlsZChyZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIC8vICRGbG93Rml4TWVbdW5zYWZlLWFkZGl0aW9uXSBGbG93IGRvZXNuJ3Qgd2FudCB1cyB0byB1c2UgYCtgIG9wZXJhdG9yIHdpdGggc3RyaW5nIGFuZCBiaWdpbnRcbiAgICAgICcnICsgbmV3Q2hpbGQsIGxhbmVzKSk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgd2Fybk9uU3ltYm9sVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgfVxuICAgIH0gLy8gUmVtYWluaW5nIGNhc2VzIGFyZSBhbGwgdHJlYXRlZCBhcyBlbXB0eS5cblxuXG4gICAgcmV0dXJuIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZEZpYmVycyhyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcykge1xuICAgIC8vIFRoaXMgaW5kaXJlY3Rpb24gb25seSBleGlzdHMgc28gd2UgY2FuIHJlc2V0IGB0aGVuYWJsZVN0YXRlYCBhdCB0aGUgZW5kLlxuICAgIC8vIEl0IHNob3VsZCBnZXQgaW5saW5lZCBieSBDbG9zdXJlLlxuICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyJDEgPSAwO1xuICAgIHZhciBmaXJzdENoaWxkRmliZXIgPSByZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMsIG51bGwgLy8gZGVidWdJbmZvXG4gICAgKTtcbiAgICB0aGVuYWJsZVN0YXRlJDEgPSBudWxsOyAvLyBEb24ndCBib3RoZXIgdG8gcmVzZXQgYHRoZW5hYmxlSW5kZXhDb3VudGVyYCB0byAwIGJlY2F1c2UgaXQgYWx3YXlzIGdldHNcbiAgICAvLyBzZXQgYXQgdGhlIGJlZ2lubmluZy5cblxuICAgIHJldHVybiBmaXJzdENoaWxkRmliZXI7XG4gIH1cblxuICByZXR1cm4gcmVjb25jaWxlQ2hpbGRGaWJlcnM7XG59XG5cbnZhciByZWNvbmNpbGVDaGlsZEZpYmVycyA9IGNyZWF0ZUNoaWxkUmVjb25jaWxlcih0cnVlKTtcbnZhciBtb3VudENoaWxkRmliZXJzID0gY3JlYXRlQ2hpbGRSZWNvbmNpbGVyKGZhbHNlKTtcbmZ1bmN0aW9uIHJlc2V0Q2hpbGRSZWNvbmNpbGVyT25VbndpbmQoKSB7XG4gIC8vIE9uIHVud2luZCwgY2xlYXIgYW55IHBlbmRpbmcgdGhlbmFibGVzIHRoYXQgd2VyZSB1c2VkLlxuICB0aGVuYWJsZVN0YXRlJDEgPSBudWxsO1xuICB0aGVuYWJsZUluZGV4Q291bnRlciQxID0gMDtcbn1cbmZ1bmN0aW9uIGNsb25lQ2hpbGRGaWJlcnMoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3MuY2hpbGQgIT09IGN1cnJlbnQuY2hpbGQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc3VtaW5nIHdvcmsgbm90IHlldCBpbXBsZW1lbnRlZC4nKTtcbiAgfVxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9PT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjdXJyZW50Q2hpbGQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgdmFyIG5ld0NoaWxkID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBjdXJyZW50Q2hpbGQucGVuZGluZ1Byb3BzKTtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXdDaGlsZDtcbiAgbmV3Q2hpbGQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG5cbiAgd2hpbGUgKGN1cnJlbnRDaGlsZC5zaWJsaW5nICE9PSBudWxsKSB7XG4gICAgY3VycmVudENoaWxkID0gY3VycmVudENoaWxkLnNpYmxpbmc7XG4gICAgbmV3Q2hpbGQgPSBuZXdDaGlsZC5zaWJsaW5nID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBjdXJyZW50Q2hpbGQucGVuZGluZ1Byb3BzKTtcbiAgICBuZXdDaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgfVxuXG4gIG5ld0NoaWxkLnNpYmxpbmcgPSBudWxsO1xufSAvLyBSZXNldCBhIHdvcmtJblByb2dyZXNzIGNoaWxkIHNldCB0byBwcmVwYXJlIGl0IGZvciBhIHNlY29uZCBwYXNzLlxuXG5mdW5jdGlvbiByZXNldENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBsYW5lcykge1xuICB2YXIgY2hpbGQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICByZXNldFdvcmtJblByb2dyZXNzKGNoaWxkLCBsYW5lcyk7XG4gICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICB9XG59XG5cbi8vIFRPRE86IFRoaXMgaXNuJ3QgYmVpbmcgdXNlZCB5ZXQsIGJ1dCBpdCdzIGludGVuZGVkIHRvIHJlcGxhY2UgdGhlXG4vLyBJbnZpc2libGVQYXJlbnRDb250ZXh0IHRoYXQgaXMgY3VycmVudGx5IG1hbmFnZWQgYnkgU3VzcGVuc2VDb250ZXh0LlxuXG52YXIgY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKTtcbnZhciBwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXNDdXJzb3IgPSBjcmVhdGVDdXJzb3IoTm9MYW5lcyk7XG5mdW5jdGlvbiBwdXNoSGlkZGVuQ29udGV4dChmaWJlciwgY29udGV4dCkge1xuICB2YXIgcHJldkVudGFuZ2xlZFJlbmRlckxhbmVzID0gZ2V0RW50YW5nbGVkUmVuZGVyTGFuZXMoKTtcbiAgcHVzaChwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXNDdXJzb3IsIHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lcywgZmliZXIpO1xuICBwdXNoKGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IsIGNvbnRleHQsIGZpYmVyKTsgLy8gV2hlbiByZW5kZXJpbmcgYSBzdWJ0cmVlIHRoYXQncyBjdXJyZW50bHkgaGlkZGVuLCB3ZSBtdXN0IGluY2x1ZGUgYWxsXG4gIC8vIGxhbmVzIHRoYXQgd291bGQgaGF2ZSByZW5kZXJlZCBpZiB0aGUgaGlkZGVuIHN1YnRyZWUgaGFkbid0IGJlZW4gZGVmZXJyZWQuXG4gIC8vIFRoYXQgaXMsIGluIG9yZGVyIHRvIHJldmVhbCBjb250ZW50IGZyb20gaGlkZGVuIC0+IHZpc2libGUsIHdlIG11c3QgY29tbWl0XG4gIC8vIGFsbCB0aGUgdXBkYXRlcyB0aGF0IHdlIHNraXBwZWQgd2hlbiB3ZSBvcmlnaW5hbGx5IGhpZCB0aGUgdHJlZS5cblxuICBzZXRFbnRhbmdsZWRSZW5kZXJMYW5lcyhtZXJnZUxhbmVzKHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lcywgY29udGV4dC5iYXNlTGFuZXMpKTtcbn1cbmZ1bmN0aW9uIHJldXNlSGlkZGVuQ29udGV4dE9uU3RhY2soZmliZXIpIHtcbiAgLy8gVGhpcyBzdWJ0cmVlIGlzIG5vdCBjdXJyZW50bHkgaGlkZGVuLCBzbyB3ZSBkb24ndCBuZWVkIHRvIGFkZCBhbnkgbGFuZXNcbiAgLy8gdG8gdGhlIHJlbmRlciBsYW5lcy4gQnV0IHdlIHN0aWxsIG5lZWQgdG8gcHVzaCBzb21ldGhpbmcgdG8gYXZvaWQgYVxuICAvLyBjb250ZXh0IG1pc21hdGNoLiBSZXVzZSB0aGUgZXhpc3RpbmcgY29udGV4dCBvbiB0aGUgc3RhY2suXG4gIHB1c2gocHJldkVudGFuZ2xlZFJlbmRlckxhbmVzQ3Vyc29yLCBnZXRFbnRhbmdsZWRSZW5kZXJMYW5lcygpLCBmaWJlcik7XG4gIHB1c2goY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvciwgY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvci5jdXJyZW50LCBmaWJlcik7XG59XG5mdW5jdGlvbiBwb3BIaWRkZW5Db250ZXh0KGZpYmVyKSB7XG4gIC8vIFJlc3RvcmUgdGhlIHByZXZpb3VzIHJlbmRlciBsYW5lcyBmcm9tIHRoZSBzdGFja1xuICBzZXRFbnRhbmdsZWRSZW5kZXJMYW5lcyhwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXNDdXJzb3IuY3VycmVudCk7XG4gIHBvcChjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIHBvcChwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXNDdXJzb3IsIGZpYmVyKTtcbn1cbmZ1bmN0aW9uIGlzQ3VycmVudFRyZWVIaWRkZW4oKSB7XG4gIHJldHVybiBjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yLmN1cnJlbnQgIT09IG51bGw7XG59XG5cbi8vIHN1c3BlbmRzLCBpLmUuIGl0J3MgdGhlIG5lYXJlc3QgYGNhdGNoYCBibG9jayBvbiB0aGUgc3RhY2suXG5cbnZhciBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKTsgLy8gUmVwcmVzZW50cyB0aGUgb3V0ZXJtb3N0IGJvdW5kYXJ5IHRoYXQgaXMgbm90IHZpc2libGUgaW4gdGhlIGN1cnJlbnQgdHJlZS5cbi8vIEV2ZXJ5dGhpbmcgYWJvdmUgdGhpcyBpcyB0aGUgXCJzaGVsbFwiLiBXaGVuIHRoaXMgaXMgbnVsbCwgaXQgbWVhbnMgd2UncmVcbi8vIHJlbmRlcmluZyBpbiB0aGUgc2hlbGwgb2YgdGhlIGFwcC4gSWYgaXQncyBub24tbnVsbCwgaXQgbWVhbnMgd2UncmUgcmVuZGVyaW5nXG4vLyBkZWVwZXIgdGhhbiB0aGUgc2hlbGwsIGluc2lkZSBhIG5ldyB0cmVlIHRoYXQgd2Fzbid0IGFscmVhZHkgdmlzaWJsZS5cbi8vXG4vLyBUaGUgbWFpbiB3YXkgd2UgdXNlIHRoaXMgY29uY2VwdCBpcyB0byBkZXRlcm1pbmUgd2hldGhlciBzaG93aW5nIGEgZmFsbGJhY2tcbi8vIHdvdWxkIHJlc3VsdCBpbiBhIGRlc2lyYWJsZSBvciB1bmRlc2lyYWJsZSBsb2FkaW5nIHN0YXRlLiBBY3RpdmluZyBhIGZhbGxiYWNrXG4vLyBpbiB0aGUgc2hlbGwgaXMgY29uc2lkZXJlZCBhbiB1bmRlcnNpcmFibGUgbG9hZGluZyBzdGF0ZSwgYmVjYXVzZSBpdCB3b3VsZFxuLy8gbWVhbiBoaWRpbmcgdmlzaWJsZSAoYWxiZWl0IHN0YWxlKSBjb250ZW50IGluIHRoZSBjdXJyZW50IHRyZWUg4oCUIHdlIHByZWZlciB0b1xuLy8gc2hvdyB0aGUgc3RhbGUgY29udGVudCwgcmF0aGVyIHRoYW4gc3dpdGNoIHRvIGEgZmFsbGJhY2suIEJ1dCBzaG93aW5nIGFcbi8vIGZhbGxiYWNrIGluIGEgbmV3IHRyZWUgaXMgZmluZSwgYmVjYXVzZSB0aGVyZSdzIG5vIHN0YWxlIGNvbnRlbnQgdG9cbi8vIHByZWZlciBpbnN0ZWFkLlxuXG52YXIgc2hlbGxCb3VuZGFyeSA9IG51bGw7XG5mdW5jdGlvbiBnZXRTaGVsbEJvdW5kYXJ5KCkge1xuICByZXR1cm4gc2hlbGxCb3VuZGFyeTtcbn1cbmZ1bmN0aW9uIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcihoYW5kbGVyKSB7XG4gIC8vIFRPRE86IFBhc3MgYXMgYXJndW1lbnRcbiAgdmFyIGN1cnJlbnQgPSBoYW5kbGVyLmFsdGVybmF0ZTtcbiAgLy8gcHJvcGFnYXRlZCBhIHNpbmdsZSBsZXZlbC4gRm9yIGV4YW1wbGUsIHdoZW4gRm9yY2VTdXNwZW5zZUZhbGxiYWNrIGlzIHNldCxcbiAgLy8gaXQgc2hvdWxkIG9ubHkgZm9yY2UgdGhlIG5lYXJlc3QgU3VzcGVuc2UgYm91bmRhcnkgaW50byBmYWxsYmFjayBtb2RlLlxuXG4gIHB1c2hTdXNwZW5zZUxpc3RDb250ZXh0KGhhbmRsZXIsIHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VMaXN0Q29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQpKTsgLy8gRXhwZXJpbWVudGFsIGZlYXR1cmU6IFNvbWUgU3VzcGVuc2UgYm91bmRhcmllcyBhcmUgbWFya2VkIGFzIGhhdmluZyBhblxuICAvLyB0byBwdXNoIGEgbmVzdGVkIFN1c3BlbnNlIGhhbmRsZXIsIGJlY2F1c2UgaXQgd2lsbCBnZXQgcmVwbGFjZWQgYnkgdGhlXG4gIC8vIG91dGVyIGZhbGxiYWNrLCBhbnl3YXkuIENvbnNpZGVyIHRoaXMgYXMgYSBmdXR1cmUgb3B0aW1pemF0aW9uLlxuXG5cbiAgcHVzaChzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvciwgaGFuZGxlciwgaGFuZGxlcik7XG5cbiAgaWYgKHNoZWxsQm91bmRhcnkgPT09IG51bGwpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBpc0N1cnJlbnRUcmVlSGlkZGVuKCkpIHtcbiAgICAgIC8vIFRoaXMgYm91bmRhcnkgaXMgbm90IHZpc2libGUgaW4gdGhlIGN1cnJlbnQgVUkuXG4gICAgICBzaGVsbEJvdW5kYXJ5ID0gaGFuZGxlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIGJvdW5kYXJ5IGlzIHNob3dpbmcgYSBmYWxsYmFjayBpbiB0aGUgY3VycmVudCBVSS5cbiAgICAgICAgc2hlbGxCb3VuZGFyeSA9IGhhbmRsZXI7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwdXNoRmFsbGJhY2tUcmVlU3VzcGVuc2VIYW5kbGVyKGZpYmVyKSB7XG4gIC8vIFdlJ3JlIGFib3V0IHRvIHJlbmRlciB0aGUgZmFsbGJhY2suIElmIHNvbWV0aGluZyBpbiB0aGUgZmFsbGJhY2sgc3VzcGVuZHMsXG4gIC8vIGl0J3MgYWtpbiB0byB0aHJvd2luZyBpbnNpZGUgb2YgYSBgY2F0Y2hgIGJsb2NrLiBUaGlzIGJvdW5kYXJ5IHNob3VsZCBub3RcbiAgLy8gY2FwdHVyZS4gUmV1c2UgdGhlIGV4aXN0aW5nIGhhbmRsZXIgb24gdGhlIHN0YWNrLlxuICByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2soZmliZXIpO1xufVxuZnVuY3Rpb24gcHVzaE9mZnNjcmVlblN1c3BlbnNlSGFuZGxlcihmaWJlcikge1xuICBpZiAoZmliZXIudGFnID09PSBPZmZzY3JlZW5Db21wb25lbnQpIHtcbiAgICAvLyBBIFN1c3BlbnNlTGlzdCBjb250ZXh0IGlzIG9ubHkgcHVzaGVkIGhlcmUgdG8gYXZvaWQgYSBwdXNoL3BvcCBtaXNtYXRjaC5cbiAgICAvLyBSZXVzZSB0aGUgY3VycmVudCB2YWx1ZSBvbiB0aGUgc3RhY2suXG4gICAgLy8gVE9ETzogV2UgY2FuIGF2b2lkIG5lZWRpbmcgdG8gcHVzaCBoZXJlIGJ5IGJ5IGZvcmtpbmcgcG9wU3VzcGVuc2VIYW5kbGVyXG4gICAgLy8gaW50byBzZXBhcmF0ZSBmdW5jdGlvbnMgZm9yIFN1c3BlbnNlIGFuZCBPZmZzY3JlZW4uXG4gICAgcHVzaFN1c3BlbnNlTGlzdENvbnRleHQoZmliZXIsIHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gICAgcHVzaChzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKTtcblxuICAgIGlmIChzaGVsbEJvdW5kYXJ5ICE9PSBudWxsKSA7IGVsc2Uge1xuICAgICAgdmFyIGN1cnJlbnQgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGJvdW5kYXJ5IGluIHRoZSBzdGFjayB0aGF0J3MgYWxyZWFkeSBzaG93aW5nXG4gICAgICAgICAgLy8gYSBmYWxsYmFjay4gU28gZXZlcnl0aGluZyBvdXRzaWRlIGlzIGNvbnNpZGVyZWQgdGhlIHNoZWxsLlxuICAgICAgICAgIHNoZWxsQm91bmRhcnkgPSBmaWJlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIGEgTGVnYWN5SGlkZGVuIGNvbXBvbmVudC5cbiAgICByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2soZmliZXIpO1xuICB9XG59XG5mdW5jdGlvbiByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2soZmliZXIpIHtcbiAgcHVzaFN1c3BlbnNlTGlzdENvbnRleHQoZmliZXIsIHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG4gIHB1c2goc3VzcGVuc2VIYW5kbGVyU3RhY2tDdXJzb3IsIGdldFN1c3BlbnNlSGFuZGxlcigpLCBmaWJlcik7XG59XG5mdW5jdGlvbiBnZXRTdXNwZW5zZUhhbmRsZXIoKSB7XG4gIHJldHVybiBzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvci5jdXJyZW50O1xufVxuZnVuY3Rpb24gcG9wU3VzcGVuc2VIYW5kbGVyKGZpYmVyKSB7XG4gIHBvcChzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvciwgZmliZXIpO1xuXG4gIGlmIChzaGVsbEJvdW5kYXJ5ID09PSBmaWJlcikge1xuICAgIC8vIFBvcHBpbmcgYmFjayBpbnRvIHRoZSBzaGVsbC5cbiAgICBzaGVsbEJvdW5kYXJ5ID0gbnVsbDtcbiAgfVxuXG4gIHBvcFN1c3BlbnNlTGlzdENvbnRleHQoZmliZXIpO1xufSAvLyBTdXNwZW5zZUxpc3QgY29udGV4dFxuLy8gVE9ETzogTW92ZSB0byBhIHNlcGFyYXRlIG1vZHVsZT8gV2UgbWF5IGNoYW5nZSB0aGUgU3VzcGVuc2VMaXN0XG4vLyBpbXBsZW1lbnRhdGlvbiB0byBoaWRlL3Nob3cgaW4gdGhlIGNvbW1pdCBwaGFzZSwgYW55d2F5LlxuXG52YXIgRGVmYXVsdFN1c3BlbnNlQ29udGV4dCA9IDA7XG52YXIgU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2sgPSAxOyAvLyBGb3JjZVN1c3BlbnNlRmFsbGJhY2sgY2FuIGJlIHVzZWQgYnkgU3VzcGVuc2VMaXN0IHRvIGZvcmNlIG5ld2x5IGFkZGVkXG4vLyBpdGVtcyBpbnRvIHRoZWlyIGZhbGxiYWNrIHN0YXRlIGR1cmluZyBvbmUgb2YgdGhlIHJlbmRlciBwYXNzZXMuXG5cbnZhciBGb3JjZVN1c3BlbnNlRmFsbGJhY2sgPSAyO1xudmFyIHN1c3BlbnNlU3RhY2tDdXJzb3IgPSBjcmVhdGVDdXJzb3IoRGVmYXVsdFN1c3BlbnNlQ29udGV4dCk7XG5mdW5jdGlvbiBoYXNTdXNwZW5zZUxpc3RDb250ZXh0KHBhcmVudENvbnRleHQsIGZsYWcpIHtcbiAgcmV0dXJuIChwYXJlbnRDb250ZXh0ICYgZmxhZykgIT09IDA7XG59XG5mdW5jdGlvbiBzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlTGlzdENvbnRleHQocGFyZW50Q29udGV4dCkge1xuICByZXR1cm4gcGFyZW50Q29udGV4dCAmIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrO1xufVxuZnVuY3Rpb24gc2V0U2hhbGxvd1N1c3BlbnNlTGlzdENvbnRleHQocGFyZW50Q29udGV4dCwgc2hhbGxvd0NvbnRleHQpIHtcbiAgcmV0dXJuIHBhcmVudENvbnRleHQgJiBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzayB8IHNoYWxsb3dDb250ZXh0O1xufVxuZnVuY3Rpb24gcHVzaFN1c3BlbnNlTGlzdENvbnRleHQoZmliZXIsIG5ld0NvbnRleHQpIHtcbiAgcHVzaChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBuZXdDb250ZXh0LCBmaWJlcik7XG59XG5mdW5jdGlvbiBwb3BTdXNwZW5zZUxpc3RDb250ZXh0KGZpYmVyKSB7XG4gIHBvcChzdXNwZW5zZVN0YWNrQ3Vyc29yLCBmaWJlcik7XG59XG5cbi8vIEEgbm9uLW51bGwgU3VzcGVuc2VTdGF0ZSBtZWFucyB0aGF0IGl0IGlzIGJsb2NrZWQgZm9yIG9uZSByZWFzb24gb3IgYW5vdGhlci5cbi8vIC0gQSBub24tbnVsbCBkZWh5ZHJhdGVkIGZpZWxkIG1lYW5zIGl0J3MgYmxvY2tlZCBwZW5kaW5nIGh5ZHJhdGlvbi5cbi8vICAgLSBBIG5vbi1udWxsIGRlaHlkcmF0ZWQgZmllbGQgY2FuIHVzZSBpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nIG9yXG4vLyAgICAgaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2sgdG8gcXVlcnkgdGhlIHJlYXNvbiBmb3IgYmVpbmcgZGVoeWRyYXRlZC5cbi8vIC0gQSBudWxsIGRlaHlkcmF0ZWQgZmllbGQgbWVhbnMgaXQncyBibG9ja2VkIGJ5IHNvbWV0aGluZyBzdXNwZW5kaW5nIGFuZFxuLy8gICB3ZSdyZSBjdXJyZW50bHkgc2hvd2luZyBhIGZhbGxiYWNrIGluc3RlYWQuXG5cbmZ1bmN0aW9uIGZpbmRGaXJzdFN1c3BlbmRlZChyb3cpIHtcbiAgdmFyIG5vZGUgPSByb3c7XG5cbiAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgICB2YXIgc3RhdGUgPSBub2RlLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgIGlmIChzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgZGVoeWRyYXRlZCA9IHN0YXRlLmRlaHlkcmF0ZWQ7XG5cbiAgICAgICAgaWYgKGRlaHlkcmF0ZWQgPT09IG51bGwgfHwgaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyhkZWh5ZHJhdGVkKSB8fCBpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayhkZWh5ZHJhdGVkKSkge1xuICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gU3VzcGVuc2VMaXN0Q29tcG9uZW50ICYmIC8vIHJldmVhbE9yZGVyIHVuZGVmaW5lZCBjYW4ndCBiZSB0cnVzdGVkIGJlY2F1c2UgaXQgZG9uJ3RcbiAgICAvLyBrZWVwIHRyYWNrIG9mIHdoZXRoZXIgaXQgc3VzcGVuZGVkIG9yIG5vdC5cbiAgICBub2RlLm1lbW9pemVkUHJvcHMucmV2ZWFsT3JkZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGRpZFN1c3BlbmQgPSAobm9kZS5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzJDE7XG5cbiAgICAgIGlmIChkaWRTdXNwZW5kKSB7XG4gICAgICAgIHJldHVybiBub2RlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gcm93KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IHJvdykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cblxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBOb0ZsYWdzID1cbi8qICAgKi9cbjA7IC8vIFJlcHJlc2VudHMgd2hldGhlciBlZmZlY3Qgc2hvdWxkIGZpcmUuXG5cbnZhciBIYXNFZmZlY3QgPVxuLyogKi9cbjE7IC8vIFJlcHJlc2VudHMgdGhlIHBoYXNlIGluIHdoaWNoIHRoZSBlZmZlY3QgKG5vdCB0aGUgY2xlYW4tdXApIGZpcmVzLlxuXG52YXIgSW5zZXJ0aW9uID1cbi8qICovXG4yO1xudmFyIExheW91dCA9XG4vKiAgICAqL1xuNDtcbnZhciBQYXNzaXZlID1cbi8qICAgKi9cbjg7XG5cbnZhciBkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQ7XG52YXIgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3Q7XG52YXIgZGlkV2FybkFib3V0VXNlV3JhcHBlZEluVHJ5Q2F0Y2g7XG52YXIgZGlkV2FybkFib3V0QXN5bmNDbGllbnRDb21wb25lbnQ7XG52YXIgZGlkV2FybkFib3V0VXNlRm9ybVN0YXRlO1xuXG57XG4gIGRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0VXNlV3JhcHBlZEluVHJ5Q2F0Y2ggPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dEFzeW5jQ2xpZW50Q29tcG9uZW50ID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRVc2VGb3JtU3RhdGUgPSBuZXcgU2V0KCk7XG59IC8vIFRoZSBlZmZlY3QgXCJpbnN0YW5jZVwiIGlzIGEgc2hhcmVkIG9iamVjdCB0aGF0IHJlbWFpbnMgdGhlIHNhbWUgZm9yIHRoZSBlbnRpcmVcbi8vIGxpZmV0aW1lIG9mIGFuIGVmZmVjdC4gSW4gUnVzdCB0ZXJtcywgYSBSZWZDZWxsLiBXZSB1c2UgaXQgdG8gc3RvcmUgdGhlXG4vLyBcImRlc3Ryb3lcIiBmdW5jdGlvbiB0aGF0IGlzIHJldHVybmVkIGZyb20gYW4gZWZmZWN0LCBiZWNhdXNlIHRoYXQgaXMgc3RhdGVmdWwuXG4vLyBUaGUgZmllbGQgaXMgYHVuZGVmaW5lZGAgaWYgdGhlIGVmZmVjdCBpcyB1bm1vdW50ZWQsIG9yIGlmIHRoZSBlZmZlY3QgcmFuXG4vLyBidXQgaXMgbm90IHN0YXRlZnVsLiBXZSBkb24ndCBleHBsaWNpdGx5IHRyYWNrIHdoZXRoZXIgdGhlIGVmZmVjdCBpcyBtb3VudGVkXG4vLyBvciB1bm1vdW50ZWQgYmVjYXVzZSB0aGF0IGNhbiBiZSBpbmZlcnJlZCBieSB0aGUgaGlkZGVubmVzcyBvZiB0aGUgZmliZXIgaW5cbi8vIHRoZSB0cmVlLCBpLmUuIHdoZXRoZXIgdGhlcmUgaXMgYSBoaWRkZW4gT2Zmc2NyZWVuIGZpYmVyIGFib3ZlIGl0LlxuLy9cbi8vIEl0J3MgdW5mb3J0dW5hdGUgdGhhdCB0aGlzIGlzIHN0b3JlZCBvbiBhIHNlcGFyYXRlIG9iamVjdCwgYmVjYXVzZSBpdCBhZGRzXG4vLyBtb3JlIG1lbW9yeSBwZXIgZWZmZWN0IGluc3RhbmNlLCBidXQgaXQncyBjb25jZXB0dWFsbHkgc291bmQuIEkgdGhpbmsgdGhlcmUnc1xuLy8gbGlrZWx5IGEgYmV0dGVyIGRhdGEgc3RydWN0dXJlIHdlIGNvdWxkIHVzZSBmb3IgZWZmZWN0czsgcGVyaGFwcyBqdXN0IG9uZVxuLy8gYXJyYXkgb2YgZWZmZWN0IGluc3RhbmNlcyBwZXIgZmliZXIuIEJ1dCBJIHRoaW5rIHRoaXMgaXMgT0sgZm9yIG5vdyBkZXNwaXRlXG4vLyB0aGUgYWRkaXRpb25hbCBtZW1vcnkgYW5kIHdlIGNhbiBmb2xsb3cgdXAgd2l0aCBwZXJmb3JtYW5jZVxuLy8gb3B0aW1pemF0aW9ucyBsYXRlci5cbi8vIFRoZXNlIGFyZSBzZXQgcmlnaHQgYmVmb3JlIGNhbGxpbmcgdGhlIGNvbXBvbmVudC5cblxuXG52YXIgcmVuZGVyTGFuZXMgPSBOb0xhbmVzOyAvLyBUaGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci4gSSd2ZSBuYW1lZCBpdCBkaWZmZXJlbnRseSB0byBkaXN0aW5ndWlzaCBpdCBmcm9tXG4vLyB0aGUgd29yay1pbi1wcm9ncmVzcyBob29rLlxuXG52YXIgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IG51bGw7IC8vIEhvb2tzIGFyZSBzdG9yZWQgYXMgYSBsaW5rZWQgbGlzdCBvbiB0aGUgZmliZXIncyBtZW1vaXplZFN0YXRlIGZpZWxkLiBUaGVcbi8vIGN1cnJlbnQgaG9vayBsaXN0IGlzIHRoZSBsaXN0IHRoYXQgYmVsb25ncyB0byB0aGUgY3VycmVudCBmaWJlci4gVGhlXG4vLyB3b3JrLWluLXByb2dyZXNzIGhvb2sgbGlzdCBpcyBhIG5ldyBsaXN0IHRoYXQgd2lsbCBiZSBhZGRlZCB0byB0aGVcbi8vIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuXG5cbnZhciBjdXJyZW50SG9vayA9IG51bGw7XG52YXIgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDsgLy8gV2hldGhlciBhbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBhdCBhbnkgcG9pbnQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuIFRoaXNcbi8vIGRvZXMgbm90IGdldCByZXNldCBpZiB3ZSBkbyBhbm90aGVyIHJlbmRlciBwYXNzOyBvbmx5IHdoZW4gd2UncmUgY29tcGxldGVseVxuLy8gZmluaXNoZWQgZXZhbHVhdGluZyB0aGlzIGNvbXBvbmVudC4gVGhpcyBpcyBhbiBvcHRpbWl6YXRpb24gc28gd2Uga25vd1xuLy8gd2hldGhlciB3ZSBuZWVkIHRvIGNsZWFyIHJlbmRlciBwaGFzZSB1cGRhdGVzIGFmdGVyIGEgdGhyb3cuXG5cbnZhciBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7IC8vIFdoZXJlIGFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIG9ubHkgZHVyaW5nIHRoZSBjdXJyZW50IHJlbmRlciBwYXNzLiBUaGlzXG4vLyBnZXRzIHJlc2V0IGFmdGVyIGVhY2ggYXR0ZW1wdC5cbi8vIFRPRE86IE1heWJlIHRoZXJlJ3Mgc29tZSB3YXkgdG8gY29uc29saWRhdGUgdGhpcyB3aXRoXG4vLyBgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZWAuIE9yIHdpdGggYG51bWJlck9mUmVSZW5kZXJzYC5cblxudmFyIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9IGZhbHNlO1xudmFyIHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWID0gZmFsc2U7IC8vIENvdW50cyB0aGUgbnVtYmVyIG9mIHVzZUlkIGhvb2tzIGluIHRoaXMgY29tcG9uZW50LlxuXG52YXIgbG9jYWxJZENvdW50ZXIgPSAwOyAvLyBDb3VudHMgbnVtYmVyIG9mIGB1c2VgLWQgdGhlbmFibGVzXG5cbnZhciB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG52YXIgdGhlbmFibGVTdGF0ZSA9IG51bGw7IC8vIFVzZWQgZm9yIGlkcyB0aGF0IGFyZSBnZW5lcmF0ZWQgY29tcGxldGVseSBjbGllbnQtc2lkZSAoaS5lLiBub3QgZHVyaW5nXG4vLyBoeWRyYXRpb24pLiBUaGlzIGNvdW50ZXIgaXMgZ2xvYmFsLCBzbyBjbGllbnQgaWRzIGFyZSBub3Qgc3RhYmxlIGFjcm9zc1xuLy8gcmVuZGVyIGF0dGVtcHRzLlxuXG52YXIgZ2xvYmFsQ2xpZW50SWRDb3VudGVyID0gMDtcbnZhciBSRV9SRU5ERVJfTElNSVQgPSAyNTsgLy8gSW4gREVWLCB0aGlzIGlzIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50bHkgZXhlY3V0aW5nIHByaW1pdGl2ZSBob29rXG5cbnZhciBjdXJyZW50SG9va05hbWVJbkRldiA9IG51bGw7IC8vIEluIERFViwgdGhpcyBsaXN0IGVuc3VyZXMgdGhhdCBob29rcyBhcmUgY2FsbGVkIGluIHRoZSBzYW1lIG9yZGVyIGJldHdlZW4gcmVuZGVycy5cbi8vIFRoZSBsaXN0IHN0b3JlcyB0aGUgb3JkZXIgb2YgaG9va3MgdXNlZCBkdXJpbmcgdGhlIGluaXRpYWwgcmVuZGVyIChtb3VudCkuXG4vLyBTdWJzZXF1ZW50IHJlbmRlcnMgKHVwZGF0ZXMpIHJlZmVyZW5jZSB0aGlzIGxpc3QuXG5cbnZhciBob29rVHlwZXNEZXYgPSBudWxsO1xudmFyIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7IC8vIEluIERFViwgdGhpcyB0cmFja3Mgd2hldGhlciBjdXJyZW50bHkgcmVuZGVyaW5nIGNvbXBvbmVudCBuZWVkcyB0byBpZ25vcmVcbi8vIHRoZSBkZXBlbmRlbmNpZXMgZm9yIEhvb2tzIHRoYXQgbmVlZCB0aGVtIChlLmcuIHVzZUVmZmVjdCBvciB1c2VNZW1vKS5cbi8vIFdoZW4gdHJ1ZSwgc3VjaCBIb29rcyB3aWxsIGFsd2F5cyBiZSBcInJlbW91bnRlZFwiLiBPbmx5IHVzZWQgZHVyaW5nIGhvdCByZWxvYWQuXG5cbnZhciBpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBtb3VudEhvb2tUeXBlc0RldigpIHtcbiAge1xuICAgIHZhciBob29rTmFtZSA9IGN1cnJlbnRIb29rTmFtZUluRGV2O1xuXG4gICAgaWYgKGhvb2tUeXBlc0RldiA9PT0gbnVsbCkge1xuICAgICAgaG9va1R5cGVzRGV2ID0gW2hvb2tOYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgaG9va1R5cGVzRGV2LnB1c2goaG9va05hbWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVIb29rVHlwZXNEZXYoKSB7XG4gIHtcbiAgICB2YXIgaG9va05hbWUgPSBjdXJyZW50SG9va05hbWVJbkRldjtcblxuICAgIGlmIChob29rVHlwZXNEZXYgIT09IG51bGwpIHtcbiAgICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2Kys7XG5cbiAgICAgIGlmIChob29rVHlwZXNEZXZbaG9va1R5cGVzVXBkYXRlSW5kZXhEZXZdICE9PSBob29rTmFtZSkge1xuICAgICAgICB3YXJuT25Ib29rTWlzbWF0Y2hJbkRldihob29rTmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpIHtcbiAge1xuICAgIGlmIChkZXBzICE9PSB1bmRlZmluZWQgJiYgZGVwcyAhPT0gbnVsbCAmJiAhaXNBcnJheShkZXBzKSkge1xuICAgICAgLy8gVmVyaWZ5IGRlcHMsIGJ1dCBvbmx5IG9uIG1vdW50IHRvIGF2b2lkIGV4dHJhIGNoZWNrcy5cbiAgICAgIC8vIEl0J3MgdW5saWtlbHkgdGhlaXIgdHlwZSB3b3VsZCBjaGFuZ2UgYXMgdXN1YWxseSB5b3UgZGVmaW5lIHRoZW0gaW5saW5lLlxuICAgICAgZXJyb3IoJyVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgdGhhdCBpcyBub3QgYW4gYXJyYXkgKGluc3RlYWQsIHJlY2VpdmVkIGAlc2ApLiBXaGVuICcgKyAnc3BlY2lmaWVkLCB0aGUgZmluYWwgYXJndW1lbnQgbXVzdCBiZSBhbiBhcnJheS4nLCBjdXJyZW50SG9va05hbWVJbkRldiwgdHlwZW9mIGRlcHMpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuT25Ib29rTWlzbWF0Y2hJbkRldihjdXJyZW50SG9va05hbWUpIHtcbiAge1xuICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxKTtcblxuICAgIGlmICghZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50LmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgaWYgKGhvb2tUeXBlc0RldiAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgdGFibGUgPSAnJztcbiAgICAgICAgdmFyIHNlY29uZENvbHVtblN0YXJ0ID0gMzA7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gaG9va1R5cGVzVXBkYXRlSW5kZXhEZXY7IGkrKykge1xuICAgICAgICAgIHZhciBvbGRIb29rTmFtZSA9IGhvb2tUeXBlc0RldltpXTtcbiAgICAgICAgICB2YXIgbmV3SG9va05hbWUgPSBpID09PSBob29rVHlwZXNVcGRhdGVJbmRleERldiA/IGN1cnJlbnRIb29rTmFtZSA6IG9sZEhvb2tOYW1lO1xuICAgICAgICAgIHZhciByb3cgPSBpICsgMSArIFwiLiBcIiArIG9sZEhvb2tOYW1lOyAvLyBFeHRyYSBzcGFjZSBzbyBzZWNvbmQgY29sdW1uIGxpbmVzIHVwXG4gICAgICAgICAgLy8gbG9sIEAgSUUgbm90IHN1cHBvcnRpbmcgU3RyaW5nI3JlcGVhdFxuXG4gICAgICAgICAgd2hpbGUgKHJvdy5sZW5ndGggPCBzZWNvbmRDb2x1bW5TdGFydCkge1xuICAgICAgICAgICAgcm93ICs9ICcgJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByb3cgKz0gbmV3SG9va05hbWUgKyAnXFxuJztcbiAgICAgICAgICB0YWJsZSArPSByb3c7XG4gICAgICAgIH1cblxuICAgICAgICBlcnJvcignUmVhY3QgaGFzIGRldGVjdGVkIGEgY2hhbmdlIGluIHRoZSBvcmRlciBvZiBIb29rcyBjYWxsZWQgYnkgJXMuICcgKyAnVGhpcyB3aWxsIGxlYWQgdG8gYnVncyBhbmQgZXJyb3JzIGlmIG5vdCBmaXhlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVhZCB0aGUgUnVsZXMgb2YgSG9va3M6IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvcnVsZXMtb2YtaG9va3NcXG5cXG4nICsgJyAgIFByZXZpb3VzIHJlbmRlciAgICAgICAgICAgIE5leHQgcmVuZGVyXFxuJyArICcgICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cXG4nICsgJyVzJyArICcgICBeXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cXG4nLCBjb21wb25lbnROYW1lLCB0YWJsZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5PblVzZUZvcm1TdGF0ZUluRGV2KCkge1xuICB7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEpO1xuXG4gICAgaWYgKCFkaWRXYXJuQWJvdXRVc2VGb3JtU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICBkaWRXYXJuQWJvdXRVc2VGb3JtU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICBlcnJvcignUmVhY3RET00udXNlRm9ybVN0YXRlIGhhcyBiZWVuIHJlbmFtZWQgdG8gUmVhY3QudXNlQWN0aW9uU3RhdGUuICcgKyAnUGxlYXNlIHVwZGF0ZSAlcyB0byB1c2UgUmVhY3QudXNlQWN0aW9uU3RhdGUuJywgY29tcG9uZW50TmFtZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5JZkFzeW5jQ2xpZW50Q29tcG9uZW50KENvbXBvbmVudCkge1xuICB7XG4gICAgLy8gVGhpcyBkZXYtb25seSBjaGVjayBvbmx5IHdvcmtzIGZvciBkZXRlY3RpbmcgbmF0aXZlIGFzeW5jIGZ1bmN0aW9ucyxcbiAgICAvLyBub3QgdHJhbnNwaWxlZCBvbmVzLiBUaGVyZSdzIGFsc28gYSBwcm9kIGNoZWNrIHRoYXQgd2UgdXNlIHRvIHByZXZlbnRcbiAgICAvLyBhc3luYyBjbGllbnQgY29tcG9uZW50cyBmcm9tIGNyYXNoaW5nIHRoZSBhcHA7IHRoZSBwcm9kIG9uZSB3b3JrcyBldmVuXG4gICAgLy8gZm9yIHRyYW5zcGlsZWQgYXN5bmMgZnVuY3Rpb25zLiBOZWl0aGVyIG1lY2hhbmlzbSBpcyBjb21wbGV0ZWx5XG4gICAgLy8gYnVsbGV0cHJvb2YgYnV0IHRvZ2V0aGVyIHRoZXkgY292ZXIgdGhlIG1vc3QgY29tbW9uIGNhc2VzLlxuICAgIHZhciBpc0FzeW5jRnVuY3Rpb24gPSAvLyAkRmxvd0lnbm9yZVttZXRob2QtdW5iaW5kaW5nXVxuICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChDb21wb25lbnQpID09PSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScgfHwgLy8gJEZsb3dJZ25vcmVbbWV0aG9kLXVuYmluZGluZ11cbiAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoQ29tcG9uZW50KSA9PT0gJ1tvYmplY3QgQXN5bmNHZW5lcmF0b3JGdW5jdGlvbl0nO1xuXG4gICAgaWYgKGlzQXN5bmNGdW5jdGlvbikge1xuICAgICAgLy8gRW5jb3VudGVyZWQgYW4gYXN5bmMgQ2xpZW50IENvbXBvbmVudC4gVGhpcyBpcyBub3QgeWV0IHN1cHBvcnRlZC5cbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRBc3luY0NsaWVudENvbXBvbmVudC5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0QXN5bmNDbGllbnRDb21wb25lbnQuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGVycm9yKCdhc3luYy9hd2FpdCBpcyBub3QgeWV0IHN1cHBvcnRlZCBpbiBDbGllbnQgQ29tcG9uZW50cywgb25seSAnICsgJ1NlcnZlciBDb21wb25lbnRzLiBUaGlzIGVycm9yIGlzIG9mdGVuIGNhdXNlZCBieSBhY2NpZGVudGFsbHkgJyArIFwiYWRkaW5nIGAndXNlIGNsaWVudCdgIHRvIGEgbW9kdWxlIHRoYXQgd2FzIG9yaWdpbmFsbHkgd3JpdHRlbiBcIiArICdmb3IgdGhlIHNlcnZlci4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGhyb3dJbnZhbGlkSG9va0Vycm9yKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaG9vayBjYWxsLiBIb29rcyBjYW4gb25seSBiZSBjYWxsZWQgaW5zaWRlIG9mIHRoZSBib2R5IG9mIGEgZnVuY3Rpb24gY29tcG9uZW50LiBUaGlzIGNvdWxkIGhhcHBlbiBmb3InICsgJyBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbicgKyAnMS4gWW91IG1pZ2h0IGhhdmUgbWlzbWF0Y2hpbmcgdmVyc2lvbnMgb2YgUmVhY3QgYW5kIHRoZSByZW5kZXJlciAoc3VjaCBhcyBSZWFjdCBET00pXFxuJyArICcyLiBZb3UgbWlnaHQgYmUgYnJlYWtpbmcgdGhlIFJ1bGVzIG9mIEhvb2tzXFxuJyArICczLiBZb3UgbWlnaHQgaGF2ZSBtb3JlIHRoYW4gb25lIGNvcHkgb2YgUmVhY3QgaW4gdGhlIHNhbWUgYXBwXFxuJyArICdTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9pbnZhbGlkLWhvb2stY2FsbCBmb3IgdGlwcyBhYm91dCBob3cgdG8gZGVidWcgYW5kIGZpeCB0aGlzIHByb2JsZW0uJyk7XG59XG5cbmZ1bmN0aW9uIGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpIHtcbiAge1xuICAgIGlmIChpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcykge1xuICAgICAgLy8gT25seSB0cnVlIHdoZW4gdGhpcyBjb21wb25lbnQgaXMgYmVpbmcgaG90IHJlbG9hZGVkLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcmV2RGVwcyA9PT0gbnVsbCkge1xuICAgIHtcbiAgICAgIGVycm9yKCclcyByZWNlaXZlZCBhIGZpbmFsIGFyZ3VtZW50IGR1cmluZyB0aGlzIHJlbmRlciwgYnV0IG5vdCBkdXJpbmcgJyArICd0aGUgcHJldmlvdXMgcmVuZGVyLiBFdmVuIHRob3VnaCB0aGUgZmluYWwgYXJndW1lbnQgaXMgb3B0aW9uYWwsICcgKyAnaXRzIHR5cGUgY2Fubm90IGNoYW5nZSBiZXR3ZWVuIHJlbmRlcnMuJywgY3VycmVudEhvb2tOYW1lSW5EZXYpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHtcbiAgICAvLyBEb24ndCBib3RoZXIgY29tcGFyaW5nIGxlbmd0aHMgaW4gcHJvZCBiZWNhdXNlIHRoZXNlIGFycmF5cyBzaG91bGQgYmVcbiAgICAvLyBwYXNzZWQgaW5saW5lLlxuICAgIGlmIChuZXh0RGVwcy5sZW5ndGggIT09IHByZXZEZXBzLmxlbmd0aCkge1xuICAgICAgZXJyb3IoJ1RoZSBmaW5hbCBhcmd1bWVudCBwYXNzZWQgdG8gJXMgY2hhbmdlZCBzaXplIGJldHdlZW4gcmVuZGVycy4gVGhlICcgKyAnb3JkZXIgYW5kIHNpemUgb2YgdGhpcyBhcnJheSBtdXN0IHJlbWFpbiBjb25zdGFudC5cXG5cXG4nICsgJ1ByZXZpb3VzOiAlc1xcbicgKyAnSW5jb21pbmc6ICVzJywgY3VycmVudEhvb2tOYW1lSW5EZXYsIFwiW1wiICsgcHJldkRlcHMuam9pbignLCAnKSArIFwiXVwiLCBcIltcIiArIG5leHREZXBzLmpvaW4oJywgJykgKyBcIl1cIik7XG4gICAgfVxuICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2RGVwcy5sZW5ndGggJiYgaSA8IG5leHREZXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgaWYgKG9iamVjdElzKG5leHREZXBzW2ldLCBwcmV2RGVwc1tpXSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZW5kZXJXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZywgbmV4dFJlbmRlckxhbmVzKSB7XG4gIHJlbmRlckxhbmVzID0gbmV4dFJlbmRlckxhbmVzO1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gd29ya0luUHJvZ3Jlc3M7XG5cbiAge1xuICAgIGhvb2tUeXBlc0RldiA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Ll9kZWJ1Z0hvb2tUeXBlcyA6IG51bGw7XG4gICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTsgLy8gVXNlZCBmb3IgaG90IHJlbG9hZGluZzpcblxuICAgIGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzID0gY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnR5cGUgIT09IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgd2FybklmQXN5bmNDbGllbnRDb21wb25lbnQoQ29tcG9uZW50KTtcbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzLmxhbmVzID0gTm9MYW5lczsgLy8gVGhlIGZvbGxvd2luZyBzaG91bGQgaGF2ZSBhbHJlYWR5IGJlZW4gcmVzZXRcbiAgLy8gY3VycmVudEhvb2sgPSBudWxsO1xuICAvLyB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICAvLyBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gIC8vIGxvY2FsSWRDb3VudGVyID0gMDtcbiAgLy8gdGhlbmFibGVJbmRleENvdW50ZXIgPSAwO1xuICAvLyB0aGVuYWJsZVN0YXRlID0gbnVsbDtcbiAgLy8gVE9ETyBXYXJuIGlmIG5vIGhvb2tzIGFyZSB1c2VkIGF0IGFsbCBkdXJpbmcgbW91bnQsIHRoZW4gc29tZSBhcmUgdXNlZCBkdXJpbmcgdXBkYXRlLlxuICAvLyBDdXJyZW50bHkgd2Ugd2lsbCBpZGVudGlmeSB0aGUgdXBkYXRlIHJlbmRlciBhcyBhIG1vdW50IGJlY2F1c2UgbWVtb2l6ZWRTdGF0ZSA9PT0gbnVsbC5cbiAgLy8gVGhpcyBpcyB0cmlja3kgYmVjYXVzZSBpdCdzIHZhbGlkIGZvciBjZXJ0YWluIHR5cGVzIG9mIGNvbXBvbmVudHMgKGUuZy4gUmVhY3QubGF6eSlcbiAgLy8gVXNpbmcgbWVtb2l6ZWRTdGF0ZSB0byBkaWZmZXJlbnRpYXRlIGJldHdlZW4gbW91bnQvdXBkYXRlIG9ubHkgd29ya3MgaWYgYXQgbGVhc3Qgb25lIHN0YXRlZnVsIGhvb2sgaXMgdXNlZC5cbiAgLy8gTm9uLXN0YXRlZnVsIGhvb2tzIChlLmcuIGNvbnRleHQpIGRvbid0IGdldCBhZGRlZCB0byBtZW1vaXplZFN0YXRlLFxuICAvLyBzbyBtZW1vaXplZFN0YXRlIHdvdWxkIGJlIG51bGwgZHVyaW5nIHVwZGF0ZXMgYW5kIG1vdW50cy5cblxuICB7XG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICB9IGVsc2UgaWYgKGhvb2tUeXBlc0RldiAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBkaXNwYXRjaGVyIGhhbmRsZXMgYW4gZWRnZSBjYXNlIHdoZXJlIGEgY29tcG9uZW50IGlzIHVwZGF0aW5nLFxuICAgICAgLy8gYnV0IG5vIHN0YXRlZnVsIGhvb2tzIGhhdmUgYmVlbiB1c2VkLlxuICAgICAgLy8gV2Ugd2FudCB0byBtYXRjaCB0aGUgcHJvZHVjdGlvbiBjb2RlIGJlaGF2aW9yICh3aGljaCB3aWxsIHVzZSBIb29rc0Rpc3BhdGNoZXJPbk1vdW50KSxcbiAgICAgIC8vIGJ1dCB3aXRoIHRoZSBleHRyYSBERVYgdmFsaWRhdGlvbiB0byBlbnN1cmUgaG9va3Mgb3JkZXJpbmcgaGFzbid0IGNoYW5nZWQuXG4gICAgICAvLyBUaGlzIGRpc3BhdGNoZXIgZG9lcyB0aGF0LlxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVY7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgfVxuICB9IC8vIEluIFN0cmljdCBNb2RlLCBkdXJpbmcgZGV2ZWxvcG1lbnQsIHVzZXIgZnVuY3Rpb25zIGFyZSBkb3VibGUgaW52b2tlZCB0b1xuICAvLyBoZWxwIGRldGVjdCBzaWRlIGVmZmVjdHMuIFRoZSBsb2dpYyBmb3IgaG93IHRoaXMgaXMgaW1wbGVtZW50ZWQgZm9yIGluXG4gIC8vIGhvb2sgY29tcG9uZW50cyBpcyBhIGJpdCBjb21wbGV4IHNvIGxldCdzIGJyZWFrIGl0IGRvd24uXG4gIC8vXG4gIC8vIFdlIHdpbGwgaW52b2tlIHRoZSBlbnRpcmUgY29tcG9uZW50IGZ1bmN0aW9uIHR3aWNlLiBIb3dldmVyLCBkdXJpbmcgdGhlXG4gIC8vIHNlY29uZCBpbnZvY2F0aW9uIG9mIHRoZSBjb21wb25lbnQsIHRoZSBob29rIHN0YXRlIGZyb20gdGhlIGZpcnN0XG4gIC8vIGludm9jYXRpb24gd2lsbCBiZSByZXVzZWQuIFRoYXQgbWVhbnMgdGhpbmdzIGxpa2UgYHVzZU1lbW9gIGZ1bmN0aW9ucyB3b24ndFxuICAvLyBydW4gYWdhaW4sIGJlY2F1c2UgdGhlIGRlcHMgd2lsbCBtYXRjaCBhbmQgdGhlIG1lbW9pemVkIHJlc3VsdCB3aWxsXG4gIC8vIGJlIHJldXNlZC5cbiAgLy9cbiAgLy8gV2Ugd2FudCBtZW1vaXplZCBmdW5jdGlvbnMgdG8gcnVuIHR3aWNlLCB0b28sIHNvIGFjY291bnQgZm9yIHRoaXMsIHVzZXJcbiAgLy8gZnVuY3Rpb25zIGFyZSBkb3VibGUgaW52b2tlZCBkdXJpbmcgdGhlICpmaXJzdCogaW52b2NhdGlvbiBvZiB0aGUgY29tcG9uZW50XG4gIC8vIGZ1bmN0aW9uLCBhbmQgYXJlICpub3QqIGRvdWJsZSBpbnZva2VkIGR1cmluZyB0aGUgc2Vjb25kIGluY292YXRpb246XG4gIC8vXG4gIC8vIC0gRmlyc3QgZXhlY3V0aW9uIG9mIGNvbXBvbmVudCBmdW5jdGlvbjogdXNlciBmdW5jdGlvbnMgYXJlIGRvdWJsZSBpbnZva2VkXG4gIC8vIC0gU2Vjb25kIGV4ZWN1dGlvbiBvZiBjb21wb25lbnQgZnVuY3Rpb24gKGluIFN0cmljdCBNb2RlLCBkdXJpbmdcbiAgLy8gICBkZXZlbG9wbWVudCk6IHVzZXIgZnVuY3Rpb25zIGFyZSBub3QgZG91YmxlIGludm9rZWQuXG4gIC8vXG4gIC8vIFRoaXMgaXMgaW50ZW50aW9uYWwgZm9yIGEgZmV3IHJlYXNvbnM7IG1vc3QgaW1wb3J0YW50bHksIGl0J3MgYmVjYXVzZSBvZlxuICAvLyBob3cgYHVzZWAgd29ya3Mgd2hlbiBzb21ldGhpbmcgc3VzcGVuZHM6IGl0IHJldXNlcyB0aGUgcHJvbWlzZSB0aGF0IHdhc1xuICAvLyBwYXNzZWQgZHVyaW5nIHRoZSBmaXJzdCBhdHRlbXB0LiBUaGlzIGlzIGl0c2VsZiBhIGZvcm0gb2YgbWVtb2l6YXRpb24uXG4gIC8vIFdlIG5lZWQgdG8gYmUgYWJsZSB0byBtZW1vaXplIHRoZSByZWFjdGl2ZSBpbnB1dHMgdG8gdGhlIGB1c2VgIGNhbGwgdXNpbmdcbiAgLy8gYSBob29rIChpLmUuIGB1c2VNZW1vYCksIHdoaWNoIG1lYW5zLCB0aGUgcmVhY3RpdmUgaW5wdXRzIHRvIGB1c2VgIG11c3RcbiAgLy8gY29tZSBmcm9tIHRoZSBzYW1lIGNvbXBvbmVudCBpbnZvY2F0aW9uIGFzIHRoZSBvdXRwdXQuXG4gIC8vXG4gIC8vIFRoZXJlIGFyZSBwbGVudHkgb2YgdGVzdHMgdG8gZW5zdXJlIHRoaXMgYmVoYXZpb3IgaXMgY29ycmVjdC5cblxuXG4gIHZhciBzaG91bGREb3VibGVSZW5kZXJERVYgPSAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpICE9PSBOb01vZGU7XG4gIHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWID0gc2hvdWxkRG91YmxlUmVuZGVyREVWO1xuICB2YXIgY2hpbGRyZW4gPSBDb21wb25lbnQocHJvcHMsIHNlY29uZEFyZyk7XG4gIHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWID0gZmFsc2U7IC8vIENoZWNrIGlmIHRoZXJlIHdhcyBhIHJlbmRlciBwaGFzZSB1cGRhdGVcblxuICBpZiAoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzKSB7XG4gICAgLy8gS2VlcCByZW5kZXJpbmcgdW50aWwgdGhlIGNvbXBvbmVudCBzdGFiaWxpemVzICh0aGVyZSBhcmUgbm8gbW9yZSByZW5kZXJcbiAgICAvLyBwaGFzZSB1cGRhdGVzKS5cbiAgICBjaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rc0FnYWluKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcpO1xuICB9XG5cbiAgaWYgKHNob3VsZERvdWJsZVJlbmRlckRFVikge1xuICAgIC8vIEluIGRldmVsb3BtZW50LCBjb21wb25lbnRzIGFyZSBpbnZva2VkIHR3aWNlIHRvIGhlbHAgZGV0ZWN0IHNpZGUgZWZmZWN0cy5cbiAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTtcblxuICAgIHRyeSB7XG4gICAgICBjaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rc0FnYWluKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgZmluaXNoUmVuZGVyaW5nSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIGZpbmlzaFJlbmRlcmluZ0hvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQpIHtcbiAge1xuICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z0hvb2tUeXBlcyA9IGhvb2tUeXBlc0RldjtcbiAgfSAvLyBXZSBjYW4gYXNzdW1lIHRoZSBwcmV2aW91cyBkaXNwYXRjaGVyIGlzIGFsd2F5cyB0aGlzIG9uZSwgc2luY2Ugd2Ugc2V0IGl0XG4gIC8vIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJlbmRlciBwaGFzZSBhbmQgdGhlcmUncyBubyByZS1lbnRyYW5jZS5cblxuXG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBDb250ZXh0T25seURpc3BhdGNoZXI7IC8vIFRoaXMgY2hlY2sgdXNlcyBjdXJyZW50SG9vayBzbyB0aGF0IGl0IHdvcmtzIHRoZSBzYW1lIGluIERFViBhbmQgcHJvZCBidW5kbGVzLlxuICAvLyBob29rVHlwZXNEZXYgY291bGQgY2F0Y2ggbW9yZSBjYXNlcyAoZS5nLiBjb250ZXh0KSBidXQgb25seSBpbiBERVYgYnVuZGxlcy5cblxuICB2YXIgZGlkUmVuZGVyVG9vRmV3SG9va3MgPSBjdXJyZW50SG9vayAhPT0gbnVsbCAmJiBjdXJyZW50SG9vay5uZXh0ICE9PSBudWxsO1xuICByZW5kZXJMYW5lcyA9IE5vTGFuZXM7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSBudWxsO1xuICBjdXJyZW50SG9vayA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG5cbiAge1xuICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gbnVsbDtcbiAgICBob29rVHlwZXNEZXYgPSBudWxsO1xuICAgIGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID0gLTE7IC8vIENvbmZpcm0gdGhhdCBhIHN0YXRpYyBmbGFnIHdhcyBub3QgYWRkZWQgb3IgcmVtb3ZlZCBzaW5jZSB0aGUgbGFzdFxuICAgIC8vIHJlbmRlci4gSWYgdGhpcyBmaXJlcywgaXQgc3VnZ2VzdHMgdGhhdCB3ZSBpbmNvcnJlY3RseSByZXNldCB0aGUgc3RhdGljXG4gICAgLy8gZmxhZ3MgaW4gc29tZSBvdGhlciBwYXJ0IG9mIHRoZSBjb2RlYmFzZS4gVGhpcyBoYXMgaGFwcGVuZWQgYmVmb3JlLCBmb3JcbiAgICAvLyBleGFtcGxlLCBpbiB0aGUgU3VzcGVuc2VMaXN0IGltcGxlbWVudGF0aW9uLlxuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgKGN1cnJlbnQuZmxhZ3MgJiBTdGF0aWNNYXNrKSAhPT0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgU3RhdGljTWFzaykgJiYgKCAvLyBEaXNhYmxlIHRoaXMgd2FybmluZyBpbiBsZWdhY3kgbW9kZSwgYmVjYXVzZSBsZWdhY3kgU3VzcGVuc2UgaXMgd2VpcmRcbiAgICAvLyBhbmQgY3JlYXRlcyBmYWxzZSBwb3NpdGl2ZXMuIFRvIG1ha2UgdGhpcyB3b3JrIGluIGxlZ2FjeSBtb2RlLCB3ZSdkXG4gICAgLy8gbmVlZCB0byBtYXJrIGZpYmVycyB0aGF0IGNvbW1pdCBpbiBhbiBpbmNvbXBsZXRlIHN0YXRlLCBzb21laG93LiBGb3JcbiAgICAvLyBub3cgSSdsbCBkaXNhYmxlIHRoZSB3YXJuaW5nIHRoYXQgbW9zdCBvZiB0aGUgYnVncyB0aGF0IHdvdWxkIHRyaWdnZXJcbiAgICAvLyBpdCBhcmUgZWl0aGVyIGV4Y2x1c2l2ZSB0byBjb25jdXJyZW50IG1vZGUgb3IgZXhpc3QgaW4gYm90aC5cbiAgICBkaXNhYmxlTGVnYWN5TW9kZSApKSB7XG4gICAgICBlcnJvcignSW50ZXJuYWwgUmVhY3QgZXJyb3I6IEV4cGVjdGVkIHN0YXRpYyBmbGFnIHdhcyBtaXNzaW5nLiBQbGVhc2UgJyArICdub3RpZnkgdGhlIFJlYWN0IHRlYW0uJyk7XG4gICAgfVxuICB9XG5cbiAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSA9IGZhbHNlOyAvLyBUaGlzIGlzIHJlc2V0IGJ5IGNoZWNrRGlkUmVuZGVySWRIb29rXG4gIC8vIGxvY2FsSWRDb3VudGVyID0gMDtcblxuICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG4gIHRoZW5hYmxlU3RhdGUgPSBudWxsO1xuXG4gIGlmIChkaWRSZW5kZXJUb29GZXdIb29rcykge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVuZGVyZWQgZmV3ZXIgaG9va3MgdGhhbiBleHBlY3RlZC4gVGhpcyBtYXkgYmUgY2F1c2VkIGJ5IGFuIGFjY2lkZW50YWwgJyArICdlYXJseSByZXR1cm4gc3RhdGVtZW50LicpO1xuICB9XG5cbiAge1xuICAgIGlmIChjaGVja0lmVXNlV3JhcHBlZEluVHJ5Q2F0Y2goKSkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKSB8fCAnVW5rbm93bic7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0VXNlV3JhcHBlZEluVHJ5Q2F0Y2guaGFzKGNvbXBvbmVudE5hbWUpICYmIC8vIFRoaXMgd2FybmluZyBhbHNvIGZpcmVzIGlmIHlvdSBzdXNwZW5kIHdpdGggYHVzZWAgaW5zaWRlIGFuXG4gICAgICAvLyBhc3luYyBjb21wb25lbnQuIFNpbmNlIHdlIHdhcm4gZm9yIHRoYXQgYWJvdmUsIHdlJ2xsIHNpbGVuY2UgdGhpc1xuICAgICAgLy8gc2Vjb25kIHdhcm5pbmcgYnkgY2hlY2tpbmcgaGVyZS5cbiAgICAgICFkaWRXYXJuQWJvdXRBc3luY0NsaWVudENvbXBvbmVudC5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VXNlV3JhcHBlZEluVHJ5Q2F0Y2guYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGVycm9yKCdgdXNlYCB3YXMgY2FsbGVkIGZyb20gaW5zaWRlIGEgdHJ5L2NhdGNoIGJsb2NrLiBUaGlzIGlzIG5vdCBhbGxvd2VkICcgKyAnYW5kIGNhbiBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IuIFRvIGhhbmRsZSBlcnJvcnMgdHJpZ2dlcmVkICcgKyAnYnkgYHVzZWAsIHdyYXAgeW91ciBjb21wb25lbnQgaW4gYSBlcnJvciBib3VuZGFyeS4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVwbGF5U3VzcGVuZGVkQ29tcG9uZW50V2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHJlcGxheSBhIGNvbXBvbmVudCB0aGF0IHByZXZpb3VzbHkgc3VzcGVuZGVkLFxuICAvLyBhZnRlciBpdHMgZGF0YSByZXNvbHZlcy5cbiAgLy9cbiAgLy8gSXQncyBhIHNpbXBsaWZpZWQgdmVyc2lvbiBvZiByZW5kZXJXaXRoSG9va3MsIGJ1dCBpdCBkb2Vzbid0IG5lZWQgdG8gZG9cbiAgLy8gbW9zdCBvZiB0aGUgc2V0IHVwIHdvcmsgYmVjYXVzZSB0aGV5IHdlcmVuJ3QgcmVzZXQgd2hlbiB3ZSBzdXNwZW5kZWQ7IHRoZXlcbiAgLy8gb25seSBnZXQgcmVzZXQgd2hlbiB0aGUgY29tcG9uZW50IGVpdGhlciBjb21wbGV0ZXMgKGZpbmlzaFJlbmRlcmluZ0hvb2tzKVxuICAvLyBvciB1bndpbmRzIChyZXNldEhvb2tzT25VbndpbmQpLlxuICB7XG4gICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTsgLy8gVXNlZCBmb3IgaG90IHJlbG9hZGluZzpcblxuICAgIGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzID0gY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50LnR5cGUgIT09IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIH1cblxuICB2YXIgY2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3NBZ2Fpbih3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBwcm9wcywgc2Vjb25kQXJnKTtcbiAgZmluaXNoUmVuZGVyaW5nSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIHJlbmRlcldpdGhIb29rc0FnYWluKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcpIHtcbiAgLy8gVGhpcyBpcyB1c2VkIHRvIHBlcmZvcm0gYW5vdGhlciByZW5kZXIgcGFzcy4gSXQncyB1c2VkIHdoZW4gc2V0U3RhdGUgaXNcbiAgLy8gY2FsbGVkIGR1cmluZyByZW5kZXIsIGFuZCBmb3IgZG91YmxlIGludm9raW5nIGNvbXBvbmVudHMgaW4gU3RyaWN0IE1vZGVcbiAgLy8gZHVyaW5nIGRldmVsb3BtZW50LlxuICAvL1xuICAvLyBUaGUgc3RhdGUgZnJvbSB0aGUgcHJldmlvdXMgcGFzcyBpcyByZXVzZWQgd2hlbmV2ZXIgcG9zc2libGUuIFNvLCBzdGF0ZVxuICAvLyB1cGRhdGVzIHRoYXQgd2VyZSBhbHJlYWR5IHByb2Nlc3NlZCBhcmUgbm90IHByb2Nlc3NlZCBhZ2FpbiwgYW5kIG1lbW9pemVkXG4gIC8vIGZ1bmN0aW9ucyAoYHVzZU1lbW9gKSBhcmUgbm90IGludm9rZWQgYWdhaW4uXG4gIC8vXG4gIC8vIEtlZXAgcmVuZGVyaW5nIGluIGEgbG9vcCBmb3IgYXMgbG9uZyBhcyByZW5kZXIgcGhhc2UgdXBkYXRlcyBjb250aW51ZSB0b1xuICAvLyBiZSBzY2hlZHVsZWQuIFVzZSBhIGNvdW50ZXIgdG8gcHJldmVudCBpbmZpbml0ZSBsb29wcy5cbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IHdvcmtJblByb2dyZXNzO1xuICB2YXIgbnVtYmVyT2ZSZVJlbmRlcnMgPSAwO1xuICB2YXIgY2hpbGRyZW47XG5cbiAgZG8ge1xuICAgIGlmIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MpIHtcbiAgICAgIC8vIEl0J3MgcG9zc2libGUgdGhhdCBhIHVzZSgpIHZhbHVlIGRlcGVuZGVkIG9uIGEgc3RhdGUgdGhhdCB3YXMgdXBkYXRlZCBpblxuICAgICAgLy8gdGhpcyByZXJlbmRlciwgc28gd2UgbmVlZCB0byB3YXRjaCBmb3IgZGlmZmVyZW50IHRoZW5hYmxlcyB0aGlzIHRpbWUuXG4gICAgICB0aGVuYWJsZVN0YXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG4gICAgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gZmFsc2U7XG5cbiAgICBpZiAobnVtYmVyT2ZSZVJlbmRlcnMgPj0gUkVfUkVOREVSX0xJTUlUKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RvbyBtYW55IHJlLXJlbmRlcnMuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIHJlbmRlcnMgdG8gcHJldmVudCAnICsgJ2FuIGluZmluaXRlIGxvb3AuJyk7XG4gICAgfVxuXG4gICAgbnVtYmVyT2ZSZVJlbmRlcnMgKz0gMTtcblxuICAgIHtcbiAgICAgIC8vIEV2ZW4gd2hlbiBob3QgcmVsb2FkaW5nLCBhbGxvdyBkZXBlbmRlbmNpZXMgdG8gc3RhYmlsaXplXG4gICAgICAvLyBhZnRlciBmaXJzdCByZW5kZXIgdG8gcHJldmVudCBpbmZpbml0ZSByZW5kZXIgcGhhc2UgdXBkYXRlcy5cbiAgICAgIGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzID0gZmFsc2U7XG4gICAgfSAvLyBTdGFydCBvdmVyIGZyb20gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdFxuXG5cbiAgICBjdXJyZW50SG9vayA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG5cbiAgICB7XG4gICAgICAvLyBBbHNvIHZhbGlkYXRlIGhvb2sgb3JkZXIgZm9yIGNhc2NhZGluZyB1cGRhdGVzLlxuICAgICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgICB9XG5cbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWIDtcbiAgICBjaGlsZHJlbiA9IENvbXBvbmVudChwcm9wcywgc2Vjb25kQXJnKTtcbiAgfSB3aGlsZSAoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzKTtcblxuICByZXR1cm4gY2hpbGRyZW47XG59XG5cbmZ1bmN0aW9uIHJlbmRlclRyYW5zaXRpb25Bd2FyZUhvc3RDb21wb25lbnRXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGxhbmVzKSB7XG5cbiAgcmV0dXJuIHJlbmRlcldpdGhIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgVHJhbnNpdGlvbkF3YXJlSG9zdENvbXBvbmVudCwgbnVsbCwgbnVsbCwgbGFuZXMpO1xufVxuZnVuY3Rpb24gVHJhbnNpdGlvbkF3YXJlSG9zdENvbXBvbmVudCgpIHtcblxuICB2YXIgZGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG5cbiAgdmFyIF9kaXNwYXRjaGVyJHVzZVN0YXRlID0gZGlzcGF0Y2hlci51c2VTdGF0ZSgpLFxuICAgICAgbWF5YmVUaGVuYWJsZSA9IF9kaXNwYXRjaGVyJHVzZVN0YXRlWzBdO1xuXG4gIHZhciBuZXh0U3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBtYXliZVRoZW5hYmxlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgdGhlbmFibGUgPSBtYXliZVRoZW5hYmxlO1xuICAgIG5leHRTdGF0ZSA9IHVzZVRoZW5hYmxlKHRoZW5hYmxlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3RhdHVzID0gbWF5YmVUaGVuYWJsZTtcbiAgICBuZXh0U3RhdGUgPSBzdGF0dXM7XG4gIH0gLy8gVGhlIFwicmVzZXQgc3RhdGVcIiBpcyBhbiBvYmplY3QuIElmIGl0IGNoYW5nZXMsIHRoYXQgbWVhbnMgc29tZXRoaW5nXG4gIC8vIHJlcXVlc3RlZCB0aGF0IHdlIHJlc2V0IHRoZSBmb3JtLlxuXG5cbiAgdmFyIF9kaXNwYXRjaGVyJHVzZVN0YXRlMiA9IGRpc3BhdGNoZXIudXNlU3RhdGUoKSxcbiAgICAgIG5leHRSZXNldFN0YXRlID0gX2Rpc3BhdGNoZXIkdXNlU3RhdGUyWzBdO1xuXG4gIHZhciBwcmV2UmVzZXRTdGF0ZSA9IGN1cnJlbnRIb29rICE9PSBudWxsID8gY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZSA6IG51bGw7XG5cbiAgaWYgKHByZXZSZXNldFN0YXRlICE9PSBuZXh0UmVzZXRTdGF0ZSkge1xuICAgIC8vIFNjaGVkdWxlIGEgZm9ybSByZXNldFxuICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gRm9ybVJlc2V0O1xuICB9XG5cbiAgcmV0dXJuIG5leHRTdGF0ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrRGlkUmVuZGVySWRIb29rKCkge1xuICAvLyBUaGlzIHNob3VsZCBiZSBjYWxsZWQgaW1tZWRpYXRlbHkgYWZ0ZXIgZXZlcnkgcmVuZGVyV2l0aEhvb2tzIGNhbGwuXG4gIC8vIENvbmNlcHR1YWxseSwgaXQncyBwYXJ0IG9mIHRoZSByZXR1cm4gdmFsdWUgb2YgcmVuZGVyV2l0aEhvb2tzOyBpdCdzIG9ubHkgYVxuICAvLyBzZXBhcmF0ZSBmdW5jdGlvbiB0byBhdm9pZCB1c2luZyBhbiBhcnJheSB0dXBsZS5cbiAgdmFyIGRpZFJlbmRlcklkSG9vayA9IGxvY2FsSWRDb3VudGVyICE9PSAwO1xuICBsb2NhbElkQ291bnRlciA9IDA7XG4gIHJldHVybiBkaWRSZW5kZXJJZEhvb2s7XG59XG5mdW5jdGlvbiBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGxhbmVzKSB7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTsgLy8gVE9ETzogRG9uJ3QgbmVlZCB0byByZXNldCB0aGUgZmxhZ3MgaGVyZSwgYmVjYXVzZSB0aGV5J3JlIHJlc2V0IGluIHRoZVxuICAvLyBjb21wbGV0ZSBwaGFzZSAoYnViYmxlUHJvcGVydGllcykuXG5cbiAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSB+KE1vdW50UGFzc2l2ZURldiB8IE1vdW50TGF5b3V0RGV2IHwgUGFzc2l2ZSQxIHwgVXBkYXRlKTtcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSB+KFBhc3NpdmUkMSB8IFVwZGF0ZSk7XG4gIH1cblxuICBjdXJyZW50LmxhbmVzID0gcmVtb3ZlTGFuZXMoY3VycmVudC5sYW5lcywgbGFuZXMpO1xufVxuZnVuY3Rpb24gcmVzZXRIb29rc0FmdGVyVGhyb3coKSB7XG4gIC8vIFRoaXMgaXMgY2FsbGVkIGltbWVkaWFldGx5IGFmdGVyIGEgdGhyb3cuIEl0IHNob3VsZG4ndCByZXNldCB0aGUgZW50aXJlXG4gIC8vIG1vZHVsZSBzdGF0ZSwgYmVjYXVzZSB0aGUgd29yayBsb29wIG1pZ2h0IGRlY2lkZSB0byByZXBsYXkgdGhlIGNvbXBvbmVudFxuICAvLyBhZ2FpbiB3aXRob3V0IHJld2luZGluZy5cbiAgLy9cbiAgLy8gSXQgc2hvdWxkIG9ubHkgcmVzZXQgdGhpbmdzIGxpa2UgdGhlIGN1cnJlbnQgZGlzcGF0Y2hlciwgdG8gcHJldmVudCBob29rc1xuICAvLyBmcm9tIGJlaW5nIGNhbGxlZCBvdXRzaWRlIG9mIGEgY29tcG9uZW50LlxuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbDsgLy8gV2UgY2FuIGFzc3VtZSB0aGUgcHJldmlvdXMgZGlzcGF0Y2hlciBpcyBhbHdheXMgdGhpcyBvbmUsIHNpbmNlIHdlIHNldCBpdFxuICAvLyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZSByZW5kZXIgcGhhc2UgYW5kIHRoZXJlJ3Mgbm8gcmUtZW50cmFuY2UuXG5cbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcbn1cbmZ1bmN0aW9uIHJlc2V0SG9va3NPblVud2luZCh3b3JrSW5Qcm9ncmVzcykge1xuICBpZiAoZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSkge1xuICAgIC8vIFRoZXJlIHdlcmUgcmVuZGVyIHBoYXNlIHVwZGF0ZXMuIFRoZXNlIGFyZSBvbmx5IHZhbGlkIGZvciB0aGlzIHJlbmRlclxuICAgIC8vIHBoYXNlLCB3aGljaCB3ZSBhcmUgbm93IGFib3J0aW5nLiBSZW1vdmUgdGhlIHVwZGF0ZXMgZnJvbSB0aGUgcXVldWVzIHNvXG4gICAgLy8gdGhleSBkbyBub3QgcGVyc2lzdCB0byB0aGUgbmV4dCByZW5kZXIuIERvIG5vdCByZW1vdmUgdXBkYXRlcyBmcm9tIGhvb2tzXG4gICAgLy8gdGhhdCB3ZXJlbid0IHByb2Nlc3NlZC5cbiAgICAvL1xuICAgIC8vIE9ubHkgcmVzZXQgdGhlIHVwZGF0ZXMgZnJvbSB0aGUgcXVldWUgaWYgaXQgaGFzIGEgY2xvbmUuIElmIGl0IGRvZXNcbiAgICAvLyBub3QgaGF2ZSBhIGNsb25lLCB0aGF0IG1lYW5zIGl0IHdhc24ndCBwcm9jZXNzZWQsIGFuZCB0aGUgdXBkYXRlcyB3ZXJlXG4gICAgLy8gc2NoZWR1bGVkIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSByZW5kZXIgcGhhc2UuXG4gICAgdmFyIGhvb2sgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgd2hpbGUgKGhvb2sgIT09IG51bGwpIHtcbiAgICAgIHZhciBxdWV1ZSA9IGhvb2sucXVldWU7XG5cbiAgICAgIGlmIChxdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICBxdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaG9vayA9IGhvb2submV4dDtcbiAgICB9XG5cbiAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7XG4gIH1cblxuICByZW5kZXJMYW5lcyA9IE5vTGFuZXM7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSBudWxsO1xuICBjdXJyZW50SG9vayA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG5cbiAge1xuICAgIGhvb2tUeXBlc0RldiA9IG51bGw7XG4gICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTtcbiAgICBjdXJyZW50SG9va05hbWVJbkRldiA9IG51bGw7XG4gIH1cblxuICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSBmYWxzZTtcbiAgbG9jYWxJZENvdW50ZXIgPSAwO1xuICB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG4gIHRoZW5hYmxlU3RhdGUgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpIHtcbiAgdmFyIGhvb2sgPSB7XG4gICAgbWVtb2l6ZWRTdGF0ZTogbnVsbCxcbiAgICBiYXNlU3RhdGU6IG51bGwsXG4gICAgYmFzZVF1ZXVlOiBudWxsLFxuICAgIHF1ZXVlOiBudWxsLFxuICAgIG5leHQ6IG51bGxcbiAgfTtcblxuICBpZiAod29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgaG9vayBpbiB0aGUgbGlzdFxuICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZSA9IHdvcmtJblByb2dyZXNzSG9vayA9IGhvb2s7XG4gIH0gZWxzZSB7XG4gICAgLy8gQXBwZW5kIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3RcbiAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9IGhvb2s7XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NIb29rO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBib3RoIGZvciB1cGRhdGVzIGFuZCBmb3IgcmUtcmVuZGVycyB0cmlnZ2VyZWQgYnkgYVxuICAvLyByZW5kZXIgcGhhc2UgdXBkYXRlLiBJdCBhc3N1bWVzIHRoZXJlIGlzIGVpdGhlciBhIGN1cnJlbnQgaG9vayB3ZSBjYW5cbiAgLy8gY2xvbmUsIG9yIGEgd29yay1pbi1wcm9ncmVzcyBob29rIGZyb20gYSBwcmV2aW91cyByZW5kZXIgcGFzcyB0aGF0IHdlIGNhblxuICAvLyB1c2UgYXMgYSBiYXNlLlxuICB2YXIgbmV4dEN1cnJlbnRIb29rO1xuXG4gIGlmIChjdXJyZW50SG9vayA9PT0gbnVsbCkge1xuICAgIHZhciBjdXJyZW50ID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5hbHRlcm5hdGU7XG5cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgbmV4dEN1cnJlbnRIb29rID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0Q3VycmVudEhvb2sgPSBudWxsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBuZXh0Q3VycmVudEhvb2sgPSBjdXJyZW50SG9vay5uZXh0O1xuICB9XG5cbiAgdmFyIG5leHRXb3JrSW5Qcm9ncmVzc0hvb2s7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzSG9vayA9PT0gbnVsbCkge1xuICAgIG5leHRXb3JrSW5Qcm9ncmVzc0hvb2sgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGU7XG4gIH0gZWxzZSB7XG4gICAgbmV4dFdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0O1xuICB9XG5cbiAgaWYgKG5leHRXb3JrSW5Qcm9ncmVzc0hvb2sgIT09IG51bGwpIHtcbiAgICAvLyBUaGVyZSdzIGFscmVhZHkgYSB3b3JrLWluLXByb2dyZXNzLiBSZXVzZSBpdC5cbiAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBuZXh0V29ya0luUHJvZ3Jlc3NIb29rO1xuICAgIG5leHRXb3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dDtcbiAgICBjdXJyZW50SG9vayA9IG5leHRDdXJyZW50SG9vaztcbiAgfSBlbHNlIHtcbiAgICAvLyBDbG9uZSBmcm9tIHRoZSBjdXJyZW50IGhvb2suXG4gICAgaWYgKG5leHRDdXJyZW50SG9vayA9PT0gbnVsbCkge1xuICAgICAgdmFyIGN1cnJlbnRGaWJlciA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuYWx0ZXJuYXRlO1xuXG4gICAgICBpZiAoY3VycmVudEZpYmVyID09PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgdGhlIGluaXRpYWwgcmVuZGVyLiBUaGlzIGJyYW5jaCBpcyByZWFjaGVkIHdoZW4gdGhlIGNvbXBvbmVudFxuICAgICAgICAvLyBzdXNwZW5kcywgcmVzdW1lcywgdGhlbiByZW5kZXJzIGFuIGFkZGl0aW9uYWwgaG9vay5cbiAgICAgICAgLy8gU2hvdWxkIG5ldmVyIGJlIHJlYWNoZWQgYmVjYXVzZSB3ZSBzaG91bGQgc3dpdGNoIHRvIHRoZSBtb3VudCBkaXNwYXRjaGVyIGZpcnN0LlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VwZGF0ZSBob29rIGNhbGxlZCBvbiBpbml0aWFsIHJlbmRlci4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhbiB1cGRhdGUuIFdlIHNob3VsZCBhbHdheXMgaGF2ZSBhIGN1cnJlbnQgaG9vay5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSZW5kZXJlZCBtb3JlIGhvb2tzIHRoYW4gZHVyaW5nIHRoZSBwcmV2aW91cyByZW5kZXIuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3VycmVudEhvb2sgPSBuZXh0Q3VycmVudEhvb2s7XG4gICAgdmFyIG5ld0hvb2sgPSB7XG4gICAgICBtZW1vaXplZFN0YXRlOiBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlLFxuICAgICAgYmFzZVN0YXRlOiBjdXJyZW50SG9vay5iYXNlU3RhdGUsXG4gICAgICBiYXNlUXVldWU6IGN1cnJlbnRIb29rLmJhc2VRdWV1ZSxcbiAgICAgIHF1ZXVlOiBjdXJyZW50SG9vay5xdWV1ZSxcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzSG9vayA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgaG9vayBpbiB0aGUgbGlzdC5cbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZSA9IHdvcmtJblByb2dyZXNzSG9vayA9IG5ld0hvb2s7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFwcGVuZCB0byB0aGUgZW5kIG9mIHRoZSBsaXN0LlxuICAgICAgd29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQgPSBuZXdIb29rO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG59IC8vIE5PVEU6IGRlZmluaW5nIHR3byB2ZXJzaW9ucyBvZiB0aGlzIGZ1bmN0aW9uIHRvIGF2b2lkIHNpemUgaW1wYWN0IHdoZW4gdGhpcyBmZWF0dXJlIGlzIGRpc2FibGVkLlxuLy8gUHJldmlvdXNseSB0aGlzIGZ1bmN0aW9uIHdhcyBpbmxpbmVkLCB0aGUgYWRkaXRpb25hbCBgbWVtb0NhY2hlYCBwcm9wZXJ0eSBtYWtlcyBpdCBub3QgaW5saW5lZC5cblxuXG52YXIgY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZTtcblxue1xuICBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBsYXN0RWZmZWN0OiBudWxsLFxuICAgICAgZXZlbnRzOiBudWxsLFxuICAgICAgc3RvcmVzOiBudWxsLFxuICAgICAgbWVtb0NhY2hlOiBudWxsXG4gICAgfTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXNlVGhlbmFibGUodGhlbmFibGUpIHtcbiAgLy8gVHJhY2sgdGhlIHBvc2l0aW9uIG9mIHRoZSB0aGVuYWJsZSB3aXRoaW4gdGhpcyBmaWJlci5cbiAgdmFyIGluZGV4ID0gdGhlbmFibGVJbmRleENvdW50ZXI7XG4gIHRoZW5hYmxlSW5kZXhDb3VudGVyICs9IDE7XG5cbiAgaWYgKHRoZW5hYmxlU3RhdGUgPT09IG51bGwpIHtcbiAgICB0aGVuYWJsZVN0YXRlID0gY3JlYXRlVGhlbmFibGVTdGF0ZSgpO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IHRyYWNrVXNlZFRoZW5hYmxlKHRoZW5hYmxlU3RhdGUsIHRoZW5hYmxlLCBpbmRleCk7XG5cbiAgaWYgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuYWx0ZXJuYXRlID09PSBudWxsICYmICh3b3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwgPyBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1lbW9pemVkU3RhdGUgPT09IG51bGwgOiB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9PT0gbnVsbCkpIHtcbiAgICAvLyBJbml0aWFsIHJlbmRlciwgYW5kIGVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIHRoZSBjb21wb25lbnQgaXNcbiAgICAvLyBjYWxsZWQsIG9yIHRoZXJlIHdlcmUgbm8gSG9va3MgY2FsbGVkIGFmdGVyIHRoaXMgdXNlKCkgdGhlIHByZXZpb3VzXG4gICAgLy8gdGltZSAocGVyaGFwcyBiZWNhdXNlIGl0IHRocmV3KS4gU3Vic2VxdWVudCBIb29rIGNhbGxzIHNob3VsZCB1c2UgdGhlXG4gICAgLy8gbW91bnQgZGlzcGF0Y2hlci5cbiAgICB7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIHVzZSh1c2FibGUpIHtcbiAgaWYgKHVzYWJsZSAhPT0gbnVsbCAmJiB0eXBlb2YgdXNhYmxlID09PSAnb2JqZWN0Jykge1xuICAgIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgICBpZiAodHlwZW9mIHVzYWJsZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgdGhlbmFibGUuXG4gICAgICB2YXIgdGhlbmFibGUgPSB1c2FibGU7XG4gICAgICByZXR1cm4gdXNlVGhlbmFibGUodGhlbmFibGUpO1xuICAgIH0gZWxzZSBpZiAodXNhYmxlLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpIHtcbiAgICAgIHZhciBjb250ZXh0ID0gdXNhYmxlO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH1cbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gIHRocm93IG5ldyBFcnJvcignQW4gdW5zdXBwb3J0ZWQgdHlwZSB3YXMgcGFzc2VkIHRvIHVzZSgpOiAnICsgU3RyaW5nKHVzYWJsZSkpO1xufVxuXG5mdW5jdGlvbiB1c2VNZW1vQ2FjaGUoc2l6ZSkge1xuICB2YXIgbWVtb0NhY2hlID0gbnVsbDsgLy8gRmFzdC1wYXRoLCBsb2FkIG1lbW8gY2FjaGUgZnJvbSB3aXAgZmliZXIgaWYgYWxyZWFkeSBwcmVwYXJlZFxuXG4gIHZhciB1cGRhdGVRdWV1ZSA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWU7XG5cbiAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgbWVtb0NhY2hlID0gdXBkYXRlUXVldWUubWVtb0NhY2hlO1xuICB9IC8vIE90aGVyd2lzZSBjbG9uZSBmcm9tIHRoZSBjdXJyZW50IGZpYmVyXG5cblxuICBpZiAobWVtb0NhY2hlID09IG51bGwpIHtcbiAgICB2YXIgY3VycmVudCA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciBjdXJyZW50VXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gICAgICBpZiAoY3VycmVudFVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBjdXJyZW50TWVtb0NhY2hlID0gY3VycmVudFVwZGF0ZVF1ZXVlLm1lbW9DYWNoZTtcblxuICAgICAgICBpZiAoY3VycmVudE1lbW9DYWNoZSAhPSBudWxsKSB7XG4gICAgICAgICAgbWVtb0NhY2hlID0ge1xuICAgICAgICAgICAgLy8gV2hlbiBlbmFibGVOb0Nsb25pbmdNZW1vQ2FjaGUgaXMgZW5hYmxlZCwgaW5zdGVhZCBvZiB0cmVhdGluZyB0aGVcbiAgICAgICAgICAgIC8vIGNhY2hlIGFzIGNvcHktb24td3JpdGUsIGxpa2Ugd2UgZG8gd2l0aCBmaWJlcnMsIHdlIHNoYXJlIHRoZSBzYW1lXG4gICAgICAgICAgICAvLyBjYWNoZSBpbnN0YW5jZSBhY3Jvc3MgYWxsIHJlbmRlciBhdHRlbXB0cywgZXZlbiBpZiB0aGUgY29tcG9uZW50XG4gICAgICAgICAgICAvLyBpcyBpbnRlcnJ1cHRlZCBiZWZvcmUgaXQgY29tbWl0cy5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBJZiBhbiB1cGRhdGUgaXMgaW50ZXJydXB0ZWQsIGVpdGhlciBiZWNhdXNlIGl0IHN1c3BlbmRlZCBvclxuICAgICAgICAgICAgLy8gYmVjYXVzZSBvZiBhbm90aGVyIHVwZGF0ZSwgd2UgY2FuIHJldXNlIHRoZSBtZW1vaXplZCBjb21wdXRhdGlvbnNcbiAgICAgICAgICAgIC8vIGZyb20gdGhlIHByZXZpb3VzIGF0dGVtcHQuIFdlIGNhbiBkbyB0aGlzIGJlY2F1c2UgdGhlIFJlYWN0XG4gICAgICAgICAgICAvLyBDb21waWxlciBwZXJmb3JtcyBhdG9taWMgd3JpdGVzIHRvIHRoZSBtZW1vIGNhY2hlLCBpLmUuIGl0IHdpbGxcbiAgICAgICAgICAgIC8vIG5vdCByZWNvcmQgdGhlIGlucHV0cyB0byBhIG1lbW9pemF0aW9uIHdpdGhvdXQgYWxzbyByZWNvcmRpbmcgaXRzXG4gICAgICAgICAgICAvLyBvdXRwdXQuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gVGhpcyBnaXZlcyB1cyBhIGZvcm0gb2YgXCJyZXN1bWluZ1wiIHdpdGhpbiBjb21wb25lbnRzIGFuZCBob29rcy5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGlzIG9ubHkgd29ya3Mgd2hlbiB1cGRhdGluZyBhIGNvbXBvbmVudCB0aGF0IGFscmVhZHkgbW91bnRlZC5cbiAgICAgICAgICAgIC8vIEl0IGhhcyBubyBpbXBhY3QgZHVyaW5nIGluaXRpYWwgcmVuZGVyLCBiZWNhdXNlIHRoZSBtZW1vIGNhY2hlIGlzXG4gICAgICAgICAgICAvLyBzdG9yZWQgb24gdGhlIGZpYmVyLCBhbmQgc2luY2Ugd2UgaGF2ZSBub3QgaW1wbGVtZW50ZWQgcmVzdW1pbmdcbiAgICAgICAgICAgIC8vIGZvciBmaWJlcnMsIGl0J3MgYWx3YXlzIGEgZnJlc2ggbWVtbyBjYWNoZSwgYW55d2F5LlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIEhvd2V2ZXIsIHRoaXMgYWxvbmUgaXMgcHJldHR5IHVzZWZ1bCDigJQgaXQgaGFwcGVucyB3aGVuZXZlciB5b3VcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0aGUgVUkgd2l0aCBmcmVzaCBkYXRhIGFmdGVyIGEgbXV0YXRpb24vYWN0aW9uLCB3aGljaCBpc1xuICAgICAgICAgICAgLy8gZXh0cmVtZWx5IGNvbW1vbiBpbiBhIFN1c3BlbnNlLWRyaXZlbiAoZS5nLiBSU0Mgb3IgUmVsYXkpIGFwcC5cbiAgICAgICAgICAgIGRhdGE6IC8vIENsb25lIHRoZSBtZW1vIGNhY2hlIGJlZm9yZSBlYWNoIHJlbmRlciAoY29weS1vbi13cml0ZSlcbiAgICAgICAgICAgIGN1cnJlbnRNZW1vQ2FjaGUuZGF0YS5tYXAoZnVuY3Rpb24gKGFycmF5KSB7XG4gICAgICAgICAgICAgIHJldHVybiBhcnJheS5zbGljZSgpO1xuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBpbmRleDogMFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gRmluYWxseSBmYWxsIGJhY2sgdG8gYWxsb2NhdGluZyBhIGZyZXNoIGluc3RhbmNlIG9mIHRoZSBjYWNoZVxuXG5cbiAgaWYgKG1lbW9DYWNoZSA9PSBudWxsKSB7XG4gICAgbWVtb0NhY2hlID0ge1xuICAgICAgZGF0YTogW10sXG4gICAgICBpbmRleDogMFxuICAgIH07XG4gIH1cblxuICBpZiAodXBkYXRlUXVldWUgPT09IG51bGwpIHtcbiAgICB1cGRhdGVRdWV1ZSA9IGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKTtcbiAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlID0gdXBkYXRlUXVldWU7XG4gIH1cblxuICB1cGRhdGVRdWV1ZS5tZW1vQ2FjaGUgPSBtZW1vQ2FjaGU7XG4gIHZhciBkYXRhID0gbWVtb0NhY2hlLmRhdGFbbWVtb0NhY2hlLmluZGV4XTtcblxuICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZGF0YSA9IG1lbW9DYWNoZS5kYXRhW21lbW9DYWNoZS5pbmRleF0gPSBuZXcgQXJyYXkoc2l6ZSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgZGF0YVtpXSA9IFJFQUNUX01FTU9fQ0FDSEVfU0VOVElORUw7XG4gICAgfVxuICB9IGVsc2UgaWYgKGRhdGEubGVuZ3RoICE9PSBzaXplKSB7XG4gICAgLy8gVE9ETzogY29uc2lkZXIgd2FybmluZyBvciB0aHJvd2luZyBoZXJlXG4gICAge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIGEgY29uc3RhbnQgc2l6ZSBhcmd1bWVudCBmb3IgZWFjaCBpbnZvY2F0aW9uIG9mIHVzZU1lbW9DYWNoZS4gJyArICdUaGUgcHJldmlvdXMgY2FjaGUgd2FzIGFsbG9jYXRlZCB3aXRoIHNpemUgJXMgYnV0IHNpemUgJXMgd2FzIHJlcXVlc3RlZC4nLCBkYXRhLmxlbmd0aCwgc2l6ZSk7XG4gICAgfVxuICB9XG5cbiAgbWVtb0NhY2hlLmluZGV4Kys7XG4gIHJldHVybiBkYXRhO1xufVxuXG5mdW5jdGlvbiBiYXNpY1N0YXRlUmVkdWNlcihzdGF0ZSwgYWN0aW9uKSB7XG4gIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV06IEZsb3cgZG9lc24ndCBsaWtlIG1peGVkIHR5cGVzXG4gIHJldHVybiB0eXBlb2YgYWN0aW9uID09PSAnZnVuY3Rpb24nID8gYWN0aW9uKHN0YXRlKSA6IGFjdGlvbjtcbn1cblxuZnVuY3Rpb24gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgaW5pdGlhbFN0YXRlO1xuXG4gIGlmIChpbml0ICE9PSB1bmRlZmluZWQpIHtcbiAgICBpbml0aWFsU3RhdGUgPSBpbml0KGluaXRpYWxBcmcpO1xuXG4gICAgaWYgKHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWKSB7XG4gICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTtcbiAgICAgIGluaXQoaW5pdGlhbEFyZyk7XG4gICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGluaXRpYWxTdGF0ZSA9IGluaXRpYWxBcmc7XG4gIH1cblxuICBob29rLm1lbW9pemVkU3RhdGUgPSBob29rLmJhc2VTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgdmFyIHF1ZXVlID0ge1xuICAgIHBlbmRpbmc6IG51bGwsXG4gICAgbGFuZXM6IE5vTGFuZXMsXG4gICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogcmVkdWNlcixcbiAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFN0YXRlXG4gIH07XG4gIGhvb2sucXVldWUgPSBxdWV1ZTtcbiAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2ggPSBkaXNwYXRjaFJlZHVjZXJBY3Rpb24uYmluZChudWxsLCBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLCBxdWV1ZSk7XG4gIHJldHVybiBbaG9vay5tZW1vaXplZFN0YXRlLCBkaXNwYXRjaF07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICByZXR1cm4gdXBkYXRlUmVkdWNlckltcGwoaG9vaywgY3VycmVudEhvb2ssIHJlZHVjZXIpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVSZWR1Y2VySW1wbChob29rLCBjdXJyZW50LCByZWR1Y2VyKSB7XG4gIHZhciBxdWV1ZSA9IGhvb2sucXVldWU7XG5cbiAgaWYgKHF1ZXVlID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgaGF2ZSBhIHF1ZXVlLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyID0gcmVkdWNlcjsgLy8gVGhlIGxhc3QgcmViYXNlIHVwZGF0ZSB0aGF0IGlzIE5PVCBwYXJ0IG9mIHRoZSBiYXNlIHN0YXRlLlxuXG4gIHZhciBiYXNlUXVldWUgPSBob29rLmJhc2VRdWV1ZTsgLy8gVGhlIGxhc3QgcGVuZGluZyB1cGRhdGUgdGhhdCBoYXNuJ3QgYmVlbiBwcm9jZXNzZWQgeWV0LlxuXG4gIHZhciBwZW5kaW5nUXVldWUgPSBxdWV1ZS5wZW5kaW5nO1xuXG4gIGlmIChwZW5kaW5nUXVldWUgIT09IG51bGwpIHtcbiAgICAvLyBXZSBoYXZlIG5ldyB1cGRhdGVzIHRoYXQgaGF2ZW4ndCBiZWVuIHByb2Nlc3NlZCB5ZXQuXG4gICAgLy8gV2UnbGwgYWRkIHRoZW0gdG8gdGhlIGJhc2UgcXVldWUuXG4gICAgaWYgKGJhc2VRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgLy8gTWVyZ2UgdGhlIHBlbmRpbmcgcXVldWUgYW5kIHRoZSBiYXNlIHF1ZXVlLlxuICAgICAgdmFyIGJhc2VGaXJzdCA9IGJhc2VRdWV1ZS5uZXh0O1xuICAgICAgdmFyIHBlbmRpbmdGaXJzdCA9IHBlbmRpbmdRdWV1ZS5uZXh0O1xuICAgICAgYmFzZVF1ZXVlLm5leHQgPSBwZW5kaW5nRmlyc3Q7XG4gICAgICBwZW5kaW5nUXVldWUubmV4dCA9IGJhc2VGaXJzdDtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAoY3VycmVudC5iYXNlUXVldWUgIT09IGJhc2VRdWV1ZSkge1xuICAgICAgICAvLyBJbnRlcm5hbCBpbnZhcmlhbnQgdGhhdCBzaG91bGQgbmV2ZXIgaGFwcGVuLCBidXQgZmVhc2libHkgY291bGQgaW5cbiAgICAgICAgLy8gdGhlIGZ1dHVyZSBpZiB3ZSBpbXBsZW1lbnQgcmVzdW1pbmcsIG9yIHNvbWUgZm9ybSBvZiB0aGF0LlxuICAgICAgICBlcnJvcignSW50ZXJuYWwgZXJyb3I6IEV4cGVjdGVkIHdvcmstaW4tcHJvZ3Jlc3MgcXVldWUgdG8gYmUgYSBjbG9uZS4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGN1cnJlbnQuYmFzZVF1ZXVlID0gYmFzZVF1ZXVlID0gcGVuZGluZ1F1ZXVlO1xuICAgIHF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuICB9XG5cbiAgdmFyIGJhc2VTdGF0ZSA9IGhvb2suYmFzZVN0YXRlO1xuXG4gIGlmIChiYXNlUXVldWUgPT09IG51bGwpIHtcbiAgICAvLyBJZiB0aGVyZSBhcmUgbm8gcGVuZGluZyB1cGRhdGVzLCB0aGVuIHRoZSBtZW1vaXplZCBzdGF0ZSBzaG91bGQgYmUgdGhlXG4gICAgLy8gc2FtZSBhcyB0aGUgYmFzZSBzdGF0ZS4gQ3VycmVudGx5IHRoZXNlIG9ubHkgZGl2ZXJnZSBpbiB0aGUgY2FzZSBvZlxuICAgIC8vIHVzZU9wdGltaXN0aWMsIGJlY2F1c2UgdXNlT3B0aW1pc3RpYyBhY2NlcHRzIGEgbmV3IGJhc2VTdGF0ZSBvblxuICAgIC8vIGV2ZXJ5IHJlbmRlci5cbiAgICBob29rLm1lbW9pemVkU3RhdGUgPSBiYXNlU3RhdGU7IC8vIFdlIGRvbid0IG5lZWQgdG8gY2FsbCBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSBiZWNhdXNlXG4gICAgLy8gYmFzZVN0YXRlIGlzIGRlcml2ZWQgZnJvbSBvdGhlciByZWFjdGl2ZSB2YWx1ZXMuXG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgaGF2ZSBhIHF1ZXVlIHRvIHByb2Nlc3MuXG4gICAgdmFyIGZpcnN0ID0gYmFzZVF1ZXVlLm5leHQ7XG4gICAgdmFyIG5ld1N0YXRlID0gYmFzZVN0YXRlO1xuICAgIHZhciBuZXdCYXNlU3RhdGUgPSBudWxsO1xuICAgIHZhciBuZXdCYXNlUXVldWVGaXJzdCA9IG51bGw7XG4gICAgdmFyIG5ld0Jhc2VRdWV1ZUxhc3QgPSBudWxsO1xuICAgIHZhciB1cGRhdGUgPSBmaXJzdDtcbiAgICB2YXIgZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiA9IGZhbHNlO1xuXG4gICAgZG8ge1xuICAgICAgLy8gQW4gZXh0cmEgT2Zmc2NyZWVuTGFuZSBiaXQgaXMgYWRkZWQgdG8gdXBkYXRlcyB0aGF0IHdlcmUgbWFkZSB0b1xuICAgICAgLy8gYSBoaWRkZW4gdHJlZSwgc28gdGhhdCB3ZSBjYW4gZGlzdGluZ3Vpc2ggdGhlbSBmcm9tIHVwZGF0ZXMgdGhhdCB3ZXJlXG4gICAgICAvLyBhbHJlYWR5IHRoZXJlIHdoZW4gdGhlIHRyZWUgd2FzIGhpZGRlbi5cbiAgICAgIHZhciB1cGRhdGVMYW5lID0gcmVtb3ZlTGFuZXModXBkYXRlLmxhbmUsIE9mZnNjcmVlbkxhbmUpO1xuICAgICAgdmFyIGlzSGlkZGVuVXBkYXRlID0gdXBkYXRlTGFuZSAhPT0gdXBkYXRlLmxhbmU7IC8vIENoZWNrIGlmIHRoaXMgdXBkYXRlIHdhcyBtYWRlIHdoaWxlIHRoZSB0cmVlIHdhcyBoaWRkZW4uIElmIHNvLCB0aGVuXG4gICAgICAvLyBpdCdzIG5vdCBhIFwiYmFzZVwiIHVwZGF0ZSBhbmQgd2Ugc2hvdWxkIGRpc3JlZ2FyZCB0aGUgZXh0cmEgYmFzZSBsYW5lc1xuICAgICAgLy8gdGhhdCB3ZXJlIGFkZGVkIHRvIHJlbmRlckxhbmVzIHdoZW4gd2UgZW50ZXJlZCB0aGUgT2Zmc2NyZWVuIHRyZWUuXG5cbiAgICAgIHZhciBzaG91bGRTa2lwVXBkYXRlID0gaXNIaWRkZW5VcGRhdGUgPyAhaXNTdWJzZXRPZkxhbmVzKGdldFdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKCksIHVwZGF0ZUxhbmUpIDogIWlzU3Vic2V0T2ZMYW5lcyhyZW5kZXJMYW5lcywgdXBkYXRlTGFuZSk7XG5cbiAgICAgIGlmIChzaG91bGRTa2lwVXBkYXRlKSB7XG4gICAgICAgIC8vIFByaW9yaXR5IGlzIGluc3VmZmljaWVudC4gU2tpcCB0aGlzIHVwZGF0ZS4gSWYgdGhpcyBpcyB0aGUgZmlyc3RcbiAgICAgICAgLy8gc2tpcHBlZCB1cGRhdGUsIHRoZSBwcmV2aW91cyB1cGRhdGUvc3RhdGUgaXMgdGhlIG5ldyBiYXNlXG4gICAgICAgIC8vIHVwZGF0ZS9zdGF0ZS5cbiAgICAgICAgdmFyIGNsb25lID0ge1xuICAgICAgICAgIGxhbmU6IHVwZGF0ZUxhbmUsXG4gICAgICAgICAgcmV2ZXJ0TGFuZTogdXBkYXRlLnJldmVydExhbmUsXG4gICAgICAgICAgYWN0aW9uOiB1cGRhdGUuYWN0aW9uLFxuICAgICAgICAgIGhhc0VhZ2VyU3RhdGU6IHVwZGF0ZS5oYXNFYWdlclN0YXRlLFxuICAgICAgICAgIGVhZ2VyU3RhdGU6IHVwZGF0ZS5lYWdlclN0YXRlLFxuICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobmV3QmFzZVF1ZXVlTGFzdCA9PT0gbnVsbCkge1xuICAgICAgICAgIG5ld0Jhc2VRdWV1ZUZpcnN0ID0gbmV3QmFzZVF1ZXVlTGFzdCA9IGNsb25lO1xuICAgICAgICAgIG5ld0Jhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0Jhc2VRdWV1ZUxhc3QgPSBuZXdCYXNlUXVldWVMYXN0Lm5leHQgPSBjbG9uZTtcbiAgICAgICAgfSAvLyBVcGRhdGUgdGhlIHJlbWFpbmluZyBwcmlvcml0eSBpbiB0aGUgcXVldWUuXG4gICAgICAgIC8vIFRPRE86IERvbid0IG5lZWQgdG8gYWNjdW11bGF0ZSB0aGlzLiBJbnN0ZWFkLCB3ZSBjYW4gcmVtb3ZlXG4gICAgICAgIC8vIHJlbmRlckxhbmVzIGZyb20gdGhlIG9yaWdpbmFsIGxhbmVzLlxuXG5cbiAgICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcyA9IG1lcmdlTGFuZXMoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5sYW5lcywgdXBkYXRlTGFuZSk7XG4gICAgICAgIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXModXBkYXRlTGFuZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhbiBvcHRpbWlzdGljIHVwZGF0ZS5cbiAgICAgICAgdmFyIHJldmVydExhbmUgPSB1cGRhdGUucmV2ZXJ0TGFuZTtcblxuICAgICAgICBpZiAocmV2ZXJ0TGFuZSA9PT0gTm9MYW5lKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBub3QgYW4gb3B0aW1pc3RpYyB1cGRhdGUsIGFuZCB3ZSdyZSBnb2luZyB0byBhcHBseSBpdCBub3cuXG4gICAgICAgICAgLy8gQnV0LCBpZiB0aGVyZSB3ZXJlIGVhcmxpZXIgdXBkYXRlcyB0aGF0IHdlcmUgc2tpcHBlZCwgd2UgbmVlZCB0b1xuICAgICAgICAgIC8vIGxlYXZlIHRoaXMgdXBkYXRlIGluIHRoZSBxdWV1ZSBzbyBpdCBjYW4gYmUgcmViYXNlZCBsYXRlci5cbiAgICAgICAgICBpZiAobmV3QmFzZVF1ZXVlTGFzdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIF9jbG9uZSA9IHtcbiAgICAgICAgICAgICAgLy8gVGhpcyB1cGRhdGUgaXMgZ29pbmcgdG8gYmUgY29tbWl0dGVkIHNvIHdlIG5ldmVyIHdhbnQgdW5jb21taXRcbiAgICAgICAgICAgICAgLy8gaXQuIFVzaW5nIE5vTGFuZSB3b3JrcyBiZWNhdXNlIDAgaXMgYSBzdWJzZXQgb2YgYWxsIGJpdG1hc2tzLCBzb1xuICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgbmV2ZXIgYmUgc2tpcHBlZCBieSB0aGUgY2hlY2sgYWJvdmUuXG4gICAgICAgICAgICAgIGxhbmU6IE5vTGFuZSxcbiAgICAgICAgICAgICAgcmV2ZXJ0TGFuZTogTm9MYW5lLFxuICAgICAgICAgICAgICBhY3Rpb246IHVwZGF0ZS5hY3Rpb24sXG4gICAgICAgICAgICAgIGhhc0VhZ2VyU3RhdGU6IHVwZGF0ZS5oYXNFYWdlclN0YXRlLFxuICAgICAgICAgICAgICBlYWdlclN0YXRlOiB1cGRhdGUuZWFnZXJTdGF0ZSxcbiAgICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIG5ld0Jhc2VRdWV1ZUxhc3QgPSBuZXdCYXNlUXVldWVMYXN0Lm5leHQgPSBfY2xvbmU7XG4gICAgICAgICAgfSAvLyBDaGVjayBpZiB0aGlzIHVwZGF0ZSBpcyBwYXJ0IG9mIGEgcGVuZGluZyBhc3luYyBhY3Rpb24uIElmIHNvLFxuICAgICAgICAgIC8vIHdlJ2xsIG5lZWQgdG8gc3VzcGVuZCB1bnRpbCB0aGUgYWN0aW9uIGhhcyBmaW5pc2hlZCwgc28gdGhhdCBpdCdzXG4gICAgICAgICAgLy8gYmF0Y2hlZCB0b2dldGhlciB3aXRoIGZ1dHVyZSB1cGRhdGVzIGluIHRoZSBzYW1lIGFjdGlvbi5cblxuXG4gICAgICAgICAgaWYgKHVwZGF0ZUxhbmUgPT09IHBlZWtFbnRhbmdsZWRBY3Rpb25MYW5lKCkpIHtcbiAgICAgICAgICAgIGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGFuIG9wdGltaXN0aWMgdXBkYXRlLiBJZiB0aGUgXCJyZXZlcnRcIiBwcmlvcml0eSBpc1xuICAgICAgICAgIC8vIHN1ZmZpY2llbnQsIGRvbid0IGFwcGx5IHRoZSB1cGRhdGUuIE90aGVyd2lzZSwgYXBwbHkgdGhlIHVwZGF0ZSxcbiAgICAgICAgICAvLyBidXQgbGVhdmUgaXQgaW4gdGhlIHF1ZXVlIHNvIGl0IGNhbiBiZSBlaXRoZXIgcmV2ZXJ0ZWQgb3JcbiAgICAgICAgICAvLyByZWJhc2VkIGluIGEgc3Vic2VxdWVudCByZW5kZXIuXG4gICAgICAgICAgaWYgKGlzU3Vic2V0T2ZMYW5lcyhyZW5kZXJMYW5lcywgcmV2ZXJ0TGFuZSkpIHtcbiAgICAgICAgICAgIC8vIFRoZSB0cmFuc2l0aW9uIHRoYXQgdGhpcyBvcHRpbWlzdGljIHVwZGF0ZSBpcyBhc3NvY2lhdGVkIHdpdGhcbiAgICAgICAgICAgIC8vIGhhcyBmaW5pc2hlZC4gUHJldGVuZCB0aGUgdXBkYXRlIGRvZXNuJ3QgZXhpc3QgYnkgc2tpcHBpbmdcbiAgICAgICAgICAgIC8vIG92ZXIgaXQuXG4gICAgICAgICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDsgLy8gQ2hlY2sgaWYgdGhpcyB1cGRhdGUgaXMgcGFydCBvZiBhIHBlbmRpbmcgYXN5bmMgYWN0aW9uLiBJZiBzbyxcbiAgICAgICAgICAgIC8vIHdlJ2xsIG5lZWQgdG8gc3VzcGVuZCB1bnRpbCB0aGUgYWN0aW9uIGhhcyBmaW5pc2hlZCwgc28gdGhhdCBpdCdzXG4gICAgICAgICAgICAvLyBiYXRjaGVkIHRvZ2V0aGVyIHdpdGggZnV0dXJlIHVwZGF0ZXMgaW4gdGhlIHNhbWUgYWN0aW9uLlxuXG4gICAgICAgICAgICBpZiAocmV2ZXJ0TGFuZSA9PT0gcGVla0VudGFuZ2xlZEFjdGlvbkxhbmUoKSkge1xuICAgICAgICAgICAgICBkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBfY2xvbmUyID0ge1xuICAgICAgICAgICAgICAvLyBPbmNlIHdlIGNvbW1pdCBhbiBvcHRpbWlzdGljIHVwZGF0ZSwgd2Ugc2hvdWxkbid0IHVuY29tbWl0IGl0XG4gICAgICAgICAgICAgIC8vIHVudGlsIHRoZSB0cmFuc2l0aW9uIGl0IGlzIGFzc29jaWF0ZWQgd2l0aCBoYXMgZmluaXNoZWRcbiAgICAgICAgICAgICAgLy8gKHJlcHJlc2VudGVkIGJ5IHJldmVydExhbmUpLiBVc2luZyBOb0xhbmUgaGVyZSB3b3JrcyBiZWNhdXNlIDBcbiAgICAgICAgICAgICAgLy8gaXMgYSBzdWJzZXQgb2YgYWxsIGJpdG1hc2tzLCBzbyB0aGlzIHdpbGwgbmV2ZXIgYmUgc2tpcHBlZCBieVxuICAgICAgICAgICAgICAvLyB0aGUgY2hlY2sgYWJvdmUuXG4gICAgICAgICAgICAgIGxhbmU6IE5vTGFuZSxcbiAgICAgICAgICAgICAgLy8gUmV1c2UgdGhlIHNhbWUgcmV2ZXJ0TGFuZSBzbyB3ZSBrbm93IHdoZW4gdGhlIHRyYW5zaXRpb25cbiAgICAgICAgICAgICAgLy8gaGFzIGZpbmlzaGVkLlxuICAgICAgICAgICAgICByZXZlcnRMYW5lOiB1cGRhdGUucmV2ZXJ0TGFuZSxcbiAgICAgICAgICAgICAgYWN0aW9uOiB1cGRhdGUuYWN0aW9uLFxuICAgICAgICAgICAgICBoYXNFYWdlclN0YXRlOiB1cGRhdGUuaGFzRWFnZXJTdGF0ZSxcbiAgICAgICAgICAgICAgZWFnZXJTdGF0ZTogdXBkYXRlLmVhZ2VyU3RhdGUsXG4gICAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGlmIChuZXdCYXNlUXVldWVMYXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIG5ld0Jhc2VRdWV1ZUZpcnN0ID0gbmV3QmFzZVF1ZXVlTGFzdCA9IF9jbG9uZTI7XG4gICAgICAgICAgICAgIG5ld0Jhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbmV3QmFzZVF1ZXVlTGFzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IF9jbG9uZTI7XG4gICAgICAgICAgICB9IC8vIFVwZGF0ZSB0aGUgcmVtYWluaW5nIHByaW9yaXR5IGluIHRoZSBxdWV1ZS5cbiAgICAgICAgICAgIC8vIFRPRE86IERvbid0IG5lZWQgdG8gYWNjdW11bGF0ZSB0aGlzLiBJbnN0ZWFkLCB3ZSBjYW4gcmVtb3ZlXG4gICAgICAgICAgICAvLyByZW5kZXJMYW5lcyBmcm9tIHRoZSBvcmlnaW5hbCBsYW5lcy5cblxuXG4gICAgICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzID0gbWVyZ2VMYW5lcyhjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzLCByZXZlcnRMYW5lKTtcbiAgICAgICAgICAgIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXMocmV2ZXJ0TGFuZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFByb2Nlc3MgdGhpcyB1cGRhdGUuXG5cblxuICAgICAgICB2YXIgYWN0aW9uID0gdXBkYXRlLmFjdGlvbjtcblxuICAgICAgICBpZiAoc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYpIHtcbiAgICAgICAgICByZWR1Y2VyKG5ld1N0YXRlLCBhY3Rpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVwZGF0ZS5oYXNFYWdlclN0YXRlKSB7XG4gICAgICAgICAgLy8gSWYgdGhpcyB1cGRhdGUgaXMgYSBzdGF0ZSB1cGRhdGUgKG5vdCBhIHJlZHVjZXIpIGFuZCB3YXMgcHJvY2Vzc2VkIGVhZ2VybHksXG4gICAgICAgICAgLy8gd2UgY2FuIHVzZSB0aGUgZWFnZXJseSBjb21wdXRlZCBzdGF0ZVxuICAgICAgICAgIG5ld1N0YXRlID0gdXBkYXRlLmVhZ2VyU3RhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3U3RhdGUgPSByZWR1Y2VyKG5ld1N0YXRlLCBhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0O1xuICAgIH0gd2hpbGUgKHVwZGF0ZSAhPT0gbnVsbCAmJiB1cGRhdGUgIT09IGZpcnN0KTtcblxuICAgIGlmIChuZXdCYXNlUXVldWVMYXN0ID09PSBudWxsKSB7XG4gICAgICBuZXdCYXNlU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID0gbmV3QmFzZVF1ZXVlRmlyc3Q7XG4gICAgfSAvLyBNYXJrIHRoYXQgdGhlIGZpYmVyIHBlcmZvcm1lZCB3b3JrLCBidXQgb25seSBpZiB0aGUgbmV3IHN0YXRlIGlzXG4gICAgLy8gZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgc3RhdGUuXG5cblxuICAgIGlmICghb2JqZWN0SXMobmV3U3RhdGUsIGhvb2subWVtb2l6ZWRTdGF0ZSkpIHtcbiAgICAgIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCk7IC8vIENoZWNrIGlmIHRoaXMgdXBkYXRlIGlzIHBhcnQgb2YgYSBwZW5kaW5nIGFzeW5jIGFjdGlvbi4gSWYgc28sIHdlJ2xsXG4gICAgICAvLyBuZWVkIHRvIHN1c3BlbmQgdW50aWwgdGhlIGFjdGlvbiBoYXMgZmluaXNoZWQsIHNvIHRoYXQgaXQncyBiYXRjaGVkXG4gICAgICAvLyB0b2dldGhlciB3aXRoIGZ1dHVyZSB1cGRhdGVzIGluIHRoZSBzYW1lIGFjdGlvbi5cbiAgICAgIC8vIFRPRE86IE9uY2Ugd2Ugc3VwcG9ydCBob29rcyBpbnNpZGUgdXNlTWVtbyAob3IgYW4gZXF1aXZhbGVudFxuICAgICAgLy8gbWVtb2l6YXRpb24gYm91bmRhcnkgbGlrZSBGb3JnZXQpLCBob2lzdCB0aGlzIGxvZ2ljIHNvIHRoYXQgaXQgb25seVxuICAgICAgLy8gc3VzcGVuZHMgaWYgdGhlIG1lbW8gYm91bmRhcnkgcHJvZHVjZXMgYSBuZXcgdmFsdWUuXG5cbiAgICAgIGlmIChkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKSB7XG4gICAgICAgIHZhciBlbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSA9IHBlZWtFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSgpO1xuXG4gICAgICAgIGlmIChlbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFRPRE86IEluc3RlYWQgb2YgdGhlIHRocm93aW5nIHRoZSB0aGVuYWJsZSBkaXJlY3RseSwgdGhyb3cgYVxuICAgICAgICAgIC8vIHNwZWNpYWwgb2JqZWN0IGxpa2UgYHVzZWAgZG9lcyBzbyB3ZSBjYW4gZGV0ZWN0IGlmIGl0J3MgY2FwdHVyZWRcbiAgICAgICAgICAvLyBieSB1c2Vyc3BhY2UuXG4gICAgICAgICAgdGhyb3cgZW50YW5nbGVkQWN0aW9uVGhlbmFibGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICBob29rLmJhc2VTdGF0ZSA9IG5ld0Jhc2VTdGF0ZTtcbiAgICBob29rLmJhc2VRdWV1ZSA9IG5ld0Jhc2VRdWV1ZUxhc3Q7XG4gICAgcXVldWUubGFzdFJlbmRlcmVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfVxuXG4gIGlmIChiYXNlUXVldWUgPT09IG51bGwpIHtcbiAgICAvLyBgcXVldWUubGFuZXNgIGlzIHVzZWQgZm9yIGVudGFuZ2xpbmcgdHJhbnNpdGlvbnMuIFdlIGNhbiBzZXQgaXQgYmFjayB0b1xuICAgIC8vIHplcm8gb25jZSB0aGUgcXVldWUgaXMgZW1wdHkuXG4gICAgcXVldWUubGFuZXMgPSBOb0xhbmVzO1xuICB9XG5cbiAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2g7XG4gIHJldHVybiBbaG9vay5tZW1vaXplZFN0YXRlLCBkaXNwYXRjaF07XG59XG5cbmZ1bmN0aW9uIHJlcmVuZGVyUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBxdWV1ZSA9IGhvb2sucXVldWU7XG5cbiAgaWYgKHF1ZXVlID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgaGF2ZSBhIHF1ZXVlLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICBxdWV1ZS5sYXN0UmVuZGVyZWRSZWR1Y2VyID0gcmVkdWNlcjsgLy8gVGhpcyBpcyBhIHJlLXJlbmRlci4gQXBwbHkgdGhlIG5ldyByZW5kZXIgcGhhc2UgdXBkYXRlcyB0byB0aGUgcHJldmlvdXNcbiAgLy8gd29yay1pbi1wcm9ncmVzcyBob29rLlxuXG4gIHZhciBkaXNwYXRjaCA9IHF1ZXVlLmRpc3BhdGNoO1xuICB2YXIgbGFzdFJlbmRlclBoYXNlVXBkYXRlID0gcXVldWUucGVuZGluZztcbiAgdmFyIG5ld1N0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChsYXN0UmVuZGVyUGhhc2VVcGRhdGUgIT09IG51bGwpIHtcbiAgICAvLyBUaGUgcXVldWUgZG9lc24ndCBwZXJzaXN0IHBhc3QgdGhpcyByZW5kZXIgcGFzcy5cbiAgICBxdWV1ZS5wZW5kaW5nID0gbnVsbDtcbiAgICB2YXIgZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSA9IGxhc3RSZW5kZXJQaGFzZVVwZGF0ZS5uZXh0O1xuICAgIHZhciB1cGRhdGUgPSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlO1xuXG4gICAgZG8ge1xuICAgICAgLy8gUHJvY2VzcyB0aGlzIHJlbmRlciBwaGFzZSB1cGRhdGUuIFdlIGRvbid0IGhhdmUgdG8gY2hlY2sgdGhlXG4gICAgICAvLyBwcmlvcml0eSBiZWNhdXNlIGl0IHdpbGwgYWx3YXlzIGJlIHRoZSBzYW1lIGFzIHRoZSBjdXJyZW50XG4gICAgICAvLyByZW5kZXIncy5cbiAgICAgIHZhciBhY3Rpb24gPSB1cGRhdGUuYWN0aW9uO1xuICAgICAgbmV3U3RhdGUgPSByZWR1Y2VyKG5ld1N0YXRlLCBhY3Rpb24pO1xuICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgfSB3aGlsZSAodXBkYXRlICE9PSBmaXJzdFJlbmRlclBoYXNlVXBkYXRlKTsgLy8gTWFyayB0aGF0IHRoZSBmaWJlciBwZXJmb3JtZWQgd29yaywgYnV0IG9ubHkgaWYgdGhlIG5ldyBzdGF0ZSBpc1xuICAgIC8vIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IHN0YXRlLlxuXG5cbiAgICBpZiAoIW9iamVjdElzKG5ld1N0YXRlLCBob29rLm1lbW9pemVkU3RhdGUpKSB7XG4gICAgICBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO1xuICAgIH1cblxuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlOyAvLyBEb24ndCBwZXJzaXN0IHRoZSBzdGF0ZSBhY2N1bXVsYXRlZCBmcm9tIHRoZSByZW5kZXIgcGhhc2UgdXBkYXRlcyB0b1xuICAgIC8vIHRoZSBiYXNlIHN0YXRlIHVubGVzcyB0aGUgcXVldWUgaXMgZW1wdHkuXG4gICAgLy8gVE9ETzogTm90IHN1cmUgaWYgdGhpcyBpcyB0aGUgZGVzaXJlZCBzZW1hbnRpY3MsIGJ1dCBpdCdzIHdoYXQgd2VcbiAgICAvLyBkbyBmb3IgZ0RTRlAuIEkgY2FuJ3QgcmVtZW1iZXIgd2h5LlxuXG4gICAgaWYgKGhvb2suYmFzZVF1ZXVlID09PSBudWxsKSB7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIH1cblxuICAgIHF1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlID0gbmV3U3RhdGU7XG4gIH1cblxuICByZXR1cm4gW25ld1N0YXRlLCBkaXNwYXRjaF07XG59XG5cbmZ1bmN0aW9uIG1vdW50U3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgdmFyIGZpYmVyID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMTtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dFNuYXBzaG90O1xuICB2YXIgaXNIeWRyYXRpbmcgPSBnZXRJc0h5ZHJhdGluZygpO1xuXG4gIGlmIChpc0h5ZHJhdGluZykge1xuICAgIGlmIChnZXRTZXJ2ZXJTbmFwc2hvdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZ2V0U2VydmVyU25hcHNob3QsIHdoaWNoIGlzIHJlcXVpcmVkIGZvciAnICsgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBXaWxsIHJldmVydCB0byBjbGllbnQgcmVuZGVyaW5nLicpO1xuICAgIH1cblxuICAgIG5leHRTbmFwc2hvdCA9IGdldFNlcnZlclNuYXBzaG90KCk7XG5cbiAgICB7XG4gICAgICBpZiAoIWRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90KSB7XG4gICAgICAgIGlmIChuZXh0U25hcHNob3QgIT09IGdldFNlcnZlclNuYXBzaG90KCkpIHtcbiAgICAgICAgICBlcnJvcignVGhlIHJlc3VsdCBvZiBnZXRTZXJ2ZXJTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AnKTtcblxuICAgICAgICAgIGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBuZXh0U25hcHNob3QgPSBnZXRTbmFwc2hvdCgpO1xuXG4gICAge1xuICAgICAgaWYgKCFkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCkge1xuICAgICAgICB2YXIgY2FjaGVkU25hcHNob3QgPSBnZXRTbmFwc2hvdCgpO1xuXG4gICAgICAgIGlmICghb2JqZWN0SXMobmV4dFNuYXBzaG90LCBjYWNoZWRTbmFwc2hvdCkpIHtcbiAgICAgICAgICBlcnJvcignVGhlIHJlc3VsdCBvZiBnZXRTbmFwc2hvdCBzaG91bGQgYmUgY2FjaGVkIHRvIGF2b2lkIGFuIGluZmluaXRlIGxvb3AnKTtcblxuICAgICAgICAgIGRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gVW5sZXNzIHdlJ3JlIHJlbmRlcmluZyBhIGJsb2NraW5nIGxhbmUsIHNjaGVkdWxlIGEgY29uc2lzdGVuY3kgY2hlY2suXG4gICAgLy8gUmlnaHQgYmVmb3JlIGNvbW1pdHRpbmcsIHdlIHdpbGwgd2FsayB0aGUgdHJlZSBhbmQgY2hlY2sgaWYgYW55IG9mIHRoZVxuICAgIC8vIHN0b3JlcyB3ZXJlIG11dGF0ZWQuXG4gICAgLy9cbiAgICAvLyBXZSB3b24ndCBkbyB0aGlzIGlmIHdlJ3JlIGh5ZHJhdGluZyBzZXJ2ZXItcmVuZGVyZWQgY29udGVudCwgYmVjYXVzZSBpZlxuICAgIC8vIHRoZSBjb250ZW50IGlzIHN0YWxlLCBpdCdzIGFscmVhZHkgdmlzaWJsZSBhbnl3YXkuIEluc3RlYWQgd2UnbGwgcGF0Y2hcbiAgICAvLyBpdCB1cCBpbiBhIHBhc3NpdmUgZWZmZWN0LlxuXG5cbiAgICB2YXIgcm9vdCA9IGdldFdvcmtJblByb2dyZXNzUm9vdCgpO1xuXG4gICAgaWYgKHJvb3QgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYSB3b3JrLWluLXByb2dyZXNzIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cblxuICAgIHZhciByb290UmVuZGVyTGFuZXMgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcygpO1xuXG4gICAgaWYgKCFpbmNsdWRlc0Jsb2NraW5nTGFuZShyb290LCByb290UmVuZGVyTGFuZXMpKSB7XG4gICAgICBwdXNoU3RvcmVDb25zaXN0ZW5jeUNoZWNrKGZpYmVyLCBnZXRTbmFwc2hvdCwgbmV4dFNuYXBzaG90KTtcbiAgICB9XG4gIH0gLy8gUmVhZCB0aGUgY3VycmVudCBzbmFwc2hvdCBmcm9tIHRoZSBzdG9yZSBvbiBldmVyeSByZW5kZXIuIFRoaXMgYnJlYWtzIHRoZVxuICAvLyBub3JtYWwgcnVsZXMgb2YgUmVhY3QsIGFuZCBvbmx5IHdvcmtzIGJlY2F1c2Ugc3RvcmUgdXBkYXRlcyBhcmVcbiAgLy8gYWx3YXlzIHN5bmNocm9ub3VzLlxuXG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV4dFNuYXBzaG90O1xuICB2YXIgaW5zdCA9IHtcbiAgICB2YWx1ZTogbmV4dFNuYXBzaG90LFxuICAgIGdldFNuYXBzaG90OiBnZXRTbmFwc2hvdFxuICB9O1xuICBob29rLnF1ZXVlID0gaW5zdDsgLy8gU2NoZWR1bGUgYW4gZWZmZWN0IHRvIHN1YnNjcmliZSB0byB0aGUgc3RvcmUuXG5cbiAgbW91bnRFZmZlY3Qoc3Vic2NyaWJlVG9TdG9yZS5iaW5kKG51bGwsIGZpYmVyLCBpbnN0LCBzdWJzY3JpYmUpLCBbc3Vic2NyaWJlXSk7IC8vIFNjaGVkdWxlIGFuIGVmZmVjdCB0byB1cGRhdGUgdGhlIG11dGFibGUgaW5zdGFuY2UgZmllbGRzLiBXZSB3aWxsIHVwZGF0ZVxuICAvLyB0aGlzIHdoZW5ldmVyIHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIG9yIHZhbHVlIGNoYW5nZXMuIEJlY2F1c2UgdGhlcmUncyBub1xuICAvLyBjbGVhbi11cCBmdW5jdGlvbiwgYW5kIHdlIHRyYWNrIHRoZSBkZXBzIGNvcnJlY3RseSwgd2UgY2FuIGNhbGwgcHVzaEVmZmVjdFxuICAvLyBkaXJlY3RseSwgd2l0aG91dCBzdG9yaW5nIGFueSBhZGRpdGlvbmFsIHN0YXRlLiBGb3IgdGhlIHNhbWUgcmVhc29uLCB3ZVxuICAvLyBkb24ndCBuZWVkIHRvIHNldCBhIHN0YXRpYyBmbGFnLCBlaXRoZXIuXG5cbiAgZmliZXIuZmxhZ3MgfD0gUGFzc2l2ZSQxO1xuICBwdXNoRWZmZWN0KEhhc0VmZmVjdCB8IFBhc3NpdmUsIHVwZGF0ZVN0b3JlSW5zdGFuY2UuYmluZChudWxsLCBmaWJlciwgaW5zdCwgbmV4dFNuYXBzaG90LCBnZXRTbmFwc2hvdCksIGNyZWF0ZUVmZmVjdEluc3RhbmNlKCksIG51bGwpO1xuICByZXR1cm4gbmV4dFNuYXBzaG90O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICB2YXIgZmliZXIgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxO1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpOyAvLyBSZWFkIHRoZSBjdXJyZW50IHNuYXBzaG90IGZyb20gdGhlIHN0b3JlIG9uIGV2ZXJ5IHJlbmRlci4gVGhpcyBicmVha3MgdGhlXG4gIC8vIG5vcm1hbCBydWxlcyBvZiBSZWFjdCwgYW5kIG9ubHkgd29ya3MgYmVjYXVzZSBzdG9yZSB1cGRhdGVzIGFyZVxuICAvLyBhbHdheXMgc3luY2hyb25vdXMuXG5cbiAgdmFyIG5leHRTbmFwc2hvdDtcbiAgdmFyIGlzSHlkcmF0aW5nID0gZ2V0SXNIeWRyYXRpbmcoKTtcblxuICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAvLyBOZWVkZWQgZm9yIHN0cmljdCBtb2RlIGRvdWJsZSByZW5kZXJcbiAgICBpZiAoZ2V0U2VydmVyU25hcHNob3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdNaXNzaW5nIGdldFNlcnZlclNuYXBzaG90LCB3aGljaCBpcyByZXF1aXJlZCBmb3IgJyArICdzZXJ2ZXItcmVuZGVyZWQgY29udGVudC4gV2lsbCByZXZlcnQgdG8gY2xpZW50IHJlbmRlcmluZy4nKTtcbiAgICB9XG5cbiAgICBuZXh0U25hcHNob3QgPSBnZXRTZXJ2ZXJTbmFwc2hvdCgpO1xuICB9IGVsc2Uge1xuICAgIG5leHRTbmFwc2hvdCA9IGdldFNuYXBzaG90KCk7XG5cbiAgICB7XG4gICAgICBpZiAoIWRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90KSB7XG4gICAgICAgIHZhciBjYWNoZWRTbmFwc2hvdCA9IGdldFNuYXBzaG90KCk7XG5cbiAgICAgICAgaWYgKCFvYmplY3RJcyhuZXh0U25hcHNob3QsIGNhY2hlZFNuYXBzaG90KSkge1xuICAgICAgICAgIGVycm9yKCdUaGUgcmVzdWx0IG9mIGdldFNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCcpO1xuXG4gICAgICAgICAgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHByZXZTbmFwc2hvdCA9IChjdXJyZW50SG9vayB8fCBob29rKS5tZW1vaXplZFN0YXRlO1xuICB2YXIgc25hcHNob3RDaGFuZ2VkID0gIW9iamVjdElzKHByZXZTbmFwc2hvdCwgbmV4dFNuYXBzaG90KTtcblxuICBpZiAoc25hcHNob3RDaGFuZ2VkKSB7XG4gICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV4dFNuYXBzaG90O1xuICAgIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCk7XG4gIH1cblxuICB2YXIgaW5zdCA9IGhvb2sucXVldWU7XG4gIHVwZGF0ZUVmZmVjdChzdWJzY3JpYmVUb1N0b3JlLmJpbmQobnVsbCwgZmliZXIsIGluc3QsIHN1YnNjcmliZSksIFtzdWJzY3JpYmVdKTsgLy8gV2hlbmV2ZXIgZ2V0U25hcHNob3Qgb3Igc3Vic2NyaWJlIGNoYW5nZXMsIHdlIG5lZWQgdG8gY2hlY2sgaW4gdGhlXG4gIC8vIGNvbW1pdCBwaGFzZSBpZiB0aGVyZSB3YXMgYW4gaW50ZXJsZWF2ZWQgbXV0YXRpb24uIEluIGNvbmN1cnJlbnQgbW9kZVxuICAvLyB0aGlzIGNhbiBoYXBwZW4gYWxsIHRoZSB0aW1lLCBidXQgZXZlbiBpbiBzeW5jaHJvbm91cyBtb2RlLCBhbiBlYXJsaWVyXG4gIC8vIGVmZmVjdCBtYXkgaGF2ZSBtdXRhdGVkIHRoZSBzdG9yZS5cblxuICBpZiAoaW5zdC5nZXRTbmFwc2hvdCAhPT0gZ2V0U25hcHNob3QgfHwgc25hcHNob3RDaGFuZ2VkIHx8IC8vIENoZWNrIGlmIHRoZSBzdWJzY3JpYmUgZnVuY3Rpb24gY2hhbmdlZC4gV2UgY2FuIHNhdmUgc29tZSBtZW1vcnkgYnlcbiAgLy8gY2hlY2tpbmcgd2hldGhlciB3ZSBzY2hlZHVsZWQgYSBzdWJzY3JpcHRpb24gZWZmZWN0IGFib3ZlLlxuICB3b3JrSW5Qcm9ncmVzc0hvb2sgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3NIb29rLm1lbW9pemVkU3RhdGUudGFnICYgSGFzRWZmZWN0KSB7XG4gICAgZmliZXIuZmxhZ3MgfD0gUGFzc2l2ZSQxO1xuICAgIHB1c2hFZmZlY3QoSGFzRWZmZWN0IHwgUGFzc2l2ZSwgdXBkYXRlU3RvcmVJbnN0YW5jZS5iaW5kKG51bGwsIGZpYmVyLCBpbnN0LCBuZXh0U25hcHNob3QsIGdldFNuYXBzaG90KSwgY3JlYXRlRWZmZWN0SW5zdGFuY2UoKSwgbnVsbCk7IC8vIFVubGVzcyB3ZSdyZSByZW5kZXJpbmcgYSBibG9ja2luZyBsYW5lLCBzY2hlZHVsZSBhIGNvbnNpc3RlbmN5IGNoZWNrLlxuICAgIC8vIFJpZ2h0IGJlZm9yZSBjb21taXR0aW5nLCB3ZSB3aWxsIHdhbGsgdGhlIHRyZWUgYW5kIGNoZWNrIGlmIGFueSBvZiB0aGVcbiAgICAvLyBzdG9yZXMgd2VyZSBtdXRhdGVkLlxuXG4gICAgdmFyIHJvb3QgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTtcblxuICAgIGlmIChyb290ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgd29yay1pbi1wcm9ncmVzcyByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzSHlkcmF0aW5nICYmICFpbmNsdWRlc0Jsb2NraW5nTGFuZShyb290LCByZW5kZXJMYW5lcykpIHtcbiAgICAgIHB1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2soZmliZXIsIGdldFNuYXBzaG90LCBuZXh0U25hcHNob3QpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXh0U25hcHNob3Q7XG59XG5cbmZ1bmN0aW9uIHB1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2soZmliZXIsIGdldFNuYXBzaG90LCByZW5kZXJlZFNuYXBzaG90KSB7XG4gIGZpYmVyLmZsYWdzIHw9IFN0b3JlQ29uc2lzdGVuY3k7XG4gIHZhciBjaGVjayA9IHtcbiAgICBnZXRTbmFwc2hvdDogZ2V0U25hcHNob3QsXG4gICAgdmFsdWU6IHJlbmRlcmVkU25hcHNob3RcbiAgfTtcbiAgdmFyIGNvbXBvbmVudFVwZGF0ZVF1ZXVlID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZTtcblxuICBpZiAoY29tcG9uZW50VXBkYXRlUXVldWUgPT09IG51bGwpIHtcbiAgICBjb21wb25lbnRVcGRhdGVRdWV1ZSA9IGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKTtcbiAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlID0gY29tcG9uZW50VXBkYXRlUXVldWU7XG4gICAgY29tcG9uZW50VXBkYXRlUXVldWUuc3RvcmVzID0gW2NoZWNrXTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgc3RvcmVzID0gY29tcG9uZW50VXBkYXRlUXVldWUuc3RvcmVzO1xuXG4gICAgaWYgKHN0b3JlcyA9PT0gbnVsbCkge1xuICAgICAgY29tcG9uZW50VXBkYXRlUXVldWUuc3RvcmVzID0gW2NoZWNrXTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RvcmVzLnB1c2goY2hlY2spO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVTdG9yZUluc3RhbmNlKGZpYmVyLCBpbnN0LCBuZXh0U25hcHNob3QsIGdldFNuYXBzaG90KSB7XG4gIC8vIFRoZXNlIGFyZSB1cGRhdGVkIGluIHRoZSBwYXNzaXZlIHBoYXNlXG4gIGluc3QudmFsdWUgPSBuZXh0U25hcHNob3Q7XG4gIGluc3QuZ2V0U25hcHNob3QgPSBnZXRTbmFwc2hvdDsgLy8gU29tZXRoaW5nIG1heSBoYXZlIGJlZW4gbXV0YXRlZCBpbiBiZXR3ZWVuIHJlbmRlciBhbmQgY29tbWl0LiBUaGlzIGNvdWxkXG4gIC8vIGhhdmUgYmVlbiBpbiBhbiBldmVudCB0aGF0IGZpcmVkIGJlZm9yZSB0aGUgcGFzc2l2ZSBlZmZlY3RzLCBvciBpdCBjb3VsZFxuICAvLyBoYXZlIGJlZW4gaW4gYSBsYXlvdXQgZWZmZWN0LiBJbiB0aGF0IGNhc2UsIHdlIHdvdWxkIGhhdmUgdXNlZCB0aGUgb2xkXG4gIC8vIHNuYXBzaG8gYW5kIGdldFNuYXBzaG90IHZhbHVlcyB0byBiYWlsIG91dC4gV2UgbmVlZCB0byBjaGVjayBvbmUgbW9yZSB0aW1lLlxuXG4gIGlmIChjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKSB7XG4gICAgLy8gRm9yY2UgYSByZS1yZW5kZXIuXG4gICAgZm9yY2VTdG9yZVJlcmVuZGVyKGZpYmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdWJzY3JpYmVUb1N0b3JlKGZpYmVyLCBpbnN0LCBzdWJzY3JpYmUpIHtcbiAgdmFyIGhhbmRsZVN0b3JlQ2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFRoZSBzdG9yZSBjaGFuZ2VkLiBDaGVjayBpZiB0aGUgc25hcHNob3QgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHdlXG4gICAgLy8gcmVhZCBmcm9tIHRoZSBzdG9yZS5cbiAgICBpZiAoY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSkge1xuICAgICAgLy8gRm9yY2UgYSByZS1yZW5kZXIuXG4gICAgICBmb3JjZVN0b3JlUmVyZW5kZXIoZmliZXIpO1xuICAgIH1cbiAgfTsgLy8gU3Vic2NyaWJlIHRvIHRoZSBzdG9yZSBhbmQgcmV0dXJuIGEgY2xlYW4tdXAgZnVuY3Rpb24uXG5cblxuICByZXR1cm4gc3Vic2NyaWJlKGhhbmRsZVN0b3JlQ2hhbmdlKTtcbn1cblxuZnVuY3Rpb24gY2hlY2tJZlNuYXBzaG90Q2hhbmdlZChpbnN0KSB7XG4gIHZhciBsYXRlc3RHZXRTbmFwc2hvdCA9IGluc3QuZ2V0U25hcHNob3Q7XG4gIHZhciBwcmV2VmFsdWUgPSBpbnN0LnZhbHVlO1xuXG4gIHRyeSB7XG4gICAgdmFyIG5leHRWYWx1ZSA9IGxhdGVzdEdldFNuYXBzaG90KCk7XG4gICAgcmV0dXJuICFvYmplY3RJcyhwcmV2VmFsdWUsIG5leHRWYWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yY2VTdG9yZVJlcmVuZGVyKGZpYmVyKSB7XG4gIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBTeW5jTGFuZSk7XG5cbiAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtb3VudFN0YXRlSW1wbChpbml0aWFsU3RhdGUpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuXG4gIGlmICh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIGluaXRpYWxTdGF0ZUluaXRpYWxpemVyID0gaW5pdGlhbFN0YXRlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdOiBGbG93IGRvZXNuJ3QgbGlrZSBtaXhlZCB0eXBlc1xuXG4gICAgaW5pdGlhbFN0YXRlID0gaW5pdGlhbFN0YXRlSW5pdGlhbGl6ZXIoKTtcblxuICAgIGlmIChzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFVikge1xuICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV06IEZsb3cgZG9lc24ndCBsaWtlIG1peGVkIHR5cGVzXG5cbiAgICAgIGluaXRpYWxTdGF0ZUluaXRpYWxpemVyKCk7XG4gICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7XG4gICAgfVxuICB9XG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIHZhciBxdWV1ZSA9IHtcbiAgICBwZW5kaW5nOiBudWxsLFxuICAgIGxhbmVzOiBOb0xhbmVzLFxuICAgIGRpc3BhdGNoOiBudWxsLFxuICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGJhc2ljU3RhdGVSZWR1Y2VyLFxuICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBpbml0aWFsU3RhdGVcbiAgfTtcbiAgaG9vay5xdWV1ZSA9IHF1ZXVlO1xuICByZXR1cm4gaG9vaztcbn1cblxuZnVuY3Rpb24gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFN0YXRlSW1wbChpbml0aWFsU3RhdGUpO1xuICB2YXIgcXVldWUgPSBob29rLnF1ZXVlO1xuICB2YXIgZGlzcGF0Y2ggPSBkaXNwYXRjaFNldFN0YXRlLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSwgcXVldWUpO1xuICBxdWV1ZS5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICByZXR1cm4gW2hvb2subWVtb2l6ZWRTdGF0ZSwgZGlzcGF0Y2hdO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xufVxuXG5mdW5jdGlvbiByZXJlbmRlclN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICByZXR1cm4gcmVyZW5kZXJSZWR1Y2VyKGJhc2ljU3RhdGVSZWR1Y2VyKTtcbn1cblxuZnVuY3Rpb24gbW91bnRPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gaG9vay5iYXNlU3RhdGUgPSBwYXNzdGhyb3VnaDtcbiAgdmFyIHF1ZXVlID0ge1xuICAgIHBlbmRpbmc6IG51bGwsXG4gICAgbGFuZXM6IE5vTGFuZXMsXG4gICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgLy8gT3B0aW1pc3RpYyBzdGF0ZSBkb2VzIG5vdCB1c2UgdGhlIGVhZ2VyIHVwZGF0ZSBvcHRpbWl6YXRpb24uXG4gICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogbnVsbCxcbiAgICBsYXN0UmVuZGVyZWRTdGF0ZTogbnVsbFxuICB9O1xuICBob29rLnF1ZXVlID0gcXVldWU7IC8vIFRoaXMgaXMgZGlmZmVyZW50IHRoYW4gdGhlIG5vcm1hbCBzZXRTdGF0ZSBmdW5jdGlvbi5cblxuICB2YXIgZGlzcGF0Y2ggPSBkaXNwYXRjaE9wdGltaXN0aWNTZXRTdGF0ZS5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsIHRydWUsIHF1ZXVlKTtcbiAgcXVldWUuZGlzcGF0Y2ggPSBkaXNwYXRjaDtcbiAgcmV0dXJuIFtwYXNzdGhyb3VnaCwgZGlzcGF0Y2hdO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHJldHVybiB1cGRhdGVPcHRpbWlzdGljSW1wbChob29rLCBjdXJyZW50SG9vaywgcGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVPcHRpbWlzdGljSW1wbChob29rLCBjdXJyZW50LCBwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICAvLyBPcHRpbWlzdGljIHVwZGF0ZXMgYXJlIGFsd2F5cyByZWJhc2VkIG9uIHRvcCBvZiB0aGUgbGF0ZXN0IHZhbHVlIHBhc3NlZCBpblxuICAvLyBhcyBhbiBhcmd1bWVudC4gSXQncyBjYWxsZWQgYSBwYXNzdGhyb3VnaCBiZWNhdXNlIGlmIHRoZXJlIGFyZSBubyBwZW5kaW5nXG4gIC8vIHVwZGF0ZXMsIGl0IHdpbGwgYmUgcmV0dXJuZWQgYXMtaXMuXG4gIC8vXG4gIC8vIFJlc2V0IHRoZSBiYXNlIHN0YXRlIHRvIHRoZSBwYXNzdGhyb3VnaC4gRnV0dXJlIHVwZGF0ZXMgd2lsbCBiZSBhcHBsaWVkXG4gIC8vIG9uIHRvcCBvZiB0aGlzLlxuICBob29rLmJhc2VTdGF0ZSA9IHBhc3N0aHJvdWdoOyAvLyBJZiBhIHJlZHVjZXIgaXMgbm90IHByb3ZpZGVkLCBkZWZhdWx0IHRvIHRoZSBzYW1lIG9uZSB1c2VkIGJ5IHVzZVN0YXRlLlxuXG4gIHZhciByZXNvbHZlZFJlZHVjZXIgPSB0eXBlb2YgcmVkdWNlciA9PT0gJ2Z1bmN0aW9uJyA/IHJlZHVjZXIgOiBiYXNpY1N0YXRlUmVkdWNlcjtcbiAgcmV0dXJuIHVwZGF0ZVJlZHVjZXJJbXBsKGhvb2ssIGN1cnJlbnRIb29rLCByZXNvbHZlZFJlZHVjZXIpO1xufVxuXG5mdW5jdGlvbiByZXJlbmRlck9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgLy8gVW5saWtlIHVzZVN0YXRlLCB1c2VPcHRpbWlzdGljIGRvZXNuJ3Qgc3VwcG9ydCByZW5kZXIgcGhhc2UgdXBkYXRlcy5cbiAgLy8gQWxzbyB1bmxpa2UgdXNlU3RhdGUsIHdlIG5lZWQgdG8gcmVwbGF5IGFsbCBwZW5kaW5nIHVwZGF0ZXMgYWdhaW4gaW4gY2FzZVxuICAvLyB0aGUgcGFzc3Rocm91Z2ggdmFsdWUgY2hhbmdlZC5cbiAgLy9cbiAgLy8gU28gaW5zdGVhZCBvZiBhIGZvcmtlZCByZS1yZW5kZXIgaW1wbGVtZW50YXRpb24gdGhhdCBrbm93cyBob3cgdG8gaGFuZGxlXG4gIC8vIHJlbmRlciBwaGFzZSB1ZHBhdGVzLCB3ZSBjYW4gdXNlIHRoZSBzYW1lIGltcGxlbWVudGF0aW9uIGFzIGR1cmluZyBhXG4gIC8vIHJlZ3VsYXIgbW91bnQgb3IgdXBkYXRlLlxuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuXG4gIGlmIChjdXJyZW50SG9vayAhPT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgYW4gdXBkYXRlLiBQcm9jZXNzIHRoZSB1cGRhdGUgcXVldWUuXG4gICAgcmV0dXJuIHVwZGF0ZU9wdGltaXN0aWNJbXBsKGhvb2ssIGN1cnJlbnRIb29rLCBwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG4gIH0gLy8gVGhpcyBpcyBhIG1vdW50LiBObyB1cGRhdGVzIHRvIHByb2Nlc3MuXG4gIC8vIFJlc2V0IHRoZSBiYXNlIHN0YXRlIHRvIHRoZSBwYXNzdGhyb3VnaC4gRnV0dXJlIHVwZGF0ZXMgd2lsbCBiZSBhcHBsaWVkXG4gIC8vIG9uIHRvcCBvZiB0aGlzLlxuXG5cbiAgaG9vay5iYXNlU3RhdGUgPSBwYXNzdGhyb3VnaDtcbiAgdmFyIGRpc3BhdGNoID0gaG9vay5xdWV1ZS5kaXNwYXRjaDtcbiAgcmV0dXJuIFtwYXNzdGhyb3VnaCwgZGlzcGF0Y2hdO1xufSAvLyB1c2VBY3Rpb25TdGF0ZSBhY3Rpb25zIHJ1biBzZXF1ZW50aWFsbHksIGJlY2F1c2UgZWFjaCBhY3Rpb24gcmVjZWl2ZXMgdGhlXG4vLyBwcmV2aW91cyBzdGF0ZSBhcyBhbiBhcmd1bWVudC4gV2Ugc3RvcmUgcGVuZGluZyBhY3Rpb25zIG9uIGEgcXVldWUuXG5cblxuZnVuY3Rpb24gZGlzcGF0Y2hBY3Rpb25TdGF0ZShmaWJlciwgYWN0aW9uUXVldWUsIHNldFBlbmRpbmdTdGF0ZSwgc2V0U3RhdGUsIHBheWxvYWQpIHtcbiAgaWYgKGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgdXBkYXRlIGZvcm0gc3RhdGUgd2hpbGUgcmVuZGVyaW5nLicpO1xuICB9XG5cbiAgdmFyIGxhc3QgPSBhY3Rpb25RdWV1ZS5wZW5kaW5nO1xuXG4gIGlmIChsYXN0ID09PSBudWxsKSB7XG4gICAgLy8gVGhlcmUgYXJlIG5vIHBlbmRpbmcgYWN0aW9uczsgdGhpcyBpcyB0aGUgZmlyc3Qgb25lLiBXZSBjYW4gcnVuXG4gICAgLy8gaXQgaW1tZWRpYXRlbHkuXG4gICAgdmFyIG5ld0xhc3QgPSB7XG4gICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgbmV4dDogbnVsbCAvLyBjaXJjdWxhclxuXG4gICAgfTtcbiAgICBuZXdMYXN0Lm5leHQgPSBhY3Rpb25RdWV1ZS5wZW5kaW5nID0gbmV3TGFzdDtcbiAgICBydW5BY3Rpb25TdGF0ZUFjdGlvbihhY3Rpb25RdWV1ZSwgc2V0UGVuZGluZ1N0YXRlLCBzZXRTdGF0ZSwgcGF5bG9hZCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhlcmUncyBhbHJlYWR5IGFuIGFjdGlvbiBydW5uaW5nLiBBZGQgdG8gdGhlIHF1ZXVlLlxuICAgIHZhciBmaXJzdCA9IGxhc3QubmV4dDtcbiAgICB2YXIgX25ld0xhc3QgPSB7XG4gICAgICBwYXlsb2FkOiBwYXlsb2FkLFxuICAgICAgbmV4dDogZmlyc3RcbiAgICB9O1xuICAgIGFjdGlvblF1ZXVlLnBlbmRpbmcgPSBsYXN0Lm5leHQgPSBfbmV3TGFzdDtcbiAgfVxufVxuXG5mdW5jdGlvbiBydW5BY3Rpb25TdGF0ZUFjdGlvbihhY3Rpb25RdWV1ZSwgc2V0UGVuZGluZ1N0YXRlLCBzZXRTdGF0ZSwgcGF5bG9hZCkge1xuICB2YXIgYWN0aW9uID0gYWN0aW9uUXVldWUuYWN0aW9uO1xuICB2YXIgcHJldlN0YXRlID0gYWN0aW9uUXVldWUuc3RhdGU7IC8vIFRoaXMgaXMgYSBmb3JrIG9mIHN0YXJ0VHJhbnNpdGlvblxuXG4gIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQ7XG4gIHZhciBjdXJyZW50VHJhbnNpdGlvbiA9IHt9O1xuICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gY3VycmVudFRyYW5zaXRpb247XG5cbiAge1xuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQuX3VwZGF0ZWRGaWJlcnMgPSBuZXcgU2V0KCk7XG4gIH0gLy8gT3B0aW1pc3RpY2FsbHkgdXBkYXRlIHRoZSBwZW5kaW5nIHN0YXRlLCBzaW1pbGFyIHRvIHVzZVRyYW5zaXRpb24uXG4gIC8vIFRoaXMgd2lsbCBiZSByZXZlcnRlZCBhdXRvbWF0aWNhbGx5IHdoZW4gYWxsIGFjdGlvbnMgYXJlIGZpbmlzaGVkLlxuXG5cbiAgc2V0UGVuZGluZ1N0YXRlKHRydWUpO1xuXG4gIHRyeSB7XG4gICAgdmFyIHJldHVyblZhbHVlID0gYWN0aW9uKHByZXZTdGF0ZSwgcGF5bG9hZCk7XG4gICAgdmFyIG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUztcblxuICAgIGlmIChvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCAhPT0gbnVsbCkge1xuICAgICAgb25TdGFydFRyYW5zaXRpb25GaW5pc2goY3VycmVudFRyYW5zaXRpb24sIHJldHVyblZhbHVlKTtcbiAgICB9XG5cbiAgICBpZiAocmV0dXJuVmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHJldHVyblZhbHVlID09PSAnb2JqZWN0JyAmJiAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG4gICAgdHlwZW9mIHJldHVyblZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciB0aGVuYWJsZSA9IHJldHVyblZhbHVlOyAvLyBBdHRhY2ggYSBsaXN0ZW5lciB0byByZWFkIHRoZSByZXR1cm4gc3RhdGUgb2YgdGhlIGFjdGlvbi4gQXMgc29vbiBhc1xuICAgICAgLy8gdGhpcyByZXNvbHZlcywgd2UgY2FuIHJ1biB0aGUgbmV4dCBhY3Rpb24gaW4gdGhlIHNlcXVlbmNlLlxuXG4gICAgICB0aGVuYWJsZS50aGVuKGZ1bmN0aW9uIChuZXh0U3RhdGUpIHtcbiAgICAgICAgYWN0aW9uUXVldWUuc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICAgIGZpbmlzaFJ1bm5pbmdBY3Rpb25TdGF0ZUFjdGlvbihhY3Rpb25RdWV1ZSwgc2V0UGVuZGluZ1N0YXRlLCBzZXRTdGF0ZSk7XG4gICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBmaW5pc2hSdW5uaW5nQWN0aW9uU3RhdGVBY3Rpb24oYWN0aW9uUXVldWUsIHNldFBlbmRpbmdTdGF0ZSwgc2V0U3RhdGUpO1xuICAgICAgfSk7XG4gICAgICBzZXRTdGF0ZSh0aGVuYWJsZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFN0YXRlKHJldHVyblZhbHVlKTtcbiAgICAgIHZhciBuZXh0U3RhdGUgPSByZXR1cm5WYWx1ZTtcbiAgICAgIGFjdGlvblF1ZXVlLnN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgZmluaXNoUnVubmluZ0FjdGlvblN0YXRlQWN0aW9uKGFjdGlvblF1ZXVlLCBzZXRQZW5kaW5nU3RhdGUsIHNldFN0YXRlKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gVGhpcyBpcyBhIHRyaWNrIHRvIGdldCB0aGUgYHVzZUFjdGlvblN0YXRlYCBob29rIHRvIHJldGhyb3cgdGhlIGVycm9yLlxuICAgIC8vIFdoZW4gaXQgdW53cmFwcyB0aGUgdGhlbmFibGUgd2l0aCB0aGUgYHVzZWAgYWxnb3JpdGhtLCB0aGUgZXJyb3JcbiAgICAvLyB3aWxsIGJlIHRocm93bi5cbiAgICB2YXIgcmVqZWN0ZWRUaGVuYWJsZSA9IHtcbiAgICAgIHRoZW46IGZ1bmN0aW9uICgpIHt9LFxuICAgICAgc3RhdHVzOiAncmVqZWN0ZWQnLFxuICAgICAgcmVhc29uOiBlcnJvciAvLyAkRmxvd0ZpeE1lOiBOb3Qgc3VyZSB3aHkgdGhpcyBkb2Vzbid0IHdvcmtcblxuICAgIH07XG4gICAgc2V0U3RhdGUocmVqZWN0ZWRUaGVuYWJsZSk7XG4gICAgZmluaXNoUnVubmluZ0FjdGlvblN0YXRlQWN0aW9uKGFjdGlvblF1ZXVlLCBzZXRQZW5kaW5nU3RhdGUsIHNldFN0YXRlKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb247XG5cbiAgICB7XG4gICAgICBpZiAocHJldlRyYW5zaXRpb24gPT09IG51bGwgJiYgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMpIHtcbiAgICAgICAgdmFyIHVwZGF0ZWRGaWJlcnNDb3VudCA9IGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLnNpemU7XG5cbiAgICAgICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuY2xlYXIoKTtcblxuICAgICAgICBpZiAodXBkYXRlZEZpYmVyc0NvdW50ID4gMTApIHtcbiAgICAgICAgICB3YXJuKCdEZXRlY3RlZCBhIGxhcmdlIG51bWJlciBvZiB1cGRhdGVzIGluc2lkZSBzdGFydFRyYW5zaXRpb24uICcgKyAnSWYgdGhpcyBpcyBkdWUgdG8gYSBzdWJzY3JpcHRpb24gcGxlYXNlIHJlLXdyaXRlIGl0IHRvIHVzZSBSZWFjdCBwcm92aWRlZCBob29rcy4gJyArICdPdGhlcndpc2UgY29uY3VycmVudCBtb2RlIGd1YXJhbnRlZXMgYXJlIG9mZiB0aGUgdGFibGUuJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoUnVubmluZ0FjdGlvblN0YXRlQWN0aW9uKGFjdGlvblF1ZXVlLCBzZXRQZW5kaW5nU3RhdGUsIHNldFN0YXRlKSB7XG4gIC8vIFRoZSBhY3Rpb24gZmluaXNoZWQgcnVubmluZy4gUG9wIGl0IGZyb20gdGhlIHF1ZXVlIGFuZCBydW4gdGhlIG5leHQgcGVuZGluZ1xuICAvLyBhY3Rpb24sIGlmIHRoZXJlIGFyZSBhbnkuXG4gIHZhciBsYXN0ID0gYWN0aW9uUXVldWUucGVuZGluZztcblxuICBpZiAobGFzdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaXJzdCA9IGxhc3QubmV4dDtcblxuICAgIGlmIChmaXJzdCA9PT0gbGFzdCkge1xuICAgICAgLy8gVGhpcyB3YXMgdGhlIGxhc3QgYWN0aW9uIGluIHRoZSBxdWV1ZS5cbiAgICAgIGFjdGlvblF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG5vZGUgZnJvbSB0aGUgY2lyY3VsYXIgcXVldWUuXG4gICAgICB2YXIgbmV4dCA9IGZpcnN0Lm5leHQ7XG4gICAgICBsYXN0Lm5leHQgPSBuZXh0OyAvLyBSdW4gdGhlIG5leHQgYWN0aW9uLlxuXG4gICAgICBydW5BY3Rpb25TdGF0ZUFjdGlvbihhY3Rpb25RdWV1ZSwgc2V0UGVuZGluZ1N0YXRlLCBzZXRTdGF0ZSwgbmV4dC5wYXlsb2FkKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWN0aW9uU3RhdGVSZWR1Y2VyKG9sZFN0YXRlLCBuZXdTdGF0ZSkge1xuICByZXR1cm4gbmV3U3RhdGU7XG59XG5cbmZ1bmN0aW9uIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGVQcm9wLCBwZXJtYWxpbmspIHtcbiAgdmFyIGluaXRpYWxTdGF0ZSA9IGluaXRpYWxTdGF0ZVByb3A7XG5cbiAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICB2YXIgcm9vdCA9IGdldFdvcmtJblByb2dyZXNzUm9vdCgpO1xuICAgIHZhciBzc3JGb3JtU3RhdGUgPSByb290LmZvcm1TdGF0ZTsgLy8gSWYgYSBmb3JtU3RhdGUgb3B0aW9uIHdhcyBwYXNzZWQgdG8gdGhlIHJvb3QsIHRoZXJlIGFyZSBmb3JtIHN0YXRlXG4gICAgLy8gbWFya2VycyB0aGF0IHdlIG5lZWQgdG8gaHlkcmF0ZS4gVGhlc2UgaW5kaWNhdGUgd2hldGhlciB0aGUgZm9ybSBzdGF0ZVxuICAgIC8vIG1hdGNoZXMgdGhpcyBob29rIGluc3RhbmNlLlxuXG4gICAgaWYgKHNzckZvcm1TdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIGlzTWF0Y2hpbmcgPSB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVGb3JtTWFya2VySW5zdGFuY2UoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSk7XG5cbiAgICAgIGlmIChpc01hdGNoaW5nKSB7XG4gICAgICAgIGluaXRpYWxTdGF0ZSA9IHNzckZvcm1TdGF0ZVswXTtcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gU3RhdGUgaG9vay4gVGhlIHN0YXRlIGlzIHN0b3JlZCBpbiBhIHRoZW5hYmxlIHdoaWNoIGlzIHRoZW4gdW53cmFwcGVkIGJ5XG4gIC8vIHRoZSBgdXNlYCBhbGdvcml0aG0gZHVyaW5nIHJlbmRlci5cblxuXG4gIHZhciBzdGF0ZUhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICBzdGF0ZUhvb2subWVtb2l6ZWRTdGF0ZSA9IHN0YXRlSG9vay5iYXNlU3RhdGUgPSBpbml0aWFsU3RhdGU7IC8vIFRPRE86IFR5cGluZyB0aGlzIFwiY29ycmVjdGx5XCIgcmVzdWx0cyBpbiByZWN1cnNpb24gbGltaXQgZXJyb3JzXG4gIC8vIGNvbnN0IHN0YXRlUXVldWU6IFVwZGF0ZVF1ZXVlPFMgfCBBd2FpdGVkPFM+LCBTIHwgQXdhaXRlZDxTPj4gPSB7XG5cbiAgdmFyIHN0YXRlUXVldWUgPSB7XG4gICAgcGVuZGluZzogbnVsbCxcbiAgICBsYW5lczogTm9MYW5lcyxcbiAgICBkaXNwYXRjaDogbnVsbCxcbiAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBhY3Rpb25TdGF0ZVJlZHVjZXIsXG4gICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxTdGF0ZVxuICB9O1xuICBzdGF0ZUhvb2sucXVldWUgPSBzdGF0ZVF1ZXVlO1xuICB2YXIgc2V0U3RhdGUgPSBkaXNwYXRjaFNldFN0YXRlLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSwgc3RhdGVRdWV1ZSk7XG4gIHN0YXRlUXVldWUuZGlzcGF0Y2ggPSBzZXRTdGF0ZTsgLy8gUGVuZGluZyBzdGF0ZS4gVGhpcyBpcyB1c2VkIHRvIHN0b3JlIHRoZSBwZW5kaW5nIHN0YXRlIG9mIHRoZSBhY3Rpb24uXG4gIC8vIFRyYWNrZWQgb3B0aW1pc3RpY2FsbHksIGxpa2UgYSB0cmFuc2l0aW9uIHBlbmRpbmcgc3RhdGUuXG5cbiAgdmFyIHBlbmRpbmdTdGF0ZUhvb2sgPSBtb3VudFN0YXRlSW1wbChmYWxzZSk7XG4gIHZhciBzZXRQZW5kaW5nU3RhdGUgPSBkaXNwYXRjaE9wdGltaXN0aWNTZXRTdGF0ZS5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsIGZhbHNlLCBwZW5kaW5nU3RhdGVIb29rLnF1ZXVlKTsgLy8gQWN0aW9uIHF1ZXVlIGhvb2suIFRoaXMgaXMgdXNlZCB0byBxdWV1ZSBwZW5kaW5nIGFjdGlvbnMuIFRoZSBxdWV1ZSBpc1xuICAvLyBzaGFyZWQgYmV0d2VlbiBhbGwgaW5zdGFuY2VzIG9mIHRoZSBob29rLiBTaW1pbGFyIHRvIGEgcmVndWxhciBzdGF0ZSBxdWV1ZSxcbiAgLy8gYnV0IGRpZmZlcmVudCBiZWNhdXNlIHRoZSBhY3Rpb25zIGFyZSBydW4gc2VxdWVudGlhbGx5LCBhbmQgdGhleSBydW4gaW5cbiAgLy8gYW4gZXZlbnQgaW5zdGVhZCBvZiBkdXJpbmcgcmVuZGVyLlxuXG4gIHZhciBhY3Rpb25RdWV1ZUhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgYWN0aW9uUXVldWUgPSB7XG4gICAgc3RhdGU6IGluaXRpYWxTdGF0ZSxcbiAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAvLyBjaXJjdWxhclxuICAgIGFjdGlvbjogYWN0aW9uLFxuICAgIHBlbmRpbmc6IG51bGxcbiAgfTtcbiAgYWN0aW9uUXVldWVIb29rLnF1ZXVlID0gYWN0aW9uUXVldWU7XG4gIHZhciBkaXNwYXRjaCA9IGRpc3BhdGNoQWN0aW9uU3RhdGUuYmluZChudWxsLCBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLCBhY3Rpb25RdWV1ZSwgc2V0UGVuZGluZ1N0YXRlLCBzZXRTdGF0ZSk7XG4gIGFjdGlvblF1ZXVlLmRpc3BhdGNoID0gZGlzcGF0Y2g7IC8vIFN0YXNoIHRoZSBhY3Rpb24gZnVuY3Rpb24gb24gdGhlIG1lbW9pemVkIHN0YXRlIG9mIHRoZSBob29rLiBXZSdsbCB1c2UgdGhpc1xuICAvLyB0byBkZXRlY3Qgd2hlbiB0aGUgYWN0aW9uIGZ1bmN0aW9uIGNoYW5nZXMgc28gd2UgY2FuIHVwZGF0ZSBpdCBpblxuICAvLyBhbiBlZmZlY3QuXG5cbiAgYWN0aW9uUXVldWVIb29rLm1lbW9pemVkU3RhdGUgPSBhY3Rpb247XG4gIHJldHVybiBbaW5pdGlhbFN0YXRlLCBkaXNwYXRjaCwgZmFsc2VdO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gIHZhciBzdGF0ZUhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIGN1cnJlbnRTdGF0ZUhvb2sgPSBjdXJyZW50SG9vaztcbiAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlSW1wbChzdGF0ZUhvb2ssIGN1cnJlbnRTdGF0ZUhvb2ssIGFjdGlvbik7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUFjdGlvblN0YXRlSW1wbChzdGF0ZUhvb2ssIGN1cnJlbnRTdGF0ZUhvb2ssIGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgdmFyIF91cGRhdGVSZWR1Y2VySW1wbCA9IHVwZGF0ZVJlZHVjZXJJbXBsKHN0YXRlSG9vaywgY3VycmVudFN0YXRlSG9vaywgYWN0aW9uU3RhdGVSZWR1Y2VyKSxcbiAgICAgIGFjdGlvblJlc3VsdCA9IF91cGRhdGVSZWR1Y2VySW1wbFswXTtcblxuICB2YXIgX3VwZGF0ZVN0YXRlID0gdXBkYXRlU3RhdGUoKSxcbiAgICAgIGlzUGVuZGluZyA9IF91cGRhdGVTdGF0ZVswXTsgLy8gVGhpcyB3aWxsIHN1c3BlbmQgdW50aWwgdGhlIGFjdGlvbiBmaW5pc2hlcy5cblxuXG4gIHZhciBzdGF0ZSA9IHR5cGVvZiBhY3Rpb25SZXN1bHQgPT09ICdvYmplY3QnICYmIGFjdGlvblJlc3VsdCAhPT0gbnVsbCAmJiAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG4gIHR5cGVvZiBhY3Rpb25SZXN1bHQudGhlbiA9PT0gJ2Z1bmN0aW9uJyA/IHVzZVRoZW5hYmxlKGFjdGlvblJlc3VsdCkgOiBhY3Rpb25SZXN1bHQ7XG4gIHZhciBhY3Rpb25RdWV1ZUhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIGFjdGlvblF1ZXVlID0gYWN0aW9uUXVldWVIb29rLnF1ZXVlO1xuICB2YXIgZGlzcGF0Y2ggPSBhY3Rpb25RdWV1ZS5kaXNwYXRjaDsgLy8gQ2hlY2sgaWYgYSBuZXcgYWN0aW9uIHdhcyBwYXNzZWQuIElmIHNvLCB1cGRhdGUgaXQgaW4gYW4gZWZmZWN0LlxuXG4gIHZhciBwcmV2QWN0aW9uID0gYWN0aW9uUXVldWVIb29rLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKGFjdGlvbiAhPT0gcHJldkFjdGlvbikge1xuICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gUGFzc2l2ZSQxO1xuICAgIHB1c2hFZmZlY3QoSGFzRWZmZWN0IHwgUGFzc2l2ZSwgYWN0aW9uU3RhdGVBY3Rpb25FZmZlY3QuYmluZChudWxsLCBhY3Rpb25RdWV1ZSwgYWN0aW9uKSwgY3JlYXRlRWZmZWN0SW5zdGFuY2UoKSwgbnVsbCk7XG4gIH1cblxuICByZXR1cm4gW3N0YXRlLCBkaXNwYXRjaCwgaXNQZW5kaW5nXTtcbn1cblxuZnVuY3Rpb24gYWN0aW9uU3RhdGVBY3Rpb25FZmZlY3QoYWN0aW9uUXVldWUsIGFjdGlvbikge1xuICBhY3Rpb25RdWV1ZS5hY3Rpb24gPSBhY3Rpb247XG59XG5cbmZ1bmN0aW9uIHJlcmVuZGVyQWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluaykge1xuICAvLyBVbmxpa2UgdXNlU3RhdGUsIHVzZUFjdGlvblN0YXRlIGRvZXNuJ3Qgc3VwcG9ydCByZW5kZXIgcGhhc2UgdXBkYXRlcy5cbiAgLy8gQWxzbyB1bmxpa2UgdXNlU3RhdGUsIHdlIG5lZWQgdG8gcmVwbGF5IGFsbCBwZW5kaW5nIHVwZGF0ZXMgYWdhaW4gaW4gY2FzZVxuICAvLyB0aGUgcGFzc3Rocm91Z2ggdmFsdWUgY2hhbmdlZC5cbiAgLy9cbiAgLy8gU28gaW5zdGVhZCBvZiBhIGZvcmtlZCByZS1yZW5kZXIgaW1wbGVtZW50YXRpb24gdGhhdCBrbm93cyBob3cgdG8gaGFuZGxlXG4gIC8vIHJlbmRlciBwaGFzZSB1ZHBhdGVzLCB3ZSBjYW4gdXNlIHRoZSBzYW1lIGltcGxlbWVudGF0aW9uIGFzIGR1cmluZyBhXG4gIC8vIHJlZ3VsYXIgbW91bnQgb3IgdXBkYXRlLlxuICB2YXIgc3RhdGVIb29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBjdXJyZW50U3RhdGVIb29rID0gY3VycmVudEhvb2s7XG5cbiAgaWYgKGN1cnJlbnRTdGF0ZUhvb2sgIT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIGFuIHVwZGF0ZS4gUHJvY2VzcyB0aGUgdXBkYXRlIHF1ZXVlLlxuICAgIHJldHVybiB1cGRhdGVBY3Rpb25TdGF0ZUltcGwoc3RhdGVIb29rLCBjdXJyZW50U3RhdGVIb29rLCBhY3Rpb24pO1xuICB9XG5cbiAgdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7IC8vIFN0YXRlXG4gIC8vIFRoaXMgaXMgYSBtb3VudC4gTm8gdXBkYXRlcyB0byBwcm9jZXNzLlxuXG4gIHZhciBzdGF0ZSA9IHN0YXRlSG9vay5tZW1vaXplZFN0YXRlO1xuICB2YXIgYWN0aW9uUXVldWVIb29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBhY3Rpb25RdWV1ZSA9IGFjdGlvblF1ZXVlSG9vay5xdWV1ZTtcbiAgdmFyIGRpc3BhdGNoID0gYWN0aW9uUXVldWUuZGlzcGF0Y2g7IC8vIFRoaXMgbWF5IGhhdmUgY2hhbmdlZCBkdXJpbmcgdGhlIHJlcmVuZGVyLlxuXG4gIGFjdGlvblF1ZXVlSG9vay5tZW1vaXplZFN0YXRlID0gYWN0aW9uOyAvLyBGb3IgbW91bnQsIHBlbmRpbmcgaXMgYWx3YXlzIGZhbHNlLlxuXG4gIHJldHVybiBbc3RhdGUsIGRpc3BhdGNoLCBmYWxzZV07XG59XG5cbmZ1bmN0aW9uIHB1c2hFZmZlY3QodGFnLCBjcmVhdGUsIGluc3QsIGRlcHMpIHtcbiAgdmFyIGVmZmVjdCA9IHtcbiAgICB0YWc6IHRhZyxcbiAgICBjcmVhdGU6IGNyZWF0ZSxcbiAgICBpbnN0OiBpbnN0LFxuICAgIGRlcHM6IGRlcHMsXG4gICAgLy8gQ2lyY3VsYXJcbiAgICBuZXh0OiBudWxsXG4gIH07XG4gIHZhciBjb21wb25lbnRVcGRhdGVRdWV1ZSA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWU7XG5cbiAgaWYgKGNvbXBvbmVudFVwZGF0ZVF1ZXVlID09PSBudWxsKSB7XG4gICAgY29tcG9uZW50VXBkYXRlUXVldWUgPSBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlKCk7XG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZSA9IGNvbXBvbmVudFVwZGF0ZVF1ZXVlO1xuICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3QgPSBlZmZlY3QubmV4dCA9IGVmZmVjdDtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGFzdEVmZmVjdCA9IGNvbXBvbmVudFVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3Q7XG5cbiAgICBpZiAobGFzdEVmZmVjdCA9PT0gbnVsbCkge1xuICAgICAgY29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdCA9IGVmZmVjdC5uZXh0ID0gZWZmZWN0O1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgICBsYXN0RWZmZWN0Lm5leHQgPSBlZmZlY3Q7XG4gICAgICBlZmZlY3QubmV4dCA9IGZpcnN0RWZmZWN0O1xuICAgICAgY29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdCA9IGVmZmVjdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWZmZWN0O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFZmZlY3RJbnN0YW5jZSgpIHtcbiAgcmV0dXJuIHtcbiAgICBkZXN0cm95OiB1bmRlZmluZWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gbW91bnRSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIHJlZiA9IHtcbiAgICBjdXJyZW50OiBpbml0aWFsVmFsdWVcbiAgfTtcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gcmVmO1xuICByZXR1cm4gcmVmO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVSZWYoaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHJldHVybiBob29rLm1lbW9pemVkU3RhdGU7XG59XG5cbmZ1bmN0aW9uIG1vdW50RWZmZWN0SW1wbChmaWJlckZsYWdzLCBob29rRmxhZ3MsIGNyZWF0ZSwgZGVwcykge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmZsYWdzIHw9IGZpYmVyRmxhZ3M7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHB1c2hFZmZlY3QoSGFzRWZmZWN0IHwgaG9va0ZsYWdzLCBjcmVhdGUsIGNyZWF0ZUVmZmVjdEluc3RhbmNlKCksIG5leHREZXBzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRWZmZWN0SW1wbChmaWJlckZsYWdzLCBob29rRmxhZ3MsIGNyZWF0ZSwgZGVwcykge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgdmFyIGVmZmVjdCA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIGluc3QgPSBlZmZlY3QuaW5zdDsgLy8gY3VycmVudEhvb2sgaXMgbnVsbCBvbiBpbml0aWFsIG1vdW50IHdoZW4gcmVyZW5kZXJpbmcgYWZ0ZXIgYSByZW5kZXIgcGhhc2VcbiAgLy8gc3RhdGUgdXBkYXRlIG9yIGZvciBzdHJpY3QgbW9kZS5cblxuICBpZiAoY3VycmVudEhvb2sgIT09IG51bGwpIHtcbiAgICBpZiAobmV4dERlcHMgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2RWZmZWN0ID0gY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICAgIHZhciBwcmV2RGVwcyA9IHByZXZFZmZlY3QuZGVwcztcblxuICAgICAgaWYgKGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpKSB7XG4gICAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHB1c2hFZmZlY3QoaG9va0ZsYWdzLCBjcmVhdGUsIGluc3QsIG5leHREZXBzKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gZmliZXJGbGFncztcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gcHVzaEVmZmVjdChIYXNFZmZlY3QgfCBob29rRmxhZ3MsIGNyZWF0ZSwgaW5zdCwgbmV4dERlcHMpO1xufVxuXG5mdW5jdGlvbiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgaWYgKChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1vZGUgJiBTdHJpY3RFZmZlY3RzTW9kZSkgIT09IE5vTW9kZSAmJiAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tb2RlICYgTm9TdHJpY3RQYXNzaXZlRWZmZWN0c01vZGUpID09PSBOb01vZGUpIHtcbiAgICBtb3VudEVmZmVjdEltcGwoTW91bnRQYXNzaXZlRGV2IHwgUGFzc2l2ZSQxIHwgUGFzc2l2ZVN0YXRpYywgUGFzc2l2ZSwgY3JlYXRlLCBkZXBzKTtcbiAgfSBlbHNlIHtcbiAgICBtb3VudEVmZmVjdEltcGwoUGFzc2l2ZSQxIHwgUGFzc2l2ZVN0YXRpYywgUGFzc2l2ZSwgY3JlYXRlLCBkZXBzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHVwZGF0ZUVmZmVjdEltcGwoUGFzc2l2ZSQxLCBQYXNzaXZlLCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiBtb3VudEluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgbW91bnRFZmZlY3RJbXBsKFVwZGF0ZSwgSW5zZXJ0aW9uLCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKFVwZGF0ZSwgSW5zZXJ0aW9uLCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGZpYmVyRmxhZ3MgPSBVcGRhdGUgfCBMYXlvdXRTdGF0aWM7XG5cbiAgaWYgKChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1vZGUgJiBTdHJpY3RFZmZlY3RzTW9kZSkgIT09IE5vTW9kZSkge1xuICAgIGZpYmVyRmxhZ3MgfD0gTW91bnRMYXlvdXREZXY7XG4gIH1cblxuICByZXR1cm4gbW91bnRFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIExheW91dCwgY3JlYXRlLCBkZXBzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICByZXR1cm4gdXBkYXRlRWZmZWN0SW1wbChVcGRhdGUsIExheW91dCwgY3JlYXRlLCBkZXBzKTtcbn1cblxuZnVuY3Rpb24gaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdChjcmVhdGUsIHJlZikge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciByZWZDYWxsYmFjayA9IHJlZjtcbiAgICB2YXIgaW5zdCA9IGNyZWF0ZSgpO1xuICAgIHZhciByZWZDbGVhbnVwID0gcmVmQ2FsbGJhY2soaW5zdCk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVmQ2xlYW51cCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIHdlIG5lZWQgdG8gYXNzdW1lIG5vIHBhcmFtZXRlcnNcbiAgICAgICAgcmVmQ2xlYW51cCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVmQ2FsbGJhY2sobnVsbCk7XG4gICAgICB9XG4gICAgfTtcbiAgfSBlbHNlIGlmIChyZWYgIT09IG51bGwgJiYgcmVmICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgcmVmT2JqZWN0ID0gcmVmO1xuXG4gICAge1xuICAgICAgaWYgKCFyZWZPYmplY3QuaGFzT3duUHJvcGVydHkoJ2N1cnJlbnQnKSkge1xuICAgICAgICBlcnJvcignRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIGZpcnN0IGFyZ3VtZW50IHRvIGVpdGhlciBiZSBhICcgKyAncmVmIGNhbGxiYWNrIG9yIFJlYWN0LmNyZWF0ZVJlZigpIG9iamVjdC4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgJ2FuIG9iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhyZWZPYmplY3QpLmpvaW4oJywgJykgKyAnfScpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBfaW5zdCA9IGNyZWF0ZSgpO1xuXG4gICAgcmVmT2JqZWN0LmN1cnJlbnQgPSBfaW5zdDtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmVmT2JqZWN0LmN1cnJlbnQgPSBudWxsO1xuICAgIH07XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbiAnICsgJ3RoYXQgY3JlYXRlcyBhIGhhbmRsZS4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY3JlYXRlICE9PSBudWxsID8gdHlwZW9mIGNyZWF0ZSA6ICdudWxsJyk7XG4gICAgfVxuICB9IC8vIFRPRE86IElmIGRlcHMgYXJlIHByb3ZpZGVkLCBzaG91bGQgd2Ugc2tpcCBjb21wYXJpbmcgdGhlIHJlZiBpdHNlbGY/XG5cblxuICB2YXIgZWZmZWN0RGVwcyA9IGRlcHMgIT09IG51bGwgJiYgZGVwcyAhPT0gdW5kZWZpbmVkID8gZGVwcy5jb25jYXQoW3JlZl0pIDogbnVsbDtcbiAgdmFyIGZpYmVyRmxhZ3MgPSBVcGRhdGUgfCBMYXlvdXRTdGF0aWM7XG5cbiAgaWYgKChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1vZGUgJiBTdHJpY3RFZmZlY3RzTW9kZSkgIT09IE5vTW9kZSkge1xuICAgIGZpYmVyRmxhZ3MgfD0gTW91bnRMYXlvdXREZXY7XG4gIH1cblxuICBtb3VudEVmZmVjdEltcGwoZmliZXJGbGFncywgTGF5b3V0LCBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0LmJpbmQobnVsbCwgY3JlYXRlLCByZWYpLCBlZmZlY3REZXBzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcykge1xuICB7XG4gICAgaWYgKHR5cGVvZiBjcmVhdGUgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCB1c2VJbXBlcmF0aXZlSGFuZGxlKCkgc2Vjb25kIGFyZ3VtZW50IHRvIGJlIGEgZnVuY3Rpb24gJyArICd0aGF0IGNyZWF0ZXMgYSBoYW5kbGUuIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNyZWF0ZSAhPT0gbnVsbCA/IHR5cGVvZiBjcmVhdGUgOiAnbnVsbCcpO1xuICAgIH1cbiAgfSAvLyBUT0RPOiBJZiBkZXBzIGFyZSBwcm92aWRlZCwgc2hvdWxkIHdlIHNraXAgY29tcGFyaW5nIHRoZSByZWYgaXRzZWxmP1xuXG5cbiAgdmFyIGVmZmVjdERlcHMgPSBkZXBzICE9PSBudWxsICYmIGRlcHMgIT09IHVuZGVmaW5lZCA/IGRlcHMuY29uY2F0KFtyZWZdKSA6IG51bGw7XG4gIHVwZGF0ZUVmZmVjdEltcGwoVXBkYXRlLCBMYXlvdXQsIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QuYmluZChudWxsLCBjcmVhdGUsIHJlZiksIGVmZmVjdERlcHMpO1xufVxuXG5mdW5jdGlvbiBtb3VudERlYnVnVmFsdWUodmFsdWUsIGZvcm1hdHRlckZuKSB7Ly8gVGhpcyBob29rIGlzIG5vcm1hbGx5IGEgbm8tb3AuXG4gIC8vIFRoZSByZWFjdC1kZWJ1Zy1ob29rcyBwYWNrYWdlIGluamVjdHMgaXRzIG93biBpbXBsZW1lbnRhdGlvblxuICAvLyBzbyB0aGF0IGUuZy4gRGV2VG9vbHMgY2FuIGRpc3BsYXkgY3VzdG9tIGhvb2sgdmFsdWVzLlxufVxuXG52YXIgdXBkYXRlRGVidWdWYWx1ZSA9IG1vdW50RGVidWdWYWx1ZTtcblxuZnVuY3Rpb24gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBbY2FsbGJhY2ssIG5leHREZXBzXTtcbiAgcmV0dXJuIGNhbGxiYWNrO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcykge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgdmFyIHByZXZTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAobmV4dERlcHMgIT09IG51bGwpIHtcbiAgICB2YXIgcHJldkRlcHMgPSBwcmV2U3RhdGVbMV07XG5cbiAgICBpZiAoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykpIHtcbiAgICAgIHJldHVybiBwcmV2U3RhdGVbMF07XG4gICAgfVxuICB9XG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gW2NhbGxiYWNrLCBuZXh0RGVwc107XG4gIHJldHVybiBjYWxsYmFjaztcbn1cblxuZnVuY3Rpb24gbW91bnRNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgdmFyIG5leHRWYWx1ZSA9IG5leHRDcmVhdGUoKTtcblxuICBpZiAoc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYpIHtcbiAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTtcbiAgICBuZXh0Q3JlYXRlKCk7XG4gICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICB9XG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gW25leHRWYWx1ZSwgbmV4dERlcHNdO1xuICByZXR1cm4gbmV4dFZhbHVlO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNZW1vKG5leHRDcmVhdGUsIGRlcHMpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIHZhciBwcmV2U3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGU7IC8vIEFzc3VtZSB0aGVzZSBhcmUgZGVmaW5lZC4gSWYgdGhleSdyZSBub3QsIGFyZUhvb2tJbnB1dHNFcXVhbCB3aWxsIHdhcm4uXG5cbiAgaWYgKG5leHREZXBzICE9PSBudWxsKSB7XG4gICAgdmFyIHByZXZEZXBzID0gcHJldlN0YXRlWzFdO1xuXG4gICAgaWYgKGFyZUhvb2tJbnB1dHNFcXVhbChuZXh0RGVwcywgcHJldkRlcHMpKSB7XG4gICAgICByZXR1cm4gcHJldlN0YXRlWzBdO1xuICAgIH1cbiAgfVxuXG4gIHZhciBuZXh0VmFsdWUgPSBuZXh0Q3JlYXRlKCk7XG5cbiAgaWYgKHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWKSB7XG4gICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7XG4gICAgbmV4dENyZWF0ZSgpO1xuICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgfVxuXG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtuZXh0VmFsdWUsIG5leHREZXBzXTtcbiAgcmV0dXJuIG5leHRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlSW1wbChob29rLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciByZXNvbHZlZEN1cnJlbnRIb29rID0gY3VycmVudEhvb2s7XG4gIHZhciBwcmV2VmFsdWUgPSByZXNvbHZlZEN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGU7XG4gIHJldHVybiB1cGRhdGVEZWZlcnJlZFZhbHVlSW1wbChob29rLCBwcmV2VmFsdWUsIHZhbHVlLCBpbml0aWFsVmFsdWUpO1xufVxuXG5mdW5jdGlvbiByZXJlbmRlckRlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuXG4gIGlmIChjdXJyZW50SG9vayA9PT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgYSByZXJlbmRlciBkdXJpbmcgYSBtb3VudC5cbiAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlSW1wbChob29rLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIGEgcmVyZW5kZXIgZHVyaW5nIGFuIHVwZGF0ZS5cbiAgICB2YXIgcHJldlZhbHVlID0gY3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgICByZXR1cm4gdXBkYXRlRGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgcHJldlZhbHVlLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtb3VudERlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgaWYgKC8vIFdoZW4gYGluaXRpYWxWYWx1ZWAgaXMgcHJvdmlkZWQsIHdlIGRlZmVyIHRoZSBpbml0aWFsIHJlbmRlciBldmVuIGlmIHRoZVxuICAvLyBjdXJyZW50IHJlbmRlciBpcyBub3Qgc3luY2hyb25vdXMuXG4gIGluaXRpYWxWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIC8vIEhvd2V2ZXIsIHRvIGF2b2lkIHdhdGVyZmFsbHMsIHdlIGRvIG5vdCBkZWZlciBpZiB0aGlzIHJlbmRlclxuICAvLyB3YXMgaXRzZWxmIHNwYXduZWQgYnkgYW4gZWFybGllciB1c2VEZWZlcnJlZFZhbHVlLiBDaGVjayBpZiBEZWZlcnJlZExhbmVcbiAgLy8gaXMgcGFydCBvZiB0aGUgcmVuZGVyIGxhbmVzLlxuICAhaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgRGVmZXJyZWRMYW5lKSkge1xuICAgIC8vIFJlbmRlciB3aXRoIHRoZSBpbml0aWFsIHZhbHVlXG4gICAgaG9vay5tZW1vaXplZFN0YXRlID0gaW5pdGlhbFZhbHVlOyAvLyBTY2hlZHVsZSBhIGRlZmVycmVkIHJlbmRlciB0byBzd2l0Y2ggdG8gdGhlIGZpbmFsIHZhbHVlLlxuXG4gICAgdmFyIGRlZmVycmVkTGFuZSA9IHJlcXVlc3REZWZlcnJlZExhbmUoKTtcbiAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzID0gbWVyZ2VMYW5lcyhjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzLCBkZWZlcnJlZExhbmUpO1xuICAgIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXMoZGVmZXJyZWRMYW5lKTtcbiAgICByZXR1cm4gaW5pdGlhbFZhbHVlO1xuICB9IGVsc2Uge1xuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHZhbHVlO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVEZWZlcnJlZFZhbHVlSW1wbChob29rLCBwcmV2VmFsdWUsIHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgaWYgKG9iamVjdElzKHZhbHVlLCBwcmV2VmFsdWUpKSB7XG4gICAgLy8gVGhlIGluY29taW5nIHZhbHVlIGlzIHJlZmVyZW50aWFsbHkgaWRlbnRpY2FsIHRvIHRoZSBjdXJyZW50bHkgcmVuZGVyZWRcbiAgICAvLyB2YWx1ZSwgc28gd2UgY2FuIGJhaWwgb3V0IHF1aWNrbHkuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIC8vIFJlY2VpdmVkIGEgbmV3IHZhbHVlIHRoYXQncyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBpbnNpZGUgYSBoaWRkZW4gdHJlZVxuICAgIGlmIChpc0N1cnJlbnRUcmVlSGlkZGVuKCkpIHtcbiAgICAgIC8vIFJldmVhbGluZyBhIHByZXJlbmRlcmVkIHRyZWUgaXMgY29uc2lkZXJlZCB0aGUgc2FtZSBhcyBtb3VudGluZyBuZXdcbiAgICAgIC8vIG9uZSwgc28gd2UgcmV1c2UgdGhlIFwibW91bnRcIiBwYXRoIGluIHRoaXMgY2FzZS5cbiAgICAgIHZhciByZXN1bHRWYWx1ZSA9IG1vdW50RGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgdmFsdWUsIGluaXRpYWxWYWx1ZSk7IC8vIFVubGlrZSBkdXJpbmcgYW4gYWN0dWFsIG1vdW50LCB3ZSBuZWVkIHRvIG1hcmsgdGhpcyBhcyBhbiB1cGRhdGUgaWZcbiAgICAgIC8vIHRoZSB2YWx1ZSBjaGFuZ2VkLlxuXG4gICAgICBpZiAoIW9iamVjdElzKHJlc3VsdFZhbHVlLCBwcmV2VmFsdWUpKSB7XG4gICAgICAgIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRWYWx1ZTtcbiAgICB9XG5cbiAgICB2YXIgc2hvdWxkRGVmZXJWYWx1ZSA9ICFpbmNsdWRlc09ubHlOb25VcmdlbnRMYW5lcyhyZW5kZXJMYW5lcyk7XG5cbiAgICBpZiAoc2hvdWxkRGVmZXJWYWx1ZSkge1xuICAgICAgLy8gVGhpcyBpcyBhbiB1cmdlbnQgdXBkYXRlLiBTaW5jZSB0aGUgdmFsdWUgaGFzIGNoYW5nZWQsIGtlZXAgdXNpbmcgdGhlXG4gICAgICAvLyBwcmV2aW91cyB2YWx1ZSBhbmQgc3Bhd24gYSBkZWZlcnJlZCByZW5kZXIgdG8gdXBkYXRlIGl0IGxhdGVyLlxuICAgICAgLy8gU2NoZWR1bGUgYSBkZWZlcnJlZCByZW5kZXJcbiAgICAgIHZhciBkZWZlcnJlZExhbmUgPSByZXF1ZXN0RGVmZXJyZWRMYW5lKCk7XG4gICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzID0gbWVyZ2VMYW5lcyhjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzLCBkZWZlcnJlZExhbmUpO1xuICAgICAgbWFya1NraXBwZWRVcGRhdGVMYW5lcyhkZWZlcnJlZExhbmUpOyAvLyBSZXVzZSB0aGUgcHJldmlvdXMgdmFsdWUuIFdlIGRvIG5vdCBuZWVkIHRvIG1hcmsgdGhpcyBhcyBhbiB1cGRhdGUsXG4gICAgICAvLyBiZWNhdXNlIHdlIGRpZCBub3QgcmVuZGVyIGEgbmV3IHZhbHVlLlxuXG4gICAgICByZXR1cm4gcHJldlZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGlzIG5vdCBhbiB1cmdlbnQgdXBkYXRlLCBzbyB3ZSBjYW4gdXNlIHRoZSBsYXRlc3QgdmFsdWUgcmVnYXJkbGVzc1xuICAgICAgLy8gb2Ygd2hhdCBpdCBpcy4gTm8gbmVlZCB0byBkZWZlciBpdC5cbiAgICAgIC8vIE1hcmsgdGhpcyBhcyBhbiB1cGRhdGUgdG8gcHJldmVudCB0aGUgZmliZXIgZnJvbSBiYWlsaW5nIG91dC5cbiAgICAgIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCk7XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSB2YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRUcmFuc2l0aW9uKGZpYmVyLCBxdWV1ZSwgcGVuZGluZ1N0YXRlLCBmaW5pc2hlZFN0YXRlLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoaGlnaGVyRXZlbnRQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5LCBDb250aW51b3VzRXZlbnRQcmlvcml0eSkpO1xuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5UO1xuICB2YXIgY3VycmVudFRyYW5zaXRpb24gPSB7fTtcblxuICB7XG4gICAgLy8gV2UgZG9uJ3QgcmVhbGx5IG5lZWQgdG8gdXNlIGFuIG9wdGltaXN0aWMgdXBkYXRlIGhlcmUsIGJlY2F1c2Ugd2VcbiAgICAvLyBzY2hlZHVsZSBhIHNlY29uZCBcInJldmVydFwiIHVwZGF0ZSBiZWxvdyAod2hpY2ggd2UgdXNlIHRvIHN1c3BlbmQgdGhlXG4gICAgLy8gdHJhbnNpdGlvbiB1bnRpbCB0aGUgYXN5bmMgYWN0aW9uIHNjb3BlIGhhcyBmaW5pc2hlZCkuIEJ1dCB3ZSdsbCB1c2UgYW5cbiAgICAvLyBvcHRpbWlzdGljIHVwZGF0ZSBhbnl3YXkgdG8gbWFrZSBpdCBsZXNzIGxpa2VseSB0aGUgYmVoYXZpb3IgYWNjaWRlbnRhbGx5XG4gICAgLy8gZGl2ZXJnZXM7IGZvciBleGFtcGxlLCBib3RoIGFuIG9wdGltaXN0aWMgdXBkYXRlIGFuZCB0aGlzIG9uZSBzaG91bGRcbiAgICAvLyBzaGFyZSB0aGUgc2FtZSBsYW5lLlxuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBjdXJyZW50VHJhbnNpdGlvbjtcbiAgICBkaXNwYXRjaE9wdGltaXN0aWNTZXRTdGF0ZShmaWJlciwgZmFsc2UsIHF1ZXVlLCBwZW5kaW5nU3RhdGUpO1xuICB9XG5cbiAge1xuICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzID0gbmV3IFNldCgpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBpZiAoZW5hYmxlQXN5bmNBY3Rpb25zKSB7XG4gICAgICB2YXIgcmV0dXJuVmFsdWUgPSBjYWxsYmFjaygpO1xuICAgICAgdmFyIG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUztcblxuICAgICAgaWYgKG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoICE9PSBudWxsKSB7XG4gICAgICAgIG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoKGN1cnJlbnRUcmFuc2l0aW9uLCByZXR1cm5WYWx1ZSk7XG4gICAgICB9IC8vIENoZWNrIGlmIHdlJ3JlIGluc2lkZSBhbiBhc3luYyBhY3Rpb24gc2NvcGUuIElmIHNvLCB3ZSdsbCBlbnRhbmdsZVxuICAgICAgLy8gdGhpcyBuZXcgYWN0aW9uIHdpdGggdGhlIGV4aXN0aW5nIHNjb3BlLlxuICAgICAgLy9cbiAgICAgIC8vIElmIHdlJ3JlIG5vdCBhbHJlYWR5IGluc2lkZSBhbiBhc3luYyBhY3Rpb24gc2NvcGUsIGFuZCB0aGlzIGFjdGlvbiBpc1xuICAgICAgLy8gYXN5bmMsIHRoZW4gd2UnbGwgY3JlYXRlIGEgbmV3IGFzeW5jIHNjb3BlLlxuICAgICAgLy9cbiAgICAgIC8vIEluIHRoZSBhc3luYyBjYXNlLCB0aGUgcmVzdWx0aW5nIHJlbmRlciB3aWxsIHN1c3BlbmQgdW50aWwgdGhlIGFzeW5jXG4gICAgICAvLyBhY3Rpb24gc2NvcGUgaGFzIGZpbmlzaGVkLlxuXG5cbiAgICAgIGlmIChyZXR1cm5WYWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgcmV0dXJuVmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhciB0aGVuYWJsZSA9IHJldHVyblZhbHVlOyAvLyBDcmVhdGUgYSB0aGVuYWJsZSB0aGF0IHJlc29sdmVzIHRvIGBmaW5pc2hlZFN0YXRlYCBvbmNlIHRoZSBhc3luY1xuICAgICAgICAvLyBhY3Rpb24gaGFzIGNvbXBsZXRlZC5cblxuICAgICAgICB2YXIgdGhlbmFibGVGb3JGaW5pc2hlZFN0YXRlID0gY2hhaW5UaGVuYWJsZVZhbHVlKHRoZW5hYmxlLCBmaW5pc2hlZFN0YXRlKTtcbiAgICAgICAgZGlzcGF0Y2hTZXRTdGF0ZShmaWJlciwgcXVldWUsIHRoZW5hYmxlRm9yRmluaXNoZWRTdGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkaXNwYXRjaFNldFN0YXRlKGZpYmVyLCBxdWV1ZSwgZmluaXNoZWRTdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB0cmljayB0byBnZXQgdGhlIGB1c2VUcmFuc2l0aW9uYCBob29rIHRvIHJldGhyb3cgdGhlIGVycm9yLlxuICAgICAgLy8gV2hlbiBpdCB1bndyYXBzIHRoZSB0aGVuYWJsZSB3aXRoIHRoZSBgdXNlYCBhbGdvcml0aG0sIHRoZSBlcnJvclxuICAgICAgLy8gd2lsbCBiZSB0aHJvd24uXG4gICAgICB2YXIgcmVqZWN0ZWRUaGVuYWJsZSA9IHtcbiAgICAgICAgdGhlbjogZnVuY3Rpb24gKCkge30sXG4gICAgICAgIHN0YXR1czogJ3JlamVjdGVkJyxcbiAgICAgICAgcmVhc29uOiBlcnJvclxuICAgICAgfTtcbiAgICAgIGRpc3BhdGNoU2V0U3RhdGUoZmliZXIsIHF1ZXVlLCByZWplY3RlZFRoZW5hYmxlKTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1xuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbjtcblxuICAgIHtcbiAgICAgIGlmIChwcmV2VHJhbnNpdGlvbiA9PT0gbnVsbCAmJiBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycykge1xuICAgICAgICB2YXIgdXBkYXRlZEZpYmVyc0NvdW50ID0gY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuc2l6ZTtcblxuICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5jbGVhcigpO1xuXG4gICAgICAgIGlmICh1cGRhdGVkRmliZXJzQ291bnQgPiAxMCkge1xuICAgICAgICAgIHdhcm4oJ0RldGVjdGVkIGEgbGFyZ2UgbnVtYmVyIG9mIHVwZGF0ZXMgaW5zaWRlIHN0YXJ0VHJhbnNpdGlvbi4gJyArICdJZiB0aGlzIGlzIGR1ZSB0byBhIHN1YnNjcmlwdGlvbiBwbGVhc2UgcmUtd3JpdGUgaXQgdG8gdXNlIFJlYWN0IHByb3ZpZGVkIGhvb2tzLiAnICsgJ090aGVyd2lzZSBjb25jdXJyZW50IG1vZGUgZ3VhcmFudGVlcyBhcmUgb2ZmIHRoZSB0YWJsZS4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHt9O1xuXG5mdW5jdGlvbiBzdGFydEhvc3RUcmFuc2l0aW9uKGZvcm1GaWJlciwgcGVuZGluZ1N0YXRlLCBhY3Rpb24sIGZvcm1EYXRhKSB7XG5cbiAgaWYgKGZvcm1GaWJlci50YWcgIT09IEhvc3RDb21wb25lbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRoZSBmb3JtIGluc3RhbmNlIHRvIGJlIGEgSG9zdENvbXBvbmVudC4gVGhpcyAnICsgJ2lzIGEgYnVnIGluIFJlYWN0LicpO1xuICB9XG5cbiAgdmFyIHN0YXRlSG9vayA9IGVuc3VyZUZvcm1Db21wb25lbnRJc1N0YXRlZnVsKGZvcm1GaWJlcik7XG4gIHZhciBxdWV1ZSA9IHN0YXRlSG9vay5xdWV1ZTtcbiAgc3RhcnRUcmFuc2l0aW9uKGZvcm1GaWJlciwgcXVldWUsIHBlbmRpbmdTdGF0ZSwgTm90UGVuZGluZ1RyYW5zaXRpb24sIC8vIFRPRE86IGBzdGFydFRyYW5zaXRpb25gIGJvdGggc2V0cyB0aGUgcGVuZGluZyBzdGF0ZSBhbmQgZGlzcGF0Y2hlc1xuICAvLyB0aGUgYWN0aW9uLCBpZiBvbmUgaXMgcHJvdmlkZWQuIENvbnNpZGVyIHJlZmFjdG9yaW5nIHRoZXNlIHR3b1xuICAvLyBjb25jZXJucyB0byBhdm9pZCB0aGUgZXh0cmEgbGFtYmRhLlxuICBhY3Rpb24gPT09IG51bGwgPyAvLyBObyBhY3Rpb24gd2FzIHByb3ZpZGVkLCBidXQgd2Ugc3RpbGwgY2FsbCBgc3RhcnRUcmFuc2l0aW9uYCB0b1xuICAvLyBzZXQgdGhlIHBlbmRpbmcgZm9ybSBzdGF0dXMuXG4gIG5vb3AgOiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gQXV0b21hdGljYWxseSByZXNldCB0aGUgZm9ybSB3aGVuIHRoZSBhY3Rpb24gY29tcGxldGVzLlxuICAgIHJlcXVlc3RGb3JtUmVzZXQoZm9ybUZpYmVyKTtcbiAgICByZXR1cm4gYWN0aW9uKGZvcm1EYXRhKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGVuc3VyZUZvcm1Db21wb25lbnRJc1N0YXRlZnVsKGZvcm1GaWJlcikge1xuICB2YXIgZXhpc3RpbmdTdGF0ZUhvb2sgPSBmb3JtRmliZXIubWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAoZXhpc3RpbmdTdGF0ZUhvb2sgIT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGZpYmVyIHdhcyBhbHJlYWR5IHVwZ3JhZGVkIHRvIGJlIHN0YXRlZnVsLlxuICAgIHJldHVybiBleGlzdGluZ1N0YXRlSG9vaztcbiAgfSAvLyBVcGdyYWRlIHRoaXMgaG9zdCBjb21wb25lbnQgZmliZXIgdG8gYmUgc3RhdGVmdWwuIFdlJ3JlIGdvaW5nIHRvIHByZXRlbmRcbiAgLy8gaXQgd2FzIHN0YXRlZnVsIGFsbCBhbG9uZyBzbyB3ZSBjYW4gcmV1c2UgbW9zdCBvZiB0aGUgaW1wbGVtZW50YXRpb25cbiAgLy8gZm9yIGZ1bmN0aW9uIGNvbXBvbmVudHMgYW5kIHVzZVRyYW5zaXRpb24uXG4gIC8vXG4gIC8vIENyZWF0ZSB0aGUgc3RhdGUgaG9vayB1c2VkIGJ5IFRyYW5zaXRpb25Bd2FyZUhvc3RDb21wb25lbnQuIFRoaXMgaXNcbiAgLy8gZXNzZW50aWFsbHkgYW4gaW5saW5lZCB2ZXJzaW9uIG9mIG1vdW50U3RhdGUuXG5cblxuICB2YXIgbmV3UXVldWUgPSB7XG4gICAgcGVuZGluZzogbnVsbCxcbiAgICBsYW5lczogTm9MYW5lcyxcbiAgICAvLyBXZSdyZSBnb2luZyB0byBjaGVhdCBhbmQgaW50ZW50aW9uYWxseSBub3QgY3JlYXRlIGEgYm91bmQgZGlzcGF0Y2hcbiAgICAvLyBtZXRob2QsIGJlY2F1c2Ugd2UgY2FuIGNhbGwgaXQgZGlyZWN0bHkgaW4gc3RhcnRUcmFuc2l0aW9uLlxuICAgIGRpc3BhdGNoOiBudWxsLFxuICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGJhc2ljU3RhdGVSZWR1Y2VyLFxuICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBOb3RQZW5kaW5nVHJhbnNpdGlvblxuICB9O1xuICB2YXIgc3RhdGVIb29rID0ge1xuICAgIG1lbW9pemVkU3RhdGU6IE5vdFBlbmRpbmdUcmFuc2l0aW9uLFxuICAgIGJhc2VTdGF0ZTogTm90UGVuZGluZ1RyYW5zaXRpb24sXG4gICAgYmFzZVF1ZXVlOiBudWxsLFxuICAgIHF1ZXVlOiBuZXdRdWV1ZSxcbiAgICBuZXh0OiBudWxsXG4gIH07IC8vIFdlIHVzZSBhbm90aGVyIHN0YXRlIGhvb2sgdG8gdHJhY2sgd2hldGhlciB0aGUgZm9ybSBuZWVkcyB0byBiZSByZXNldC5cbiAgLy8gVGhlIHN0YXRlIGlzIGFuIGVtcHR5IG9iamVjdC4gVG8gdHJpZ2dlciBhIHJlc2V0LCB3ZSB1cGRhdGUgdGhlIHN0YXRlXG4gIC8vIHRvIGEgbmV3IG9iamVjdC4gVGhlbiBkdXJpbmcgcmVuZGVyaW5nLCB3ZSBkZXRlY3QgdGhhdCB0aGUgc3RhdGUgaGFzXG4gIC8vIGNoYW5nZWQgYW5kIHNjaGVkdWxlIGEgY29tbWl0IGVmZmVjdC5cblxuICB2YXIgaW5pdGlhbFJlc2V0U3RhdGUgPSB7fTtcbiAgdmFyIG5ld1Jlc2V0U3RhdGVRdWV1ZSA9IHtcbiAgICBwZW5kaW5nOiBudWxsLFxuICAgIGxhbmVzOiBOb0xhbmVzLFxuICAgIC8vIFdlJ3JlIGdvaW5nIHRvIGNoZWF0IGFuZCBpbnRlbnRpb25hbGx5IG5vdCBjcmVhdGUgYSBib3VuZCBkaXNwYXRjaFxuICAgIC8vIG1ldGhvZCwgYmVjYXVzZSB3ZSBjYW4gY2FsbCBpdCBkaXJlY3RseSBpbiBzdGFydFRyYW5zaXRpb24uXG4gICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogYmFzaWNTdGF0ZVJlZHVjZXIsXG4gICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxSZXNldFN0YXRlXG4gIH07XG4gIHZhciByZXNldFN0YXRlSG9vayA9IHtcbiAgICBtZW1vaXplZFN0YXRlOiBpbml0aWFsUmVzZXRTdGF0ZSxcbiAgICBiYXNlU3RhdGU6IGluaXRpYWxSZXNldFN0YXRlLFxuICAgIGJhc2VRdWV1ZTogbnVsbCxcbiAgICBxdWV1ZTogbmV3UmVzZXRTdGF0ZVF1ZXVlLFxuICAgIG5leHQ6IG51bGxcbiAgfTtcbiAgc3RhdGVIb29rLm5leHQgPSByZXNldFN0YXRlSG9vazsgLy8gQWRkIHRoZSBob29rIGxpc3QgdG8gYm90aCBmaWJlciBhbHRlcm5hdGVzLiBUaGUgaWRlYSBpcyB0aGF0IHRoZSBmaWJlclxuICAvLyBoYWQgdGhpcyBob29rIGFsbCBhbG9uZy5cblxuICBmb3JtRmliZXIubWVtb2l6ZWRTdGF0ZSA9IHN0YXRlSG9vaztcbiAgdmFyIGFsdGVybmF0ZSA9IGZvcm1GaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgIGFsdGVybmF0ZS5tZW1vaXplZFN0YXRlID0gc3RhdGVIb29rO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlSG9vaztcbn1cblxuZnVuY3Rpb24gcmVxdWVzdEZvcm1SZXNldChmb3JtRmliZXIpIHtcbiAgdmFyIHRyYW5zaXRpb24gPSByZXF1ZXN0Q3VycmVudFRyYW5zaXRpb24oKTtcblxuICB7XG4gICAgaWYgKHRyYW5zaXRpb24gPT09IG51bGwpIHtcbiAgICAgIC8vIEFuIG9wdGltaXN0aWMgdXBkYXRlIG9jY3VycmVkLCBidXQgc3RhcnRUcmFuc2l0aW9uIGlzIG5vdCBvbiB0aGUgc3RhY2suXG4gICAgICAvLyBUaGUgZm9ybSByZXNldCB3aWxsIGJlIHNjaGVkdWxlZCBhdCBkZWZhdWx0IChzeW5jKSBwcmlvcml0eSwgd2hpY2hcbiAgICAgIC8vIGlzIHByb2JhYmx5IG5vdCB3aGF0IHRoZSB1c2VyIGludGVuZGVkLiBNb3N0IGxpa2VseSBiZWNhdXNlIHRoZVxuICAgICAgLy8gcmVxdWVzdEZvcm1SZXNldCBjYWxsIGhhcHBlbmVkIGFmdGVyIGFuIGBhd2FpdGAuXG4gICAgICAvLyBUT0RPOiBUaGVvcmV0aWNhbGx5LCByZXF1ZXN0Rm9ybVJlc2V0IGlzIHN0aWxsIHVzZWZ1bCBldmVuIGZvclxuICAgICAgLy8gbm9uLXRyYW5zaXRpb24gdXBkYXRlcyBiZWNhdXNlIGl0IGFsbG93cyB5b3UgdG8gdXBkYXRlIGRlZmF1bHRWYWx1ZVxuICAgICAgLy8gc3luY2hyb25vdXNseSBhbmQgdGhlbiB3YWl0IHRvIHJlc2V0IHVudGlsIGFmdGVyIHRoZSB1cGRhdGUgY29tbWl0cy5cbiAgICAgIC8vIEkndmUgY2hvc2VuIHRvIHdhcm4gYW55d2F5IGJlY2F1c2UgaXQncyBtb3JlIGxpa2VseSB0aGUgYGF3YWl0YCBtaXN0YWtlXG4gICAgICAvLyBkZXNjcmliZWQgYWJvdmUuIEJ1dCBhcmd1YWJseSB3ZSBzaG91bGRuJ3QuXG4gICAgICBlcnJvcigncmVxdWVzdEZvcm1SZXNldCB3YXMgY2FsbGVkIG91dHNpZGUgYSB0cmFuc2l0aW9uIG9yIGFjdGlvbi4gVG8gJyArICdmaXgsIG1vdmUgdG8gYW4gYWN0aW9uLCBvciB3cmFwIHdpdGggc3RhcnRUcmFuc2l0aW9uLicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzdGF0ZUhvb2sgPSBlbnN1cmVGb3JtQ29tcG9uZW50SXNTdGF0ZWZ1bChmb3JtRmliZXIpO1xuICB2YXIgbmV3UmVzZXRTdGF0ZSA9IHt9O1xuICB2YXIgcmVzZXRTdGF0ZUhvb2sgPSBzdGF0ZUhvb2submV4dDtcbiAgdmFyIHJlc2V0U3RhdGVRdWV1ZSA9IHJlc2V0U3RhdGVIb29rLnF1ZXVlO1xuICBkaXNwYXRjaFNldFN0YXRlKGZvcm1GaWJlciwgcmVzZXRTdGF0ZVF1ZXVlLCBuZXdSZXNldFN0YXRlKTtcbn1cblxuZnVuY3Rpb24gbW91bnRUcmFuc2l0aW9uKCkge1xuICB2YXIgc3RhdGVIb29rID0gbW91bnRTdGF0ZUltcGwoZmFsc2UpOyAvLyBUaGUgYHN0YXJ0YCBtZXRob2QgbmV2ZXIgY2hhbmdlcy5cblxuICB2YXIgc3RhcnQgPSBzdGFydFRyYW5zaXRpb24uYmluZChudWxsLCBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLCBzdGF0ZUhvb2sucXVldWUsIHRydWUsIGZhbHNlKTtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBzdGFydDtcbiAgcmV0dXJuIFtmYWxzZSwgc3RhcnRdO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVUcmFuc2l0aW9uKCkge1xuICB2YXIgX3VwZGF0ZVN0YXRlMiA9IHVwZGF0ZVN0YXRlKCksXG4gICAgICBib29sZWFuT3JUaGVuYWJsZSA9IF91cGRhdGVTdGF0ZTJbMF07XG5cbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIHN0YXJ0ID0gaG9vay5tZW1vaXplZFN0YXRlO1xuICB2YXIgaXNQZW5kaW5nID0gdHlwZW9mIGJvb2xlYW5PclRoZW5hYmxlID09PSAnYm9vbGVhbicgPyBib29sZWFuT3JUaGVuYWJsZSA6IC8vIFRoaXMgd2lsbCBzdXNwZW5kIHVudGlsIHRoZSBhc3luYyBhY3Rpb24gc2NvcGUgaGFzIGZpbmlzaGVkLlxuICB1c2VUaGVuYWJsZShib29sZWFuT3JUaGVuYWJsZSk7XG4gIHJldHVybiBbaXNQZW5kaW5nLCBzdGFydF07XG59XG5cbmZ1bmN0aW9uIHJlcmVuZGVyVHJhbnNpdGlvbigpIHtcbiAgdmFyIF9yZXJlbmRlclN0YXRlID0gcmVyZW5kZXJTdGF0ZSgpLFxuICAgICAgYm9vbGVhbk9yVGhlbmFibGUgPSBfcmVyZW5kZXJTdGF0ZVswXTtcblxuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgc3RhcnQgPSBob29rLm1lbW9pemVkU3RhdGU7XG4gIHZhciBpc1BlbmRpbmcgPSB0eXBlb2YgYm9vbGVhbk9yVGhlbmFibGUgPT09ICdib29sZWFuJyA/IGJvb2xlYW5PclRoZW5hYmxlIDogLy8gVGhpcyB3aWxsIHN1c3BlbmQgdW50aWwgdGhlIGFzeW5jIGFjdGlvbiBzY29wZSBoYXMgZmluaXNoZWQuXG4gIHVzZVRoZW5hYmxlKGJvb2xlYW5PclRoZW5hYmxlKTtcbiAgcmV0dXJuIFtpc1BlbmRpbmcsIHN0YXJ0XTtcbn1cblxuZnVuY3Rpb24gdXNlSG9zdFRyYW5zaXRpb25TdGF0dXMoKSB7XG5cbiAgdmFyIHN0YXR1cyA9IHJlYWRDb250ZXh0KEhvc3RUcmFuc2l0aW9uQ29udGV4dCk7XG4gIHJldHVybiBzdGF0dXMgIT09IG51bGwgPyBzdGF0dXMgOiBOb3RQZW5kaW5nVHJhbnNpdGlvbjtcbn1cblxuZnVuY3Rpb24gbW91bnRJZCgpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgcm9vdCA9IGdldFdvcmtJblByb2dyZXNzUm9vdCgpOyAvLyBUT0RPOiBJbiBGaXp6LCBpZCBnZW5lcmF0aW9uIGlzIHNwZWNpZmljIHRvIGVhY2ggc2VydmVyIGNvbmZpZy4gTWF5YmUgd2VcbiAgLy8gc2hvdWxkIGRvIHRoaXMgaW4gRmliZXIsIHRvbz8gRGVmZXJyaW5nIHRoaXMgZGVjaXNpb24gZm9yIG5vdyBiZWNhdXNlXG4gIC8vIHRoZXJlJ3Mgbm8gb3RoZXIgcGxhY2UgdG8gc3RvcmUgdGhlIHByZWZpeCBleGNlcHQgZm9yIGFuIGludGVybmFsIGZpZWxkIG9uXG4gIC8vIHRoZSBwdWJsaWMgY3JlYXRlUm9vdCBvYmplY3QsIHdoaWNoIHRoZSBmaWJlciB0cmVlIGRvZXMgbm90IGN1cnJlbnRseSBoYXZlXG4gIC8vIGEgcmVmZXJlbmNlIHRvLlxuXG4gIHZhciBpZGVudGlmaWVyUHJlZml4ID0gcm9vdC5pZGVudGlmaWVyUHJlZml4O1xuICB2YXIgaWQ7XG5cbiAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICB2YXIgdHJlZUlkID0gZ2V0VHJlZUlkKCk7IC8vIFVzZSBhIGNhcHRpYWwgUiBwcmVmaXggZm9yIHNlcnZlci1nZW5lcmF0ZWQgaWRzLlxuXG4gICAgaWQgPSAnOicgKyBpZGVudGlmaWVyUHJlZml4ICsgJ1InICsgdHJlZUlkOyAvLyBVbmxlc3MgdGhpcyBpcyB0aGUgZmlyc3QgaWQgYXQgdGhpcyBsZXZlbCwgYXBwZW5kIGEgbnVtYmVyIGF0IHRoZSBlbmRcbiAgICAvLyB0aGF0IHJlcHJlc2VudHMgdGhlIHBvc2l0aW9uIG9mIHRoaXMgdXNlSWQgaG9vayBhbW9uZyBhbGwgdGhlIHVzZUlkXG4gICAgLy8gaG9va3MgZm9yIHRoaXMgZmliZXIuXG5cbiAgICB2YXIgbG9jYWxJZCA9IGxvY2FsSWRDb3VudGVyKys7XG5cbiAgICBpZiAobG9jYWxJZCA+IDApIHtcbiAgICAgIGlkICs9ICdIJyArIGxvY2FsSWQudG9TdHJpbmcoMzIpO1xuICAgIH1cblxuICAgIGlkICs9ICc6JztcbiAgfSBlbHNlIHtcbiAgICAvLyBVc2UgYSBsb3dlcmNhc2UgciBwcmVmaXggZm9yIGNsaWVudC1nZW5lcmF0ZWQgaWRzLlxuICAgIHZhciBnbG9iYWxDbGllbnRJZCA9IGdsb2JhbENsaWVudElkQ291bnRlcisrO1xuICAgIGlkID0gJzonICsgaWRlbnRpZmllclByZWZpeCArICdyJyArIGdsb2JhbENsaWVudElkLnRvU3RyaW5nKDMyKSArICc6JztcbiAgfVxuXG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IGlkO1xuICByZXR1cm4gaWQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUlkKCkge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgaWQgPSBob29rLm1lbW9pemVkU3RhdGU7XG4gIHJldHVybiBpZDtcbn1cblxuZnVuY3Rpb24gbW91bnRSZWZyZXNoKCkge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciByZWZyZXNoID0gaG9vay5tZW1vaXplZFN0YXRlID0gcmVmcmVzaENhY2hlLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSk7XG4gIHJldHVybiByZWZyZXNoO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVSZWZyZXNoKCkge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICByZXR1cm4gaG9vay5tZW1vaXplZFN0YXRlO1xufVxuXG5mdW5jdGlvbiByZWZyZXNoQ2FjaGUoZmliZXIsIHNlZWRLZXksIHNlZWRWYWx1ZSkge1xuICAvLyBUT0RPOiBDb25zaWRlciB3YXJuaW5nIGlmIHRoZSByZWZyZXNoIGlzIGF0IGRpc2NyZXRlIHByaW9yaXR5LCBvciBpZiB3ZVxuICAvLyBvdGhlcndpc2Ugc3VzcGVjdCB0aGF0IGl0IHdhc24ndCBiYXRjaGVkIHByb3Blcmx5LlxuXG5cbiAgdmFyIHByb3ZpZGVyID0gZmliZXIucmV0dXJuO1xuXG4gIHdoaWxlIChwcm92aWRlciAhPT0gbnVsbCkge1xuICAgIHN3aXRjaCAocHJvdmlkZXIudGFnKSB7XG4gICAgICBjYXNlIENhY2hlQ29tcG9uZW50OlxuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFNjaGVkdWxlIGFuIHVwZGF0ZSBvbiB0aGUgY2FjaGUgYm91bmRhcnkgdG8gdHJpZ2dlciBhIHJlZnJlc2guXG4gICAgICAgICAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShwcm92aWRlcik7XG4gICAgICAgICAgdmFyIHJlZnJlc2hVcGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlVXBkYXRlKHByb3ZpZGVyLCByZWZyZXNoVXBkYXRlLCBsYW5lKTtcblxuICAgICAgICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgcHJvdmlkZXIsIGxhbmUpO1xuICAgICAgICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhyb290LCBwcm92aWRlciwgbGFuZSk7XG4gICAgICAgICAgfSAvLyBUT0RPOiBJZiBhIHJlZnJlc2ggbmV2ZXIgY29tbWl0cywgdGhlIG5ldyBjYWNoZSBjcmVhdGVkIGhlcmUgbXVzdCBiZVxuICAgICAgICAgIC8vIHJlbGVhc2VkLiBBIHNpbXBsZSBjYXNlIGlzIHN0YXJ0IHJlZnJlc2hpbmcgYSBjYWNoZSBib3VuZGFyeSwgYnV0IHRoZW5cbiAgICAgICAgICAvLyB1bm1vdW50IHRoYXQgYm91bmRhcnkgYmVmb3JlIHRoZSByZWZyZXNoIGNvbXBsZXRlcy5cblxuXG4gICAgICAgICAgdmFyIHNlZWRlZENhY2hlID0gY3JlYXRlQ2FjaGUoKTtcblxuICAgICAgICAgIGlmIChzZWVkS2V5ICE9PSBudWxsICYmIHNlZWRLZXkgIT09IHVuZGVmaW5lZCAmJiByb290ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBlcnJvcignVGhlIHNlZWQgYXJndW1lbnQgaXMgbm90IGVuYWJsZWQgb3V0c2lkZSBleHBlcmltZW50YWwgY2hhbm5lbHMuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IHtcbiAgICAgICAgICAgIGNhY2hlOiBzZWVkZWRDYWNoZVxuICAgICAgICAgIH07XG4gICAgICAgICAgcmVmcmVzaFVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm92aWRlciA9IHByb3ZpZGVyLnJldHVybjtcbiAgfSAvLyBUT0RPOiBXYXJuIGlmIHVubW91bnRlZD9cblxufVxuXG5mdW5jdGlvbiBkaXNwYXRjaFJlZHVjZXJBY3Rpb24oZmliZXIsIHF1ZXVlLCBhY3Rpb24pIHtcbiAge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcihcIlN0YXRlIHVwZGF0ZXMgZnJvbSB0aGUgdXNlU3RhdGUoKSBhbmQgdXNlUmVkdWNlcigpIEhvb2tzIGRvbid0IHN1cHBvcnQgdGhlIFwiICsgJ3NlY29uZCBjYWxsYmFjayBhcmd1bWVudC4gVG8gZXhlY3V0ZSBhIHNpZGUgZWZmZWN0IGFmdGVyICcgKyAncmVuZGVyaW5nLCBkZWNsYXJlIGl0IGluIHRoZSBjb21wb25lbnQgYm9keSB3aXRoIHVzZUVmZmVjdCgpLicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICB2YXIgdXBkYXRlID0ge1xuICAgIGxhbmU6IGxhbmUsXG4gICAgcmV2ZXJ0TGFuZTogTm9MYW5lLFxuICAgIGFjdGlvbjogYWN0aW9uLFxuICAgIGhhc0VhZ2VyU3RhdGU6IGZhbHNlLFxuICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuXG4gIGlmIChpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSkge1xuICAgIGVucXVldWVSZW5kZXJQaGFzZVVwZGF0ZShxdWV1ZSwgdXBkYXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZShmaWJlciwgcXVldWUsIHVwZGF0ZSwgbGFuZSk7XG5cbiAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBsYW5lKTtcbiAgICAgIGVudGFuZ2xlVHJhbnNpdGlvblVwZGF0ZShyb290LCBxdWV1ZSwgbGFuZSk7XG4gICAgfVxuICB9XG5cbiAgbWFya1VwZGF0ZUluRGV2VG9vbHMoZmliZXIsIGxhbmUpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaFNldFN0YXRlKGZpYmVyLCBxdWV1ZSwgYWN0aW9uKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGFyZ3VtZW50c1szXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoXCJTdGF0ZSB1cGRhdGVzIGZyb20gdGhlIHVzZVN0YXRlKCkgYW5kIHVzZVJlZHVjZXIoKSBIb29rcyBkb24ndCBzdXBwb3J0IHRoZSBcIiArICdzZWNvbmQgY2FsbGJhY2sgYXJndW1lbnQuIFRvIGV4ZWN1dGUgYSBzaWRlIGVmZmVjdCBhZnRlciAnICsgJ3JlbmRlcmluZywgZGVjbGFyZSBpdCBpbiB0aGUgY29tcG9uZW50IGJvZHkgd2l0aCB1c2VFZmZlY3QoKS4nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgdmFyIHVwZGF0ZSA9IHtcbiAgICBsYW5lOiBsYW5lLFxuICAgIHJldmVydExhbmU6IE5vTGFuZSxcbiAgICBhY3Rpb246IGFjdGlvbixcbiAgICBoYXNFYWdlclN0YXRlOiBmYWxzZSxcbiAgICBlYWdlclN0YXRlOiBudWxsLFxuICAgIG5leHQ6IG51bGxcbiAgfTtcblxuICBpZiAoaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikpIHtcbiAgICBlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUocXVldWUsIHVwZGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICAgIGlmIChmaWJlci5sYW5lcyA9PT0gTm9MYW5lcyAmJiAoYWx0ZXJuYXRlID09PSBudWxsIHx8IGFsdGVybmF0ZS5sYW5lcyA9PT0gTm9MYW5lcykpIHtcbiAgICAgIC8vIFRoZSBxdWV1ZSBpcyBjdXJyZW50bHkgZW1wdHksIHdoaWNoIG1lYW5zIHdlIGNhbiBlYWdlcmx5IGNvbXB1dGUgdGhlXG4gICAgICAvLyBuZXh0IHN0YXRlIGJlZm9yZSBlbnRlcmluZyB0aGUgcmVuZGVyIHBoYXNlLiBJZiB0aGUgbmV3IHN0YXRlIGlzIHRoZVxuICAgICAgLy8gc2FtZSBhcyB0aGUgY3VycmVudCBzdGF0ZSwgd2UgbWF5IGJlIGFibGUgdG8gYmFpbCBvdXQgZW50aXJlbHkuXG4gICAgICB2YXIgbGFzdFJlbmRlcmVkUmVkdWNlciA9IHF1ZXVlLmxhc3RSZW5kZXJlZFJlZHVjZXI7XG5cbiAgICAgIGlmIChsYXN0UmVuZGVyZWRSZWR1Y2VyICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IG51bGw7XG5cbiAgICAgICAge1xuICAgICAgICAgIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG4gICAgICAgIH1cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIHZhciBjdXJyZW50U3RhdGUgPSBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZTtcbiAgICAgICAgICB2YXIgZWFnZXJTdGF0ZSA9IGxhc3RSZW5kZXJlZFJlZHVjZXIoY3VycmVudFN0YXRlLCBhY3Rpb24pOyAvLyBTdGFzaCB0aGUgZWFnZXJseSBjb21wdXRlZCBzdGF0ZSwgYW5kIHRoZSByZWR1Y2VyIHVzZWQgdG8gY29tcHV0ZVxuICAgICAgICAgIC8vIGl0LCBvbiB0aGUgdXBkYXRlIG9iamVjdC4gSWYgdGhlIHJlZHVjZXIgaGFzbid0IGNoYW5nZWQgYnkgdGhlXG4gICAgICAgICAgLy8gdGltZSB3ZSBlbnRlciB0aGUgcmVuZGVyIHBoYXNlLCB0aGVuIHRoZSBlYWdlciBzdGF0ZSBjYW4gYmUgdXNlZFxuICAgICAgICAgIC8vIHdpdGhvdXQgY2FsbGluZyB0aGUgcmVkdWNlciBhZ2Fpbi5cblxuICAgICAgICAgIHVwZGF0ZS5oYXNFYWdlclN0YXRlID0gdHJ1ZTtcbiAgICAgICAgICB1cGRhdGUuZWFnZXJTdGF0ZSA9IGVhZ2VyU3RhdGU7XG5cbiAgICAgICAgICBpZiAob2JqZWN0SXMoZWFnZXJTdGF0ZSwgY3VycmVudFN0YXRlKSkge1xuICAgICAgICAgICAgLy8gRmFzdCBwYXRoLiBXZSBjYW4gYmFpbCBvdXQgd2l0aG91dCBzY2hlZHVsaW5nIFJlYWN0IHRvIHJlLXJlbmRlci5cbiAgICAgICAgICAgIC8vIEl0J3Mgc3RpbGwgcG9zc2libGUgdGhhdCB3ZSdsbCBuZWVkIHRvIHJlYmFzZSB0aGlzIHVwZGF0ZSBsYXRlcixcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjb21wb25lbnQgcmUtcmVuZGVycyBmb3IgYSBkaWZmZXJlbnQgcmVhc29uIGFuZCBieSB0aGF0XG4gICAgICAgICAgICAvLyB0aW1lIHRoZSByZWR1Y2VyIGhhcyBjaGFuZ2VkLlxuICAgICAgICAgICAgLy8gVE9ETzogRG8gd2Ugc3RpbGwgbmVlZCB0byBlbnRhbmdsZSB0cmFuc2l0aW9ucyBpbiB0aGlzIGNhc2U/XG4gICAgICAgICAgICBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGVBbmRFYWdlcmx5QmFpbG91dChmaWJlciwgcXVldWUsIHVwZGF0ZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikgey8vIFN1cHByZXNzIHRoZSBlcnJvci4gSXQgd2lsbCB0aHJvdyBhZ2FpbiBpbiB0aGUgcmVuZGVyIHBoYXNlLlxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZShmaWJlciwgcXVldWUsIHVwZGF0ZSwgbGFuZSk7XG5cbiAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBsYW5lKTtcbiAgICAgIGVudGFuZ2xlVHJhbnNpdGlvblVwZGF0ZShyb290LCBxdWV1ZSwgbGFuZSk7XG4gICAgfVxuICB9XG5cbiAgbWFya1VwZGF0ZUluRGV2VG9vbHMoZmliZXIsIGxhbmUpO1xufVxuXG5mdW5jdGlvbiBkaXNwYXRjaE9wdGltaXN0aWNTZXRTdGF0ZShmaWJlciwgdGhyb3dJZkR1cmluZ1JlbmRlciwgcXVldWUsIGFjdGlvbikge1xuICB2YXIgdHJhbnNpdGlvbiA9IHJlcXVlc3RDdXJyZW50VHJhbnNpdGlvbigpO1xuXG4gIHtcbiAgICBpZiAodHJhbnNpdGlvbiA9PT0gbnVsbCkge1xuICAgICAgLy8gQW4gb3B0aW1pc3RpYyB1cGRhdGUgb2NjdXJyZWQsIGJ1dCBzdGFydFRyYW5zaXRpb24gaXMgbm90IG9uIHRoZSBzdGFjay5cbiAgICAgIC8vIFRoZXJlIGFyZSB0d28gbGlrZWx5IHNjZW5hcmlvcy5cbiAgICAgIC8vIE9uZSBwb3NzaWJpbGl0eSBpcyB0aGF0IHRoZSBvcHRpbWlzdGljIHVwZGF0ZSBpcyB0cmlnZ2VyZWQgYnkgYSByZWd1bGFyXG4gICAgICAvLyBldmVudCBoYW5kbGVyIChlLmcuIGBvblN1Ym1pdGApIGluc3RlYWQgb2YgYW4gYWN0aW9uLiBUaGlzIGlzIGEgbWlzdGFrZVxuICAgICAgLy8gYW5kIHdlIHdpbGwgd2Fybi5cbiAgICAgIC8vIFRoZSBvdGhlciBwb3NzaWJpbGl0eSBpcyB0aGUgb3B0aW1pc3RpYyB1cGRhdGUgaXMgaW5zaWRlIGFuIGFzeW5jXG4gICAgICAvLyBhY3Rpb24sIGJ1dCBhZnRlciBhbiBgYXdhaXRgLiBJbiB0aGlzIGNhc2UsIHdlIGNhbiBtYWtlIGl0IFwianVzdCB3b3JrXCJcbiAgICAgIC8vIGJ5IGFzc29jaWF0aW5nIHRoZSBvcHRpbWlzdGljIHVwZGF0ZSB3aXRoIHRoZSBwZW5kaW5nIGFzeW5jIGFjdGlvbi5cbiAgICAgIC8vIFRlY2huaWNhbGx5IGl0J3MgcG9zc2libGUgdGhhdCB0aGUgb3B0aW1pc3RpYyB1cGRhdGUgaXMgdW5yZWxhdGVkIHRvXG4gICAgICAvLyB0aGUgcGVuZGluZyBhY3Rpb24sIGJ1dCB3ZSBkb24ndCBoYXZlIGEgd2F5IG9mIGtub3dpbmcgdGhpcyBmb3Igc3VyZVxuICAgICAgLy8gYmVjYXVzZSBicm93c2VycyBjdXJyZW50bHkgZG8gbm90IHByb3ZpZGUgYSB3YXkgdG8gdHJhY2sgYXN5bmMgc2NvcGUuXG4gICAgICAvLyAoVGhlIEFzeW5jQ29udGV4dCBwcm9wb3NhbCwgaWYgaXQgbGFuZHMsIHdpbGwgc29sdmUgdGhpcyBpbiB0aGVcbiAgICAgIC8vIGZ1dHVyZS4pIEhvd2V2ZXIsIHRoaXMgaXMgbm8gZGlmZmVyZW50IHRoYW4gdGhlIHByb2JsZW0gb2YgdW5yZWxhdGVkXG4gICAgICAvLyB0cmFuc2l0aW9ucyBiZWluZyBncm91cGVkIHRvZ2V0aGVyIOKAlCBpdCdzIG5vdCB3cm9uZyBwZXIgc2UsIGJ1dCBpdCdzXG4gICAgICAvLyBub3QgaWRlYWwuXG4gICAgICAvLyBPbmNlIEFzeW5jQ29udGV4dCBzdGFydHMgbGFuZGluZyBpbiBicm93c2Vycywgd2Ugd2lsbCBwcm92aWRlIGJldHRlclxuICAgICAgLy8gd2FybmluZ3MgaW4gZGV2ZWxvcG1lbnQgZm9yIHRoZXNlIGNhc2VzLlxuICAgICAgaWYgKHBlZWtFbnRhbmdsZWRBY3Rpb25MYW5lKCkgIT09IE5vTGFuZSkgOyBlbHNlIHtcbiAgICAgICAgLy8gVGhlcmUncyBubyBwZW5kaW5nIGFzeW5jIGFjdGlvbi4gVGhlIG1vc3QgbGlrZWx5IGNhdXNlIGlzIHRoYXQgd2UncmVcbiAgICAgICAgLy8gaW5zaWRlIGEgcmVndWxhciBldmVudCBoYW5kbGVyIChlLmcuIG9uU3VibWl0KSBpbnN0ZWFkIG9mIGFuIGFjdGlvbi5cbiAgICAgICAgZXJyb3IoJ0FuIG9wdGltaXN0aWMgc3RhdGUgdXBkYXRlIG9jY3VycmVkIG91dHNpZGUgYSB0cmFuc2l0aW9uIG9yICcgKyAnYWN0aW9uLiBUbyBmaXgsIG1vdmUgdGhlIHVwZGF0ZSB0byBhbiBhY3Rpb24sIG9yIHdyYXAgJyArICd3aXRoIHN0YXJ0VHJhbnNpdGlvbi4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlID0ge1xuICAgIC8vIEFuIG9wdGltaXN0aWMgdXBkYXRlIGNvbW1pdHMgc3luY2hyb25vdXNseS5cbiAgICBsYW5lOiBTeW5jTGFuZSxcbiAgICAvLyBBZnRlciBjb21taXR0aW5nLCB0aGUgb3B0aW1pc3RpYyB1cGRhdGUgaXMgXCJyZXZlcnRlZFwiIHVzaW5nIHRoZSBzYW1lXG4gICAgLy8gbGFuZSBhcyB0aGUgdHJhbnNpdGlvbiBpdCdzIGFzc29jaWF0ZWQgd2l0aC5cbiAgICByZXZlcnRMYW5lOiByZXF1ZXN0VHJhbnNpdGlvbkxhbmUoKSxcbiAgICBhY3Rpb246IGFjdGlvbixcbiAgICBoYXNFYWdlclN0YXRlOiBmYWxzZSxcbiAgICBlYWdlclN0YXRlOiBudWxsLFxuICAgIG5leHQ6IG51bGxcbiAgfTtcblxuICBpZiAoaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikpIHtcbiAgICAvLyBXaGVuIGNhbGxpbmcgc3RhcnRUcmFuc2l0aW9uIGR1cmluZyByZW5kZXIsIHRoaXMgd2FybnMgaW5zdGVhZCBvZlxuICAgIC8vIHRocm93aW5nIGJlY2F1c2UgdGhyb3dpbmcgd291bGQgYmUgYSBicmVha2luZyBjaGFuZ2UuIHNldE9wdGltaXN0aWNTdGF0ZVxuICAgIC8vIGlzIGEgbmV3IEFQSSBzbyBpdCdzIE9LIHRvIHRocm93LlxuICAgIGlmICh0aHJvd0lmRHVyaW5nUmVuZGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1cGRhdGUgb3B0aW1pc3RpYyBzdGF0ZSB3aGlsZSByZW5kZXJpbmcuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN0YXJ0VHJhbnNpdGlvbiB3YXMgY2FsbGVkIGR1cmluZyByZW5kZXIuIFdlIGRvbid0IG5lZWQgdG8gZG8gYW55dGhpbmdcbiAgICAgIC8vIGJlc2lkZXMgd2FybiBoZXJlIGJlY2F1c2UgdGhlIHJlbmRlciBwaGFzZSB1cGRhdGUgd291bGQgYmUgb3ZlcmlkZGVuIGJ5XG4gICAgICAvLyB0aGUgc2Vjb25kIHVwZGF0ZSwgYW55d2F5LiBXZSBjYW4gcmVtb3ZlIHRoaXMgYnJhbmNoIGFuZCBtYWtlIGl0IHRocm93XG4gICAgICAvLyBpbiBhIGZ1dHVyZSByZWxlYXNlLlxuICAgICAge1xuICAgICAgICBlcnJvcignQ2Fubm90IGNhbGwgc3RhcnRUcmFuc2l0aW9uIHdoaWxlIHJlbmRlcmluZy4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUoZmliZXIsIHF1ZXVlLCB1cGRhdGUsIFN5bmNMYW5lKTtcblxuICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICAvLyBOT1RFOiBUaGUgb3B0aW1pc3RpYyB1cGRhdGUgaW1wbGVtZW50YXRpb24gYXNzdW1lcyB0aGF0IHRoZSB0cmFuc2l0aW9uXG4gICAgICAvLyB3aWxsIG5ldmVyIGJlIGF0dGVtcHRlZCBiZWZvcmUgdGhlIG9wdGltaXN0aWMgdXBkYXRlLiBUaGlzIGN1cnJlbnRseVxuICAgICAgLy8gaG9sZHMgYmVjYXVzZSB0aGUgb3B0aW1pc3RpYyB1cGRhdGUgaXMgYWx3YXlzIHN5bmNocm9ub3VzLiBJZiB3ZSBldmVyXG4gICAgICAvLyBjaGFuZ2UgdGhhdCwgd2UnbGwgbmVlZCB0byBhY2NvdW50IGZvciB0aGlzLlxuICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBTeW5jTGFuZSk7IC8vIE9wdGltaXN0aWMgdXBkYXRlcyBhcmUgYWx3YXlzIHN5bmNocm9ub3VzLCBzbyB3ZSBkb24ndCBuZWVkIHRvIGNhbGxcbiAgICAgIC8vIGVudGFuZ2xlVHJhbnNpdGlvblVwZGF0ZSBoZXJlLlxuICAgIH1cbiAgfVxuXG4gIG1hcmtVcGRhdGVJbkRldlRvb2xzKGZpYmVyLCBTeW5jTGFuZSk7XG59XG5cbmZ1bmN0aW9uIGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpIHtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgcmV0dXJuIGZpYmVyID09PSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxIHx8IGFsdGVybmF0ZSAhPT0gbnVsbCAmJiBhbHRlcm5hdGUgPT09IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDE7XG59XG5cbmZ1bmN0aW9uIGVucXVldWVSZW5kZXJQaGFzZVVwZGF0ZShxdWV1ZSwgdXBkYXRlKSB7XG4gIC8vIFRoaXMgaXMgYSByZW5kZXIgcGhhc2UgdXBkYXRlLiBTdGFzaCBpdCBpbiBhIGxhemlseS1jcmVhdGVkIG1hcCBvZlxuICAvLyBxdWV1ZSAtPiBsaW5rZWQgbGlzdCBvZiB1cGRhdGVzLiBBZnRlciB0aGlzIHJlbmRlciBwYXNzLCB3ZSdsbCByZXN0YXJ0XG4gIC8vIGFuZCBhcHBseSB0aGUgc3Rhc2hlZCB1cGRhdGVzIG9uIHRvcCBvZiB0aGUgd29yay1pbi1wcm9ncmVzcyBob29rLlxuICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gdHJ1ZTtcbiAgdmFyIHBlbmRpbmcgPSBxdWV1ZS5wZW5kaW5nO1xuXG4gIGlmIChwZW5kaW5nID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlLiBDcmVhdGUgYSBjaXJjdWxhciBsaXN0LlxuICAgIHVwZGF0ZS5uZXh0ID0gdXBkYXRlO1xuICB9IGVsc2Uge1xuICAgIHVwZGF0ZS5uZXh0ID0gcGVuZGluZy5uZXh0O1xuICAgIHBlbmRpbmcubmV4dCA9IHVwZGF0ZTtcbiAgfVxuXG4gIHF1ZXVlLnBlbmRpbmcgPSB1cGRhdGU7XG59IC8vIFRPRE86IE1vdmUgdG8gUmVhY3RGaWJlckNvbmN1cnJlbnRVcGRhdGVzP1xuXG5cbmZ1bmN0aW9uIGVudGFuZ2xlVHJhbnNpdGlvblVwZGF0ZShyb290LCBxdWV1ZSwgbGFuZSkge1xuICBpZiAoaXNUcmFuc2l0aW9uTGFuZShsYW5lKSkge1xuICAgIHZhciBxdWV1ZUxhbmVzID0gcXVldWUubGFuZXM7IC8vIElmIGFueSBlbnRhbmdsZWQgbGFuZXMgYXJlIG5vIGxvbmdlciBwZW5kaW5nIG9uIHRoZSByb290LCB0aGVuIHRoZXlcbiAgICAvLyBtdXN0IGhhdmUgZmluaXNoZWQuIFdlIGNhbiByZW1vdmUgdGhlbSBmcm9tIHRoZSBzaGFyZWQgcXVldWUsIHdoaWNoXG4gICAgLy8gcmVwcmVzZW50cyBhIHN1cGVyc2V0IG9mIHRoZSBhY3R1YWxseSBwZW5kaW5nIGxhbmVzLiBJbiBzb21lIGNhc2VzIHdlXG4gICAgLy8gbWF5IGVudGFuZ2xlIG1vcmUgdGhhbiB3ZSBuZWVkIHRvLCBidXQgdGhhdCdzIE9LLiBJbiBmYWN0IGl0J3Mgd29yc2UgaWZcbiAgICAvLyB3ZSAqZG9uJ3QqIGVudGFuZ2xlIHdoZW4gd2Ugc2hvdWxkLlxuXG4gICAgcXVldWVMYW5lcyA9IGludGVyc2VjdExhbmVzKHF1ZXVlTGFuZXMsIHJvb3QucGVuZGluZ0xhbmVzKTsgLy8gRW50YW5nbGUgdGhlIG5ldyB0cmFuc2l0aW9uIGxhbmUgd2l0aCB0aGUgb3RoZXIgdHJhbnNpdGlvbiBsYW5lcy5cblxuICAgIHZhciBuZXdRdWV1ZUxhbmVzID0gbWVyZ2VMYW5lcyhxdWV1ZUxhbmVzLCBsYW5lKTtcbiAgICBxdWV1ZS5sYW5lcyA9IG5ld1F1ZXVlTGFuZXM7IC8vIEV2ZW4gaWYgcXVldWUubGFuZXMgYWxyZWFkeSBpbmNsdWRlIGxhbmUsIHdlIGRvbid0IGtub3cgZm9yIGNlcnRhaW4gaWZcbiAgICAvLyB0aGUgbGFuZSBmaW5pc2hlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIHdlIGVudGFuZ2xlZCBpdC4gU28gd2UgbmVlZCB0b1xuICAgIC8vIGVudGFuZ2xlIGl0IGFnYWluLCBqdXN0IHRvIGJlIHN1cmUuXG5cbiAgICBtYXJrUm9vdEVudGFuZ2xlZChyb290LCBuZXdRdWV1ZUxhbmVzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrVXBkYXRlSW5EZXZUb29scyhmaWJlciwgbGFuZSwgYWN0aW9uKSB7XG5cbiAge1xuICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSk7XG4gIH1cbn1cblxudmFyIENvbnRleHRPbmx5RGlzcGF0Y2hlciA9IHtcbiAgcmVhZENvbnRleHQ6IHJlYWRDb250ZXh0LFxuICB1c2U6IHVzZSxcbiAgdXNlQ2FsbGJhY2s6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlQ29udGV4dDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VFZmZlY3Q6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VMYXlvdXRFZmZlY3Q6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlSW5zZXJ0aW9uRWZmZWN0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZU1lbW86IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlUmVkdWNlcjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VSZWY6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlU3RhdGU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlRGVidWdWYWx1ZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VEZWZlcnJlZFZhbHVlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVRyYW5zaXRpb246IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlU3luY0V4dGVybmFsU3RvcmU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlSWQ6IHRocm93SW52YWxpZEhvb2tFcnJvclxufTtcblxue1xuICBDb250ZXh0T25seURpc3BhdGNoZXIudXNlQ2FjaGVSZWZyZXNoID0gdGhyb3dJbnZhbGlkSG9va0Vycm9yO1xufVxuXG57XG4gIENvbnRleHRPbmx5RGlzcGF0Y2hlci51c2VNZW1vQ2FjaGUgPSB0aHJvd0ludmFsaWRIb29rRXJyb3I7XG59XG5cbntcbiAgQ29udGV4dE9ubHlEaXNwYXRjaGVyLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID0gdGhyb3dJbnZhbGlkSG9va0Vycm9yO1xuICBDb250ZXh0T25seURpc3BhdGNoZXIudXNlRm9ybVN0YXRlID0gdGhyb3dJbnZhbGlkSG9va0Vycm9yO1xuICBDb250ZXh0T25seURpc3BhdGNoZXIudXNlQWN0aW9uU3RhdGUgPSB0aHJvd0ludmFsaWRIb29rRXJyb3I7XG59XG5cbntcbiAgQ29udGV4dE9ubHlEaXNwYXRjaGVyLnVzZU9wdGltaXN0aWMgPSB0aHJvd0ludmFsaWRIb29rRXJyb3I7XG59XG5cbnZhciBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSBudWxsO1xudmFyIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYgPSBudWxsO1xudmFyIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSBudWxsO1xudmFyIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IG51bGw7XG52YXIgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IG51bGw7XG52YXIgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSBudWxsO1xudmFyIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSBudWxsO1xuXG57XG4gIHZhciB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgZXJyb3IoJ0NvbnRleHQgY2FuIG9ubHkgYmUgcmVhZCB3aGlsZSBSZWFjdCBpcyByZW5kZXJpbmcuICcgKyAnSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gJyArICdJbiBmdW5jdGlvbiBjb21wb25lbnRzLCB5b3UgY2FuIHJlYWQgaXQgZGlyZWN0bHkgaW4gdGhlIGZ1bmN0aW9uIGJvZHksIGJ1dCBub3QgJyArICdpbnNpZGUgSG9va3MgbGlrZSB1c2VSZWR1Y2VyKCkgb3IgdXNlTWVtbygpLicpO1xuICB9O1xuXG4gIHZhciB3YXJuSW52YWxpZEhvb2tBY2Nlc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgZXJyb3IoJ0RvIG5vdCBjYWxsIEhvb2tzIGluc2lkZSB1c2VFZmZlY3QoLi4uKSwgdXNlTWVtbyguLi4pLCBvciBvdGhlciBidWlsdC1pbiBIb29rcy4gJyArICdZb3UgY2FuIG9ubHkgY2FsbCBIb29rcyBhdCB0aGUgdG9wIGxldmVsIG9mIHlvdXIgUmVhY3QgZnVuY3Rpb24uICcgKyAnRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZSAnICsgJ2h0dHBzOi8vcmVhY3QuZGV2L2xpbmsvcnVsZXMtb2YtaG9va3MnKTtcbiAgfTtcblxuICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2U6IHVzZSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICByZXR1cm4gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgcmV0dXJuIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgcmV0dXJuIG1vdW50SW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUluc2VydGlvbkVmZmVjdCc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICByZXR1cm4gbW91bnRJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHJldHVybiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudERlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3luY0V4dGVybmFsU3RvcmUnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgICB9LFxuICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJZCc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50SWQoKTtcbiAgICB9XG4gIH07XG5cbiAge1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VDYWNoZVJlZnJlc2ggPSBmdW5jdGlvbiB1c2VDYWNoZVJlZnJlc2goKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWNoZVJlZnJlc2gnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFJlZnJlc2goKTtcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VNZW1vQ2FjaGUgPSB1c2VNZW1vQ2FjaGU7XG4gIH1cblxuICB7XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID0gdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM7XG5cbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gdXNlRm9ybVN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUZvcm1TdGF0ZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUpO1xuICAgIH07XG5cbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlQWN0aW9uU3RhdGUgPSBmdW5jdGlvbiB1c2VBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VBY3Rpb25TdGF0ZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUpO1xuICAgIH07XG4gIH1cblxuICB7XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZU9wdGltaXN0aWMgPSBmdW5jdGlvbiB1c2VPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VPcHRpbWlzdGljJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRPcHRpbWlzdGljKHBhc3N0aHJvdWdoKTtcbiAgICB9O1xuICB9XG5cbiAgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZTogdXNlLFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50SW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUluc2VydGlvbkVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRSZWYoaW5pdGlhbFZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnREZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3luY0V4dGVybmFsU3RvcmUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG4gICAgfSxcbiAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSWQnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRJZCgpO1xuICAgIH1cbiAgfTtcblxuICB7XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFVi51c2VDYWNoZVJlZnJlc2ggPSBmdW5jdGlvbiB1c2VDYWNoZVJlZnJlc2goKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWNoZVJlZnJlc2gnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRSZWZyZXNoKCk7XG4gICAgfTtcbiAgfVxuXG4gIHtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWLnVzZU1lbW9DYWNoZSA9IHVzZU1lbW9DYWNoZTtcbiAgfVxuXG4gIHtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID0gdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM7XG5cbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWLnVzZUZvcm1TdGF0ZSA9IGZ1bmN0aW9uIHVzZUZvcm1TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VGb3JtU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB3YXJuT25Vc2VGb3JtU3RhdGVJbkRldigpO1xuICAgICAgcmV0dXJuIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUpO1xuICAgIH07XG5cbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gdXNlQWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluaykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQWN0aW9uU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSk7XG4gICAgfTtcbiAgfVxuXG4gIHtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWLnVzZU9wdGltaXN0aWMgPSBmdW5jdGlvbiB1c2VPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VPcHRpbWlzdGljJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50T3B0aW1pc3RpYyhwYXNzdGhyb3VnaCk7XG4gICAgfTtcbiAgfVxuXG4gIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2U6IHVzZSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbnNlcnRpb25FZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZigpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN5bmNFeHRlcm5hbFN0b3JlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgICB9LFxuICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJZCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJZCgpO1xuICAgIH1cbiAgfTtcblxuICB7XG4gICAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VDYWNoZVJlZnJlc2ggPSBmdW5jdGlvbiB1c2VDYWNoZVJlZnJlc2goKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWNoZVJlZnJlc2gnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVmcmVzaCgpO1xuICAgIH07XG4gIH1cblxuICB7XG4gICAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VNZW1vQ2FjaGUgPSB1c2VNZW1vQ2FjaGU7XG4gIH1cblxuICB7XG4gICAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9IHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuXG4gICAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiB1c2VGb3JtU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluaykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRm9ybVN0YXRlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgd2Fybk9uVXNlRm9ybVN0YXRlSW5EZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG5cbiAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gdXNlQWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluaykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQWN0aW9uU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQWN0aW9uU3RhdGUoYWN0aW9uKTtcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIHVzZU9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU9wdGltaXN0aWMnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG4gICAgfTtcbiAgfVxuXG4gIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZTogdXNlLFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUluc2VydGlvbkVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVmKCk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZXJlbmRlclN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG4gICAgfSxcbiAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSWQnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSWQoKTtcbiAgICB9XG4gIH07XG5cbiAge1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VDYWNoZVJlZnJlc2ggPSBmdW5jdGlvbiB1c2VDYWNoZVJlZnJlc2goKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWNoZVJlZnJlc2gnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVmcmVzaCgpO1xuICAgIH07XG4gIH1cblxuICB7XG4gICAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZU1lbW9DYWNoZSA9IHVzZU1lbW9DYWNoZTtcbiAgfVxuXG4gIHtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPSB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcblxuICAgIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiB1c2VGb3JtU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluaykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRm9ybVN0YXRlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgd2Fybk9uVXNlRm9ybVN0YXRlSW5EZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlckFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcblxuICAgIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VBY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uIHVzZUFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUFjdGlvblN0YXRlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyQWN0aW9uU3RhdGUoYWN0aW9uKTtcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gdXNlT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3B0aW1pc3RpYyc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlck9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xuICAgIH07XG4gIH1cblxuICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgd2FybkludmFsaWRDb250ZXh0QWNjZXNzKCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2U6IGZ1bmN0aW9uICh1c2FibGUpIHtcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgcmV0dXJuIHVzZSh1c2FibGUpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50Q2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50SW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUluc2VydGlvbkVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudE1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50UmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50U3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50VHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3luY0V4dGVybmFsU3RvcmUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50U3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xuICAgIH0sXG4gICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUlkJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudElkKCk7XG4gICAgfVxuICB9O1xuXG4gIHtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZUNhY2hlUmVmcmVzaCA9IGZ1bmN0aW9uIHVzZUNhY2hlUmVmcmVzaCgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhY2hlUmVmcmVzaCc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50UmVmcmVzaCgpO1xuICAgIH07XG4gIH1cblxuICB7XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VNZW1vQ2FjaGUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICByZXR1cm4gdXNlTWVtb0NhY2hlKHNpemUpO1xuICAgIH07XG4gIH1cblxuICB7XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9IHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuXG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiB1c2VGb3JtU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluaykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRm9ybVN0YXRlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlKTtcbiAgICB9O1xuXG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VBY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uIHVzZUFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUFjdGlvblN0YXRlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlKTtcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIHVzZU9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU9wdGltaXN0aWMnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50T3B0aW1pc3RpYyhwYXNzdGhyb3VnaCk7XG4gICAgfTtcbiAgfVxuXG4gIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgd2FybkludmFsaWRDb250ZXh0QWNjZXNzKCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2U6IGZ1bmN0aW9uICh1c2FibGUpIHtcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgcmV0dXJuIHVzZSh1c2FibGUpO1xuICAgIH0sXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW5zZXJ0aW9uRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbnNlcnRpb25FZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWYoKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN5bmNFeHRlcm5hbFN0b3JlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xuICAgIH0sXG4gICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUlkJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSWQoKTtcbiAgICB9XG4gIH07XG5cbiAge1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZUNhY2hlUmVmcmVzaCA9IGZ1bmN0aW9uIHVzZUNhY2hlUmVmcmVzaCgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhY2hlUmVmcmVzaCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWZyZXNoKCk7XG4gICAgfTtcbiAgfVxuXG4gIHtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VNZW1vQ2FjaGUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICByZXR1cm4gdXNlTWVtb0NhY2hlKHNpemUpO1xuICAgIH07XG4gIH1cblxuICB7XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPSB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcblxuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZUZvcm1TdGF0ZSA9IGZ1bmN0aW9uIHVzZUZvcm1TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VGb3JtU3RhdGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG5cbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VBY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uIHVzZUFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUFjdGlvblN0YXRlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQWN0aW9uU3RhdGUoYWN0aW9uKTtcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZU9wdGltaXN0aWMgPSBmdW5jdGlvbiB1c2VPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VPcHRpbWlzdGljJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG4gICAgfTtcbiAgfVxuXG4gIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZTogZnVuY3Rpb24gKHVzYWJsZSkge1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICByZXR1cm4gdXNlKHVzYWJsZSk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUluc2VydGlvbkVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVmKCk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZXJlbmRlclN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VEZWJ1Z1ZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGZvcm1hdHRlckZuKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWJ1Z1ZhbHVlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlckRlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgICB9LFxuICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJZCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUlkKCk7XG4gICAgfVxuICB9O1xuXG4gIHtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZUNhY2hlUmVmcmVzaCA9IGZ1bmN0aW9uIHVzZUNhY2hlUmVmcmVzaCgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhY2hlUmVmcmVzaCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWZyZXNoKCk7XG4gICAgfTtcbiAgfVxuXG4gIHtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZU1lbW9DYWNoZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHJldHVybiB1c2VNZW1vQ2FjaGUoc2l6ZSk7XG4gICAgfTtcbiAgfVxuXG4gIHtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID0gdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM7XG5cbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZUZvcm1TdGF0ZSA9IGZ1bmN0aW9uIHVzZUZvcm1TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VGb3JtU3RhdGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlckFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcblxuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlQWN0aW9uU3RhdGUgPSBmdW5jdGlvbiB1c2VBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VBY3Rpb25TdGF0ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyQWN0aW9uU3RhdGUoYWN0aW9uKTtcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIHVzZU9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU9wdGltaXN0aWMnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlck9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpO1xuICAgIH07XG4gIH1cbn1cblxudmFyIG5vdyA9IFNjaGVkdWxlci51bnN0YWJsZV9ub3c7XG52YXIgY29tbWl0VGltZSA9IDA7XG52YXIgbGF5b3V0RWZmZWN0U3RhcnRUaW1lID0gLTE7XG52YXIgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcbnZhciBwYXNzaXZlRWZmZWN0U3RhcnRUaW1lID0gLTE7XG4vKipcbiAqIFRyYWNrcyB3aGV0aGVyIHRoZSBjdXJyZW50IHVwZGF0ZSB3YXMgYSBuZXN0ZWQvY2FzY2FkaW5nIHVwZGF0ZSAoc2NoZWR1bGVkIGZyb20gYSBsYXlvdXQgZWZmZWN0KS5cbiAqXG4gKiBUaGUgb3ZlcmFsbCBzZXF1ZW5jZSBpczpcbiAqICAgMS4gcmVuZGVyXG4gKiAgIDIuIGNvbW1pdCAoYW5kIGNhbGwgYG9uUmVuZGVyYCwgYG9uQ29tbWl0YClcbiAqICAgMy4gY2hlY2sgZm9yIG5lc3RlZCB1cGRhdGVzXG4gKiAgIDQuIGZsdXNoIHBhc3NpdmUgZWZmZWN0cyAoYW5kIGNhbGwgYG9uUG9zdENvbW1pdGApXG4gKlxuICogTmVzdGVkIHVwZGF0ZXMgYXJlIGlkZW50aWZpZWQgaW4gc3RlcCAzIGFib3ZlLFxuICogYnV0IHN0ZXAgNCBzdGlsbCBhcHBsaWVzIHRvIHRoZSB3b3JrIHRoYXQgd2FzIGp1c3QgY29tbWl0dGVkLlxuICogV2UgdXNlIHR3byBmbGFncyB0byB0cmFjayBuZXN0ZWQgdXBkYXRlcyB0aGVuOlxuICogb25lIHRyYWNrcyB3aGV0aGVyIHRoZSB1cGNvbWluZyB1cGRhdGUgaXMgYSBuZXN0ZWQgdXBkYXRlLFxuICogYW5kIHRoZSBvdGhlciB0cmFja3Mgd2hldGhlciB0aGUgY3VycmVudCB1cGRhdGUgd2FzIGEgbmVzdGVkIHVwZGF0ZS5cbiAqIFRoZSBmaXJzdCB2YWx1ZSBnZXRzIHN5bmNlZCB0byB0aGUgc2Vjb25kIGF0IHRoZSBzdGFydCBvZiB0aGUgcmVuZGVyIHBoYXNlLlxuICovXG5cbnZhciBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgPSBmYWxzZTtcbnZhciBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcblxuZnVuY3Rpb24gaXNDdXJyZW50VXBkYXRlTmVzdGVkKCkge1xuICByZXR1cm4gY3VycmVudFVwZGF0ZUlzTmVzdGVkO1xufVxuXG5mdW5jdGlvbiBtYXJrTmVzdGVkVXBkYXRlU2NoZWR1bGVkKCkge1xuICB7XG4gICAgbmVzdGVkVXBkYXRlU2NoZWR1bGVkID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldE5lc3RlZFVwZGF0ZUZsYWcoKSB7XG4gIHtcbiAgICBjdXJyZW50VXBkYXRlSXNOZXN0ZWQgPSBmYWxzZTtcbiAgICBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzeW5jTmVzdGVkVXBkYXRlRmxhZygpIHtcbiAge1xuICAgIGN1cnJlbnRVcGRhdGVJc05lc3RlZCA9IG5lc3RlZFVwZGF0ZVNjaGVkdWxlZDtcbiAgICBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRDb21taXRUaW1lKCkge1xuICByZXR1cm4gY29tbWl0VGltZTtcbn1cblxuZnVuY3Rpb24gcmVjb3JkQ29tbWl0VGltZSgpIHtcblxuICBjb21taXRUaW1lID0gbm93KCk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0UHJvZmlsZXJUaW1lcihmaWJlcikge1xuXG4gIHByb2ZpbGVyU3RhcnRUaW1lID0gbm93KCk7XG5cbiAgaWYgKGZpYmVyLmFjdHVhbFN0YXJ0VGltZSA8IDApIHtcbiAgICBmaWJlci5hY3R1YWxTdGFydFRpbWUgPSBub3coKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZyhmaWJlcikge1xuXG4gIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG59XG5cbmZ1bmN0aW9uIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEoZmliZXIsIG92ZXJyaWRlQmFzZVRpbWUpIHtcblxuICBpZiAocHJvZmlsZXJTdGFydFRpbWUgPj0gMCkge1xuICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdygpIC0gcHJvZmlsZXJTdGFydFRpbWU7XG4gICAgZmliZXIuYWN0dWFsRHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG5cbiAgICBpZiAob3ZlcnJpZGVCYXNlVGltZSkge1xuICAgICAgZmliZXIuc2VsZkJhc2VEdXJhdGlvbiA9IGVsYXBzZWRUaW1lO1xuICAgIH1cblxuICAgIHByb2ZpbGVyU3RhcnRUaW1lID0gLTE7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oZmliZXIpIHtcblxuICBpZiAobGF5b3V0RWZmZWN0U3RhcnRUaW1lID49IDApIHtcbiAgICB2YXIgZWxhcHNlZFRpbWUgPSBub3coKSAtIGxheW91dEVmZmVjdFN0YXJ0VGltZTtcbiAgICBsYXlvdXRFZmZlY3RTdGFydFRpbWUgPSAtMTsgLy8gU3RvcmUgZHVyYXRpb24gb24gdGhlIG5leHQgbmVhcmVzdCBQcm9maWxlciBhbmNlc3RvclxuICAgIC8vIE9yIHRoZSByb290IChmb3IgdGhlIERldlRvb2xzIFByb2ZpbGVyIHRvIHJlYWQpXG5cbiAgICB2YXIgcGFyZW50RmliZXIgPSBmaWJlci5yZXR1cm47XG5cbiAgICB3aGlsZSAocGFyZW50RmliZXIgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgdmFyIHJvb3QgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgcm9vdC5lZmZlY3REdXJhdGlvbiArPSBlbGFwc2VkVGltZTtcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgY2FzZSBQcm9maWxlcjpcbiAgICAgICAgICB2YXIgcGFyZW50U3RhdGVOb2RlID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgIHBhcmVudFN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiArPSBlbGFwc2VkVGltZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIucmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRQYXNzaXZlRWZmZWN0RHVyYXRpb24oZmliZXIpIHtcblxuICBpZiAocGFzc2l2ZUVmZmVjdFN0YXJ0VGltZSA+PSAwKSB7XG4gICAgdmFyIGVsYXBzZWRUaW1lID0gbm93KCkgLSBwYXNzaXZlRWZmZWN0U3RhcnRUaW1lO1xuICAgIHBhc3NpdmVFZmZlY3RTdGFydFRpbWUgPSAtMTsgLy8gU3RvcmUgZHVyYXRpb24gb24gdGhlIG5leHQgbmVhcmVzdCBQcm9maWxlciBhbmNlc3RvclxuICAgIC8vIE9yIHRoZSByb290IChmb3IgdGhlIERldlRvb2xzIFByb2ZpbGVyIHRvIHJlYWQpXG5cbiAgICB2YXIgcGFyZW50RmliZXIgPSBmaWJlci5yZXR1cm47XG5cbiAgICB3aGlsZSAocGFyZW50RmliZXIgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgdmFyIHJvb3QgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcm9vdC5wYXNzaXZlRWZmZWN0RHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgICAgdmFyIHBhcmVudFN0YXRlTm9kZSA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgICAgIGlmIChwYXJlbnRTdGF0ZU5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIERldGFjaGVkIGZpYmVycyBoYXZlIHRoZWlyIHN0YXRlIG5vZGUgY2xlYXJlZCBvdXQuXG4gICAgICAgICAgICAvLyBJbiB0aGlzIGNhc2UsIHRoZSByZXR1cm4gcG9pbnRlciBpcyBhbHNvIGNsZWFyZWQgb3V0LFxuICAgICAgICAgICAgLy8gc28gd2Ugd29uJ3QgYmUgYWJsZSB0byByZXBvcnQgdGhlIHRpbWUgc3BlbnQgaW4gdGhpcyBQcm9maWxlcidzIHN1YnRyZWUuXG4gICAgICAgICAgICBwYXJlbnRTdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9IGVsYXBzZWRUaW1lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5yZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKSB7XG5cbiAgbGF5b3V0RWZmZWN0U3RhcnRUaW1lID0gbm93KCk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0UGFzc2l2ZUVmZmVjdFRpbWVyKCkge1xuXG4gIHBhc3NpdmVFZmZlY3RTdGFydFRpbWUgPSBub3coKTtcbn1cblxuZnVuY3Rpb24gdHJhbnNmZXJBY3R1YWxEdXJhdGlvbihmaWJlcikge1xuICAvLyBUcmFuc2ZlciB0aW1lIHNwZW50IHJlbmRlcmluZyB0aGVzZSBjaGlsZHJlbiBzbyB3ZSBkb24ndCBsb3NlIGl0XG4gIC8vIGFmdGVyIHdlIHJlcmVuZGVyLiBUaGlzIGlzIHVzZWQgYXMgYSBoZWxwZXIgaW4gc3BlY2lhbCBjYXNlc1xuICAvLyB3aGVyZSB3ZSBzaG91bGQgY291bnQgdGhlIHdvcmsgb2YgbXVsdGlwbGUgcGFzc2VzLlxuICB2YXIgY2hpbGQgPSBmaWJlci5jaGlsZDtcblxuICB3aGlsZSAoY2hpbGQpIHtcbiAgICAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hZGRpdGlvbl0gYWRkaXRpb24gd2l0aCBwb3NzaWJsZSBudWxsL3VuZGVmaW5lZCB2YWx1ZVxuICAgIGZpYmVyLmFjdHVhbER1cmF0aW9uICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uO1xuICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgfVxufVxuXG52YXIgZmFrZUludGVybmFsSW5zdGFuY2UgPSB7fTtcbnZhciBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQ7XG52YXIgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlO1xudmFyIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZTtcbnZhciBkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlO1xudmFyIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZTtcbnZhciBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZTtcbnZhciBkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGU7XG52YXIgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrO1xuXG57XG4gIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrID0gbmV3IFNldCgpOyAvLyBUaGlzIGlzIHNvIGdyb3NzIGJ1dCBpdCdzIGF0IGxlYXN0IG5vbi1jcml0aWNhbCBhbmQgY2FuIGJlIHJlbW92ZWQgaWZcbiAgLy8gaXQgY2F1c2VzIHByb2JsZW1zLiBUaGlzIGlzIG1lYW50IHRvIGdpdmUgYSBuaWNlciBlcnJvciBtZXNzYWdlIGZvclxuICAvLyBSZWFjdERPTTE1LnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHJlYWN0RE9NMTZDb21wb25lbnQsXG4gIC8vIC4uLikpIHdoaWNoIG90aGVyd2lzZSB0aHJvd3MgYSBcIl9wcm9jZXNzQ2hpbGRDb250ZXh0IGlzIG5vdCBhIGZ1bmN0aW9uXCJcbiAgLy8gZXhjZXB0aW9uLlxuXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmYWtlSW50ZXJuYWxJbnN0YW5jZSwgJ19wcm9jZXNzQ2hpbGRDb250ZXh0Jywge1xuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ19wcm9jZXNzQ2hpbGRDb250ZXh0IGlzIG5vdCBhdmFpbGFibGUgaW4gUmVhY3QgMTYrLiBUaGlzIGxpa2VseSAnICsgJ21lYW5zIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBhbmQgYXJlIGF0dGVtcHRpbmcgdG8gbmVzdCAnICsgJ2EgUmVhY3QgMTUgdHJlZSBpbnNpZGUgYSBSZWFjdCAxNiB0cmVlIHVzaW5nICcgKyBcInVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyLCB3aGljaCBpc24ndCBzdXBwb3J0ZWQuIFRyeSBcIiArICd0byBtYWtlIHN1cmUgeW91IGhhdmUgb25seSBvbmUgY29weSBvZiBSZWFjdCAoYW5kIGlkZWFsbHksIHN3aXRjaCAnICsgJ3RvIFJlYWN0RE9NLmNyZWF0ZVBvcnRhbCkuJyk7XG4gICAgfVxuICB9KTtcbiAgT2JqZWN0LmZyZWV6ZShmYWtlSW50ZXJuYWxJbnN0YW5jZSk7XG59XG5cbmZ1bmN0aW9uIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjaykge1xuICB7XG4gICAgaWYgKGNhbGxiYWNrID09PSBudWxsIHx8IHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cblxuICAgIHZhciBrZXkgPSBTdHJpbmcoY2FsbGJhY2spO1xuXG4gICAgaWYgKCFkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2suaGFzKGtleSkpIHtcbiAgICAgIGRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5hZGQoa2V5KTtcblxuICAgICAgZXJyb3IoJ0V4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjYWxsYmFjayk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5PblVuZGVmaW5lZERlcml2ZWRTdGF0ZSh0eXBlLCBwYXJ0aWFsU3RhdGUpIHtcbiAge1xuICAgIGlmIChwYXJ0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSkgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlLmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGVycm9yKCclcy5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKTogQSB2YWxpZCBzdGF0ZSBvYmplY3QgKG9yIG51bGwpIG11c3QgYmUgcmV0dXJuZWQuICcgKyAnWW91IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLicsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyh3b3JrSW5Qcm9ncmVzcywgY3RvciwgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLCBuZXh0UHJvcHMpIHtcbiAgdmFyIHByZXZTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIHZhciBwYXJ0aWFsU3RhdGUgPSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuXG4gIHtcbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICB0cnkge1xuICAgICAgICAvLyBJbnZva2UgdGhlIGZ1bmN0aW9uIGFuIGV4dHJhIHRpbWUgdG8gaGVscCBkZXRlY3Qgc2lkZS1lZmZlY3RzLlxuICAgICAgICBwYXJ0aWFsU3RhdGUgPSBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMobmV4dFByb3BzLCBwcmV2U3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdhcm5PblVuZGVmaW5lZERlcml2ZWRTdGF0ZShjdG9yLCBwYXJ0aWFsU3RhdGUpO1xuICB9IC8vIE1lcmdlIHRoZSBwYXJ0aWFsIHN0YXRlIGFuZCB0aGUgcHJldmlvdXMgc3RhdGUuXG5cblxuICB2YXIgbWVtb2l6ZWRTdGF0ZSA9IHBhcnRpYWxTdGF0ZSA9PT0gbnVsbCB8fCBwYXJ0aWFsU3RhdGUgPT09IHVuZGVmaW5lZCA/IHByZXZTdGF0ZSA6IGFzc2lnbih7fSwgcHJldlN0YXRlLCBwYXJ0aWFsU3RhdGUpO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbWVtb2l6ZWRTdGF0ZTsgLy8gT25jZSB0aGUgdXBkYXRlIHF1ZXVlIGlzIGVtcHR5LCBwZXJzaXN0IHRoZSBkZXJpdmVkIHN0YXRlIG9udG8gdGhlXG4gIC8vIGJhc2Ugc3RhdGUuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzLmxhbmVzID09PSBOb0xhbmVzKSB7XG4gICAgLy8gUXVldWUgaXMgYWx3YXlzIG5vbi1udWxsIGZvciBjbGFzc2VzXG4gICAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgdXBkYXRlUXVldWUuYmFzZVN0YXRlID0gbWVtb2l6ZWRTdGF0ZTtcbiAgfVxufVxuXG52YXIgY2xhc3NDb21wb25lbnRVcGRhdGVyID0ge1xuICBpc01vdW50ZWQ6IGlzTW91bnRlZCxcbiAgLy8gJEZsb3dGaXhNZVttaXNzaW5nLWxvY2FsLWFubm90XVxuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBmaWJlciA9IGdldChpbnN0KTtcbiAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICAgIHVwZGF0ZS5wYXlsb2FkID0gcGF5bG9hZDtcblxuICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIHZhciByb290ID0gZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlLCBsYW5lKTtcblxuICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIGxhbmUpO1xuICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhyb290LCBmaWJlciwgbGFuZSk7XG4gICAgfVxuXG4gICAge1xuICAgICAgbWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCBsYW5lKTtcbiAgICB9XG4gIH0sXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChpbnN0LCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciBmaWJlciA9IGdldChpbnN0KTtcbiAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICAgIHVwZGF0ZS50YWcgPSBSZXBsYWNlU3RhdGU7XG4gICAgdXBkYXRlLnBheWxvYWQgPSBwYXlsb2FkO1xuXG4gICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUsIGxhbmUpO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgbGFuZSk7XG4gICAgICBlbnRhbmdsZVRyYW5zaXRpb25zKHJvb3QsIGZpYmVyLCBsYW5lKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpO1xuICAgIH1cbiAgfSxcbiAgLy8gJEZsb3dGaXhNZVttaXNzaW5nLWxvY2FsLWFubm90XVxuICBlbnF1ZXVlRm9yY2VVcGRhdGU6IGZ1bmN0aW9uIChpbnN0LCBjYWxsYmFjaykge1xuICAgIHZhciBmaWJlciA9IGdldChpbnN0KTtcbiAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGZpYmVyKTtcbiAgICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICAgIHVwZGF0ZS50YWcgPSBGb3JjZVVwZGF0ZTtcblxuICAgIGlmIChjYWxsYmFjayAhPT0gdW5kZWZpbmVkICYmIGNhbGxiYWNrICE9PSBudWxsKSB7XG4gICAgICB7XG4gICAgICAgIHdhcm5PbkludmFsaWRDYWxsYmFjayhjYWxsYmFjayk7XG4gICAgICB9XG5cbiAgICAgIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgIH1cblxuICAgIHZhciByb290ID0gZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlLCBsYW5lKTtcblxuICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIGxhbmUpO1xuICAgICAgZW50YW5nbGVUcmFuc2l0aW9ucyhyb290LCBmaWJlciwgbGFuZSk7XG4gICAgfVxuXG4gICAge1xuICAgICAgbWFya0ZvcmNlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCBsYW5lKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHNob3VsZFVwZGF0ZSA9IGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZShuZXdQcm9wcywgbmV3U3RhdGUsIG5leHRDb250ZXh0KTtcblxuICAgIHtcbiAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIEludm9rZSB0aGUgZnVuY3Rpb24gYW4gZXh0cmEgdGltZSB0byBoZWxwIGRldGVjdCBzaWRlLWVmZmVjdHMuXG4gICAgICAgICAgc2hvdWxkVXBkYXRlID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoc2hvdWxkVXBkYXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZXJyb3IoJyVzLnNob3VsZENvbXBvbmVudFVwZGF0ZSgpOiBSZXR1cm5lZCB1bmRlZmluZWQgaW5zdGVhZCBvZiBhICcgKyAnYm9vbGVhbiB2YWx1ZS4gTWFrZSBzdXJlIHRvIHJldHVybiB0cnVlIG9yIGZhbHNlLicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbiAgfVxuXG4gIGlmIChjdG9yLnByb3RvdHlwZSAmJiBjdG9yLnByb3RvdHlwZS5pc1B1cmVSZWFjdENvbXBvbmVudCkge1xuICAgIHJldHVybiAhc2hhbGxvd0VxdWFsKG9sZFByb3BzLCBuZXdQcm9wcykgfHwgIXNoYWxsb3dFcXVhbChvbGRTdGF0ZSwgbmV3U3RhdGUpO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNoZWNrQ2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gIHtcbiAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JztcbiAgICB2YXIgcmVuZGVyUHJlc2VudCA9IGluc3RhbmNlLnJlbmRlcjtcblxuICAgIGlmICghcmVuZGVyUHJlc2VudCkge1xuICAgICAgaWYgKGN0b3IucHJvdG90eXBlICYmIHR5cGVvZiBjdG9yLnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3IoJ05vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgJXMgJyArICdpbnN0YW5jZTogZGlkIHlvdSBhY2NpZGVudGFsbHkgcmV0dXJuIGFuIG9iamVjdCBmcm9tIHRoZSBjb25zdHJ1Y3Rvcj8nLCBuYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCdObyBgcmVuZGVyYCBtZXRob2QgZm91bmQgb24gdGhlICVzICcgKyAnaW5zdGFuY2U6IHlvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gZGVmaW5lIGByZW5kZXJgLicsIG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5nZXRJbml0aWFsU3RhdGUgJiYgIWluc3RhbmNlLmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCAmJiAhaW5zdGFuY2Uuc3RhdGUpIHtcbiAgICAgIGVycm9yKCdnZXRJbml0aWFsU3RhdGUgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnRGlkIHlvdSBtZWFuIHRvIGRlZmluZSBhIHN0YXRlIHByb3BlcnR5IGluc3RlYWQ/JywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmdldERlZmF1bHRQcm9wcyAmJiAhaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIHdhcyBkZWZpbmVkIG9uICVzLCBhIHBsYWluIEphdmFTY3JpcHQgY2xhc3MuICcgKyAnVGhpcyBpcyBvbmx5IHN1cHBvcnRlZCBmb3IgY2xhc3NlcyBjcmVhdGVkIHVzaW5nIFJlYWN0LmNyZWF0ZUNsYXNzLiAnICsgJ1VzZSBhIHN0YXRpYyBwcm9wZXJ0eSB0byBkZWZpbmUgZGVmYXVsdFByb3BzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLnByb3BUeXBlcykge1xuICAgICAgZXJyb3IoJ3Byb3BUeXBlcyB3YXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcy4gVXNlIGEgc3RhdGljICcgKyAncHJvcGVydHkgdG8gZGVmaW5lIHByb3BUeXBlcyBpbnN0ZWFkLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5jb250ZXh0VHlwZSkge1xuICAgICAgZXJyb3IoJ2NvbnRleHRUeXBlIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgY29udGV4dFR5cGUgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAoY3Rvci5jaGlsZENvbnRleHRUeXBlcykge1xuICAgICAgICBlcnJvcignJXMgdXNlcyB0aGUgbGVnYWN5IGNoaWxkQ29udGV4dFR5cGVzIEFQSSB3aGljaCB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gJyArICdVc2UgUmVhY3QuY3JlYXRlQ29udGV4dCgpIGluc3RlYWQuJywgbmFtZSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjdG9yLmNvbnRleHRUeXBlcykge1xuICAgICAgICBlcnJvcignJXMgdXNlcyB0aGUgbGVnYWN5IGNvbnRleHRUeXBlcyBBUEkgd2hpY2ggd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuICcgKyAnVXNlIFJlYWN0LmNyZWF0ZUNvbnRleHQoKSB3aXRoIHN0YXRpYyBjb250ZXh0VHlwZSBpbnN0ZWFkLicsIG5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50U2hvdWxkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFNob3VsZFVwZGF0ZSgpLiBEaWQgeW91IG1lYW4gc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk/ICcgKyAnVGhlIG5hbWUgaXMgcGhyYXNlZCBhcyBhIHF1ZXN0aW9uIGJlY2F1c2UgdGhlIGZ1bmN0aW9uIGlzICcgKyAnZXhwZWN0ZWQgdG8gcmV0dXJuIGEgdmFsdWUuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGN0b3IucHJvdG90eXBlICYmIGN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50ICYmIHR5cGVvZiBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCBzaG91bGRDb21wb25lbnRVcGRhdGUoKS4gJyArICdzaG91bGRDb21wb25lbnRVcGRhdGUgc2hvdWxkIG5vdCBiZSB1c2VkIHdoZW4gZXh0ZW5kaW5nIFJlYWN0LlB1cmVDb21wb25lbnQuICcgKyAnUGxlYXNlIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIGlzIHVzZWQuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdBIHB1cmUgY29tcG9uZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFVubW91bnQoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdEaWQgeW91IG1lYW4gY29tcG9uZW50V2lsbFVubW91bnQoKT8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRSZWNlaXZlUHJvcHMoKS4gQnV0IHRoZXJlIGlzIG5vIHN1Y2ggbGlmZWN5Y2xlIG1ldGhvZC4gJyArICdJZiB5b3UgbWVhbnQgdG8gdXBkYXRlIHRoZSBzdGF0ZSBpbiByZXNwb25zZSB0byBjaGFuZ2luZyBwcm9wcywgJyArICd1c2UgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpLiBJZiB5b3UgbWVhbnQgdG8gZmV0Y2ggZGF0YSBvciAnICsgJ3J1biBzaWRlLWVmZmVjdHMgb3IgbXV0YXRpb25zIGFmdGVyIFJlYWN0IGhhcyB1cGRhdGVkIHRoZSBVSSwgdXNlIGNvbXBvbmVudERpZFVwZGF0ZSgpLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk/JywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcygpLiBEaWQgeW91IG1lYW4gVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgaGFzTXV0YXRlZFByb3BzID0gaW5zdGFuY2UucHJvcHMgIT09IG5ld1Byb3BzO1xuXG4gICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSB1bmRlZmluZWQgJiYgaGFzTXV0YXRlZFByb3BzKSB7XG4gICAgICBlcnJvcignV2hlbiBjYWxsaW5nIHN1cGVyKCkgaW4gYCVzYCwgbWFrZSBzdXJlIHRvIHBhc3MgJyArIFwidXAgdGhlIHNhbWUgcHJvcHMgdGhhdCB5b3VyIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIHdhcyBwYXNzZWQuXCIsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmIChpbnN0YW5jZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIGVycm9yKCdTZXR0aW5nIGRlZmF1bHRQcm9wcyBhcyBhbiBpbnN0YW5jZSBwcm9wZXJ0eSBvbiAlcyBpcyBub3Qgc3VwcG9ydGVkIGFuZCB3aWxsIGJlIGlnbm9yZWQuJyArICcgSW5zdGVhZCwgZGVmaW5lIGRlZmF1bHRQcm9wcyBhcyBhIHN0YXRpYyBwcm9wZXJ0eSBvbiAlcy4nLCBuYW1lLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgIT09ICdmdW5jdGlvbicgJiYgIWRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5oYXMoY3RvcikpIHtcbiAgICAgIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZS5hZGQoY3Rvcik7XG5cbiAgICAgIGVycm9yKCclczogZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBzaG91bGQgYmUgdXNlZCB3aXRoIGNvbXBvbmVudERpZFVwZGF0ZSgpLiAnICsgJ1RoaXMgY29tcG9uZW50IGRlZmluZXMgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUoKSBvbmx5LicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclczogZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCkgaXMgZGVmaW5lZCBhcyBhbiBpbnN0YW5jZSBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGEgc3RhdGljIG1ldGhvZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzOiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAnICsgJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgY3Rvci5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIGlzIGRlZmluZWQgYXMgYSBzdGF0aWMgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhbiBpbnN0YW5jZSBtZXRob2QuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgdmFyIHN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG5cbiAgICBpZiAoc3RhdGUgJiYgKHR5cGVvZiBzdGF0ZSAhPT0gJ29iamVjdCcgfHwgaXNBcnJheShzdGF0ZSkpKSB7XG4gICAgICBlcnJvcignJXMuc3RhdGU6IG11c3QgYmUgc2V0IHRvIGFuIG9iamVjdCBvciBudWxsJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRDaGlsZENvbnRleHQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGN0b3IuY2hpbGRDb250ZXh0VHlwZXMgIT09ICdvYmplY3QnKSB7XG4gICAgICBlcnJvcignJXMuZ2V0Q2hpbGRDb250ZXh0KCk6IGNoaWxkQ29udGV4dFR5cGVzIG11c3QgYmUgZGVmaW5lZCBpbiBvcmRlciB0byAnICsgJ3VzZSBnZXRDaGlsZENvbnRleHQoKS4nLCBuYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgcHJvcHMpIHtcbiAgdmFyIGNvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG4gIHZhciBjb250ZXh0VHlwZSA9IGN0b3IuY29udGV4dFR5cGU7XG5cbiAge1xuICAgIGlmICgnY29udGV4dFR5cGUnIGluIGN0b3IpIHtcbiAgICAgIHZhciBpc1ZhbGlkID0gLy8gQWxsb3cgbnVsbCBmb3IgY29uZGl0aW9uYWwgZGVjbGFyYXRpb25cbiAgICAgIGNvbnRleHRUeXBlID09PSBudWxsIHx8IGNvbnRleHRUeXBlICE9PSB1bmRlZmluZWQgJiYgY29udGV4dFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRTtcblxuICAgICAgaWYgKCFpc1ZhbGlkICYmICFkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUuaGFzKGN0b3IpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5hZGQoY3Rvcik7XG4gICAgICAgIHZhciBhZGRlbmR1bSA9ICcnO1xuXG4gICAgICAgIGlmIChjb250ZXh0VHlwZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIEhvd2V2ZXIsIGl0IGlzIHNldCB0byB1bmRlZmluZWQuICcgKyAnVGhpcyBjYW4gYmUgY2F1c2VkIGJ5IGEgdHlwbyBvciBieSBtaXhpbmcgdXAgbmFtZWQgYW5kIGRlZmF1bHQgaW1wb3J0cy4gJyArICdUaGlzIGNhbiBhbHNvIGhhcHBlbiBkdWUgdG8gYSBjaXJjdWxhciBkZXBlbmRlbmN5LCBzbyAnICsgJ3RyeSBtb3ZpbmcgdGhlIGNyZWF0ZUNvbnRleHQoKSBjYWxsIHRvIGEgc2VwYXJhdGUgZmlsZS4nO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGEgJyArIHR5cGVvZiBjb250ZXh0VHlwZSArICcuJztcbiAgICAgICAgfSBlbHNlIGlmIChjb250ZXh0VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OU1VNRVJfVFlQRSkge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBwYXNzIHRoZSBDb250ZXh0LkNvbnN1bWVyIGluc3RlYWQ/JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIGFuIG9iamVjdCB3aXRoIGtleXMgeycgKyBPYmplY3Qua2V5cyhjb250ZXh0VHlwZSkuam9pbignLCAnKSArICd9Lic7XG4gICAgICAgIH1cblxuICAgICAgICBlcnJvcignJXMgZGVmaW5lcyBhbiBpbnZhbGlkIGNvbnRleHRUeXBlLiAnICsgJ2NvbnRleHRUeXBlIHNob3VsZCBwb2ludCB0byB0aGUgQ29udGV4dCBvYmplY3QgcmV0dXJuZWQgYnkgUmVhY3QuY3JlYXRlQ29udGV4dCgpLiVzJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnLCBhZGRlbmR1bSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICBjb250ZXh0ID0gcmVhZENvbnRleHQoY29udGV4dFR5cGUpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlID0gbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpOyAvLyBJbnN0YW50aWF0ZSB0d2ljZSB0byBoZWxwIGRldGVjdCBzaWRlLWVmZmVjdHMuXG5cbiAge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGluc3RhbmNlID0gbmV3IGN0b3IocHJvcHMsIGNvbnRleHQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5ld1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBzdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSAhPT0gbnVsbCAmJiBpbnN0YW5jZS5zdGF0ZSAhPT0gdW5kZWZpbmVkID8gaW5zdGFuY2Uuc3RhdGUgOiBudWxsO1xuICBpbnN0YW5jZS51cGRhdGVyID0gY2xhc3NDb21wb25lbnRVcGRhdGVyO1xuICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBpbnN0YW5jZTsgLy8gVGhlIGluc3RhbmNlIG5lZWRzIGFjY2VzcyB0byB0aGUgZmliZXIgc28gdGhhdCBpdCBjYW4gc2NoZWR1bGUgdXBkYXRlc1xuXG4gIHNldChpbnN0YW5jZSwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gIHtcbiAgICBpbnN0YW5jZS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gZmFrZUludGVybmFsSW5zdGFuY2U7XG4gIH1cblxuICB7XG4gICAgaWYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiBzdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlLmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGVycm9yKCdgJXNgIHVzZXMgYGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wc2AgYnV0IGl0cyBpbml0aWFsIHN0YXRlIGlzICcgKyAnJXMuIFRoaXMgaXMgbm90IHJlY29tbWVuZGVkLiBJbnN0ZWFkLCBkZWZpbmUgdGhlIGluaXRpYWwgc3RhdGUgYnkgJyArICdhc3NpZ25pbmcgYW4gb2JqZWN0IHRvIGB0aGlzLnN0YXRlYCBpbiB0aGUgY29uc3RydWN0b3Igb2YgYCVzYC4gJyArICdUaGlzIGVuc3VyZXMgdGhhdCBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBhcmd1bWVudHMgaGF2ZSBhIGNvbnNpc3RlbnQgc2hhcGUuJywgY29tcG9uZW50TmFtZSwgaW5zdGFuY2Uuc3RhdGUgPT09IG51bGwgPyAnbnVsbCcgOiAndW5kZWZpbmVkJywgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfSAvLyBJZiBuZXcgY29tcG9uZW50IEFQSXMgYXJlIGRlZmluZWQsIFwidW5zYWZlXCIgbGlmZWN5Y2xlcyB3b24ndCBiZSBjYWxsZWQuXG4gICAgLy8gV2FybiBhYm91dCB0aGVzZSBsaWZlY3ljbGVzIGlmIHRoZXkgYXJlIHByZXNlbnQuXG4gICAgLy8gRG9uJ3Qgd2FybiBhYm91dCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIG1ldGhvZHMgdGhvdWdoLlxuXG5cbiAgICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIGZvdW5kV2lsbE1vdW50TmFtZSA9IG51bGw7XG4gICAgICB2YXIgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9IG51bGw7XG4gICAgICB2YXIgZm91bmRXaWxsVXBkYXRlTmFtZSA9IG51bGw7XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICAgIGZvdW5kV2lsbE1vdW50TmFtZSA9ICdjb21wb25lbnRXaWxsTW91bnQnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3VuZFdpbGxNb3VudE5hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9ICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZS5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSAnY29tcG9uZW50V2lsbFVwZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBmb3VuZFdpbGxVcGRhdGVOYW1lID0gJ1VOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlJztcbiAgICAgIH1cblxuICAgICAgaWYgKGZvdW5kV2lsbE1vdW50TmFtZSAhPT0gbnVsbCB8fCBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lICE9PSBudWxsIHx8IGZvdW5kV2lsbFVwZGF0ZU5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIF9jb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICAgIHZhciBuZXdBcGlOYW1lID0gdHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nID8gJ2dldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpJyA6ICdnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpJztcblxuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuaGFzKF9jb21wb25lbnROYW1lKSkge1xuICAgICAgICAgIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGUuYWRkKF9jb21wb25lbnROYW1lKTtcblxuICAgICAgICAgIGVycm9yKCdVbnNhZmUgbGVnYWN5IGxpZmVjeWNsZXMgd2lsbCBub3QgYmUgY2FsbGVkIGZvciBjb21wb25lbnRzIHVzaW5nIG5ldyBjb21wb25lbnQgQVBJcy5cXG5cXG4nICsgJyVzIHVzZXMgJXMgYnV0IGFsc28gY29udGFpbnMgdGhlIGZvbGxvd2luZyBsZWdhY3kgbGlmZWN5Y2xlczolcyVzJXNcXG5cXG4nICsgJ1RoZSBhYm92ZSBsaWZlY3ljbGVzIHNob3VsZCBiZSByZW1vdmVkLiBMZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOlxcbicgKyAnaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMnLCBfY29tcG9uZW50TmFtZSwgbmV3QXBpTmFtZSwgZm91bmRXaWxsTW91bnROYW1lICE9PSBudWxsID8gXCJcXG4gIFwiICsgZm91bmRXaWxsTW91bnROYW1lIDogJycsIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgIT09IG51bGwgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lIDogJycsIGZvdW5kV2lsbFVwZGF0ZU5hbWUgIT09IG51bGwgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxVcGRhdGVOYW1lIDogJycpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIENhY2hlIHVubWFza2VkIGNvbnRleHQgc28gd2UgY2FuIGF2b2lkIHJlY3JlYXRpbmcgbWFza2VkIGNvbnRleHQgdW5sZXNzIG5lY2Vzc2FyeS5cblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbmZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKSB7XG4gIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCk7XG4gIH1cblxuICBpZiAob2xkU3RhdGUgIT09IGluc3RhbmNlLnN0YXRlKSB7XG4gICAge1xuICAgICAgZXJyb3IoJyVzLmNvbXBvbmVudFdpbGxNb3VudCgpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gdGhpcy5zdGF0ZSBpcyAnICsgXCJkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgXCIgKyAnY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgfVxuXG4gICAgY2xhc3NDb21wb25lbnRVcGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUoaW5zdGFuY2UsIGluc3RhbmNlLnN0YXRlLCBudWxsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXh0Q29udGV4dCkge1xuICB2YXIgb2xkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcblxuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gIH1cblxuICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgfVxuXG4gIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gb2xkU3RhdGUpIHtcbiAgICB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudC5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgICAgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50LmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignJXMuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpOiBBc3NpZ25pbmcgZGlyZWN0bHkgdG8gJyArIFwidGhpcy5zdGF0ZSBpcyBkZXByZWNhdGVkIChleGNlcHQgaW5zaWRlIGEgY29tcG9uZW50J3MgXCIgKyAnY29uc3RydWN0b3IpLiBVc2Ugc2V0U3RhdGUgaW5zdGVhZC4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuICB9XG59IC8vIEludm9rZXMgdGhlIG1vdW50IGxpZmUtY3ljbGVzIG9uIGEgcHJldmlvdXNseSBuZXZlciByZW5kZXJlZCBpbnN0YW5jZS5cblxuXG5mdW5jdGlvbiBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzLCByZW5kZXJMYW5lcykge1xuICB7XG4gICAgY2hlY2tDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBuZXdQcm9wcyk7XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgaW5zdGFuY2UucmVmcyA9IHt9O1xuICBpbml0aWFsaXplVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgaW5zdGFuY2UuY29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfSBlbHNlIHtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuICB9XG5cbiAge1xuICAgIGlmIChpbnN0YW5jZS5zdGF0ZSA9PT0gbmV3UHJvcHMpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXREaXJlY3RseUFzc2lnbmluZ1Byb3BzVG9TdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBJdCBpcyBub3QgcmVjb21tZW5kZWQgdG8gYXNzaWduIHByb3BzIGRpcmVjdGx5IHRvIHN0YXRlICcgKyBcImJlY2F1c2UgdXBkYXRlcyB0byBwcm9wcyB3b24ndCBiZSByZWZsZWN0ZWQgaW4gc3RhdGUuIFwiICsgJ0luIG1vc3QgY2FzZXMsIGl0IGlzIGJldHRlciB0byB1c2UgcHJvcHMgZGlyZWN0bHkuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpO1xuICAgIH1cblxuICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG4gIH1cblxuICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5ld1Byb3BzKTtcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH0gLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG5cblxuICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzICE9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICBjYWxsQ29tcG9uZW50V2lsbE1vdW50KHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7IC8vIElmIHdlIGhhZCBhZGRpdGlvbmFsIHN0YXRlIHVwZGF0ZXMgZHVyaW5nIHRoaXMgbGlmZS1jeWNsZSwgbGV0J3NcbiAgICAvLyBwcm9jZXNzIHRoZW0gbm93LlxuXG4gICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgICBzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKCk7XG4gICAgaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZSB8IExheW91dFN0YXRpYztcbiAgfVxuXG4gIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdEVmZmVjdHNNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gTW91bnRMYXlvdXREZXY7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBuZXdQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICB2YXIgdW5yZXNvbHZlZE9sZFByb3BzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcztcbiAgdmFyIG9sZFByb3BzID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoY3RvciwgdW5yZXNvbHZlZE9sZFByb3BzKTtcbiAgaW5zdGFuY2UucHJvcHMgPSBvbGRQcm9wcztcbiAgdmFyIG9sZENvbnRleHQgPSBpbnN0YW5jZS5jb250ZXh0O1xuICB2YXIgY29udGV4dFR5cGUgPSBjdG9yLmNvbnRleHRUeXBlO1xuICB2YXIgbmV4dENvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG5cbiAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICBuZXh0Q29udGV4dCA9IHJlYWRDb250ZXh0KGNvbnRleHRUeXBlKTtcbiAgfVxuXG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPSBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcztcbiAgdmFyIGhhc05ld0xpZmVjeWNsZXMgPSB0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJzsgLy8gV2hlbiBjb21wYXJpbmcgd2hldGhlciBwcm9wcyBjaGFuZ2VkLCB3ZSBzaG91bGQgY29tcGFyZSB1c2luZyB0aGVcbiAgLy8gdW5yZXNvbHZlZCBwcm9wcyBvYmplY3QgdGhhdCBpcyBzdG9yZWQgb24gdGhlIGZpYmVyLCByYXRoZXIgdGhhbiB0aGVcbiAgLy8gb25lIHRoYXQgZ2V0cyBhc3NpZ25lZCB0byB0aGUgaW5zdGFuY2UsIGJlY2F1c2UgdGhhdCBvYmplY3QgbWF5IGhhdmUgYmVlblxuICAvLyBjbG9uZWQgdG8gcmVzb2x2ZSBkZWZhdWx0IHByb3BzIGFuZC9vciByZW1vdmUgYHJlZmAuXG5cbiAgdmFyIHVucmVzb2x2ZWROZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIGRpZFJlY2VpdmVOZXdQcm9wcyA9IHVucmVzb2x2ZWROZXdQcm9wcyAhPT0gdW5yZXNvbHZlZE9sZFByb3BzOyAvLyBOb3RlOiBEdXJpbmcgdGhlc2UgbGlmZS1jeWNsZXMsIGluc3RhbmNlLnByb3BzL2luc3RhbmNlLnN0YXRlIGFyZSB3aGF0XG4gIC8vIGV2ZXIgdGhlIHByZXZpb3VzbHkgYXR0ZW1wdGVkIHRvIHJlbmRlciAtIG5vdCB0aGUgXCJjdXJyZW50XCIuIEhvd2V2ZXIsXG4gIC8vIGR1cmluZyBjb21wb25lbnREaWRVcGRhdGUgd2UgcGFzcyB0aGUgXCJjdXJyZW50XCIgcHJvcHMuXG4gIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuXG4gIGlmICghaGFzTmV3TGlmZWN5Y2xlcyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSkge1xuICAgIGlmIChkaWRSZWNlaXZlTmV3UHJvcHMgfHwgb2xkQ29udGV4dCAhPT0gbmV4dENvbnRleHQpIHtcbiAgICAgIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICB9XG4gIH1cblxuICByZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZygpO1xuICB2YXIgb2xkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB2YXIgbmV3U3RhdGUgPSBpbnN0YW5jZS5zdGF0ZSA9IG9sZFN0YXRlO1xuICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5ld1Byb3BzLCBpbnN0YW5jZSwgcmVuZGVyTGFuZXMpO1xuICBzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKCk7XG4gIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAoIWRpZFJlY2VpdmVOZXdQcm9wcyAmJiBvbGRTdGF0ZSA9PT0gbmV3U3RhdGUgJiYgIWhhc0NvbnRleHRDaGFuZ2VkKCkgJiYgIWNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSkge1xuICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlIHwgTGF5b3V0U3RhdGljO1xuICAgIH1cblxuICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdEVmZmVjdHNNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBNb3VudExheW91dERldjtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5ld1Byb3BzKTtcbiAgICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICB2YXIgc2hvdWxkVXBkYXRlID0gY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpIHx8IGNoZWNrU2hvdWxkQ29tcG9uZW50VXBkYXRlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBvbGRQcm9wcywgbmV3UHJvcHMsIG9sZFN0YXRlLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuXG4gIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICAgIGlmICghaGFzTmV3TGlmZWN5Y2xlcyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZSB8IExheW91dFN0YXRpYztcbiAgICB9XG5cbiAgICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RFZmZlY3RzTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gTW91bnRMYXlvdXREZXY7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlIHwgTGF5b3V0U3RhdGljO1xuICAgIH1cblxuICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdEVmZmVjdHNNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBNb3VudExheW91dERldjtcbiAgICB9IC8vIElmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5lZCBmYWxzZSwgd2Ugc2hvdWxkIHN0aWxsIHVwZGF0ZSB0aGVcbiAgICAvLyBtZW1vaXplZCBzdGF0ZSB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgd29yayBjYW4gYmUgcmV1c2VkLlxuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV3UHJvcHM7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9IC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgLy8gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2UuXG5cblxuICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICBpbnN0YW5jZS5jb250ZXh0ID0gbmV4dENvbnRleHQ7XG4gIHJldHVybiBzaG91bGRVcGRhdGU7XG59IC8vIEludm9rZXMgdGhlIHVwZGF0ZSBsaWZlLWN5Y2xlcyBhbmQgcmV0dXJucyBmYWxzZSBpZiBpdCBzaG91bGRuJ3QgcmVyZW5kZXIuXG5cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3NJbnN0YW5jZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgY2xvbmVVcGRhdGVRdWV1ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHZhciB1bnJlc29sdmVkT2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICB2YXIgb2xkUHJvcHMgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhjdG9yLCB1bnJlc29sdmVkT2xkUHJvcHMpO1xuICBpbnN0YW5jZS5wcm9wcyA9IG9sZFByb3BzO1xuICB2YXIgdW5yZXNvbHZlZE5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgb2xkQ29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG4gIHZhciBjb250ZXh0VHlwZSA9IGN0b3IuY29udGV4dFR5cGU7XG4gIHZhciBuZXh0Q29udGV4dCA9IGVtcHR5Q29udGV4dE9iamVjdDtcblxuICBpZiAodHlwZW9mIGNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgIG5leHRDb250ZXh0ID0gcmVhZENvbnRleHQoY29udGV4dFR5cGUpO1xuICB9XG5cbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICB2YXIgaGFzTmV3TGlmZWN5Y2xlcyA9IHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nOyAvLyBOb3RlOiBEdXJpbmcgdGhlc2UgbGlmZS1jeWNsZXMsIGluc3RhbmNlLnByb3BzL2luc3RhbmNlLnN0YXRlIGFyZSB3aGF0XG4gIC8vIGV2ZXIgdGhlIHByZXZpb3VzbHkgYXR0ZW1wdGVkIHRvIHJlbmRlciAtIG5vdCB0aGUgXCJjdXJyZW50XCIuIEhvd2V2ZXIsXG4gIC8vIGR1cmluZyBjb21wb25lbnREaWRVcGRhdGUgd2UgcGFzcyB0aGUgXCJjdXJyZW50XCIgcHJvcHMuXG4gIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuXG4gIGlmICghaGFzTmV3TGlmZWN5Y2xlcyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSkge1xuICAgIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgIT09IHVucmVzb2x2ZWROZXdQcm9wcyB8fCBvbGRDb250ZXh0ICE9PSBuZXh0Q29udGV4dCkge1xuICAgICAgY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV4dENvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIHJlc2V0SGFzRm9yY2VVcGRhdGVCZWZvcmVQcm9jZXNzaW5nKCk7XG4gIHZhciBvbGRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIHZhciBuZXdTdGF0ZSA9IGluc3RhbmNlLnN0YXRlID0gb2xkU3RhdGU7XG4gIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV3UHJvcHMsIGluc3RhbmNlLCByZW5kZXJMYW5lcyk7XG4gIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKTtcbiAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgPT09IHVucmVzb2x2ZWROZXdQcm9wcyAmJiBvbGRTdGF0ZSA9PT0gbmV3U3RhdGUgJiYgIWhhc0NvbnRleHRDaGFuZ2VkKCkgJiYgIWNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSAmJiAhKGVuYWJsZUxhenlDb250ZXh0UHJvcGFnYXRpb24gICApKSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNuYXBzaG90O1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV3UHJvcHMpO1xuICAgIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIHZhciBzaG91bGRVcGRhdGUgPSBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkgfHwgY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCkgfHwgLy8gVE9ETzogSW4gc29tZSBjYXNlcywgd2UnbGwgZW5kIHVwIGNoZWNraW5nIGlmIGNvbnRleHQgaGFzIGNoYW5nZWQgdHdpY2UsXG4gIC8vIGJvdGggYmVmb3JlIGFuZCBhZnRlciBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCBoYXMgYmVlbiBjYWxsZWQuIE5vdCBpZGVhbCxcbiAgLy8gYnV0IEknbSBsb2F0aCB0byByZWZhY3RvciB0aGlzIGZ1bmN0aW9uLiBUaGlzIG9ubHkgaGFwcGVucyBmb3IgbWVtb2l6ZWRcbiAgLy8gY29tcG9uZW50cyBzbyBpdCdzIG5vdCB0aGF0IGNvbW1vbi5cbiAgZW5hYmxlTGF6eUNvbnRleHRQcm9wYWdhdGlvbiAgIDtcblxuICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gICAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cbiAgICBpZiAoIWhhc05ld0xpZmVjeWNsZXMgJiYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU25hcHNob3Q7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIElmIGFuIHVwZGF0ZSB3YXMgYWxyZWFkeSBpbiBwcm9ncmVzcywgd2Ugc2hvdWxkIHNjaGVkdWxlIGFuIFVwZGF0ZVxuICAgIC8vIGVmZmVjdCBldmVuIHRob3VnaCB3ZSdyZSBiYWlsaW5nIG91dCwgc28gdGhhdCBjV1UvY0RVIGFyZSBjYWxsZWQuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAodW5yZXNvbHZlZE9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTbmFwc2hvdDtcbiAgICAgIH1cbiAgICB9IC8vIElmIHNob3VsZENvbXBvbmVudFVwZGF0ZSByZXR1cm5lZCBmYWxzZSwgd2Ugc2hvdWxkIHN0aWxsIHVwZGF0ZSB0aGVcbiAgICAvLyBtZW1vaXplZCBwcm9wcy9zdGF0ZSB0byBpbmRpY2F0ZSB0aGF0IHRoaXMgd29yayBjYW4gYmUgcmV1c2VkLlxuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbmV3UHJvcHM7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9IC8vIFVwZGF0ZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UncyBzdGF0ZSwgcHJvcHMsIGFuZCBjb250ZXh0IHBvaW50ZXJzIGV2ZW5cbiAgLy8gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2UuXG5cblxuICBpbnN0YW5jZS5wcm9wcyA9IG5ld1Byb3BzO1xuICBpbnN0YW5jZS5zdGF0ZSA9IG5ld1N0YXRlO1xuICBpbnN0YW5jZS5jb250ZXh0ID0gbmV4dENvbnRleHQ7XG4gIHJldHVybiBzaG91bGRVcGRhdGU7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKENvbXBvbmVudCwgYmFzZVByb3BzLCAvLyBPbmx5IHJlc29sdmUgZGVmYXVsdCBwcm9wcyBpZiB0aGlzIGlzIGEgbGF6eSBjb21wb25lbnQuIE90aGVyd2lzZSwgdGhleVxuLy8gd291bGQgaGF2ZSBhbHJlYWR5IGJlZW4gcmVzb2x2ZWQgYnkgdGhlIEpTWCBydW50aW1lLlxuLy8gVE9ETzogV2UncmUgZ29pbmcgdG8gcmVtb3ZlIGRlZmF1bHQgcHJvcCByZXNvbHV0aW9uIGZyb20gdGhlIEpTWCBydW50aW1lXG4vLyBhbmQga2VlcCBpdCBvbmx5IGZvciBjbGFzcyBjb21wb25lbnRzLiBBcyBwYXJ0IG9mIHRoYXQgY2hhbmdlLCB3ZSBzaG91bGRcbi8vIHJlbW92ZSB0aGlzIGV4dHJhIGNoZWNrLlxuYWxyZWFkeVJlc29sdmVkRGVmYXVsdFByb3BzKSB7XG4gIHZhciBuZXdQcm9wcyA9IGJhc2VQcm9wcztcblxuICB7XG4gICAgLy8gUmVtb3ZlIHJlZiBmcm9tIHRoZSBwcm9wcyBvYmplY3QsIGlmIGl0IGV4aXN0cy5cbiAgICBpZiAoJ3JlZicgaW4gYmFzZVByb3BzKSB7XG4gICAgICBuZXdQcm9wcyA9IHt9O1xuXG4gICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBiYXNlUHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BOYW1lICE9PSAncmVmJykge1xuICAgICAgICAgIG5ld1Byb3BzW3Byb3BOYW1lXSA9IGJhc2VQcm9wc1twcm9wTmFtZV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gUmVzb2x2ZSBkZWZhdWx0IHByb3BzLlxuXG5cbiAgdmFyIGRlZmF1bHRQcm9wcyA9IENvbXBvbmVudC5kZWZhdWx0UHJvcHM7XG5cbiAgaWYgKGRlZmF1bHRQcm9wcyAmJiAoIC8vIElmIGRpc2FibGVEZWZhdWx0UHJvcHNFeGNlcHRGb3JDbGFzc2VzIGlzIHRydWUsIHdlIGFsd2F5cyByZXNvbHZlXG4gIC8vIGRlZmF1bHQgcHJvcHMgaGVyZSBpbiB0aGUgcmVjb25jaWxlciwgcmF0aGVyIHRoYW4gaW4gdGhlIEpTWCBydW50aW1lLlxuICBkaXNhYmxlRGVmYXVsdFByb3BzRXhjZXB0Rm9yQ2xhc3NlcyApKSB7XG4gICAgLy8gV2UgbWF5IGhhdmUgYWxyZWFkeSBjb3BpZWQgdGhlIHByb3BzIG9iamVjdCBhYm92ZSB0byByZW1vdmUgcmVmLiBJZiBzbyxcbiAgICAvLyB3ZSBjYW4gbW9kaWZ5IHRoYXQuIE90aGVyd2lzZSwgY29weSB0aGUgcHJvcHMgb2JqZWN0IHdpdGggT2JqZWN0LmFzc2lnbi5cbiAgICBpZiAobmV3UHJvcHMgPT09IGJhc2VQcm9wcykge1xuICAgICAgbmV3UHJvcHMgPSBhc3NpZ24oe30sIG5ld1Byb3BzKTtcbiAgICB9IC8vIFRha2VuIGZyb20gb2xkIEpTWCBydW50aW1lLCB3aGVyZSB0aGlzIHVzZWQgdG8gbGl2ZS5cblxuXG4gICAgZm9yICh2YXIgX3Byb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgaWYgKG5ld1Byb3BzW19wcm9wTmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdQcm9wc1tfcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW19wcm9wTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld1Byb3BzO1xufVxuXG52YXIgcmVwb3J0R2xvYmFsRXJyb3IgPSB0eXBlb2YgcmVwb3J0RXJyb3IgPT09ICdmdW5jdGlvbicgPyAvLyBJbiBtb2Rlcm4gYnJvd3NlcnMsIHJlcG9ydEVycm9yIHdpbGwgZGlzcGF0Y2ggYW4gZXJyb3IgZXZlbnQsXG4vLyBlbXVsYXRpbmcgYW4gdW5jYXVnaHQgSmF2YVNjcmlwdCBlcnJvci5cbnJlcG9ydEVycm9yIDogZnVuY3Rpb24gKGVycm9yKSB7XG4gIGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygd2luZG93LkVycm9yRXZlbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBCcm93c2VyIFBvbHlmaWxsXG4gICAgdmFyIG1lc3NhZ2UgPSB0eXBlb2YgZXJyb3IgPT09ICdvYmplY3QnICYmIGVycm9yICE9PSBudWxsICYmIHR5cGVvZiBlcnJvci5tZXNzYWdlID09PSAnc3RyaW5nJyA/IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgIFN0cmluZyhlcnJvci5tZXNzYWdlKSA6IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICAgIFN0cmluZyhlcnJvcik7XG4gICAgdmFyIGV2ZW50ID0gbmV3IHdpbmRvdy5FcnJvckV2ZW50KCdlcnJvcicsIHtcbiAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIGVycm9yOiBlcnJvclxuICAgIH0pO1xuICAgIHZhciBzaG91bGRMb2cgPSB3aW5kb3cuZGlzcGF0Y2hFdmVudChldmVudCk7XG5cbiAgICBpZiAoIXNob3VsZExvZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICB0eXBlb2YgcHJvY2Vzcy5lbWl0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gTm9kZSBQb2x5ZmlsbFxuICAgIHByb2Nlc3MuZW1pdCgndW5jYXVnaHRFeGNlcHRpb24nLCBlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuXG4gIGNvbnNvbGVbJ2Vycm9yJ10oZXJyb3IpO1xufTtcblxudmFyIGNvbXBvbmVudE5hbWUgPSBudWxsO1xudmFyIGVycm9yQm91bmRhcnlOYW1lID0gbnVsbDtcbmZ1bmN0aW9uIGRlZmF1bHRPblVuY2F1Z2h0RXJyb3IoZXJyb3IsIGVycm9ySW5mbykge1xuICAvLyBPdmVycmlkaW5nIHRoaXMgY2FuIHNpbGVuY2UgdGhlc2Ugd2FybmluZ3MgZS5nLiBmb3IgdGVzdHMuXG4gIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xMzM4NFxuICAvLyBGb3IgdW5jYXVnaHQgcm9vdCBlcnJvcnMgd2UgcmVwb3J0IHRoZW0gYXMgdW5jYXVnaHQgdG8gdGhlIGJyb3dzZXInc1xuICAvLyBvbmVycm9yIGNhbGxiYWNrLiBUaGlzIHdvbid0IGhhdmUgY29tcG9uZW50IHN0YWNrcyBhbmQgdGhlIGVycm9yIGFkZGVuZHVtLlxuICAvLyBTbyB3ZSBhZGQgdGhvc2UgaW50byBhIHNlcGFyYXRlIGNvbnNvbGUud2Fybi5cbiAgcmVwb3J0R2xvYmFsRXJyb3IoZXJyb3IpO1xuXG4gIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZU1lc3NhZ2UgPSBjb21wb25lbnROYW1lID8gXCJBbiBlcnJvciBvY2N1cnJlZCBpbiB0aGUgPFwiICsgY29tcG9uZW50TmFtZSArIFwiPiBjb21wb25lbnQuXCIgOiAnQW4gZXJyb3Igb2NjdXJyZWQgaW4gb25lIG9mIHlvdXIgUmVhY3QgY29tcG9uZW50cy4nO1xuICAgIHZhciBlcnJvckJvdW5kYXJ5TWVzc2FnZSA9ICdDb25zaWRlciBhZGRpbmcgYW4gZXJyb3IgYm91bmRhcnkgdG8geW91ciB0cmVlIHRvIGN1c3RvbWl6ZSBlcnJvciBoYW5kbGluZyBiZWhhdmlvci5cXG4nICsgJ1Zpc2l0IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvZXJyb3ItYm91bmRhcmllcyB0byBsZWFybiBtb3JlIGFib3V0IGVycm9yIGJvdW5kYXJpZXMuJztcblxuICAgIHtcbiAgICAgIC8vIFRoZSBjdXJyZW50IEZpYmVyIGlzIGRpc2Nvbm5lY3RlZCBhdCB0aGlzIHBvaW50IHdoaWNoIG1lYW5zIHRoYXQgY29uc29sZSBwcmludGluZ1xuICAgICAgLy8gY2Fubm90IGFkZCBhIGNvbXBvbmVudCBzdGFjayBzaW5jZSBpdCB0ZXJtaW5hdGVzIGF0IHRoZSBkZWxldGlvbiBub2RlLiBUaGlzIGlzIG5vdFxuICAgICAgLy8gYSBwcm9ibGVtIGZvciBvd25lciBzdGFja3Mgd2hpY2ggYXJlIG5vdCBkaXNjb25uZWN0ZWQgYnV0IGZvciB0aGUgcGFyZW50IGNvbXBvbmVudFxuICAgICAgLy8gc3RhY2tzIHdlIG5lZWQgdG8gdXNlIHRoZSBzbmFwc2hvdCB3ZSd2ZSBwcmV2aW91c2x5IGV4dHJhY3RlZC5cbiAgICAgIHZhciBjb21wb25lbnRTdGFjayA9IGVycm9ySW5mby5jb21wb25lbnRTdGFjayAhPSBudWxsID8gZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrIDogJyc7IC8vIERvbid0IHRyYW5zZm9ybSB0byBvdXIgd3JhcHBlclxuXG4gICAgICBjb25zb2xlWyd3YXJuJ10oJyVzXFxuXFxuJXNcXG4lcycsIGNvbXBvbmVudE5hbWVNZXNzYWdlLCBlcnJvckJvdW5kYXJ5TWVzc2FnZSwgY29tcG9uZW50U3RhY2spO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGVmYXVsdE9uQ2F1Z2h0RXJyb3IoZXJyb3IkMSwgZXJyb3JJbmZvKSB7XG4gIC8vIE92ZXJyaWRpbmcgdGhpcyBjYW4gc2lsZW5jZSB0aGVzZSB3YXJuaW5ncyBlLmcuIGZvciB0ZXN0cy5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEzMzg0XG4gIC8vIENhdWdodCBieSBlcnJvciBib3VuZGFyeVxuICB7XG4gICAgdmFyIGNvbXBvbmVudE5hbWVNZXNzYWdlID0gY29tcG9uZW50TmFtZSA/IFwiVGhlIGFib3ZlIGVycm9yIG9jY3VycmVkIGluIHRoZSA8XCIgKyBjb21wb25lbnROYW1lICsgXCI+IGNvbXBvbmVudC5cIiA6ICdUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gb25lIG9mIHlvdXIgUmVhY3QgY29tcG9uZW50cy4nOyAvLyBJbiBkZXZlbG9wbWVudCwgd2UgcHJvdmlkZSBvdXIgb3duIG1lc3NhZ2Ugd2hpY2ggaW5jbHVkZXMgdGhlIGNvbXBvbmVudCBzdGFja1xuICAgIC8vIGluIGFkZGl0aW9uIHRvIHRoZSBlcnJvci5cblxuICAgIHZhciByZWNyZWF0ZU1lc3NhZ2UgPSBcIlJlYWN0IHdpbGwgdHJ5IHRvIHJlY3JlYXRlIHRoaXMgY29tcG9uZW50IHRyZWUgZnJvbSBzY3JhdGNoIFwiICsgKFwidXNpbmcgdGhlIGVycm9yIGJvdW5kYXJ5IHlvdSBwcm92aWRlZCwgXCIgKyAoZXJyb3JCb3VuZGFyeU5hbWUgfHwgJ0Fub255bW91cycpICsgXCIuXCIpO1xuXG4gICAge1xuICAgICAgLy8gVGhlIGN1cnJlbnQgRmliZXIgaXMgZGlzY29ubmVjdGVkIGF0IHRoaXMgcG9pbnQgd2hpY2ggbWVhbnMgdGhhdCBjb25zb2xlIHByaW50aW5nXG4gICAgICAvLyBjYW5ub3QgYWRkIGEgY29tcG9uZW50IHN0YWNrIHNpbmNlIGl0IHRlcm1pbmF0ZXMgYXQgdGhlIGRlbGV0aW9uIG5vZGUuIFRoaXMgaXMgbm90XG4gICAgICAvLyBhIHByb2JsZW0gZm9yIG93bmVyIHN0YWNrcyB3aGljaCBhcmUgbm90IGRpc2Nvbm5lY3RlZCBidXQgZm9yIHRoZSBwYXJlbnQgY29tcG9uZW50XG4gICAgICAvLyBzdGFja3Mgd2UgbmVlZCB0byB1c2UgdGhlIHNuYXBzaG90IHdlJ3ZlIHByZXZpb3VzbHkgZXh0cmFjdGVkLlxuICAgICAgdmFyIGNvbXBvbmVudFN0YWNrID0gZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrICE9IG51bGwgPyBlcnJvckluZm8uY29tcG9uZW50U3RhY2sgOiAnJzsgLy8gRG9uJ3QgdHJhbnNmb3JtIHRvIG91ciB3cmFwcGVyXG5cbiAgICAgIGNvbnNvbGVbJ2Vycm9yJ10oJyVvXFxuXFxuJXNcXG5cXG4lc1xcbiVzJywgZXJyb3IkMSwgY29tcG9uZW50TmFtZU1lc3NhZ2UsIHJlY3JlYXRlTWVzc2FnZSwgY29tcG9uZW50U3RhY2spO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZGVmYXVsdE9uUmVjb3ZlcmFibGVFcnJvcihlcnJvciwgZXJyb3JJbmZvKSB7XG4gIHJlcG9ydEdsb2JhbEVycm9yKGVycm9yKTtcbn1cbmZ1bmN0aW9uIGxvZ1VuY2F1Z2h0RXJyb3Iocm9vdCwgZXJyb3JJbmZvKSB7XG4gIHRyeSB7XG4gICAgaWYgKHRydWUpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBlcnJvckluZm8uc291cmNlID8gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihlcnJvckluZm8uc291cmNlKSA6IG51bGw7XG4gICAgICBlcnJvckJvdW5kYXJ5TmFtZSA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGVycm9yID0gZXJyb3JJbmZvLnZhbHVlO1xuXG4gICAgaWYgKHRydWUgJiYgUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgIT09IG51bGwpIHtcbiAgICAgIC8vIEZvciB1bmNhdWdodCBlcnJvcnMgaW5zaWRlIGFjdCwgd2UgdHJhY2sgdGhlbSBvbiB0aGUgYWN0IGFuZCB0aGVuXG4gICAgICAvLyByZXRocm93IHRoZW0gaW50byB0aGUgdGVzdC5cbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLnRocm93bkVycm9ycy5wdXNoKGVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgb25VbmNhdWdodEVycm9yID0gcm9vdC5vblVuY2F1Z2h0RXJyb3I7XG4gICAgb25VbmNhdWdodEVycm9yKGVycm9yLCB7XG4gICAgICBjb21wb25lbnRTdGFjazogZXJyb3JJbmZvLnN0YWNrXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUaGlzIG1ldGhvZCBtdXN0IG5vdCB0aHJvdywgb3IgUmVhY3QgaW50ZXJuYWwgc3RhdGUgd2lsbCBnZXQgbWVzc2VkIHVwLlxuICAgIC8vIElmIGNvbnNvbGUuZXJyb3IgaXMgb3ZlcnJpZGRlbiwgb3IgbG9nQ2FwdHVyZWRFcnJvcigpIHNob3dzIGEgZGlhbG9nIHRoYXQgdGhyb3dzLFxuICAgIC8vIHdlIHdhbnQgdG8gcmVwb3J0IHRoaXMgZXJyb3Igb3V0c2lkZSBvZiB0aGUgbm9ybWFsIHN0YWNrIGFzIGEgbGFzdCByZXNvcnQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzE4OFxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gbG9nQ2F1Z2h0RXJyb3Iocm9vdCwgYm91bmRhcnksIGVycm9ySW5mbykge1xuICB0cnkge1xuICAgIGlmICh0cnVlKSB7XG4gICAgICBjb21wb25lbnROYW1lID0gZXJyb3JJbmZvLnNvdXJjZSA/IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZXJyb3JJbmZvLnNvdXJjZSkgOiBudWxsO1xuICAgICAgZXJyb3JCb3VuZGFyeU5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGJvdW5kYXJ5KTtcbiAgICB9XG5cbiAgICB2YXIgZXJyb3IgPSBlcnJvckluZm8udmFsdWU7XG4gICAgdmFyIG9uQ2F1Z2h0RXJyb3IgPSByb290Lm9uQ2F1Z2h0RXJyb3I7XG4gICAgb25DYXVnaHRFcnJvcihlcnJvciwge1xuICAgICAgY29tcG9uZW50U3RhY2s6IGVycm9ySW5mby5zdGFjayxcbiAgICAgIGVycm9yQm91bmRhcnk6IGJvdW5kYXJ5LnRhZyA9PT0gQ2xhc3NDb21wb25lbnQgPyBib3VuZGFyeS5zdGF0ZU5vZGUgLy8gVGhpcyBzaG91bGQgYWx3YXlzIGJlIHRoZSBjYXNlIGFzIGxvbmcgYXMgd2Ugb25seSBoYXZlIGNsYXNzIGJvdW5kYXJpZXNcbiAgICAgIDogbnVsbFxuICAgIH0pO1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gVGhpcyBtZXRob2QgbXVzdCBub3QgdGhyb3csIG9yIFJlYWN0IGludGVybmFsIHN0YXRlIHdpbGwgZ2V0IG1lc3NlZCB1cC5cbiAgICAvLyBJZiBjb25zb2xlLmVycm9yIGlzIG92ZXJyaWRkZW4sIG9yIGxvZ0NhcHR1cmVkRXJyb3IoKSBzaG93cyBhIGRpYWxvZyB0aGF0IHRocm93cyxcbiAgICAvLyB3ZSB3YW50IHRvIHJlcG9ydCB0aGlzIGVycm9yIG91dHNpZGUgb2YgdGhlIG5vcm1hbCBzdGFjayBhcyBhIGxhc3QgcmVzb3J0LlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTMxODhcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IGU7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUm9vdEVycm9yVXBkYXRlKHJvb3QsIGVycm9ySW5mbywgbGFuZSkge1xuICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGxhbmUpOyAvLyBVbm1vdW50IHRoZSByb290IGJ5IHJlbmRlcmluZyBudWxsLlxuXG4gIHVwZGF0ZS50YWcgPSBDYXB0dXJlVXBkYXRlOyAvLyBDYXV0aW9uOiBSZWFjdCBEZXZUb29scyBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByb3BlcnR5XG4gIC8vIGJlaW5nIGNhbGxlZCBcImVsZW1lbnRcIi5cblxuICB1cGRhdGUucGF5bG9hZCA9IHtcbiAgICBlbGVtZW50OiBudWxsXG4gIH07XG5cbiAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwcmV2RmliZXIgPSBnZXRDdXJyZW50RmliZXIoKTsgLy8gc2hvdWxkIGp1c3QgYmUgdGhlIHJvb3RcblxuICAgIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoZXJyb3JJbmZvLnNvdXJjZSk7XG4gICAgbG9nVW5jYXVnaHRFcnJvcihyb290LCBlcnJvckluZm8pO1xuICAgIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYocHJldkZpYmVyKTtcbiAgfTtcblxuICByZXR1cm4gdXBkYXRlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKGxhbmUpIHtcbiAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShsYW5lKTtcbiAgdXBkYXRlLnRhZyA9IENhcHR1cmVVcGRhdGU7XG4gIHJldHVybiB1cGRhdGU7XG59XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVDbGFzc0Vycm9yVXBkYXRlKHVwZGF0ZSwgcm9vdCwgZmliZXIsIGVycm9ySW5mbykge1xuICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID0gZmliZXIudHlwZS5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3I7XG5cbiAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgZXJyb3IkMSA9IGVycm9ySW5mby52YWx1ZTtcblxuICAgIHVwZGF0ZS5wYXlsb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcihlcnJvciQxKTtcbiAgICB9O1xuXG4gICAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAge1xuICAgICAgICBtYXJrRmFpbGVkRXJyb3JCb3VuZGFyeUZvckhvdFJlbG9hZGluZyhmaWJlcik7XG4gICAgICB9XG5cbiAgICAgIHZhciBwcmV2RmliZXIgPSBnZXRDdXJyZW50RmliZXIoKTsgLy8gc2hvdWxkIGJlIHRoZSBlcnJvciBib3VuZGFyeVxuXG4gICAgICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKGVycm9ySW5mby5zb3VyY2UpO1xuICAgICAgbG9nQ2F1Z2h0RXJyb3Iocm9vdCwgZmliZXIsIGVycm9ySW5mbyk7XG4gICAgICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKHByZXZGaWJlcik7XG4gICAgfTtcbiAgfVxuXG4gIHZhciBpbnN0ID0gZmliZXIuc3RhdGVOb2RlO1xuXG4gIGlmIChpbnN0ICE9PSBudWxsICYmIHR5cGVvZiBpbnN0LmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gJEZsb3dGaXhNZVttaXNzaW5nLXRoaXMtYW5ub3RdXG4gICAgdXBkYXRlLmNhbGxiYWNrID0gZnVuY3Rpb24gY2FsbGJhY2soKSB7XG4gICAgICB7XG4gICAgICAgIG1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZXZGaWJlciA9IGdldEN1cnJlbnRGaWJlcigpOyAvLyBzaG91bGQgYmUgdGhlIGVycm9yIGJvdW5kYXJ5XG5cbiAgICAgIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoZXJyb3JJbmZvLnNvdXJjZSk7XG4gICAgICBsb2dDYXVnaHRFcnJvcihyb290LCBmaWJlciwgZXJyb3JJbmZvKTtcbiAgICAgIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYocHJldkZpYmVyKTtcblxuICAgICAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gVG8gcHJlc2VydmUgdGhlIHByZWV4aXN0aW5nIHJldHJ5IGJlaGF2aW9yIG9mIGVycm9yIGJvdW5kYXJpZXMsXG4gICAgICAgIC8vIHdlIGtlZXAgdHJhY2sgb2Ygd2hpY2ggb25lcyBhbHJlYWR5IGZhaWxlZCBkdXJpbmcgdGhpcyBiYXRjaC5cbiAgICAgICAgLy8gVGhpcyBnZXRzIHJlc2V0IGJlZm9yZSB3ZSB5aWVsZCBiYWNrIHRvIHRoZSBicm93c2VyLlxuICAgICAgICAvLyBUT0RPOiBXYXJuIGluIHN0cmljdCBtb2RlIGlmIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciBpc1xuICAgICAgICAvLyBub3QgZGVmaW5lZC5cbiAgICAgICAgbWFya0xlZ2FjeUVycm9yQm91bmRhcnlBc0ZhaWxlZCh0aGlzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGVycm9yJDEgPSBlcnJvckluZm8udmFsdWU7XG4gICAgICB2YXIgc3RhY2sgPSBlcnJvckluZm8uc3RhY2s7XG4gICAgICB0aGlzLmNvbXBvbmVudERpZENhdGNoKGVycm9yJDEsIHtcbiAgICAgICAgY29tcG9uZW50U3RhY2s6IHN0YWNrICE9PSBudWxsID8gc3RhY2sgOiAnJ1xuICAgICAgfSk7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBJZiBjb21wb25lbnREaWRDYXRjaCBpcyB0aGUgb25seSBlcnJvciBib3VuZGFyeSBtZXRob2QgZGVmaW5lZCxcbiAgICAgICAgICAvLyB0aGVuIGl0IG5lZWRzIHRvIGNhbGwgc2V0U3RhdGUgdG8gcmVjb3ZlciBmcm9tIGVycm9ycy5cbiAgICAgICAgICAvLyBJZiBubyBzdGF0ZSB1cGRhdGUgaXMgc2NoZWR1bGVkIHRoZW4gdGhlIGJvdW5kYXJ5IHdpbGwgc3dhbGxvdyB0aGUgZXJyb3IuXG4gICAgICAgICAgaWYgKCFpbmNsdWRlc1NvbWVMYW5lKGZpYmVyLmxhbmVzLCBTeW5jTGFuZSkpIHtcbiAgICAgICAgICAgIGVycm9yKCclczogRXJyb3IgYm91bmRhcmllcyBzaG91bGQgaW1wbGVtZW50IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcigpLiAnICsgJ0luIHRoYXQgbWV0aG9kLCByZXR1cm4gYSBzdGF0ZSB1cGRhdGUgdG8gZGlzcGxheSBhbiBlcnJvciBtZXNzYWdlIG9yIGZhbGxiYWNrIFVJLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdVbmtub3duJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3VzcGVuc2VCb3VuZGFyeVNob3VsZENhcHR1cmUoc3VzcGVuc2VCb3VuZGFyeSwgcmV0dXJuRmliZXIsIHNvdXJjZUZpYmVyLCByb290LCByb290UmVuZGVyTGFuZXMpIHtcbiAgLy8gd2l0aCB0aGUgbm9ybWFsIHN1c3BlbmQgcGF0aC5cbiAgLy9cbiAgLy8gQWZ0ZXIgdGhpcyB3ZSdsbCB1c2UgYSBzZXQgb2YgaGV1cmlzdGljcyB0byBkZXRlcm1pbmUgd2hldGhlciB0aGlzXG4gIC8vIHJlbmRlciBwYXNzIHdpbGwgcnVuIHRvIGNvbXBsZXRpb24gb3IgcmVzdGFydCBvciBcInN1c3BlbmRcIiB0aGUgY29tbWl0LlxuICAvLyBUaGUgYWN0dWFsIGxvZ2ljIGZvciB0aGlzIGlzIHNwcmVhZCBvdXQgaW4gZGlmZmVyZW50IHBsYWNlcy5cbiAgLy9cbiAgLy8gVGhpcyBmaXJzdCBwcmluY2lwbGUgaXMgdGhhdCBpZiB3ZSdyZSBnb2luZyB0byBzdXNwZW5kIHdoZW4gd2UgY29tcGxldGVcbiAgLy8gYSByb290LCB0aGVuIHdlIHNob3VsZCBhbHNvIHJlc3RhcnQgaWYgd2UgZ2V0IGFuIHVwZGF0ZSBvciBwaW5nIHRoYXRcbiAgLy8gbWlnaHQgdW5zdXNwZW5kIGl0LCBhbmQgdmljZSB2ZXJzYS4gVGhlIG9ubHkgcmVhc29uIHRvIHN1c3BlbmQgaXNcbiAgLy8gYmVjYXVzZSB5b3UgdGhpbmsgeW91IG1pZ2h0IHdhbnQgdG8gcmVzdGFydCBiZWZvcmUgY29tbWl0dGluZy4gSG93ZXZlcixcbiAgLy8gaXQgZG9lc24ndCBtYWtlIHNlbnNlIHRvIHJlc3RhcnQgb25seSB3aGlsZSBpbiB0aGUgcGVyaW9kIHdlJ3JlIHN1c3BlbmRlZC5cbiAgLy9cbiAgLy8gUmVzdGFydGluZyB0b28gYWdncmVzc2l2ZWx5IGlzIGFsc28gbm90IGdvb2QgYmVjYXVzZSBpdCBzdGFydmVzIG91dCBhbnlcbiAgLy8gaW50ZXJtZWRpYXRlIGxvYWRpbmcgc3RhdGUuIFNvIHdlIHVzZSBoZXVyaXN0aWNzIHRvIGRldGVybWluZSB3aGVuLlxuICAvLyBTdXNwZW5zZSBIZXVyaXN0aWNzXG4gIC8vXG4gIC8vIElmIG5vdGhpbmcgdGhyZXcgYSBQcm9taXNlIG9yIGFsbCB0aGUgc2FtZSBmYWxsYmFja3MgYXJlIGFscmVhZHkgc2hvd2luZyxcbiAgLy8gdGhlbiBkb24ndCBzdXNwZW5kL3Jlc3RhcnQuXG4gIC8vXG4gIC8vIElmIHRoaXMgaXMgYW4gaW5pdGlhbCByZW5kZXIgb2YgYSBuZXcgdHJlZSBvZiBTdXNwZW5zZSBib3VuZGFyaWVzIGFuZFxuICAvLyB0aG9zZSB0cmlnZ2VyIGEgZmFsbGJhY2ssIHRoZW4gZG9uJ3Qgc3VzcGVuZC9yZXN0YXJ0LiBXZSB3YW50IHRvIGVuc3VyZVxuICAvLyB0aGF0IHdlIGNhbiBzaG93IHRoZSBpbml0aWFsIGxvYWRpbmcgc3RhdGUgYXMgcXVpY2tseSBhcyBwb3NzaWJsZS5cbiAgLy9cbiAgLy8gSWYgd2UgaGl0IGEgXCJEZWxheWVkXCIgY2FzZSwgc3VjaCBhcyB3aGVuIHdlJ2Qgc3dpdGNoIGZyb20gY29udGVudCBiYWNrIGludG9cbiAgLy8gYSBmYWxsYmFjaywgdGhlbiB3ZSBzaG91bGQgYWx3YXlzIHN1c3BlbmQvcmVzdGFydC4gVHJhbnNpdGlvbnMgYXBwbHlcbiAgLy8gdG8gdGhpcyBjYXNlLiBJZiBub25lIGlzIGRlZmluZWQsIEpORCBpcyB1c2VkIGluc3RlYWQuXG4gIC8vXG4gIC8vIElmIHdlJ3JlIGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrIGFuZCBpdCBnZXRzIFwicmV0cmllZFwiLCBhbGxvd2luZyB1cyB0byBzaG93XG4gIC8vIGFub3RoZXIgbGV2ZWwsIGJ1dCB0aGVyZSdzIHN0aWxsIGFuIGlubmVyIGJvdW5kYXJ5IHRoYXQgd291bGQgc2hvdyBhIGZhbGxiYWNrLFxuICAvLyB0aGVuIHdlIHN1c3BlbmQvcmVzdGFydCBmb3IgNTAwbXMgc2luY2UgdGhlIGxhc3QgdGltZSB3ZSBzaG93ZWQgYSBmYWxsYmFja1xuICAvLyBhbnl3aGVyZSBpbiB0aGUgdHJlZS4gVGhpcyBlZmZlY3RpdmVseSB0aHJvdHRsZXMgcHJvZ3Jlc3NpdmUgbG9hZGluZyBpbnRvIGFcbiAgLy8gY29uc2lzdGVudCB0cmFpbiBvZiBjb21taXRzLiBUaGlzIGFsc28gZ2l2ZXMgdXMgYW4gb3Bwb3J0dW5pdHkgdG8gcmVzdGFydCB0b1xuICAvLyBnZXQgdG8gdGhlIGNvbXBsZXRlZCBzdGF0ZSBzbGlnaHRseSBlYXJsaWVyLlxuICAvL1xuICAvLyBJZiB0aGVyZSdzIGFtYmlndWl0eSBkdWUgdG8gYmF0Y2hpbmcgaXQncyByZXNvbHZlZCBpbiBwcmVmZXJlbmNlIG9mOlxuICAvLyAxKSBcImRlbGF5ZWRcIiwgMikgXCJpbml0aWFsIHJlbmRlclwiLCAzKSBcInJldHJ5XCIuXG4gIC8vXG4gIC8vIFdlIHdhbnQgdG8gZW5zdXJlIHRoYXQgYSBcImJ1c3lcIiBzdGF0ZSBkb2Vzbid0IGdldCBmb3JjZSBjb21taXR0ZWQuIFdlIHdhbnQgdG9cbiAgLy8gZW5zdXJlIHRoYXQgbmV3IGluaXRpYWwgbG9hZGluZyBzdGF0ZXMgY2FuIGNvbW1pdCBhcyBzb29uIGFzIHBvc3NpYmxlLlxuXG5cbiAgc3VzcGVuc2VCb3VuZGFyeS5mbGFncyB8PSBTaG91bGRDYXB0dXJlOyAvLyBUT0RPOiBJIHRoaW5rIHdlIGNhbiByZW1vdmUgdGhpcywgc2luY2Ugd2Ugbm93IHVzZSBgRGlkQ2FwdHVyZWAgaW5cbiAgLy8gdGhlIGJlZ2luIHBoYXNlIHRvIHByZXZlbnQgYW4gZWFybHkgYmFpbG91dC5cblxuICBzdXNwZW5zZUJvdW5kYXJ5LmxhbmVzID0gcm9vdFJlbmRlckxhbmVzO1xuICByZXR1cm4gc3VzcGVuc2VCb3VuZGFyeTtcbn1cblxuZnVuY3Rpb24gdGhyb3dFeGNlcHRpb24ocm9vdCwgcmV0dXJuRmliZXIsIHNvdXJjZUZpYmVyLCB2YWx1ZSwgcm9vdFJlbmRlckxhbmVzKSB7XG4gIC8vIFRoZSBzb3VyY2UgZmliZXIgZGlkIG5vdCBjb21wbGV0ZS5cbiAgc291cmNlRmliZXIuZmxhZ3MgfD0gSW5jb21wbGV0ZTtcblxuICB7XG4gICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICAvLyBJZiB3ZSBoYXZlIHBlbmRpbmcgd29yayBzdGlsbCwgcmVzdG9yZSB0aGUgb3JpZ2luYWwgdXBkYXRlcnNcbiAgICAgIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgcm9vdFJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH1cblxuICBpZiAodmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuXG4gICAgaWYgKHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgd2FrZWFibGUuIFRoZSBjb21wb25lbnQgc3VzcGVuZGVkLlxuICAgICAgdmFyIHdha2VhYmxlID0gdmFsdWU7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKGdldElzSHlkcmF0aW5nKCkgJiYgKGRpc2FibGVMZWdhY3lNb2RlICkpIHtcbiAgICAgICAgICBtYXJrRGlkVGhyb3dXaGlsZUh5ZHJhdGluZ0RFVigpO1xuICAgICAgICB9XG4gICAgICB9XG5cblxuICAgICAgdmFyIHN1c3BlbnNlQm91bmRhcnkgPSBnZXRTdXNwZW5zZUhhbmRsZXIoKTtcblxuICAgICAgaWYgKHN1c3BlbnNlQm91bmRhcnkgIT09IG51bGwpIHtcbiAgICAgICAgc3dpdGNoIChzdXNwZW5zZUJvdW5kYXJ5LnRhZykge1xuICAgICAgICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vIElmIHRoaXMgc3VzcGVuc2UgYm91bmRhcnkgaXMgbm90IGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrLCBtYXJrXG4gICAgICAgICAgICAgIC8vIHRoZSBpbi1wcm9ncmVzcyByZW5kZXIgYXMgc3VzcGVuZGVkLiBXZSB0cnkgdG8gcGVyZm9ybSB0aGlzIGxvZ2ljXG4gICAgICAgICAgICAgIC8vIGFzIHNvb24gYXMgc29vbiBhcyBwb3NzaWJsZSBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSwgc28gdGhlIHdvcmtcbiAgICAgICAgICAgICAgLy8gbG9vcCBjYW4ga25vdyB0aGluZ3MgbGlrZSB3aGV0aGVyIGl0J3MgT0sgdG8gc3dpdGNoIHRvIG90aGVyIHRhc2tzLFxuICAgICAgICAgICAgICAvLyBvciB3aGV0aGVyIGl0IGNhbiB3YWl0IGZvciBkYXRhIHRvIHJlc29sdmUgYmVmb3JlIGNvbnRpbnVpbmcuXG4gICAgICAgICAgICAgIC8vIFRPRE86IE1vc3Qgb2YgdGhlc2UgY2hlY2tzIGFyZSBhbHJlYWR5IHBlcmZvcm1lZCB3aGVuIGVudGVyaW5nIGFcbiAgICAgICAgICAgICAgLy8gU3VzcGVuc2UgYm91bmRhcnkuIFdlIHNob3VsZCB0cmFjayB0aGUgaW5mb3JtYXRpb24gb24gdGhlIHN0YWNrIHNvXG4gICAgICAgICAgICAgIC8vIHdlIGRvbid0IGhhdmUgdG8gcmVjb21wdXRlIGl0IG9uIGRlbWFuZC4gVGhpcyB3b3VsZCBhbHNvIGFsbG93IHVzXG4gICAgICAgICAgICAgIC8vIHRvIHVuaWZ5IHdpdGggYHVzZWAgd2hpY2ggbmVlZHMgdG8gcGVyZm9ybSB0aGlzIGxvZ2ljIGV2ZW4gc29vbmVyLFxuICAgICAgICAgICAgICAvLyBiZWZvcmUgYHRocm93RXhjZXB0aW9uYCBpcyBjYWxsZWQuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBpZiAoZ2V0U2hlbGxCb3VuZGFyeSgpID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAvLyBTdXNwZW5kZWQgaW4gdGhlIFwic2hlbGxcIiBvZiB0aGUgYXBwLiBUaGlzIGlzIGFuIHVuZGVzaXJhYmxlXG4gICAgICAgICAgICAgICAgICAvLyBsb2FkaW5nIHN0YXRlLiBXZSBzaG91bGQgYXZvaWQgY29tbWl0dGluZyB0aGlzIHRyZWUuXG4gICAgICAgICAgICAgICAgICByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIC8vIElmIHdlIHN1c3BlbmRlZCBkZWVwZXIgdGhhbiB0aGUgc2hlbGwsIHdlIGRvbid0IG5lZWQgdG8gZGVsYXlcbiAgICAgICAgICAgICAgICAgIC8vIHRoZSBjb21tbWl0LiBIb3dldmVyLCB3ZSBzdGlsbCBjYWxsIHJlbmRlckRpZFN1c3BlbmQgaWYgdGhpcyBpc1xuICAgICAgICAgICAgICAgICAgLy8gYSBuZXcgYm91bmRhcnksIHRvIHRlbGwgdGhlIHdvcmsgbG9vcCB0aGF0IGEgbmV3IGZhbGxiYWNrIGhhc1xuICAgICAgICAgICAgICAgICAgLy8gYXBwZWFyZWQgZHVyaW5nIHRoaXMgcmVuZGVyLlxuICAgICAgICAgICAgICAgICAgLy8gVE9ETzogVGhlb3JldGljYWxseSB3ZSBzaG91bGQgYmUgYWJsZSB0byBkZWxldGUgdGhpcyBicmFuY2guXG4gICAgICAgICAgICAgICAgICAvLyBJdCdzIGN1cnJlbnRseSB1c2VkIGZvciB0d28gdGhpbmdzOiAxKSB0byB0aHJvdHRsZSB0aGVcbiAgICAgICAgICAgICAgICAgIC8vIGFwcGVhcmFuY2Ugb2Ygc3VjY2Vzc2l2ZSBsb2FkaW5nIHN0YXRlcywgYW5kIDIpIGluXG4gICAgICAgICAgICAgICAgICAvLyBTdXNwZW5zZUxpc3QsIHRvIGRldGVybWluZSB3aGV0aGVyIHRoZSBjaGlsZHJlbiBpbmNsdWRlIGFueVxuICAgICAgICAgICAgICAgICAgLy8gcGVuZGluZyBmYWxsYmFja3MuIEZvciAxLCB3ZSBzaG91bGQgYXBwbHkgdGhyb3R0bGluZyB0byBhbGxcbiAgICAgICAgICAgICAgICAgIC8vIHJldHJpZXMsIG5vdCBqdXN0IG9uZXMgdGhhdCByZW5kZXIgYW4gYWRkaXRpb25hbCBmYWxsYmFjay4gRm9yXG4gICAgICAgICAgICAgICAgICAvLyAyLCB3ZSBzaG91bGQgY2hlY2sgc3VidHJlZUZsYWdzIGluc3RlYWQuIFRoZW4gd2UgY2FuIGRlbGV0ZVxuICAgICAgICAgICAgICAgICAgLy8gdGhpcyBicmFuY2guXG4gICAgICAgICAgICAgICAgICB2YXIgY3VycmVudCA9IHN1c3BlbnNlQm91bmRhcnkuYWx0ZXJuYXRlO1xuXG4gICAgICAgICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJEaWRTdXNwZW5kKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc3VzcGVuc2VCb3VuZGFyeS5mbGFncyAmPSB+Rm9yY2VDbGllbnRSZW5kZXI7XG4gICAgICAgICAgICAgIG1hcmtTdXNwZW5zZUJvdW5kYXJ5U2hvdWxkQ2FwdHVyZShzdXNwZW5zZUJvdW5kYXJ5LCByZXR1cm5GaWJlciwgc291cmNlRmliZXIsIHJvb3QsIHJvb3RSZW5kZXJMYW5lcyk7IC8vIFJldHJ5IGxpc3RlbmVyXG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIC8vIElmIHRoZSBmYWxsYmFjayBkb2VzIGNvbW1pdCwgd2UgbmVlZCB0byBhdHRhY2ggYSBkaWZmZXJlbnQgdHlwZSBvZlxuICAgICAgICAgICAgICAvLyBsaXN0ZW5lci4gVGhpcyBvbmUgc2NoZWR1bGVzIGFuIHVwZGF0ZSBvbiB0aGUgU3VzcGVuc2UgYm91bmRhcnkgdG9cbiAgICAgICAgICAgICAgLy8gdHVybiB0aGUgZmFsbGJhY2sgc3RhdGUgb2ZmLlxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvLyBTdGFzaCB0aGUgd2FrZWFibGUgb24gdGhlIGJvdW5kYXJ5IGZpYmVyIHNvIHdlIGNhbiBhY2Nlc3MgaXQgaW4gdGhlXG4gICAgICAgICAgICAgIC8vIGNvbW1pdCBwaGFzZS5cbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgLy8gV2hlbiB0aGUgd2FrZWFibGUgcmVzb2x2ZXMsIHdlJ2xsIGF0dGVtcHQgdG8gcmVuZGVyIHRoZSBib3VuZGFyeVxuICAgICAgICAgICAgICAvLyBhZ2FpbiAoXCJyZXRyeVwiKS5cbiAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIFN1c3BlbnNleSByZXNvdXJjZS4gV2UgZG8gbm90IGF0dGFjaCByZXRyeVxuICAgICAgICAgICAgICAvLyBsaXN0ZW5lcnMgdG8gdGhlc2UsIGJlY2F1c2Ugd2UgZG9uJ3QgYWN0dWFsbHkgbmVlZCB0aGVtIGZvclxuICAgICAgICAgICAgICAvLyByZW5kZXJpbmcuIE9ubHkgZm9yIGNvbW1pdHRpbmcuIEluc3RlYWQsIGlmIGEgZmFsbGJhY2sgY29tbWl0c1xuICAgICAgICAgICAgICAvLyBhbmQgdGhlIG9ubHkgdGhpbmcgdGhhdCBzdXNwZW5kZWQgd2FzIGEgU3VzcGVuc2V5IHJlc291cmNlLCB3ZVxuICAgICAgICAgICAgICAvLyByZXRyeSBpbW1lZGlhdGVseS5cbiAgICAgICAgICAgICAgLy8gVE9ETzogUmVmYWN0b3IgdGhyb3dFeGNlcHRpb24gc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIGRvIHRoaXMgdHlwZVxuICAgICAgICAgICAgICAvLyBjaGVjay4gVGhlIGNhbGxlciBhbHJlYWR5IGtub3dzIHdoYXQgdGhlIGNhdXNlIHdhcy5cblxuICAgICAgICAgICAgICB2YXIgaXNTdXNwZW5zZXlSZXNvdXJjZSA9IHdha2VhYmxlID09PSBub29wU3VzcGVuc2V5Q29tbWl0VGhlbmFibGU7XG5cbiAgICAgICAgICAgICAgaWYgKGlzU3VzcGVuc2V5UmVzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICBzdXNwZW5zZUJvdW5kYXJ5LmZsYWdzIHw9IFNjaGVkdWxlUmV0cnk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldHJ5UXVldWUgPSBzdXNwZW5zZUJvdW5kYXJ5LnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJldHJ5UXVldWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHN1c3BlbnNlQm91bmRhcnkudXBkYXRlUXVldWUgPSBuZXcgU2V0KFt3YWtlYWJsZV0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXRyeVF1ZXVlLmFkZCh3YWtlYWJsZSk7XG4gICAgICAgICAgICAgICAgfSAvLyBXZSBvbmx5IGF0dGFjaCBwaW5nIGxpc3RlbmVycyBpbiBjb25jdXJyZW50IG1vZGUuIExlZ2FjeVxuICAgICAgICAgICAgICAgIC8vIFN1c3BlbnNlIGFsd2F5cyBjb21taXRzIGZhbGxiYWNrcyBzeW5jaHJvbm91c2x5LCBzbyB0aGVyZSBhcmVcbiAgICAgICAgICAgICAgICAvLyBubyBwaW5ncy5cblxuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHdha2VhYmxlLCByb290UmVuZGVyTGFuZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgc3VzcGVuc2VCb3VuZGFyeS5mbGFncyB8PSBTaG91bGRDYXB0dXJlO1xuXG4gICAgICAgICAgICAgICAgdmFyIF9pc1N1c3BlbnNleVJlc291cmNlID0gd2FrZWFibGUgPT09IG5vb3BTdXNwZW5zZXlDb21taXRUaGVuYWJsZTtcblxuICAgICAgICAgICAgICAgIGlmIChfaXNTdXNwZW5zZXlSZXNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgc3VzcGVuc2VCb3VuZGFyeS5mbGFncyB8PSBTY2hlZHVsZVJldHJ5O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB2YXIgb2Zmc2NyZWVuUXVldWUgPSBzdXNwZW5zZUJvdW5kYXJ5LnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgICAgICAgICAgICBpZiAob2Zmc2NyZWVuUXVldWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5ld09mZnNjcmVlblF1ZXVlID0ge1xuICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25zOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIG1hcmtlckluc3RhbmNlczogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICByZXRyeVF1ZXVlOiBuZXcgU2V0KFt3YWtlYWJsZV0pXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHN1c3BlbnNlQm91bmRhcnkudXBkYXRlUXVldWUgPSBuZXdPZmZzY3JlZW5RdWV1ZTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfcmV0cnlRdWV1ZSA9IG9mZnNjcmVlblF1ZXVlLnJldHJ5UXVldWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9yZXRyeVF1ZXVlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgb2Zmc2NyZWVuUXVldWUucmV0cnlRdWV1ZSA9IG5ldyBTZXQoW3dha2VhYmxlXSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3JldHJ5UXVldWUuYWRkKHdha2VhYmxlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICBhdHRhY2hQaW5nTGlzdGVuZXIocm9vdCwgd2FrZWFibGUsIHJvb3RSZW5kZXJMYW5lcyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIFN1c3BlbnNlIGhhbmRsZXIgdGFnIChcIiArIHN1c3BlbnNlQm91bmRhcnkudGFnICsgXCIpLiBUaGlzIFwiICsgJ2lzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gTm8gYm91bmRhcnkgd2FzIGZvdW5kLiBVbmxlc3MgdGhpcyBpcyBhIHN5bmMgdXBkYXRlLCB0aGlzIGlzIE9LLlxuICAgICAgICAvLyBXZSBjYW4gc3VzcGVuZCBhbmQgd2FpdCBmb3IgbW9yZSBkYXRhIHRvIGFycml2ZS5cbiAgICAgICAge1xuICAgICAgICAgIC8vIEluIGEgY29uY3VycmVudCByb290LCBzdXNwZW5kaW5nIHdpdGhvdXQgYSBTdXNwZW5zZSBib3VuZGFyeSBpc1xuICAgICAgICAgIC8vIGFsbG93ZWQuIEl0IHdpbGwgc3VzcGVuZCBpbmRlZmluaXRlbHkgd2l0aG91dCBjb21taXR0aW5nLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gVE9ETzogU2hvdWxkIHdlIGhhdmUgZGlmZmVyZW50IGJlaGF2aW9yIGZvciBkaXNjcmV0ZSB1cGRhdGVzPyBXaGF0XG4gICAgICAgICAgLy8gYWJvdXQgZmx1c2hTeW5jPyBNYXliZSBpdCBzaG91bGQgcHV0IHRoZSB0cmVlIGludG8gYW4gaW5lcnQgc3RhdGUsXG4gICAgICAgICAgLy8gYW5kIHBvdGVudGlhbGx5IGxvZyBhIHdhcm5pbmcuIFJldmlzaXQgdGhpcyBmb3IgYSBmdXR1cmUgcmVsZWFzZS5cbiAgICAgICAgICBhdHRhY2hQaW5nTGlzdGVuZXIocm9vdCwgd2FrZWFibGUsIHJvb3RSZW5kZXJMYW5lcyk7XG4gICAgICAgICAgcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBUaGlzIGlzIGEgcmVndWxhciBlcnJvciwgbm90IGEgU3VzcGVuc2Ugd2FrZWFibGUuXG5cblxuICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSAmJiAoZGlzYWJsZUxlZ2FjeU1vZGUgKSkge1xuICAgIG1hcmtEaWRUaHJvd1doaWxlSHlkcmF0aW5nREVWKCk7XG5cbiAgICB2YXIgX3N1c3BlbnNlQm91bmRhcnkgPSBnZXRTdXNwZW5zZUhhbmRsZXIoKTsgLy8gSWYgdGhlIGVycm9yIHdhcyB0aHJvd24gZHVyaW5nIGh5ZHJhdGlvbiwgd2UgbWF5IGJlIGFibGUgdG8gcmVjb3ZlciBieVxuICAgIC8vIGRpc2NhcmRpbmcgdGhlIGRlaHlkcmF0ZWQgY29udGVudCBhbmQgc3dpdGNoaW5nIHRvIGEgY2xpZW50IHJlbmRlci5cbiAgICAvLyBJbnN0ZWFkIG9mIHN1cmZhY2luZyB0aGUgZXJyb3IsIGZpbmQgdGhlIG5lYXJlc3QgU3VzcGVuc2UgYm91bmRhcnlcbiAgICAvLyBhbmQgcmVuZGVyIGl0IGFnYWluIHdpdGhvdXQgaHlkcmF0aW9uLlxuXG5cbiAgICBpZiAoX3N1c3BlbnNlQm91bmRhcnkgIT09IG51bGwpIHtcbiAgICAgIGlmICgoX3N1c3BlbnNlQm91bmRhcnkuZmxhZ3MgJiBTaG91bGRDYXB0dXJlKSA9PT0gTm9GbGFncyQxKSB7XG4gICAgICAgIC8vIFNldCBhIGZsYWcgdG8gaW5kaWNhdGUgdGhhdCB3ZSBzaG91bGQgdHJ5IHJlbmRlcmluZyB0aGUgbm9ybWFsXG4gICAgICAgIC8vIGNoaWxkcmVuIGFnYWluLCBub3QgdGhlIGZhbGxiYWNrLlxuICAgICAgICBfc3VzcGVuc2VCb3VuZGFyeS5mbGFncyB8PSBGb3JjZUNsaWVudFJlbmRlcjtcbiAgICAgIH1cblxuICAgICAgbWFya1N1c3BlbnNlQm91bmRhcnlTaG91bGRDYXB0dXJlKF9zdXNwZW5zZUJvdW5kYXJ5LCByZXR1cm5GaWJlciwgc291cmNlRmliZXIsIHJvb3QsIHJvb3RSZW5kZXJMYW5lcyk7IC8vIEV2ZW4gdGhvdWdoIHRoZSB1c2VyIG1heSBub3QgYmUgYWZmZWN0ZWQgYnkgdGhpcyBlcnJvciwgd2Ugc2hvdWxkXG4gICAgICAvLyBzdGlsbCBsb2cgaXQgc28gaXQgY2FuIGJlIGZpeGVkLlxuXG4gICAgICBpZiAodmFsdWUgIT09IEh5ZHJhdGlvbk1pc21hdGNoRXhjZXB0aW9uKSB7XG4gICAgICAgIHZhciBfd3JhcHBlckVycm9yID0gbmV3IEVycm9yKCdUaGVyZSB3YXMgYW4gZXJyb3Igd2hpbGUgaHlkcmF0aW5nIGJ1dCBSZWFjdCB3YXMgYWJsZSB0byByZWNvdmVyIGJ5ICcgKyAnaW5zdGVhZCBjbGllbnQgcmVuZGVyaW5nIGZyb20gdGhlIG5lYXJlc3QgU3VzcGVuc2UgYm91bmRhcnkuJywge1xuICAgICAgICAgIGNhdXNlOiB2YWx1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBxdWV1ZUh5ZHJhdGlvbkVycm9yKGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKF93cmFwcGVyRXJyb3IsIHNvdXJjZUZpYmVyKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHZhbHVlICE9PSBIeWRyYXRpb25NaXNtYXRjaEV4Y2VwdGlvbikge1xuICAgICAgICB2YXIgX3dyYXBwZXJFcnJvcjIgPSBuZXcgRXJyb3IoJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBoeWRyYXRpbmcgYnV0IFJlYWN0IHdhcyBhYmxlIHRvIHJlY292ZXIgYnkgJyArICdpbnN0ZWFkIGNsaWVudCByZW5kZXJpbmcgdGhlIGVudGlyZSByb290LicsIHtcbiAgICAgICAgICBjYXVzZTogdmFsdWVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcXVldWVIeWRyYXRpb25FcnJvcihjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihfd3JhcHBlckVycm9yMiwgc291cmNlRmliZXIpKTtcbiAgICAgIH1cblxuICAgICAgdmFyIF93b3JrSW5Qcm9ncmVzcyA9IHJvb3QuY3VycmVudC5hbHRlcm5hdGU7IC8vIFNjaGVkdWxlIGFuIHVwZGF0ZSBhdCB0aGUgcm9vdCB0byBsb2cgdGhlIGVycm9yIGJ1dCB0aGlzIHNob3VsZG4ndFxuICAgICAgLy8gYWN0dWFsbHkgaGFwcGVuIGJlY2F1c2Ugd2Ugc2hvdWxkIHJlY292ZXIuXG5cbiAgICAgIF93b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTaG91bGRDYXB0dXJlO1xuICAgICAgdmFyIGxhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShyb290UmVuZGVyTGFuZXMpO1xuICAgICAgX3dvcmtJblByb2dyZXNzLmxhbmVzID0gbWVyZ2VMYW5lcyhfd29ya0luUHJvZ3Jlc3MubGFuZXMsIGxhbmUpO1xuICAgICAgdmFyIHJvb3RFcnJvckluZm8gPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih2YWx1ZSwgc291cmNlRmliZXIpO1xuICAgICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShfd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLCByb290RXJyb3JJbmZvLCAvLyBUaGlzIHNob3VsZCBuZXZlciBhY3R1YWxseSBnZXQgbG9nZ2VkIGR1ZSB0byB0aGUgcmVjb3ZlcnkuXG4gICAgICBsYW5lKTtcbiAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZShfd29ya0luUHJvZ3Jlc3MsIHVwZGF0ZSk7XG4gICAgICByZW5kZXJEaWRFcnJvcigpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHZhciB3cmFwcGVyRXJyb3IgPSBuZXcgRXJyb3IoJ1RoZXJlIHdhcyBhbiBlcnJvciBkdXJpbmcgY29uY3VycmVudCByZW5kZXJpbmcgYnV0IFJlYWN0IHdhcyBhYmxlIHRvIHJlY292ZXIgYnkgJyArICdpbnN0ZWFkIHN5bmNocm9ub3VzbHkgcmVuZGVyaW5nIHRoZSBlbnRpcmUgcm9vdC4nLCB7XG4gICAgY2F1c2U6IHZhbHVlXG4gIH0pO1xuICBxdWV1ZUNvbmN1cnJlbnRFcnJvcihjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih3cmFwcGVyRXJyb3IsIHNvdXJjZUZpYmVyKSk7XG4gIHJlbmRlckRpZEVycm9yKCk7IC8vIFdlIGRpZG4ndCBmaW5kIGEgYm91bmRhcnkgdGhhdCBjb3VsZCBoYW5kbGUgdGhpcyB0eXBlIG9mIGV4Y2VwdGlvbi4gU3RhcnRcbiAgLy8gb3ZlciBhbmQgdHJhdmVyc2UgcGFyZW50IHBhdGggYWdhaW4sIHRoaXMgdGltZSB0cmVhdGluZyB0aGUgZXhjZXB0aW9uXG4gIC8vIGFzIGFuIGVycm9yLlxuXG4gIGlmIChyZXR1cm5GaWJlciA9PT0gbnVsbCkge1xuICAgIC8vIFRoZXJlJ3Mgbm8gcmV0dXJuIGZpYmVyLCB3aGljaCBtZWFucyB0aGUgcm9vdCBlcnJvcmVkLiBUaGlzIHNob3VsZCBuZXZlclxuICAgIC8vIGhhcHBlbi4gUmV0dXJuIGB0cnVlYCB0byB0cmlnZ2VyIGEgZmF0YWwgZXJyb3IgKHBhbmljKS5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHZhciBlcnJvckluZm8gPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih2YWx1ZSwgc291cmNlRmliZXIpO1xuICB2YXIgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcblxuICBkbyB7XG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTaG91bGRDYXB0dXJlO1xuXG4gICAgICAgICAgdmFyIF9sYW5lID0gcGlja0FyYml0cmFyeUxhbmUocm9vdFJlbmRlckxhbmVzKTtcblxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzcy5sYW5lcywgX2xhbmUpO1xuXG4gICAgICAgICAgdmFyIF91cGRhdGUgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLCBlcnJvckluZm8sIF9sYW5lKTtcblxuICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgX3VwZGF0ZSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIC8vIENhcHR1cmUgYW5kIHJldHJ5XG4gICAgICAgIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gTm9GbGFncyQxICYmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPT09ICdmdW5jdGlvbicgfHwgaW5zdGFuY2UgIT09IG51bGwgJiYgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nICYmICFpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSkpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTaG91bGRDYXB0dXJlO1xuXG4gICAgICAgICAgdmFyIF9sYW5lMiA9IHBpY2tBcmJpdHJhcnlMYW5lKHJvb3RSZW5kZXJMYW5lcyk7XG5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3MubGFuZXMsIF9sYW5lMik7IC8vIFNjaGVkdWxlIHRoZSBlcnJvciBib3VuZGFyeSB0byByZS1yZW5kZXIgdXNpbmcgdXBkYXRlZCBzdGF0ZVxuXG4gICAgICAgICAgdmFyIF91cGRhdGUyID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShfbGFuZTIpO1xuXG4gICAgICAgICAgaW5pdGlhbGl6ZUNsYXNzRXJyb3JVcGRhdGUoX3VwZGF0ZTIsIHJvb3QsIHdvcmtJblByb2dyZXNzLCBlcnJvckluZm8pO1xuICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgX3VwZGF0ZTIpO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gd2UgYmFpbCBvdXQgd2hlbiB3ZSBnZXQgYSBudWxsXG5cblxuICAgIHdvcmtJblByb2dyZXNzID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICB9IHdoaWxlICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCk7XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBpbnRvIGEgZGVoeWRyYXRlZCBib3VuZGFyeS5cblxudmFyIFNlbGVjdGl2ZUh5ZHJhdGlvbkV4Y2VwdGlvbiA9IG5ldyBFcnJvcihcIlRoaXMgaXMgbm90IGEgcmVhbCBlcnJvci4gSXQncyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgb2YgUmVhY3QncyBcIiArIFwic2VsZWN0aXZlIGh5ZHJhdGlvbiBmZWF0dXJlLiBJZiB0aGlzIGxlYWtzIGludG8gdXNlcnNwYWNlLCBpdCdzIGEgYnVnIGluIFwiICsgJ1JlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbnZhciBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG52YXIgZGlkV2FybkFib3V0QmFkQ2xhc3M7XG52YXIgZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50O1xudmFyIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnQ7XG52YXIgZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcztcbnZhciBkaWRXYXJuQWJvdXRSZXZlYWxPcmRlcjtcbnZhciBkaWRXYXJuQWJvdXRUYWlsT3B0aW9ucztcblxue1xuICBkaWRXYXJuQWJvdXRCYWRDbGFzcyA9IHt9O1xuICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQgPSB7fTtcbiAgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9O1xuICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzID0gZmFsc2U7XG4gIGRpZFdhcm5BYm91dFJldmVhbE9yZGVyID0ge307XG4gIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zID0ge307XG59XG5cbmZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgLy8gSWYgdGhpcyBpcyBhIGZyZXNoIG5ldyBjb21wb25lbnQgdGhhdCBoYXNuJ3QgYmVlbiByZW5kZXJlZCB5ZXQsIHdlXG4gICAgLy8gd29uJ3QgdXBkYXRlIGl0cyBjaGlsZCBzZXQgYnkgYXBwbHlpbmcgbWluaW1hbCBzaWRlLWVmZmVjdHMuIEluc3RlYWQsXG4gICAgLy8gd2Ugd2lsbCBhZGQgdGhlbSBhbGwgdG8gdGhlIGNoaWxkIGJlZm9yZSBpdCBnZXRzIHJlbmRlcmVkLiBUaGF0IG1lYW5zXG4gICAgLy8gd2UgY2FuIG9wdGltaXplIHRoaXMgcmVjb25jaWxpYXRpb24gcGFzcyBieSBub3QgdHJhY2tpbmcgc2lkZS1lZmZlY3RzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbW91bnRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgdGhlIGN1cnJlbnQgY2hpbGQgaXMgdGhlIHNhbWUgYXMgdGhlIHdvcmsgaW4gcHJvZ3Jlc3MsIGl0IG1lYW5zIHRoYXRcbiAgICAvLyB3ZSBoYXZlbid0IHlldCBzdGFydGVkIGFueSB3b3JrIG9uIHRoZXNlIGNoaWxkcmVuLiBUaGVyZWZvcmUsIHdlIHVzZVxuICAgIC8vIHRoZSBjbG9uZSBhbGdvcml0aG0gdG8gY3JlYXRlIGEgY29weSBvZiBhbGwgdGhlIGN1cnJlbnQgY2hpbGRyZW4uXG4gICAgLy8gSWYgd2UgaGFkIGFueSBwcm9ncmVzc2VkIHdvcmsgYWxyZWFkeSwgdGhhdCBpcyBpbnZhbGlkIGF0IHRoaXMgcG9pbnQgc29cbiAgICAvLyBsZXQncyB0aHJvdyBpdCBvdXQuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yY2VVbm1vdW50Q3VycmVudEFuZFJlY29uY2lsZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGZvcmsgb2YgcmVjb25jaWxlQ2hpbGRyZW4uIEl0J3MgdXNlZCBpbiBjYXNlcyB3aGVyZSB3ZVxuICAvLyB3YW50IHRvIHJlY29uY2lsZSB3aXRob3V0IG1hdGNoaW5nIGFnYWluc3QgdGhlIGV4aXN0aW5nIHNldC4gVGhpcyBoYXMgdGhlXG4gIC8vIGVmZmVjdCBvZiBhbGwgY3VycmVudCBjaGlsZHJlbiBiZWluZyB1bm1vdW50ZWQ7IGV2ZW4gaWYgdGhlIHR5cGUgYW5kIGtleVxuICAvLyBhcmUgdGhlIHNhbWUsIHRoZSBvbGQgY2hpbGQgaXMgdW5tb3VudGVkIGFuZCBhIG5ldyBjaGlsZCBpcyBjcmVhdGVkLlxuICAvL1xuICAvLyBUbyBkbyB0aGlzLCB3ZSdyZSBnb2luZyB0byBnbyB0aHJvdWdoIHRoZSByZWNvbmNpbGUgYWxnb3JpdGhtIHR3aWNlLiBJblxuICAvLyB0aGUgZmlyc3QgcGFzcywgd2Ugc2NoZWR1bGUgYSBkZWxldGlvbiBmb3IgYWxsIHRoZSBjdXJyZW50IGNoaWxkcmVuIGJ5XG4gIC8vIHBhc3NpbmcgbnVsbC5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbnVsbCwgcmVuZGVyTGFuZXMpOyAvLyBJbiB0aGUgc2Vjb25kIHBhc3MsIHdlIG1vdW50IHRoZSBuZXcgY2hpbGRyZW4uIFRoZSB0cmljayBoZXJlIGlzIHRoYXQgd2VcbiAgLy8gcGFzcyBudWxsIGluIHBsYWNlIG9mIHdoZXJlIHdlIHVzdWFsbHkgcGFzcyB0aGUgY3VycmVudCBjaGlsZCBzZXQuIFRoaXMgaGFzXG4gIC8vIHRoZSBlZmZlY3Qgb2YgcmVtb3VudGluZyBhbGwgY2hpbGRyZW4gcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZWlyXG4gIC8vIGlkZW50aXRpZXMgbWF0Y2guXG5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUZvcndhcmRSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuICAvLyBUT0RPOiBjdXJyZW50IGNhbiBiZSBub24tbnVsbCBoZXJlIGV2ZW4gaWYgdGhlIGNvbXBvbmVudFxuICAvLyBoYXNuJ3QgeWV0IG1vdW50ZWQuIFRoaXMgaGFwcGVucyBhZnRlciB0aGUgZmlyc3QgcmVuZGVyIHN1c3BlbmRzLlxuICAvLyBXZSdsbCBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgdGhpcyBpcyBmaW5lIG9yIGNhbiBjYXVzZSBpc3N1ZXMuXG4gIHZhciByZW5kZXIgPSBDb21wb25lbnQucmVuZGVyO1xuICB2YXIgcmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICB2YXIgcHJvcHNXaXRob3V0UmVmO1xuXG4gIGlmICgncmVmJyBpbiBuZXh0UHJvcHMpIHtcbiAgICAvLyBgcmVmYCBpcyBqdXN0IGEgcHJvcCBub3csIGJ1dCBgZm9yd2FyZFJlZmAgZXhwZWN0cyBpdCB0byBub3QgYXBwZWFyIGluXG4gICAgLy8gdGhlIHByb3BzIG9iamVjdC4gVGhpcyB1c2VkIHRvIGhhcHBlbiBpbiB0aGUgSlNYIHJ1bnRpbWUsIGJ1dCBub3cgd2UgZG9cbiAgICAvLyBpdCBoZXJlLlxuICAgIHByb3BzV2l0aG91dFJlZiA9IHt9O1xuXG4gICAgZm9yICh2YXIga2V5IGluIG5leHRQcm9wcykge1xuICAgICAgLy8gU2luY2UgYHJlZmAgc2hvdWxkIG9ubHkgYXBwZWFyIGluIHByb3BzIHZpYSB0aGUgSlNYIHRyYW5zZm9ybSwgd2UgY2FuXG4gICAgICAvLyBhc3N1bWUgdGhhdCB0aGlzIGlzIGEgcGxhaW4gb2JqZWN0LiBTbyB3ZSBkb24ndCBuZWVkIGFcbiAgICAgIC8vIGhhc093blByb3BlcnR5IGNoZWNrLlxuICAgICAgaWYgKGtleSAhPT0gJ3JlZicpIHtcbiAgICAgICAgcHJvcHNXaXRob3V0UmVmW2tleV0gPSBuZXh0UHJvcHNba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcHJvcHNXaXRob3V0UmVmID0gbmV4dFByb3BzO1xuICB9IC8vIFRoZSByZXN0IGlzIGEgZm9yayBvZiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudFxuXG5cbiAgdmFyIG5leHRDaGlsZHJlbjtcbiAgdmFyIGhhc0lkO1xuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gIHtcbiAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICB7XG4gICAgc2V0SXNSZW5kZXJpbmcodHJ1ZSk7XG4gICAgbmV4dENoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXIsIHByb3BzV2l0aG91dFJlZiwgcmVmLCByZW5kZXJMYW5lcyk7XG4gICAgaGFzSWQgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuICAgIHNldElzUmVuZGVyaW5nKGZhbHNlKTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICB9XG5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFJlY2VpdmVVcGRhdGUpIHtcbiAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgaWYgKGdldElzSHlkcmF0aW5nKCkgJiYgaGFzSWQpIHtcbiAgICBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTtcbiAgfSAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG5cblxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQZXJmb3JtZWRXb3JrO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlTWVtb0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgdmFyIHR5cGUgPSBDb21wb25lbnQudHlwZTtcblxuICAgIGlmIChpc1NpbXBsZUZ1bmN0aW9uQ29tcG9uZW50KHR5cGUpICYmIENvbXBvbmVudC5jb21wYXJlID09PSBudWxsICYmICggLy8gU2ltcGxlTWVtb0NvbXBvbmVudCBjb2RlcGF0aCBkb2Vzbid0IHJlc29sdmUgb3V0ZXIgcHJvcHMgZWl0aGVyLlxuICAgIGRpc2FibGVEZWZhdWx0UHJvcHNFeGNlcHRGb3JDbGFzc2VzICkpIHtcbiAgICAgIHZhciByZXNvbHZlZFR5cGUgPSB0eXBlO1xuXG4gICAgICB7XG4gICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlKTtcbiAgICAgIH0gLy8gSWYgdGhpcyBpcyBhIHBsYWluIGZ1bmN0aW9uIGNvbXBvbmVudCB3aXRob3V0IGRlZmF1bHQgcHJvcHMsXG4gICAgICAvLyBhbmQgd2l0aCBvbmx5IHRoZSBkZWZhdWx0IHNoYWxsb3cgY29tcGFyaXNvbiwgd2UgdXBncmFkZSBpdFxuICAgICAgLy8gdG8gYSBTaW1wbGVNZW1vQ29tcG9uZW50IHRvIGFsbG93IGZhc3QgcGF0aCB1cGRhdGVzLlxuXG5cbiAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IFNpbXBsZU1lbW9Db21wb25lbnQ7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZWRUeXBlO1xuXG4gICAgICB7XG4gICAgICAgIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgdHlwZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZXNvbHZlZFR5cGUsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyhDb21wb25lbnQudHlwZSwgbnVsbCwgbmV4dFByb3BzLCB3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MubW9kZSwgcmVuZGVyTGFuZXMpO1xuICAgIGNoaWxkLnJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcbiAgICBjaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGNoaWxkO1xuICAgIHJldHVybiBjaGlsZDtcbiAgfVxuXG4gIHZhciBjdXJyZW50Q2hpbGQgPSBjdXJyZW50LmNoaWxkOyAvLyBUaGlzIGlzIGFsd2F5cyBleGFjdGx5IG9uZSBjaGlsZFxuXG4gIHZhciBoYXNTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQgPSBjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LCByZW5kZXJMYW5lcyk7XG5cbiAgaWYgKCFoYXNTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQpIHtcbiAgICAvLyBUaGlzIHdpbGwgYmUgdGhlIHByb3BzIHdpdGggcmVzb2x2ZWQgZGVmYXVsdFByb3BzLFxuICAgIC8vIHVubGlrZSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgd2hpY2ggd2lsbCBiZSB0aGUgdW5yZXNvbHZlZCBvbmVzLlxuICAgIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50Q2hpbGQubWVtb2l6ZWRQcm9wczsgLy8gRGVmYXVsdCB0byBzaGFsbG93IGNvbXBhcmlzb25cblxuICAgIHZhciBjb21wYXJlID0gQ29tcG9uZW50LmNvbXBhcmU7XG4gICAgY29tcGFyZSA9IGNvbXBhcmUgIT09IG51bGwgPyBjb21wYXJlIDogc2hhbGxvd0VxdWFsO1xuXG4gICAgaWYgKGNvbXBhcmUocHJldlByb3BzLCBuZXh0UHJvcHMpICYmIGN1cnJlbnQucmVmID09PSB3b3JrSW5Qcm9ncmVzcy5yZWYpIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgfVxuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG4gIHZhciBuZXdDaGlsZCA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnRDaGlsZCwgbmV4dFByb3BzKTtcbiAgbmV3Q2hpbGQucmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICBuZXdDaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBuZXdDaGlsZDtcbiAgcmV0dXJuIG5ld0NoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAgLy8gVE9ETzogY3VycmVudCBjYW4gYmUgbm9uLW51bGwgaGVyZSBldmVuIGlmIHRoZSBjb21wb25lbnRcbiAgLy8gaGFzbid0IHlldCBtb3VudGVkLiBUaGlzIGhhcHBlbnMgd2hlbiB0aGUgaW5uZXIgcmVuZGVyIHN1c3BlbmRzLlxuICAvLyBXZSdsbCBuZWVkIHRvIGZpZ3VyZSBvdXQgaWYgdGhpcyBpcyBmaW5lIG9yIGNhbiBjYXVzZSBpc3N1ZXMuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcblxuICAgIGlmIChzaGFsbG93RXF1YWwocHJldlByb3BzLCBuZXh0UHJvcHMpICYmIGN1cnJlbnQucmVmID09PSB3b3JrSW5Qcm9ncmVzcy5yZWYgJiYgKCAvLyBQcmV2ZW50IGJhaWxvdXQgaWYgdGhlIGltcGxlbWVudGF0aW9uIGNoYW5nZWQgZHVlIHRvIGhvdCByZWxvYWQuXG4gICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9PT0gY3VycmVudC50eXBlICkpIHtcbiAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSBmYWxzZTsgLy8gVGhlIHByb3BzIGFyZSBzaGFsbG93bHkgZXF1YWwuIFJldXNlIHRoZSBwcmV2aW91cyBwcm9wcyBvYmplY3QsIGxpa2Ugd2VcbiAgICAgIC8vIHdvdWxkIGR1cmluZyBhIG5vcm1hbCBmaWJlciBiYWlsb3V0LlxuICAgICAgLy9cbiAgICAgIC8vIFdlIGRvbid0IGhhdmUgc3Ryb25nIGd1YXJhbnRlZXMgdGhhdCB0aGUgcHJvcHMgb2JqZWN0IGlzIHJlZmVyZW50aWFsbHlcbiAgICAgIC8vIGVxdWFsIGR1cmluZyB1cGRhdGVzIHdoZXJlIHdlIGNhbid0IGJhaWwgb3V0IGFueXdheSDigJQgbGlrZSBpZiB0aGUgcHJvcHNcbiAgICAgIC8vIGFyZSBzaGFsbG93bHkgZXF1YWwsIGJ1dCB0aGVyZSdzIGEgbG9jYWwgc3RhdGUgb3IgY29udGV4dCB1cGRhdGUgaW4gdGhlXG4gICAgICAvLyBzYW1lIGJhdGNoLlxuICAgICAgLy9cbiAgICAgIC8vIEhvd2V2ZXIsIGFzIGEgcHJpbmNpcGxlLCB3ZSBzaG91bGQgYWltIHRvIG1ha2UgdGhlIGJlaGF2aW9yIGNvbnNpc3RlbnRcbiAgICAgIC8vIGFjcm9zcyBkaWZmZXJlbnQgd2F5cyBvZiBtZW1vaXppbmcgYSBjb21wb25lbnQuIEZvciBleGFtcGxlLCBSZWFjdC5tZW1vXG4gICAgICAvLyBoYXMgYSBkaWZmZXJlbnQgaW50ZXJuYWwgRmliZXIgbGF5b3V0IGlmIHlvdSBwYXNzIGEgbm9ybWFsIGZ1bmN0aW9uXG4gICAgICAvLyBjb21wb25lbnQgKFNpbXBsZU1lbW9Db21wb25lbnQpIHZlcnN1cyBpZiB5b3UgcGFzcyBhIGRpZmZlcmVudCB0eXBlXG4gICAgICAvLyBsaWtlIGZvcndhcmRSZWYgKE1lbW9Db21wb25lbnQpLiBCdXQgdGhpcyBpcyBhbiBpbXBsZW1lbnRhdGlvbiBkZXRhaWwuXG4gICAgICAvLyBXcmFwcGluZyBhIGNvbXBvbmVudCBpbiBmb3J3YXJkUmVmIChvciBSZWFjdC5sYXp5LCBldGMpIHNob3VsZG4ndFxuICAgICAgLy8gYWZmZWN0IHdoZXRoZXIgdGhlIHByb3BzIG9iamVjdCBpcyByZXVzZWQgZHVyaW5nIGEgYmFpbG91dC5cblxuICAgICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzID0gbmV4dFByb3BzID0gcHJldlByb3BzO1xuXG4gICAgICBpZiAoIWNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKSkge1xuICAgICAgICAvLyBUaGUgcGVuZGluZyBsYW5lcyB3ZXJlIGNsZWFyZWQgYXQgdGhlIGJlZ2lubmluZyBvZiBiZWdpbldvcmsuIFdlJ3JlXG4gICAgICAgIC8vIGFib3V0IHRvIGJhaWwgb3V0LCBidXQgdGhlcmUgbWlnaHQgYmUgb3RoZXIgbGFuZXMgdGhhdCB3ZXJlbid0XG4gICAgICAgIC8vIGluY2x1ZGVkIGluIHRoZSBjdXJyZW50IHJlbmRlci4gVXN1YWxseSwgdGhlIHByaW9yaXR5IGxldmVsIG9mIHRoZVxuICAgICAgICAvLyByZW1haW5pbmcgdXBkYXRlcyBpcyBhY2N1bXVsYXRlZCBkdXJpbmcgdGhlIGV2YWx1YXRpb24gb2YgdGhlXG4gICAgICAgIC8vIGNvbXBvbmVudCAoaS5lLiB3aGVuIHByb2Nlc3NpbmcgdGhlIHVwZGF0ZSBxdWV1ZSkuIEJ1dCBzaW5jZSBzaW5jZVxuICAgICAgICAvLyB3ZSdyZSBiYWlsaW5nIG91dCBlYXJseSAqd2l0aG91dCogZXZhbHVhdGluZyB0aGUgY29tcG9uZW50LCB3ZSBuZWVkXG4gICAgICAgIC8vIHRvIGFjY291bnQgZm9yIGl0IGhlcmUsIHRvby4gUmVzZXQgdG8gdGhlIHZhbHVlIG9mIHRoZSBjdXJyZW50IGZpYmVyLlxuICAgICAgICAvLyBOT1RFOiBUaGlzIG9ubHkgYXBwbGllcyB0byBTaW1wbGVNZW1vQ29tcG9uZW50LCBub3QgTWVtb0NvbXBvbmVudCxcbiAgICAgICAgLy8gYmVjYXVzZSBhIE1lbW9Db21wb25lbnQgZmliZXIgZG9lcyBub3QgaGF2ZSBob29rcyBvciBhbiB1cGRhdGUgcXVldWU7XG4gICAgICAgIC8vIHJhdGhlciwgaXQgd3JhcHMgYXJvdW5kIGFuIGlubmVyIGNvbXBvbmVudCwgd2hpY2ggbWF5IG9yIG1heSBub3RcbiAgICAgICAgLy8gY29udGFpbnMgaG9va3MuXG4gICAgICAgIC8vIFRPRE86IE1vdmUgdGhlIHJlc2V0IGF0IGluIGJlZ2luV29yayBvdXQgb2YgdGhlIGNvbW1vbiBwYXRoIHNvIHRoYXRcbiAgICAgICAgLy8gdGhpcyBpcyBubyBsb25nZXIgbmVjZXNzYXJ5LlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGN1cnJlbnQubGFuZXM7XG4gICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9IGVsc2UgaWYgKChjdXJyZW50LmZsYWdzICYgRm9yY2VVcGRhdGVGb3JMZWdhY3lTdXNwZW5zZSkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIHRoYXQgb25seSBleGlzdHMgZm9yIGxlZ2FjeSBtb2RlLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTkyMTYuXG4gICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICB2YXIgbmV4dElzRGV0YWNoZWQgPSAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLl9wZW5kaW5nVmlzaWJpbGl0eSAmIE9mZnNjcmVlbkRldGFjaGVkKSAhPT0gMDtcbiAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkU3RhdGUgOiBudWxsO1xuICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcblxuICBpZiAobmV4dFByb3BzLm1vZGUgPT09ICdoaWRkZW4nIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgbmV4dElzRGV0YWNoZWQpIHtcbiAgICAvLyBSZW5kZXJpbmcgYSBoaWRkZW4gdHJlZS5cbiAgICB2YXIgZGlkU3VzcGVuZCA9ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzJDE7XG5cbiAgICBpZiAoZGlkU3VzcGVuZCkge1xuICAgICAgLy8gU29tZXRoaW5nIHN1c3BlbmRlZCBpbnNpZGUgYSBoaWRkZW4gdHJlZVxuICAgICAgLy8gSW5jbHVkZSB0aGUgYmFzZSBsYW5lcyBmcm9tIHRoZSBsYXN0IHJlbmRlclxuICAgICAgdmFyIG5leHRCYXNlTGFuZXMgPSBwcmV2U3RhdGUgIT09IG51bGwgPyBtZXJnZUxhbmVzKHByZXZTdGF0ZS5iYXNlTGFuZXMsIHJlbmRlckxhbmVzKSA6IHJlbmRlckxhbmVzO1xuXG4gICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBSZXNldCB0byB0aGUgY3VycmVudCBjaGlsZHJlblxuICAgICAgICB2YXIgY3VycmVudENoaWxkID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkOyAvLyBUaGUgY3VycmVudCByZW5kZXIgc3VzcGVuZGVkLCBidXQgdGhlcmUgbWF5IGJlIG90aGVyIGxhbmVzIHdpdGhcbiAgICAgICAgLy8gcGVuZGluZyB3b3JrLiBXZSBjYW4ndCByZWFkIGBjaGlsZExhbmVzYCBmcm9tIHRoZSBjdXJyZW50IE9mZnNjcmVlblxuICAgICAgICAvLyBmaWJlciBiZWNhdXNlIHdlIHJlc2V0IGl0IHdoZW4gaXQgd2FzIGRlZmVycmVkOyBob3dldmVyLCB3ZSBjYW4gcmVhZFxuICAgICAgICAvLyB0aGUgcGVuZGluZyBsYW5lcyBmcm9tIHRoZSBjaGlsZCBmaWJlcnMuXG5cbiAgICAgICAgdmFyIGN1cnJlbnRDaGlsZExhbmVzID0gTm9MYW5lcztcblxuICAgICAgICB3aGlsZSAoY3VycmVudENoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgY3VycmVudENoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKG1lcmdlTGFuZXMoY3VycmVudENoaWxkTGFuZXMsIGN1cnJlbnRDaGlsZC5sYW5lcyksIGN1cnJlbnRDaGlsZC5jaGlsZExhbmVzKTtcbiAgICAgICAgICBjdXJyZW50Q2hpbGQgPSBjdXJyZW50Q2hpbGQuc2libGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYW5lc1dlSnVzdEF0dGVtcHRlZCA9IG5leHRCYXNlTGFuZXM7XG4gICAgICAgIHZhciByZW1haW5pbmdDaGlsZExhbmVzID0gcmVtb3ZlTGFuZXMoY3VycmVudENoaWxkTGFuZXMsIGxhbmVzV2VKdXN0QXR0ZW1wdGVkKTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IHJlbWFpbmluZ0NoaWxkTGFuZXM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gTm9MYW5lcztcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZGVmZXJIaWRkZW5PZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRCYXNlTGFuZXMpO1xuICAgIH1cblxuICAgIGlmICghaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgT2Zmc2NyZWVuTGFuZSkpIHtcbiAgICAgIC8vIFdlJ3JlIGhpZGRlbiwgYW5kIHdlJ3JlIG5vdCByZW5kZXJpbmcgYXQgT2Zmc2NyZWVuLiBXZSB3aWxsIGJhaWwgb3V0XG4gICAgICAvLyBhbmQgcmVzdW1lIHRoaXMgdHJlZSBsYXRlci5cbiAgICAgIC8vIFNjaGVkdWxlIHRoaXMgZmliZXIgdG8gcmUtcmVuZGVyIGF0IE9mZnNjcmVlbiBwcmlvcml0eVxuICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gbGFuZVRvTGFuZXMoT2Zmc2NyZWVuTGFuZSk7IC8vIEluY2x1ZGUgdGhlIGJhc2UgbGFuZXMgZnJvbSB0aGUgbGFzdCByZW5kZXJcblxuICAgICAgdmFyIF9uZXh0QmFzZUxhbmVzID0gcHJldlN0YXRlICE9PSBudWxsID8gbWVyZ2VMYW5lcyhwcmV2U3RhdGUuYmFzZUxhbmVzLCByZW5kZXJMYW5lcykgOiByZW5kZXJMYW5lcztcblxuICAgICAgcmV0dXJuIGRlZmVySGlkZGVuT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfbmV4dEJhc2VMYW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIHNlY29uZCByZW5kZXIuIFRoZSBzdXJyb3VuZGluZyB2aXNpYmxlIGNvbnRlbnQgaGFzIGFscmVhZHlcbiAgICAgIC8vIGNvbW1pdHRlZC4gTm93IHdlIHJlc3VtZSByZW5kZXJpbmcgdGhlIGhpZGRlbiB0cmVlLlxuICAgICAgLy8gUmVuZGVyaW5nIGF0IG9mZnNjcmVlbiwgc28gd2UgY2FuIGNsZWFyIHRoZSBiYXNlIGxhbmVzLlxuICAgICAgdmFyIF9uZXh0U3RhdGUgPSB7XG4gICAgICAgIGJhc2VMYW5lczogTm9MYW5lcyxcbiAgICAgICAgY2FjaGVQb29sOiBudWxsXG4gICAgICB9O1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IF9uZXh0U3RhdGU7XG5cbiAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIElmIHRoZSByZW5kZXIgdGhhdCBzcGF3bmVkIHRoaXMgb25lIGFjY2Vzc2VkIHRoZSBjYWNoZSBwb29sLCByZXN1bWVcbiAgICAgICAgLy8gdXNpbmcgdGhlIHNhbWUgY2FjaGUuIFVubGVzcyB0aGUgcGFyZW50IGNoYW5nZWQsIHNpbmNlIHRoYXQgbWVhbnNcbiAgICAgICAgLy8gdGhlcmUgd2FzIGEgcmVmcmVzaC5cbiAgICAgICAgdmFyIHByZXZDYWNoZVBvb2wgPSBwcmV2U3RhdGUgIT09IG51bGwgPyBwcmV2U3RhdGUuY2FjaGVQb29sIDogbnVsbDsgLy8gVE9ETzogQ29uc2lkZXIgaWYgYW5kIGhvdyBPZmZzY3JlZW4gcHJlLXJlbmRlcmluZyBzaG91bGRcbiAgICAgICAgLy8gYmUgYXR0cmlidXRlZCB0byB0aGUgdHJhbnNpdGlvbiB0aGF0IHNwYXduZWQgaXRcblxuICAgICAgICBwdXNoVHJhbnNpdGlvbih3b3JrSW5Qcm9ncmVzcywgcHJldkNhY2hlUG9vbCk7XG4gICAgICB9IC8vIFB1c2ggdGhlIGxhbmVzIHRoYXQgd2VyZSBza2lwcGVkIHdoZW4gd2UgYmFpbGVkIG91dC5cblxuXG4gICAgICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIHB1c2hIaWRkZW5Db250ZXh0KHdvcmtJblByb2dyZXNzLCBwcmV2U3RhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV1c2VIaWRkZW5Db250ZXh0T25TdGFjayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG5cbiAgICAgIHB1c2hPZmZzY3JlZW5TdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBSZW5kZXJpbmcgYSB2aXNpYmxlIHRyZWUuXG4gICAgaWYgKHByZXZTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgLy8gV2UncmUgZ29pbmcgZnJvbSBoaWRkZW4gLT4gdmlzaWJsZS5cbiAgICAgIHZhciBfcHJldkNhY2hlUG9vbCA9IG51bGw7XG5cbiAgICAgIHtcbiAgICAgICAgLy8gSWYgdGhlIHJlbmRlciB0aGF0IHNwYXduZWQgdGhpcyBvbmUgYWNjZXNzZWQgdGhlIGNhY2hlIHBvb2wsIHJlc3VtZVxuICAgICAgICAvLyB1c2luZyB0aGUgc2FtZSBjYWNoZS4gVW5sZXNzIHRoZSBwYXJlbnQgY2hhbmdlZCwgc2luY2UgdGhhdCBtZWFuc1xuICAgICAgICAvLyB0aGVyZSB3YXMgYSByZWZyZXNoLlxuICAgICAgICBfcHJldkNhY2hlUG9vbCA9IHByZXZTdGF0ZS5jYWNoZVBvb2w7XG4gICAgICB9XG5cbiAgICAgIHB1c2hUcmFuc2l0aW9uKHdvcmtJblByb2dyZXNzLCBfcHJldkNhY2hlUG9vbCk7IC8vIFB1c2ggdGhlIGxhbmVzIHRoYXQgd2VyZSBza2lwcGVkIHdoZW4gd2UgYmFpbGVkIG91dC5cblxuICAgICAgcHVzaEhpZGRlbkNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHByZXZTdGF0ZSk7XG4gICAgICByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2sod29ya0luUHJvZ3Jlc3MpOyAvLyBTaW5jZSB3ZSdyZSBub3QgaGlkZGVuIGFueW1vcmUsIHJlc2V0IHRoZSBzdGF0ZVxuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2Ugd2VyZW4ndCBwcmV2aW91c2x5IGhpZGRlbiwgYW5kIHdlIHN0aWxsIGFyZW4ndCwgc28gdGhlcmUncyBub3RoaW5nXG4gICAgICAvLyBzcGVjaWFsIHRvIGRvLiBOZWVkIHRvIHB1c2ggdG8gdGhlIHN0YWNrIHJlZ2FyZGxlc3MsIHRob3VnaCwgdG8gYXZvaWRcbiAgICAgIC8vIGEgcHVzaC9wb3AgbWlzYWxpZ25tZW50LlxuICAgICAge1xuICAgICAgICAvLyBJZiB0aGUgcmVuZGVyIHRoYXQgc3Bhd25lZCB0aGlzIG9uZSBhY2Nlc3NlZCB0aGUgY2FjaGUgcG9vbCwgcmVzdW1lXG4gICAgICAgIC8vIHVzaW5nIHRoZSBzYW1lIGNhY2hlLiBVbmxlc3MgdGhlIHBhcmVudCBjaGFuZ2VkLCBzaW5jZSB0aGF0IG1lYW5zXG4gICAgICAgIC8vIHRoZXJlIHdhcyBhIHJlZnJlc2guXG4gICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgcHVzaFRyYW5zaXRpb24od29ya0luUHJvZ3Jlc3MsIG51bGwpO1xuICAgICAgICB9XG4gICAgICB9IC8vIFdlJ3JlIGFib3V0IHRvIGJhaWwgb3V0LCBidXQgd2UgbmVlZCB0byBwdXNoIHRoaXMgdG8gdGhlIHN0YWNrIGFueXdheVxuICAgICAgLy8gdG8gYXZvaWQgYSBwdXNoL3BvcCBtaXNhbGlnbm1lbnQuXG5cblxuICAgICAgcmV1c2VIaWRkZW5Db250ZXh0T25TdGFjayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2sod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfVxuXG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBkZWZlckhpZGRlbk9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dEJhc2VMYW5lcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG5leHRTdGF0ZSA9IHtcbiAgICBiYXNlTGFuZXM6IG5leHRCYXNlTGFuZXMsXG4gICAgLy8gU2F2ZSB0aGUgY2FjaGUgcG9vbCBzbyB3ZSBjYW4gcmVzdW1lIGxhdGVyLlxuICAgIGNhY2hlUG9vbDogZ2V0T2Zmc2NyZWVuRGVmZXJyZWRDYWNoZSgpIFxuICB9O1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV4dFN0YXRlO1xuXG4gIHtcbiAgICAvLyBwdXNoIHRoZSBjYWNoZSBwb29sIGV2ZW4gdGhvdWdoIHdlJ3JlIGdvaW5nIHRvIGJhaWwgb3V0XG4gICAgLy8gYmVjYXVzZSBvdGhlcndpc2UgdGhlcmUnZCBiZSBhIGNvbnRleHQgbWlzbWF0Y2hcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgcHVzaFRyYW5zaXRpb24od29ya0luUHJvZ3Jlc3MsIG51bGwpO1xuICAgIH1cbiAgfSAvLyBXZSdyZSBhYm91dCB0byBiYWlsIG91dCwgYnV0IHdlIG5lZWQgdG8gcHVzaCB0aGlzIHRvIHRoZSBzdGFjayBhbnl3YXlcbiAgLy8gdG8gYXZvaWQgYSBwdXNoL3BvcCBtaXNhbGlnbm1lbnQuXG5cblxuICByZXVzZUhpZGRlbkNvbnRleHRPblN0YWNrKHdvcmtJblByb2dyZXNzKTtcbiAgcHVzaE9mZnNjcmVlblN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgcmV0dXJuIG51bGw7XG59IC8vIE5vdGU6IFRoZXNlIGhhcHBlbiB0byBoYXZlIGlkZW50aWNhbCBiZWdpbiBwaGFzZXMsIGZvciBub3cuIFdlIHNob3VsZG4ndCBob2xkXG5cbmZ1bmN0aW9uIHVwZGF0ZUNhY2hlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuXG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIHZhciBwYXJlbnRDYWNoZSA9IHJlYWRDb250ZXh0KENhY2hlQ29udGV4dCk7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBJbml0aWFsIG1vdW50LiBSZXF1ZXN0IGEgZnJlc2ggY2FjaGUgZnJvbSB0aGUgcG9vbC5cbiAgICB2YXIgZnJlc2hDYWNoZSA9IHJlcXVlc3RDYWNoZUZyb21Qb29sKHJlbmRlckxhbmVzKTtcbiAgICB2YXIgaW5pdGlhbFN0YXRlID0ge1xuICAgICAgcGFyZW50OiBwYXJlbnRDYWNoZSxcbiAgICAgIGNhY2hlOiBmcmVzaENhY2hlXG4gICAgfTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICAgIGluaXRpYWxpemVVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgcHVzaENhY2hlUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGZyZXNoQ2FjaGUpO1xuICB9IGVsc2Uge1xuICAgIC8vIENoZWNrIGZvciB1cGRhdGVzXG4gICAgaWYgKGluY2x1ZGVzU29tZUxhbmUoY3VycmVudC5sYW5lcywgcmVuZGVyTGFuZXMpKSB7XG4gICAgICBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbnVsbCwgcmVuZGVyTGFuZXMpO1xuICAgICAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpO1xuICAgIH1cblxuICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgdmFyIG5leHRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7IC8vIENvbXBhcmUgdGhlIG5ldyBwYXJlbnQgY2FjaGUgdG8gdGhlIHByZXZpb3VzIHRvIHNlZSBkZXRlY3QgdGhlcmUgd2FzXG4gICAgLy8gYSByZWZyZXNoLlxuXG4gICAgaWYgKHByZXZTdGF0ZS5wYXJlbnQgIT09IHBhcmVudENhY2hlKSB7XG4gICAgICAvLyBSZWZyZXNoIGluIHBhcmVudC4gVXBkYXRlIHRoZSBwYXJlbnQuXG4gICAgICB2YXIgZGVyaXZlZFN0YXRlID0ge1xuICAgICAgICBwYXJlbnQ6IHBhcmVudENhY2hlLFxuICAgICAgICBjYWNoZTogcGFyZW50Q2FjaGVcbiAgICAgIH07IC8vIENvcGllZCBmcm9tIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyBpbXBsZW1lbnRhdGlvbi4gT25jZSB0aGUgdXBkYXRlXG4gICAgICAvLyBxdWV1ZSBpcyBlbXB0eSwgcGVyc2lzdCB0aGUgZGVyaXZlZCBzdGF0ZSBvbnRvIHRoZSBiYXNlIHN0YXRlLlxuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gZGVyaXZlZFN0YXRlO1xuXG4gICAgICBpZiAod29ya0luUHJvZ3Jlc3MubGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB1cGRhdGVRdWV1ZS5iYXNlU3RhdGUgPSBkZXJpdmVkU3RhdGU7XG4gICAgICB9XG5cbiAgICAgIHB1c2hDYWNoZVByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBwYXJlbnRDYWNoZSk7IC8vIE5vIG5lZWQgdG8gcHJvcGFnYXRlIGEgY29udGV4dCBjaGFuZ2UgYmVjYXVzZSB0aGUgcmVmcmVzaGVkIHBhcmVudFxuICAgICAgLy8gYWxyZWFkeSBkaWQuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBwYXJlbnQgZGlkbid0IHJlZnJlc2guIE5vdyBjaGVjayBpZiB0aGlzIGNhY2hlIGRpZC5cbiAgICAgIHZhciBuZXh0Q2FjaGUgPSBuZXh0U3RhdGUuY2FjaGU7XG4gICAgICBwdXNoQ2FjaGVQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgbmV4dENhY2hlKTtcblxuICAgICAgaWYgKG5leHRDYWNoZSAhPT0gcHJldlN0YXRlLmNhY2hlKSB7XG4gICAgICAgIC8vIFRoaXMgY2FjaGUgcmVmcmVzaGVkLiBQcm9wYWdhdGUgYSBjb250ZXh0IGNoYW5nZS5cbiAgICAgICAgcHJvcGFnYXRlQ29udGV4dENoYW5nZSh3b3JrSW5Qcm9ncmVzcywgQ2FjaGVDb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbjtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59IC8vIFRoaXMgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGlmIHRoZSBuYW1lIGNoYW5nZXNcblxuZnVuY3Rpb24gdXBkYXRlRnJhZ21lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNb2RlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUHJvZmlsZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG5cbiAgICB7XG4gICAgICAvLyBSZXNldCBlZmZlY3QgZHVyYXRpb25zIGZvciB0aGUgbmV4dCBldmVudHVhbCBlZmZlY3QgcGhhc2UuXG4gICAgICAvLyBUaGVzZSBhcmUgcmVzZXQgZHVyaW5nIHJlbmRlciB0byBhbGxvdyB0aGUgRGV2VG9vbHMgY29tbWl0IGhvb2sgYSBjaGFuY2UgdG8gcmVhZCB0aGVtLFxuICAgICAgdmFyIHN0YXRlTm9kZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgIHN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICBzdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gMDtcbiAgICB9XG4gIH1cblxuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgbmV4dENoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICAvLyBUT0RPOiBDaGVjayBwcm9wcy5yZWYgaW5zdGVhZCBvZiBmaWJlci5yZWYgd2hlbiBlbmFibGVSZWZBc1Byb3AgaXMgb24uXG4gIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG5cbiAgaWYgKHJlZiA9PT0gbnVsbCkge1xuICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQucmVmICE9PSBudWxsKSB7XG4gICAgICAvLyBTY2hlZHVsZSBhIFJlZiBlZmZlY3RcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFJlZiB8IFJlZlN0YXRpYztcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiByZWYgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHJlZiAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcmVmIHRvIGJlIGEgZnVuY3Rpb24sIGFuIG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVSZWYoKSwgb3IgdW5kZWZpbmVkL251bGwuJyk7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5yZWYgIT09IHJlZikge1xuXG5cbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFJlZiB8IFJlZlN0YXRpYztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuICB7XG4gICAgaWYgKENvbXBvbmVudC5wcm90b3R5cGUgJiYgdHlwZW9mIENvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRCYWRDbGFzc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcihcIlRoZSA8JXMgLz4gY29tcG9uZW50IGFwcGVhcnMgdG8gaGF2ZSBhIHJlbmRlciBtZXRob2QsIGJ1dCBkb2Vzbid0IGV4dGVuZCBSZWFjdC5Db21wb25lbnQuIFwiICsgJ1RoaXMgaXMgbGlrZWx5IHRvIGNhdXNlIGVycm9ycy4gQ2hhbmdlICVzIHRvIGV4dGVuZCBSZWFjdC5Db21wb25lbnQgaW5zdGVhZC4nLCBjb21wb25lbnROYW1lLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRCYWRDbGFzc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZyh3b3JrSW5Qcm9ncmVzcywgbnVsbCk7XG4gICAgfVxuXG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIFNvbWUgdmFsaWRhdGlvbnMgd2VyZSBwcmV2aW91c2x5IGRvbmUgaW4gbW91bnRJbmRldGVybWluYXRlQ29tcG9uZW50IGhvd2V2ZXIgYW5kIGFyZSBub3cgcnVuXG4gICAgICAvLyBpbiB1cGRhdGVGdW50aW9uQ29tcG9uZW50IGJ1dCBvbmx5IG9uIG1vdW50XG4gICAgICB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnR5cGUpO1xuXG4gICAgICBpZiAoQ29tcG9uZW50LmNvbnRleHRUeXBlcykge1xuICAgICAgICBlcnJvcignJXMgdXNlcyB0aGUgbGVnYWN5IGNvbnRleHRUeXBlcyBBUEkgd2hpY2ggd2FzIHJlbW92ZWQgaW4gUmVhY3QgMTkuICcgKyAnVXNlIFJlYWN0LmNyZWF0ZUNvbnRleHQoKSB3aXRoIFJlYWN0LnVzZUNvbnRleHQoKSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIGNvbnRleHQ7XG5cbiAgdmFyIG5leHRDaGlsZHJlbjtcbiAgdmFyIGhhc0lkO1xuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gIHtcbiAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICB7XG4gICAgc2V0SXNSZW5kZXJpbmcodHJ1ZSk7XG4gICAgbmV4dENoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgY29udGV4dCwgcmVuZGVyTGFuZXMpO1xuICAgIGhhc0lkID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcbiAgICBzZXRJc1JlbmRlcmluZyhmYWxzZSk7XG4gIH1cblxuICB7XG4gICAgbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTtcbiAgfVxuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsICYmICFkaWRSZWNlaXZlVXBkYXRlKSB7XG4gICAgYmFpbG91dEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIGlmIChnZXRJc0h5ZHJhdGluZygpICYmIGhhc0lkKSB7XG4gICAgcHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHJlcGxheUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIENvbXBvbmVudCwgc2Vjb25kQXJnLCByZW5kZXJMYW5lcykge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcmVwbGF5IGEgY29tcG9uZW50IHRoYXQgcHJldmlvdXNseSBzdXNwZW5kZWQsXG4gIC8vIGFmdGVyIGl0cyBkYXRhIHJlc29sdmVzLiBJdCdzIGEgc2ltcGxpZmllZCB2ZXJzaW9uIG9mXG4gIC8vIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50IHRoYXQgcmV1c2VzIHRoZSBob29rcyBmcm9tIHRoZSBwcmV2aW91cyBhdHRlbXB0LlxuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gIHtcbiAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZCh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICB2YXIgbmV4dENoaWxkcmVuID0gcmVwbGF5U3VzcGVuZGVkQ29tcG9uZW50V2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgc2Vjb25kQXJnKTtcbiAgdmFyIGhhc0lkID0gY2hlY2tEaWRSZW5kZXJJZEhvb2soKTtcblxuICB7XG4gICAgbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTtcbiAgfVxuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsICYmICFkaWRSZWNlaXZlVXBkYXRlKSB7XG4gICAgYmFpbG91dEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIGlmIChnZXRJc0h5ZHJhdGluZygpICYmIGhhc0lkKSB7XG4gICAgcHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAge1xuICAgIC8vIFRoaXMgaXMgdXNlZCBieSBEZXZUb29scyB0byBmb3JjZSBhIGJvdW5kYXJ5IHRvIGVycm9yLlxuICAgIHN3aXRjaCAoc2hvdWxkRXJyb3Iod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICBjYXNlIGZhbHNlOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9pbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgICAgICB2YXIgY3RvciA9IHdvcmtJblByb2dyZXNzLnR5cGU7IC8vIFRPRE8gVGhpcyB3YXkgb2YgcmVzZXR0aW5nIHRoZSBlcnJvciBib3VuZGFyeSBzdGF0ZSBpcyBhIGhhY2suXG4gICAgICAgICAgLy8gSXMgdGhlcmUgYSBiZXR0ZXIgd2F5IHRvIGRvIHRoaXM/XG5cbiAgICAgICAgICB2YXIgdGVtcEluc3RhbmNlID0gbmV3IGN0b3Iod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcywgX2luc3RhbmNlLmNvbnRleHQpO1xuICAgICAgICAgIHZhciBzdGF0ZSA9IHRlbXBJbnN0YW5jZS5zdGF0ZTtcblxuICAgICAgICAgIF9pbnN0YW5jZS51cGRhdGVyLmVucXVldWVTZXRTdGF0ZShfaW5zdGFuY2UsIHN0YXRlLCBudWxsKTtcblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgdHJ1ZTpcbiAgICAgICAge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU2hvdWxkQ2FwdHVyZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcblxuICAgICAgICAgIHZhciBlcnJvciQxID0gbmV3IEVycm9yKCdTaW11bGF0ZWQgZXJyb3IgY29taW5nIGZyb20gRGV2VG9vbHMnKTtcbiAgICAgICAgICB2YXIgbGFuZSA9IHBpY2tBcmJpdHJhcnlMYW5lKHJlbmRlckxhbmVzKTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3MubGFuZXMsIGxhbmUpOyAvLyBTY2hlZHVsZSB0aGUgZXJyb3IgYm91bmRhcnkgdG8gcmUtcmVuZGVyIHVzaW5nIHVwZGF0ZWQgc3RhdGVcblxuICAgICAgICAgIHZhciByb290ID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCk7XG5cbiAgICAgICAgICBpZiAocm9vdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIHdvcmstaW4tcHJvZ3Jlc3Mgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUobGFuZSk7XG4gICAgICAgICAgaW5pdGlhbGl6ZUNsYXNzRXJyb3JVcGRhdGUodXBkYXRlLCByb290LCB3b3JrSW5Qcm9ncmVzcywgY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoZXJyb3IkMSwgd29ya0luUHJvZ3Jlc3MpKTtcbiAgICAgICAgICBlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIHVwZGF0ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gIH0gLy8gUHVzaCBjb250ZXh0IHByb3ZpZGVycyBlYXJseSB0byBwcmV2ZW50IGNvbnRleHQgc3RhY2sgbWlzbWF0Y2hlcy5cbiAgLy8gRHVyaW5nIG1vdW50aW5nIHdlIGRvbid0IGtub3cgdGhlIGNoaWxkIGNvbnRleHQgeWV0IGFzIHRoZSBpbnN0YW5jZSBkb2Vzbid0IGV4aXN0LlxuICAvLyBXZSB3aWxsIGludmFsaWRhdGUgdGhlIGNoaWxkIGNvbnRleHQgaW4gZmluaXNoQ2xhc3NDb21wb25lbnQoKSByaWdodCBhZnRlciByZW5kZXJpbmcuXG5cblxuICB2YXIgaGFzQ29udGV4dDtcblxuICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoKSkge1xuICAgIGhhc0NvbnRleHQgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIGhhc0NvbnRleHQgPSBmYWxzZTtcbiAgfVxuXG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgdmFyIHNob3VsZFVwZGF0ZTtcblxuICBpZiAoaW5zdGFuY2UgPT09IG51bGwpIHtcblxuICAgIGNvbnN0cnVjdENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzKTtcbiAgICBtb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgc2hvdWxkVXBkYXRlID0gdHJ1ZTtcbiAgfSBlbHNlIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgLy8gSW4gYSByZXN1bWUsIHdlJ2xsIGFscmVhZHkgaGF2ZSBhbiBpbnN0YW5jZSB3ZSBjYW4gcmV1c2UuXG4gICAgc2hvdWxkVXBkYXRlID0gcmVzdW1lTW91bnRDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICB9IGVsc2Uge1xuICAgIHNob3VsZFVwZGF0ZSA9IHVwZGF0ZUNsYXNzSW5zdGFuY2UoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICB2YXIgbmV4dFVuaXRPZldvcmsgPSBmaW5pc2hDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBzaG91bGRVcGRhdGUsIGhhc0NvbnRleHQsIHJlbmRlckxhbmVzKTtcblxuICB7XG4gICAgdmFyIGluc3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgICBpZiAoc2hvdWxkVXBkYXRlICYmIGluc3QucHJvcHMgIT09IG5leHRQcm9wcykge1xuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKSB7XG4gICAgICAgIGVycm9yKCdJdCBsb29rcyBsaWtlICVzIGlzIHJlYXNzaWduaW5nIGl0cyBvd24gYHRoaXMucHJvcHNgIHdoaWxlIHJlbmRlcmluZy4gJyArICdUaGlzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIGNhbiBsZWFkIHRvIGNvbmZ1c2luZyBidWdzLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpIHx8ICdhIGNvbXBvbmVudCcpO1xuICAgICAgfVxuXG4gICAgICBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV4dFVuaXRPZldvcms7XG59XG5cbmZ1bmN0aW9uIGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHNob3VsZFVwZGF0ZSwgaGFzQ29udGV4dCwgcmVuZGVyTGFuZXMpIHtcbiAgLy8gUmVmcyBzaG91bGQgdXBkYXRlIGV2ZW4gaWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybnMgZmFsc2VcbiAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHZhciBkaWRDYXB0dXJlRXJyb3IgPSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncyQxO1xuXG4gIGlmICghc2hvdWxkVXBkYXRlICYmICFkaWRDYXB0dXJlRXJyb3IpIHtcblxuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7IC8vIFJlcmVuZGVyXG5cbiAge1xuICAgIHNldEN1cnJlbnRGaWJlcih3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICB2YXIgbmV4dENoaWxkcmVuO1xuXG4gIGlmIChkaWRDYXB0dXJlRXJyb3IgJiYgdHlwZW9mIENvbXBvbmVudC5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBJZiB3ZSBjYXB0dXJlZCBhbiBlcnJvciwgYnV0IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciBpcyBub3QgZGVmaW5lZCxcbiAgICAvLyB1bm1vdW50IGFsbCB0aGUgY2hpbGRyZW4uIGNvbXBvbmVudERpZENhdGNoIHdpbGwgc2NoZWR1bGUgYW4gdXBkYXRlIHRvXG4gICAgLy8gcmUtcmVuZGVyIGEgZmFsbGJhY2suIFRoaXMgaXMgdGVtcG9yYXJ5IHVudGlsIHdlIG1pZ3JhdGUgZXZlcnlvbmUgdG9cbiAgICAvLyB0aGUgbmV3IEFQSS5cbiAgICAvLyBUT0RPOiBXYXJuIGluIGEgZnV0dXJlIHJlbGVhc2UuXG4gICAgbmV4dENoaWxkcmVuID0gbnVsbDtcblxuICAgIHtcbiAgICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBzZXRJc1JlbmRlcmluZyh0cnVlKTtcbiAgICAgIG5leHRDaGlsZHJlbiA9IGluc3RhbmNlLnJlbmRlcigpO1xuXG4gICAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBpbnN0YW5jZS5yZW5kZXIoKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc2V0SXNSZW5kZXJpbmcoZmFsc2UpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gICAgfVxuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgZGlkQ2FwdHVyZUVycm9yKSB7XG4gICAgLy8gSWYgd2UncmUgcmVjb3ZlcmluZyBmcm9tIGFuIGVycm9yLCByZWNvbmNpbGUgd2l0aG91dCByZXVzaW5nIGFueSBvZlxuICAgIC8vIHRoZSBleGlzdGluZyBjaGlsZHJlbi4gQ29uY2VwdHVhbGx5LCB0aGUgbm9ybWFsIGNoaWxkcmVuIGFuZCB0aGUgY2hpbGRyZW5cbiAgICAvLyB0aGF0IGFyZSBzaG93biBvbiBlcnJvciBhcmUgdHdvIGRpZmZlcmVudCBzZXRzLCBzbyB3ZSBzaG91bGRuJ3QgcmV1c2VcbiAgICAvLyBub3JtYWwgY2hpbGRyZW4gZXZlbiBpZiB0aGVpciBpZGVudGl0aWVzIG1hdGNoLlxuICAgIGZvcmNlVW5tb3VudEN1cnJlbnRBbmRSZWNvbmNpbGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgfSAvLyBNZW1vaXplIHN0YXRlIHVzaW5nIHRoZSB2YWx1ZXMgd2UganVzdCB1c2VkIHRvIHJlbmRlci5cbiAgLy8gVE9ETzogUmVzdHJ1Y3R1cmUgc28gd2UgbmV2ZXIgcmVhZCB2YWx1ZXMgZnJvbSB0aGUgaW5zdGFuY2UuXG5cblxuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7IC8vIFRoZSBjb250ZXh0IG1pZ2h0IGhhdmUgY2hhbmdlZCBzbyB3ZSBuZWVkIHRvIHJlY2FsY3VsYXRlIGl0LlxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcykge1xuICB2YXIgcm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgcm9vdC5jb250YWluZXJJbmZvKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdFJvb3QoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHB1c2hIb3N0Um9vdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgaGF2ZSBhIGN1cnJlbnQgZmliZXIuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gIH1cblxuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIHByZXZDaGlsZHJlbiA9IHByZXZTdGF0ZS5lbGVtZW50O1xuICBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXh0UHJvcHMsIG51bGwsIHJlbmRlckxhbmVzKTtcbiAgdmFyIG5leHRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAge1xuICAgIHZhciBuZXh0Q2FjaGUgPSBuZXh0U3RhdGUuY2FjaGU7XG4gICAgcHVzaENhY2hlUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIG5leHRDYWNoZSk7XG5cbiAgICBpZiAobmV4dENhY2hlICE9PSBwcmV2U3RhdGUuY2FjaGUpIHtcbiAgICAgIC8vIFRoZSByb290IGNhY2hlIHJlZnJlc2hlZC5cbiAgICAgIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIENhY2hlQ29udGV4dCwgcmVuZGVyTGFuZXMpO1xuICAgIH1cbiAgfSAvLyBUaGlzIHdvdWxkIGlkZWFsbHkgZ28gaW5zaWRlIHByb2Nlc3NVcGRhdGVRdWV1ZSwgYnV0IGJlY2F1c2UgaXQgc3VzcGVuZHMsXG4gIC8vIGl0IG5lZWRzIHRvIGhhcHBlbiBhZnRlciB0aGUgYHB1c2hDYWNoZVByb3ZpZGVyYCBjYWxsIGFib3ZlIHRvIGF2b2lkIGFcbiAgLy8gY29udGV4dCBzdGFjayBtaXNtYXRjaC4gQSBiaXQgdW5mb3J0dW5hdGUuXG5cblxuICBzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKCk7IC8vIENhdXRpb246IFJlYWN0IERldlRvb2xzIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJvcGVydHlcbiAgLy8gYmVpbmcgY2FsbGVkIFwiZWxlbWVudFwiLlxuXG4gIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0U3RhdGUuZWxlbWVudDtcblxuICBpZiAoc3VwcG9ydHNIeWRyYXRpb24gJiYgcHJldlN0YXRlLmlzRGVoeWRyYXRlZCkge1xuICAgIC8vIFRoaXMgaXMgYSBoeWRyYXRpb24gcm9vdCB3aG9zZSBzaGVsbCBoYXMgbm90IHlldCBoeWRyYXRlZC4gV2Ugc2hvdWxkXG4gICAgLy8gYXR0ZW1wdCB0byBoeWRyYXRlLlxuICAgIC8vIEZsaXAgaXNEZWh5ZHJhdGVkIHRvIGZhbHNlIHRvIGluZGljYXRlIHRoYXQgd2hlbiB0aGlzIHJlbmRlclxuICAgIC8vIGZpbmlzaGVzLCB0aGUgcm9vdCB3aWxsIG5vIGxvbmdlciBiZSBkZWh5ZHJhdGVkLlxuICAgIHZhciBvdmVycmlkZVN0YXRlID0ge1xuICAgICAgZWxlbWVudDogbmV4dENoaWxkcmVuLFxuICAgICAgaXNEZWh5ZHJhdGVkOiBmYWxzZSxcbiAgICAgIGNhY2hlOiBuZXh0U3RhdGUuY2FjaGVcbiAgICB9O1xuICAgIHZhciB1cGRhdGVRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlOyAvLyBgYmFzZVN0YXRlYCBjYW4gYWx3YXlzIGJlIHRoZSBsYXN0IHN0YXRlIGJlY2F1c2UgdGhlIHJvb3QgZG9lc24ndFxuICAgIC8vIGhhdmUgcmVkdWNlciBmdW5jdGlvbnMgc28gaXQgZG9lc24ndCBuZWVkIHJlYmFzaW5nLlxuXG4gICAgdXBkYXRlUXVldWUuYmFzZVN0YXRlID0gb3ZlcnJpZGVTdGF0ZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gb3ZlcnJpZGVTdGF0ZTtcblxuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIEZvcmNlQ2xpZW50UmVuZGVyKSB7XG4gICAgICAvLyBTb21ldGhpbmcgZXJyb3JlZCBkdXJpbmcgYSBwcmV2aW91cyBhdHRlbXB0IHRvIGh5ZHJhdGUgdGhlIHNoZWxsLCBzbyB3ZVxuICAgICAgLy8gZm9yY2VkIGEgY2xpZW50IHJlbmRlci4gV2Ugc2hvdWxkIGhhdmUgYSByZWNvdmVyYWJsZSBlcnJvciBhbHJlYWR5IHNjaGVkdWxlZC5cbiAgICAgIHJldHVybiBtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gICAgfSBlbHNlIGlmIChuZXh0Q2hpbGRyZW4gIT09IHByZXZDaGlsZHJlbikge1xuICAgICAgdmFyIHJlY292ZXJhYmxlRXJyb3IgPSBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihuZXcgRXJyb3IoJ1RoaXMgcm9vdCByZWNlaXZlZCBhbiBlYXJseSB1cGRhdGUsIGJlZm9yZSBhbnl0aGluZyB3YXMgYWJsZSAnICsgJ2h5ZHJhdGUuIFN3aXRjaGVkIHRoZSBlbnRpcmUgcm9vdCB0byBjbGllbnQgcmVuZGVyaW5nLicpLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBxdWV1ZUh5ZHJhdGlvbkVycm9yKHJlY292ZXJhYmxlRXJyb3IpO1xuICAgICAgcmV0dXJuIG1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIG91dGVybW9zdCBzaGVsbCBoYXMgbm90IGh5ZHJhdGVkIHlldC4gU3RhcnQgaHlkcmF0aW5nLlxuICAgICAgZW50ZXJIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB2YXIgY2hpbGQgPSBtb3VudENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY2hpbGQ7XG4gICAgICB2YXIgbm9kZSA9IGNoaWxkO1xuXG4gICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAvLyBNYXJrIGVhY2ggY2hpbGQgYXMgaHlkcmF0aW5nLiBUaGlzIGlzIGEgZmFzdCBwYXRoIHRvIGtub3cgd2hldGhlciB0aGlzXG4gICAgICAgIC8vIHRyZWUgaXMgcGFydCBvZiBhIGh5ZHJhdGluZyB0cmVlLiBUaGlzIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIGEgY2hpbGRcbiAgICAgICAgLy8gbm9kZSBoYXMgZnVsbHkgbW91bnRlZCB5ZXQsIGFuZCBmb3Igc2NoZWR1bGluZyBldmVudCByZXBsYXlpbmcuXG4gICAgICAgIC8vIENvbmNlcHR1YWxseSB0aGlzIGlzIHNpbWlsYXIgdG8gUGxhY2VtZW50IGluIHRoYXQgYSBuZXcgc3VidHJlZSBpc1xuICAgICAgICAvLyBpbnNlcnRlZCBpbnRvIHRoZSBSZWFjdCB0cmVlIGhlcmUuIEl0IGp1c3QgaGFwcGVucyB0byBub3QgbmVlZCBET01cbiAgICAgICAgLy8gbXV0YXRpb25zIGJlY2F1c2UgaXQgYWxyZWFkeSBleGlzdHMuXG4gICAgICAgIG5vZGUuZmxhZ3MgPSBub2RlLmZsYWdzICYgflBsYWNlbWVudCB8IEh5ZHJhdGluZztcbiAgICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gUm9vdCBpcyBub3QgZGVoeWRyYXRlZC4gRWl0aGVyIHRoaXMgaXMgYSBjbGllbnQtb25seSByb290LCBvciBpdFxuICAgIC8vIGFscmVhZHkgaHlkcmF0ZWQuXG4gICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuXG4gICAgaWYgKG5leHRDaGlsZHJlbiA9PT0gcHJldkNoaWxkcmVuKSB7XG4gICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIH1cblxuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gbW91bnRIb3N0Um9vdFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgLy8gUmV2ZXJ0IHRvIGNsaWVudCByZW5kZXJpbmcuXG4gIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRm9yY2VDbGllbnRSZW5kZXI7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVIb3N0Q29tcG9uZW50JDEoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgcHVzaEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgdmFyIHR5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICB2YXIgbmV4dFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcHJldlByb3BzID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG51bGw7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHZhciBpc0RpcmVjdFRleHRDaGlsZCA9IHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIG5leHRQcm9wcyk7XG5cbiAgaWYgKGlzRGlyZWN0VGV4dENoaWxkKSB7XG4gICAgLy8gV2Ugc3BlY2lhbCBjYXNlIGEgZGlyZWN0IHRleHQgY2hpbGQgb2YgYSBob3N0IG5vZGUuIFRoaXMgaXMgYSBjb21tb25cbiAgICAvLyBjYXNlLiBXZSB3b24ndCBoYW5kbGUgaXQgYXMgYSByZWlmaWVkIGNoaWxkLiBXZSB3aWxsIGluc3RlYWQgaGFuZGxlXG4gICAgLy8gdGhpcyBpbiB0aGUgaG9zdCBlbnZpcm9ubWVudCB0aGF0IGFsc28gaGFzIGFjY2VzcyB0byB0aGlzIHByb3AuIFRoYXRcbiAgICAvLyBhdm9pZHMgYWxsb2NhdGluZyBhbm90aGVyIEhvc3RUZXh0IGZpYmVyIGFuZCB0cmF2ZXJzaW5nIGl0LlxuICAgIG5leHRDaGlsZHJlbiA9IG51bGw7XG4gIH0gZWxzZSBpZiAocHJldlByb3BzICE9PSBudWxsICYmIHNob3VsZFNldFRleHRDb250ZW50KHR5cGUsIHByZXZQcm9wcykpIHtcbiAgICAvLyBJZiB3ZSdyZSBzd2l0Y2hpbmcgZnJvbSBhIGRpcmVjdCB0ZXh0IGNoaWxkIHRvIGEgbm9ybWFsIGNoaWxkLCBvciB0b1xuICAgIC8vIGVtcHR5LCB3ZSBuZWVkIHRvIHNjaGVkdWxlIHRoZSB0ZXh0IGNvbnRlbnQgdG8gYmUgcmVzZXQuXG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gQ29udGVudFJlc2V0O1xuICB9XG5cbiAge1xuICAgIHZhciBtZW1vaXplZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICAgIGlmIChtZW1vaXplZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGZpYmVyIGhhcyBiZWVuIHVwZ3JhZGVkIHRvIGEgc3RhdGVmdWwgY29tcG9uZW50LiBUaGUgb25seSB3YXlcbiAgICAgIC8vIGhhcHBlbnMgY3VycmVudGx5IGlzIGZvciBmb3JtIGFjdGlvbnMuIFdlIHVzZSBob29rcyB0byB0cmFjayB0aGVcbiAgICAgIC8vIHBlbmRpbmcgYW5kIGVycm9yIHN0YXRlIG9mIHRoZSBmb3JtLlxuICAgICAgLy9cbiAgICAgIC8vIE9uY2UgYSBmaWJlciBpcyB1cGdyYWRlZCB0byBiZSBzdGF0ZWZ1bCwgaXQgcmVtYWlucyBzdGF0ZWZ1bCBmb3IgdGhlXG4gICAgICAvLyByZXN0IG9mIGl0cyBsaWZldGltZS5cbiAgICAgIHZhciBuZXdTdGF0ZSA9IHJlbmRlclRyYW5zaXRpb25Bd2FyZUhvc3RDb21wb25lbnRXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTsgLy8gSWYgdGhlIHRyYW5zaXRpb24gc3RhdGUgY2hhbmdlZCwgcHJvcGFnYXRlIHRoZSBjaGFuZ2UgdG8gYWxsIHRoZVxuICAgICAgLy8gZGVzY2VuZGVudHMuIFdlIHVzZSBDb250ZXh0IGFzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBmb3IgdGhpcy5cbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgc2V0IGhlcmUgaW5zdGVhZCBvZiBwdXNoSG9zdENvbnRleHQgYmVjYXVzZVxuICAgICAgLy8gcHVzaEhvc3RDb250ZXh0IGdldHMgY2FsbGVkIGJlZm9yZSB3ZSBwcm9jZXNzIHRoZSBzdGF0ZSBob29rLCB0byBhdm9pZFxuICAgICAgLy8gYSBzdGF0ZSBtaXNtYXRjaCBpbiB0aGUgZXZlbnQgdGhhdCBzb21ldGhpbmcgc3VzcGVuZHMuXG4gICAgICAvL1xuICAgICAgLy8gTk9URTogVGhpcyBhc3N1bWVzIHRoYXQgdGhlcmUgY2Fubm90IGJlIG5lc3RlZCB0cmFuc2l0aW9uIHByb3ZpZGVycyxcbiAgICAgIC8vIGJlY2F1c2UgdGhlIG9ubHkgcmVuZGVyZXIgdGhhdCBpbXBsZW1lbnRzIHRoaXMgZmVhdHVyZSBpcyBSZWFjdCBET00sXG4gICAgICAvLyBhbmQgZm9ybXMgY2Fubm90IGJlIG5lc3RlZC4gSWYgd2UgZGlkIHN1cHBvcnQgbmVzdGVkIHByb3ZpZGVycywgdGhlblxuICAgICAgLy8gd2Ugd291bGQgbmVlZCB0byBwdXNoIGEgY29udGV4dCB2YWx1ZSBldmVuIGZvciBob3N0IGZpYmVycyB0aGF0XG4gICAgICAvLyBoYXZlbid0IGJlZW4gdXBncmFkZWQgeWV0LlxuXG4gICAgICBpZiAoaXNQcmltYXJ5UmVuZGVyZXIpIHtcbiAgICAgICAgSG9zdFRyYW5zaXRpb25Db250ZXh0Ll9jdXJyZW50VmFsdWUgPSBuZXdTdGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIEhvc3RUcmFuc2l0aW9uQ29udGV4dC5fY3VycmVudFZhbHVlMiA9IG5ld1N0YXRlO1xuICAgICAgfVxuXG4gICAgICB7XG4gICAgICAgIGlmIChkaWRSZWNlaXZlVXBkYXRlKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBvbGRTdGF0ZUhvb2sgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICB2YXIgb2xkU3RhdGUgPSBvbGRTdGF0ZUhvb2subWVtb2l6ZWRTdGF0ZTsgLy8gVGhpcyB1c2VzIHJlZ3VsYXIgZXF1YWxpdHkgaW5zdGVhZCBvZiBPYmplY3QuaXMgYmVjYXVzZSB3ZSBhc3N1bWVcbiAgICAgICAgICAgIC8vIHRoYXQgaG9zdCB0cmFuc2l0aW9uIHN0YXRlIGRvZXNuJ3QgaW5jbHVkZSBOYU4gYXMgYSB2YWxpZCB0eXBlLlxuXG4gICAgICAgICAgICBpZiAob2xkU3RhdGUgIT09IG5ld1N0YXRlKSB7XG4gICAgICAgICAgICAgIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIEhvc3RUcmFuc2l0aW9uQ29udGV4dCwgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdEhvaXN0YWJsZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHZhciBjdXJyZW50UHJvcHMgPSBjdXJyZW50ID09PSBudWxsID8gbnVsbCA6IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgdmFyIHJlc291cmNlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGdldFJlc291cmNlKHdvcmtJblByb2dyZXNzLnR5cGUsIGN1cnJlbnRQcm9wcywgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKTtcblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIGlmICghZ2V0SXNIeWRyYXRpbmcoKSAmJiByZXNvdXJjZSA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyBpcyBub3QgYSBSZXNvdXJjZSBIb2lzdGFibGUgYW5kIHdlIGFyZW4ndCBoeWRyYXRpbmcgc28gd2UgY29uc3RydWN0IHRoZSBpbnN0YW5jZS5cbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGNyZWF0ZUhvaXN0YWJsZUluc3RhbmNlKHdvcmtJblByb2dyZXNzLnR5cGUsIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcywgZ2V0Um9vdEhvc3RDb250YWluZXIoKSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfSAvLyBSZXNvdXJjZXMgbmV2ZXIgaGF2ZSByZWNvbmNpbGVyIG1hbmFnZWQgY2hpbGRyZW4uIEl0IGlzIHBvc3NpYmxlIGZvclxuICAvLyB0aGUgaG9zdCBpbXBsZW1lbnRhdGlvbiBvZiBnZXRSZXNvdXJjZSB0byBjb25zaWRlciBjaGlsZHJlbiBpbiB0aGVcbiAgLy8gcmVzb3VyY2UgY29uc3RydWN0aW9uIGJ1dCB0aGV5IHdpbGwgb3RoZXJ3aXNlIGJlIGRpc2NhcmRlZC4gSW4gcHJhY3RpY2VcbiAgLy8gdGhpcyBwcmVjbHVkZXMgYWxsIGJ1dCB0aGUgc2ltcGxlc3QgY2hpbGRyZW4gYW5kIEhvc3Qgc3BlY2lmaWMgd2FybmluZ3NcbiAgLy8gc2hvdWxkIGJlIGltcGxlbWVudGVkIHRvIHdhcm4gd2hlbiBjaGlsZHJlbiBhcmUgcGFzc3NlZCB3aGVuIG90aGVyd2lzZSBub3RcbiAgLy8gZXhwZWN0ZWRcblxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVIb3N0U2luZ2xldG9uKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgY2xhaW1IeWRyYXRhYmxlU2luZ2xldG9uKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW47XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwgJiYgIWdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAvLyBTaW1pbGFyIHRvIFBvcnRhbHMgd2UgYXBwZW5kIFNpbmdsZXRvbiBjaGlsZHJlbiBpbiB0aGUgY29tbWl0IHBoYXNlLiBTbyB3ZVxuICAgIC8vIFRyYWNrIGluc2VydGlvbnMgZXZlbiBvbiBtb3VudC5cbiAgICAvLyBUT0RPOiBDb25zaWRlciB1bmlmeWluZyB0aGlzIHdpdGggaG93IHRoZSByb290IHdvcmtzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RUZXh0JDEoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVUZXh0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICB9IC8vIE5vdGhpbmcgdG8gZG8gaGVyZS4gVGhpcyBpcyB0ZXJtaW5hbC4gV2UnbGwgZG8gdGhlIGNvbXBsZXRpb24gc3RlcFxuICAvLyBpbW1lZGlhdGVseSBhZnRlci5cblxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBtb3VudExhenlDb21wb25lbnQoX2N1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBlbGVtZW50VHlwZSwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIHByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgbGF6eUNvbXBvbmVudCA9IGVsZW1lbnRUeXBlO1xuICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcbiAgdmFyIENvbXBvbmVudCA9IGluaXQocGF5bG9hZCk7IC8vIFN0b3JlIHRoZSB1bndyYXBwZWQgY29tcG9uZW50IGluIHRoZSB0eXBlLlxuXG4gIHdvcmtJblByb2dyZXNzLnR5cGUgPSBDb21wb25lbnQ7XG5cbiAgaWYgKHR5cGVvZiBDb21wb25lbnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpZiAoaXNGdW5jdGlvbkNsYXNzQ29tcG9uZW50KENvbXBvbmVudCkpIHtcbiAgICAgIHZhciByZXNvbHZlZFByb3BzID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoQ29tcG9uZW50LCBwcm9wcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBDbGFzc0NvbXBvbmVudDtcblxuICAgICAge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gQ29tcG9uZW50ID0gcmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKENvbXBvbmVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVDbGFzc0NvbXBvbmVudChudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfcmVzb2x2ZWRQcm9wcyA9IHByb3BzIDtcblxuICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gRnVuY3Rpb25Db21wb25lbnQ7XG5cbiAgICAgIHtcbiAgICAgICAgdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQpO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gQ29tcG9uZW50ID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKENvbXBvbmVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChudWxsLCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBfcmVzb2x2ZWRQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChDb21wb25lbnQgIT09IHVuZGVmaW5lZCAmJiBDb21wb25lbnQgIT09IG51bGwpIHtcbiAgICB2YXIgJCR0eXBlb2YgPSBDb21wb25lbnQuJCR0eXBlb2Y7XG5cbiAgICBpZiAoJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUpIHtcbiAgICAgIHZhciBfcmVzb2x2ZWRQcm9wczIgPSBwcm9wcyA7XG5cbiAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IEZvcndhcmRSZWY7XG5cbiAgICAgIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudCA9IHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKENvbXBvbmVudCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVGb3J3YXJkUmVmKG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIF9yZXNvbHZlZFByb3BzMiwgcmVuZGVyTGFuZXMpO1xuICAgIH0gZWxzZSBpZiAoJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkge1xuICAgICAgdmFyIF9yZXNvbHZlZFByb3BzMyA9IHByb3BzIDtcblxuICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gTWVtb0NvbXBvbmVudDtcbiAgICAgIHJldHVybiB1cGRhdGVNZW1vQ29tcG9uZW50KG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIF9yZXNvbHZlZFByb3BzMyAsIC8vIFRoZSBpbm5lciB0eXBlIGNhbiBoYXZlIGRlZmF1bHRzIHRvb1xuICAgICAgcmVuZGVyTGFuZXMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBoaW50ID0gJyc7XG5cbiAge1xuICAgIGlmIChDb21wb25lbnQgIT09IG51bGwgJiYgdHlwZW9mIENvbXBvbmVudCA9PT0gJ29iamVjdCcgJiYgQ29tcG9uZW50LiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUpIHtcbiAgICAgIGhpbnQgPSAnIERpZCB5b3Ugd3JhcCBhIGNvbXBvbmVudCBpbiBSZWFjdC5sYXp5KCkgbW9yZSB0aGFuIG9uY2U/JztcbiAgICB9XG4gIH0gLy8gVGhpcyBtZXNzYWdlIGludGVudGlvbmFsbHkgZG9lc24ndCBtZW50aW9uIEZvcndhcmRSZWYgb3IgTWVtb0NvbXBvbmVudFxuICAvLyBiZWNhdXNlIHRoZSBmYWN0IHRoYXQgaXQncyBhIHNlcGFyYXRlIHR5cGUgb2Ygd29yayBpcyBhblxuICAvLyBpbXBsZW1lbnRhdGlvbiBkZXRhaWwuXG5cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJFbGVtZW50IHR5cGUgaXMgaW52YWxpZC4gUmVjZWl2ZWQgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG86IFwiICsgQ29tcG9uZW50ICsgXCIuIFwiICsgKFwiTGF6eSBlbGVtZW50IHR5cGUgbXVzdCByZXNvbHZlIHRvIGEgY2xhc3Mgb3IgZnVuY3Rpb24uXCIgKyBoaW50KSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50KSB7XG4gIHtcbiAgICBpZiAoQ29tcG9uZW50KSB7XG4gICAgICBpZiAoQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzKSB7XG4gICAgICAgIGVycm9yKCdjaGlsZENvbnRleHRUeXBlcyBjYW5ub3QgYmUgZGVmaW5lZCBvbiBhIGZ1bmN0aW9uIGNvbXBvbmVudC5cXG4nICsgJyAgJXMuY2hpbGRDb250ZXh0VHlwZXMgPSAuLi4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lMiA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50W19jb21wb25lbnROYW1lMl0pIHtcbiAgICAgICAgZXJyb3IoJyVzOiBGdW5jdGlvbiBjb21wb25lbnRzIGRvIG5vdCBzdXBwb3J0IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4nLCBfY29tcG9uZW50TmFtZTIpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUyXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBDb21wb25lbnQuY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIENvbXBvbmVudC5jb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgICAgdmFyIF9jb21wb25lbnROYW1lMyA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShDb21wb25lbnQpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUzXSkge1xuICAgICAgICBlcnJvcignJXM6IEZ1bmN0aW9uIGNvbXBvbmVudHMgZG8gbm90IHN1cHBvcnQgY29udGV4dFR5cGUuJywgX2NvbXBvbmVudE5hbWUzKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUzXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBTVVNQRU5ERURfTUFSS0VSID0ge1xuICBkZWh5ZHJhdGVkOiBudWxsLFxuICB0cmVlQ29udGV4dDogbnVsbCxcbiAgcmV0cnlMYW5lOiBOb0xhbmVcbn07XG5cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcykge1xuICByZXR1cm4ge1xuICAgIGJhc2VMYW5lczogcmVuZGVyTGFuZXMsXG4gICAgY2FjaGVQb29sOiBnZXRTdXNwZW5kZWRDYWNoZSgpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocHJldk9mZnNjcmVlblN0YXRlLCByZW5kZXJMYW5lcykge1xuICB2YXIgY2FjaGVQb29sID0gbnVsbDtcblxuICB7XG4gICAgdmFyIHByZXZDYWNoZVBvb2wgPSBwcmV2T2Zmc2NyZWVuU3RhdGUuY2FjaGVQb29sO1xuXG4gICAgaWYgKHByZXZDYWNoZVBvb2wgIT09IG51bGwpIHtcbiAgICAgIHZhciBwYXJlbnRDYWNoZSA9IGlzUHJpbWFyeVJlbmRlcmVyID8gQ2FjaGVDb250ZXh0Ll9jdXJyZW50VmFsdWUgOiBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZTI7XG5cbiAgICAgIGlmIChwcmV2Q2FjaGVQb29sLnBhcmVudCAhPT0gcGFyZW50Q2FjaGUpIHtcbiAgICAgICAgLy8gRGV0ZWN0ZWQgYSByZWZyZXNoIGluIHRoZSBwYXJlbnQuIFRoaXMgb3ZlcnJpZGVzIGFueSBwcmV2aW91c2x5XG4gICAgICAgIC8vIHN1c3BlbmRlZCBjYWNoZS5cbiAgICAgICAgY2FjaGVQb29sID0ge1xuICAgICAgICAgIHBhcmVudDogcGFyZW50Q2FjaGUsXG4gICAgICAgICAgcG9vbDogcGFyZW50Q2FjaGVcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdlIGNhbiByZXVzZSB0aGUgY2FjaGUgZnJvbSBsYXN0IHRpbWUuIFRoZSBvbmx5IHRoaW5nIHRoYXQgd291bGQgaGF2ZVxuICAgICAgICAvLyBvdmVycmlkZGVuIGl0IGlzIGEgcGFyZW50IHJlZnJlc2gsIHdoaWNoIHdlIGNoZWNrZWQgZm9yIGFib3ZlLlxuICAgICAgICBjYWNoZVBvb2wgPSBwcmV2Q2FjaGVQb29sO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGVyZSdzIG5vIHByZXZpb3VzIGNhY2hlIHBvb2wsIGdyYWIgdGhlIGN1cnJlbnQgb25lLlxuICAgICAgY2FjaGVQb29sID0gZ2V0U3VzcGVuZGVkQ2FjaGUoKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGJhc2VMYW5lczogbWVyZ2VMYW5lcyhwcmV2T2Zmc2NyZWVuU3RhdGUuYmFzZUxhbmVzLCByZW5kZXJMYW5lcyksXG4gICAgY2FjaGVQb29sOiBjYWNoZVBvb2xcbiAgfTtcbn0gLy8gVE9ETzogUHJvYmFibHkgc2hvdWxkIGlubGluZSB0aGlzIGJhY2tcblxuXG5mdW5jdGlvbiBzaG91bGRSZW1haW5PbkZhbGxiYWNrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAvLyBJZiB3ZSdyZSBhbHJlYWR5IHNob3dpbmcgYSBmYWxsYmFjaywgdGhlcmUgYXJlIGNhc2VzIHdoZXJlIHdlIG5lZWQgdG9cbiAgLy8gcmVtYWluIG9uIHRoYXQgZmFsbGJhY2sgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZSBjb250ZW50IGhhcyByZXNvbHZlZC5cbiAgLy8gRm9yIGV4YW1wbGUsIFN1c3BlbnNlTGlzdCBjb29yZGluYXRlcyB3aGVuIG5lc3RlZCBjb250ZW50IGFwcGVhcnMuXG4gIC8vIFRPRE86IEZvciBjb21wYXRpYmlsaXR5IHdpdGggb2Zmc2NyZWVuIHByZXJlbmRlcmluZywgdGhpcyBzaG91bGQgYWxzbyBjaGVja1xuICAvLyB3aGV0aGVyIHRoZSBjdXJyZW50IGZpYmVyIChpZiBpdCBleGlzdHMpIHdhcyB2aXNpYmxlIGluIHRoZSBwcmV2aW91cyB0cmVlLlxuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIHZhciBzdXNwZW5zZVN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG4gICAgaWYgKHN1c3BlbnNlU3RhdGUgPT09IG51bGwpIHtcbiAgICAgIC8vIEN1cnJlbnRseSBzaG93aW5nIGNvbnRlbnQuIERvbid0IGhpZGUgaXQsIGV2ZW4gaWYgRm9yY2VTdXNwZW5zZUZhbGxiYWNrXG4gICAgICAvLyBpcyB0cnVlLiBNb3JlIHByZWNpc2UgbmFtZSBtaWdodCBiZSBcIkZvcmNlUmVtYWluU3VzcGVuc2VGYWxsYmFja1wiLlxuICAgICAgLy8gTm90ZTogVGhpcyBpcyBhIGZhY3RvcmluZyBzbWVsbC4gQ2FuJ3QgcmVtYWluIG9uIGEgZmFsbGJhY2sgaWYgdGhlcmUnc1xuICAgICAgLy8gbm8gZmFsbGJhY2sgdG8gcmVtYWluIG9uLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSAvLyBOb3QgY3VycmVudGx5IHNob3dpbmcgY29udGVudC4gQ29uc3VsdCB0aGUgU3VzcGVuc2UgY29udGV4dC5cblxuXG4gIHZhciBzdXNwZW5zZUNvbnRleHQgPSBzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG4gIHJldHVybiBoYXNTdXNwZW5zZUxpc3RDb250ZXh0KHN1c3BlbnNlQ29udGV4dCwgRm9yY2VTdXNwZW5zZUZhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUoY3VycmVudCwgcHJpbWFyeVRyZWVEaWREZWZlciwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIHJlbWFpbmluZ0xhbmVzID0gY3VycmVudCAhPT0gbnVsbCA/IHJlbW92ZUxhbmVzKGN1cnJlbnQuY2hpbGRMYW5lcywgcmVuZGVyTGFuZXMpIDogTm9MYW5lcztcblxuICBpZiAocHJpbWFyeVRyZWVEaWREZWZlcikge1xuICAgIC8vIEEgdXNlRGVmZXJyZWRWYWx1ZSBob29rIHNwYXduZWQgYSBkZWZlcnJlZCB0YXNrIGluc2lkZSB0aGUgcHJpbWFyeSB0cmVlLlxuICAgIC8vIEVuc3VyZSB0aGF0IHdlIHJldHJ5IHRoaXMgY29tcG9uZW50IGF0IHRoZSBkZWZlcnJlZCBwcmlvcml0eS5cbiAgICAvLyBUT0RPOiBXZSBjb3VsZCBtYWtlIHRoaXMgYSBwZXItc3VidHJlZSB2YWx1ZSBpbnN0ZWFkIG9mIGEgZ2xvYmFsIG9uZS5cbiAgICAvLyBXb3VsZCBuZWVkIHRvIHRyYWNrIGl0IG9uIHRoZSBjb250ZXh0IHN0YWNrIHNvbWVob3csIHNpbWlsYXIgdG8gd2hhdFxuICAgIC8vIHdlJ2QgaGF2ZSB0byBkbyBmb3IgcmVzdW1hYmxlIGNvbnRleHRzLlxuICAgIHJlbWFpbmluZ0xhbmVzID0gbWVyZ2VMYW5lcyhyZW1haW5pbmdMYW5lcywgcGVla0RlZmVycmVkTGFuZSgpKTtcbiAgfVxuXG4gIHJldHVybiByZW1haW5pbmdMYW5lcztcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7IC8vIFRoaXMgaXMgdXNlZCBieSBEZXZUb29scyB0byBmb3JjZSBhIGJvdW5kYXJ5IHRvIHN1c3BlbmQuXG5cbiAge1xuICAgIGlmIChzaG91bGRTdXNwZW5kKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICB9XG4gIH1cblxuICB2YXIgc2hvd0ZhbGxiYWNrID0gZmFsc2U7XG4gIHZhciBkaWRTdXNwZW5kID0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3MkMTtcblxuICBpZiAoZGlkU3VzcGVuZCB8fCBzaG91bGRSZW1haW5PbkZhbGxiYWNrKGN1cnJlbnQpKSB7XG4gICAgLy8gU29tZXRoaW5nIGluIHRoaXMgYm91bmRhcnkncyBzdWJ0cmVlIGFscmVhZHkgc3VzcGVuZGVkLiBTd2l0Y2ggdG9cbiAgICAvLyByZW5kZXJpbmcgdGhlIGZhbGxiYWNrIGNoaWxkcmVuLlxuICAgIHNob3dGYWxsYmFjayA9IHRydWU7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gfkRpZENhcHR1cmU7XG4gIH0gLy8gQ2hlY2sgaWYgdGhlIHByaW1hcnkgY2hpbGRyZW4gc3Bhd25lZCBhIGRlZmVycmVkIHRhc2sgKHVzZURlZmVycmVkVmFsdWUpXG4gIC8vIGR1cmluZyB0aGUgZmlyc3QgcGFzcy5cblxuXG4gIHZhciBkaWRQcmltYXJ5Q2hpbGRyZW5EZWZlciA9ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZERlZmVyKSAhPT0gTm9GbGFncyQxO1xuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSB+RGlkRGVmZXI7IC8vIE9LLCB0aGUgbmV4dCBwYXJ0IGlzIGNvbmZ1c2luZy4gV2UncmUgYWJvdXQgdG8gcmVjb25jaWxlIHRoZSBTdXNwZW5zZVxuICAvLyBib3VuZGFyeSdzIGNoaWxkcmVuLiBUaGlzIGludm9sdmVzIHNvbWUgY3VzdG9tIHJlY29uY2lsaWF0aW9uIGxvZ2ljLiBUd29cbiAgLy8gbWFpbiByZWFzb25zIHRoaXMgaXMgc28gY29tcGxpY2F0ZWQuXG4gIC8vXG4gIC8vIEZpcnN0LCBMZWdhY3kgTW9kZSBoYXMgZGlmZmVyZW50IHNlbWFudGljcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuIFRoZVxuICAvLyBwcmltYXJ5IHRyZWUgd2lsbCBjb21taXQgaW4gYW4gaW5jb25zaXN0ZW50IHN0YXRlLCBzbyB3aGVuIHdlIGRvIHRoZVxuICAvLyBzZWNvbmQgcGFzcyB0byByZW5kZXIgdGhlIGZhbGxiYWNrLCB3ZSBkbyBzb21lIGV4Y2VlZGluZ2x5LCB1aCwgY2xldmVyXG4gIC8vIGhhY2tzIHRvIG1ha2UgdGhhdCBub3QgdG90YWxseSBicmVhay4gTGlrZSB0cmFuc2ZlcnJpbmcgZWZmZWN0cyBhbmRcbiAgLy8gZGVsZXRpb25zIGZyb20gaGlkZGVuIHRyZWUuIEluIENvbmN1cnJlbnQgTW9kZSwgaXQncyBtdWNoIHNpbXBsZXIsXG4gIC8vIGJlY2F1c2Ugd2UgYmFpbG91dCBvbiB0aGUgcHJpbWFyeSB0cmVlIGNvbXBsZXRlbHkgYW5kIGxlYXZlIGl0IGluIGl0cyBvbGRcbiAgLy8gc3RhdGUsIG5vIGVmZmVjdHMuIFNhbWUgYXMgd2hhdCB3ZSBkbyBmb3IgT2Zmc2NyZWVuIChleGNlcHQgdGhhdFxuICAvLyBPZmZzY3JlZW4gZG9lc24ndCBoYXZlIHRoZSBmaXJzdCByZW5kZXIgcGFzcykuXG4gIC8vXG4gIC8vIFNlY29uZCBpcyBoeWRyYXRpb24uIER1cmluZyBoeWRyYXRpb24sIHRoZSBTdXNwZW5zZSBmaWJlciBoYXMgYSBzbGlnaHRseVxuICAvLyBkaWZmZXJlbnQgbGF5b3V0LCB3aGVyZSB0aGUgY2hpbGQgcG9pbnRzIHRvIGEgZGVoeWRyYXRlZCBmcmFnbWVudCwgd2hpY2hcbiAgLy8gY29udGFpbnMgdGhlIERPTSByZW5kZXJlZCBieSB0aGUgc2VydmVyLlxuICAvL1xuICAvLyBUaGlyZCwgZXZlbiBpZiB5b3Ugc2V0IGFsbCB0aGF0IGFzaWRlLCBTdXNwZW5zZSBpcyBsaWtlIGVycm9yIGJvdW5kYXJpZXMgaW5cbiAgLy8gdGhhdCB3ZSBmaXJzdCB3ZSB0cnkgdG8gcmVuZGVyIG9uZSB0cmVlLCBhbmQgaWYgdGhhdCBmYWlscywgd2UgcmVuZGVyIGFnYWluXG4gIC8vIGFuZCBzd2l0Y2ggdG8gYSBkaWZmZXJlbnQgdHJlZS4gTGlrZSBhIHRyeS9jYXRjaCBibG9jay4gU28gd2UgaGF2ZSB0byB0cmFja1xuICAvLyB3aGljaCBicmFuY2ggd2UncmUgY3VycmVudGx5IHJlbmRlcmluZy4gSWRlYWxseSB3ZSB3b3VsZCBtb2RlbCB0aGlzIHVzaW5nXG4gIC8vIGEgc3RhY2suXG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBJbml0aWFsIG1vdW50XG4gICAgLy8gU3BlY2lhbCBwYXRoIGZvciBoeWRyYXRpb25cbiAgICAvLyBJZiB3ZSdyZSBjdXJyZW50bHkgaHlkcmF0aW5nLCB0cnkgdG8gaHlkcmF0ZSB0aGlzIGJvdW5kYXJ5LlxuICAgIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgICAvLyBXZSBtdXN0IHB1c2ggdGhlIHN1c3BlbnNlIGhhbmRsZXIgY29udGV4dCAqYmVmb3JlKiBhdHRlbXB0aW5nIHRvXG4gICAgICAvLyBoeWRyYXRlLCB0byBhdm9pZCBhIG1pc21hdGNoIGluIGNhc2UgaXQgZXJyb3JzLlxuICAgICAgaWYgKHNob3dGYWxsYmFjaykge1xuICAgICAgICBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHVzaEZhbGxiYWNrVHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG5cbiAgICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZVN1c3BlbnNlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpOyAvLyBUaGlzIGNvdWxkJ3ZlIGJlZW4gYSBkZWh5ZHJhdGVkIHN1c3BlbnNlIGNvbXBvbmVudC5cblxuICAgICAgdmFyIHN1c3BlbnNlU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICBpZiAoc3VzcGVuc2VTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgZGVoeWRyYXRlZCA9IHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZDtcblxuICAgICAgICBpZiAoZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBtb3VudERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudCh3b3JrSW5Qcm9ncmVzcywgZGVoeWRyYXRlZCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gSWYgaHlkcmF0aW9uIGRpZG4ndCBzdWNjZWVkLCBmYWxsIHRocm91Z2ggdG8gdGhlIG5vcm1hbCBTdXNwZW5zZSBwYXRoLlxuICAgICAgLy8gVG8gYXZvaWQgYSBzdGFjayBtaXNtYXRjaCB3ZSBuZWVkIHRvIHBvcCB0aGUgU3VzcGVuc2UgaGFuZGxlciB0aGF0IHdlXG4gICAgICAvLyBwdXNoZWQgYWJvdmUuIFRoaXMgd2lsbCBiZWNvbWUgbGVzcyBhd2t3YXJkIHdoZW4gbW92ZSB0aGUgaHlkcmF0aW9uXG4gICAgICAvLyBsb2dpYyB0byBpdHMgb3duIGZpYmVyLlxuXG5cbiAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgdmFyIG5leHRQcmltYXJ5Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gICAgdmFyIG5leHRGYWxsYmFja0NoaWxkcmVuID0gbmV4dFByb3BzLmZhbGxiYWNrO1xuXG4gICAgaWYgKHNob3dGYWxsYmFjaykge1xuICAgICAgcHVzaEZhbGxiYWNrVHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB2YXIgZmFsbGJhY2tGcmFnbWVudCA9IG1vdW50U3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBuZXh0UHJpbWFyeUNoaWxkcmVuLCBuZXh0RmFsbGJhY2tDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgICAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5tZW1vaXplZFN0YXRlID0gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKTtcbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LmNoaWxkTGFuZXMgPSBnZXRSZW1haW5pbmdXb3JrSW5QcmltYXJ5VHJlZShjdXJyZW50LCBkaWRQcmltYXJ5Q2hpbGRyZW5EZWZlciwgcmVuZGVyTGFuZXMpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IFNVU1BFTkRFRF9NQVJLRVI7XG5cbiAgICAgIHJldHVybiBmYWxsYmFja0ZyYWdtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIG5leHRQcmltYXJ5Q2hpbGRyZW4pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIGFuIHVwZGF0ZS5cbiAgICAvLyBTcGVjaWFsIHBhdGggZm9yIGh5ZHJhdGlvblxuICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2RlaHlkcmF0ZWQgPSBwcmV2U3RhdGUuZGVoeWRyYXRlZDtcblxuICAgICAgaWYgKF9kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGRpZFN1c3BlbmQsIGRpZFByaW1hcnlDaGlsZHJlbkRlZmVyLCBuZXh0UHJvcHMsIF9kZWh5ZHJhdGVkLCBwcmV2U3RhdGUsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hvd0ZhbGxiYWNrKSB7XG4gICAgICBwdXNoRmFsbGJhY2tUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHZhciBfbmV4dEZhbGxiYWNrQ2hpbGRyZW4gPSBuZXh0UHJvcHMuZmFsbGJhY2s7XG4gICAgICB2YXIgX25leHRQcmltYXJ5Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gICAgICB2YXIgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gdXBkYXRlU3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfbmV4dFByaW1hcnlDaGlsZHJlbiwgX25leHRGYWxsYmFja0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50MiA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgdmFyIHByZXZPZmZzY3JlZW5TdGF0ZSA9IGN1cnJlbnQuY2hpbGQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDIubWVtb2l6ZWRTdGF0ZSA9IHByZXZPZmZzY3JlZW5TdGF0ZSA9PT0gbnVsbCA/IG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcykgOiB1cGRhdGVTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHByZXZPZmZzY3JlZW5TdGF0ZSwgcmVuZGVyTGFuZXMpO1xuXG4gICAgICBfcHJpbWFyeUNoaWxkRnJhZ21lbnQyLmNoaWxkTGFuZXMgPSBnZXRSZW1haW5pbmdXb3JrSW5QcmltYXJ5VHJlZShjdXJyZW50LCBkaWRQcmltYXJ5Q2hpbGRyZW5EZWZlciwgcmVuZGVyTGFuZXMpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IFNVU1BFTkRFRF9NQVJLRVI7XG4gICAgICByZXR1cm4gZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgdmFyIF9uZXh0UHJpbWFyeUNoaWxkcmVuMiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgICAgdmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDMgPSB1cGRhdGVTdXNwZW5zZVByaW1hcnlDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX25leHRQcmltYXJ5Q2hpbGRyZW4yKTtcblxuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICByZXR1cm4gX3ByaW1hcnlDaGlsZEZyYWdtZW50MztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICB2YXIgbW9kZSA9IHdvcmtJblByb2dyZXNzLm1vZGU7XG4gIHZhciBwcmltYXJ5Q2hpbGRQcm9wcyA9IHtcbiAgICBtb2RlOiAndmlzaWJsZScsXG4gICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuICB9O1xuICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIocHJpbWFyeUNoaWxkUHJvcHMsIG1vZGUpO1xuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbiAgcmV0dXJuIHByaW1hcnlDaGlsZEZyYWdtZW50O1xufVxuXG5mdW5jdGlvbiBtb3VudFN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuLCBmYWxsYmFja0NoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICB2YXIgbW9kZSA9IHdvcmtJblByb2dyZXNzLm1vZGU7XG4gIHZhciBwcmltYXJ5Q2hpbGRQcm9wcyA9IHtcbiAgICBtb2RlOiAnaGlkZGVuJyxcbiAgICBjaGlsZHJlbjogcHJpbWFyeUNoaWxkcmVuXG4gIH07XG4gIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbiAgdmFyIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcblxuICB7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIocHJpbWFyeUNoaWxkUHJvcHMsIG1vZGUpO1xuICAgIGZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZhbGxiYWNrQ2hpbGRyZW4sIG1vZGUsIHJlbmRlckxhbmVzLCBudWxsKTtcbiAgfVxuXG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICBmYWxsYmFja0NoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgPSBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG4gIHJldHVybiBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihvZmZzY3JlZW5Qcm9wcywgbW9kZSwgcmVuZGVyTGFuZXMpIHtcbiAgLy8gVGhlIHByb3BzIGFyZ3VtZW50IHRvIGBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW5gIGlzIGBhbnlgIHR5cGVkLCBzbyB3ZSB1c2VcbiAgLy8gdGhpcyB3cmFwcGVyIGZ1bmN0aW9uIHRvIGNvbnN0cmFpbiBpdC5cbiAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbihvZmZzY3JlZW5Qcm9wcywgbW9kZSwgTm9MYW5lcywgbnVsbCk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoY3VycmVudCwgb2Zmc2NyZWVuUHJvcHMpIHtcbiAgLy8gVGhlIHByb3BzIGFyZ3VtZW50IHRvIGBjcmVhdGVXb3JrSW5Qcm9ncmVzc2AgaXMgYGFueWAgdHlwZWQsIHNvIHdlIHVzZSB0aGlzXG4gIC8vIHdyYXBwZXIgZnVuY3Rpb24gdG8gY29uc3RyYWluIGl0LlxuICByZXR1cm4gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgb2Zmc2NyZWVuUHJvcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZVByaW1hcnlDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICB2YXIgY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50ID0gY3VycmVudC5jaGlsZDtcbiAgdmFyIGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZztcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQsIHtcbiAgICBtb2RlOiAndmlzaWJsZScsXG4gICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuICB9KTtcblxuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZyA9IG51bGw7XG5cbiAgaWYgKGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAvLyBEZWxldGUgdGhlIGZhbGxiYWNrIGNoaWxkIGZyYWdtZW50XG4gICAgdmFyIGRlbGV0aW9ucyA9IHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucztcblxuICAgIGlmIChkZWxldGlvbnMgPT09IG51bGwpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyA9IFtjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50XTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IENoaWxkRGVsZXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0aW9ucy5wdXNoKGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG4gIHJldHVybiBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4sIGZhbGxiYWNrQ2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIHZhciBtb2RlID0gd29ya0luUHJvZ3Jlc3MubW9kZTtcbiAgdmFyIGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudCA9IGN1cnJlbnQuY2hpbGQ7XG4gIHZhciBjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmc7XG4gIHZhciBwcmltYXJ5Q2hpbGRQcm9wcyA9IHtcbiAgICBtb2RlOiAnaGlkZGVuJyxcbiAgICBjaGlsZHJlbjogcHJpbWFyeUNoaWxkcmVuXG4gIH07XG4gIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcblxuICB7XG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudCwgcHJpbWFyeUNoaWxkUHJvcHMpOyAvLyBTaW5jZSB3ZSdyZSByZXVzaW5nIGEgY3VycmVudCB0cmVlLCB3ZSBuZWVkIHRvIHJldXNlIHRoZSBmbGFncywgdG9vLlxuICAgIC8vIChXZSBkb24ndCBkbyB0aGlzIGluIGxlZ2FjeSBtb2RlLCBiZWNhdXNlIGluIGxlZ2FjeSBtb2RlIHdlIGRvbid0IHJlLXVzZVxuICAgIC8vIHRoZSBjdXJyZW50IHRyZWU7IHNlZSBwcmV2aW91cyBicmFuY2guKVxuXG4gICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuc3VidHJlZUZsYWdzID0gY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LnN1YnRyZWVGbGFncyAmIFN0YXRpY01hc2s7XG4gIH1cblxuICB2YXIgZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuXG4gIGlmIChjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCwgZmFsbGJhY2tDaGlsZHJlbik7XG4gIH0gZWxzZSB7XG4gICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZmFsbGJhY2tDaGlsZHJlbiwgbW9kZSwgcmVuZGVyTGFuZXMsIG51bGwpOyAvLyBOZWVkcyBhIHBsYWNlbWVudCBlZmZlY3QgYmVjYXVzZSB0aGUgcGFyZW50ICh0aGUgU3VzcGVuc2UgYm91bmRhcnkpIGFscmVhZHlcbiAgICAvLyBtb3VudGVkIGJ1dCB0aGlzIGlzIGEgbmV3IGZpYmVyLlxuXG4gICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50LmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgfVxuXG4gIGZhbGxiYWNrQ2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnNpYmxpbmcgPSBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG4gIHJldHVybiBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAvLyBGYWxsaW5nIGJhY2sgdG8gY2xpZW50IHJlbmRlcmluZy4gQmVjYXVzZSB0aGlzIGhhcyBwZXJmb3JtYW5jZVxuICAvLyBpbXBsaWNhdGlvbnMsIGl0J3MgY29uc2lkZXJlZCBhIHJlY292ZXJhYmxlIGVycm9yLCBldmVuIHRob3VnaCB0aGUgdXNlclxuICAvLyBsaWtlbHkgd29uJ3Qgb2JzZXJ2ZSBhbnl0aGluZyB3cm9uZyB3aXRoIHRoZSBVSS5cbiAgLy8gVGhpcyB3aWxsIGFkZCB0aGUgb2xkIGZpYmVyIHRvIHRoZSBkZWxldGlvbiBsaXN0XG4gIHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LmNoaWxkLCBudWxsLCByZW5kZXJMYW5lcyk7IC8vIFdlJ3JlIG5vdyBub3Qgc3VzcGVuZGVkIG5vciBkZWh5ZHJhdGVkLlxuXG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBwcmltYXJ5Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbik7IC8vIE5lZWRzIGEgcGxhY2VtZW50IGVmZmVjdCBiZWNhdXNlIHRoZSBwYXJlbnQgKHRoZSBTdXNwZW5zZSBib3VuZGFyeSkgYWxyZWFkeVxuICAvLyBtb3VudGVkIGJ1dCB0aGlzIGlzIGEgbmV3IGZpYmVyLlxuXG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIHJldHVybiBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZUZhbGxiYWNrQWZ0ZXJSZXRyeVdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbiwgZmFsbGJhY2tDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIGZpYmVyTW9kZSA9IHdvcmtJblByb2dyZXNzLm1vZGU7XG4gIHZhciBwcmltYXJ5Q2hpbGRQcm9wcyA9IHtcbiAgICBtb2RlOiAndmlzaWJsZScsXG4gICAgY2hpbGRyZW46IHByaW1hcnlDaGlsZHJlblxuICB9O1xuICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIocHJpbWFyeUNoaWxkUHJvcHMsIGZpYmVyTW9kZSk7XG4gIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChmYWxsYmFja0NoaWxkcmVuLCBmaWJlck1vZGUsIHJlbmRlckxhbmVzLCBudWxsKTsgLy8gTmVlZHMgYSBwbGFjZW1lbnQgZWZmZWN0IGJlY2F1c2UgdGhlIHBhcmVudCAodGhlIFN1c3BlbnNlXG4gIC8vIGJvdW5kYXJ5KSBhbHJlYWR5IG1vdW50ZWQgYnV0IHRoaXMgaXMgYSBuZXcgZmliZXIuXG5cbiAgZmFsbGJhY2tDaGlsZEZyYWdtZW50LmZsYWdzIHw9IFBsYWNlbWVudDtcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIGZhbGxiYWNrQ2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZyA9IGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcblxuICB7XG4gICAgLy8gV2Ugd2lsbCBoYXZlIGRyb3BwZWQgdGhlIGVmZmVjdCBsaXN0IHdoaWNoIGNvbnRhaW5zIHRoZVxuICAgIC8vIGRlbGV0aW9uLiBXZSBuZWVkIHRvIHJlY29uY2lsZSB0byBkZWxldGUgdGhlIGN1cnJlbnQgY2hpbGQuXG4gICAgcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQuY2hpbGQsIG51bGwsIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHJldHVybiBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIG1vdW50RGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50KHdvcmtJblByb2dyZXNzLCBzdXNwZW5zZUluc3RhbmNlLCByZW5kZXJMYW5lcykge1xuICAvLyBEdXJpbmcgdGhlIGZpcnN0IHBhc3MsIHdlJ2xsIGJhaWwgb3V0IGFuZCBub3QgZHJpbGwgaW50byB0aGUgY2hpbGRyZW4uXG4gIC8vIEluc3RlYWQsIHdlJ2xsIGxlYXZlIHRoZSBjb250ZW50IGluIHBsYWNlIGFuZCB0cnkgdG8gaHlkcmF0ZSBpdCBsYXRlci5cbiAgaWYgKGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrKHN1c3BlbnNlSW5zdGFuY2UpKSB7XG4gICAgLy8gVGhpcyBpcyBhIGNsaWVudC1vbmx5IGJvdW5kYXJ5LiBTaW5jZSB3ZSB3b24ndCBnZXQgYW55IGNvbnRlbnQgZnJvbSB0aGUgc2VydmVyXG4gICAgLy8gZm9yIHRoaXMsIHdlIG5lZWQgdG8gc2NoZWR1bGUgdGhhdCBhdCBhIGhpZ2hlciBwcmlvcml0eSBiYXNlZCBvbiB3aGVuIGl0IHdvdWxkXG4gICAgLy8gaGF2ZSB0aW1lZCBvdXQuIEluIHRoZW9yeSB3ZSBjb3VsZCByZW5kZXIgaXQgaW4gdGhpcyBwYXNzIGJ1dCBpdCB3b3VsZCBoYXZlIHRoZVxuICAgIC8vIHdyb25nIHByaW9yaXR5IGFzc29jaWF0ZWQgd2l0aCBpdCBhbmQgd2lsbCBwcmV2ZW50IGh5ZHJhdGlvbiBvZiBwYXJlbnQgcGF0aC5cbiAgICAvLyBJbnN0ZWFkLCB3ZSdsbCBsZWF2ZSB3b3JrIGxlZnQgb24gaXQgdG8gcmVuZGVyIGl0IGluIGEgc2VwYXJhdGUgY29tbWl0LlxuICAgIC8vIFRPRE8gVGhpcyB0aW1lIHNob3VsZCBiZSB0aGUgdGltZSBhdCB3aGljaCB0aGUgc2VydmVyIHJlbmRlcmVkIHJlc3BvbnNlIHRoYXQgaXNcbiAgICAvLyBhIHBhcmVudCB0byB0aGlzIGJvdW5kYXJ5IHdhcyBkaXNwbGF5ZWQuIEhvd2V2ZXIsIHNpbmNlIHdlIGN1cnJlbnRseSBkb24ndCBoYXZlXG4gICAgLy8gYSBwcm90b2NvbCB0byB0cmFuc2ZlciB0aGF0IHRpbWUsIHdlJ2xsIGp1c3QgZXN0aW1hdGUgaXQgYnkgdXNpbmcgdGhlIGN1cnJlbnRcbiAgICAvLyB0aW1lLiBUaGlzIHdpbGwgbWVhbiB0aGF0IFN1c3BlbnNlIHRpbWVvdXRzIGFyZSBzbGlnaHRseSBzaGlmdGVkIHRvIGxhdGVyIHRoYW5cbiAgICAvLyB0aGV5IHNob3VsZCBiZS5cbiAgICAvLyBTY2hlZHVsZSBhIG5vcm1hbCBwcmkgdXBkYXRlIHRvIHJlbmRlciB0aGlzIGNvbnRlbnQuXG4gICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBsYW5lVG9MYW5lcyhEZWZhdWx0SHlkcmF0aW9uTGFuZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UnbGwgY29udGludWUgaHlkcmF0aW5nIHRoZSByZXN0IGF0IG9mZnNjcmVlbiBwcmlvcml0eSBzaW5jZSB3ZSdsbCBhbHJlYWR5XG4gICAgLy8gYmUgc2hvd2luZyB0aGUgcmlnaHQgY29udGVudCBjb21pbmcgZnJvbSB0aGUgc2VydmVyLCBpdCBpcyBubyBydXNoLlxuICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbGFuZVRvTGFuZXMoT2Zmc2NyZWVuTGFuZSk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBkaWRTdXNwZW5kLCBkaWRQcmltYXJ5Q2hpbGRyZW5EZWZlciwgbmV4dFByb3BzLCBzdXNwZW5zZUluc3RhbmNlLCBzdXNwZW5zZVN0YXRlLCByZW5kZXJMYW5lcykge1xuICBpZiAoIWRpZFN1c3BlbmQpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCByZW5kZXIgcGFzcy4gQXR0ZW1wdCB0byBoeWRyYXRlLlxuICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7IC8vIFdlIHNob3VsZCBuZXZlciBiZSBoeWRyYXRpbmcgYXQgdGhpcyBwb2ludCBiZWNhdXNlIGl0IGlzIHRoZSBmaXJzdCBwYXNzLFxuICAgIC8vIGJ1dCBhZnRlciB3ZSd2ZSBhbHJlYWR5IGNvbW1pdHRlZCBvbmNlLlxuXG4gICAgd2FybklmSHlkcmF0aW5nKCk7XG5cbiAgICBpZiAoaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2soc3VzcGVuc2VJbnN0YW5jZSkpIHtcbiAgICAgIC8vIFRoaXMgYm91bmRhcnkgaXMgaW4gYSBwZXJtYW5lbnQgZmFsbGJhY2sgc3RhdGUuIEluIHRoaXMgY2FzZSwgd2UnbGwgbmV2ZXJcbiAgICAgIC8vIGdldCBhbiB1cGRhdGUgYW5kIHdlJ2xsIG5ldmVyIGJlIGFibGUgdG8gaHlkcmF0ZSB0aGUgZmluYWwgY29udGVudC4gTGV0J3MganVzdCB0cnkgdGhlXG4gICAgICAvLyBjbGllbnQgc2lkZSByZW5kZXIgaW5zdGVhZC5cbiAgICAgIHZhciBkaWdlc3Q7XG4gICAgICB2YXIgbWVzc2FnZTtcbiAgICAgIHZhciBzdGFjayA9IG51bGw7XG4gICAgICB2YXIgY29tcG9uZW50U3RhY2sgPSBudWxsO1xuXG4gICAgICB7XG4gICAgICAgIHZhciBfZ2V0U3VzcGVuc2VJbnN0YW5jZUYgPSBnZXRTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2tFcnJvckRldGFpbHMoc3VzcGVuc2VJbnN0YW5jZSk7XG5cbiAgICAgICAgZGlnZXN0ID0gX2dldFN1c3BlbnNlSW5zdGFuY2VGLmRpZ2VzdDtcbiAgICAgICAgbWVzc2FnZSA9IF9nZXRTdXNwZW5zZUluc3RhbmNlRi5tZXNzYWdlO1xuICAgICAgICBzdGFjayA9IF9nZXRTdXNwZW5zZUluc3RhbmNlRi5zdGFjaztcbiAgICAgICAgY29tcG9uZW50U3RhY2sgPSBfZ2V0U3VzcGVuc2VJbnN0YW5jZUYuY29tcG9uZW50U3RhY2s7XG4gICAgICB9IC8vIFRPRE86IEZpZ3VyZSBvdXQgYSBiZXR0ZXIgc2lnbmFsIHRoYW4gZW5jb2RpbmcgYSBtYWdpYyBkaWdlc3QgdmFsdWUuXG5cblxuICAgICAge1xuICAgICAgICB2YXIgZXJyb3I7XG5cbiAgICAgICAgaWYgKG1lc3NhZ2UpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVycm9yID0gbmV3IEVycm9yKCdUaGUgc2VydmVyIGNvdWxkIG5vdCBmaW5pc2ggdGhpcyBTdXNwZW5zZSBib3VuZGFyeSwgbGlrZWx5ICcgKyAnZHVlIHRvIGFuIGVycm9yIGR1cmluZyBzZXJ2ZXIgcmVuZGVyaW5nLiAnICsgJ1N3aXRjaGVkIHRvIGNsaWVudCByZW5kZXJpbmcuJyk7XG4gICAgICAgIH0gLy8gUmVwbGFjZSB0aGUgc3RhY2sgd2l0aCB0aGUgc2VydmVyIHN0YWNrXG5cblxuICAgICAgICBlcnJvci5zdGFjayA9IHN0YWNrIHx8ICcnO1xuICAgICAgICBlcnJvci5kaWdlc3QgPSBkaWdlc3Q7XG4gICAgICAgIHZhciBjYXB0dXJlZFZhbHVlID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUZyb21FcnJvcihlcnJvciwgY29tcG9uZW50U3RhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb21wb25lbnRTdGFjayk7XG4gICAgICAgIHF1ZXVlSHlkcmF0aW9uRXJyb3IoY2FwdHVyZWRWYWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIH1cbiAgICAvLyBhbnkgY29udGV4dCBoYXMgY2hhbmdlZCwgd2UgbmVlZCB0byB0cmVhdCBpcyBhcyBpZiB0aGUgaW5wdXQgbWlnaHQgaGF2ZSBjaGFuZ2VkLlxuXG5cbiAgICB2YXIgaGFzQ29udGV4dENoYW5nZWQgPSBpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCBjdXJyZW50LmNoaWxkTGFuZXMpO1xuXG4gICAgaWYgKGRpZFJlY2VpdmVVcGRhdGUgfHwgaGFzQ29udGV4dENoYW5nZWQpIHtcbiAgICAgIC8vIFRoaXMgYm91bmRhcnkgaGFzIGNoYW5nZWQgc2luY2UgdGhlIGZpcnN0IHJlbmRlci4gVGhpcyBtZWFucyB0aGF0IHdlIGFyZSBub3cgdW5hYmxlIHRvXG4gICAgICAvLyBoeWRyYXRlIGl0LiBXZSBtaWdodCBzdGlsbCBiZSBhYmxlIHRvIGh5ZHJhdGUgaXQgdXNpbmcgYSBoaWdoZXIgcHJpb3JpdHkgbGFuZS5cbiAgICAgIHZhciByb290ID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCk7XG5cbiAgICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBhdHRlbXB0SHlkcmF0aW9uQXRMYW5lID0gZ2V0QnVtcGVkTGFuZUZvckh5ZHJhdGlvbihyb290LCByZW5kZXJMYW5lcyk7XG5cbiAgICAgICAgaWYgKGF0dGVtcHRIeWRyYXRpb25BdExhbmUgIT09IE5vTGFuZSAmJiBhdHRlbXB0SHlkcmF0aW9uQXRMYW5lICE9PSBzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZSkge1xuICAgICAgICAgIC8vIEludGVudGlvbmFsbHkgbXV0YXRpbmcgc2luY2UgdGhpcyByZW5kZXIgd2lsbCBnZXQgaW50ZXJydXB0ZWQuIFRoaXNcbiAgICAgICAgICAvLyBpcyBvbmUgb2YgdGhlIHZlcnkgcmFyZSB0aW1lcyB3aGVyZSB3ZSBtdXRhdGUgdGhlIGN1cnJlbnQgdHJlZVxuICAgICAgICAgIC8vIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuICAgICAgICAgIHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lID0gYXR0ZW1wdEh5ZHJhdGlvbkF0TGFuZTtcbiAgICAgICAgICBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoY3VycmVudCwgYXR0ZW1wdEh5ZHJhdGlvbkF0TGFuZSk7XG4gICAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGN1cnJlbnQsIGF0dGVtcHRIeWRyYXRpb25BdExhbmUpOyAvLyBUaHJvdyBhIHNwZWNpYWwgb2JqZWN0IHRoYXQgc2lnbmFscyB0byB0aGUgd29yayBsb29wIHRoYXQgaXQgc2hvdWxkXG4gICAgICAgICAgLy8gaW50ZXJydXB0IHRoZSBjdXJyZW50IHJlbmRlci5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIEJlY2F1c2Ugd2UncmUgaW5zaWRlIGEgUmVhY3Qtb25seSBleGVjdXRpb24gc3RhY2ssIHdlIGRvbid0XG4gICAgICAgICAgLy8gc3RyaWN0bHkgbmVlZCB0byB0aHJvdyBoZXJlIOKAlCB3ZSBjb3VsZCBpbnN0ZWFkIG1vZGlmeSBzb21lIGludGVybmFsXG4gICAgICAgICAgLy8gd29yayBsb29wIHN0YXRlLiBCdXQgdXNpbmcgYW4gZXhjZXB0aW9uIG1lYW5zIHdlIGRvbid0IG5lZWQgdG9cbiAgICAgICAgICAvLyBjaGVjayBmb3IgdGhpcyBjYXNlIG9uIGV2ZXJ5IGl0ZXJhdGlvbiBvZiB0aGUgd29yayBsb29wLiBTbyBkb2luZ1xuICAgICAgICAgIC8vIGl0IHRoaXMgd2F5IG1vdmVzIHRoZSBjaGVjayBvdXQgb2YgdGhlIGZhc3QgcGF0aC5cblxuICAgICAgICAgIHRocm93IFNlbGVjdGl2ZUh5ZHJhdGlvbkV4Y2VwdGlvbjtcbiAgICAgICAgfVxuICAgICAgfSAvLyBJZiB3ZSBkaWQgbm90IHNlbGVjdGl2ZWx5IGh5ZHJhdGUsIHdlJ2xsIGNvbnRpbnVlIHJlbmRlcmluZyB3aXRob3V0XG4gICAgICAvLyBoeWRyYXRpbmcuIE1hcmsgdGhpcyB0cmVlIGFzIHN1c3BlbmRlZCB0byBwcmV2ZW50IGl0IGZyb20gY29tbWl0dGluZ1xuICAgICAgLy8gb3V0c2lkZSBhIHRyYW5zaXRpb24uXG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBwYXRoIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGUgaHlkcmF0aW9uIGxhbmUgYWxyZWFkeSBzdXNwZW5kZWQuXG4gICAgICAvLyBDdXJyZW50bHksIGl0IGFsc28gaGFwcGVucyBkdXJpbmcgc3luYyB1cGRhdGVzIGJlY2F1c2UgdGhlcmUgaXMgbm9cbiAgICAgIC8vIGh5ZHJhdGlvbiBsYW5lIGZvciBzeW5jIHVwZGF0ZXMuXG4gICAgICAvLyBUT0RPOiBXZSBzaG91bGQgaWRlYWxseSBoYXZlIGEgc3luYyBoeWRyYXRpb24gbGFuZSB0aGF0IHdlIGNhbiBhcHBseSB0byBkb1xuICAgICAgLy8gYSBwYXNzIHdoZXJlIHdlIGh5ZHJhdGUgdGhpcyBzdWJ0cmVlIGluIHBsYWNlIHVzaW5nIHRoZSBwcmV2aW91cyBDb250ZXh0IGFuZCB0aGVuXG4gICAgICAvLyByZWFwcGx5IHRoZSB1cGRhdGUgYWZ0ZXJ3YXJkcy5cblxuXG4gICAgICBpZiAoaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyhzdXNwZW5zZUluc3RhbmNlKSkgOyBlbHNlIHtcbiAgICAgICAgcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICB9IGVsc2UgaWYgKGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcoc3VzcGVuc2VJbnN0YW5jZSkpIHtcbiAgICAgIC8vIFRoaXMgY29tcG9uZW50IGlzIHN0aWxsIHBlbmRpbmcgbW9yZSBkYXRhIGZyb20gdGhlIHNlcnZlciwgc28gd2UgY2FuJ3QgaHlkcmF0ZSBpdHNcbiAgICAgIC8vIGNvbnRlbnQuIFdlIHRyZWF0IGl0IGFzIGlmIHRoaXMgY29tcG9uZW50IHN1c3BlbmRlZCBpdHNlbGYuIEl0IG1pZ2h0IHNlZW0gYXMgaWZcbiAgICAgIC8vIHdlIGNvdWxkIGp1c3QgdHJ5IHRvIHJlbmRlciBpdCBjbGllbnQtc2lkZSBpbnN0ZWFkLiBIb3dldmVyLCB0aGlzIHdpbGwgcGVyZm9ybSBhXG4gICAgICAvLyBsb3Qgb2YgdW5uZWNlc3Nhcnkgd29yayBhbmQgaXMgdW5saWtlbHkgdG8gY29tcGxldGUgc2luY2UgaXQgb2Z0ZW4gd2lsbCBzdXNwZW5kXG4gICAgICAvLyBvbiBtaXNzaW5nIGRhdGEgYW55d2F5LiBBZGRpdGlvbmFsbHksIHRoZSBzZXJ2ZXIgbWlnaHQgYmUgYWJsZSB0byByZW5kZXIgbW9yZVxuICAgICAgLy8gdGhhbiB3ZSBjYW4gb24gdGhlIGNsaWVudCB5ZXQuIEluIHRoYXQgY2FzZSB3ZSdkIGVuZCB1cCB3aXRoIG1vcmUgZmFsbGJhY2sgc3RhdGVzXG4gICAgICAvLyBvbiB0aGUgY2xpZW50IHRoYW4gaWYgd2UganVzdCBsZWF2ZSBpdCBhbG9uZS4gSWYgdGhlIHNlcnZlciB0aW1lcyBvdXQgb3IgZXJyb3JzXG4gICAgICAvLyB0aGVzZSBzaG91bGQgdXBkYXRlIHRoaXMgYm91bmRhcnkgdG8gdGhlIHBlcm1hbmVudCBGYWxsYmFjayBzdGF0ZSBpbnN0ZWFkLlxuICAgICAgLy8gTWFyayBpdCBhcyBoYXZpbmcgY2FwdHVyZWQgKGkuZS4gc3VzcGVuZGVkKS5cbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7IC8vIExlYXZlIHRoZSBjaGlsZCBpbiBwbGFjZS4gSS5lLiB0aGUgZGVoeWRyYXRlZCBmcmFnbWVudC5cblxuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkOyAvLyBSZWdpc3RlciBhIGNhbGxiYWNrIHRvIHJldHJ5IHRoaXMgYm91bmRhcnkgb25jZSB0aGUgc2VydmVyIGhhcyBzZW50IHRoZSByZXN1bHQuXG5cbiAgICAgIHZhciByZXRyeSA9IHJldHJ5RGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkuYmluZChudWxsLCBjdXJyZW50KTtcbiAgICAgIHJlZ2lzdGVyU3VzcGVuc2VJbnN0YW5jZVJldHJ5KHN1c3BlbnNlSW5zdGFuY2UsIHJldHJ5KTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBhdHRlbXB0LlxuICAgICAgcmVlbnRlckh5ZHJhdGlvblN0YXRlRnJvbURlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKHdvcmtJblByb2dyZXNzLCBzdXNwZW5zZUluc3RhbmNlLCBzdXNwZW5zZVN0YXRlLnRyZWVDb250ZXh0KTtcbiAgICAgIHZhciBwcmltYXJ5Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gICAgICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4pOyAvLyBNYXJrIHRoZSBjaGlsZHJlbiBhcyBoeWRyYXRpbmcuIFRoaXMgaXMgYSBmYXN0IHBhdGggdG8ga25vdyB3aGV0aGVyIHRoaXNcbiAgICAgIC8vIHRyZWUgaXMgcGFydCBvZiBhIGh5ZHJhdGluZyB0cmVlLiBUaGlzIGlzIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIGEgY2hpbGRcbiAgICAgIC8vIG5vZGUgaGFzIGZ1bGx5IG1vdW50ZWQgeWV0LCBhbmQgZm9yIHNjaGVkdWxpbmcgZXZlbnQgcmVwbGF5aW5nLlxuICAgICAgLy8gQ29uY2VwdHVhbGx5IHRoaXMgaXMgc2ltaWxhciB0byBQbGFjZW1lbnQgaW4gdGhhdCBhIG5ldyBzdWJ0cmVlIGlzXG4gICAgICAvLyBpbnNlcnRlZCBpbnRvIHRoZSBSZWFjdCB0cmVlIGhlcmUuIEl0IGp1c3QgaGFwcGVucyB0byBub3QgbmVlZCBET01cbiAgICAgIC8vIG11dGF0aW9ucyBiZWNhdXNlIGl0IGFscmVhZHkgZXhpc3RzLlxuXG4gICAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5mbGFncyB8PSBIeWRyYXRpbmc7XG4gICAgICByZXR1cm4gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgdGhlIHNlY29uZCByZW5kZXIgcGFzcy4gV2UgYWxyZWFkeSBhdHRlbXB0ZWQgdG8gaHlkcmF0ZWQsIGJ1dFxuICAgIC8vIHNvbWV0aGluZyBlaXRoZXIgc3VzcGVuZGVkIG9yIGVycm9yZWQuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRm9yY2VDbGllbnRSZW5kZXIpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBlcnJvcmVkIGR1cmluZyBoeWRyYXRpb24uIFRyeSBhZ2FpbiB3aXRob3V0IGh5ZHJhdGluZy5cbiAgICAgIC8vIFRoZSBlcnJvciBzaG91bGQndmUgYWxyZWFkeSBiZWVuIGxvZ2dlZCBpbiB0aHJvd0V4Y2VwdGlvbi5cbiAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSB+Rm9yY2VDbGllbnRSZW5kZXI7XG4gICAgICByZXR1cm4gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICB9IGVsc2UgaWYgKHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgIT09IG51bGwpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBzdXNwZW5kZWQgYW5kIHdlIHNob3VsZCBzdGlsbCBiZSBpbiBkZWh5ZHJhdGVkIG1vZGUuXG4gICAgICAvLyBMZWF2ZSB0aGUgZXhpc3RpbmcgY2hpbGQgaW4gcGxhY2UuXG4gICAgICAvLyBQdXNoIHRvIGF2b2lkIGEgbWlzbWF0Y2hcbiAgICAgIHB1c2hGYWxsYmFja1RyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkOyAvLyBUaGUgZGVoeWRyYXRlZCBjb21wbGV0aW9uIHBhc3MgZXhwZWN0cyB0aGlzIGZsYWcgdG8gYmUgdGhlcmVcbiAgICAgIC8vIGJ1dCB0aGUgbm9ybWFsIHN1c3BlbnNlIHBhc3MgZG9lc24ndC5cblxuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTdXNwZW5kZWQgYnV0IHdlIHNob3VsZCBubyBsb25nZXIgYmUgaW4gZGVoeWRyYXRlZCBtb2RlLlxuICAgICAgLy8gVGhlcmVmb3JlIHdlIG5vdyBoYXZlIHRvIHJlbmRlciB0aGUgZmFsbGJhY2suXG4gICAgICBwdXNoRmFsbGJhY2tUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHZhciBuZXh0UHJpbWFyeUNoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICAgICAgdmFyIG5leHRGYWxsYmFja0NoaWxkcmVuID0gbmV4dFByb3BzLmZhbGxiYWNrO1xuICAgICAgdmFyIGZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IG1vdW50U3VzcGVuc2VGYWxsYmFja0FmdGVyUmV0cnlXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0UHJpbWFyeUNoaWxkcmVuLCBuZXh0RmFsbGJhY2tDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgICAgdmFyIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDQubWVtb2l6ZWRTdGF0ZSA9IG1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShyZW5kZXJMYW5lcyk7XG4gICAgICBfcHJpbWFyeUNoaWxkRnJhZ21lbnQ0LmNoaWxkTGFuZXMgPSBnZXRSZW1haW5pbmdXb3JrSW5QcmltYXJ5VHJlZShjdXJyZW50LCBkaWRQcmltYXJ5Q2hpbGRyZW5EZWZlciwgcmVuZGVyTGFuZXMpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IFNVU1BFTkRFRF9NQVJLRVI7XG4gICAgICByZXR1cm4gZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIoZmliZXIsIHJlbmRlckxhbmVzLCBwcm9wYWdhdGlvblJvb3QpIHtcbiAgZmliZXIubGFuZXMgPSBtZXJnZUxhbmVzKGZpYmVyLmxhbmVzLCByZW5kZXJMYW5lcyk7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgIGFsdGVybmF0ZS5sYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmxhbmVzLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICBzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoKGZpYmVyLnJldHVybiwgcmVuZGVyTGFuZXMsIHByb3BhZ2F0aW9uUm9vdCk7XG59XG5cbmZ1bmN0aW9uIHByb3BhZ2F0ZVN1c3BlbnNlQ29udGV4dENoYW5nZSh3b3JrSW5Qcm9ncmVzcywgZmlyc3RDaGlsZCwgcmVuZGVyTGFuZXMpIHtcbiAgLy8gTWFyayBhbnkgU3VzcGVuc2UgYm91bmRhcmllcyB3aXRoIGZhbGxiYWNrcyBhcyBoYXZpbmcgd29yayB0byBkby5cbiAgLy8gSWYgdGhleSB3ZXJlIHByZXZpb3VzbHkgZm9yY2VkIGludG8gZmFsbGJhY2tzLCB0aGV5IG1heSBub3cgYmUgYWJsZVxuICAvLyB0byB1bmJsb2NrLlxuICB2YXIgbm9kZSA9IGZpcnN0Q2hpbGQ7XG5cbiAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICBpZiAobm9kZS50YWcgPT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgICB2YXIgc3RhdGUgPSBub2RlLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgIGlmIChzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBzY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIobm9kZSwgcmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBTdXNwZW5zZUxpc3RDb21wb25lbnQpIHtcbiAgICAgIC8vIElmIHRoZSB0YWlsIGlzIGhpZGRlbiB0aGVyZSBtaWdodCBub3QgYmUgYW4gU3VzcGVuc2UgYm91bmRhcmllc1xuICAgICAgLy8gdG8gc2NoZWR1bGUgd29yayBvbi4gSW4gdGhpcyBjYXNlIHdlIGhhdmUgdG8gc2NoZWR1bGUgaXQgb24gdGhlXG4gICAgICAvLyBsaXN0IGl0c2VsZi5cbiAgICAgIC8vIFdlIGRvbid0IGhhdmUgdG8gdHJhdmVyc2UgdG8gdGhlIGNoaWxkcmVuIG9mIHRoZSBsaXN0IHNpbmNlXG4gICAgICAvLyB0aGUgbGlzdCB3aWxsIHByb3BhZ2F0ZSB0aGUgY2hhbmdlIHdoZW4gaXQgcmVyZW5kZXJzLlxuICAgICAgc2NoZWR1bGVTdXNwZW5zZVdvcmtPbkZpYmVyKG5vZGUsIHJlbmRlckxhbmVzLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kTGFzdENvbnRlbnRSb3coZmlyc3RDaGlsZCkge1xuICAvLyBUaGlzIGlzIGdvaW5nIHRvIGZpbmQgdGhlIGxhc3Qgcm93IGFtb25nIHRoZXNlIGNoaWxkcmVuIHRoYXQgaXMgYWxyZWFkeVxuICAvLyBzaG93aW5nIGNvbnRlbnQgb24gdGhlIHNjcmVlbiwgYXMgb3Bwb3NlZCB0byBiZWluZyBpbiBmYWxsYmFjayBzdGF0ZSBvclxuICAvLyBuZXcuIElmIGEgcm93IGhhcyBtdWx0aXBsZSBTdXNwZW5zZSBib3VuZGFyaWVzLCBhbnkgb2YgdGhlbSBiZWluZyBpbiB0aGVcbiAgLy8gZmFsbGJhY2sgc3RhdGUsIGNvdW50cyBhcyB0aGUgd2hvbGUgcm93IGJlaW5nIGluIGEgZmFsbGJhY2sgc3RhdGUuXG4gIC8vIE5vdGUgdGhhdCB0aGUgXCJyb3dzXCIgd2lsbCBiZSB3b3JrSW5Qcm9ncmVzcywgYnV0IGFueSBuZXN0ZWQgY2hpbGRyZW5cbiAgLy8gd2lsbCBzdGlsbCBiZSBjdXJyZW50IHNpbmNlIHdlIGhhdmVuJ3QgcmVuZGVyZWQgdGhlbSB5ZXQuIFRoZSBtb3VudGVkXG4gIC8vIG9yZGVyIG1heSBub3QgYmUgdGhlIHNhbWUgYXMgdGhlIG5ldyBvcmRlci4gV2UgdXNlIHRoZSBuZXcgb3JkZXIuXG4gIHZhciByb3cgPSBmaXJzdENoaWxkO1xuICB2YXIgbGFzdENvbnRlbnRSb3cgPSBudWxsO1xuXG4gIHdoaWxlIChyb3cgIT09IG51bGwpIHtcbiAgICB2YXIgY3VycmVudFJvdyA9IHJvdy5hbHRlcm5hdGU7IC8vIE5ldyByb3dzIGNhbid0IGJlIGNvbnRlbnQgcm93cy5cblxuICAgIGlmIChjdXJyZW50Um93ICE9PSBudWxsICYmIGZpbmRGaXJzdFN1c3BlbmRlZChjdXJyZW50Um93KSA9PT0gbnVsbCkge1xuICAgICAgbGFzdENvbnRlbnRSb3cgPSByb3c7XG4gICAgfVxuXG4gICAgcm93ID0gcm93LnNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbGFzdENvbnRlbnRSb3c7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlUmV2ZWFsT3JkZXIocmV2ZWFsT3JkZXIpIHtcbiAge1xuICAgIGlmIChyZXZlYWxPcmRlciAhPT0gdW5kZWZpbmVkICYmIHJldmVhbE9yZGVyICE9PSAnZm9yd2FyZHMnICYmIHJldmVhbE9yZGVyICE9PSAnYmFja3dhcmRzJyAmJiByZXZlYWxPcmRlciAhPT0gJ3RvZ2V0aGVyJyAmJiAhZGlkV2FybkFib3V0UmV2ZWFsT3JkZXJbcmV2ZWFsT3JkZXJdKSB7XG4gICAgICBkaWRXYXJuQWJvdXRSZXZlYWxPcmRlcltyZXZlYWxPcmRlcl0gPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZW9mIHJldmVhbE9yZGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICBzd2l0Y2ggKHJldmVhbE9yZGVyLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICBjYXNlICd0b2dldGhlcic6XG4gICAgICAgICAgY2FzZSAnZm9yd2FyZHMnOlxuICAgICAgICAgIGNhc2UgJ2JhY2t3YXJkcyc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGVycm9yKCdcIiVzXCIgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcgKyAnVXNlIGxvd2VyY2FzZSBcIiVzXCIgaW5zdGVhZC4nLCByZXZlYWxPcmRlciwgcmV2ZWFsT3JkZXIudG9Mb3dlckNhc2UoKSk7XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdmb3J3YXJkJzpcbiAgICAgICAgICBjYXNlICdiYWNrd2FyZCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGVycm9yKCdcIiVzXCIgaXMgbm90IGEgdmFsaWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcgKyAnUmVhY3QgdXNlcyB0aGUgLXMgc3VmZml4IGluIHRoZSBzcGVsbGluZy4gVXNlIFwiJXNzXCIgaW5zdGVhZC4nLCByZXZlYWxPcmRlciwgcmV2ZWFsT3JkZXIudG9Mb3dlckNhc2UoKSk7XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgZXJyb3IoJ1wiJXNcIiBpcyBub3QgYSBzdXBwb3J0ZWQgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gJyArICdEaWQgeW91IG1lYW4gXCJ0b2dldGhlclwiLCBcImZvcndhcmRzXCIgb3IgXCJiYWNrd2FyZHNcIj8nLCByZXZlYWxPcmRlcik7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlcnJvcignJXMgaXMgbm90IGEgc3VwcG9ydGVkIHZhbHVlIGZvciByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnICsgJ0RpZCB5b3UgbWVhbiBcInRvZ2V0aGVyXCIsIFwiZm9yd2FyZHNcIiBvciBcImJhY2t3YXJkc1wiPycsIHJldmVhbE9yZGVyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVUYWlsT3B0aW9ucyh0YWlsTW9kZSwgcmV2ZWFsT3JkZXIpIHtcbiAge1xuICAgIGlmICh0YWlsTW9kZSAhPT0gdW5kZWZpbmVkICYmICFkaWRXYXJuQWJvdXRUYWlsT3B0aW9uc1t0YWlsTW9kZV0pIHtcbiAgICAgIGlmICh0YWlsTW9kZSAhPT0gJ2NvbGxhcHNlZCcgJiYgdGFpbE1vZGUgIT09ICdoaWRkZW4nKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zW3RhaWxNb2RlXSA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJ1wiJXNcIiBpcyBub3QgYSBzdXBwb3J0ZWQgdmFsdWUgZm9yIHRhaWwgb24gPFN1c3BlbnNlTGlzdCAvPi4gJyArICdEaWQgeW91IG1lYW4gXCJjb2xsYXBzZWRcIiBvciBcImhpZGRlblwiPycsIHRhaWxNb2RlKTtcbiAgICAgIH0gZWxzZSBpZiAocmV2ZWFsT3JkZXIgIT09ICdmb3J3YXJkcycgJiYgcmV2ZWFsT3JkZXIgIT09ICdiYWNrd2FyZHMnKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zW3RhaWxNb2RlXSA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJzxTdXNwZW5zZUxpc3QgdGFpbD1cIiVzXCIgLz4gaXMgb25seSB2YWxpZCBpZiByZXZlYWxPcmRlciBpcyAnICsgJ1wiZm9yd2FyZHNcIiBvciBcImJhY2t3YXJkc1wiLiAnICsgJ0RpZCB5b3UgbWVhbiB0byBzcGVjaWZ5IHJldmVhbE9yZGVyPVwiZm9yd2FyZHNcIj8nLCB0YWlsTW9kZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoY2hpbGRTbG90LCBpbmRleCkge1xuICB7XG4gICAgdmFyIGlzQW5BcnJheSA9IGlzQXJyYXkoY2hpbGRTbG90KTtcbiAgICB2YXIgaXNJdGVyYWJsZSA9ICFpc0FuQXJyYXkgJiYgdHlwZW9mIGdldEl0ZXJhdG9yRm4oY2hpbGRTbG90KSA9PT0gJ2Z1bmN0aW9uJztcblxuICAgIGlmIChpc0FuQXJyYXkgfHwgaXNJdGVyYWJsZSkge1xuICAgICAgdmFyIHR5cGUgPSBpc0FuQXJyYXkgPyAnYXJyYXknIDogJ2l0ZXJhYmxlJztcblxuICAgICAgZXJyb3IoJ0EgbmVzdGVkICVzIHdhcyBwYXNzZWQgdG8gcm93ICMlcyBpbiA8U3VzcGVuc2VMaXN0IC8+LiBXcmFwIGl0IGluICcgKyAnYW4gYWRkaXRpb25hbCBTdXNwZW5zZUxpc3QgdG8gY29uZmlndXJlIGl0cyByZXZlYWxPcmRlcjogJyArICc8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPS4uLj4gLi4uICcgKyAnPFN1c3BlbnNlTGlzdCByZXZlYWxPcmRlcj0uLi4+eyVzfTwvU3VzcGVuc2VMaXN0PiAuLi4gJyArICc8L1N1c3BlbnNlTGlzdD4nLCB0eXBlLCBpbmRleCwgdHlwZSk7XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTdXNwZW5zZUxpc3RDaGlsZHJlbihjaGlsZHJlbiwgcmV2ZWFsT3JkZXIpIHtcbiAge1xuICAgIGlmICgocmV2ZWFsT3JkZXIgPT09ICdmb3J3YXJkcycgfHwgcmV2ZWFsT3JkZXIgPT09ICdiYWNrd2FyZHMnKSAmJiBjaGlsZHJlbiAhPT0gdW5kZWZpbmVkICYmIGNoaWxkcmVuICE9PSBudWxsICYmIGNoaWxkcmVuICE9PSBmYWxzZSkge1xuICAgICAgaWYgKGlzQXJyYXkoY2hpbGRyZW4pKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBpZiAoIXZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoY2hpbGRyZW5baV0sIGkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHZhciBjaGlsZHJlbkl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKGNoaWxkcmVuKTtcblxuICAgICAgICAgIGlmIChjaGlsZHJlbkl0ZXJhdG9yKSB7XG4gICAgICAgICAgICB2YXIgc3RlcCA9IGNoaWxkcmVuSXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgdmFyIF9pID0gMDtcblxuICAgICAgICAgICAgZm9yICg7ICFzdGVwLmRvbmU7IHN0ZXAgPSBjaGlsZHJlbkl0ZXJhdG9yLm5leHQoKSkge1xuICAgICAgICAgICAgICBpZiAoIXZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQoc3RlcC52YWx1ZSwgX2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgX2krKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3IoJ0Egc2luZ2xlIHJvdyB3YXMgcGFzc2VkIHRvIGEgPFN1c3BlbnNlTGlzdCByZXZlYWxPcmRlcj1cIiVzXCIgLz4uICcgKyAnVGhpcyBpcyBub3QgdXNlZnVsIHNpbmNlIGl0IG5lZWRzIG11bHRpcGxlIHJvd3MuICcgKyAnRGlkIHlvdSBtZWFuIHRvIHBhc3MgbXVsdGlwbGUgY2hpbGRyZW4gb3IgYW4gYXJyYXk/JywgcmV2ZWFsT3JkZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgaXNCYWNrd2FyZHMsIHRhaWwsIGxhc3RDb250ZW50Um93LCB0YWlsTW9kZSkge1xuICB2YXIgcmVuZGVyU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChyZW5kZXJTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSB7XG4gICAgICBpc0JhY2t3YXJkczogaXNCYWNrd2FyZHMsXG4gICAgICByZW5kZXJpbmc6IG51bGwsXG4gICAgICByZW5kZXJpbmdTdGFydFRpbWU6IDAsXG4gICAgICBsYXN0OiBsYXN0Q29udGVudFJvdyxcbiAgICAgIHRhaWw6IHRhaWwsXG4gICAgICB0YWlsTW9kZTogdGFpbE1vZGVcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIC8vIFdlIGNhbiByZXVzZSB0aGUgZXhpc3Rpbmcgb2JqZWN0IGZyb20gcHJldmlvdXMgcmVuZGVycy5cbiAgICByZW5kZXJTdGF0ZS5pc0JhY2t3YXJkcyA9IGlzQmFja3dhcmRzO1xuICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZyA9IG51bGw7XG4gICAgcmVuZGVyU3RhdGUucmVuZGVyaW5nU3RhcnRUaW1lID0gMDtcbiAgICByZW5kZXJTdGF0ZS5sYXN0ID0gbGFzdENvbnRlbnRSb3c7XG4gICAgcmVuZGVyU3RhdGUudGFpbCA9IHRhaWw7XG4gICAgcmVuZGVyU3RhdGUudGFpbE1vZGUgPSB0YWlsTW9kZTtcbiAgfVxufSAvLyBUaGlzIGNhbiBlbmQgdXAgcmVuZGVyaW5nIHRoaXMgY29tcG9uZW50IG11bHRpcGxlIHBhc3Nlcy5cbi8vIFRoZSBmaXJzdCBwYXNzIHNwbGl0cyB0aGUgY2hpbGRyZW4gZmliZXJzIGludG8gdHdvIHNldHMuIEEgaGVhZCBhbmQgdGFpbC5cbi8vIFdlIGZpcnN0IHJlbmRlciB0aGUgaGVhZC4gSWYgYW55dGhpbmcgaXMgaW4gZmFsbGJhY2sgc3RhdGUsIHdlIGRvIGFub3RoZXJcbi8vIHBhc3MgdGhyb3VnaCBiZWdpbldvcmsgdG8gcmVyZW5kZXIgYWxsIGNoaWxkcmVuIChpbmNsdWRpbmcgdGhlIHRhaWwpIHdpdGhcbi8vIHRoZSBmb3JjZSBzdXNwZW5kIGNvbnRleHQuIElmIHRoZSBmaXJzdCByZW5kZXIgZGlkbid0IGhhdmUgYW55dGhpbmcgaW5cbi8vIGluIGZhbGxiYWNrIHN0YXRlLiBUaGVuIHdlIHJlbmRlciBlYWNoIHJvdyBpbiB0aGUgdGFpbCBvbmUtYnktb25lLlxuLy8gVGhhdCBoYXBwZW5zIGluIHRoZSBjb21wbGV0ZVdvcmsgcGhhc2Ugd2l0aG91dCBnb2luZyBiYWNrIHRvIGJlZ2luV29yay5cblxuXG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciByZXZlYWxPcmRlciA9IG5leHRQcm9wcy5yZXZlYWxPcmRlcjtcbiAgdmFyIHRhaWxNb2RlID0gbmV4dFByb3BzLnRhaWw7XG4gIHZhciBuZXdDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgdmFsaWRhdGVSZXZlYWxPcmRlcihyZXZlYWxPcmRlcik7XG4gIHZhbGlkYXRlVGFpbE9wdGlvbnModGFpbE1vZGUsIHJldmVhbE9yZGVyKTtcbiAgdmFsaWRhdGVTdXNwZW5zZUxpc3RDaGlsZHJlbihuZXdDaGlsZHJlbiwgcmV2ZWFsT3JkZXIpO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV3Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgdmFyIHN1c3BlbnNlQ29udGV4dCA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgdmFyIHNob3VsZEZvcmNlRmFsbGJhY2sgPSBoYXNTdXNwZW5zZUxpc3RDb250ZXh0KHN1c3BlbnNlQ29udGV4dCwgRm9yY2VTdXNwZW5zZUZhbGxiYWNrKTtcblxuICBpZiAoc2hvdWxkRm9yY2VGYWxsYmFjaykge1xuICAgIHN1c3BlbnNlQ29udGV4dCA9IHNldFNoYWxsb3dTdXNwZW5zZUxpc3RDb250ZXh0KHN1c3BlbnNlQ29udGV4dCwgRm9yY2VTdXNwZW5zZUZhbGxiYWNrKTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICB9IGVsc2Uge1xuICAgIHZhciBkaWRTdXNwZW5kQmVmb3JlID0gY3VycmVudCAhPT0gbnVsbCAmJiAoY3VycmVudC5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzJDE7XG5cbiAgICBpZiAoZGlkU3VzcGVuZEJlZm9yZSkge1xuICAgICAgLy8gSWYgd2UgcHJldmlvdXNseSBmb3JjZWQgYSBmYWxsYmFjaywgd2UgbmVlZCB0byBzY2hlZHVsZSB3b3JrXG4gICAgICAvLyBvbiBhbnkgbmVzdGVkIGJvdW5kYXJpZXMgdG8gbGV0IHRoZW0ga25vdyB0byB0cnkgdG8gcmVuZGVyXG4gICAgICAvLyBhZ2Fpbi4gVGhpcyBpcyB0aGUgc2FtZSBhcyBjb250ZXh0IHVwZGF0aW5nLlxuICAgICAgcHJvcGFnYXRlU3VzcGVuc2VDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5jaGlsZCwgcmVuZGVyTGFuZXMpO1xuICAgIH1cblxuICAgIHN1c3BlbnNlQ29udGV4dCA9IHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VMaXN0Q29udGV4dChzdXNwZW5zZUNvbnRleHQpO1xuICB9XG5cbiAgcHVzaFN1c3BlbnNlTGlzdENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHN1c3BlbnNlQ29udGV4dCk7XG5cbiAge1xuICAgIHN3aXRjaCAocmV2ZWFsT3JkZXIpIHtcbiAgICAgIGNhc2UgJ2ZvcndhcmRzJzpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXN0Q29udGVudFJvdyA9IGZpbmRMYXN0Q29udGVudFJvdyh3b3JrSW5Qcm9ncmVzcy5jaGlsZCk7XG4gICAgICAgICAgdmFyIHRhaWw7XG5cbiAgICAgICAgICBpZiAobGFzdENvbnRlbnRSb3cgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRoZSB3aG9sZSBsaXN0IGlzIHBhcnQgb2YgdGhlIHRhaWwuXG4gICAgICAgICAgICAvLyBUT0RPOiBXZSBjb3VsZCBmYXN0IHBhdGggYnkganVzdCByZW5kZXJpbmcgdGhlIHRhaWwgbm93LlxuICAgICAgICAgICAgdGFpbCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEaXNjb25uZWN0IHRoZSB0YWlsIHJvd3MgYWZ0ZXIgdGhlIGNvbnRlbnQgcm93LlxuICAgICAgICAgICAgLy8gV2UncmUgZ29pbmcgdG8gcmVuZGVyIHRoZW0gc2VwYXJhdGVseSBsYXRlci5cbiAgICAgICAgICAgIHRhaWwgPSBsYXN0Q29udGVudFJvdy5zaWJsaW5nO1xuICAgICAgICAgICAgbGFzdENvbnRlbnRSb3cuc2libGluZyA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKHdvcmtJblByb2dyZXNzLCBmYWxzZSwgLy8gaXNCYWNrd2FyZHNcbiAgICAgICAgICB0YWlsLCBsYXN0Q29udGVudFJvdywgdGFpbE1vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ2JhY2t3YXJkcyc6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBXZSdyZSBnb2luZyB0byBmaW5kIHRoZSBmaXJzdCByb3cgdGhhdCBoYXMgZXhpc3RpbmcgY29udGVudC5cbiAgICAgICAgICAvLyBBdCB0aGUgc2FtZSB0aW1lIHdlJ3JlIGdvaW5nIHRvIHJldmVyc2UgdGhlIGxpc3Qgb2YgZXZlcnl0aGluZ1xuICAgICAgICAgIC8vIHdlIHBhc3MgaW4gdGhlIG1lYW50aW1lLiBUaGF0J3MgZ29pbmcgdG8gYmUgb3VyIHRhaWwgaW4gcmV2ZXJzZVxuICAgICAgICAgIC8vIG9yZGVyLlxuICAgICAgICAgIHZhciBfdGFpbCA9IG51bGw7XG4gICAgICAgICAgdmFyIHJvdyA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbDtcblxuICAgICAgICAgIHdoaWxlIChyb3cgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50Um93ID0gcm93LmFsdGVybmF0ZTsgLy8gTmV3IHJvd3MgY2FuJ3QgYmUgY29udGVudCByb3dzLlxuXG4gICAgICAgICAgICBpZiAoY3VycmVudFJvdyAhPT0gbnVsbCAmJiBmaW5kRmlyc3RTdXNwZW5kZWQoY3VycmVudFJvdykgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgYmVnaW5uaW5nIG9mIHRoZSBtYWluIGNvbnRlbnQuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcm93O1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5leHRSb3cgPSByb3cuc2libGluZztcbiAgICAgICAgICAgIHJvdy5zaWJsaW5nID0gX3RhaWw7XG4gICAgICAgICAgICBfdGFpbCA9IHJvdztcbiAgICAgICAgICAgIHJvdyA9IG5leHRSb3c7XG4gICAgICAgICAgfSAvLyBUT0RPOiBJZiB3b3JrSW5Qcm9ncmVzcy5jaGlsZCBpcyBudWxsLCB3ZSBjYW4gY29udGludWUgb24gdGhlIHRhaWwgaW1tZWRpYXRlbHkuXG5cblxuICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgdHJ1ZSwgLy8gaXNCYWNrd2FyZHNcbiAgICAgICAgICBfdGFpbCwgbnVsbCwgLy8gbGFzdFxuICAgICAgICAgIHRhaWxNb2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICd0b2dldGhlcic6XG4gICAgICAgIHtcbiAgICAgICAgICBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUod29ya0luUHJvZ3Jlc3MsIGZhbHNlLCAvLyBpc0JhY2t3YXJkc1xuICAgICAgICAgIG51bGwsIC8vIHRhaWxcbiAgICAgICAgICBudWxsLCAvLyBsYXN0XG4gICAgICAgICAgdW5kZWZpbmVkKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gVGhlIGRlZmF1bHQgcmV2ZWFsIG9yZGVyIGlzIHRoZSBzYW1lIGFzIG5vdCBoYXZpbmdcbiAgICAgICAgICAvLyBhIGJvdW5kYXJ5LlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVQb3J0YWxDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBQb3J0YWxzIGFyZSBzcGVjaWFsIGJlY2F1c2Ugd2UgZG9uJ3QgYXBwZW5kIHRoZSBjaGlsZHJlbiBkdXJpbmcgbW91bnRcbiAgICAvLyBidXQgYXQgY29tbWl0LiBUaGVyZWZvcmUgd2UgbmVlZCB0byB0cmFjayBpbnNlcnRpb25zIHdoaWNoIHRoZSBub3JtYWxcbiAgICAvLyBmbG93IGRvZXNuJ3QgZG8gZHVyaW5nIG1vdW50LiBUaGlzIGRvZXNuJ3QgaGFwcGVuIGF0IHRoZSByb290IGJlY2F1c2VcbiAgICAvLyB0aGUgcm9vdCBhbHdheXMgc3RhcnRzIHdpdGggYSBcImN1cnJlbnRcIiB3aXRoIGEgbnVsbCBjaGlsZC5cbiAgICAvLyBUT0RPOiBDb25zaWRlciB1bmlmeWluZyB0aGlzIHdpdGggaG93IHRoZSByb290IHdvcmtzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICB9IGVsc2Uge1xuICAgIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxudmFyIGhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRleHRQcm92aWRlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIGNvbnRleHQ7XG5cbiAge1xuICAgIGNvbnRleHQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICB9XG5cbiAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgb2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICB2YXIgbmV3VmFsdWUgPSBuZXdQcm9wcy52YWx1ZTtcblxuICB7XG4gICAgaWYgKCEoJ3ZhbHVlJyBpbiBuZXdQcm9wcykpIHtcbiAgICAgIGlmICghaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIpIHtcbiAgICAgICAgaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIgPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCdUaGUgYHZhbHVlYCBwcm9wIGlzIHJlcXVpcmVkIGZvciB0aGUgYDxDb250ZXh0LlByb3ZpZGVyPmAuIERpZCB5b3UgbWlzc3BlbGwgaXQgb3IgZm9yZ2V0IHRvIHBhc3MgaXQ/Jyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCBuZXdWYWx1ZSk7XG5cbiAge1xuICAgIGlmIChvbGRQcm9wcyAhPT0gbnVsbCkge1xuICAgICAgdmFyIG9sZFZhbHVlID0gb2xkUHJvcHMudmFsdWU7XG5cbiAgICAgIGlmIChvYmplY3RJcyhvbGRWYWx1ZSwgbmV3VmFsdWUpKSB7XG4gICAgICAgIC8vIE5vIGNoYW5nZS4gQmFpbG91dCBlYXJseSBpZiBjaGlsZHJlbiBhcmUgdGhlIHNhbWUuXG4gICAgICAgIGlmIChvbGRQcm9wcy5jaGlsZHJlbiA9PT0gbmV3UHJvcHMuY2hpbGRyZW4gJiYgIWhhc0NvbnRleHRDaGFuZ2VkKCkpIHtcbiAgICAgICAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgY29udGV4dCB2YWx1ZSBjaGFuZ2VkLiBTZWFyY2ggZm9yIG1hdGNoaW5nIGNvbnN1bWVycyBhbmQgc2NoZWR1bGVcbiAgICAgICAgLy8gdGhlbSB0byB1cGRhdGUuXG4gICAgICAgIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIGNvbnRleHQsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbmV3Q2hpbGRyZW4gPSBuZXdQcm9wcy5jaGlsZHJlbjtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5ld0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ29udGV4dENvbnN1bWVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgY29udGV4dDtcblxuICB7XG4gICAgdmFyIGNvbnN1bWVyVHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgY29udGV4dCA9IGNvbnN1bWVyVHlwZS5fY29udGV4dDtcbiAgfVxuXG4gIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIHJlbmRlciA9IG5ld1Byb3BzLmNoaWxkcmVuO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIHJlbmRlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ0EgY29udGV4dCBjb25zdW1lciB3YXMgcmVuZGVyZWQgd2l0aCBtdWx0aXBsZSBjaGlsZHJlbiwgb3IgYSBjaGlsZCAnICsgXCJ0aGF0IGlzbid0IGEgZnVuY3Rpb24uIEEgY29udGV4dCBjb25zdW1lciBleHBlY3RzIGEgc2luZ2xlIGNoaWxkIFwiICsgJ3RoYXQgaXMgYSBmdW5jdGlvbi4gSWYgeW91IGRpZCBwYXNzIGEgZnVuY3Rpb24sIG1ha2Ugc3VyZSB0aGVyZSAnICsgJ2lzIG5vIHRyYWlsaW5nIG9yIGxlYWRpbmcgd2hpdGVzcGFjZSBhcm91bmQgaXQuJyk7XG4gICAgfVxuICB9XG5cbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgdmFyIG5ld1ZhbHVlID0gcmVhZENvbnRleHQoY29udGV4dCk7XG5cbiAge1xuICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIHZhciBuZXdDaGlsZHJlbjtcblxuICB7XG4gICAgc2V0SXNSZW5kZXJpbmcodHJ1ZSk7XG4gICAgbmV3Q2hpbGRyZW4gPSByZW5kZXIobmV3VmFsdWUpO1xuICAgIHNldElzUmVuZGVyaW5nKGZhbHNlKTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXdDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCkge1xuICBkaWRSZWNlaXZlVXBkYXRlID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAvLyBSZXVzZSBwcmV2aW91cyBkZXBlbmRlbmNpZXNcbiAgICB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSBjdXJyZW50LmRlcGVuZGVuY2llcztcbiAgfVxuXG4gIHtcbiAgICAvLyBEb24ndCB1cGRhdGUgXCJiYXNlXCIgcmVuZGVyIHRpbWVzIGZvciBiYWlsb3V0cy5cbiAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZygpO1xuICB9XG5cbiAgbWFya1NraXBwZWRVcGRhdGVMYW5lcyh3b3JrSW5Qcm9ncmVzcy5sYW5lcyk7IC8vIENoZWNrIGlmIHRoZSBjaGlsZHJlbiBoYXZlIGFueSBwZW5kaW5nIHdvcmsuXG5cbiAgaWYgKCFpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKSkge1xuICAgIC8vIFRoZSBjaGlsZHJlbiBkb24ndCBoYXZlIGFueSB3b3JrIGVpdGhlci4gV2UgY2FuIHNraXAgdGhlbS5cbiAgICAvLyBUT0RPOiBPbmNlIHdlIGFkZCBiYWNrIHJlc3VtaW5nLCB3ZSBzaG91bGQgY2hlY2sgaWYgdGhlIGNoaWxkcmVuIGFyZVxuICAgIC8vIGEgd29yay1pbi1wcm9ncmVzcyBzZXQuIElmIHNvLCB3ZSBuZWVkIHRvIHRyYW5zZmVyIHRoZWlyIGVmZmVjdHMuXG4gICAge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9IC8vIFRoaXMgZmliZXIgZG9lc24ndCBoYXZlIHdvcmssIGJ1dCBpdHMgc3VidHJlZSBkb2VzLiBDbG9uZSB0aGUgY2hpbGRcbiAgLy8gZmliZXJzIGFuZCBjb250aW51ZS5cblxuXG4gIGNsb25lQ2hpbGRGaWJlcnMoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHJlbW91bnRGaWJlcihjdXJyZW50LCBvbGRXb3JrSW5Qcm9ncmVzcywgbmV3V29ya0luUHJvZ3Jlc3MpIHtcbiAge1xuICAgIHZhciByZXR1cm5GaWJlciA9IG9sZFdvcmtJblByb2dyZXNzLnJldHVybjtcblxuICAgIGlmIChyZXR1cm5GaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHN3YXAgdGhlIHJvb3QgZmliZXIuJyk7XG4gICAgfSAvLyBEaXNjb25uZWN0IGZyb20gdGhlIG9sZCBjdXJyZW50LlxuICAgIC8vIEl0IHdpbGwgZ2V0IGRlbGV0ZWQuXG5cblxuICAgIGN1cnJlbnQuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICBvbGRXb3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBudWxsOyAvLyBDb25uZWN0IHRvIHRoZSBuZXcgdHJlZS5cblxuICAgIG5ld1dvcmtJblByb2dyZXNzLmluZGV4ID0gb2xkV29ya0luUHJvZ3Jlc3MuaW5kZXg7XG4gICAgbmV3V29ya0luUHJvZ3Jlc3Muc2libGluZyA9IG9sZFdvcmtJblByb2dyZXNzLnNpYmxpbmc7XG4gICAgbmV3V29ya0luUHJvZ3Jlc3MucmV0dXJuID0gb2xkV29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICAgIG5ld1dvcmtJblByb2dyZXNzLnJlZiA9IG9sZFdvcmtJblByb2dyZXNzLnJlZjtcblxuICAgIHtcbiAgICAgIG5ld1dvcmtJblByb2dyZXNzLl9kZWJ1Z0luZm8gPSBvbGRXb3JrSW5Qcm9ncmVzcy5fZGVidWdJbmZvO1xuICAgIH0gLy8gUmVwbGFjZSB0aGUgY2hpbGQvc2libGluZyBwb2ludGVycyBhYm92ZSBpdC5cblxuXG4gICAgaWYgKG9sZFdvcmtJblByb2dyZXNzID09PSByZXR1cm5GaWJlci5jaGlsZCkge1xuICAgICAgcmV0dXJuRmliZXIuY2hpbGQgPSBuZXdXb3JrSW5Qcm9ncmVzcztcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHByZXZTaWJsaW5nID0gcmV0dXJuRmliZXIuY2hpbGQ7XG5cbiAgICAgIGlmIChwcmV2U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHBhcmVudCB0byBoYXZlIGEgY2hpbGQuJyk7XG4gICAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgIHdoaWxlIChwcmV2U2libGluZy5zaWJsaW5nICE9PSBvbGRXb3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgcHJldlNpYmxpbmcgPSBwcmV2U2libGluZy5zaWJsaW5nO1xuXG4gICAgICAgIGlmIChwcmV2U2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIHRoZSBwcmV2aW91cyBzaWJsaW5nLicpO1xuICAgICAgICB9XG4gICAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgIHByZXZTaWJsaW5nLnNpYmxpbmcgPSBuZXdXb3JrSW5Qcm9ncmVzcztcbiAgICB9IC8vIERlbGV0ZSB0aGUgb2xkIGZpYmVyIGFuZCBwbGFjZSB0aGUgbmV3IG9uZS5cbiAgICAvLyBTaW5jZSB0aGUgb2xkIGZpYmVyIGlzIGRpc2Nvbm5lY3RlZCwgd2UgaGF2ZSB0byBzY2hlZHVsZSBpdCBtYW51YWxseS5cblxuXG4gICAgdmFyIGRlbGV0aW9ucyA9IHJldHVybkZpYmVyLmRlbGV0aW9ucztcblxuICAgIGlmIChkZWxldGlvbnMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybkZpYmVyLmRlbGV0aW9ucyA9IFtjdXJyZW50XTtcbiAgICAgIHJldHVybkZpYmVyLmZsYWdzIHw9IENoaWxkRGVsZXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0aW9ucy5wdXNoKGN1cnJlbnQpO1xuICAgIH1cblxuICAgIG5ld1dvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBsYWNlbWVudDsgLy8gUmVzdGFydCB3b3JrIGZyb20gdGhlIG5ldyBmaWJlci5cblxuICAgIHJldHVybiBuZXdXb3JrSW5Qcm9ncmVzcztcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dChjdXJyZW50LCByZW5kZXJMYW5lcykge1xuICAvLyBCZWZvcmUgcGVyZm9ybWluZyBhbiBlYXJseSBiYWlsb3V0LCB3ZSBtdXN0IGNoZWNrIGlmIHRoZXJlIGFyZSBwZW5kaW5nXG4gIC8vIHVwZGF0ZXMgb3IgY29udGV4dC5cbiAgdmFyIHVwZGF0ZUxhbmVzID0gY3VycmVudC5sYW5lcztcblxuICBpZiAoaW5jbHVkZXNTb21lTGFuZSh1cGRhdGVMYW5lcywgcmVuZGVyTGFuZXMpKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm8gcGVuZGluZyB1cGRhdGUsIGJ1dCBiZWNhdXNlIGNvbnRleHQgaXMgcHJvcGFnYXRlZCBsYXppbHksIHdlIG5lZWRcblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGF0dGVtcHRFYXJseUJhaWxvdXRJZk5vU2NoZWR1bGVkVXBkYXRlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAvLyBUaGlzIGZpYmVyIGRvZXMgbm90IGhhdmUgYW55IHBlbmRpbmcgd29yay4gQmFpbG91dCB3aXRob3V0IGVudGVyaW5nXG4gIC8vIHRoZSBiZWdpbiBwaGFzZS4gVGhlcmUncyBzdGlsbCBzb21lIGJvb2trZWVwaW5nIHdlIHRoYXQgbmVlZHMgdG8gYmUgZG9uZVxuICAvLyBpbiB0aGlzIG9wdGltaXplZCBwYXRoLCBtb3N0bHkgcHVzaGluZyBzdHVmZiBvbnRvIHRoZSBzdGFjay5cbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgIHtcbiAgICAgICAgdmFyIGNhY2hlID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlO1xuICAgICAgICBwdXNoQ2FjaGVQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgY2FjaGUpO1xuICAgICAgfVxuXG4gICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICBwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICB7XG4gICAgICAgIHZhciBuZXdWYWx1ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMudmFsdWU7XG4gICAgICAgIHZhciBjb250ZXh0O1xuXG4gICAgICAgIHtcbiAgICAgICAgICBjb250ZXh0ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHB1c2hQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgbmV3VmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICB7XG4gICAgICAgIC8vIFByb2ZpbGVyIHNob3VsZCBvbmx5IGNhbGwgb25SZW5kZXIgd2hlbiBvbmUgb2YgaXRzIGRlc2NlbmRhbnRzIGFjdHVhbGx5IHJlbmRlcmVkLlxuICAgICAgICB2YXIgaGFzQ2hpbGRXb3JrID0gaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyk7XG5cbiAgICAgICAgaWYgKGhhc0NoaWxkV29yaykge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBSZXNldCBlZmZlY3QgZHVyYXRpb25zIGZvciB0aGUgbmV4dCBldmVudHVhbCBlZmZlY3QgcGhhc2UuXG4gICAgICAgICAgLy8gVGhlc2UgYXJlIHJlc2V0IGR1cmluZyByZW5kZXIgdG8gYWxsb3cgdGhlIERldlRvb2xzIGNvbW1pdCBob29rIGEgY2hhbmNlIHRvIHJlYWQgdGhlbSxcbiAgICAgICAgICB2YXIgc3RhdGVOb2RlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICAgIHN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICAgICAgc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgIGlmIChzdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChzdGF0ZS5kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBXZSdyZSBub3QgZ29pbmcgdG8gcmVuZGVyIHRoZSBjaGlsZHJlbiwgc28gdGhpcyBpcyBqdXN0IHRvIG1haW50YWluXG4gICAgICAgICAgICAvLyBwdXNoL3BvcCBzeW1tZXRyeVxuICAgICAgICAgICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTsgLy8gV2Uga25vdyB0aGF0IHRoaXMgY29tcG9uZW50IHdpbGwgc3VzcGVuZCBhZ2FpbiBiZWNhdXNlIGlmIGl0IGhhc1xuICAgICAgICAgICAgLy8gYmVlbiB1bnN1c3BlbmRlZCBpdCBoYXMgY29tbWl0dGVkIGFzIGEgcmVzb2x2ZWQgU3VzcGVuc2UgY29tcG9uZW50LlxuICAgICAgICAgICAgLy8gSWYgaXQgbmVlZHMgdG8gYmUgcmV0cmllZCwgaXQgc2hvdWxkIGhhdmUgd29yayBzY2hlZHVsZWQgb24gaXQuXG5cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7IC8vIFdlIHNob3VsZCBuZXZlciByZW5kZXIgdGhlIGNoaWxkcmVuIG9mIGEgZGVoeWRyYXRlZCBib3VuZGFyeSB1bnRpbCB3ZVxuICAgICAgICAgICAgLy8gdXBncmFkZSBpdC4gV2UgcmV0dXJuIG51bGwgaW5zdGVhZCBvZiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrLlxuXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9IC8vIElmIHRoaXMgYm91bmRhcnkgaXMgY3VycmVudGx5IHRpbWVkIG91dCwgd2UgbmVlZCB0byBkZWNpZGVcbiAgICAgICAgICAvLyB3aGV0aGVyIHRvIHJldHJ5IHRoZSBwcmltYXJ5IGNoaWxkcmVuLCBvciB0byBza2lwIG92ZXIgaXQgYW5kXG4gICAgICAgICAgLy8gZ28gc3RyYWlnaHQgdG8gdGhlIGZhbGxiYWNrLiBDaGVjayB0aGUgcHJpb3JpdHkgb2YgdGhlIHByaW1hcnlcbiAgICAgICAgICAvLyBjaGlsZCBmcmFnbWVudC5cblxuXG4gICAgICAgICAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgdmFyIHByaW1hcnlDaGlsZExhbmVzID0gcHJpbWFyeUNoaWxkRnJhZ21lbnQuY2hpbGRMYW5lcztcblxuICAgICAgICAgIGlmIChpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCBwcmltYXJ5Q2hpbGRMYW5lcykpIHtcbiAgICAgICAgICAgIC8vIFRoZSBwcmltYXJ5IGNoaWxkcmVuIGhhdmUgcGVuZGluZyB3b3JrLiBVc2UgdGhlIG5vcm1hbCBwYXRoXG4gICAgICAgICAgICAvLyB0byBhdHRlbXB0IHRvIHJlbmRlciB0aGUgcHJpbWFyeSBjaGlsZHJlbiBhZ2Fpbi5cbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGUgcHJpbWFyeSBjaGlsZCBmcmFnbWVudCBkb2VzIG5vdCBoYXZlIHBlbmRpbmcgd29yayBtYXJrZWRcbiAgICAgICAgICAgIC8vIG9uIGl0XG4gICAgICAgICAgICBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpOyAvLyBUaGUgcHJpbWFyeSBjaGlsZHJlbiBkbyBub3QgaGF2ZSBwZW5kaW5nIHdvcmsgd2l0aCBzdWZmaWNpZW50XG4gICAgICAgICAgICAvLyBwcmlvcml0eS4gQmFpbG91dC5cblxuICAgICAgICAgICAgdmFyIGNoaWxkID0gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgICAgICAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gVGhlIGZhbGxiYWNrIGNoaWxkcmVuIGhhdmUgcGVuZGluZyB3b3JrLiBTa2lwIG92ZXIgdGhlXG4gICAgICAgICAgICAgIC8vIHByaW1hcnkgY2hpbGRyZW4gYW5kIHdvcmsgb24gdGhlIGZhbGxiYWNrLlxuICAgICAgICAgICAgICByZXR1cm4gY2hpbGQuc2libGluZztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIE5vdGU6IFdlIGNhbiByZXR1cm4gYG51bGxgIGhlcmUgYmVjYXVzZSB3ZSBhbHJlYWR5IGNoZWNrZWRcbiAgICAgICAgICAgICAgLy8gd2hldGhlciB0aGVyZSB3ZXJlIG5lc3RlZCBjb250ZXh0IGNvbnN1bWVycywgdmlhIHRoZSBjYWxsIHRvXG4gICAgICAgICAgICAgIC8vIGBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrYCBhYm92ZS5cbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgZGlkU3VzcGVuZEJlZm9yZSA9IChjdXJyZW50LmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3MkMTtcblxuICAgICAgICB2YXIgX2hhc0NoaWxkV29yayA9IGluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpO1xuXG4gICAgICAgIGlmIChkaWRTdXNwZW5kQmVmb3JlKSB7XG4gICAgICAgICAgaWYgKF9oYXNDaGlsZFdvcmspIHtcbiAgICAgICAgICAgIC8vIElmIHNvbWV0aGluZyB3YXMgaW4gZmFsbGJhY2sgc3RhdGUgbGFzdCB0aW1lLCBhbmQgd2UgaGF2ZSBhbGwgdGhlXG4gICAgICAgICAgICAvLyBzYW1lIGNoaWxkcmVuIHRoZW4gd2UncmUgc3RpbGwgaW4gcHJvZ3Jlc3NpdmUgbG9hZGluZyBzdGF0ZS5cbiAgICAgICAgICAgIC8vIFNvbWV0aGluZyBtaWdodCBnZXQgdW5ibG9ja2VkIGJ5IHN0YXRlIHVwZGF0ZXMgb3IgcmV0cmllcyBpbiB0aGVcbiAgICAgICAgICAgIC8vIHRyZWUgd2hpY2ggd2lsbCBhZmZlY3QgdGhlIHRhaWwuIFNvIHdlIG5lZWQgdG8gdXNlIHRoZSBub3JtYWxcbiAgICAgICAgICAgIC8vIHBhdGggdG8gY29tcHV0ZSB0aGUgY29ycmVjdCB0YWlsLlxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIH0gLy8gSWYgbm9uZSBvZiB0aGUgY2hpbGRyZW4gaGFkIGFueSB3b3JrLCB0aGF0IG1lYW5zIHRoYXQgbm9uZSBvZlxuICAgICAgICAgIC8vIHRoZW0gZ290IHJldHJpZWQgc28gdGhleSdsbCBzdGlsbCBiZSBibG9ja2VkIGluIHRoZSBzYW1lIHdheVxuICAgICAgICAgIC8vIGFzIGJlZm9yZS4gV2UgY2FuIGZhc3QgYmFpbCBvdXQuXG5cblxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgIH0gLy8gSWYgbm90aGluZyBzdXNwZW5kZWQgYmVmb3JlIGFuZCB3ZSdyZSByZW5kZXJpbmcgdGhlIHNhbWUgY2hpbGRyZW4sXG4gICAgICAgIC8vIHRoZW4gdGhlIHRhaWwgZG9lc24ndCBtYXR0ZXIuIEFueXRoaW5nIG5ldyB0aGF0IHN1c3BlbmRzIHdpbGwgd29ya1xuICAgICAgICAvLyBpbiB0aGUgXCJ0b2dldGhlclwiIG1vZGUsIHNvIHdlIGNhbiBjb250aW51ZSBmcm9tIHRoZSBzdGF0ZSB3ZSBoYWQuXG5cblxuICAgICAgICB2YXIgcmVuZGVyU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgIGlmIChyZW5kZXJTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFJlc2V0IHRvIHRoZSBcInRvZ2V0aGVyXCIgbW9kZSBpbiBjYXNlIHdlJ3ZlIHN0YXJ0ZWQgYSBkaWZmZXJlbnRcbiAgICAgICAgICAvLyB1cGRhdGUgaW4gdGhlIHBhc3QgYnV0IGRpZG4ndCBjb21wbGV0ZSBpdC5cbiAgICAgICAgICByZW5kZXJTdGF0ZS5yZW5kZXJpbmcgPSBudWxsO1xuICAgICAgICAgIHJlbmRlclN0YXRlLnRhaWwgPSBudWxsO1xuICAgICAgICAgIHJlbmRlclN0YXRlLmxhc3RFZmZlY3QgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcHVzaFN1c3BlbnNlTGlzdENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCk7XG5cbiAgICAgICAgaWYgKF9oYXNDaGlsZFdvcmspIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJZiBub25lIG9mIHRoZSBjaGlsZHJlbiBoYWQgYW55IHdvcmssIHRoYXQgbWVhbnMgdGhhdCBub25lIG9mXG4gICAgICAgICAgLy8gdGhlbSBnb3QgcmV0cmllZCBzbyB0aGV5J2xsIHN0aWxsIGJlIGJsb2NrZWQgaW4gdGhlIHNhbWUgd2F5XG4gICAgICAgICAgLy8gYXMgYmVmb3JlLiBXZSBjYW4gZmFzdCBiYWlsIG91dC5cbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIC8vIE5lZWQgdG8gY2hlY2sgaWYgdGhlIHRyZWUgc3RpbGwgbmVlZHMgdG8gYmUgZGVmZXJyZWQuIFRoaXMgaXNcbiAgICAgICAgLy8gYWxtb3N0IGlkZW50aWNhbCB0byB0aGUgbG9naWMgdXNlZCBpbiB0aGUgbm9ybWFsIHVwZGF0ZSBwYXRoLFxuICAgICAgICAvLyBzbyB3ZSdsbCBqdXN0IGVudGVyIHRoYXQuIFRoZSBvbmx5IGRpZmZlcmVuY2UgaXMgd2UnbGwgYmFpbCBvdXRcbiAgICAgICAgLy8gYXQgdGhlIG5leHQgbGV2ZWwgaW5zdGVhZCBvZiB0aGlzIG9uZSwgYmVjYXVzZSB0aGUgY2hpbGQgcHJvcHNcbiAgICAgICAgLy8gaGF2ZSBub3QgY2hhbmdlZC4gV2hpY2ggaXMgZmluZS5cbiAgICAgICAgLy8gVE9ETzogUHJvYmFibHkgc2hvdWxkIHJlZmFjdG9yIGBiZWdpbldvcmtgIHRvIHNwbGl0IHRoZSBiYWlsb3V0XG4gICAgICAgIC8vIHBhdGggZnJvbSB0aGUgbm9ybWFsIHBhdGguIEknbSB0ZW1wdGVkIHRvIGRvIGEgbGFiZWxlZCBicmVhayBoZXJlXG4gICAgICAgIC8vIGJ1dCBJIHdvbid0IDopXG4gICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gTm9MYW5lcztcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBDYWNoZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfY2FjaGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGU7XG4gICAgICAgICAgcHVzaENhY2hlUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIF9jYWNoZSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxuXG4gIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG59XG5cbmZ1bmN0aW9uIGJlZ2luV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5fZGVidWdOZWVkc1JlbW91bnQgJiYgY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgLy8gVGhpcyB3aWxsIHJlc3RhcnQgdGhlIGJlZ2luIHBoYXNlIHdpdGggYSBuZXcgZmliZXIuXG4gICAgICByZXR1cm4gcmVtb3VudEZpYmVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMod29ya0luUHJvZ3Jlc3MudHlwZSwgd29ya0luUHJvZ3Jlc3Mua2V5LCB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsIHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyIHx8IG51bGwsIHdvcmtJblByb2dyZXNzLm1vZGUsIHdvcmtJblByb2dyZXNzLmxhbmVzKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcyB8fCBoYXNDb250ZXh0Q2hhbmdlZCgpIHx8ICggLy8gRm9yY2UgYSByZS1yZW5kZXIgaWYgdGhlIGltcGxlbWVudGF0aW9uIGNoYW5nZWQgZHVlIHRvIGhvdCByZWxvYWQ6XG4gICAgd29ya0luUHJvZ3Jlc3MudHlwZSAhPT0gY3VycmVudC50eXBlICkpIHtcbiAgICAgIC8vIElmIHByb3BzIG9yIGNvbnRleHQgY2hhbmdlZCwgbWFyayB0aGUgZmliZXIgYXMgaGF2aW5nIHBlcmZvcm1lZCB3b3JrLlxuICAgICAgLy8gVGhpcyBtYXkgYmUgdW5zZXQgaWYgdGhlIHByb3BzIGFyZSBkZXRlcm1pbmVkIHRvIGJlIGVxdWFsIGxhdGVyIChtZW1vKS5cbiAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBOZWl0aGVyIHByb3BzIG5vciBsZWdhY3kgY29udGV4dCBjaGFuZ2VzLiBDaGVjayBpZiB0aGVyZSdzIGEgcGVuZGluZ1xuICAgICAgLy8gdXBkYXRlIG9yIGNvbnRleHQgY2hhbmdlLlxuICAgICAgdmFyIGhhc1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCA9IGNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKTtcblxuICAgICAgaWYgKCFoYXNTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQgJiYgLy8gSWYgdGhpcyBpcyB0aGUgc2Vjb25kIHBhc3Mgb2YgYW4gZXJyb3Igb3Igc3VzcGVuc2UgYm91bmRhcnksIHRoZXJlXG4gICAgICAvLyBtYXkgbm90IGJlIHdvcmsgc2NoZWR1bGVkIG9uIGBjdXJyZW50YCwgc28gd2UgY2hlY2sgZm9yIHRoaXMgZmxhZy5cbiAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpID09PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgLy8gTm8gcGVuZGluZyB1cGRhdGVzIG9yIGNvbnRleHQuIEJhaWwgb3V0IG5vdy5cbiAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gYXR0ZW1wdEVhcmx5QmFpbG91dElmTm9TY2hlZHVsZWRVcGRhdGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgICAgaWYgKChjdXJyZW50LmZsYWdzICYgRm9yY2VVcGRhdGVGb3JMZWdhY3lTdXNwZW5zZSkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBjYXNlIHRoYXQgb25seSBleGlzdHMgZm9yIGxlZ2FjeSBtb2RlLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTkyMTYuXG4gICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQW4gdXBkYXRlIHdhcyBzY2hlZHVsZWQgb24gdGhpcyBmaWJlciwgYnV0IHRoZXJlIGFyZSBubyBuZXcgcHJvcHNcbiAgICAgICAgLy8gbm9yIGxlZ2FjeSBjb250ZXh0LiBTZXQgdGhpcyB0byBmYWxzZS4gSWYgYW4gdXBkYXRlIHF1ZXVlIG9yIGNvbnRleHRcbiAgICAgICAgLy8gY29uc3VtZXIgcHJvZHVjZXMgYSBjaGFuZ2VkIHZhbHVlLCBpdCB3aWxsIHNldCB0aGlzIHRvIHRydWUuIE90aGVyd2lzZSxcbiAgICAgICAgLy8gdGhlIGNvbXBvbmVudCB3aWxsIGFzc3VtZSB0aGUgY2hpbGRyZW4gaGF2ZSBub3QgY2hhbmdlZCBhbmQgYmFpbCBvdXQuXG4gICAgICAgIGRpZFJlY2VpdmVVcGRhdGUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgaWYgKGdldElzSHlkcmF0aW5nKCkgJiYgaXNGb3JrZWRDaGlsZCh3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgY2hpbGQgYmVsb25ncyB0byBhIGxpc3Qgb2YgbXVsaXBsZSBjaGlsZHJlbiBpblxuICAgICAgLy8gaXRzIHBhcmVudC5cbiAgICAgIC8vXG4gICAgICAvLyBJbiBhIHRydWUgbXVsdGktdGhyZWFkZWQgaW1wbGVtZW50YXRpb24sIHdlIHdvdWxkIHJlbmRlciBjaGlsZHJlbiBvblxuICAgICAgLy8gcGFyYWxsZWwgdGhyZWFkcy4gVGhpcyB3b3VsZCByZXByZXNlbnQgdGhlIGJlZ2lubmluZyBvZiBhIG5ldyByZW5kZXJcbiAgICAgIC8vIHRocmVhZCBmb3IgdGhpcyBzdWJ0cmVlLlxuICAgICAgLy9cbiAgICAgIC8vIFdlIG9ubHkgdXNlIHRoaXMgZm9yIGlkIGdlbmVyYXRpb24gZHVyaW5nIGh5ZHJhdGlvbiwgd2hpY2ggaXMgd2h5IHRoZVxuICAgICAgLy8gbG9naWMgaXMgbG9jYXRlZCBpbiB0aGlzIHNwZWNpYWwgYnJhbmNoLlxuICAgICAgdmFyIHNsb3RJbmRleCA9IHdvcmtJblByb2dyZXNzLmluZGV4O1xuICAgICAgdmFyIG51bWJlck9mRm9ya3MgPSBnZXRGb3Jrc0F0TGV2ZWwoKTtcbiAgICAgIHB1c2hUcmVlSWQod29ya0luUHJvZ3Jlc3MsIG51bWJlck9mRm9ya3MsIHNsb3RJbmRleCk7XG4gICAgfVxuICB9IC8vIEJlZm9yZSBlbnRlcmluZyB0aGUgYmVnaW4gcGhhc2UsIGNsZWFyIHBlbmRpbmcgdXBkYXRlIHByaW9yaXR5LlxuICAvLyBUT0RPOiBUaGlzIGFzc3VtZXMgdGhhdCB3ZSdyZSBhYm91dCB0byBldmFsdWF0ZSB0aGUgY29tcG9uZW50IGFuZCBwcm9jZXNzXG4gIC8vIHRoZSB1cGRhdGUgcXVldWUuIEhvd2V2ZXIsIHRoZXJlJ3MgYW4gZXhjZXB0aW9uOiBTaW1wbGVNZW1vQ29tcG9uZW50XG4gIC8vIHNvbWV0aW1lcyBiYWlscyBvdXQgbGF0ZXIgaW4gdGhlIGJlZ2luIHBoYXNlLiBUaGlzIGluZGljYXRlcyB0aGF0IHdlIHNob3VsZFxuICAvLyBtb3ZlIHRoaXMgYXNzaWdubWVudCBvdXQgb2YgdGhlIGNvbW1vbiBwYXRoIGFuZCBpbnRvIGVhY2ggYnJhbmNoLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBOb0xhbmVzO1xuXG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSBMYXp5Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgZWxlbWVudFR5cGUgPSB3b3JrSW5Qcm9ncmVzcy5lbGVtZW50VHlwZTtcbiAgICAgICAgcmV0dXJuIG1vdW50TGF6eUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgZWxlbWVudFR5cGUsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBDb21wb25lbnQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgdW5yZXNvbHZlZFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICAgICAgICB2YXIgcmVzb2x2ZWRQcm9wcyA9IHVucmVzb2x2ZWRQcm9wcyA7XG4gICAgICAgIHJldHVybiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCByZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX0NvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciBfdW5yZXNvbHZlZFByb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gICAgICAgIHZhciBfcmVzb2x2ZWRQcm9wczQgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhfQ29tcG9uZW50LCBfdW5yZXNvbHZlZFByb3BzKTtcblxuICAgICAgICByZXR1cm4gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIF9Db21wb25lbnQsIF9yZXNvbHZlZFByb3BzNCwgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHJldHVybiB1cGRhdGVIb3N0Um9vdChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBIb3N0SG9pc3RhYmxlOlxuICAgICAgaWYgKHN1cHBvcnRzUmVzb3VyY2VzKSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVIb3N0SG9pc3RhYmxlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cblxuICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgICAgaWYgKHN1cHBvcnRzU2luZ2xldG9ucykge1xuICAgICAgICByZXR1cm4gdXBkYXRlSG9zdFNpbmdsZXRvbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlSG9zdENvbXBvbmVudCQxKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RUZXh0JDEoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAge1xuICAgICAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciBfdW5yZXNvbHZlZFByb3BzMiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICAgICAgICB2YXIgX3Jlc29sdmVkUHJvcHM1ID0gX3VucmVzb2x2ZWRQcm9wczIgO1xuXG4gICAgICAgIHJldHVybiB1cGRhdGVGb3J3YXJkUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0eXBlLCBfcmVzb2x2ZWRQcm9wczUsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gdXBkYXRlRnJhZ21lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgTW9kZTpcbiAgICAgIHJldHVybiB1cGRhdGVNb2RlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgcmV0dXJuIHVwZGF0ZVByb2ZpbGVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIHJldHVybiB1cGRhdGVDb250ZXh0UHJvdmlkZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgQ29udGV4dENvbnN1bWVyOlxuICAgICAgcmV0dXJuIHVwZGF0ZUNvbnRleHRDb25zdW1lcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX3R5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgX3VucmVzb2x2ZWRQcm9wczMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7IC8vIFJlc29sdmUgb3V0ZXIgcHJvcHMgZmlyc3QsIHRoZW4gcmVzb2x2ZSBpbm5lciBwcm9wcy5cblxuICAgICAgICB2YXIgX3Jlc29sdmVkUHJvcHM2ID0gX3VucmVzb2x2ZWRQcm9wczMgO1xuXG4gICAgICAgIF9yZXNvbHZlZFByb3BzNiA9IF9yZXNvbHZlZFByb3BzNiA7XG4gICAgICAgIHJldHVybiB1cGRhdGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfdHlwZSwgX3Jlc29sdmVkUHJvcHM2LCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB1cGRhdGVTaW1wbGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy50eXBlLCB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIGNhc2UgSW5jb21wbGV0ZUZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBDYWNoZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiB1cGRhdGVDYWNoZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHVuaXQgb2Ygd29yayB0YWcgKFwiICsgd29ya0luUHJvZ3Jlc3MudGFnICsgXCIpLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gXCIgKyAnUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xufVxuXG52YXIgdmFsdWVDdXJzb3IgPSBjcmVhdGVDdXJzb3IobnVsbCk7XG52YXIgcmVuZGVyZXJDdXJzb3JERVY7XG5cbntcbiAgcmVuZGVyZXJDdXJzb3JERVYgPSBjcmVhdGVDdXJzb3IobnVsbCk7XG59XG5cbnZhciByZW5kZXJlcjJDdXJzb3JERVY7XG5cbntcbiAgcmVuZGVyZXIyQ3Vyc29yREVWID0gY3JlYXRlQ3Vyc29yKG51bGwpO1xufVxuXG52YXIgcmVuZGVyZXJTaWdpbDtcblxue1xuICAvLyBVc2UgdGhpcyB0byBkZXRlY3QgbXVsdGlwbGUgcmVuZGVyZXJzIHVzaW5nIHRoZSBzYW1lIGNvbnRleHRcbiAgcmVuZGVyZXJTaWdpbCA9IHt9O1xufVxuXG52YXIgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSBudWxsO1xudmFyIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG52YXIgbGFzdEZ1bGx5T2JzZXJ2ZWRDb250ZXh0ID0gbnVsbDtcbnZhciBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gZmFsc2U7XG5mdW5jdGlvbiByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKSB7XG4gIC8vIFRoaXMgaXMgY2FsbGVkIHJpZ2h0IGJlZm9yZSBSZWFjdCB5aWVsZHMgZXhlY3V0aW9uLCB0byBlbnN1cmUgYHJlYWRDb250ZXh0YFxuICAvLyBjYW5ub3QgYmUgY2FsbGVkIG91dHNpZGUgdGhlIHJlbmRlciBwaGFzZS5cbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSBudWxsO1xuICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBudWxsO1xuICBsYXN0RnVsbHlPYnNlcnZlZENvbnRleHQgPSBudWxsO1xuXG4gIHtcbiAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIGVudGVyRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKSB7XG4gIHtcbiAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gdHJ1ZTtcbiAgfVxufVxuZnVuY3Rpb24gZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCkge1xuICB7XG4gICAgaXNEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFViA9IGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBwdXNoUHJvdmlkZXIocHJvdmlkZXJGaWJlciwgY29udGV4dCwgbmV4dFZhbHVlKSB7XG4gIGlmIChpc1ByaW1hcnlSZW5kZXJlcikge1xuICAgIHB1c2godmFsdWVDdXJzb3IsIGNvbnRleHQuX2N1cnJlbnRWYWx1ZSwgcHJvdmlkZXJGaWJlcik7XG4gICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gbmV4dFZhbHVlO1xuXG4gICAge1xuICAgICAgcHVzaChyZW5kZXJlckN1cnNvckRFViwgY29udGV4dC5fY3VycmVudFJlbmRlcmVyLCBwcm92aWRlckZpYmVyKTtcblxuICAgICAgaWYgKGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAhPT0gdW5kZWZpbmVkICYmIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAhPT0gbnVsbCAmJiBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgIT09IHJlbmRlcmVyU2lnaWwpIHtcbiAgICAgICAgZXJyb3IoJ0RldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSAnICsgJ3NhbWUgY29udGV4dCBwcm92aWRlci4gVGhpcyBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciA9IHJlbmRlcmVyU2lnaWw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHB1c2godmFsdWVDdXJzb3IsIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIsIHByb3ZpZGVyRmliZXIpO1xuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBuZXh0VmFsdWU7XG5cbiAgICB7XG4gICAgICBwdXNoKHJlbmRlcmVyMkN1cnNvckRFViwgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiwgcHJvdmlkZXJGaWJlcik7XG5cbiAgICAgIGlmIChjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyICE9PSB1bmRlZmluZWQgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiAhPT0gbnVsbCAmJiBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyICE9PSByZW5kZXJlclNpZ2lsKSB7XG4gICAgICAgIGVycm9yKCdEZXRlY3RlZCBtdWx0aXBsZSByZW5kZXJlcnMgY29uY3VycmVudGx5IHJlbmRlcmluZyB0aGUgJyArICdzYW1lIGNvbnRleHQgcHJvdmlkZXIuIFRoaXMgaXMgY3VycmVudGx5IHVuc3VwcG9ydGVkLicpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gcmVuZGVyZXJTaWdpbDtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBvcFByb3ZpZGVyKGNvbnRleHQsIHByb3ZpZGVyRmliZXIpIHtcbiAgdmFyIGN1cnJlbnRWYWx1ZSA9IHZhbHVlQ3Vyc29yLmN1cnJlbnQ7XG5cbiAgaWYgKGlzUHJpbWFyeVJlbmRlcmVyKSB7XG4gICAgY29udGV4dC5fY3VycmVudFZhbHVlID0gY3VycmVudFZhbHVlO1xuXG4gICAge1xuICAgICAgdmFyIGN1cnJlbnRSZW5kZXJlciA9IHJlbmRlcmVyQ3Vyc29yREVWLmN1cnJlbnQ7XG4gICAgICBwb3AocmVuZGVyZXJDdXJzb3JERVYsIHByb3ZpZGVyRmliZXIpO1xuICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gY3VycmVudFJlbmRlcmVyO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUyID0gY3VycmVudFZhbHVlO1xuXG4gICAge1xuICAgICAgdmFyIGN1cnJlbnRSZW5kZXJlcjIgPSByZW5kZXJlcjJDdXJzb3JERVYuY3VycmVudDtcbiAgICAgIHBvcChyZW5kZXJlcjJDdXJzb3JERVYsIHByb3ZpZGVyRmliZXIpO1xuICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyMiA9IGN1cnJlbnRSZW5kZXJlcjI7XG4gICAgfVxuICB9XG5cbiAgcG9wKHZhbHVlQ3Vyc29yLCBwcm92aWRlckZpYmVyKTtcbn1cbmZ1bmN0aW9uIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgocGFyZW50LCByZW5kZXJMYW5lcywgcHJvcGFnYXRpb25Sb290KSB7XG4gIC8vIFVwZGF0ZSB0aGUgY2hpbGQgbGFuZXMgb2YgYWxsIHRoZSBhbmNlc3RvcnMsIGluY2x1ZGluZyB0aGUgYWx0ZXJuYXRlcy5cbiAgdmFyIG5vZGUgPSBwYXJlbnQ7XG5cbiAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICB2YXIgYWx0ZXJuYXRlID0gbm9kZS5hbHRlcm5hdGU7XG5cbiAgICBpZiAoIWlzU3Vic2V0T2ZMYW5lcyhub2RlLmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKSkge1xuICAgICAgbm9kZS5jaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhub2RlLmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKTtcblxuICAgICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICBhbHRlcm5hdGUuY2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMoYWx0ZXJuYXRlLmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCAmJiAhaXNTdWJzZXRPZkxhbmVzKGFsdGVybmF0ZS5jaGlsZExhbmVzLCByZW5kZXJMYW5lcykpIHtcbiAgICAgIGFsdGVybmF0ZS5jaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUuY2hpbGRMYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgIH0gZWxzZSA7XG5cbiAgICBpZiAobm9kZSA9PT0gcHJvcGFnYXRpb25Sb290KSB7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gIH1cblxuICB7XG4gICAgaWYgKG5vZGUgIT09IHByb3BhZ2F0aW9uUm9vdCkge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgdGhlIHByb3BhZ2F0aW9uIHJvb3Qgd2hlbiBzY2hlZHVsaW5nIGNvbnRleHQgd29yay4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcHJvcGFnYXRlQ29udGV4dENoYW5nZSh3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgcmVuZGVyTGFuZXMpIHtcbiAge1xuICAgIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VfZWFnZXIod29ya0luUHJvZ3Jlc3MsIGNvbnRleHQsIHJlbmRlckxhbmVzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlX2VhZ2VyKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCByZW5kZXJMYW5lcykge1xuXG4gIHZhciBmaWJlciA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG4gIGlmIChmaWJlciAhPT0gbnVsbCkge1xuICAgIC8vIFNldCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgdGhlIGNoaWxkIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuICAgIGZpYmVyLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB9XG5cbiAgd2hpbGUgKGZpYmVyICE9PSBudWxsKSB7XG4gICAgdmFyIG5leHRGaWJlciA9IHZvaWQgMDsgLy8gVmlzaXQgdGhpcyBmaWJlci5cblxuICAgIHZhciBsaXN0ID0gZmliZXIuZGVwZW5kZW5jaWVzO1xuXG4gICAgaWYgKGxpc3QgIT09IG51bGwpIHtcbiAgICAgIG5leHRGaWJlciA9IGZpYmVyLmNoaWxkO1xuICAgICAgdmFyIGRlcGVuZGVuY3kgPSBsaXN0LmZpcnN0Q29udGV4dDtcblxuICAgICAgd2hpbGUgKGRlcGVuZGVuY3kgIT09IG51bGwpIHtcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNvbnRleHQgbWF0Y2hlcy5cbiAgICAgICAgaWYgKGRlcGVuZGVuY3kuY29udGV4dCA9PT0gY29udGV4dCkge1xuICAgICAgICAgIC8vIE1hdGNoISBTY2hlZHVsZSBhbiB1cGRhdGUgb24gdGhpcyBmaWJlci5cbiAgICAgICAgICBpZiAoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYSBmb3JjZSB1cGRhdGUgb24gdGhlIHdvcmstaW4tcHJvZ3Jlc3MuXG4gICAgICAgICAgICB2YXIgbGFuZSA9IHBpY2tBcmJpdHJhcnlMYW5lKHJlbmRlckxhbmVzKTtcbiAgICAgICAgICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgICAgICAgICB1cGRhdGUudGFnID0gRm9yY2VVcGRhdGU7IC8vIFRPRE86IEJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBhIHdvcmstaW4tcHJvZ3Jlc3MsIHRoaXMgd2lsbCBhZGQgdGhlXG4gICAgICAgICAgICAvLyB1cGRhdGUgdG8gdGhlIGN1cnJlbnQgZmliZXIsIHRvbywgd2hpY2ggbWVhbnMgaXQgd2lsbCBwZXJzaXN0IGV2ZW4gaWZcbiAgICAgICAgICAgIC8vIHRoaXMgcmVuZGVyIGlzIHRocm93biBhd2F5LiBTaW5jZSBpdCdzIGEgcmFjZSBjb25kaXRpb24sIG5vdCBzdXJlIGl0J3NcbiAgICAgICAgICAgIC8vIHdvcnRoIGZpeGluZy5cbiAgICAgICAgICAgIC8vIElubGluZWQgYGVucXVldWVVcGRhdGVgIHRvIHJlbW92ZSBpbnRlcmxlYXZlZCB1cGRhdGUgY2hlY2tcblxuICAgICAgICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmliZXIudXBkYXRlUXVldWU7XG5cbiAgICAgICAgICAgIGlmICh1cGRhdGVRdWV1ZSA9PT0gbnVsbCkgOyBlbHNlIHtcbiAgICAgICAgICAgICAgdmFyIHNoYXJlZFF1ZXVlID0gdXBkYXRlUXVldWUuc2hhcmVkO1xuICAgICAgICAgICAgICB2YXIgcGVuZGluZyA9IHNoYXJlZFF1ZXVlLnBlbmRpbmc7XG5cbiAgICAgICAgICAgICAgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG4gICAgICAgICAgICAgICAgdXBkYXRlLm5leHQgPSB1cGRhdGU7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlLm5leHQgPSBwZW5kaW5nLm5leHQ7XG4gICAgICAgICAgICAgICAgcGVuZGluZy5uZXh0ID0gdXBkYXRlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgc2hhcmVkUXVldWUucGVuZGluZyA9IHVwZGF0ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaWJlci5sYW5lcyA9IG1lcmdlTGFuZXMoZmliZXIubGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgICAgICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgYWx0ZXJuYXRlLmxhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUubGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoKGZpYmVyLnJldHVybiwgcmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzKTsgLy8gTWFyayB0aGUgdXBkYXRlZCBsYW5lcyBvbiB0aGUgbGlzdCwgdG9vLlxuXG4gICAgICAgICAgbGlzdC5sYW5lcyA9IG1lcmdlTGFuZXMobGlzdC5sYW5lcywgcmVuZGVyTGFuZXMpOyAvLyBTaW5jZSB3ZSBhbHJlYWR5IGZvdW5kIGEgbWF0Y2gsIHdlIGNhbiBzdG9wIHRyYXZlcnNpbmcgdGhlXG4gICAgICAgICAgLy8gZGVwZW5kZW5jeSBsaXN0LlxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBkZXBlbmRlbmN5ID0gZGVwZW5kZW5jeS5uZXh0O1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZmliZXIudGFnID09PSBDb250ZXh0UHJvdmlkZXIpIHtcbiAgICAgIC8vIERvbid0IHNjYW4gZGVlcGVyIGlmIHRoaXMgaXMgYSBtYXRjaGluZyBwcm92aWRlclxuICAgICAgbmV4dEZpYmVyID0gZmliZXIudHlwZSA9PT0gd29ya0luUHJvZ3Jlc3MudHlwZSA/IG51bGwgOiBmaWJlci5jaGlsZDtcbiAgICB9IGVsc2UgaWYgKGZpYmVyLnRhZyA9PT0gRGVoeWRyYXRlZEZyYWdtZW50KSB7XG4gICAgICAvLyBJZiBhIGRlaHlkcmF0ZWQgc3VzcGVuc2UgYm91bmRhcnkgaXMgaW4gdGhpcyBzdWJ0cmVlLCB3ZSBkb24ndCBrbm93XG4gICAgICAvLyBpZiBpdCB3aWxsIGhhdmUgYW55IGNvbnRleHQgY29uc3VtZXJzIGluIGl0LiBUaGUgYmVzdCB3ZSBjYW4gZG8gaXNcbiAgICAgIC8vIG1hcmsgaXQgYXMgaGF2aW5nIHVwZGF0ZXMuXG4gICAgICB2YXIgcGFyZW50U3VzcGVuc2UgPSBmaWJlci5yZXR1cm47XG5cbiAgICAgIGlmIChwYXJlbnRTdXNwZW5zZSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlIGp1c3QgY2FtZSBmcm9tIGEgcGFyZW50IHNvIHdlIG11c3QgaGF2ZSBoYWQgYSBwYXJlbnQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG5cbiAgICAgIHBhcmVudFN1c3BlbnNlLmxhbmVzID0gbWVyZ2VMYW5lcyhwYXJlbnRTdXNwZW5zZS5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgdmFyIF9hbHRlcm5hdGUgPSBwYXJlbnRTdXNwZW5zZS5hbHRlcm5hdGU7XG5cbiAgICAgIGlmIChfYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgIF9hbHRlcm5hdGUubGFuZXMgPSBtZXJnZUxhbmVzKF9hbHRlcm5hdGUubGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH0gLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IHBhc3NpbmcgdGhpcyBmaWJlciBhcyB0aGUgcGFyZW50XG4gICAgICAvLyBiZWNhdXNlIHdlIHdhbnQgdG8gc2NoZWR1bGUgdGhpcyBmaWJlciBhcyBoYXZpbmcgd29ya1xuICAgICAgLy8gb24gaXRzIGNoaWxkcmVuLiBXZSdsbCB1c2UgdGhlIGNoaWxkTGFuZXMgb25cbiAgICAgIC8vIHRoaXMgZmliZXIgdG8gaW5kaWNhdGUgdGhhdCBhIGNvbnRleHQgaGFzIGNoYW5nZWQuXG5cblxuICAgICAgc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChwYXJlbnRTdXNwZW5zZSwgcmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIG5leHRGaWJlciA9IGZpYmVyLnNpYmxpbmc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRyYXZlcnNlIGRvd24uXG4gICAgICBuZXh0RmliZXIgPSBmaWJlci5jaGlsZDtcbiAgICB9XG5cbiAgICBpZiAobmV4dEZpYmVyICE9PSBudWxsKSB7XG4gICAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBjaGlsZCB0byB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlci5cbiAgICAgIG5leHRGaWJlci5yZXR1cm4gPSBmaWJlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTm8gY2hpbGQuIFRyYXZlcnNlIHRvIG5leHQgc2libGluZy5cbiAgICAgIG5leHRGaWJlciA9IGZpYmVyO1xuXG4gICAgICB3aGlsZSAobmV4dEZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChuZXh0RmliZXIgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgLy8gV2UncmUgYmFjayB0byB0aGUgcm9vdCBvZiB0aGlzIHN1YnRyZWUuIEV4aXQuXG4gICAgICAgICAgbmV4dEZpYmVyID0gbnVsbDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzaWJsaW5nID0gbmV4dEZpYmVyLnNpYmxpbmc7XG5cbiAgICAgICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAvLyBTZXQgdGhlIHJldHVybiBwb2ludGVyIG9mIHRoZSBzaWJsaW5nIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuICAgICAgICAgIHNpYmxpbmcucmV0dXJuID0gbmV4dEZpYmVyLnJldHVybjtcbiAgICAgICAgICBuZXh0RmliZXIgPSBzaWJsaW5nO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IC8vIE5vIG1vcmUgc2libGluZ3MuIFRyYXZlcnNlIHVwLlxuXG5cbiAgICAgICAgbmV4dEZpYmVyID0gbmV4dEZpYmVyLnJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaWJlciA9IG5leHRGaWJlcjtcbiAgfVxufVxuZnVuY3Rpb24gcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID0gd29ya0luUHJvZ3Jlc3M7XG4gIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG4gIGxhc3RGdWxseU9ic2VydmVkQ29udGV4dCA9IG51bGw7XG4gIHZhciBkZXBlbmRlbmNpZXMgPSB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXM7XG5cbiAgaWYgKGRlcGVuZGVuY2llcyAhPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIHZhciBmaXJzdENvbnRleHQgPSBkZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0O1xuXG4gICAgICBpZiAoZmlyc3RDb250ZXh0ICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChpbmNsdWRlc1NvbWVMYW5lKGRlcGVuZGVuY2llcy5sYW5lcywgcmVuZGVyTGFuZXMpKSB7XG4gICAgICAgICAgLy8gQ29udGV4dCBsaXN0IGhhcyBhIHBlbmRpbmcgdXBkYXRlLiBNYXJrIHRoYXQgdGhpcyBmaWJlciBwZXJmb3JtZWQgd29yay5cbiAgICAgICAgICBtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSgpO1xuICAgICAgICB9IC8vIFJlc2V0IHRoZSB3b3JrLWluLXByb2dyZXNzIGxpc3RcblxuXG4gICAgICAgIGRlcGVuZGVuY2llcy5maXJzdENvbnRleHQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVhZENvbnRleHQoY29udGV4dCkge1xuICB7XG4gICAgLy8gVGhpcyB3YXJuaW5nIHdvdWxkIGZpcmUgaWYgeW91IHJlYWQgY29udGV4dCBpbnNpZGUgYSBIb29rIGxpa2UgdXNlTWVtby5cbiAgICAvLyBVbmxpa2UgdGhlIGNsYXNzIGNoZWNrIGJlbG93LCBpdCdzIG5vdCBlbmZvcmNlZCBpbiBwcm9kdWN0aW9uIGZvciBwZXJmLlxuICAgIGlmIChpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKSB7XG4gICAgICBlcnJvcignQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gJyArICdJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnICsgJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnICsgJ2luc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlYWRDb250ZXh0Rm9yQ29uc3VtZXIoY3VycmVudGx5UmVuZGVyaW5nRmliZXIsIGNvbnRleHQpO1xufVxuZnVuY3Rpb24gcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihjb25zdW1lciwgY29udGV4dCwgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyID09PSBudWxsKSB7XG4gICAgcHJlcGFyZVRvUmVhZENvbnRleHQoY29uc3VtZXIsIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHJldHVybiByZWFkQ29udGV4dEZvckNvbnN1bWVyKGNvbnN1bWVyLCBjb250ZXh0KTtcbn1cblxuZnVuY3Rpb24gcmVhZENvbnRleHRGb3JDb25zdW1lcihjb25zdW1lciwgY29udGV4dCkge1xuICB2YXIgdmFsdWUgPSBpc1ByaW1hcnlSZW5kZXJlciA/IGNvbnRleHQuX2N1cnJlbnRWYWx1ZSA6IGNvbnRleHQuX2N1cnJlbnRWYWx1ZTI7XG5cbiAgaWYgKGxhc3RGdWxseU9ic2VydmVkQ29udGV4dCA9PT0gY29udGV4dCkgOyBlbHNlIHtcbiAgICB2YXIgY29udGV4dEl0ZW0gPSB7XG4gICAgICBjb250ZXh0OiBjb250ZXh0LFxuICAgICAgbWVtb2l6ZWRWYWx1ZTogdmFsdWUsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcblxuICAgIGlmIChsYXN0Q29udGV4dERlcGVuZGVuY3kgPT09IG51bGwpIHtcbiAgICAgIGlmIChjb25zdW1lciA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRleHQgY2FuIG9ubHkgYmUgcmVhZCB3aGlsZSBSZWFjdCBpcyByZW5kZXJpbmcuICcgKyAnSW4gY2xhc3NlcywgeW91IGNhbiByZWFkIGl0IGluIHRoZSByZW5kZXIgbWV0aG9kIG9yIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gJyArICdJbiBmdW5jdGlvbiBjb21wb25lbnRzLCB5b3UgY2FuIHJlYWQgaXQgZGlyZWN0bHkgaW4gdGhlIGZ1bmN0aW9uIGJvZHksIGJ1dCBub3QgJyArICdpbnNpZGUgSG9va3MgbGlrZSB1c2VSZWR1Y2VyKCkgb3IgdXNlTWVtbygpLicpO1xuICAgICAgfSAvLyBUaGlzIGlzIHRoZSBmaXJzdCBkZXBlbmRlbmN5IGZvciB0aGlzIGNvbXBvbmVudC4gQ3JlYXRlIGEgbmV3IGxpc3QuXG5cblxuICAgICAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gY29udGV4dEl0ZW07XG4gICAgICBjb25zdW1lci5kZXBlbmRlbmNpZXMgPSB7XG4gICAgICAgIGxhbmVzOiBOb0xhbmVzLFxuICAgICAgICBmaXJzdENvbnRleHQ6IGNvbnRleHRJdGVtXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBBcHBlbmQgYSBuZXcgY29udGV4dCBpdGVtLlxuICAgICAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbGFzdENvbnRleHREZXBlbmRlbmN5Lm5leHQgPSBjb250ZXh0SXRlbTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8vIHJlcGxhY2UgaXQgd2l0aCBhIGxpZ2h0d2VpZ2h0IHNoaW0gdGhhdCBvbmx5IGhhcyB0aGUgZmVhdHVyZXMgd2UgdXNlLlxuXG52YXIgQWJvcnRDb250cm9sbGVyTG9jYWwgPSB0eXBlb2YgQWJvcnRDb250cm9sbGVyICE9PSAndW5kZWZpbmVkJyA/IEFib3J0Q29udHJvbGxlciA6IC8vICRGbG93Rml4TWVbbWlzc2luZy10aGlzLWFubm90XVxuLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5mdW5jdGlvbiBBYm9ydENvbnRyb2xsZXJTaGltKCkge1xuICB2YXIgbGlzdGVuZXJzID0gW107XG4gIHZhciBzaWduYWwgPSB0aGlzLnNpZ25hbCA9IHtcbiAgICBhYm9ydGVkOiBmYWxzZSxcbiAgICBhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gIH07XG5cbiAgdGhpcy5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICBzaWduYWwuYWJvcnRlZCA9IHRydWU7XG4gICAgbGlzdGVuZXJzLmZvckVhY2goZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gbGlzdGVuZXIoKTtcbiAgICB9KTtcbiAgfTtcbn0gOyAvLyBJbnRlbnRpb25hbGx5IG5vdCBuYW1lZCBpbXBvcnRzIGJlY2F1c2UgUm9sbHVwIHdvdWxkXG4vLyB1c2UgZHluYW1pYyBkaXNwYXRjaCBmb3IgQ29tbW9uSlMgaW50ZXJvcCBuYW1lZCBpbXBvcnRzLlxuXG52YXIgc2NoZWR1bGVDYWxsYmFjayQxID0gU2NoZWR1bGVyLnVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2ssXG4gICAgTm9ybWFsUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfTm9ybWFsUHJpb3JpdHk7XG52YXIgQ2FjaGVDb250ZXh0ID0ge1xuICAkJHR5cGVvZjogUkVBQ1RfQ09OVEVYVF9UWVBFLFxuICAvLyBXZSBkb24ndCB1c2UgQ29uc3VtZXIvUHJvdmlkZXIgZm9yIENhY2hlIGNvbXBvbmVudHMuIFNvIHdlJ2xsIGNoZWF0LlxuICBDb25zdW1lcjogbnVsbCxcbiAgUHJvdmlkZXI6IG51bGwsXG4gIC8vIFdlJ2xsIGluaXRpYWxpemUgdGhlc2UgYXQgdGhlIHJvb3QuXG4gIF9jdXJyZW50VmFsdWU6IG51bGwsXG4gIF9jdXJyZW50VmFsdWUyOiBudWxsLFxuICBfdGhyZWFkQ291bnQ6IDBcbn0gO1xuXG57XG4gIENhY2hlQ29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gbnVsbDtcbiAgQ2FjaGVDb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gbnVsbDtcbn0gLy8gQ3JlYXRlcyBhIG5ldyBlbXB0eSBDYWNoZSBpbnN0YW5jZSB3aXRoIGEgcmVmLWNvdW50IG9mIDAuIFRoZSBjYWxsZXIgaXMgcmVzcG9uc2libGVcbi8vIGZvciByZXRhaW5pbmcgdGhlIGNhY2hlIG9uY2UgaXQgaXMgaW4gdXNlIChyZXRhaW5DYWNoZSksIGFuZCByZWxlYXNpbmcgdGhlIGNhY2hlXG4vLyBvbmNlIGl0IGlzIG5vIGxvbmdlciBuZWVkZWQgKHJlbGVhc2VDYWNoZSkuXG5cblxuZnVuY3Rpb24gY3JlYXRlQ2FjaGUoKSB7XG5cbiAgdmFyIGNhY2hlID0ge1xuICAgIGNvbnRyb2xsZXI6IG5ldyBBYm9ydENvbnRyb2xsZXJMb2NhbCgpLFxuICAgIGRhdGE6IG5ldyBNYXAoKSxcbiAgICByZWZDb3VudDogMFxuICB9O1xuICByZXR1cm4gY2FjaGU7XG59XG5mdW5jdGlvbiByZXRhaW5DYWNoZShjYWNoZSkge1xuXG4gIHtcbiAgICBpZiAoY2FjaGUuY29udHJvbGxlci5zaWduYWwuYWJvcnRlZCkge1xuICAgICAgd2FybignQSBjYWNoZSBpbnN0YW5jZSB3YXMgcmV0YWluZWQgYWZ0ZXIgaXQgd2FzIGFscmVhZHkgZnJlZWQuICcgKyAnVGhpcyBsaWtlbHkgaW5kaWNhdGVzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgIH1cbiAgfVxuXG4gIGNhY2hlLnJlZkNvdW50Kys7XG59IC8vIENsZWFudXAgYSBjYWNoZSBpbnN0YW5jZSwgcG90ZW50aWFsbHkgZnJlZWluZyBpdCBpZiB0aGVyZSBhcmUgbm8gbW9yZSByZWZlcmVuY2VzXG5cbmZ1bmN0aW9uIHJlbGVhc2VDYWNoZShjYWNoZSkge1xuXG4gIGNhY2hlLnJlZkNvdW50LS07XG5cbiAge1xuICAgIGlmIChjYWNoZS5yZWZDb3VudCA8IDApIHtcbiAgICAgIHdhcm4oJ0EgY2FjaGUgaW5zdGFuY2Ugd2FzIHJlbGVhc2VkIGFmdGVyIGl0IHdhcyBhbHJlYWR5IGZyZWVkLiAnICsgJ1RoaXMgbGlrZWx5IGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAoY2FjaGUucmVmQ291bnQgPT09IDApIHtcbiAgICBzY2hlZHVsZUNhbGxiYWNrJDEoTm9ybWFsUHJpb3JpdHksIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNhY2hlLmNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gcHVzaENhY2hlUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGNhY2hlKSB7XG5cbiAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBDYWNoZUNvbnRleHQsIGNhY2hlKTtcbn1cbmZ1bmN0aW9uIHBvcENhY2hlUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGNhY2hlKSB7XG5cbiAgcG9wUHJvdmlkZXIoQ2FjaGVDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG59XG5cbi8vIHRoZSBzaGFyZWQgaW50ZXJuYWxzIG9iamVjdC4gVGhpcyBpcyB1c2VkIGJ5IHRoZSBpc29tb3JwaGljIGltcGxlbWVudGF0aW9uIG9mXG4vLyBzdGFydFRyYW5zaXRpb24gdG8gY29tcG9zZSBhbGwgdGhlIHN0YXJ0VHJhbnNpdGlvbnMgdG9nZXRoZXIuXG4vL1xuLy8gICBmdW5jdGlvbiBzdGFydFRyYW5zaXRpb24oZm4pIHtcbi8vICAgICByZXR1cm4gc3RhcnRUcmFuc2l0aW9uRE9NKCgpID0+IHtcbi8vICAgICAgIHJldHVybiBzdGFydFRyYW5zaXRpb25BUlQoKCkgPT4ge1xuLy8gICAgICAgICByZXR1cm4gc3RhcnRUcmFuc2l0aW9uVGhyZWVGaWJlcigoKSA9PiB7XG4vLyAgICAgICAgICAgLy8gYW5kIHNvIG9uLi4uXG4vLyAgICAgICAgICAgcmV0dXJuIGZuKCk7XG4vLyAgICAgICAgIH0pO1xuLy8gICAgICAgfSk7XG4vLyAgICAgfSk7XG4vLyAgIH1cbi8vXG4vLyBDdXJyZW50bHkgd2Ugb25seSBjb21wb3NlIHRvZ2V0aGVyIHRoZSBjb2RlIHRoYXQgcnVucyBhdCB0aGUgZW5kIG9mIGVhY2hcbi8vIHN0YXJ0VHJhbnNpdGlvbiwgYmVjYXVzZSBmb3Igbm93IHRoYXQncyBzdWZmaWNpZW50IOKAlCB0aGUgcGFydCB0aGF0IHNldHNcbi8vIGlzVHJhbnNpdGlvbj10cnVlIG9uIHRoZSBzdGFjayB1c2VzIGEgc2VwYXJhdGUgc2hhcmVkIGludGVybmFsIGZpZWxkLiBCdXRcbi8vIHJlYWxseSB3ZSBzaG91bGQgZGVsZXRlIHRoZSBzaGFyZWQgZmllbGQgYW5kIHRyYWNrIGlzVHJhbnNpdGlvbiBwZXJcbi8vIHJlY29uY2lsZXIuIExlYXZpbmcgdGhpcyBmb3IgYSBmdXR1cmUgUFIuXG5cbnZhciBwcmV2T25TdGFydFRyYW5zaXRpb25GaW5pc2ggPSBSZWFjdFNoYXJlZEludGVybmFscy5TO1xuXG5SZWFjdFNoYXJlZEludGVybmFscy5TID0gZnVuY3Rpb24gb25TdGFydFRyYW5zaXRpb25GaW5pc2hGb3JSZWNvbmNpbGVyKHRyYW5zaXRpb24sIHJldHVyblZhbHVlKSB7XG4gIGlmICh0eXBlb2YgcmV0dXJuVmFsdWUgPT09ICdvYmplY3QnICYmIHJldHVyblZhbHVlICE9PSBudWxsICYmIHR5cGVvZiByZXR1cm5WYWx1ZS50aGVuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVGhpcyBpcyBhbiBhc3luYyBhY3Rpb25cbiAgICB2YXIgdGhlbmFibGUgPSByZXR1cm5WYWx1ZTtcbiAgICBlbnRhbmdsZUFzeW5jQWN0aW9uKHRyYW5zaXRpb24sIHRoZW5hYmxlKTtcbiAgfVxuXG4gIGlmIChwcmV2T25TdGFydFRyYW5zaXRpb25GaW5pc2ggIT09IG51bGwpIHtcbiAgICBwcmV2T25TdGFydFRyYW5zaXRpb25GaW5pc2godHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZXF1ZXN0Q3VycmVudFRyYW5zaXRpb24oKSB7XG4gIHJldHVybiBSZWFjdFNoYXJlZEludGVybmFscy5UO1xufSAvLyBXaGVuIHJldHJ5aW5nIGEgU3VzcGVuc2UvT2Zmc2NyZWVuIGJvdW5kYXJ5LCB3ZSByZXN0b3JlIHRoZSBjYWNoZSB0aGF0IHdhc1xuLy8gdXNlZCBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlciBieSBwbGFjaW5nIGl0IGhlcmUsIG9uIHRoZSBzdGFjay5cblxudmFyIHJlc3VtZWRDYWNoZSA9IGNyZWF0ZUN1cnNvcihudWxsKTsgLy8gRHVyaW5nIHRoZSByZW5kZXIvc3luY2hyb25vdXMgY29tbWl0IHBoYXNlLCB3ZSBkb24ndCBhY3R1YWxseSBwcm9jZXNzIHRoZVxuXG5mdW5jdGlvbiBwZWVrQ2FjaGVGcm9tUG9vbCgpIHtcbiAgLy8gSWYgd2UncmUgcmVuZGVyaW5nIGluc2lkZSBhIFN1c3BlbnNlIGJvdW5kYXJ5IHRoYXQgaXMgY3VycmVudGx5IGhpZGRlbixcbiAgLy8gd2Ugc2hvdWxkIHVzZSB0aGUgc2FtZSBjYWNoZSB0aGF0IHdlIHVzZWQgZHVyaW5nIHRoZSBwcmV2aW91cyByZW5kZXIsIGlmXG4gIC8vIG9uZSBleGlzdHMuXG5cblxuICB2YXIgY2FjaGVSZXN1bWVkRnJvbVByZXZpb3VzUmVuZGVyID0gcmVzdW1lZENhY2hlLmN1cnJlbnQ7XG5cbiAgaWYgKGNhY2hlUmVzdW1lZEZyb21QcmV2aW91c1JlbmRlciAhPT0gbnVsbCkge1xuICAgIHJldHVybiBjYWNoZVJlc3VtZWRGcm9tUHJldmlvdXNSZW5kZXI7XG4gIH0gLy8gT3RoZXJ3aXNlLCBjaGVjayB0aGUgcm9vdCdzIGNhY2hlIHBvb2wuXG5cblxuICB2YXIgcm9vdCA9IGdldFdvcmtJblByb2dyZXNzUm9vdCgpO1xuICB2YXIgY2FjaGVGcm9tUm9vdENhY2hlUG9vbCA9IHJvb3QucG9vbGVkQ2FjaGU7XG4gIHJldHVybiBjYWNoZUZyb21Sb290Q2FjaGVQb29sO1xufVxuXG5mdW5jdGlvbiByZXF1ZXN0Q2FjaGVGcm9tUG9vbChyZW5kZXJMYW5lcykge1xuICAvLyBTaW1pbGFyIHRvIHByZXZpb3VzIGZ1bmN0aW9uLCBleGNlcHQgaWYgdGhlcmUncyBub3QgYWxyZWFkeSBhIGNhY2hlIGluIHRoZVxuICAvLyBwb29sLCB3ZSBhbGxvY2F0ZSBhIG5ldyBvbmUuXG4gIHZhciBjYWNoZUZyb21Qb29sID0gcGVla0NhY2hlRnJvbVBvb2woKTtcblxuICBpZiAoY2FjaGVGcm9tUG9vbCAhPT0gbnVsbCkge1xuICAgIHJldHVybiBjYWNoZUZyb21Qb29sO1xuICB9IC8vIENyZWF0ZSBhIGZyZXNoIGNhY2hlIGFuZCBhZGQgaXQgdG8gdGhlIHJvb3QgY2FjaGUgcG9vbC4gQSBjYWNoZSBjYW4gaGF2ZVxuICAvLyBtdWx0aXBsZSBvd25lcnM6XG4gIC8vIC0gQSBjYWNoZSBwb29sIHRoYXQgbGl2ZXMgb24gdGhlIEZpYmVyUm9vdC4gVGhpcyBpcyB3aGVyZSBhbGwgZnJlc2ggY2FjaGVzXG4gIC8vICAgYXJlIG9yaWdpbmFsbHkgY3JlYXRlZCAoVE9ETzogZXhjZXB0IGR1cmluZyByZWZyZXNoZXMsIHVudGlsIHdlIGltcGxlbWVudFxuICAvLyAgIHRoaXMgY29ycmVjdGx5KS4gVGhlIHJvb3QgdGFrZXMgb3duZXJzaGlwIGltbWVkaWF0ZWx5IHdoZW4gdGhlIGNhY2hlIGlzXG4gIC8vICAgY3JlYXRlZC4gQ29uY2VwdHVhbGx5LCByb290LnBvb2xlZENhY2hlIGlzIGFuIE9wdGlvbjxBcmM8Q2FjaGU+PiAob3duZWQpLFxuICAvLyAgIGFuZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoaXMgZnVuY3Rpb24gaXMgYSAmQXJjPENhY2hlPiAoYm9ycm93ZWQpLlxuICAvLyAtIE9uZSBvZiBzZXZlcmFsIGZpYmVyIHR5cGVzOiBob3N0IHJvb3QsIGNhY2hlIGJvdW5kYXJ5LCBzdXNwZW5zZVxuICAvLyAgIGNvbXBvbmVudC4gVGhlc2UgcmV0YWluIGFuZCByZWxlYXNlIGluIHRoZSBjb21taXQgcGhhc2UuXG5cblxuICB2YXIgcm9vdCA9IGdldFdvcmtJblByb2dyZXNzUm9vdCgpO1xuICB2YXIgZnJlc2hDYWNoZSA9IGNyZWF0ZUNhY2hlKCk7XG4gIHJvb3QucG9vbGVkQ2FjaGUgPSBmcmVzaENhY2hlO1xuICByZXRhaW5DYWNoZShmcmVzaENhY2hlKTtcblxuICBpZiAoZnJlc2hDYWNoZSAhPT0gbnVsbCkge1xuICAgIHJvb3QucG9vbGVkQ2FjaGVMYW5lcyB8PSByZW5kZXJMYW5lcztcbiAgfVxuXG4gIHJldHVybiBmcmVzaENhY2hlO1xufVxuZnVuY3Rpb24gcHVzaFRyYW5zaXRpb24ob2Zmc2NyZWVuV29ya0luUHJvZ3Jlc3MsIHByZXZDYWNoZVBvb2wsIG5ld1RyYW5zaXRpb25zKSB7XG4gIHtcbiAgICBpZiAocHJldkNhY2hlUG9vbCA9PT0gbnVsbCkge1xuICAgICAgcHVzaChyZXN1bWVkQ2FjaGUsIHJlc3VtZWRDYWNoZS5jdXJyZW50LCBvZmZzY3JlZW5Xb3JrSW5Qcm9ncmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2gocmVzdW1lZENhY2hlLCBwcmV2Q2FjaGVQb29sLnBvb2wsIG9mZnNjcmVlbldvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHBvcFRyYW5zaXRpb24od29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQpIHtcbiAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcblxuICAgIHtcbiAgICAgIHBvcChyZXN1bWVkQ2FjaGUsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFN1c3BlbmRlZENhY2hlKCkge1xuICAvLyBjYWNoZSB0aGF0IHdvdWxkIGhhdmUgYmVlbiB1c2VkIHRvIHJlbmRlciBmcmVzaCBkYXRhIGR1cmluZyB0aGlzIHJlbmRlcixcbiAgLy8gaWYgdGhlcmUgd2FzIGFueSwgc28gdGhhdCB3ZSBjYW4gcmVzdW1lIHJlbmRlcmluZyB3aXRoIHRoZSBzYW1lIGNhY2hlIHdoZW5cbiAgLy8gd2UgcmVjZWl2ZSBtb3JlIGRhdGEuXG5cblxuICB2YXIgY2FjaGVGcm9tUG9vbCA9IHBlZWtDYWNoZUZyb21Qb29sKCk7XG5cbiAgaWYgKGNhY2hlRnJvbVBvb2wgPT09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLy8gV2UgbXVzdCBhbHNvIHNhdmUgdGhlIHBhcmVudCwgc28gdGhhdCB3aGVuIHdlIHJlc3VtZSB3ZSBjYW4gZGV0ZWN0XG4gICAgLy8gYSByZWZyZXNoLlxuICAgIHBhcmVudDogaXNQcmltYXJ5UmVuZGVyZXIgPyBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZSA6IENhY2hlQ29udGV4dC5fY3VycmVudFZhbHVlMixcbiAgICBwb29sOiBjYWNoZUZyb21Qb29sXG4gIH07XG59XG5mdW5jdGlvbiBnZXRPZmZzY3JlZW5EZWZlcnJlZENhY2hlKCkge1xuXG4gIHZhciBjYWNoZUZyb21Qb29sID0gcGVla0NhY2hlRnJvbVBvb2woKTtcblxuICBpZiAoY2FjaGVGcm9tUG9vbCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBXZSBtdXN0IGFsc28gc3RvcmUgdGhlIHBhcmVudCwgc28gdGhhdCB3aGVuIHdlIHJlc3VtZSB3ZSBjYW4gZGV0ZWN0XG4gICAgLy8gYSByZWZyZXNoLlxuICAgIHBhcmVudDogaXNQcmltYXJ5UmVuZGVyZXIgPyBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZSA6IENhY2hlQ29udGV4dC5fY3VycmVudFZhbHVlMixcbiAgICBwb29sOiBjYWNoZUZyb21Qb29sXG4gIH07XG59XG5cbi8qKlxuICogVGFnIHRoZSBmaWJlciB3aXRoIGFuIHVwZGF0ZSBlZmZlY3QuIFRoaXMgdHVybnMgYSBQbGFjZW1lbnQgaW50b1xuICogYSBQbGFjZW1lbnRBbmRVcGRhdGUuXG4gKi9cblxuZnVuY3Rpb24gbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcykge1xuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG59XG4vKipcbiAqIEluIHBlcnNpc3RlbnQgbW9kZSwgcmV0dXJuIHdoZXRoZXIgdGhpcyB1cGRhdGUgbmVlZHMgdG8gY2xvbmUgdGhlIHN1YnRyZWUuXG4gKi9cblxuXG5mdW5jdGlvbiBkb2VzUmVxdWlyZUNsb25lKGN1cnJlbnQsIGNvbXBsZXRlZFdvcmspIHtcbiAgdmFyIGRpZEJhaWxvdXQgPSBjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQuY2hpbGQgPT09IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG5cbiAgaWYgKGRpZEJhaWxvdXQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAoKGNvbXBsZXRlZFdvcmsuZmxhZ3MgJiBDaGlsZERlbGV0aW9uKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gVE9ETzogSWYgd2UgbW92ZSB0aGUgYGRvZXNSZXF1aXJlQ2xvbmVgIGNhbGwgYWZ0ZXIgYGJ1YmJsZVByb3BlcnRpZXNgXG4gIC8vIHRoZW4gd2Ugb25seSBoYXZlIHRvIGNoZWNrIHRoZSBgY29tcGxldGVkV29yay5zdWJ0cmVlRmxhZ3NgLlxuXG5cbiAgdmFyIGNoaWxkID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICBpZiAoKGNoaWxkLmZsYWdzICYgTXV0YXRpb25NYXNrKSAhPT0gTm9GbGFncyQxIHx8IChjaGlsZC5zdWJ0cmVlRmxhZ3MgJiBNdXRhdGlvbk1hc2spICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYXBwZW5kQWxsQ2hpbGRyZW4ocGFyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLCBpc0hpZGRlbikge1xuICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudCwgbm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCB8fCAoc3VwcG9ydHNTaW5nbGV0b25zID8gbm9kZS50YWcgPT09IEhvc3RTaW5nbGV0b24gOiBmYWxzZSkpIDsgZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH0gZWxzZSBpZiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgX25vZGUgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICAgIHdoaWxlIChfbm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKF9ub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBfbm9kZS5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSAmJiBpc0hpZGRlbikge1xuICAgICAgICAgIC8vIFRoaXMgY2hpbGQgaXMgaW5zaWRlIGEgdGltZWQgb3V0IHRyZWUuIEhpZGUgaXQuXG4gICAgICAgICAgdmFyIHByb3BzID0gX25vZGUubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICB2YXIgdHlwZSA9IF9ub2RlLnR5cGU7XG4gICAgICAgICAgaW5zdGFuY2UgPSBjbG9uZUhpZGRlbkluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50LCBpbnN0YW5jZSk7XG4gICAgICB9IGVsc2UgaWYgKF9ub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgdmFyIF9pbnN0YW5jZSA9IF9ub2RlLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAobmVlZHNWaXNpYmlsaXR5VG9nZ2xlICYmIGlzSGlkZGVuKSB7XG4gICAgICAgICAgLy8gVGhpcyBjaGlsZCBpcyBpbnNpZGUgYSB0aW1lZCBvdXQgdHJlZS4gSGlkZSBpdC5cbiAgICAgICAgICB2YXIgdGV4dCA9IF9ub2RlLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgX2luc3RhbmNlID0gY2xvbmVIaWRkZW5UZXh0SW5zdGFuY2UoX2luc3RhbmNlLCB0ZXh0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIF9pbnN0YW5jZSk7XG4gICAgICB9IGVsc2UgaWYgKF9ub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkgOyBlbHNlIGlmIChfbm9kZS50YWcgPT09IE9mZnNjcmVlbkNvbXBvbmVudCAmJiBfbm9kZS5tZW1vaXplZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZSBjaGlsZHJlbiBpbiB0aGlzIGJvdW5kYXJ5IGFyZSBoaWRkZW4uIFRvZ2dsZSB0aGVpciB2aXNpYmlsaXR5XG4gICAgICAgIC8vIGJlZm9yZSBhcHBlbmRpbmcuXG4gICAgICAgIHZhciBjaGlsZCA9IF9ub2RlLmNoaWxkO1xuXG4gICAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNoaWxkLnJldHVybiA9IF9ub2RlO1xuICAgICAgICB9XG5cbiAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW4ocGFyZW50LCBfbm9kZSxcbiAgICAgICAgLyogbmVlZHNWaXNpYmlsaXR5VG9nZ2xlICovXG4gICAgICAgIHRydWUsXG4gICAgICAgIC8qIGlzSGlkZGVuICovXG4gICAgICAgIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChfbm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBfbm9kZS5jaGlsZC5yZXR1cm4gPSBfbm9kZTtcbiAgICAgICAgX25vZGUgPSBfbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChfbm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICB3aGlsZSAoX25vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgaWYgKF9ub2RlLnJldHVybiA9PT0gbnVsbCB8fCBfbm9kZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgX25vZGUgPSBfbm9kZS5yZXR1cm47XG4gICAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgIF9ub2RlLnNpYmxpbmcucmV0dXJuID0gX25vZGUucmV0dXJuO1xuICAgICAgX25vZGUgPSBfbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxufSAvLyBBbiB1bmZvcnR1bmF0ZSBmb3JrIG9mIGFwcGVuZEFsbENoaWxkcmVuIGJlY2F1c2Ugd2UgaGF2ZSB0d28gZGlmZmVyZW50IHBhcmVudCB0eXBlcy5cblxuXG5mdW5jdGlvbiBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyKGNvbnRhaW5lckNoaWxkU2V0LCB3b3JrSW5Qcm9ncmVzcywgbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLCBpc0hpZGRlbikge1xuICBpZiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGNyZWF0ZWQgYnV0IHdlIG5lZWQgcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICB2YXIgbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAobmVlZHNWaXNpYmlsaXR5VG9nZ2xlICYmIGlzSGlkZGVuKSB7XG4gICAgICAgICAgLy8gVGhpcyBjaGlsZCBpcyBpbnNpZGUgYSB0aW1lZCBvdXQgdHJlZS4gSGlkZSBpdC5cbiAgICAgICAgICB2YXIgcHJvcHMgPSBub2RlLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgdmFyIHR5cGUgPSBub2RlLnR5cGU7XG4gICAgICAgICAgaW5zdGFuY2UgPSBjbG9uZUhpZGRlbkluc3RhbmNlKGluc3RhbmNlLCB0eXBlLCBwcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyQ2hpbGRTZXQsIGluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgICAgIHZhciBfaW5zdGFuY2UyID0gbm9kZS5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSAmJiBpc0hpZGRlbikge1xuICAgICAgICAgIC8vIFRoaXMgY2hpbGQgaXMgaW5zaWRlIGEgdGltZWQgb3V0IHRyZWUuIEhpZGUgaXQuXG4gICAgICAgICAgdmFyIHRleHQgPSBub2RlLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgX2luc3RhbmNlMiA9IGNsb25lSGlkZGVuVGV4dEluc3RhbmNlKF9pbnN0YW5jZTIsIHRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0KGNvbnRhaW5lckNoaWxkU2V0LCBfaW5zdGFuY2UyKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIDsgZWxzZSBpZiAobm9kZS50YWcgPT09IE9mZnNjcmVlbkNvbXBvbmVudCAmJiBub2RlLm1lbW9pemVkU3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhlIGNoaWxkcmVuIGluIHRoaXMgYm91bmRhcnkgYXJlIGhpZGRlbi4gVG9nZ2xlIHRoZWlyIHZpc2liaWxpdHlcbiAgICAgICAgLy8gYmVmb3JlIGFwcGVuZGluZy5cbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuICAgICAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBjaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICB9IC8vIElmIE9mZnNjcmVlbiBpcyBub3QgaW4gbWFudWFsIG1vZGUsIGRldGFjaGVkIHRyZWUgaXMgaGlkZGVuIGZyb20gdXNlciBzcGFjZS5cblxuXG4gICAgICAgIHZhciBfbmVlZHNWaXNpYmlsaXR5VG9nZ2xlID0gIWlzT2Zmc2NyZWVuTWFudWFsKG5vZGUpO1xuXG4gICAgICAgIGFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIoY29udGFpbmVyQ2hpbGRTZXQsIG5vZGUsXG4gICAgICAgIC8qIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSAqL1xuICAgICAgICBfbmVlZHNWaXNpYmlsaXR5VG9nZ2xlLFxuICAgICAgICAvKiBpc0hpZGRlbiAqL1xuICAgICAgICB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGU7XG5cbiAgICAgIGlmIChub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RDb250YWluZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcbiAgICBpZiAoZG9lc1JlcXVpcmVDbG9uZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgIHZhciBwb3J0YWxPclJvb3QgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICB2YXIgY29udGFpbmVyID0gcG9ydGFsT3JSb290LmNvbnRhaW5lckluZm87XG4gICAgICB2YXIgbmV3Q2hpbGRTZXQgPSBjcmVhdGVDb250YWluZXJDaGlsZFNldCgpOyAvLyBJZiBjaGlsZHJlbiBtaWdodCBoYXZlIGNoYW5nZWQsIHdlIGhhdmUgdG8gYWRkIHRoZW0gYWxsIHRvIHRoZSBzZXQuXG5cbiAgICAgIGFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIobmV3Q2hpbGRTZXQsIHdvcmtJblByb2dyZXNzLFxuICAgICAgLyogbmVlZHNWaXNpYmlsaXR5VG9nZ2xlICovXG4gICAgICBmYWxzZSxcbiAgICAgIC8qIGlzSGlkZGVuICovXG4gICAgICBmYWxzZSk7XG4gICAgICBwb3J0YWxPclJvb3QucGVuZGluZ0NoaWxkcmVuID0gbmV3Q2hpbGRTZXQ7IC8vIFNjaGVkdWxlIGFuIHVwZGF0ZSBvbiB0aGUgY29udGFpbmVyIHRvIHN3YXAgb3V0IHRoZSBjb250YWluZXIuXG5cbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgZmluYWxpemVDb250YWluZXJDaGlsZHJlbihjb250YWluZXIsIG5ld0NoaWxkU2V0KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHlwZSwgbmV3UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBhbiBhbHRlcm5hdGUsIHRoYXQgbWVhbnMgdGhpcyBpcyBhbiB1cGRhdGUgYW5kIHdlIG5lZWQgdG9cbiAgICAvLyBzY2hlZHVsZSBhIHNpZGUtZWZmZWN0IHRvIGRvIHRoZSB1cGRhdGVzLlxuICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcblxuICAgIGlmIChvbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICAgIC8vIEluIG11dGF0aW9uIG1vZGUsIHRoaXMgaXMgc3VmZmljaWVudCBmb3IgYSBiYWlsb3V0IGJlY2F1c2VcbiAgICAgIC8vIHdlIHdvbid0IHRvdWNoIHRoaXMgbm9kZSBldmVuIGlmIGNoaWxkcmVuIGNoYW5nZWQuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gZWxzZSBpZiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAgIHZhciBjdXJyZW50SW5zdGFuY2UgPSBjdXJyZW50LnN0YXRlTm9kZTtcbiAgICB2YXIgX29sZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzOyAvLyBJZiB0aGVyZSBhcmUgbm8gZWZmZWN0cyBhc3NvY2lhdGVkIHdpdGggdGhpcyBub2RlLCB0aGVuIG5vbmUgb2Ygb3VyIGNoaWxkcmVuIGhhZCBhbnkgdXBkYXRlcy5cbiAgICAvLyBUaGlzIGd1YXJhbnRlZXMgdGhhdCB3ZSBjYW4gcmV1c2UgYWxsIG9mIHRoZW0uXG5cbiAgICB2YXIgcmVxdWlyZXNDbG9uZSA9IGRvZXNSZXF1aXJlQ2xvbmUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgaWYgKCFyZXF1aXJlc0Nsb25lICYmIF9vbGRQcm9wcyA9PT0gbmV3UHJvcHMpIHtcbiAgICAgIC8vIE5vIGNoYW5nZXMsIGp1c3QgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlLlxuICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgbWlnaHQgcmVsZWFzZSBhIHByZXZpb3VzIGNsb25lLlxuICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgIHZhciBuZXdDaGlsZFNldCA9IG51bGw7XG5cbiAgICBpZiAocmVxdWlyZXNDbG9uZSAmJiBwYXNzQ2hpbGRyZW5XaGVuQ2xvbmluZ1BlcnNpc3RlZE5vZGVzKSB7XG4gICAgICBuZXdDaGlsZFNldCA9IGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0KCk7IC8vIElmIGNoaWxkcmVuIG1pZ2h0IGhhdmUgY2hhbmdlZCwgd2UgaGF2ZSB0byBhZGQgdGhlbSBhbGwgdG8gdGhlIHNldC5cblxuICAgICAgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lcihuZXdDaGlsZFNldCwgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAvKiBuZWVkc1Zpc2liaWxpdHlUb2dnbGUgKi9cbiAgICAgIGZhbHNlLFxuICAgICAgLyogaXNIaWRkZW4gKi9cbiAgICAgIGZhbHNlKTtcbiAgICB9XG5cbiAgICB2YXIgbmV3SW5zdGFuY2UgPSBjbG9uZUluc3RhbmNlKGN1cnJlbnRJbnN0YW5jZSwgdHlwZSwgX29sZFByb3BzLCBuZXdQcm9wcywgIXJlcXVpcmVzQ2xvbmUsIG5ld0NoaWxkU2V0KTtcblxuICAgIGlmIChuZXdJbnN0YW5jZSA9PT0gY3VycmVudEluc3RhbmNlKSB7XG4gICAgICAvLyBObyBjaGFuZ2VzLCBqdXN0IHJldXNlIHRoZSBleGlzdGluZyBpbnN0YW5jZS5cbiAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIG1pZ2h0IHJlbGVhc2UgYSBwcmV2aW91cyBjbG9uZS5cbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnRJbnN0YW5jZTtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIENlcnRhaW4gcmVuZGVyZXJzIHJlcXVpcmUgY29tbWl0LXRpbWUgZWZmZWN0cyBmb3IgaW5pdGlhbCBtb3VudC5cbiAgICAvLyAoZWcgRE9NIHJlbmRlcmVyIHN1cHBvcnRzIGF1dG8tZm9jdXMgZm9yIGNlcnRhaW4gZWxlbWVudHMpLlxuICAgIC8vIE1ha2Ugc3VyZSBzdWNoIHJlbmRlcmVycyBnZXQgc2NoZWR1bGVkIGZvciBsYXRlciB3b3JrLlxuXG5cbiAgICBpZiAoZmluYWxpemVJbml0aWFsQ2hpbGRyZW4obmV3SW5zdGFuY2UsIHR5cGUsIG5ld1Byb3BzLCBjdXJyZW50SG9zdENvbnRleHQpKSB7XG4gICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBuZXdJbnN0YW5jZTtcblxuICAgIGlmICghcmVxdWlyZXNDbG9uZSkge1xuICAgICAgLy8gSWYgdGhlcmUgYXJlIG5vIG90aGVyIGVmZmVjdHMgaW4gdGhpcyB0cmVlLCB3ZSBuZWVkIHRvIGZsYWcgdGhpcyBub2RlIGFzIGhhdmluZyBvbmUuXG4gICAgICAvLyBFdmVuIHRob3VnaCB3ZSdyZSBub3QgZ29pbmcgdG8gdXNlIGl0IGZvciBhbnl0aGluZy5cbiAgICAgIC8vIE90aGVyd2lzZSBwYXJlbnRzIHdvbid0IGtub3cgdGhhdCB0aGVyZSBhcmUgbmV3IGNoaWxkcmVuIHRvIHByb3BhZ2F0ZSB1cHdhcmRzLlxuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIGNoaWxkcmVuIG1pZ2h0IGhhdmUgY2hhbmdlZCwgd2UgaGF2ZSB0byBhZGQgdGhlbSBhbGwgdG8gdGhlIHNldC5cbiAgICAgIGFwcGVuZEFsbENoaWxkcmVuKG5ld0luc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIC8qIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSAqL1xuICAgICAgZmFsc2UsXG4gICAgICAvKiBpc0hpZGRlbiAqL1xuICAgICAgZmFsc2UpO1xuICAgIH1cbiAgfVxufSAvLyBUaGlzIGZ1bmN0aW9uIG11c3QgYmUgY2FsbGVkIGF0IHRoZSB2ZXJ5IGVuZCBvZiB0aGUgY29tcGxldGUgcGhhc2UsIGJlY2F1c2Vcbi8vIGl0IG1pZ2h0IHRocm93IHRvIHN1c3BlbmQsIGFuZCBpZiB0aGUgcmVzb3VyY2UgaW1tZWRpYXRlbHkgbG9hZHMsIHRoZSB3b3JrXG4vLyBsb29wIHdpbGwgcmVzdW1lIHJlbmRlcmluZyBhcyBpZiB0aGUgd29yay1pbi1wcm9ncmVzcyBjb21wbGV0ZWQuIFNvIGl0IG11c3Rcbi8vIGZ1bGx5IGNvbXBsZXRlLlxuLy8gVE9ETzogVGhpcyBzaG91bGQgaWRlYWxseSBtb3ZlIHRvIGJlZ2luIHBoYXNlLCBidXQgY3VycmVudGx5IHRoZSBpbnN0YW5jZSBpc1xuLy8gbm90IGNyZWF0ZWQgdW50aWwgdGhlIGNvbXBsZXRlIHBoYXNlLiBGb3Igb3VyIGV4aXN0aW5nIHVzZSBjYXNlcywgaG9zdCBub2Rlc1xuLy8gdGhhdCBzdXNwZW5kIGRvbid0IGhhdmUgY2hpbGRyZW4sIHNvIGl0IGRvZXNuJ3QgbWF0dGVyLiBCdXQgdGhhdCBtaWdodCBub3Rcbi8vIGFsd2F5cyBiZSB0cnVlIGluIHRoZSBmdXR1cmUuXG5cblxuZnVuY3Rpb24gcHJlbG9hZEluc3RhbmNlQW5kU3VzcGVuZElmTmVlZGVkKHdvcmtJblByb2dyZXNzLCB0eXBlLCBwcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKCFtYXlTdXNwZW5kQ29tbWl0KHR5cGUsIHByb3BzKSkge1xuICAgIC8vIElmIHRoaXMgZmxhZyB3YXMgc2V0IHByZXZpb3VzbHksIHdlIGNhbiByZW1vdmUgaXQuIFRoZSBmbGFnXG4gICAgLy8gcmVwcmVzZW50cyB3aGV0aGVyIHRoaXMgcGFydGljdWxhciBzZXQgb2YgcHJvcHMgbWlnaHQgZXZlciBuZWVkIHRvXG4gICAgLy8gc3VzcGVuZC4gVGhlIHNhZmVzdCB0aGluZyB0byBkbyBpcyBmb3IgbWF5U3VzcGVuZENvbW1pdCB0byBhbHdheXNcbiAgICAvLyByZXR1cm4gdHJ1ZSwgYnV0IGlmIHRoZSByZW5kZXJlciBpcyByZWFzb25hYmx5IGNvbmZpZGVudCB0aGF0IHRoZVxuICAgIC8vIHVuZGVybHlpbmcgcmVzb3VyY2Ugd29uJ3QgYmUgZXZpY3RlZCwgaXQgY2FuIHJldHVybiBmYWxzZSBhcyBhXG4gICAgLy8gcGVyZm9ybWFuY2Ugb3B0aW1pemF0aW9uLlxuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IH5NYXlTdXNwZW5kQ29tbWl0O1xuICAgIHJldHVybjtcbiAgfSAvLyBNYXJrIHRoaXMgZmliZXIgd2l0aCBhIGZsYWcuIFRoaXMgZ2V0cyBzZXQgb24gYWxsIGhvc3QgaW5zdGFuY2VzXG4gIC8vIHRoYXQgbWlnaHQgcG9zc2libHkgc3VzcGVuZCwgZXZlbiBpZiB0aGV5IGRvbid0IG5lZWQgdG8gc3VzcGVuZFxuICAvLyBjdXJyZW50bHkuIFdlIHVzZSB0aGlzIHdoZW4gcmV2ZWFsaW5nIGEgcHJlcmVuZGVyZWQgdHJlZSwgYmVjYXVzZVxuICAvLyBldmVuIHRob3VnaCB0aGUgdHJlZSBoYXMgXCJtb3VudGVkXCIsIGl0cyByZXNvdXJjZXMgbWlnaHQgbm90IGhhdmVcbiAgLy8gbG9hZGVkIHlldC5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IE1heVN1c3BlbmRDb21taXQ7IC8vIHByZWxvYWQgdGhlIGluc3RhbmNlIGlmIG5lY2Vzc2FyeS4gRXZlbiBpZiB0aGlzIGlzIGFuIHVyZ2VudCByZW5kZXIgdGhlcmVcbiAgLy8gY291bGQgYmUgYmVuZWZpdHMgdG8gcHJlbG9hZGluZyBlYXJseS5cbiAgLy8gQFRPRE8gd2Ugc2hvdWxkIHByb2JhYmx5IGRvIHRoZSBwcmVsb2FkIGluIGJlZ2luIHdvcmtcblxuICB2YXIgaXNSZWFkeSA9IHByZWxvYWRJbnN0YW5jZSh0eXBlLCBwcm9wcyk7XG5cbiAgaWYgKCFpc1JlYWR5KSB7XG4gICAgaWYgKHNob3VsZFJlbWFpbk9uUHJldmlvdXNTY3JlZW4oKSkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU2hvdWxkU3VzcGVuZENvbW1pdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VzcGVuZENvbW1pdCgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmVsb2FkUmVzb3VyY2VBbmRTdXNwZW5kSWZOZWVkZWQod29ya0luUHJvZ3Jlc3MsIHJlc291cmNlLCB0eXBlLCBwcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAgLy8gVGhpcyBpcyBhIGZvcmsgb2YgcHJlbG9hZEluc3RhbmNlQW5kU3VzcGVuZElmTmVlZGVkLCBidXQgZm9yIHJlc291cmNlcy5cbiAgaWYgKCFtYXlSZXNvdXJjZVN1c3BlbmRDb21taXQocmVzb3VyY2UpKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gfk1heVN1c3BlbmRDb21taXQ7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gTWF5U3VzcGVuZENvbW1pdDtcbiAgdmFyIGlzUmVhZHkgPSBwcmVsb2FkUmVzb3VyY2UocmVzb3VyY2UpO1xuXG4gIGlmICghaXNSZWFkeSkge1xuICAgIGlmIChzaG91bGRSZW1haW5PblByZXZpb3VzU2NyZWVuKCkpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNob3VsZFN1c3BlbmRDb21taXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN1c3BlbmRDb21taXQoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVSZXRyeUVmZmVjdCh3b3JrSW5Qcm9ncmVzcywgcmV0cnlRdWV1ZSkge1xuICB2YXIgd2FrZWFibGVzID0gcmV0cnlRdWV1ZTtcblxuICBpZiAod2FrZWFibGVzICE9PSBudWxsKSB7XG4gICAgLy8gU2NoZWR1bGUgYW4gZWZmZWN0IHRvIGF0dGFjaCBhIHJldHJ5IGxpc3RlbmVyIHRvIHRoZSBwcm9taXNlLlxuICAgIC8vIFRPRE86IE1vdmUgdG8gcGFzc2l2ZSBwaGFzZVxuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGJvdW5kYXJ5IHN1c3BlbmRlZCwgYnV0IG5vIHdha2VhYmxlcyB3ZXJlIGFkZGVkIHRvIHRoZSByZXRyeVxuICAgIC8vIHF1ZXVlLiBDaGVjayBpZiB0aGUgcmVuZGVyZXIgc3VzcGVuZGVkIGNvbW1pdC4gSWYgc28sIHRoaXMgbWVhbnNcbiAgICAvLyB0aGF0IG9uY2UgdGhlIGZhbGxiYWNrIGlzIGNvbW1pdHRlZCwgd2UgY2FuIGltbWVkaWF0ZWx5IHJldHJ5XG4gICAgLy8gcmVuZGVyaW5nIGFnYWluLCBiZWNhdXNlIHJlbmRlcmluZyB3YXNuJ3QgYWN0dWFsbHkgYmxvY2tlZC4gT25seVxuICAgIC8vIHRoZSBjb21taXQgcGhhc2UuXG4gICAgLy8gVE9ETzogQ29uc2lkZXIgYSBtb2RlbCB3aGVyZSB3ZSBhbHdheXMgc2NoZWR1bGUgYW4gaW1tZWRpYXRlIHJldHJ5LCBldmVuXG4gICAgLy8gZm9yIG5vcm1hbCBTdXNwZW5zZS4gVGhhdCB3YXkgdGhlIHJldHJ5IGNhbiBwYXJ0aWFsbHkgcmVuZGVyIHVwIHRvIHRoZVxuICAgIC8vIGZpcnN0IHRoaW5nIHRoYXQgc3VzcGVuZHMuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLmZsYWdzICYgU2NoZWR1bGVSZXRyeSkge1xuICAgICAgdmFyIHJldHJ5TGFuZSA9IC8vIFRPRE86IFRoaXMgY2hlY2sgc2hvdWxkIHByb2JhYmx5IGJlIG1vdmVkIGludG8gY2xhaW1OZXh0UmV0cnlMYW5lXG4gICAgICAvLyBJIGFsc28gc3VzcGVjdCB0aGF0IHdlIG5lZWQgc29tZSBmdXJ0aGVyIGNvbnNvbGlkYXRpb24gb2Ygb2Zmc2NyZWVuXG4gICAgICAvLyBhbmQgcmV0cnkgbGFuZXMuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgIT09IE9mZnNjcmVlbkNvbXBvbmVudCA/IGNsYWltTmV4dFJldHJ5TGFuZSgpIDogT2Zmc2NyZWVuTGFuZTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzcy5sYW5lcywgcmV0cnlMYW5lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdFRleHQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG9sZFRleHQsIG5ld1RleHQpIHtcbiAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAvLyBJZiB0aGUgdGV4dCBkaWZmZXJzLCBtYXJrIGl0IGFzIGFuIHVwZGF0ZS4gQWxsIHRoZSB3b3JrIGluIGRvbmUgaW4gY29tbWl0V29yay5cbiAgICBpZiAob2xkVGV4dCAhPT0gbmV3VGV4dCkge1xuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcbiAgICBpZiAob2xkVGV4dCAhPT0gbmV3VGV4dCkge1xuICAgICAgLy8gSWYgdGhlIHRleHQgY29udGVudCBkaWZmZXJzLCB3ZSdsbCBjcmVhdGUgYSBuZXcgdGV4dCBpbnN0YW5jZSBmb3IgaXQuXG4gICAgICB2YXIgcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlVGV4dEluc3RhbmNlKG5ld1RleHQsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7IC8vIFdlJ2xsIGhhdmUgdG8gbWFyayBpdCBhcyBoYXZpbmcgYW4gZWZmZWN0LCBldmVuIHRob3VnaCB3ZSB3b24ndCB1c2UgdGhlIGVmZmVjdCBmb3IgYW55dGhpbmcuXG4gICAgICAvLyBUaGlzIGxldHMgdGhlIHBhcmVudHMga25vdyB0aGF0IGF0IGxlYXN0IG9uZSBvZiB0aGVpciBjaGlsZHJlbiBoYXMgY2hhbmdlZC5cblxuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIGhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjaykge1xuICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgIC8vIElmIHdlJ3JlIGh5ZHJhdGluZywgd2Ugc2hvdWxkIGNvbnN1bWUgYXMgbWFueSBpdGVtcyBhcyB3ZSBjYW5cbiAgICAvLyBzbyB3ZSBkb24ndCBsZWF2ZSBhbnkgYmVoaW5kLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHN3aXRjaCAocmVuZGVyU3RhdGUudGFpbE1vZGUpIHtcbiAgICBjYXNlICdoaWRkZW4nOlxuICAgICAge1xuICAgICAgICAvLyBBbnkgaW5zZXJ0aW9ucyBhdCB0aGUgZW5kIG9mIHRoZSB0YWlsIGxpc3QgYWZ0ZXIgdGhpcyBwb2ludFxuICAgICAgICAvLyBzaG91bGQgYmUgaW52aXNpYmxlLiBJZiB0aGVyZSBhcmUgYWxyZWFkeSBtb3VudGVkIGJvdW5kYXJpZXNcbiAgICAgICAgLy8gYW55dGhpbmcgYmVmb3JlIHRoZW0gYXJlIG5vdCBjb25zaWRlcmVkIGZvciBjb2xsYXBzaW5nLlxuICAgICAgICAvLyBUaGVyZWZvcmUgd2UgbmVlZCB0byBnbyB0aHJvdWdoIHRoZSB3aG9sZSB0YWlsIHRvIGZpbmQgaWZcbiAgICAgICAgLy8gdGhlcmUgYXJlIGFueS5cbiAgICAgICAgdmFyIHRhaWxOb2RlID0gcmVuZGVyU3RhdGUudGFpbDtcbiAgICAgICAgdmFyIGxhc3RUYWlsTm9kZSA9IG51bGw7XG5cbiAgICAgICAgd2hpbGUgKHRhaWxOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHRhaWxOb2RlLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgbGFzdFRhaWxOb2RlID0gdGFpbE5vZGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdGFpbE5vZGUgPSB0YWlsTm9kZS5zaWJsaW5nO1xuICAgICAgICB9IC8vIE5leHQgd2UncmUgc2ltcGx5IGdvaW5nIHRvIGRlbGV0ZSBhbGwgaW5zZXJ0aW9ucyBhZnRlciB0aGVcbiAgICAgICAgLy8gbGFzdCByZW5kZXJlZCBpdGVtLlxuXG5cbiAgICAgICAgaWYgKGxhc3RUYWlsTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIEFsbCByZW1haW5pbmcgaXRlbXMgaW4gdGhlIHRhaWwgYXJlIGluc2VydGlvbnMuXG4gICAgICAgICAgcmVuZGVyU3RhdGUudGFpbCA9IG51bGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRGV0YWNoIHRoZSBpbnNlcnRpb24gYWZ0ZXIgdGhlIGxhc3Qgbm9kZSB0aGF0IHdhcyBhbHJlYWR5XG4gICAgICAgICAgLy8gaW5zZXJ0ZWQuXG4gICAgICAgICAgbGFzdFRhaWxOb2RlLnNpYmxpbmcgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlICdjb2xsYXBzZWQnOlxuICAgICAge1xuICAgICAgICAvLyBBbnkgaW5zZXJ0aW9ucyBhdCB0aGUgZW5kIG9mIHRoZSB0YWlsIGxpc3QgYWZ0ZXIgdGhpcyBwb2ludFxuICAgICAgICAvLyBzaG91bGQgYmUgaW52aXNpYmxlLiBJZiB0aGVyZSBhcmUgYWxyZWFkeSBtb3VudGVkIGJvdW5kYXJpZXNcbiAgICAgICAgLy8gYW55dGhpbmcgYmVmb3JlIHRoZW0gYXJlIG5vdCBjb25zaWRlcmVkIGZvciBjb2xsYXBzaW5nLlxuICAgICAgICAvLyBUaGVyZWZvcmUgd2UgbmVlZCB0byBnbyB0aHJvdWdoIHRoZSB3aG9sZSB0YWlsIHRvIGZpbmQgaWZcbiAgICAgICAgLy8gdGhlcmUgYXJlIGFueS5cbiAgICAgICAgdmFyIF90YWlsTm9kZSA9IHJlbmRlclN0YXRlLnRhaWw7XG4gICAgICAgIHZhciBfbGFzdFRhaWxOb2RlID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAoX3RhaWxOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKF90YWlsTm9kZS5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIF9sYXN0VGFpbE5vZGUgPSBfdGFpbE5vZGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgX3RhaWxOb2RlID0gX3RhaWxOb2RlLnNpYmxpbmc7XG4gICAgICAgIH0gLy8gTmV4dCB3ZSdyZSBzaW1wbHkgZ29pbmcgdG8gZGVsZXRlIGFsbCBpbnNlcnRpb25zIGFmdGVyIHRoZVxuICAgICAgICAvLyBsYXN0IHJlbmRlcmVkIGl0ZW0uXG5cblxuICAgICAgICBpZiAoX2xhc3RUYWlsTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIEFsbCByZW1haW5pbmcgaXRlbXMgaW4gdGhlIHRhaWwgYXJlIGluc2VydGlvbnMuXG4gICAgICAgICAgaWYgKCFoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2sgJiYgcmVuZGVyU3RhdGUudGFpbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gV2Ugc3VzcGVuZGVkIGR1cmluZyB0aGUgaGVhZC4gV2Ugd2FudCB0byBzaG93IGF0IGxlYXN0IG9uZVxuICAgICAgICAgICAgLy8gcm93IGF0IHRoZSB0YWlsLiBTbyB3ZSdsbCBrZWVwIG9uIGFuZCBjdXQgb2ZmIHRoZSByZXN0LlxuICAgICAgICAgICAgcmVuZGVyU3RhdGUudGFpbC5zaWJsaW5nID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVuZGVyU3RhdGUudGFpbCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERldGFjaCB0aGUgaW5zZXJ0aW9uIGFmdGVyIHRoZSBsYXN0IG5vZGUgdGhhdCB3YXMgYWxyZWFkeVxuICAgICAgICAgIC8vIGluc2VydGVkLlxuICAgICAgICAgIF9sYXN0VGFpbE5vZGUuc2libGluZyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBidWJibGVQcm9wZXJ0aWVzKGNvbXBsZXRlZFdvcmspIHtcbiAgdmFyIGRpZEJhaWxvdXQgPSBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZSAhPT0gbnVsbCAmJiBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZS5jaGlsZCA9PT0gY29tcGxldGVkV29yay5jaGlsZDtcbiAgdmFyIG5ld0NoaWxkTGFuZXMgPSBOb0xhbmVzO1xuICB2YXIgc3VidHJlZUZsYWdzID0gTm9GbGFncyQxO1xuXG4gIGlmICghZGlkQmFpbG91dCkge1xuICAgIC8vIEJ1YmJsZSB1cCB0aGUgZWFybGllc3QgZXhwaXJhdGlvbiB0aW1lLlxuICAgIGlmICgoY29tcGxldGVkV29yay5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgIC8vIEluIHByb2ZpbGluZyBtb2RlLCByZXNldENoaWxkRXhwaXJhdGlvblRpbWUgaXMgYWxzbyB1c2VkIHRvIHJlc2V0XG4gICAgICAvLyBwcm9maWxlciBkdXJhdGlvbnMuXG4gICAgICB2YXIgYWN0dWFsRHVyYXRpb24gPSBjb21wbGV0ZWRXb3JrLmFjdHVhbER1cmF0aW9uO1xuICAgICAgdmFyIHRyZWVCYXNlRHVyYXRpb24gPSBjb21wbGV0ZWRXb3JrLnNlbGZCYXNlRHVyYXRpb247XG4gICAgICB2YXIgY2hpbGQgPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbmV3Q2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMobmV3Q2hpbGRMYW5lcywgbWVyZ2VMYW5lcyhjaGlsZC5sYW5lcywgY2hpbGQuY2hpbGRMYW5lcykpO1xuICAgICAgICBzdWJ0cmVlRmxhZ3MgfD0gY2hpbGQuc3VidHJlZUZsYWdzO1xuICAgICAgICBzdWJ0cmVlRmxhZ3MgfD0gY2hpbGQuZmxhZ3M7IC8vIFdoZW4gYSBmaWJlciBpcyBjbG9uZWQsIGl0cyBhY3R1YWxEdXJhdGlvbiBpcyByZXNldCB0byAwLiBUaGlzIHZhbHVlIHdpbGxcbiAgICAgICAgLy8gb25seSBiZSB1cGRhdGVkIGlmIHdvcmsgaXMgZG9uZSBvbiB0aGUgZmliZXIgKGkuZS4gaXQgZG9lc24ndCBiYWlsb3V0KS5cbiAgICAgICAgLy8gV2hlbiB3b3JrIGlzIGRvbmUsIGl0IHNob3VsZCBidWJibGUgdG8gdGhlIHBhcmVudCdzIGFjdHVhbER1cmF0aW9uLiBJZlxuICAgICAgICAvLyB0aGUgZmliZXIgaGFzIG5vdCBiZWVuIGNsb25lZCB0aG91Z2gsIChtZWFuaW5nIG5vIHdvcmsgd2FzIGRvbmUpLCB0aGVuXG4gICAgICAgIC8vIHRoaXMgdmFsdWUgd2lsbCByZWZsZWN0IHRoZSBhbW91bnQgb2YgdGltZSBzcGVudCB3b3JraW5nIG9uIGEgcHJldmlvdXNcbiAgICAgICAgLy8gcmVuZGVyLiBJbiB0aGF0IGNhc2UgaXQgc2hvdWxkIG5vdCBidWJibGUuIFdlIGRldGVybWluZSB3aGV0aGVyIGl0IHdhc1xuICAgICAgICAvLyBjbG9uZWQgYnkgY29tcGFyaW5nIHRoZSBjaGlsZCBwb2ludGVyLlxuICAgICAgICAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hZGRpdGlvbl0gYWRkaXRpb24gd2l0aCBwb3NzaWJsZSBudWxsL3VuZGVmaW5lZCB2YWx1ZVxuXG4gICAgICAgIGFjdHVhbER1cmF0aW9uICs9IGNoaWxkLmFjdHVhbER1cmF0aW9uOyAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hZGRpdGlvbl0gYWRkaXRpb24gd2l0aCBwb3NzaWJsZSBudWxsL3VuZGVmaW5lZCB2YWx1ZVxuXG4gICAgICAgIHRyZWVCYXNlRHVyYXRpb24gKz0gY2hpbGQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBjb21wbGV0ZWRXb3JrLmFjdHVhbER1cmF0aW9uID0gYWN0dWFsRHVyYXRpb247XG4gICAgICBjb21wbGV0ZWRXb3JrLnRyZWVCYXNlRHVyYXRpb24gPSB0cmVlQmFzZUR1cmF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2NoaWxkID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICAgICAgd2hpbGUgKF9jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBuZXdDaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhuZXdDaGlsZExhbmVzLCBtZXJnZUxhbmVzKF9jaGlsZC5sYW5lcywgX2NoaWxkLmNoaWxkTGFuZXMpKTtcbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IF9jaGlsZC5zdWJ0cmVlRmxhZ3M7XG4gICAgICAgIHN1YnRyZWVGbGFncyB8PSBfY2hpbGQuZmxhZ3M7IC8vIFVwZGF0ZSB0aGUgcmV0dXJuIHBvaW50ZXIgc28gdGhlIHRyZWUgaXMgY29uc2lzdGVudC4gVGhpcyBpcyBhIGNvZGVcbiAgICAgICAgLy8gc21lbGwgYmVjYXVzZSBpdCBhc3N1bWVzIHRoZSBjb21taXQgcGhhc2UgaXMgbmV2ZXIgY29uY3VycmVudCB3aXRoXG4gICAgICAgIC8vIHRoZSByZW5kZXIgcGhhc2UuIFdpbGwgYWRkcmVzcyBkdXJpbmcgcmVmYWN0b3IgdG8gYWx0ZXJuYXRlIG1vZGVsLlxuXG4gICAgICAgIF9jaGlsZC5yZXR1cm4gPSBjb21wbGV0ZWRXb3JrO1xuICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wbGV0ZWRXb3JrLnN1YnRyZWVGbGFncyB8PSBzdWJ0cmVlRmxhZ3M7XG4gIH0gZWxzZSB7XG4gICAgLy8gQnViYmxlIHVwIHRoZSBlYXJsaWVzdCBleHBpcmF0aW9uIHRpbWUuXG4gICAgaWYgKChjb21wbGV0ZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgLy8gSW4gcHJvZmlsaW5nIG1vZGUsIHJlc2V0Q2hpbGRFeHBpcmF0aW9uVGltZSBpcyBhbHNvIHVzZWQgdG8gcmVzZXRcbiAgICAgIC8vIHByb2ZpbGVyIGR1cmF0aW9ucy5cbiAgICAgIHZhciBfdHJlZUJhc2VEdXJhdGlvbiA9IGNvbXBsZXRlZFdvcmsuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICAgIHZhciBfY2hpbGQyID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICAgICAgd2hpbGUgKF9jaGlsZDIgIT09IG51bGwpIHtcbiAgICAgICAgbmV3Q2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMobmV3Q2hpbGRMYW5lcywgbWVyZ2VMYW5lcyhfY2hpbGQyLmxhbmVzLCBfY2hpbGQyLmNoaWxkTGFuZXMpKTsgLy8gXCJTdGF0aWNcIiBmbGFncyBzaGFyZSB0aGUgbGlmZXRpbWUgb2YgdGhlIGZpYmVyL2hvb2sgdGhleSBiZWxvbmcgdG8sXG4gICAgICAgIC8vIHNvIHdlIHNob3VsZCBidWJibGUgdGhvc2UgdXAgZXZlbiBkdXJpbmcgYSBiYWlsb3V0LiBBbGwgdGhlIG90aGVyXG4gICAgICAgIC8vIGZsYWdzIGhhdmUgYSBsaWZldGltZSBvbmx5IG9mIGEgc2luZ2xlIHJlbmRlciArIGNvbW1pdCwgc28gd2Ugc2hvdWxkXG4gICAgICAgIC8vIGlnbm9yZSB0aGVtLlxuXG4gICAgICAgIHN1YnRyZWVGbGFncyB8PSBfY2hpbGQyLnN1YnRyZWVGbGFncyAmIFN0YXRpY01hc2s7XG4gICAgICAgIHN1YnRyZWVGbGFncyB8PSBfY2hpbGQyLmZsYWdzICYgU3RhdGljTWFzazsgLy8gJEZsb3dGaXhNZVt1bnNhZmUtYWRkaXRpb25dIGFkZGl0aW9uIHdpdGggcG9zc2libGUgbnVsbC91bmRlZmluZWQgdmFsdWVcblxuICAgICAgICBfdHJlZUJhc2VEdXJhdGlvbiArPSBfY2hpbGQyLnRyZWVCYXNlRHVyYXRpb247XG4gICAgICAgIF9jaGlsZDIgPSBfY2hpbGQyLnNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIGNvbXBsZXRlZFdvcmsudHJlZUJhc2VEdXJhdGlvbiA9IF90cmVlQmFzZUR1cmF0aW9uO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgX2NoaWxkMyA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChfY2hpbGQzICE9PSBudWxsKSB7XG4gICAgICAgIG5ld0NoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKG5ld0NoaWxkTGFuZXMsIG1lcmdlTGFuZXMoX2NoaWxkMy5sYW5lcywgX2NoaWxkMy5jaGlsZExhbmVzKSk7IC8vIFwiU3RhdGljXCIgZmxhZ3Mgc2hhcmUgdGhlIGxpZmV0aW1lIG9mIHRoZSBmaWJlci9ob29rIHRoZXkgYmVsb25nIHRvLFxuICAgICAgICAvLyBzbyB3ZSBzaG91bGQgYnViYmxlIHRob3NlIHVwIGV2ZW4gZHVyaW5nIGEgYmFpbG91dC4gQWxsIHRoZSBvdGhlclxuICAgICAgICAvLyBmbGFncyBoYXZlIGEgbGlmZXRpbWUgb25seSBvZiBhIHNpbmdsZSByZW5kZXIgKyBjb21taXQsIHNvIHdlIHNob3VsZFxuICAgICAgICAvLyBpZ25vcmUgdGhlbS5cblxuICAgICAgICBzdWJ0cmVlRmxhZ3MgfD0gX2NoaWxkMy5zdWJ0cmVlRmxhZ3MgJiBTdGF0aWNNYXNrO1xuICAgICAgICBzdWJ0cmVlRmxhZ3MgfD0gX2NoaWxkMy5mbGFncyAmIFN0YXRpY01hc2s7IC8vIFVwZGF0ZSB0aGUgcmV0dXJuIHBvaW50ZXIgc28gdGhlIHRyZWUgaXMgY29uc2lzdGVudC4gVGhpcyBpcyBhIGNvZGVcbiAgICAgICAgLy8gc21lbGwgYmVjYXVzZSBpdCBhc3N1bWVzIHRoZSBjb21taXQgcGhhc2UgaXMgbmV2ZXIgY29uY3VycmVudCB3aXRoXG4gICAgICAgIC8vIHRoZSByZW5kZXIgcGhhc2UuIFdpbGwgYWRkcmVzcyBkdXJpbmcgcmVmYWN0b3IgdG8gYWx0ZXJuYXRlIG1vZGVsLlxuXG4gICAgICAgIF9jaGlsZDMucmV0dXJuID0gY29tcGxldGVkV29yaztcbiAgICAgICAgX2NoaWxkMyA9IF9jaGlsZDMuc2libGluZztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb21wbGV0ZWRXb3JrLnN1YnRyZWVGbGFncyB8PSBzdWJ0cmVlRmxhZ3M7XG4gIH1cblxuICBjb21wbGV0ZWRXb3JrLmNoaWxkTGFuZXMgPSBuZXdDaGlsZExhbmVzO1xuICByZXR1cm4gZGlkQmFpbG91dDtcbn1cblxuZnVuY3Rpb24gY29tcGxldGVEZWh5ZHJhdGVkU3VzcGVuc2VCb3VuZGFyeShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dFN0YXRlKSB7XG4gIHZhciB3YXNIeWRyYXRlZCA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcblxuICBpZiAobmV4dFN0YXRlICE9PSBudWxsICYmIG5leHRTdGF0ZS5kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG4gICAgLy8gV2UgbWlnaHQgYmUgaW5zaWRlIGEgaHlkcmF0aW9uIHN0YXRlIHRoZSBmaXJzdCB0aW1lIHdlJ3JlIHBpY2tpbmcgdXAgdGhpc1xuICAgIC8vIFN1c3BlbnNlIGJvdW5kYXJ5LCBhbmQgYWxzbyBhZnRlciB3ZSd2ZSByZWVudGVyZWQgaXQgZm9yIGZ1cnRoZXIgaHlkcmF0aW9uLlxuICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICBpZiAoIXdhc0h5ZHJhdGVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQSBkZWh5ZHJhdGVkIHN1c3BlbnNlIGNvbXBvbmVudCB3YXMgY29tcGxldGVkIHdpdGhvdXQgYSBoeWRyYXRlZCBub2RlLiAnICsgJ1RoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG5cbiAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0U3VzcGVuc2VJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAge1xuICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICAgIHZhciBpc1RpbWVkT3V0U3VzcGVuc2UgPSBuZXh0U3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgICBpZiAoaXNUaW1lZE91dFN1c3BlbnNlKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBjb3VudCB0aW1lIHNwZW50IGluIGEgdGltZWQgb3V0IFN1c3BlbnNlIHN1YnRyZWUgYXMgcGFydCBvZiB0aGUgYmFzZSBkdXJhdGlvbi5cbiAgICAgICAgICAgIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG4gICAgICAgICAgICBpZiAocHJpbWFyeUNoaWxkRnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gJEZsb3dGaXhNZVt1bnNhZmUtYXJpdGhtZXRpY10gRmxvdyBkb2Vzbid0IHN1cHBvcnQgdHlwZSBjYXN0aW5nIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlIC09IG9wZXJhdG9yXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gLT0gcHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0UGVuZGluZ0h5ZHJhdGlvbldhcm5pbmdzKCk7IC8vIFdlIG1pZ2h0IGhhdmUgcmVlbnRlcmVkIHRoaXMgYm91bmRhcnkgdG8gaHlkcmF0ZSBpdC4gSWYgc28sIHdlIG5lZWQgdG8gcmVzZXQgdGhlIGh5ZHJhdGlvblxuICAgICAgLy8gc3RhdGUgc2luY2Ugd2UncmUgbm93IGV4aXRpbmcgb3V0IG9mIGl0LiBwb3BIeWRyYXRpb25TdGF0ZSBkb2Vzbid0IGRvIHRoYXQgZm9yIHVzLlxuXG4gICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG5cbiAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gTm9GbGFncyQxKSB7XG4gICAgICAgIC8vIFRoaXMgYm91bmRhcnkgZGlkIG5vdCBzdXNwZW5kIHNvIGl0J3Mgbm93IGh5ZHJhdGVkIGFuZCB1bnN1c3BlbmRlZC5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICB9IC8vIElmIG5vdGhpbmcgc3VzcGVuZGVkLCB3ZSBuZWVkIHRvIHNjaGVkdWxlIGFuIGVmZmVjdCB0byBtYXJrIHRoaXMgYm91bmRhcnlcbiAgICAgIC8vIGFzIGhhdmluZyBoeWRyYXRlZCBzbyBldmVudHMga25vdyB0aGF0IHRoZXkncmUgZnJlZSB0byBiZSBpbnZva2VkLlxuICAgICAgLy8gSXQncyBhbHNvIGEgc2lnbmFsIHRvIHJlcGxheSBldmVudHMgYW5kIHRoZSBzdXNwZW5zZSBjYWxsYmFjay5cbiAgICAgIC8vIElmIHNvbWV0aGluZyBzdXNwZW5kZWQsIHNjaGVkdWxlIGFuIGVmZmVjdCB0byBhdHRhY2ggcmV0cnkgbGlzdGVuZXJzLlxuICAgICAgLy8gU28gd2UgbWlnaHQgYXMgd2VsbCBhbHdheXMgbWFyayB0aGlzLlxuXG5cbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICB7XG4gICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgdmFyIF9pc1RpbWVkT3V0U3VzcGVuc2UgPSBuZXh0U3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgICBpZiAoX2lzVGltZWRPdXRTdXNwZW5zZSkge1xuICAgICAgICAgICAgLy8gRG9uJ3QgY291bnQgdGltZSBzcGVudCBpbiBhIHRpbWVkIG91dCBTdXNwZW5zZSBzdWJ0cmVlIGFzIHBhcnQgb2YgdGhlIGJhc2UgZHVyYXRpb24uXG4gICAgICAgICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICAgICAgICAgIGlmIChfcHJpbWFyeUNoaWxkRnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gJEZsb3dGaXhNZVt1bnNhZmUtYXJpdGhtZXRpY10gRmxvdyBkb2Vzbid0IHN1cHBvcnQgdHlwZSBjYXN0aW5nIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlIC09IG9wZXJhdG9yXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gLT0gX3ByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gU3VjY2Vzc2Z1bGx5IGNvbXBsZXRlZCB0aGlzIHRyZWUuIElmIHRoaXMgd2FzIGEgZm9yY2VkIGNsaWVudCByZW5kZXIsXG4gICAgLy8gdGhlcmUgbWF5IGhhdmUgYmVlbiByZWNvdmVyYWJsZSBlcnJvcnMgZHVyaW5nIGZpcnN0IGh5ZHJhdGlvblxuICAgIC8vIGF0dGVtcHQuIElmIHNvLCBhZGQgdGhlbSB0byBhIHF1ZXVlIHNvIHdlIGNhbiBsb2cgdGhlbSBpbiB0aGVcbiAgICAvLyBjb21taXQgcGhhc2UuXG4gICAgdXBncmFkZUh5ZHJhdGlvbkVycm9yc1RvUmVjb3ZlcmFibGUoKTsgLy8gRmFsbCB0aHJvdWdoIHRvIG5vcm1hbCBTdXNwZW5zZSBwYXRoXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21wbGV0ZVdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXdQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wczsgLy8gTm90ZTogVGhpcyBpbnRlbnRpb25hbGx5IGRvZXNuJ3QgY2hlY2sgaWYgd2UncmUgaHlkcmF0aW5nIGJlY2F1c2UgY29tcGFyaW5nXG4gIC8vIHRvIHRoZSBjdXJyZW50IHRyZWUgcHJvdmlkZXIgZmliZXIgaXMganVzdCBhcyBmYXN0IGFuZCBsZXNzIGVycm9yLXByb25lLlxuICAvLyBJZGVhbGx5IHdlIHdvdWxkIGhhdmUgYSBzcGVjaWFsIHZlcnNpb24gb2YgdGhlIHdvcmsgbG9vcCBvbmx5XG4gIC8vIGZvciBoeWRyYXRpb24uXG5cbiAgcG9wVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSBJbmNvbXBsZXRlRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSAvLyBGYWxsdGhyb3VnaFxuXG4gICAgICB9XG5cbiAgICBjYXNlIExhenlDb21wb25lbnQ6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgRnJhZ21lbnQ6XG4gICAgY2FzZSBNb2RlOlxuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgY2FzZSBDb250ZXh0Q29uc3VtZXI6XG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGZpYmVyUm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzQ2FjaGUgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHByZXZpb3VzQ2FjaGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGNhY2hlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZS5jYWNoZTtcblxuICAgICAgICAgIGlmIChjYWNoZSAhPT0gcHJldmlvdXNDYWNoZSkge1xuICAgICAgICAgICAgLy8gUnVuIHBhc3NpdmUgZWZmZWN0cyB0byByZXRhaW4vcmVsZWFzZSB0aGUgY2FjaGUuXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQYXNzaXZlJDE7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcG9wQ2FjaGVQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgaWYgKGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCkge1xuICAgICAgICAgIGZpYmVyUm9vdC5jb250ZXh0ID0gZmliZXJSb290LnBlbmRpbmdDb250ZXh0O1xuICAgICAgICAgIGZpYmVyUm9vdC5wZW5kaW5nQ29udGV4dCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LmNoaWxkID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gSWYgd2UgaHlkcmF0ZWQsIHBvcCBzbyB0aGF0IHdlIGNhbiBkZWxldGUgYW55IHJlbWFpbmluZyBjaGlsZHJlblxuICAgICAgICAgIC8vIHRoYXQgd2VyZW4ndCBoeWRyYXRlZC5cbiAgICAgICAgICB2YXIgd2FzSHlkcmF0ZWQgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICBpZiAod2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgIGVtaXRQZW5kaW5nSHlkcmF0aW9uV2FybmluZ3MoKTsgLy8gSWYgd2UgaHlkcmF0ZWQsIHRoZW4gd2UnbGwgbmVlZCB0byBzY2hlZHVsZSBhbiB1cGRhdGUgZm9yXG4gICAgICAgICAgICAvLyB0aGUgY29tbWl0IHNpZGUtZWZmZWN0cyBvbiB0aGUgcm9vdC5cblxuICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgICAgICAgaWYgKCAvLyBDaGVjayBpZiB0aGlzIGlzIGEgY2xpZW50IHJvb3RcbiAgICAgICAgICAgICAgIXByZXZTdGF0ZS5pc0RlaHlkcmF0ZWQgfHwgLy8gQ2hlY2sgaWYgd2UgcmV2ZXJ0ZWQgdG8gY2xpZW50IHJlbmRlcmluZyAoZS5nLiBkdWUgdG8gYW4gZXJyb3IpXG4gICAgICAgICAgICAgICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIEZvcmNlQ2xpZW50UmVuZGVyKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgICAgICAgLy8gU2NoZWR1bGUgYW4gZWZmZWN0IHRvIGNsZWFyIHRoaXMgY29udGFpbmVyIGF0IHRoZSBzdGFydCBvZiB0aGVcbiAgICAgICAgICAgICAgICAvLyBuZXh0IGNvbW1pdC4gVGhpcyBoYW5kbGVzIHRoZSBjYXNlIG9mIFJlYWN0IHJlbmRlcmluZyBpbnRvIGFcbiAgICAgICAgICAgICAgICAvLyBjb250YWluZXIgd2l0aCBwcmV2aW91cyBjaGlsZHJlbi4gSXQncyBhbHNvIHNhZmUgdG8gZG8gZm9yXG4gICAgICAgICAgICAgICAgLy8gdXBkYXRlcyB0b28sIGJlY2F1c2UgY3VycmVudC5jaGlsZCB3b3VsZCBvbmx5IGJlIG51bGwgaWYgdGhlXG4gICAgICAgICAgICAgICAgLy8gcHJldmlvdXMgcmVuZGVyIHdhcyBudWxsIChzbyB0aGUgY29udGFpbmVyIHdvdWxkIGFscmVhZHlcbiAgICAgICAgICAgICAgICAvLyBiZSBlbXB0eSkuXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU25hcHNob3Q7IC8vIElmIHRoaXMgd2FzIGEgZm9yY2VkIGNsaWVudCByZW5kZXIsIHRoZXJlIG1heSBoYXZlIGJlZW5cbiAgICAgICAgICAgICAgICAvLyByZWNvdmVyYWJsZSBlcnJvcnMgZHVyaW5nIGZpcnN0IGh5ZHJhdGlvbiBhdHRlbXB0LiBJZiBzbywgYWRkXG4gICAgICAgICAgICAgICAgLy8gdGhlbSB0byBhIHF1ZXVlIHNvIHdlIGNhbiBsb2cgdGhlbSBpbiB0aGUgY29tbWl0IHBoYXNlLlxuXG4gICAgICAgICAgICAgICAgdXBncmFkZUh5ZHJhdGlvbkVycm9yc1RvUmVjb3ZlcmFibGUoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdEhvaXN0YWJsZTpcbiAgICAgIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzUmVzb3VyY2VzKSB7XG4gICAgICAgICAgLy8gVGhlIGJyYW5jaGluZyBoZXJlIGlzIG1vcmUgY29tcGxpY2F0ZWQgdGhhbiB5b3UgbWlnaHQgZXhwZWN0IGJlY2F1c2VcbiAgICAgICAgICAvLyBhIEhvc3RIb2lzdGFibGUgc29tZXRpbWVzIGNvcnJlc3BvbmRzIHRvIGEgUmVzb3VyY2UgYW5kIHNvbWV0aW1lc1xuICAgICAgICAgIC8vIGNvcnJlc3BvbmRzIHRvIGFuIEluc3RhbmNlLiBJdCBjYW4gYWxzbyBzd2l0Y2ggZHVyaW5nIGFuIHVwZGF0ZS5cbiAgICAgICAgICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgICAgdmFyIG5leHRSZXNvdXJjZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gV2UgYXJlIG1vdW50aW5nIGFuZCBtdXN0IFVwZGF0ZSB0aGlzIEhvaXN0YWJsZSBpbiB0aGlzIGNvbW1pdFxuICAgICAgICAgICAgLy8gQFRPRE8gcmVmYWN0b3IgdGhpcyBibG9jayB0byBjcmVhdGUgdGhlIGluc3RhbmNlIGhlcmUgaW4gY29tcGxldGVcbiAgICAgICAgICAgIC8vIHBoYXNlIGlmIHdlIGFyZSBub3QgaHlkcmF0aW5nLlxuICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICAgIGlmIChuZXh0UmVzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIEhvaXN0YWJsZSBSZXNvdXJjZVxuICAgICAgICAgICAgICAvLyBUaGlzIG11c3QgY29tZSBhdCB0aGUgdmVyeSBlbmQgb2YgdGhlIGNvbXBsZXRlIHBoYXNlLlxuICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgcHJlbG9hZFJlc291cmNlQW5kU3VzcGVuZElmTmVlZGVkKHdvcmtJblByb2dyZXNzLCBuZXh0UmVzb3VyY2UpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBIb2lzdGFibGUgSW5zdGFuY2VcbiAgICAgICAgICAgICAgLy8gVGhpcyBtdXN0IGNvbWUgYXQgdGhlIHZlcnkgZW5kIG9mIHRoZSBjb21wbGV0ZSBwaGFzZS5cbiAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgIHByZWxvYWRJbnN0YW5jZUFuZFN1c3BlbmRJZk5lZWRlZCh3b3JrSW5Qcm9ncmVzcywgdHlwZSwgbmV3UHJvcHMpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UgYXJlIHVwZGF0aW5nLlxuICAgICAgICAgICAgdmFyIGN1cnJlbnRSZXNvdXJjZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICAgICAgaWYgKG5leHRSZXNvdXJjZSAhPT0gY3VycmVudFJlc291cmNlKSB7XG4gICAgICAgICAgICAgIC8vIFdlIGFyZSB0cmFuc2l0aW9uaW5nIHRvLCBmcm9tLCBvciBiZXR3ZWVuIEhvaXN0YWJsZSBSZXNvdXJjZXNcbiAgICAgICAgICAgICAgLy8gYW5kIHJlcXVpcmUgYW4gdXBkYXRlXG4gICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobmV4dFJlc291cmNlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBIb2lzdGFibGUgUmVzb3VyY2VcbiAgICAgICAgICAgICAgLy8gVGhpcyBtdXN0IGNvbWUgYXQgdGhlIHZlcnkgZW5kIG9mIHRoZSBjb21wbGV0ZSBwaGFzZS5cbiAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICAgICAgaWYgKG5leHRSZXNvdXJjZSA9PT0gY3VycmVudFJlc291cmNlKSB7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gfk1heVN1c3BlbmRDb21taXQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJlbG9hZFJlc291cmNlQW5kU3VzcGVuZElmTmVlZGVkKHdvcmtJblByb2dyZXNzLCBuZXh0UmVzb3VyY2UpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgSG9pc3RhYmxlIEluc3RhbmNlXG4gICAgICAgICAgICAgIC8vIFdlIG1heSBoYXZlIHByb3BzIHRvIHVwZGF0ZSBvbiB0aGUgSG9pc3RhYmxlIGluc3RhbmNlLlxuICAgICAgICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgICAgICAgICAgICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcblxuICAgICAgICAgICAgICAgIGlmIChvbGRQcm9wcyAhPT0gbmV3UHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSB1c2UgdGhlIHVwZGF0ZUhvc3RDb21wb25lbnQgcGF0aCBiZWN1YXNlIGl0IHByb2R1Y2VzXG4gICAgICAgICAgICAgICAgLy8gdGhlIHVwZGF0ZSBxdWV1ZSB3ZSBuZWVkIGZvciBIb2lzdGFibGVzLlxuICAgICAgICAgICAgICAgIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHR5cGUsIG5ld1Byb3BzKTtcbiAgICAgICAgICAgICAgfSAvLyBUaGlzIG11c3QgY29tZSBhdCB0aGUgdmVyeSBlbmQgb2YgdGhlIGNvbXBsZXRlIHBoYXNlLlxuXG5cbiAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgIHByZWxvYWRJbnN0YW5jZUFuZFN1c3BlbmRJZk5lZWRlZCh3b3JrSW5Qcm9ncmVzcywgdHlwZSwgbmV3UHJvcHMpO1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gRmFsbCB0aHJvdWdoXG5cbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICAgIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzU2luZ2xldG9ucykge1xuICAgICAgICAgIHBvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB2YXIgcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICAgICAgICB2YXIgX3R5cGUgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgICAgICAgICAgIHZhciBfb2xkUHJvcHMyID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuXG4gICAgICAgICAgICAgIGlmIChfb2xkUHJvcHMyICE9PSBuZXdQcm9wcykge1xuICAgICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfdHlwZSwgbmV3UHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoIW5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5ICcgKyAnY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgICAgICAgfSAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuXG5cbiAgICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcblxuICAgICAgICAgICAgdmFyIF93YXNIeWRyYXRlZCA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgdmFyIGluc3RhbmNlO1xuXG4gICAgICAgICAgICBpZiAoX3dhc0h5ZHJhdGVkKSB7XG4gICAgICAgICAgICAgIC8vIFdlIGlnbm9yZSB0aGUgYm9vbGVhbiBpbmRpY2F0aW5nIHRoZXJlIGlzIGFuIHVwZGF0ZVF1ZXVlIGJlY2F1c2VcbiAgICAgICAgICAgICAgLy8gaXQgaXMgdXNlZCBvbmx5IHRvIHNldCB0ZXh0IGNoaWxkcmVuIGFuZCBIb3N0U2luZ2xldG9ucyBkbyBub3RcbiAgICAgICAgICAgICAgLy8gdXNlIHRoZW0uXG4gICAgICAgICAgICAgIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnRIb3N0Q29udGV4dCk7XG4gICAgICAgICAgICAgIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaW5zdGFuY2UgPSByZXNvbHZlU2luZ2xldG9uSW5zdGFuY2UoX3R5cGUsIG5ld1Byb3BzLCByb290Q29udGFpbmVySW5zdGFuY2UsIGN1cnJlbnRIb3N0Q29udGV4dCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSAvLyBGYWxsIHRocm91Z2hcblxuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHZhciBfdHlwZTIgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuXG4gICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX3R5cGUyLCBuZXdQcm9wcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFuZXdQcm9wcykge1xuICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5ICcgKyAnY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgICAgIH0gLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gd2UgYWJvcnQgd29yay5cblxuXG4gICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTsgLy8gVE9ETzogTW92ZSBjcmVhdGVJbnN0YW5jZSB0byBiZWdpbldvcmsgYW5kIGtlZXAgaXQgb24gYSBjb250ZXh0XG4gICAgICAgICAgLy8gXCJzdGFja1wiIGFzIHRoZSBwYXJlbnQuIFRoZW4gYXBwZW5kIGNoaWxkcmVuIGFzIHdlIGdvIGluIGJlZ2luV29ya1xuICAgICAgICAgIC8vIG9yIGNvbXBsZXRlV29yayBkZXBlbmRpbmcgb24gd2hldGhlciB3ZSB3YW50IHRvIGFkZCB0aGVtIHRvcC0+ZG93biBvclxuICAgICAgICAgIC8vIGJvdHRvbS0+dXAuIFRvcC0+ZG93biBpcyBmYXN0ZXIgaW4gSUUxMS5cblxuXG4gICAgICAgICAgdmFyIF93YXNIeWRyYXRlZDIgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICBpZiAoX3dhc0h5ZHJhdGVkMikge1xuICAgICAgICAgICAgLy8gVE9ETzogTW92ZSB0aGlzIGFuZCBjcmVhdGVJbnN0YW5jZSBzdGVwIGludG8gdGhlIGJlZ2luUGhhc2VcbiAgICAgICAgICAgIC8vIHRvIGNvbnNvbGlkYXRlLlxuICAgICAgICAgICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgX2N1cnJlbnRIb3N0Q29udGV4dCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBfcm9vdENvbnRhaW5lckluc3RhbmNlID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcblxuICAgICAgICAgICAgdmFyIF9pbnN0YW5jZTMgPSBjcmVhdGVJbnN0YW5jZShfdHlwZTIsIG5ld1Byb3BzLCBfcm9vdENvbnRhaW5lckluc3RhbmNlLCBfY3VycmVudEhvc3RDb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7IC8vIFRPRE86IEZvciBwZXJzaXN0ZW50IHJlbmRlcmVycywgd2Ugc2hvdWxkIHBhc3MgY2hpbGRyZW4gYXMgcGFydFxuICAgICAgICAgICAgLy8gb2YgdGhlIGluaXRpYWwgaW5zdGFuY2UgY3JlYXRpb25cblxuXG4gICAgICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihfaW5zdGFuY2UzLCB3b3JrSW5Qcm9ncmVzcywgZmFsc2UsIGZhbHNlKTtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IF9pbnN0YW5jZTM7IC8vIENlcnRhaW4gcmVuZGVyZXJzIHJlcXVpcmUgY29tbWl0LXRpbWUgZWZmZWN0cyBmb3IgaW5pdGlhbCBtb3VudC5cbiAgICAgICAgICAgIC8vIChlZyBET00gcmVuZGVyZXIgc3VwcG9ydHMgYXV0by1mb2N1cyBmb3IgY2VydGFpbiBlbGVtZW50cykuXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgc3VjaCByZW5kZXJlcnMgZ2V0IHNjaGVkdWxlZCBmb3IgbGF0ZXIgd29yay5cblxuICAgICAgICAgICAgaWYgKGZpbmFsaXplSW5pdGlhbENoaWxkcmVuKF9pbnN0YW5jZTMsIF90eXBlMiwgbmV3UHJvcHMsIF9jdXJyZW50SG9zdENvbnRleHQpKSB7XG4gICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpOyAvLyBUaGlzIG11c3QgY29tZSBhdCB0aGUgdmVyeSBlbmQgb2YgdGhlIGNvbXBsZXRlIHBoYXNlLCBiZWNhdXNlIGl0IG1pZ2h0XG4gICAgICAgIC8vIHRocm93IHRvIHN1c3BlbmQsIGFuZCBpZiB0aGUgcmVzb3VyY2UgaW1tZWRpYXRlbHkgbG9hZHMsIHRoZSB3b3JrIGxvb3BcbiAgICAgICAgLy8gd2lsbCByZXN1bWUgcmVuZGVyaW5nIGFzIGlmIHRoZSB3b3JrLWluLXByb2dyZXNzIGNvbXBsZXRlZC4gU28gaXQgbXVzdFxuICAgICAgICAvLyBmdWxseSBjb21wbGV0ZS5cblxuICAgICAgICBwcmVsb2FkSW5zdGFuY2VBbmRTdXNwZW5kSWZOZWVkZWQod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnR5cGUsIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHtcbiAgICAgICAgdmFyIG5ld1RleHQgPSBuZXdQcm9wcztcblxuICAgICAgICBpZiAoY3VycmVudCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBvbGRUZXh0ID0gY3VycmVudC5tZW1vaXplZFByb3BzOyAvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZFxuICAgICAgICAgIC8vIHRvIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG5cbiAgICAgICAgICB1cGRhdGVIb3N0VGV4dChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuZXdUZXh0ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlIG11c3QgaGF2ZSBuZXcgcHJvcHMgZm9yIG5ldyBtb3VudHMuIFRoaXMgZXJyb3IgaXMgbGlrZWx5ICcgKyAnY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgICAgIH0gLy8gVGhpcyBjYW4gaGFwcGVuIHdoZW4gd2UgYWJvcnQgd29yay5cblxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfcm9vdENvbnRhaW5lckluc3RhbmNlMiA9IGdldFJvb3RIb3N0Q29udGFpbmVyKCk7XG5cbiAgICAgICAgICB2YXIgX2N1cnJlbnRIb3N0Q29udGV4dDIgPSBnZXRIb3N0Q29udGV4dCgpO1xuXG4gICAgICAgICAgdmFyIF93YXNIeWRyYXRlZDMgPSBwb3BIeWRyYXRpb25TdGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgICAgICBpZiAoX3dhc0h5ZHJhdGVkMykge1xuICAgICAgICAgICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjcmVhdGVUZXh0SW5zdGFuY2UobmV3VGV4dCwgX3Jvb3RDb250YWluZXJJbnN0YW5jZTIsIF9jdXJyZW50SG9zdENvbnRleHQyLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIG5leHRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7IC8vIFNwZWNpYWwgcGF0aCBmb3IgZGVoeWRyYXRlZCBib3VuZGFyaWVzLiBXZSBtYXkgZXZlbnR1YWxseSBtb3ZlIHRoaXNcbiAgICAgICAgLy8gdG8gaXRzIG93biBmaWJlciB0eXBlIHNvIHRoYXQgd2UgY2FuIGFkZCBvdGhlciBraW5kcyBvZiBoeWRyYXRpb25cbiAgICAgICAgLy8gYm91bmRhcmllcyB0aGF0IGFyZW4ndCBhc3NvY2lhdGVkIHdpdGggYSBTdXNwZW5zZSB0cmVlLiBJbiBhbnRpY2lwYXRpb25cbiAgICAgICAgLy8gb2Ygc3VjaCBhIHJlZmFjdG9yLCBhbGwgdGhlIGh5ZHJhdGlvbiBsb2dpYyBpcyBjb250YWluZWQgaW5cbiAgICAgICAgLy8gdGhpcyBicmFuY2guXG5cbiAgICAgICAgaWYgKGN1cnJlbnQgPT09IG51bGwgfHwgY3VycmVudC5tZW1vaXplZFN0YXRlICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGZhbGx0aHJvdWdoVG9Ob3JtYWxTdXNwZW5zZVBhdGggPSBjb21wbGV0ZURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0U3RhdGUpO1xuXG4gICAgICAgICAgaWYgKCFmYWxsdGhyb3VnaFRvTm9ybWFsU3VzcGVuc2VQYXRoKSB7XG4gICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBGb3JjZUNsaWVudFJlbmRlcikge1xuICAgICAgICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpOyAvLyBTcGVjaWFsIGNhc2UuIFRoZXJlIHdlcmUgcmVtYWluaW5nIHVuaHlkcmF0ZWQgbm9kZXMuIFdlIHRyZWF0XG4gICAgICAgICAgICAgIC8vIHRoaXMgYXMgYSBtaXNtYXRjaC4gUmV2ZXJ0IHRvIGNsaWVudCByZW5kZXJpbmcuXG5cbiAgICAgICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTsgLy8gRGlkIG5vdCBmaW5pc2ggaHlkcmF0aW5nLCBlaXRoZXIgYmVjYXVzZSB0aGlzIGlzIHRoZSBpbml0aWFsXG4gICAgICAgICAgICAgIC8vIHJlbmRlciBvciBiZWNhdXNlIHNvbWV0aGluZyBzdXNwZW5kZWQuXG5cbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSAvLyBDb250aW51ZSB3aXRoIHRoZSBub3JtYWwgU3VzcGVuc2UgcGF0aC5cblxuICAgICAgICB9XG5cbiAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgIC8vIFNvbWV0aGluZyBzdXNwZW5kZWQuIFJlLXJlbmRlciB3aXRoIHRoZSBmYWxsYmFjayBjaGlsZHJlbi5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHJlbmRlckxhbmVzOyAvLyBEbyBub3QgcmVzZXQgdGhlIGVmZmVjdCBsaXN0LlxuXG4gICAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH0gLy8gRG9uJ3QgYnViYmxlIHByb3BlcnRpZXMgaW4gdGhpcyBjYXNlLlxuXG5cbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV4dERpZFRpbWVvdXQgPSBuZXh0U3RhdGUgIT09IG51bGw7XG4gICAgICAgIHZhciBwcmV2RGlkVGltZW91dCA9IGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuXG4gICAgICAgIGlmIChuZXh0RGlkVGltZW91dCkge1xuICAgICAgICAgIHZhciBvZmZzY3JlZW5GaWJlciA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgIHZhciBfcHJldmlvdXNDYWNoZSA9IG51bGw7XG5cbiAgICAgICAgICBpZiAob2Zmc2NyZWVuRmliZXIuYWx0ZXJuYXRlICE9PSBudWxsICYmIG9mZnNjcmVlbkZpYmVyLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlICE9PSBudWxsICYmIG9mZnNjcmVlbkZpYmVyLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgX3ByZXZpb3VzQ2FjaGUgPSBvZmZzY3JlZW5GaWJlci5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2NhY2hlID0gbnVsbDtcblxuICAgICAgICAgIGlmIChvZmZzY3JlZW5GaWJlci5tZW1vaXplZFN0YXRlICE9PSBudWxsICYmIG9mZnNjcmVlbkZpYmVyLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICE9PSBudWxsKSB7XG4gICAgICAgICAgICBfY2FjaGUgPSBvZmZzY3JlZW5GaWJlci5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChfY2FjaGUgIT09IF9wcmV2aW91c0NhY2hlKSB7XG4gICAgICAgICAgICAvLyBSdW4gcGFzc2l2ZSBlZmZlY3RzIHRvIHJldGFpbi9yZWxlYXNlIHRoZSBjYWNoZS5cbiAgICAgICAgICAgIG9mZnNjcmVlbkZpYmVyLmZsYWdzIHw9IFBhc3NpdmUkMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gSWYgdGhlIHN1c3BlbmRlZCBzdGF0ZSBvZiB0aGUgYm91bmRhcnkgY2hhbmdlcywgd2UgbmVlZCB0byBzY2hlZHVsZVxuICAgICAgICAvLyBhIHBhc3NpdmUgZWZmZWN0LCB3aGljaCBpcyB3aGVuIHdlIHByb2Nlc3MgdGhlIHRyYW5zaXRpb25zXG5cblxuICAgICAgICBpZiAobmV4dERpZFRpbWVvdXQgIT09IHByZXZEaWRUaW1lb3V0KSB7XG4gICAgICAgICAgLy8gYW4gZWZmZWN0IHRvIHRvZ2dsZSB0aGUgc3VidHJlZSdzIHZpc2liaWxpdHkuIFdoZW4gd2Ugc3dpdGNoIGZyb21cbiAgICAgICAgICAvLyBmYWxsYmFjayAtPiBwcmltYXJ5LCB0aGUgaW5uZXIgT2Zmc2NyZWVuIGZpYmVyIHNjaGVkdWxlcyB0aGlzIGVmZmVjdFxuICAgICAgICAgIC8vIGFzIHBhcnQgb2YgaXRzIG5vcm1hbCBjb21wbGV0ZSBwaGFzZS4gQnV0IHdoZW4gd2Ugc3dpdGNoIGZyb21cbiAgICAgICAgICAvLyBwcmltYXJ5IC0+IGZhbGxiYWNrLCB0aGUgaW5uZXIgT2Zmc2NyZWVuIGZpYmVyIGRvZXMgbm90IGhhdmUgYSBjb21wbGV0ZVxuICAgICAgICAgIC8vIHBoYXNlLiBTbyB3ZSBuZWVkIHRvIHNjaGVkdWxlIGl0cyBlZmZlY3QgaGVyZS5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFdlIGFsc28gdXNlIHRoaXMgZmxhZyB0byBjb25uZWN0L2Rpc2Nvbm5lY3QgdGhlIGVmZmVjdHMsIGJ1dCB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxvZ2ljIGFwcGxpZXM6IHdoZW4gcmUtY29ubmVjdGluZywgdGhlIE9mZnNjcmVlbiBmaWJlcidzIGNvbXBsZXRlXG4gICAgICAgICAgLy8gcGhhc2Ugd2lsbCBoYW5kbGUgc2NoZWR1bGluZyB0aGUgZWZmZWN0LiBJdCdzIG9ubHkgd2hlbiB0aGUgZmFsbGJhY2tcbiAgICAgICAgICAvLyBpcyBhY3RpdmUgdGhhdCB3ZSBoYXZlIHRvIGRvIGFueXRoaW5nIHNwZWNpYWwuXG5cblxuICAgICAgICAgIGlmIChuZXh0RGlkVGltZW91dCkge1xuICAgICAgICAgICAgdmFyIF9vZmZzY3JlZW5GaWJlcjIgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICAgIF9vZmZzY3JlZW5GaWJlcjIuZmxhZ3MgfD0gVmlzaWJpbGl0eTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmV0cnlRdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuICAgICAgICBzY2hlZHVsZVJldHJ5RWZmZWN0KHdvcmtJblByb2dyZXNzLCByZXRyeVF1ZXVlKTtcblxuICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICAgIGlmIChuZXh0RGlkVGltZW91dCkge1xuICAgICAgICAgICAgICAvLyBEb24ndCBjb3VudCB0aW1lIHNwZW50IGluIGEgdGltZWQgb3V0IFN1c3BlbnNlIHN1YnRyZWUgYXMgcGFydCBvZiB0aGUgYmFzZSBkdXJhdGlvbi5cbiAgICAgICAgICAgICAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICAgICAgICAgICAgaWYgKHByaW1hcnlDaGlsZEZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgLy8gJEZsb3dGaXhNZVt1bnNhZmUtYXJpdGhtZXRpY10gRmxvdyBkb2Vzbid0IHN1cHBvcnQgdHlwZSBjYXN0aW5nIGluIGNvbWJpbmF0aW9uIHdpdGggdGhlIC09IG9wZXJhdG9yXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiAtPSBwcmltYXJ5Q2hpbGRGcmFnbWVudC50cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHVwZGF0ZUhvc3RDb250YWluZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICBwcmVwYXJlUG9ydGFsTW91bnQod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgfVxuXG4gICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICAvLyBQb3AgcHJvdmlkZXIgZmliZXJcbiAgICAgIHZhciBjb250ZXh0O1xuXG4gICAgICB7XG4gICAgICAgIGNvbnRleHQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgfVxuXG4gICAgICBwb3BQcm92aWRlcihjb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSAvLyBTYW1lIGFzIGNsYXNzIGNvbXBvbmVudCBjYXNlLiBJIHB1dCBpdCBkb3duIGhlcmUgc28gdGhhdCB0aGUgdGFncyBhcmVcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BTdXNwZW5zZUxpc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgdmFyIHJlbmRlclN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICBpZiAocmVuZGVyU3RhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSdyZSBydW5uaW5nIGluIHRoZSBkZWZhdWx0LCBcImluZGVwZW5kZW50XCIgbW9kZS5cbiAgICAgICAgICAvLyBXZSBkb24ndCBkbyBhbnl0aGluZyBpbiB0aGlzIG1vZGUuXG4gICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZGlkU3VzcGVuZEFscmVhZHkgPSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncyQxO1xuICAgICAgICB2YXIgcmVuZGVyZWRUYWlsID0gcmVuZGVyU3RhdGUucmVuZGVyaW5nO1xuXG4gICAgICAgIGlmIChyZW5kZXJlZFRhaWwgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBXZSBqdXN0IHJlbmRlcmVkIHRoZSBoZWFkLlxuICAgICAgICAgIGlmICghZGlkU3VzcGVuZEFscmVhZHkpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHBhc3MuIFdlIG5lZWQgdG8gZmlndXJlIG91dCBpZiBhbnl0aGluZyBpcyBzdGlsbFxuICAgICAgICAgICAgLy8gc3VzcGVuZGVkIGluIHRoZSByZW5kZXJlZCBzZXQuXG4gICAgICAgICAgICAvLyBJZiBuZXcgY29udGVudCB1bnN1c3BlbmRlZCwgYnV0IHRoZXJlJ3Mgc3RpbGwgc29tZSBjb250ZW50IHRoYXRcbiAgICAgICAgICAgIC8vIGRpZG4ndC4gVGhlbiB3ZSBuZWVkIHRvIGRvIGEgc2Vjb25kIHBhc3MgdGhhdCBmb3JjZXMgZXZlcnl0aGluZ1xuICAgICAgICAgICAgLy8gdG8ga2VlcCBzaG93aW5nIHRoZWlyIGZhbGxiYWNrcy5cbiAgICAgICAgICAgIC8vIFdlIG1pZ2h0IGJlIHN1c3BlbmRlZCBpZiBzb21ldGhpbmcgaW4gdGhpcyByZW5kZXIgcGFzcyBzdXNwZW5kZWQsIG9yXG4gICAgICAgICAgICAvLyBzb21ldGhpbmcgaW4gdGhlIHByZXZpb3VzIGNvbW1pdHRlZCBwYXNzIHN1c3BlbmRlZC4gT3RoZXJ3aXNlLFxuICAgICAgICAgICAgLy8gdGhlcmUncyBubyBjaGFuY2Ugc28gd2UgY2FuIHNraXAgdGhlIGV4cGVuc2l2ZSBjYWxsIHRvXG4gICAgICAgICAgICAvLyBmaW5kRmlyc3RTdXNwZW5kZWQuXG4gICAgICAgICAgICB2YXIgY2Fubm90QmVTdXNwZW5kZWQgPSByZW5kZXJIYXNOb3RTdXNwZW5kZWRZZXQoKSAmJiAoY3VycmVudCA9PT0gbnVsbCB8fCAoY3VycmVudC5mbGFncyAmIERpZENhcHR1cmUpID09PSBOb0ZsYWdzJDEpO1xuXG4gICAgICAgICAgICBpZiAoIWNhbm5vdEJlU3VzcGVuZGVkKSB7XG4gICAgICAgICAgICAgIHZhciByb3cgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICAgICAgICAgICAgICB3aGlsZSAocm93ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHN1c3BlbmRlZCA9IGZpbmRGaXJzdFN1c3BlbmRlZChyb3cpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN1c3BlbmRlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgZGlkU3VzcGVuZEFscmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgZmFsc2UpOyAvLyBJZiB0aGlzIGlzIGEgbmV3bHkgc3VzcGVuZGVkIHRyZWUsIGl0IG1pZ2h0IG5vdCBnZXQgY29tbWl0dGVkIGFzXG4gICAgICAgICAgICAgICAgICAvLyBwYXJ0IG9mIHRoZSBzZWNvbmQgcGFzcy4gSW4gdGhhdCBjYXNlIG5vdGhpbmcgd2lsbCBzdWJzY3JpYmUgdG9cbiAgICAgICAgICAgICAgICAgIC8vIGl0cyB0aGVuYWJsZXMuIEluc3RlYWQsIHdlJ2xsIHRyYW5zZmVyIGl0cyB0aGVuYWJsZXMgdG8gdGhlXG4gICAgICAgICAgICAgICAgICAvLyBTdXNwZW5zZUxpc3Qgc28gdGhhdCBpdCBjYW4gcmV0cnkgaWYgdGhleSByZXNvbHZlLlxuICAgICAgICAgICAgICAgICAgLy8gVGhlcmUgbWlnaHQgYmUgbXVsdGlwbGUgb2YgdGhlc2UgaW4gdGhlIGxpc3QgYnV0IHNpbmNlIHdlJ3JlXG4gICAgICAgICAgICAgICAgICAvLyBnb2luZyB0byB3YWl0IGZvciBhbGwgb2YgdGhlbSBhbnl3YXksIGl0IGRvZXNuJ3QgcmVhbGx5IG1hdHRlclxuICAgICAgICAgICAgICAgICAgLy8gd2hpY2ggb25lcyBnZXRzIHRvIHBpbmcuIEluIHRoZW9yeSB3ZSBjb3VsZCBnZXQgY2xldmVyIGFuZCBrZWVwXG4gICAgICAgICAgICAgICAgICAvLyB0cmFjayBvZiBob3cgbWFueSBkZXBlbmRlbmNpZXMgcmVtYWluIGJ1dCBpdCBnZXRzIHRyaWNreSBiZWNhdXNlXG4gICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgbWVhbnRpbWUsIHdlIGNhbiBhZGQvcmVtb3ZlL2NoYW5nZSBpdGVtcyBhbmQgZGVwZW5kZW5jaWVzLlxuICAgICAgICAgICAgICAgICAgLy8gV2UgbWlnaHQgYmFpbCBvdXQgb2YgdGhlIGxvb3AgYmVmb3JlIGZpbmRpbmcgYW55IGJ1dCB0aGF0XG4gICAgICAgICAgICAgICAgICAvLyBkb2Vzbid0IG1hdHRlciBzaW5jZSB0aGF0IG1lYW5zIHRoYXQgdGhlIG90aGVyIGJvdW5kYXJpZXMgdGhhdFxuICAgICAgICAgICAgICAgICAgLy8gd2UgZGlkIGZpbmQgYWxyZWFkeSBoYXMgdGhlaXIgbGlzdGVuZXJzIGF0dGFjaGVkLlxuXG4gICAgICAgICAgICAgICAgICB2YXIgX3JldHJ5UXVldWUgPSBzdXNwZW5kZWQudXBkYXRlUXVldWU7XG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IF9yZXRyeVF1ZXVlO1xuICAgICAgICAgICAgICAgICAgc2NoZWR1bGVSZXRyeUVmZmVjdCh3b3JrSW5Qcm9ncmVzcywgX3JldHJ5UXVldWUpOyAvLyBSZXJlbmRlciB0aGUgd2hvbGUgbGlzdCwgYnV0IHRoaXMgdGltZSwgd2UnbGwgZm9yY2UgZmFsbGJhY2tzXG4gICAgICAgICAgICAgICAgICAvLyB0byBzdGF5IGluIHBsYWNlLlxuICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGVmZmVjdCBmbGFncyBiZWZvcmUgZG9pbmcgdGhlIHNlY29uZCBwYXNzIHNpbmNlIHRoYXQncyBub3cgaW52YWxpZC5cbiAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHRoZSBjaGlsZCBmaWJlcnMgdG8gdGhlaXIgb3JpZ2luYWwgc3RhdGUuXG5cbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IE5vRmxhZ3MkMTtcbiAgICAgICAgICAgICAgICAgIHJlc2V0Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTsgLy8gU2V0IHVwIHRoZSBTdXNwZW5zZSBMaXN0IENvbnRleHQgdG8gZm9yY2Ugc3VzcGVuc2UgYW5kXG4gICAgICAgICAgICAgICAgICAvLyBpbW1lZGlhdGVseSByZXJlbmRlciB0aGUgY2hpbGRyZW4uXG5cbiAgICAgICAgICAgICAgICAgIHB1c2hTdXNwZW5zZUxpc3RDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzZXRTaGFsbG93U3VzcGVuc2VMaXN0Q29udGV4dChzdXNwZW5zZVN0YWNrQ3Vyc29yLmN1cnJlbnQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjaykpOyAvLyBEb24ndCBidWJibGUgcHJvcGVydGllcyBpbiB0aGlzIGNhc2UuXG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByb3cgPSByb3cuc2libGluZztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVuZGVyU3RhdGUudGFpbCAhPT0gbnVsbCAmJiBub3ckMSgpID4gZ2V0UmVuZGVyVGFyZ2V0VGltZSgpKSB7XG4gICAgICAgICAgICAgIC8vIFdlIGhhdmUgYWxyZWFkeSBwYXNzZWQgb3VyIENQVSBkZWFkbGluZSBidXQgd2Ugc3RpbGwgaGF2ZSByb3dzXG4gICAgICAgICAgICAgIC8vIGxlZnQgaW4gdGhlIHRhaWwuIFdlJ2xsIGp1c3QgZ2l2ZSB1cCBmdXJ0aGVyIGF0dGVtcHRzIHRvIHJlbmRlclxuICAgICAgICAgICAgICAvLyB0aGUgbWFpbiBjb250ZW50IGFuZCBvbmx5IHJlbmRlciBmYWxsYmFja3MuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgICAgIGRpZFN1c3BlbmRBbHJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBmYWxzZSk7IC8vIFNpbmNlIG5vdGhpbmcgYWN0dWFsbHkgc3VzcGVuZGVkLCB0aGVyZSB3aWxsIG5vdGhpbmcgdG8gcGluZyB0aGlzXG4gICAgICAgICAgICAgIC8vIHRvIGdldCBpdCBzdGFydGVkIGJhY2sgdXAgdG8gYXR0ZW1wdCB0aGUgbmV4dCBpdGVtLiBXaGlsZSBpbiB0ZXJtc1xuICAgICAgICAgICAgICAvLyBvZiBwcmlvcml0eSB0aGlzIHdvcmsgaGFzIHRoZSBzYW1lIHByaW9yaXR5IGFzIHRoaXMgY3VycmVudCByZW5kZXIsXG4gICAgICAgICAgICAgIC8vIGl0J3Mgbm90IHBhcnQgb2YgdGhlIHNhbWUgdHJhbnNpdGlvbiBvbmNlIHRoZSB0cmFuc2l0aW9uIGhhc1xuICAgICAgICAgICAgICAvLyBjb21taXR0ZWQuIElmIGl0J3Mgc3luYywgd2Ugc3RpbGwgd2FudCB0byB5aWVsZCBzbyB0aGF0IGl0IGNhbiBiZVxuICAgICAgICAgICAgICAvLyBwYWludGVkLiBDb25jZXB0dWFsbHksIHRoaXMgaXMgcmVhbGx5IHRoZSBzYW1lIGFzIHBpbmdpbmcuXG4gICAgICAgICAgICAgIC8vIFdlIGNhbiB1c2UgYW55IFJldHJ5TGFuZSBldmVuIGlmIGl0J3MgdGhlIG9uZSBjdXJyZW50bHkgcmVuZGVyaW5nXG4gICAgICAgICAgICAgIC8vIHNpbmNlIHdlJ3JlIGxlYXZpbmcgaXQgYmVoaW5kIG9uIHRoaXMgbm9kZS5cblxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IFNvbWVSZXRyeUxhbmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgZmFsc2UpO1xuICAgICAgICAgIH0gLy8gTmV4dCB3ZSdyZSBnb2luZyB0byByZW5kZXIgdGhlIHRhaWwuXG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBcHBlbmQgdGhlIHJlbmRlcmVkIHJvdyB0byB0aGUgY2hpbGQgbGlzdC5cbiAgICAgICAgICBpZiAoIWRpZFN1c3BlbmRBbHJlYWR5KSB7XG4gICAgICAgICAgICB2YXIgX3N1c3BlbmRlZCA9IGZpbmRGaXJzdFN1c3BlbmRlZChyZW5kZXJlZFRhaWwpO1xuXG4gICAgICAgICAgICBpZiAoX3N1c3BlbmRlZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICAgICAgICAgICAgICBkaWRTdXNwZW5kQWxyZWFkeSA9IHRydWU7IC8vIEVuc3VyZSB3ZSB0cmFuc2ZlciB0aGUgdXBkYXRlIHF1ZXVlIHRvIHRoZSBwYXJlbnQgc28gdGhhdCBpdCBkb2Vzbid0XG4gICAgICAgICAgICAgIC8vIGdldCBsb3N0IGlmIHRoaXMgcm93IGVuZHMgdXAgZHJvcHBlZCBkdXJpbmcgYSBzZWNvbmQgcGFzcy5cblxuICAgICAgICAgICAgICB2YXIgX3JldHJ5UXVldWUyID0gX3N1c3BlbmRlZC51cGRhdGVRdWV1ZTtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBfcmV0cnlRdWV1ZTI7XG4gICAgICAgICAgICAgIHNjaGVkdWxlUmV0cnlFZmZlY3Qod29ya0luUHJvZ3Jlc3MsIF9yZXRyeVF1ZXVlMik7XG4gICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgdHJ1ZSk7IC8vIFRoaXMgbWlnaHQgaGF2ZSBiZWVuIG1vZGlmaWVkLlxuXG4gICAgICAgICAgICAgIGlmIChyZW5kZXJTdGF0ZS50YWlsID09PSBudWxsICYmIHJlbmRlclN0YXRlLnRhaWxNb2RlID09PSAnaGlkZGVuJyAmJiAhcmVuZGVyZWRUYWlsLmFsdGVybmF0ZSAmJiAhZ2V0SXNIeWRyYXRpbmcoKSAvLyBXZSBkb24ndCBjdXQgaXQgaWYgd2UncmUgaHlkcmF0aW5nLlxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIC8vIFdlJ3JlIGRvbmUuXG4gICAgICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIC8vIFRoZSB0aW1lIGl0IHRvb2sgdG8gcmVuZGVyIGxhc3Qgcm93IGlzIGdyZWF0ZXIgdGhhbiB0aGUgcmVtYWluaW5nXG4gICAgICAgICAgICAvLyB0aW1lIHdlIGhhdmUgdG8gcmVuZGVyLiBTbyByZW5kZXJpbmcgb25lIG1vcmUgcm93IHdvdWxkIGxpa2VseVxuICAgICAgICAgICAgLy8gZXhjZWVkIGl0LlxuICAgICAgICAgICAgbm93JDEoKSAqIDIgLSByZW5kZXJTdGF0ZS5yZW5kZXJpbmdTdGFydFRpbWUgPiBnZXRSZW5kZXJUYXJnZXRUaW1lKCkgJiYgcmVuZGVyTGFuZXMgIT09IE9mZnNjcmVlbkxhbmUpIHtcbiAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBub3cgcGFzc2VkIG91ciBDUFUgZGVhZGxpbmUgYW5kIHdlJ2xsIGp1c3QgZ2l2ZSB1cCBmdXJ0aGVyXG4gICAgICAgICAgICAgIC8vIGF0dGVtcHRzIHRvIHJlbmRlciB0aGUgbWFpbiBjb250ZW50IGFuZCBvbmx5IHJlbmRlciBmYWxsYmFja3MuXG4gICAgICAgICAgICAgIC8vIFRoZSBhc3N1bXB0aW9uIGlzIHRoYXQgdGhpcyBpcyB1c3VhbGx5IGZhc3Rlci5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICAgICAgZGlkU3VzcGVuZEFscmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIGZhbHNlKTsgLy8gU2luY2Ugbm90aGluZyBhY3R1YWxseSBzdXNwZW5kZWQsIHRoZXJlIHdpbGwgbm90aGluZyB0byBwaW5nIHRoaXNcbiAgICAgICAgICAgICAgLy8gdG8gZ2V0IGl0IHN0YXJ0ZWQgYmFjayB1cCB0byBhdHRlbXB0IHRoZSBuZXh0IGl0ZW0uIFdoaWxlIGluIHRlcm1zXG4gICAgICAgICAgICAgIC8vIG9mIHByaW9yaXR5IHRoaXMgd29yayBoYXMgdGhlIHNhbWUgcHJpb3JpdHkgYXMgdGhpcyBjdXJyZW50IHJlbmRlcixcbiAgICAgICAgICAgICAgLy8gaXQncyBub3QgcGFydCBvZiB0aGUgc2FtZSB0cmFuc2l0aW9uIG9uY2UgdGhlIHRyYW5zaXRpb24gaGFzXG4gICAgICAgICAgICAgIC8vIGNvbW1pdHRlZC4gSWYgaXQncyBzeW5jLCB3ZSBzdGlsbCB3YW50IHRvIHlpZWxkIHNvIHRoYXQgaXQgY2FuIGJlXG4gICAgICAgICAgICAgIC8vIHBhaW50ZWQuIENvbmNlcHR1YWxseSwgdGhpcyBpcyByZWFsbHkgdGhlIHNhbWUgYXMgcGluZ2luZy5cbiAgICAgICAgICAgICAgLy8gV2UgY2FuIHVzZSBhbnkgUmV0cnlMYW5lIGV2ZW4gaWYgaXQncyB0aGUgb25lIGN1cnJlbnRseSByZW5kZXJpbmdcbiAgICAgICAgICAgICAgLy8gc2luY2Ugd2UncmUgbGVhdmluZyBpdCBiZWhpbmQgb24gdGhpcyBub2RlLlxuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gU29tZVJldHJ5TGFuZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAocmVuZGVyU3RhdGUuaXNCYWNrd2FyZHMpIHtcbiAgICAgICAgICAgIC8vIFRoZSBlZmZlY3QgbGlzdCBvZiB0aGUgYmFja3dhcmRzIHRhaWwgd2lsbCBoYXZlIGJlZW4gYWRkZWRcbiAgICAgICAgICAgIC8vIHRvIHRoZSBlbmQuIFRoaXMgYnJlYWtzIHRoZSBndWFyYW50ZWUgdGhhdCBsaWZlLWN5Y2xlcyBmaXJlIGluXG4gICAgICAgICAgICAvLyBzaWJsaW5nIG9yZGVyIGJ1dCB0aGF0IGlzbid0IGEgc3Ryb25nIGd1YXJhbnRlZSBwcm9taXNlZCBieSBSZWFjdC5cbiAgICAgICAgICAgIC8vIEVzcGVjaWFsbHkgc2luY2UgdGhlc2UgbWlnaHQgYWxzbyBqdXN0IHBvcCBpbiBkdXJpbmcgZnV0dXJlIGNvbW1pdHMuXG4gICAgICAgICAgICAvLyBBcHBlbmQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgbGlzdC5cbiAgICAgICAgICAgIHJlbmRlcmVkVGFpbC5zaWJsaW5nID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlbmRlcmVkVGFpbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHByZXZpb3VzU2libGluZyA9IHJlbmRlclN0YXRlLmxhc3Q7XG5cbiAgICAgICAgICAgIGlmIChwcmV2aW91c1NpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcHJldmlvdXNTaWJsaW5nLnNpYmxpbmcgPSByZW5kZXJlZFRhaWw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlbmRlcmVkVGFpbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVuZGVyU3RhdGUubGFzdCA9IHJlbmRlcmVkVGFpbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVuZGVyU3RhdGUudGFpbCAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIHN0aWxsIGhhdmUgdGFpbCByb3dzIHRvIHJlbmRlci5cbiAgICAgICAgICAvLyBQb3AgYSByb3cuXG4gICAgICAgICAgdmFyIG5leHQgPSByZW5kZXJTdGF0ZS50YWlsO1xuICAgICAgICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZyA9IG5leHQ7XG4gICAgICAgICAgcmVuZGVyU3RhdGUudGFpbCA9IG5leHQuc2libGluZztcbiAgICAgICAgICByZW5kZXJTdGF0ZS5yZW5kZXJpbmdTdGFydFRpbWUgPSBub3ckMSgpO1xuICAgICAgICAgIG5leHQuc2libGluZyA9IG51bGw7IC8vIFJlc3RvcmUgdGhlIGNvbnRleHQuXG4gICAgICAgICAgLy8gVE9ETzogV2UgY2FuIHByb2JhYmx5IGp1c3QgYXZvaWQgcG9wcGluZyBpdCBpbnN0ZWFkIGFuZCBvbmx5XG4gICAgICAgICAgLy8gc2V0dGluZyBpdCB0aGUgZmlyc3QgdGltZSB3ZSBnbyBmcm9tIG5vdCBzdXNwZW5kZWQgdG8gc3VzcGVuZGVkLlxuXG4gICAgICAgICAgdmFyIHN1c3BlbnNlQ29udGV4dCA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtcblxuICAgICAgICAgIGlmIChkaWRTdXNwZW5kQWxyZWFkeSkge1xuICAgICAgICAgICAgc3VzcGVuc2VDb250ZXh0ID0gc2V0U2hhbGxvd1N1c3BlbnNlTGlzdENvbnRleHQoc3VzcGVuc2VDb250ZXh0LCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdXNwZW5zZUNvbnRleHQgPSBzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlTGlzdENvbnRleHQoc3VzcGVuc2VDb250ZXh0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwdXNoU3VzcGVuc2VMaXN0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VDb250ZXh0KTsgLy8gRG8gYSBwYXNzIG92ZXIgdGhlIG5leHQgcm93LlxuICAgICAgICAgIC8vIERvbid0IGJ1YmJsZSBwcm9wZXJ0aWVzIGluIHRoaXMgY2FzZS5cblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBTY29wZUNvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBwb3BIaWRkZW5Db250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgdmFyIF9uZXh0U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICAgICAgICB2YXIgbmV4dElzSGlkZGVuID0gX25leHRTdGF0ZSAhPT0gbnVsbDsgLy8gU2NoZWR1bGUgYSBWaXNpYmlsaXR5IGVmZmVjdCBpZiB0aGUgdmlzaWJpbGl0eSBoYXMgY2hhbmdlZFxuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIF9wcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICB2YXIgcHJldklzSGlkZGVuID0gX3ByZXZTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKHByZXZJc0hpZGRlbiAhPT0gbmV4dElzSGlkZGVuKSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFZpc2liaWxpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIE9uIGluaXRpYWwgbW91bnQsIHdlIG9ubHkgbmVlZCBhIFZpc2liaWxpdHkgZWZmZWN0IGlmIHRoZSB0cmVlXG4gICAgICAgICAgICAvLyBpcyBoaWRkZW4uXG4gICAgICAgICAgICBpZiAobmV4dElzSGlkZGVuKSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFZpc2liaWxpdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFuZXh0SXNIaWRkZW4gfHwgIWRpc2FibGVMZWdhY3lNb2RlICkge1xuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIERvbid0IGJ1YmJsZSBwcm9wZXJ0aWVzIGZvciBoaWRkZW4gY2hpbGRyZW4gdW5sZXNzIHdlJ3JlIHJlbmRlcmluZ1xuICAgICAgICAgIC8vIGF0IG9mZnNjcmVlbiBwcmlvcml0eS5cbiAgICAgICAgICBpZiAoaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgT2Zmc2NyZWVuTGFuZSkgJiYgLy8gQWxzbyBkb24ndCBidWJibGUgaWYgdGhlIHRyZWUgc3VzcGVuZGVkXG4gICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IE5vTGFuZXMpIHtcbiAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpOyAvLyBDaGVjayBpZiB0aGVyZSB3YXMgYW4gaW5zZXJ0aW9uIG9yIHVwZGF0ZSBpbiB0aGUgaGlkZGVuIHN1YnRyZWUuXG4gICAgICAgICAgICAvLyBJZiBzbywgd2UgbmVlZCB0byBoaWRlIHRob3NlIG5vZGVzIGluIHRoZSBjb21taXQgcGhhc2UsIHNvXG4gICAgICAgICAgICAvLyBzY2hlZHVsZSBhIHZpc2liaWxpdHkgZWZmZWN0LlxuXG4gICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzICYgKFBsYWNlbWVudCB8IFVwZGF0ZSkpIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVmlzaWJpbGl0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb2Zmc2NyZWVuUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcblxuICAgICAgICBpZiAob2Zmc2NyZWVuUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgX3JldHJ5UXVldWUzID0gb2Zmc2NyZWVuUXVldWUucmV0cnlRdWV1ZTtcbiAgICAgICAgICBzY2hlZHVsZVJldHJ5RWZmZWN0KHdvcmtJblByb2dyZXNzLCBfcmV0cnlRdWV1ZTMpO1xuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgIHZhciBfcHJldmlvdXNDYWNoZTIgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgIT09IG51bGwpIHtcbiAgICAgICAgICAgIF9wcmV2aW91c0NhY2hlMiA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2NhY2hlMiA9IG51bGw7XG5cbiAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgX2NhY2hlMiA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2w7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF9jYWNoZTIgIT09IF9wcmV2aW91c0NhY2hlMikge1xuICAgICAgICAgICAgLy8gUnVuIHBhc3NpdmUgZWZmZWN0cyB0byByZXRhaW4vcmVsZWFzZSB0aGUgY2FjaGUuXG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQYXNzaXZlJDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcG9wVHJhbnNpdGlvbih3b3JrSW5Qcm9ncmVzcywgY3VycmVudCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBDYWNoZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIHZhciBfcHJldmlvdXNDYWNoZTMgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIF9wcmV2aW91c0NhY2hlMyA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX2NhY2hlMyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUuY2FjaGU7XG5cbiAgICAgICAgICBpZiAoX2NhY2hlMyAhPT0gX3ByZXZpb3VzQ2FjaGUzKSB7XG4gICAgICAgICAgICAvLyBSdW4gcGFzc2l2ZSBlZmZlY3RzIHRvIHJldGFpbi9yZWxlYXNlIHRoZSBjYWNoZS5cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBhc3NpdmUkMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwb3BDYWNoZVByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBUcmFjaW5nTWFya2VyQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB1bml0IG9mIHdvcmsgdGFnIChcIiArIHdvcmtJblByb2dyZXNzLnRhZyArIFwiKS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFwiICsgJ1JlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbn1cblxuZnVuY3Rpb24gdW53aW5kV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgLy8gTm90ZTogVGhpcyBpbnRlbnRpb25hbGx5IGRvZXNuJ3QgY2hlY2sgaWYgd2UncmUgaHlkcmF0aW5nIGJlY2F1c2UgY29tcGFyaW5nXG4gIC8vIHRvIHRoZSBjdXJyZW50IHRyZWUgcHJvdmlkZXIgZmliZXIgaXMganVzdCBhcyBmYXN0IGFuZCBsZXNzIGVycm9yLXByb25lLlxuICAvLyBJZGVhbGx5IHdlIHdvdWxkIGhhdmUgYSBzcGVjaWFsIHZlcnNpb24gb2YgdGhlIHdvcmsgbG9vcCBvbmx5XG4gIC8vIGZvciBoeWRyYXRpb24uXG4gIHBvcFRyZWVDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcblxuICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgdmFyIGZsYWdzID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3M7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgU2hvdWxkQ2FwdHVyZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzID0gZmxhZ3MgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7XG5cbiAgICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICAgICAgdHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuXG4gICAgICAgIHtcbiAgICAgICAgICBwb3BDYWNoZVByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgdmFyIF9mbGFncyA9IHdvcmtJblByb2dyZXNzLmZsYWdzO1xuXG4gICAgICAgIGlmICgoX2ZsYWdzICYgU2hvdWxkQ2FwdHVyZSkgIT09IE5vRmxhZ3MkMSAmJiAoX2ZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgIC8vIFRoZXJlIHdhcyBhbiBlcnJvciBkdXJpbmcgcmVuZGVyIHRoYXQgd2Fzbid0IGNhcHR1cmVkIGJ5IGEgc3VzcGVuc2VcbiAgICAgICAgICAvLyBib3VuZGFyeS4gRG8gYSBzZWNvbmQgcGFzcyBvbiB0aGUgcm9vdCB0byB1bm1vdW50IHRoZSBjaGlsZHJlbi5cbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IF9mbGFncyAmIH5TaG91bGRDYXB0dXJlIHwgRGlkQ2FwdHVyZTtcbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH0gLy8gV2UgdW53b3VuZCB0byB0aGUgcm9vdCB3aXRob3V0IGNvbXBsZXRpbmcgaXQuIEV4aXQuXG5cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdEhvaXN0YWJsZTpcbiAgICBjYXNlIEhvc3RTaW5nbGV0b246XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICAvLyBUT0RPOiBwb3BIeWRyYXRpb25TdGF0ZVxuICAgICAgICBwb3BIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgdmFyIHN1c3BlbnNlU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgIGlmIChzdXNwZW5zZVN0YXRlICE9PSBudWxsICYmIHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhyZXcgaW4gbmV3bHkgbW91bnRlZCBkZWh5ZHJhdGVkIGNvbXBvbmVudC4gVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gJyArICdSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIF9mbGFnczIgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncztcblxuICAgICAgICBpZiAoX2ZsYWdzMiAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IF9mbGFnczIgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7IC8vIENhcHR1cmVkIGEgc3VzcGVuc2UgZWZmZWN0LiBSZS1yZW5kZXIgdGhlIGJvdW5kYXJ5LlxuXG4gICAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcFN1c3BlbnNlTGlzdENvbnRleHQod29ya0luUHJvZ3Jlc3MpOyAvLyBTdXNwZW5zZUxpc3QgZG9lc24ndCBhY3R1YWxseSBjYXRjaCBhbnl0aGluZy4gSXQgc2hvdWxkJ3ZlIGJlZW5cbiAgICAgICAgLy8gY2F1Z2h0IGJ5IGEgbmVzdGVkIGJvdW5kYXJ5LiBJZiBub3QsIGl0IHNob3VsZCBidWJibGUgdGhyb3VnaC5cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIHZhciBjb250ZXh0O1xuXG4gICAgICB7XG4gICAgICAgIGNvbnRleHQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgfVxuXG4gICAgICBwb3BQcm92aWRlcihjb250ZXh0LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBwb3BIaWRkZW5Db250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcG9wVHJhbnNpdGlvbih3b3JrSW5Qcm9ncmVzcywgY3VycmVudCk7XG4gICAgICAgIHZhciBfZmxhZ3MzID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3M7XG5cbiAgICAgICAgaWYgKF9mbGFnczMgJiBTaG91bGRDYXB0dXJlKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBfZmxhZ3MzICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlOyAvLyBDYXB0dXJlZCBhIHN1c3BlbnNlIGVmZmVjdC4gUmUtcmVuZGVyIHRoZSBib3VuZGFyeS5cblxuICAgICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2FjaGVDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcENhY2hlUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgVHJhY2luZ01hcmtlckNvbXBvbmVudDpcblxuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW53aW5kSW50ZXJydXB0ZWRXb3JrKGN1cnJlbnQsIGludGVycnVwdGVkV29yaywgcmVuZGVyTGFuZXMpIHtcbiAgLy8gTm90ZTogVGhpcyBpbnRlbnRpb25hbGx5IGRvZXNuJ3QgY2hlY2sgaWYgd2UncmUgaHlkcmF0aW5nIGJlY2F1c2UgY29tcGFyaW5nXG4gIC8vIHRvIHRoZSBjdXJyZW50IHRyZWUgcHJvdmlkZXIgZmliZXIgaXMganVzdCBhcyBmYXN0IGFuZCBsZXNzIGVycm9yLXByb25lLlxuICAvLyBJZGVhbGx5IHdlIHdvdWxkIGhhdmUgYSBzcGVjaWFsIHZlcnNpb24gb2YgdGhlIHdvcmsgbG9vcCBvbmx5XG4gIC8vIGZvciBoeWRyYXRpb24uXG4gIHBvcFRyZWVDb250ZXh0KGludGVycnVwdGVkV29yayk7XG5cbiAgc3dpdGNoIChpbnRlcnJ1cHRlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG5cbiAgICAgICAge1xuICAgICAgICAgIHBvcENhY2hlUHJvdmlkZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgfVxuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKGludGVycnVwdGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0SG9pc3RhYmxlOlxuICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcG9wSG9zdENvbnRhaW5lcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKGludGVycnVwdGVkV29yayk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgcG9wU3VzcGVuc2VMaXN0Q29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIHZhciBjb250ZXh0O1xuXG4gICAgICB7XG4gICAgICAgIGNvbnRleHQgPSBpbnRlcnJ1cHRlZFdvcmsudHlwZTtcbiAgICAgIH1cblxuICAgICAgcG9wUHJvdmlkZXIoY29udGV4dCwgaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICBwb3BTdXNwZW5zZUhhbmRsZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIHBvcEhpZGRlbkNvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIHBvcFRyYW5zaXRpb24oaW50ZXJydXB0ZWRXb3JrLCBjdXJyZW50KTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBDYWNoZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wQ2FjaGVQcm92aWRlcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgfVxufVxuXG52YXIgZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGUgPSBudWxsO1xuXG57XG4gIGRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlID0gbmV3IFNldCgpO1xufSAvLyBVc2VkIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlIHRvIHRyYWNrIHRoZSBzdGF0ZSBvZiB0aGUgT2Zmc2NyZWVuIGNvbXBvbmVudCBzdGFjay5cbi8vIEFsbG93cyB1cyB0byBhdm9pZCB0cmF2ZXJzaW5nIHRoZSByZXR1cm4gcGF0aCB0byBmaW5kIHRoZSBuZWFyZXN0IE9mZnNjcmVlbiBhbmNlc3Rvci5cblxuXG52YXIgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gZmFsc2U7XG52YXIgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IGZhbHNlOyAvLyBVc2VkIHRvIHRyYWNrIGlmIGEgZm9ybSBuZWVkcyB0byBiZSByZXNldCBhdCB0aGUgZW5kIG9mIHRoZSBtdXRhdGlvbiBwaGFzZS5cblxudmFyIG5lZWRzRm9ybVJlc2V0ID0gZmFsc2U7XG52YXIgUG9zc2libHlXZWFrU2V0ID0gdHlwZW9mIFdlYWtTZXQgPT09ICdmdW5jdGlvbicgPyBXZWFrU2V0IDogU2V0O1xudmFyIG5leHRFZmZlY3QgPSBudWxsOyAvLyBVc2VkIGZvciBQcm9maWxpbmcgYnVpbGRzIHRvIHRyYWNrIHVwZGF0ZXJzLlxuXG52YXIgaW5Qcm9ncmVzc0xhbmVzID0gbnVsbDtcbnZhciBpblByb2dyZXNzUm9vdCA9IG51bGw7XG5cbmZ1bmN0aW9uIHNob3VsZFByb2ZpbGUoY3VycmVudCkge1xuICByZXR1cm4gKGN1cnJlbnQubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlICYmIChnZXRFeGVjdXRpb25Db250ZXh0KCkgJiBDb21taXRDb250ZXh0KSAhPT0gTm9Db250ZXh0O1xufVxuXG5mdW5jdGlvbiBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRXaXRoVGltZXIoY3VycmVudCwgaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UucHJvcHMgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhjdXJyZW50LnR5cGUsIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyk7XG4gIGluc3RhbmNlLnN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChzaG91bGRQcm9maWxlKGN1cnJlbnQpKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGN1cnJlbnQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICB9XG59IC8vIENhcHR1cmUgZXJyb3JzIHNvIHRoZXkgZG9uJ3QgaW50ZXJydXB0IHVubW91bnRpbmcuXG5cblxuZnVuY3Rpb24gc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGluc3RhbmNlKSB7XG4gIHRyeSB7XG4gICAgY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyKGN1cnJlbnQsIGluc3RhbmNlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvcik7XG4gIH1cbn0gLy8gQ2FwdHVyZSBlcnJvcnMgc28gdGhleSBkb24ndCBpbnRlcnJ1cHQgbW91bnRpbmcuXG5cblxuZnVuY3Rpb24gc2FmZWx5QXR0YWNoUmVmKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcbiAgdHJ5IHtcbiAgICBjb21taXRBdHRhY2hSZWYoY3VycmVudCk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gIHZhciByZWYgPSBjdXJyZW50LnJlZjtcbiAgdmFyIHJlZkNsZWFudXAgPSBjdXJyZW50LnJlZkNsZWFudXA7XG5cbiAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgcmVmQ2xlYW51cCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHNob3VsZFByb2ZpbGUoY3VycmVudCkpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICAgICAgcmVmQ2xlYW51cCgpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihjdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVmQ2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvcik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICAvLyBgcmVmQ2xlYW51cGAgaGFzIGJlZW4gY2FsbGVkLiBOdWxsaWZ5IGFsbCByZWZlcmVuY2VzIHRvIGl0IHRvIHByZXZlbnQgZG91YmxlIGludm9jYXRpb24uXG4gICAgICAgIGN1cnJlbnQucmVmQ2xlYW51cCA9IG51bGw7XG4gICAgICAgIHZhciBmaW5pc2hlZFdvcmsgPSBjdXJyZW50LmFsdGVybmF0ZTtcblxuICAgICAgICBpZiAoZmluaXNoZWRXb3JrICE9IG51bGwpIHtcbiAgICAgICAgICBmaW5pc2hlZFdvcmsucmVmQ2xlYW51cCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChzaG91bGRQcm9maWxlKGN1cnJlbnQpKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICAgIHJlZihudWxsKTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oY3VycmVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlZihudWxsKTtcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIHVuYWJsZSB0byBuYXJyb3cgdHlwZSB0byBSZWZPYmplY3RcbiAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2FmZWx5Q2FsbERlc3Ryb3koY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVzdHJveSkge1xuICB0cnkge1xuICAgIGRlc3Ryb3koKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvcik7XG4gIH1cbn1cbnZhciBzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIgPSBmYWxzZTtcbmZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaXJzdENoaWxkKSB7XG4gIHByZXBhcmVGb3JDb21taXQocm9vdC5jb250YWluZXJJbmZvKTtcbiAgbmV4dEVmZmVjdCA9IGZpcnN0Q2hpbGQ7XG4gIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c19iZWdpbigpOyAvLyBXZSBubyBsb25nZXIgbmVlZCB0byB0cmFjayB0aGUgYWN0aXZlIGluc3RhbmNlIGZpYmVyXG5cbiAgdmFyIHNob3VsZEZpcmUgPSBzaG91bGRGaXJlQWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXI7XG4gIHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciA9IGZhbHNlO1xuICByZXR1cm4gc2hvdWxkRmlyZTtcbn1cblxuZnVuY3Rpb24gY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzX2JlZ2luKCkge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7IC8vIFRoaXMgcGhhc2UgaXMgb25seSB1c2VkIGZvciBiZWZvcmVBY3RpdmVJbnN0YW5jZUJsdXIuXG5cbiAgICB2YXIgY2hpbGQgPSBmaWJlci5jaGlsZDtcblxuICAgIGlmICgoZmliZXIuc3VidHJlZUZsYWdzICYgQmVmb3JlTXV0YXRpb25NYXNrKSAhPT0gTm9GbGFncyQxICYmIGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBjaGlsZC5yZXR1cm4gPSBmaWJlcjtcbiAgICAgIG5leHRFZmZlY3QgPSBjaGlsZDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzX2NvbXBsZXRlKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c19jb21wbGV0ZSgpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0O1xuICAgIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoZmliZXIpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c09uRmliZXIoZmliZXIpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaWJlciwgZmliZXIucmV0dXJuLCBlcnJvcik7XG4gICAgfVxuXG4gICAgcmVzZXRDdXJyZW50RGVidWdGaWJlckluREVWKCk7XG4gICAgdmFyIHNpYmxpbmcgPSBmaWJlci5zaWJsaW5nO1xuXG4gICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgIHNpYmxpbmcucmV0dXJuID0gZmliZXIucmV0dXJuO1xuICAgICAgbmV4dEVmZmVjdCA9IHNpYmxpbmc7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbmV4dEVmZmVjdCA9IGZpYmVyLnJldHVybjtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHNPbkZpYmVyKGZpbmlzaGVkV29yaykge1xuICB2YXIgY3VycmVudCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG4gIHZhciBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcblxuICBpZiAoKGZsYWdzICYgU25hcHNob3QpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKGZpbmlzaGVkV29yayk7XG4gIH1cblxuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBpZiAoKGZsYWdzICYgU25hcHNob3QpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlOyAvLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG4gICAgICAgICAgICAvLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cbiAgICAgICAgICAgIC8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHdlIGltcGxlbWVudCByZXN1bWluZy5cblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoIWZpbmlzaGVkV29yay50eXBlLmRlZmF1bHRQcm9wcyAmJiAhKCdyZWYnIGluIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKSAmJiAhZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcykge1xuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5wcm9wcyAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJyArICdnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZS4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcgKyAnZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBzbmFwc2hvdCA9IGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKGZpbmlzaGVkV29yay50eXBlLCBwcmV2UHJvcHMpLCBwcmV2U3RhdGUpO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBkaWRXYXJuU2V0ID0gZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGU7XG5cbiAgICAgICAgICAgICAgaWYgKHNuYXBzaG90ID09PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5TZXQuaGFzKGZpbmlzaGVkV29yay50eXBlKSkge1xuICAgICAgICAgICAgICAgIGRpZFdhcm5TZXQuYWRkKGZpbmlzaGVkV29yay50eXBlKTtcblxuICAgICAgICAgICAgICAgIGVycm9yKCclcy5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpOiBBIHNuYXBzaG90IHZhbHVlIChvciBudWxsKSAnICsgJ211c3QgYmUgcmV0dXJuZWQuIFlvdSBoYXZlIHJldHVybmVkIHVuZGVmaW5lZC4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGluc3RhbmNlLl9fcmVhY3RJbnRlcm5hbFNuYXBzaG90QmVmb3JlVXBkYXRlID0gc25hcHNob3Q7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICBpZiAoKGZsYWdzICYgU25hcHNob3QpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgICAgICAgICAgdmFyIHJvb3QgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgY2xlYXJDb250YWluZXIocm9vdC5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICBjYXNlIEhvc3RIb2lzdGFibGU6XG4gICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgIGNhc2UgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50OlxuICAgICAgLy8gTm90aGluZyB0byBkbyBmb3IgdGhlc2UgY29tcG9uZW50IHR5cGVzXG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIGlmICgoZmxhZ3MgJiBTbmFwc2hvdCkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhpcyB1bml0IG9mIHdvcmsgdGFnIHNob3VsZCBub3QgaGF2ZSBzaWRlLWVmZmVjdHMuIFRoaXMgZXJyb3IgaXMgJyArICdsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICB9XG5cbiAgaWYgKChmbGFncyAmIFNuYXBzaG90KSAhPT0gTm9GbGFncyQxKSB7XG4gICAgcmVzZXRDdXJyZW50RGVidWdGaWJlckluREVWKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KGZsYWdzLCBmaW5pc2hlZFdvcmssIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcbiAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICB2YXIgbGFzdEVmZmVjdCA9IHVwZGF0ZVF1ZXVlICE9PSBudWxsID8gdXBkYXRlUXVldWUubGFzdEVmZmVjdCA6IG51bGw7XG5cbiAgaWYgKGxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgdmFyIGVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuXG4gICAgZG8ge1xuICAgICAgaWYgKChlZmZlY3QudGFnICYgZmxhZ3MpID09PSBmbGFncykge1xuICAgICAgICAvLyBVbm1vdW50XG4gICAgICAgIHZhciBpbnN0ID0gZWZmZWN0Lmluc3Q7XG4gICAgICAgIHZhciBkZXN0cm95ID0gaW5zdC5kZXN0cm95O1xuXG4gICAgICAgIGlmIChkZXN0cm95ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpbnN0LmRlc3Ryb3kgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgUGFzc2l2ZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICAgICAgbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RhcnRlZChmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoZmxhZ3MgJiBMYXlvdXQpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgICAgIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZChmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICgoZmxhZ3MgJiBJbnNlcnRpb24pICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgICAgIHNldElzUnVubmluZ0luc2VydGlvbkVmZmVjdCh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBzYWZlbHlDYWxsRGVzdHJveShmaW5pc2hlZFdvcmssIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlc3Ryb3kpO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKChmbGFncyAmIEluc2VydGlvbikgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICAgICAgc2V0SXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0KGZhbHNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgUGFzc2l2ZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICAgICAgbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RvcHBlZCgpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoZmxhZ3MgJiBMYXlvdXQpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgICAgIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBlZmZlY3QgPSBlZmZlY3QubmV4dDtcbiAgICB9IHdoaWxlIChlZmZlY3QgIT09IGZpcnN0RWZmZWN0KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KGZsYWdzLCBmaW5pc2hlZFdvcmspIHtcbiAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuICB2YXIgbGFzdEVmZmVjdCA9IHVwZGF0ZVF1ZXVlICE9PSBudWxsID8gdXBkYXRlUXVldWUubGFzdEVmZmVjdCA6IG51bGw7XG5cbiAgaWYgKGxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmlyc3RFZmZlY3QgPSBsYXN0RWZmZWN0Lm5leHQ7XG4gICAgdmFyIGVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuXG4gICAgZG8ge1xuICAgICAgaWYgKChlZmZlY3QudGFnICYgZmxhZ3MpID09PSBmbGFncykge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKChmbGFncyAmIFBhc3NpdmUpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgICBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RhcnRlZChmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKGZsYWdzICYgTGF5b3V0KSAhPT0gTm9GbGFncykge1xuICAgICAgICAgICAgbWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RhcnRlZChmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBNb3VudFxuXG5cbiAgICAgICAgdmFyIGNyZWF0ZSA9IGVmZmVjdC5jcmVhdGU7XG5cbiAgICAgICAge1xuICAgICAgICAgIGlmICgoZmxhZ3MgJiBJbnNlcnRpb24pICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgICBzZXRJc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QodHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGluc3QgPSBlZmZlY3QuaW5zdDtcbiAgICAgICAgdmFyIGRlc3Ryb3kgPSBjcmVhdGUoKTtcbiAgICAgICAgaW5zdC5kZXN0cm95ID0gZGVzdHJveTtcblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKChmbGFncyAmIEluc2VydGlvbikgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICAgIHNldElzUnVubmluZ0luc2VydGlvbkVmZmVjdChmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgIGlmICgoZmxhZ3MgJiBQYXNzaXZlKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgICAgbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKChmbGFncyAmIExheW91dCkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICAgIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKGRlc3Ryb3kgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZGVzdHJveSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGhvb2tOYW1lID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBpZiAoKGVmZmVjdC50YWcgJiBMYXlvdXQpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgICAgICAgaG9va05hbWUgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoKGVmZmVjdC50YWcgJiBJbnNlcnRpb24pICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgICAgICAgaG9va05hbWUgPSAndXNlSW5zZXJ0aW9uRWZmZWN0JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGhvb2tOYW1lID0gJ3VzZUVmZmVjdCc7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBhZGRlbmR1bSA9IHZvaWQgMDtcblxuICAgICAgICAgICAgaWYgKGRlc3Ryb3kgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgYWRkZW5kdW0gPSAnIFlvdSByZXR1cm5lZCBudWxsLiBJZiB5b3VyIGVmZmVjdCBkb2VzIG5vdCByZXF1aXJlIGNsZWFuICcgKyAndXAsIHJldHVybiB1bmRlZmluZWQgKG9yIG5vdGhpbmcpLic7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZXN0cm95LnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgYWRkZW5kdW0gPSAnXFxuXFxuSXQgbG9va3MgbGlrZSB5b3Ugd3JvdGUgJyArIGhvb2tOYW1lICsgJyhhc3luYyAoKSA9PiAuLi4pIG9yIHJldHVybmVkIGEgUHJvbWlzZS4gJyArICdJbnN0ZWFkLCB3cml0ZSB0aGUgYXN5bmMgZnVuY3Rpb24gaW5zaWRlIHlvdXIgZWZmZWN0ICcgKyAnYW5kIGNhbGwgaXQgaW1tZWRpYXRlbHk6XFxuXFxuJyArIGhvb2tOYW1lICsgJygoKSA9PiB7XFxuJyArICcgIGFzeW5jIGZ1bmN0aW9uIGZldGNoRGF0YSgpIHtcXG4nICsgJyAgICAvLyBZb3UgY2FuIGF3YWl0IGhlcmVcXG4nICsgJyAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IE15QVBJLmdldERhdGEoc29tZUlkKTtcXG4nICsgJyAgICAvLyAuLi5cXG4nICsgJyAgfVxcbicgKyAnICBmZXRjaERhdGEoKTtcXG4nICsgXCJ9LCBbc29tZUlkXSk7IC8vIE9yIFtdIGlmIGVmZmVjdCBkb2Vzbid0IG5lZWQgcHJvcHMgb3Igc3RhdGVcXG5cXG5cIiArICdMZWFybiBtb3JlIGFib3V0IGRhdGEgZmV0Y2hpbmcgd2l0aCBIb29rczogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9ob29rcy1kYXRhLWZldGNoaW5nJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGFkZGVuZHVtID0gJyBZb3UgcmV0dXJuZWQ6ICcgKyBkZXN0cm95O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlcnJvcignJXMgbXVzdCBub3QgcmV0dXJuIGFueXRoaW5nIGJlc2lkZXMgYSBmdW5jdGlvbiwgJyArICd3aGljaCBpcyB1c2VkIGZvciBjbGVhbi11cC4lcycsIGhvb2tOYW1lLCBhZGRlbmR1bSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVmZmVjdCA9IGVmZmVjdC5uZXh0O1xuICAgIH0gd2hpbGUgKGVmZmVjdCAhPT0gZmlyc3RFZmZlY3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVFZmZlY3REdXJhdGlvbnMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspIHtcbiAgaWYgKGdldEV4ZWN1dGlvbkNvbnRleHQoKSAmIENvbW1pdENvbnRleHQpIHtcbiAgICAvLyBPbmx5IFByb2ZpbGVycyB3aXRoIHdvcmsgaW4gdGhlaXIgc3VidHJlZSB3aWxsIGhhdmUgYW4gVXBkYXRlIGVmZmVjdCBzY2hlZHVsZWQuXG4gICAgaWYgKChmaW5pc2hlZFdvcmsuZmxhZ3MgJiBVcGRhdGUpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwYXNzaXZlRWZmZWN0RHVyYXRpb24gPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbjtcbiAgICAgICAgICAgIHZhciBfZmluaXNoZWRXb3JrJG1lbW9pemUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgICAgICAgICBpZCA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZS5pZCxcbiAgICAgICAgICAgICAgICBvblBvc3RDb21taXQgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUub25Qb3N0Q29tbWl0OyAvLyBUaGlzIHZhbHVlIHdpbGwgc3RpbGwgcmVmbGVjdCB0aGUgcHJldmlvdXMgY29tbWl0IHBoYXNlLlxuICAgICAgICAgICAgLy8gSXQgZG9lcyBub3QgZ2V0IHJlc2V0IHVudGlsIHRoZSBzdGFydCBvZiB0aGUgbmV4dCBjb21taXQgcGhhc2UuXG5cbiAgICAgICAgICAgIHZhciBjb21taXRUaW1lID0gZ2V0Q29tbWl0VGltZSgpO1xuICAgICAgICAgICAgdmFyIHBoYXNlID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZSA9PT0gbnVsbCA/ICdtb3VudCcgOiAndXBkYXRlJztcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoaXNDdXJyZW50VXBkYXRlTmVzdGVkKCkpIHtcbiAgICAgICAgICAgICAgICBwaGFzZSA9ICduZXN0ZWQtdXBkYXRlJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mIG9uUG9zdENvbW1pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBvblBvc3RDb21taXQoaWQsIHBoYXNlLCBwYXNzaXZlRWZmZWN0RHVyYXRpb24sIGNvbW1pdFRpbWUpO1xuICAgICAgICAgICAgfSAvLyBCdWJibGUgdGltZXMgdG8gdGhlIG5leHQgbmVhcmVzdCBhbmNlc3RvciBQcm9maWxlci5cbiAgICAgICAgICAgIC8vIEFmdGVyIHdlIHByb2Nlc3MgdGhhdCBQcm9maWxlciwgd2UnbGwgYnViYmxlIGZ1cnRoZXIgdXAuXG5cblxuICAgICAgICAgICAgdmFyIHBhcmVudEZpYmVyID0gZmluaXNoZWRXb3JrLnJldHVybjtcblxuICAgICAgICAgICAgb3V0ZXI6IHdoaWxlIChwYXJlbnRGaWJlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBzd2l0Y2ggKHBhcmVudEZpYmVyLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICAgICAgICB2YXIgcm9vdCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgICAgIHJvb3QucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9IHBhc3NpdmVFZmZlY3REdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuXG4gICAgICAgICAgICAgICAgY2FzZSBQcm9maWxlcjpcbiAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRTdGF0ZU5vZGUgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgICBwYXJlbnRTdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uICs9IHBhc3NpdmVFZmZlY3REdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5yZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0SG9va0xheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrLCBob29rRmxhZ3MpIHtcbiAgLy8gQXQgdGhpcyBwb2ludCBsYXlvdXQgZWZmZWN0cyBoYXZlIGFscmVhZHkgYmVlbiBkZXN0cm95ZWQgKGR1cmluZyBtdXRhdGlvbiBwaGFzZSkuXG4gIC8vIFRoaXMgaXMgZG9uZSB0byBwcmV2ZW50IHNpYmxpbmcgY29tcG9uZW50IGVmZmVjdHMgZnJvbSBpbnRlcmZlcmluZyB3aXRoIGVhY2ggb3RoZXIsXG4gIC8vIGUuZy4gYSBkZXN0cm95IGZ1bmN0aW9uIGluIG9uZSBjb21wb25lbnQgc2hvdWxkIG5ldmVyIG92ZXJyaWRlIGEgcmVmIHNldFxuICAvLyBieSBhIGNyZWF0ZSBmdW5jdGlvbiBpbiBhbm90aGVyIGNvbXBvbmVudCBkdXJpbmcgdGhlIHNhbWUgY29tbWl0LlxuICBpZiAoc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspKSB7XG4gICAgdHJ5IHtcbiAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoaG9va0ZsYWdzLCBmaW5pc2hlZFdvcmspO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICB9XG5cbiAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KGhvb2tGbGFncywgZmluaXNoZWRXb3JrKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdENsYXNzTGF5b3V0TGlmZWN5Y2xlcyhmaW5pc2hlZFdvcmssIGN1cnJlbnQpIHtcbiAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAvLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cbiAgICAvLyBUT0RPOiByZXZpc2l0IHRoaXMgd2hlbiB3ZSBpbXBsZW1lbnQgcmVzdW1pbmcuXG4gICAge1xuICAgICAgaWYgKCFmaW5pc2hlZFdvcmsudHlwZS5kZWZhdWx0UHJvcHMgJiYgISgncmVmJyBpbiBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykgJiYgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJyArICdjb21wb25lbnREaWRNb3VudC4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMucHJvcHNgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgc3RhdGUgdG8gbWF0Y2ggbWVtb2l6ZWQgc3RhdGUgYmVmb3JlICcgKyAnY29tcG9uZW50RGlkTW91bnQuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGFydExheW91dEVmZmVjdFRpbWVyKCk7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50KCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oZmluaXNoZWRXb3JrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgcHJldlByb3BzID0gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoZmluaXNoZWRXb3JrLnR5cGUsIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyk7XG4gICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTsgLy8gV2UgY291bGQgdXBkYXRlIGluc3RhbmNlIHByb3BzIGFuZCBzdGF0ZSBoZXJlLFxuICAgIC8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuICAgIC8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHdlIGltcGxlbWVudCByZXN1bWluZy5cblxuICAgIHtcbiAgICAgIGlmICghZmluaXNoZWRXb3JrLnR5cGUuZGVmYXVsdFByb3BzICYmICEoJ3JlZicgaW4gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpICYmICFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5wcm9wcyAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpIHtcbiAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgJyArICdjb21wb25lbnREaWRVcGRhdGUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspKSB7XG4gICAgICB0cnkge1xuICAgICAgICBzdGFydExheW91dEVmZmVjdFRpbWVyKCk7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSwgaW5zdGFuY2UuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICB9XG5cbiAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZShwcmV2UHJvcHMsIHByZXZTdGF0ZSwgaW5zdGFuY2UuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdENsYXNzQ2FsbGJhY2tzKGZpbmlzaGVkV29yaykge1xuICAvLyBUT0RPOiBJIHRoaW5rIHRoaXMgaXMgbm93IGFsd2F5cyBub24tbnVsbCBieSB0aGUgdGltZSBpdCByZWFjaGVzIHRoZVxuICAvLyBjb21taXQgcGhhc2UuIENvbnNpZGVyIHJlbW92aW5nIHRoZSB0eXBlIGNoZWNrLlxuICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG5cbiAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgIHtcbiAgICAgIGlmICghZmluaXNoZWRXb3JrLnR5cGUuZGVmYXVsdFByb3BzICYmICEoJ3JlZicgaW4gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpICYmICFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZS5wcm9wcyAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpIHtcbiAgICAgICAgICBlcnJvcignRXhwZWN0ZWQgJXMgcHJvcHMgdG8gbWF0Y2ggbWVtb2l6ZWQgcHJvcHMgYmVmb3JlICcgKyAncHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgJyArICdwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnN0YXRlYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAvLyBidXQgaW5zdGVhZCB3ZSByZWx5IG9uIHRoZW0gYmVpbmcgc2V0IGR1cmluZyBsYXN0IHJlbmRlci5cbiAgICAvLyBUT0RPOiByZXZpc2l0IHRoaXMgd2hlbiB3ZSBpbXBsZW1lbnQgcmVzdW1pbmcuXG5cblxuICAgIHRyeSB7XG4gICAgICBjb21taXRDYWxsYmFja3ModXBkYXRlUXVldWUsIGluc3RhbmNlKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEhvc3RDb21wb25lbnRNb3VudChmaW5pc2hlZFdvcmspIHtcbiAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZTtcbiAgdmFyIHByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG4gIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cbiAgdHJ5IHtcbiAgICBjb21taXRNb3VudChpbnN0YW5jZSwgdHlwZSwgcHJvcHMsIGZpbmlzaGVkV29yayk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UHJvZmlsZXJVcGRhdGUoZmluaXNoZWRXb3JrLCBjdXJyZW50KSB7XG4gIGlmIChnZXRFeGVjdXRpb25Db250ZXh0KCkgJiBDb21taXRDb250ZXh0KSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBfZmluaXNoZWRXb3JrJG1lbW9pemUyID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMsXG4gICAgICAgICAgb25Db21taXQgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUyLm9uQ29tbWl0LFxuICAgICAgICAgIG9uUmVuZGVyID0gX2ZpbmlzaGVkV29yayRtZW1vaXplMi5vblJlbmRlcjtcbiAgICAgIHZhciBlZmZlY3REdXJhdGlvbiA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb247XG4gICAgICB2YXIgY29tbWl0VGltZSA9IGdldENvbW1pdFRpbWUoKTtcbiAgICAgIHZhciBwaGFzZSA9IGN1cnJlbnQgPT09IG51bGwgPyAnbW91bnQnIDogJ3VwZGF0ZSc7XG5cbiAgICAgIGlmIChlbmFibGVQcm9maWxlck5lc3RlZFVwZGF0ZVBoYXNlKSB7XG4gICAgICAgIGlmIChpc0N1cnJlbnRVcGRhdGVOZXN0ZWQoKSkge1xuICAgICAgICAgIHBoYXNlID0gJ25lc3RlZC11cGRhdGUnO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2Ygb25SZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb25SZW5kZXIoZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMuaWQsIHBoYXNlLCBmaW5pc2hlZFdvcmsuYWN0dWFsRHVyYXRpb24sIGZpbmlzaGVkV29yay50cmVlQmFzZUR1cmF0aW9uLCBmaW5pc2hlZFdvcmsuYWN0dWFsU3RhcnRUaW1lLCBjb21taXRUaW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyQ29tbWl0SG9va3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvbkNvbW1pdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIG9uQ29tbWl0KGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLmlkLCBwaGFzZSwgZWZmZWN0RHVyYXRpb24sIGNvbW1pdFRpbWUpO1xuICAgICAgICB9IC8vIFNjaGVkdWxlIGEgcGFzc2l2ZSBlZmZlY3QgZm9yIHRoaXMgUHJvZmlsZXIgdG8gY2FsbCBvblBvc3RDb21taXQgaG9va3MuXG4gICAgICAgIC8vIFRoaXMgZWZmZWN0IHNob3VsZCBiZSBzY2hlZHVsZWQgZXZlbiBpZiB0aGVyZSBpcyBubyBvblBvc3RDb21taXQgY2FsbGJhY2sgZm9yIHRoaXMgUHJvZmlsZXIsXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGVmZmVjdCBpcyBhbHNvIHdoZXJlIHRpbWVzIGJ1YmJsZSB0byBwYXJlbnQgUHJvZmlsZXJzLlxuXG5cbiAgICAgICAgZW5xdWV1ZVBlbmRpbmdQYXNzaXZlUHJvZmlsZXJFZmZlY3QoZmluaXNoZWRXb3JrKTsgLy8gUHJvcGFnYXRlIGxheW91dCBlZmZlY3QgZHVyYXRpb25zIHRvIHRoZSBuZXh0IG5lYXJlc3QgUHJvZmlsZXIgYW5jZXN0b3IuXG4gICAgICAgIC8vIERvIG5vdCByZXNldCB0aGVzZSB2YWx1ZXMgdW50aWwgdGhlIG5leHQgcmVuZGVyIHNvIERldlRvb2xzIGhhcyBhIGNoYW5jZSB0byByZWFkIHRoZW0gZmlyc3QuXG5cbiAgICAgICAgdmFyIHBhcmVudEZpYmVyID0gZmluaXNoZWRXb3JrLnJldHVybjtcblxuICAgICAgICBvdXRlcjogd2hpbGUgKHBhcmVudEZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgc3dpdGNoIChwYXJlbnRGaWJlci50YWcpIHtcbiAgICAgICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgICAgIHZhciByb290ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICByb290LmVmZmVjdER1cmF0aW9uICs9IGVmZmVjdER1cmF0aW9uO1xuICAgICAgICAgICAgICBicmVhayBvdXRlcjtcblxuICAgICAgICAgICAgY2FzZSBQcm9maWxlcjpcbiAgICAgICAgICAgICAgdmFyIHBhcmVudFN0YXRlTm9kZSA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgcGFyZW50U3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uICs9IGVmZmVjdER1cmF0aW9uO1xuICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlcihmaW5pc2hlZFJvb3QsIGN1cnJlbnQsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMpIHtcbiAgLy8gV2hlbiB1cGRhdGluZyB0aGlzIGZ1bmN0aW9uLCBhbHNvIHVwZGF0ZSByZWFwcGVhckxheW91dEVmZmVjdHMsIHdoaWNoIGRvZXNcbiAgLy8gbW9zdCBvZiB0aGUgc2FtZSB0aGluZ3Mgd2hlbiBhbiBvZmZzY3JlZW4gdHJlZSBnb2VzIGZyb20gaGlkZGVuIC0+IHZpc2libGUuXG4gIHZhciBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcblxuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcblxuICAgICAgICBpZiAoZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICBjb21taXRIb29rTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmssIExheW91dCB8IEhhc0VmZmVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcblxuICAgICAgICBpZiAoZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICBjb21taXRDbGFzc0xheW91dExpZmVjeWNsZXMoZmluaXNoZWRXb3JrLCBjdXJyZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbGFncyAmIENhbGxiYWNrKSB7XG4gICAgICAgICAgY29tbWl0Q2xhc3NDYWxsYmFja3MoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbGFncyAmIFJlZikge1xuICAgICAgICAgIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgQ2FsbGJhY2spIHtcbiAgICAgICAgICAvLyBUT0RPOiBJIHRoaW5rIHRoaXMgaXMgbm93IGFsd2F5cyBub24tbnVsbCBieSB0aGUgdGltZSBpdCByZWFjaGVzIHRoZVxuICAgICAgICAgIC8vIGNvbW1pdCBwaGFzZS4gQ29uc2lkZXIgcmVtb3ZpbmcgdGhlIHR5cGUgY2hlY2suXG4gICAgICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBudWxsO1xuXG4gICAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLmNoaWxkLnRhZykge1xuICAgICAgICAgICAgICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICAgICAgICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IGdldFB1YmxpY0luc3RhbmNlKGZpbmlzaGVkV29yay5jaGlsZC5zdGF0ZU5vZGUpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgICAgICAgICAgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuY2hpbGQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29tbWl0Q2FsbGJhY2tzKHVwZGF0ZVF1ZXVlLCBpbnN0YW5jZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdEhvaXN0YWJsZTpcbiAgICAgIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzUmVzb3VyY2VzKSB7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuXG4gICAgICAgICAgaWYgKGZsYWdzICYgUmVmKSB7XG4gICAgICAgICAgICBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSAvLyBGYWxsIHRocm91Z2hcblxuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspOyAvLyBSZW5kZXJlcnMgbWF5IHNjaGVkdWxlIHdvcmsgdG8gYmUgZG9uZSBhZnRlciBob3N0IGNvbXBvbmVudHMgYXJlIG1vdW50ZWRcbiAgICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBtYXkgc2NoZWR1bGUgYXV0by1mb2N1cyBmb3IgaW5wdXRzIGFuZCBmb3JtIGNvbnRyb2xzKS5cbiAgICAgICAgLy8gVGhlc2UgZWZmZWN0cyBzaG91bGQgb25seSBiZSBjb21taXR0ZWQgd2hlbiBjb21wb25lbnRzIGFyZSBmaXJzdCBtb3VudGVkLFxuICAgICAgICAvLyBha2Egd2hlbiB0aGVyZSBpcyBubyBjdXJyZW50L2FsdGVybmF0ZS5cblxuICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCAmJiBmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIGNvbW1pdEhvc3RDb21wb25lbnRNb3VudChmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZsYWdzICYgUmVmKSB7XG4gICAgICAgICAgc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTsgLy8gVE9ETzogU2hvdWxkIHRoaXMgZmlyZSBpbnNpZGUgYW4gb2Zmc2NyZWVuIHRyZWU/IE9yIHNob3VsZCBpdCB3YWl0IHRvXG4gICAgICAgIC8vIGZpcmUgd2hlbiB0aGUgdHJlZSBiZWNvbWVzIHZpc2libGUgYWdhaW4uXG5cbiAgICAgICAgaWYgKGZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgY29tbWl0UHJvZmlsZXJVcGRhdGUoZmluaXNoZWRXb3JrLCBjdXJyZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIGNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBpc01vZGVyblJvb3QgPSBkaXNhYmxlTGVnYWN5TW9kZSA7XG5cbiAgICAgICAgaWYgKGlzTW9kZXJuUm9vdCkge1xuICAgICAgICAgIHZhciBpc0hpZGRlbiA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuICAgICAgICAgIHZhciBuZXdPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBpc0hpZGRlbiB8fCBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG5cbiAgICAgICAgICBpZiAobmV3T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuKSA7IGVsc2Uge1xuICAgICAgICAgICAgLy8gVGhlIE9mZnNjcmVlbiB0cmVlIGlzIHZpc2libGUuXG4gICAgICAgICAgICB2YXIgd2FzSGlkZGVuID0gY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50Lm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG4gICAgICAgICAgICB2YXIgbmV3T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IHdhc0hpZGRlbiB8fCBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICAgICAgdmFyIHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgICAgICB2YXIgcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gbmV3T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuO1xuICAgICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IG5ld09mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG5cbiAgICAgICAgICAgIGlmIChvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuICYmICFwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbikge1xuICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSByb290IG9mIGEgcmVhcHBlYXJpbmcgYm91bmRhcnkuIEFzIHdlIGNvbnRpbnVlXG4gICAgICAgICAgICAgIC8vIHRyYXZlcnNpbmcgdGhlIGxheW91dCBlZmZlY3RzLCB3ZSBtdXN0IGFsc28gcmUtbW91bnQgbGF5b3V0XG4gICAgICAgICAgICAgIC8vIGVmZmVjdHMgdGhhdCB3ZXJlIHVubW91bnRlZCB3aGVuIHRoZSBPZmZzY3JlZW4gc3VidHJlZSB3YXNcbiAgICAgICAgICAgICAgLy8gaGlkZGVuLiBTbyB0aGlzIGlzIGEgc3VwZXJzZXQgb2YgdGhlIG5vcm1hbCBjb21taXRMYXlvdXRFZmZlY3RzLlxuICAgICAgICAgICAgICB2YXIgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyA9IChmaW5pc2hlZFdvcmsuc3VidHJlZUZsYWdzICYgTGF5b3V0TWFzaykgIT09IE5vRmxhZ3MkMTtcbiAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbGFncyAmIFJlZikge1xuICAgICAgICAgIHZhciBwcm9wcyA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzO1xuXG4gICAgICAgICAgaWYgKHByb3BzLm1vZGUgPT09ICdtYW51YWwnKSB7XG4gICAgICAgICAgICBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGhpZGVPclVuaGlkZUFsbENoaWxkcmVuKGZpbmlzaGVkV29yaywgaXNIaWRkZW4pIHtcbiAgLy8gT25seSBoaWRlIG9yIHVuaGlkZSB0aGUgdG9wLW1vc3QgaG9zdCBub2Rlcy5cbiAgdmFyIGhvc3RTdWJ0cmVlUm9vdCA9IG51bGw7XG5cbiAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBpbnNlcnRlZCBidXQgd2UgbmVlZCB0byByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gZmluaXNoZWRXb3JrO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmIChub2RlLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCAoc3VwcG9ydHNSZXNvdXJjZXMgPyBub2RlLnRhZyA9PT0gSG9zdEhvaXN0YWJsZSA6IGZhbHNlKSB8fCAoc3VwcG9ydHNTaW5nbGV0b25zID8gbm9kZS50YWcgPT09IEhvc3RTaW5nbGV0b24gOiBmYWxzZSkpIHtcbiAgICAgICAgaWYgKGhvc3RTdWJ0cmVlUm9vdCA9PT0gbnVsbCkge1xuICAgICAgICAgIGhvc3RTdWJ0cmVlUm9vdCA9IG5vZGU7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gbm9kZS5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgICAgICAgICBoaWRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdW5oaWRlSW5zdGFuY2Uobm9kZS5zdGF0ZU5vZGUsIG5vZGUubWVtb2l6ZWRQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgaWYgKGhvc3RTdWJ0cmVlUm9vdCA9PT0gbnVsbCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgX2luc3RhbmNlID0gbm9kZS5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgICAgICAgICBoaWRlVGV4dEluc3RhbmNlKF9pbnN0YW5jZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1bmhpZGVUZXh0SW5zdGFuY2UoX2luc3RhbmNlLCBub2RlLm1lbW9pemVkUHJvcHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKG5vZGUudGFnID09PSBPZmZzY3JlZW5Db21wb25lbnQgfHwgbm9kZS50YWcgPT09IExlZ2FjeUhpZGRlbkNvbXBvbmVudCkgJiYgbm9kZS5tZW1vaXplZFN0YXRlICE9PSBudWxsICYmIG5vZGUgIT09IGZpbmlzaGVkV29yaykgOyBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChob3N0U3VidHJlZVJvb3QgPT09IG5vZGUpIHtcbiAgICAgICAgICBob3N0U3VidHJlZVJvb3QgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoaG9zdFN1YnRyZWVSb290ID09PSBub2RlKSB7XG4gICAgICAgIGhvc3RTdWJ0cmVlUm9vdCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEF0dGFjaFJlZihmaW5pc2hlZFdvcmspIHtcbiAgdmFyIHJlZiA9IGZpbmlzaGVkV29yay5yZWY7XG5cbiAgaWYgKHJlZiAhPT0gbnVsbCkge1xuICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgdmFyIGluc3RhbmNlVG9Vc2U7XG5cbiAgICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICAgIGNhc2UgSG9zdEhvaXN0YWJsZTpcbiAgICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgaW5zdGFuY2VUb1VzZSA9IGdldFB1YmxpY0luc3RhbmNlKGluc3RhbmNlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGluc3RhbmNlVG9Vc2UgPSBpbnN0YW5jZTtcbiAgICB9IC8vIE1vdmVkIG91dHNpZGUgdG8gZW5zdXJlIERDRSB3b3JrcyB3aXRoIHRoaXMgZmxhZ1xuXG4gICAgaWYgKHR5cGVvZiByZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaykpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzdGFydExheW91dEVmZmVjdFRpbWVyKCk7XG4gICAgICAgICAgZmluaXNoZWRXb3JrLnJlZkNsZWFudXAgPSByZWYoaW5zdGFuY2VUb1VzZSk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZmluaXNoZWRXb3JrLnJlZkNsZWFudXAgPSByZWYoaW5zdGFuY2VUb1VzZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETzogV2Ugc2hvdWxkIG1vdmUgdGhlc2Ugd2FybmluZ3MgdG8gaGFwcGVuIGR1cmluZyB0aGUgcmVuZGVyXG4gICAgICAgIC8vIHBoYXNlIChtYXJrUmVmKS5cbiAgICAgICAgaWYgKHR5cGVvZiByZWYgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgZXJyb3IoJ1N0cmluZyByZWZzIGFyZSBubyBsb25nZXIgc3VwcG9ydGVkLicpO1xuICAgICAgICB9IGVsc2UgaWYgKCFyZWYuaGFzT3duUHJvcGVydHkoJ2N1cnJlbnQnKSkge1xuICAgICAgICAgIGVycm9yKCdVbmV4cGVjdGVkIHJlZiBvYmplY3QgcHJvdmlkZWQgZm9yICVzLiAnICsgJ1VzZSBlaXRoZXIgYSByZWYtc2V0dGVyIGZ1bmN0aW9uIG9yIFJlYWN0LmNyZWF0ZVJlZigpLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSB1bmFibGUgdG8gbmFycm93IHR5cGUgdG8gdGhlIG5vbi1mdW5jdGlvbiBjYXNlXG5cblxuICAgICAgcmVmLmN1cnJlbnQgPSBpbnN0YW5jZVRvVXNlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRhY2hGaWJlck11dGF0aW9uKGZpYmVyKSB7XG4gIC8vIEN1dCBvZmYgdGhlIHJldHVybiBwb2ludGVyIHRvIGRpc2Nvbm5lY3QgaXQgZnJvbSB0aGUgdHJlZS5cbiAgLy8gVGhpcyBlbmFibGVzIHVzIHRvIGRldGVjdCBhbmQgd2FybiBhZ2FpbnN0IHN0YXRlIHVwZGF0ZXMgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC5cbiAgLy8gSXQgYWxzbyBwcmV2ZW50cyBldmVudHMgZnJvbSBidWJibGluZyBmcm9tIHdpdGhpbiBkaXNjb25uZWN0ZWQgY29tcG9uZW50cy5cbiAgLy9cbiAgLy8gSWRlYWxseSwgd2Ugc2hvdWxkIGFsc28gY2xlYXIgdGhlIGNoaWxkIHBvaW50ZXIgb2YgdGhlIHBhcmVudCBhbHRlcm5hdGUgdG8gbGV0IHRoaXNcbiAgLy8gZ2V0IEdDOmVkIGJ1dCB3ZSBkb24ndCBrbm93IHdoaWNoIGZvciBzdXJlIHdoaWNoIHBhcmVudCBpcyB0aGUgY3VycmVudFxuICAvLyBvbmUgc28gd2UnbGwgc2V0dGxlIGZvciBHQzppbmcgdGhlIHN1YnRyZWUgb2YgdGhpcyBjaGlsZC5cbiAgLy8gVGhpcyBjaGlsZCBpdHNlbGYgd2lsbCBiZSBHQzplZCB3aGVuIHRoZSBwYXJlbnQgdXBkYXRlcyB0aGUgbmV4dCB0aW1lLlxuICAvL1xuICAvLyBOb3RlIHRoYXQgd2UgY2FuJ3QgY2xlYXIgY2hpbGQgb3Igc2libGluZyBwb2ludGVycyB5ZXQuXG4gIC8vIFRoZXkncmUgbmVlZGVkIGZvciBwYXNzaXZlIGVmZmVjdHMgYW5kIGZvciBmaW5kRE9NTm9kZS5cbiAgLy8gV2UgZGVmZXIgdGhvc2UgZmllbGRzLCBhbmQgYWxsIG90aGVyIGNsZWFudXAsIHRvIHRoZSBwYXNzaXZlIHBoYXNlIChzZWUgZGV0YWNoRmliZXJBZnRlckVmZmVjdHMpLlxuICAvL1xuICAvLyBEb24ndCByZXNldCB0aGUgYWx0ZXJuYXRlIHlldCwgZWl0aGVyLiBXZSBuZWVkIHRoYXQgc28gd2UgY2FuIGRldGFjaCB0aGVcbiAgLy8gYWx0ZXJuYXRlJ3MgZmllbGRzIGluIHRoZSBwYXNzaXZlIHBoYXNlLiBDbGVhcmluZyB0aGUgcmV0dXJuIHBvaW50ZXIgaXNcbiAgLy8gc3VmZmljaWVudCBmb3IgZmluZERPTU5vZGUgc2VtYW50aWNzLlxuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICBhbHRlcm5hdGUucmV0dXJuID0gbnVsbDtcbiAgfVxuXG4gIGZpYmVyLnJldHVybiA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKGZpYmVyKSB7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgIGZpYmVyLmFsdGVybmF0ZSA9IG51bGw7XG4gICAgZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoYWx0ZXJuYXRlKTtcbiAgfSAvLyBDbGVhciBjeWNsaWNhbCBGaWJlciBmaWVsZHMuIFRoaXMgbGV2ZWwgYWxvbmUgaXMgZGVzaWduZWQgdG8gcm91Z2hseVxuICAvLyBhcHByb3hpbWF0ZSB0aGUgcGxhbm5lZCBGaWJlciByZWZhY3Rvci4gSW4gdGhhdCB3b3JsZCwgYHNldFN0YXRlYCB3aWxsIGJlXG4gIC8vIGJvdW5kIHRvIGEgc3BlY2lhbCBcImluc3RhbmNlXCIgb2JqZWN0IGluc3RlYWQgb2YgYSBGaWJlci4gVGhlIEluc3RhbmNlXG4gIC8vIG9iamVjdCB3aWxsIG5vdCBoYXZlIGFueSBvZiB0aGVzZSBmaWVsZHMuIEl0IHdpbGwgb25seSBiZSBjb25uZWN0ZWQgdG9cbiAgLy8gdGhlIGZpYmVyIHRyZWUgdmlhIGEgc2luZ2xlIGxpbmsgYXQgdGhlIHJvb3QuIFNvIGlmIHRoaXMgbGV2ZWwgYWxvbmUgaXNcbiAgLy8gc3VmZmljaWVudCB0byBmaXggbWVtb3J5IGlzc3VlcywgdGhhdCBib2RlcyB3ZWxsIGZvciBvdXIgcGxhbnMuXG5cblxuICBmaWJlci5jaGlsZCA9IG51bGw7XG4gIGZpYmVyLmRlbGV0aW9ucyA9IG51bGw7XG4gIGZpYmVyLnNpYmxpbmcgPSBudWxsOyAvLyBUaGUgYHN0YXRlTm9kZWAgaXMgY3ljbGljYWwgYmVjYXVzZSBvbiBob3N0IG5vZGVzIGl0IHBvaW50cyB0byB0aGUgaG9zdFxuICAvLyB0cmVlLCB3aGljaCBoYXMgaXRzIG93biBwb2ludGVycyB0byBjaGlsZHJlbiwgcGFyZW50cywgYW5kIHNpYmxpbmdzLlxuICAvLyBUaGUgb3RoZXIgaG9zdCBub2RlcyBhbHNvIHBvaW50IGJhY2sgdG8gZmliZXJzLCBzbyB3ZSBzaG91bGQgZGV0YWNoIHRoYXRcbiAgLy8gb25lLCB0b28uXG5cbiAgaWYgKGZpYmVyLnRhZyA9PT0gSG9zdENvbXBvbmVudCkge1xuICAgIHZhciBob3N0SW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICBpZiAoaG9zdEluc3RhbmNlICE9PSBudWxsKSB7XG4gICAgICBkZXRhY2hEZWxldGVkSW5zdGFuY2UoaG9zdEluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICBmaWJlci5zdGF0ZU5vZGUgPSBudWxsO1xuXG4gIHtcbiAgICBmaWJlci5fZGVidWdPd25lciA9IG51bGw7XG4gIH0gLy8gVGhlb3JldGljYWxseSwgbm90aGluZyBpbiBoZXJlIHNob3VsZCBiZSBuZWNlc3NhcnksIGJlY2F1c2Ugd2UgYWxyZWFkeVxuICAvLyBkaXNjb25uZWN0ZWQgdGhlIGZpYmVyIGZyb20gdGhlIHRyZWUuIFNvIGV2ZW4gaWYgc29tZXRoaW5nIGxlYWtzIHRoaXNcbiAgLy8gcGFydGljdWxhciBmaWJlciwgaXQgd29uJ3QgbGVhayBhbnl0aGluZyBlbHNlLlxuXG5cbiAgZmliZXIucmV0dXJuID0gbnVsbDtcbiAgZmliZXIuZGVwZW5kZW5jaWVzID0gbnVsbDtcbiAgZmliZXIubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gIGZpYmVyLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICBmaWJlci5wZW5kaW5nUHJvcHMgPSBudWxsO1xuICBmaWJlci5zdGF0ZU5vZGUgPSBudWxsOyAvLyBUT0RPOiBNb3ZlIHRvIGBjb21taXRQYXNzaXZlVW5tb3VudEluc2lkZURlbGV0ZWRUcmVlT25GaWJlcmAgaW5zdGVhZC5cblxuICBmaWJlci51cGRhdGVRdWV1ZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGVtcHR5UG9ydGFsQ29udGFpbmVyKGN1cnJlbnQpIHtcbiAgaWYgKCFzdXBwb3J0c1BlcnNpc3RlbmNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBvcnRhbCA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICB2YXIgY29udGFpbmVySW5mbyA9IHBvcnRhbC5jb250YWluZXJJbmZvO1xuICB2YXIgZW1wdHlDaGlsZFNldCA9IGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0KCk7XG4gIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbihjb250YWluZXJJbmZvLCBlbXB0eUNoaWxkU2V0KTtcbn1cblxuZnVuY3Rpb24gZ2V0SG9zdFBhcmVudEZpYmVyKGZpYmVyKSB7XG4gIHZhciBwYXJlbnQgPSBmaWJlci5yZXR1cm47XG5cbiAgd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgIGlmIChpc0hvc3RQYXJlbnQocGFyZW50KSkge1xuICAgICAgcmV0dXJuIHBhcmVudDtcbiAgICB9XG5cbiAgICBwYXJlbnQgPSBwYXJlbnQucmV0dXJuO1xuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyAnICsgJ2luIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbn1cblxuZnVuY3Rpb24gaXNIb3N0UGFyZW50KGZpYmVyKSB7XG4gIHJldHVybiBmaWJlci50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgZmliZXIudGFnID09PSBIb3N0Um9vdCB8fCAoc3VwcG9ydHNSZXNvdXJjZXMgPyBmaWJlci50YWcgPT09IEhvc3RIb2lzdGFibGUgOiBmYWxzZSkgfHwgKHN1cHBvcnRzU2luZ2xldG9ucyA/IGZpYmVyLnRhZyA9PT0gSG9zdFNpbmdsZXRvbiA6IGZhbHNlKSB8fCBmaWJlci50YWcgPT09IEhvc3RQb3J0YWw7XG59XG5cbmZ1bmN0aW9uIGdldEhvc3RTaWJsaW5nKGZpYmVyKSB7XG4gIC8vIFdlJ3JlIGdvaW5nIHRvIHNlYXJjaCBmb3J3YXJkIGludG8gdGhlIHRyZWUgdW50aWwgd2UgZmluZCBhIHNpYmxpbmcgaG9zdFxuICAvLyBub2RlLiBVbmZvcnR1bmF0ZWx5LCBpZiBtdWx0aXBsZSBpbnNlcnRpb25zIGFyZSBkb25lIGluIGEgcm93IHdlIGhhdmUgdG9cbiAgLy8gc2VhcmNoIHBhc3QgdGhlbS4gVGhpcyBsZWFkcyB0byBleHBvbmVudGlhbCBzZWFyY2ggZm9yIHRoZSBuZXh0IHNpYmxpbmcuXG4gIC8vIFRPRE86IEZpbmQgYSBtb3JlIGVmZmljaWVudCB3YXkgdG8gZG8gdGhpcy5cbiAgdmFyIG5vZGUgPSBmaWJlcjtcblxuICBzaWJsaW5nczogd2hpbGUgKHRydWUpIHtcbiAgICAvLyBJZiB3ZSBkaWRuJ3QgZmluZCBhbnl0aGluZywgbGV0J3MgdHJ5IHRoZSBuZXh0IHNpYmxpbmcuXG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IGlzSG9zdFBhcmVudChub2RlLnJldHVybikpIHtcbiAgICAgICAgLy8gSWYgd2UgcG9wIG91dCBvZiB0aGUgcm9vdCBvciBoaXQgdGhlIHBhcmVudCB0aGUgZmliZXIgd2UgYXJlIHRoZVxuICAgICAgICAvLyBsYXN0IHNpYmxpbmcuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cblxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuXG4gICAgd2hpbGUgKG5vZGUudGFnICE9PSBIb3N0Q29tcG9uZW50ICYmIG5vZGUudGFnICE9PSBIb3N0VGV4dCAmJiAoIXN1cHBvcnRzU2luZ2xldG9ucyA/IHRydWUgOiBub2RlLnRhZyAhPT0gSG9zdFNpbmdsZXRvbikgJiYgbm9kZS50YWcgIT09IERlaHlkcmF0ZWRGcmFnbWVudCkge1xuICAgICAgLy8gSWYgaXQgaXMgbm90IGhvc3Qgbm9kZSBhbmQsIHdlIG1pZ2h0IGhhdmUgYSBob3N0IG5vZGUgaW5zaWRlIGl0LlxuICAgICAgLy8gVHJ5IHRvIHNlYXJjaCBkb3duIHVudGlsIHdlIGZpbmQgb25lLlxuICAgICAgaWYgKG5vZGUuZmxhZ3MgJiBQbGFjZW1lbnQpIHtcbiAgICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGNoaWxkLCB0cnkgdGhlIHNpYmxpbmdzIGluc3RlYWQuXG4gICAgICAgIGNvbnRpbnVlIHNpYmxpbmdzO1xuICAgICAgfSAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2hpbGQsIHRyeSB0aGUgc2libGluZ3MgaW5zdGVhZC5cbiAgICAgIC8vIFdlIGFsc28gc2tpcCBwb3J0YWxzIGJlY2F1c2UgdGhleSBhcmUgbm90IHBhcnQgb2YgdGhpcyBob3N0IHRyZWUuXG5cblxuICAgICAgaWYgKG5vZGUuY2hpbGQgPT09IG51bGwgfHwgbm9kZS50YWcgPT09IEhvc3RQb3J0YWwpIHtcbiAgICAgICAgY29udGludWUgc2libGluZ3M7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgfVxuICAgIH0gLy8gQ2hlY2sgaWYgdGhpcyBob3N0IG5vZGUgaXMgc3RhYmxlIG9yIGFib3V0IHRvIGJlIHBsYWNlZC5cblxuXG4gICAgaWYgKCEobm9kZS5mbGFncyAmIFBsYWNlbWVudCkpIHtcbiAgICAgIC8vIEZvdW5kIGl0IVxuICAgICAgcmV0dXJuIG5vZGUuc3RhdGVOb2RlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQbGFjZW1lbnQoZmluaXNoZWRXb3JrKSB7XG4gIGlmICghc3VwcG9ydHNNdXRhdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmIChzdXBwb3J0c1NpbmdsZXRvbnMpIHtcbiAgICBpZiAoZmluaXNoZWRXb3JrLnRhZyA9PT0gSG9zdFNpbmdsZXRvbikge1xuICAgICAgLy8gU2luZ2xldG9ucyBhcmUgYWxyZWFkeSBpbiB0aGUgSG9zdCBhbmQgZG9uJ3QgbmVlZCB0byBiZSBwbGFjZWRcbiAgICAgIC8vIFNpbmNlIHRoZXkgb3BlcmF0ZSBzb21ld2hhdCBsaWtlIFBvcnRhbHMgdGhvdWdoIHRoZWlyIGNoaWxkcmVuIHdpbGxcbiAgICAgIC8vIGhhdmUgUGxhY2VtZW50IGFuZCB3aWxsIGdldCBwbGFjZWQgaW5zaWRlIHRoZW1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gLy8gUmVjdXJzaXZlbHkgaW5zZXJ0IGFsbCBob3N0IG5vZGVzIGludG8gdGhlIHBhcmVudC5cblxuXG4gIHZhciBwYXJlbnRGaWJlciA9IGdldEhvc3RQYXJlbnRGaWJlcihmaW5pc2hlZFdvcmspO1xuXG4gIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgICAge1xuICAgICAgICBpZiAoc3VwcG9ydHNTaW5nbGV0b25zKSB7XG4gICAgICAgICAgdmFyIHBhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICB2YXIgYmVmb3JlID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTsgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgdG8gcmVjdXJzZSBkb3duIGl0c1xuICAgICAgICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cblxuICAgICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShmaW5pc2hlZFdvcmssIGJlZm9yZSwgcGFyZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSAvLyBGYWxsIHRocm91Z2hcblxuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX3BhcmVudCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAocGFyZW50RmliZXIuZmxhZ3MgJiBDb250ZW50UmVzZXQpIHtcbiAgICAgICAgICAvLyBSZXNldCB0aGUgdGV4dCBjb250ZW50IG9mIHRoZSBwYXJlbnQgYmVmb3JlIGRvaW5nIGFueSBpbnNlcnRpb25zXG4gICAgICAgICAgcmVzZXRUZXh0Q29udGVudChfcGFyZW50KTsgLy8gQ2xlYXIgQ29udGVudFJlc2V0IGZyb20gdGhlIGVmZmVjdCB0YWdcblxuICAgICAgICAgIHBhcmVudEZpYmVyLmZsYWdzICY9IH5Db250ZW50UmVzZXQ7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2JlZm9yZSA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7IC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGluc2VydGVkIGJ1dCB3ZSBuZWVkIHRvIHJlY3Vyc2UgZG93biBpdHNcbiAgICAgICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuXG5cbiAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKGZpbmlzaGVkV29yaywgX2JlZm9yZSwgX3BhcmVudCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICB7XG4gICAgICAgIHZhciBfcGFyZW50MiA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuXG4gICAgICAgIHZhciBfYmVmb3JlMiA9IGdldEhvc3RTaWJsaW5nKGZpbmlzaGVkV29yayk7XG5cbiAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihmaW5pc2hlZFdvcmssIF9iZWZvcmUyLCBfcGFyZW50Mik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBob3N0IHBhcmVudCBmaWJlci4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnICcgKyAnaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIobm9kZSwgYmVmb3JlLCBwYXJlbnQpIHtcbiAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICB2YXIgaXNIb3N0ID0gdGFnID09PSBIb3N0Q29tcG9uZW50IHx8IHRhZyA9PT0gSG9zdFRleHQ7XG5cbiAgaWYgKGlzSG9zdCkge1xuICAgIHZhciBzdGF0ZU5vZGUgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgIGlmIChiZWZvcmUpIHtcbiAgICAgIGluc2VydEluQ29udGFpbmVyQmVmb3JlKHBhcmVudCwgc3RhdGVOb2RlLCBiZWZvcmUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyKHBhcmVudCwgc3RhdGVOb2RlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGFnID09PSBIb3N0UG9ydGFsIHx8IChzdXBwb3J0c1NpbmdsZXRvbnMgPyB0YWcgPT09IEhvc3RTaW5nbGV0b24gOiBmYWxzZSkpIDsgZWxzZSB7XG4gICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihjaGlsZCwgYmVmb3JlLCBwYXJlbnQpO1xuICAgICAgdmFyIHNpYmxpbmcgPSBjaGlsZC5zaWJsaW5nO1xuXG4gICAgICB3aGlsZSAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKHNpYmxpbmcsIGJlZm9yZSwgcGFyZW50KTtcbiAgICAgICAgc2libGluZyA9IHNpYmxpbmcuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKG5vZGUsIGJlZm9yZSwgcGFyZW50KSB7XG4gIHZhciB0YWcgPSBub2RlLnRhZztcbiAgdmFyIGlzSG9zdCA9IHRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCB0YWcgPT09IEhvc3RUZXh0O1xuXG4gIGlmIChpc0hvc3QpIHtcbiAgICB2YXIgc3RhdGVOb2RlID0gbm9kZS5zdGF0ZU5vZGU7XG5cbiAgICBpZiAoYmVmb3JlKSB7XG4gICAgICBpbnNlcnRCZWZvcmUocGFyZW50LCBzdGF0ZU5vZGUsIGJlZm9yZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwcGVuZENoaWxkKHBhcmVudCwgc3RhdGVOb2RlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodGFnID09PSBIb3N0UG9ydGFsIHx8IChzdXBwb3J0c1NpbmdsZXRvbnMgPyB0YWcgPT09IEhvc3RTaW5nbGV0b24gOiBmYWxzZSkpIDsgZWxzZSB7XG4gICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKGNoaWxkLCBiZWZvcmUsIHBhcmVudCk7XG4gICAgICB2YXIgc2libGluZyA9IGNoaWxkLnNpYmxpbmc7XG5cbiAgICAgIHdoaWxlIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZShzaWJsaW5nLCBiZWZvcmUsIHBhcmVudCk7XG4gICAgICAgIHNpYmxpbmcgPSBzaWJsaW5nLnNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG59IC8vIFRoZXNlIGFyZSB0cmFja2VkIG9uIHRoZSBzdGFjayBhcyB3ZSByZWN1cnNpdmVseSB0cmF2ZXJzZSBhXG4vLyBkZWxldGVkIHN1YnRyZWUuXG4vLyBUT0RPOiBVcGRhdGUgdGhlc2UgZHVyaW5nIHRoZSB3aG9sZSBtdXRhdGlvbiBwaGFzZSwgbm90IGp1c3QgZHVyaW5nXG4vLyBhIGRlbGV0aW9uLlxuXG5cbnZhciBob3N0UGFyZW50ID0gbnVsbDtcbnZhciBob3N0UGFyZW50SXNDb250YWluZXIgPSBmYWxzZTtcblxuZnVuY3Rpb24gY29tbWl0RGVsZXRpb25FZmZlY3RzKHJvb3QsIHJldHVybkZpYmVyLCBkZWxldGVkRmliZXIpIHtcbiAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBkZWxldGVkIGJ1dCB3ZSBuZWVkIHRvIHJlY3Vyc2UgZG93biBpdHNcbiAgICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG4gICAgLy8gUmVjdXJzaXZlbHkgZGVsZXRlIGFsbCBob3N0IG5vZGVzIGZyb20gdGhlIHBhcmVudCwgZGV0YWNoIHJlZnMsIGNsZWFuXG4gICAgLy8gdXAgbW91bnRlZCBsYXlvdXQgZWZmZWN0cywgYW5kIGNhbGwgY29tcG9uZW50V2lsbFVubW91bnQuXG4gICAgLy8gV2Ugb25seSBuZWVkIHRvIHJlbW92ZSB0aGUgdG9wbW9zdCBob3N0IGNoaWxkIGluIGVhY2ggYnJhbmNoLiBCdXQgdGhlbiB3ZVxuICAgIC8vIHN0aWxsIG5lZWQgdG8ga2VlcCB0cmF2ZXJzaW5nIHRvIHVubW91bnQgZWZmZWN0cywgcmVmcywgYW5kIGNXVS4gVE9ETzogV2VcbiAgICAvLyBjb3VsZCBzcGxpdCB0aGlzIGludG8gdHdvIHNlcGFyYXRlIHRyYXZlcnNhbHMgZnVuY3Rpb25zLCB3aGVyZSB0aGUgc2Vjb25kXG4gICAgLy8gb25lIGRvZXNuJ3QgaW5jbHVkZSBhbnkgcmVtb3ZlQ2hpbGQgbG9naWMuIFRoaXMgaXMgbWF5YmUgdGhlIHNhbWVcbiAgICAvLyBmdW5jdGlvbiBhcyBcImRpc2FwcGVhckxheW91dEVmZmVjdHNcIiAob3Igd2hhdGV2ZXIgdGhhdCB0dXJucyBpbnRvIGFmdGVyXG4gICAgLy8gdGhlIGxheW91dCBwaGFzZSBpcyByZWZhY3RvcmVkIHRvIHVzZSByZWN1cnNpb24pLlxuICAgIC8vIEJlZm9yZSBzdGFydGluZywgZmluZCB0aGUgbmVhcmVzdCBob3N0IHBhcmVudCBvbiB0aGUgc3RhY2sgc28gd2Uga25vd1xuICAgIC8vIHdoaWNoIGluc3RhbmNlL2NvbnRhaW5lciB0byByZW1vdmUgdGhlIGNoaWxkcmVuIGZyb20uXG4gICAgLy8gVE9ETzogSW5zdGVhZCBvZiBzZWFyY2hpbmcgdXAgdGhlIGZpYmVyIHJldHVybiBwYXRoIG9uIGV2ZXJ5IGRlbGV0aW9uLCB3ZVxuICAgIC8vIGNhbiB0cmFjayB0aGUgbmVhcmVzdCBob3N0IGNvbXBvbmVudCBvbiB0aGUgSlMgc3RhY2sgYXMgd2UgdHJhdmVyc2UgdGhlXG4gICAgLy8gdHJlZSBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZS4gVGhpcyB3b3VsZCBtYWtlIGluc2VydGlvbnMgZmFzdGVyLCB0b28uXG4gICAgdmFyIHBhcmVudCA9IHJldHVybkZpYmVyO1xuXG4gICAgZmluZFBhcmVudDogd2hpbGUgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChwYXJlbnQudGFnKSB7XG4gICAgICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGhvc3RQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlO1xuICAgICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGhvc3RQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGhvc3RQYXJlbnQgPSBwYXJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWsgZmluZFBhcmVudDtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGhvc3RQYXJlbnQgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gZmluZCBhIGhvc3QgcGFyZW50LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgJyArICdhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuXG4gICAgY29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlcihyb290LCByZXR1cm5GaWJlciwgZGVsZXRlZEZpYmVyKTtcbiAgICBob3N0UGFyZW50ID0gbnVsbDtcbiAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBEZXRhY2ggcmVmcyBhbmQgY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudCgpIG9uIHRoZSB3aG9sZSBzdWJ0cmVlLlxuICAgIGNvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIocm9vdCwgcmV0dXJuRmliZXIsIGRlbGV0ZWRGaWJlcik7XG4gIH1cblxuICBkZXRhY2hGaWJlck11dGF0aW9uKGRlbGV0ZWRGaWJlcik7XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBwYXJlbnQpIHtcbiAgLy8gVE9ETzogVXNlIGEgc3RhdGljIGZsYWcgdG8gc2tpcCB0cmVlcyB0aGF0IGRvbid0IGhhdmUgdW5tb3VudCBlZmZlY3RzXG4gIHZhciBjaGlsZCA9IHBhcmVudC5jaGlsZDtcblxuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICBjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgY2hpbGQpO1xuICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVsZXRlZEZpYmVyKSB7XG4gIG9uQ29tbWl0VW5tb3VudChkZWxldGVkRmliZXIpOyAvLyBUaGUgY2FzZXMgaW4gdGhpcyBvdXRlciBzd2l0Y2ggbW9kaWZ5IHRoZSBzdGFjayBiZWZvcmUgdGhleSB0cmF2ZXJzZVxuICAvLyBpbnRvIHRoZWlyIHN1YnRyZWUuIFRoZXJlIGFyZSBzaW1wbGVyIGNhc2VzIGluIHRoZSBpbm5lciBzd2l0Y2hcbiAgLy8gdGhhdCBkb24ndCBtb2RpZnkgdGhlIHN0YWNrLlxuXG4gIHN3aXRjaCAoZGVsZXRlZEZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdEhvaXN0YWJsZTpcbiAgICAgIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzUmVzb3VyY2VzKSB7XG4gICAgICAgICAgaWYgKCFvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKSB7XG4gICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVsZXRlZEZpYmVyKTtcblxuICAgICAgICAgIGlmIChkZWxldGVkRmliZXIubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgICAgcmVsZWFzZVJlc291cmNlKGRlbGV0ZWRGaWJlci5tZW1vaXplZFN0YXRlKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpIHtcbiAgICAgICAgICAgIHVubW91bnRIb2lzdGFibGUoZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RTaW5nbGV0b246XG4gICAgICB7XG4gICAgICAgIGlmIChzdXBwb3J0c1NpbmdsZXRvbnMpIHtcbiAgICAgICAgICBpZiAoIW9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pIHtcbiAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwcmV2SG9zdFBhcmVudCA9IGhvc3RQYXJlbnQ7XG4gICAgICAgICAgdmFyIHByZXZIb3N0UGFyZW50SXNDb250YWluZXIgPSBob3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICAgICAgaG9zdFBhcmVudCA9IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlbGV0ZWRGaWJlcik7IC8vIE5vcm1hbGx5IHRoaXMgaXMgY2FsbGVkIGluIHBhc3NpdmUgdW5tb3VudCBlZmZlY3QgcGhhc2UgaG93ZXZlciB3aXRoXG4gICAgICAgICAgLy8gSG9zdFNpbmdsZXRvbiB3ZSB3YXJuIGlmIHlvdSBhY3F1aXJlIG9uZSB0aGF0IGlzIGFscmVhZHkgYXNzb2NpYXRlZCB0b1xuICAgICAgICAgIC8vIGEgZGlmZmVyZW50IGZpYmVyLiBUbyBpbmNyZWFzZSBvdXIgY2hhbmNlcyBvZiBhdm9pZGluZyB0aGlzLCBzcGVjaWZpY2FsbHlcbiAgICAgICAgICAvLyBpZiB5b3Uga2V5ZWQgYSBIb3N0U2luZ2xldG9uIHNvIHRoZXJlIHdpbGwgYmUgYSBkZWxldGUgZm9sbG93ZWQgYnkgYSBQbGFjZW1lbnRcbiAgICAgICAgICAvLyB3ZSB0cmVhdCBkZXRhY2ggZWFnZXJseSBoZXJlXG5cbiAgICAgICAgICByZWxlYXNlU2luZ2xldG9uSW5zdGFuY2UoZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSk7XG4gICAgICAgICAgaG9zdFBhcmVudCA9IHByZXZIb3N0UGFyZW50O1xuICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IHByZXZIb3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGlmICghb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbikge1xuICAgICAgICAgIHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgICB9IC8vIEludGVudGlvbmFsIGZhbGx0aHJvdWdoIHRvIG5leHQgYnJhbmNoXG5cbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICB7XG4gICAgICAgIC8vIFdlIG9ubHkgbmVlZCB0byByZW1vdmUgdGhlIG5lYXJlc3QgaG9zdCBjaGlsZC4gU2V0IHRoZSBob3N0IHBhcmVudFxuICAgICAgICAvLyB0byBgbnVsbGAgb24gdGhlIHN0YWNrIHRvIGluZGljYXRlIHRoYXQgbmVzdGVkIGNoaWxkcmVuIGRvbid0XG4gICAgICAgIC8vIG5lZWQgdG8gYmUgcmVtb3ZlZC5cbiAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICB2YXIgX3ByZXZIb3N0UGFyZW50ID0gaG9zdFBhcmVudDtcbiAgICAgICAgICB2YXIgX3ByZXZIb3N0UGFyZW50SXNDb250YWluZXIgPSBob3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICAgICAgaG9zdFBhcmVudCA9IG51bGw7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlbGV0ZWRGaWJlcik7XG4gICAgICAgICAgaG9zdFBhcmVudCA9IF9wcmV2SG9zdFBhcmVudDtcbiAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSBfcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lcjtcblxuICAgICAgICAgIGlmIChob3N0UGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBOb3cgdGhhdCBhbGwgdGhlIGNoaWxkIGVmZmVjdHMgaGF2ZSB1bm1vdW50ZWQsIHdlIGNhbiByZW1vdmUgdGhlXG4gICAgICAgICAgICAvLyBub2RlIGZyb20gdGhlIHRyZWUuXG4gICAgICAgICAgICBpZiAoaG9zdFBhcmVudElzQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcihob3N0UGFyZW50LCBkZWxldGVkRmliZXIuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlbW92ZUNoaWxkKGhvc3RQYXJlbnQsIGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVsZXRlZEZpYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgRGVoeWRyYXRlZEZyYWdtZW50OlxuICAgICAge1xuICAgICAgICAvLyBEZWxldGUgdGhlIGRlaHlkcmF0ZWQgc3VzcGVuc2UgYm91bmRhcnkgYW5kIGFsbCBvZiBpdHMgY29udGVudC5cblxuXG4gICAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgICAgICAgaWYgKGhvc3RQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChob3N0UGFyZW50SXNDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgY2xlYXJTdXNwZW5zZUJvdW5kYXJ5RnJvbUNvbnRhaW5lcihob3N0UGFyZW50LCBkZWxldGVkRmliZXIuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGNsZWFyU3VzcGVuc2VCb3VuZGFyeShob3N0UGFyZW50LCBkZWxldGVkRmliZXIuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICB7XG4gICAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgICAgICAgLy8gV2hlbiB3ZSBnbyBpbnRvIGEgcG9ydGFsLCBpdCBiZWNvbWVzIHRoZSBwYXJlbnQgdG8gcmVtb3ZlIGZyb20uXG4gICAgICAgICAgdmFyIF9wcmV2SG9zdFBhcmVudDIgPSBob3N0UGFyZW50O1xuICAgICAgICAgIHZhciBfcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lcjIgPSBob3N0UGFyZW50SXNDb250YWluZXI7XG4gICAgICAgICAgaG9zdFBhcmVudCA9IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSB0cnVlO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuICAgICAgICAgIGhvc3RQYXJlbnQgPSBfcHJldkhvc3RQYXJlbnQyO1xuICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IF9wcmV2SG9zdFBhcmVudElzQ29udGFpbmVyMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbXB0eVBvcnRhbENvbnRhaW5lcihkZWxldGVkRmliZXIpO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgaWYgKCFvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKSB7XG4gICAgICAgICAgdmFyIHVwZGF0ZVF1ZXVlID0gZGVsZXRlZEZpYmVyLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgbGFzdEVmZmVjdCA9IHVwZGF0ZVF1ZXVlLmxhc3RFZmZlY3Q7XG5cbiAgICAgICAgICAgIGlmIChsYXN0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICAgICAgICAgICAgdmFyIGVmZmVjdCA9IGZpcnN0RWZmZWN0O1xuXG4gICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFnID0gZWZmZWN0LnRhZztcbiAgICAgICAgICAgICAgICB2YXIgaW5zdCA9IGVmZmVjdC5pbnN0O1xuICAgICAgICAgICAgICAgIHZhciBkZXN0cm95ID0gaW5zdC5kZXN0cm95O1xuXG4gICAgICAgICAgICAgICAgaWYgKGRlc3Ryb3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgaWYgKCh0YWcgJiBJbnNlcnRpb24pICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGluc3QuZGVzdHJveSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgc2FmZWx5Q2FsbERlc3Ryb3koZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZXN0cm95KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoKHRhZyAmIExheW91dCkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZChkZWxldGVkRmliZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZFByb2ZpbGUoZGVsZXRlZEZpYmVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICBpbnN0LmRlc3Ryb3kgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgc2FmZWx5Q2FsbERlc3Ryb3koZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZXN0cm95KTtcbiAgICAgICAgICAgICAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihkZWxldGVkRmliZXIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGluc3QuZGVzdHJveSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICBzYWZlbHlDYWxsRGVzdHJveShkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlc3Ryb3kpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZWZmZWN0ID0gZWZmZWN0Lm5leHQ7XG4gICAgICAgICAgICAgIH0gd2hpbGUgKGVmZmVjdCAhPT0gZmlyc3RFZmZlY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBpZiAoIW9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pIHtcbiAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBkZWxldGVkRmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVW5tb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgaW5zdGFuY2UpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG5cbiAgICAgICAge1xuICAgICAgICAgIC8vIElmIHRoaXMgb2Zmc2NyZWVuIGNvbXBvbmVudCBpcyBoaWRkZW4sIHdlIGFscmVhZHkgdW5tb3VudGVkIGl0LiBCZWZvcmVcbiAgICAgICAgICAvLyBkZWxldGluZyB0aGUgY2hpbGRyZW4sIHRyYWNrIHRoYXQgaXQncyBhbHJlYWR5IHVubW91bnRlZCBzbyB0aGF0IHdlXG4gICAgICAgICAgLy8gZG9uJ3QgYXR0ZW1wdCB0byB1bm1vdW50IHRoZSBlZmZlY3RzIGFnYWluLlxuICAgICAgICAgIC8vIFRPRE86IElmIHRoZSB0cmVlIGlzIGhpZGRlbiwgaW4gbW9zdCBjYXNlcyB3ZSBzaG91bGQgYmUgYWJsZSB0byBza2lwXG4gICAgICAgICAgLy8gb3ZlciB0aGUgbmVzdGVkIGNoaWxkcmVuIGVudGlyZWx5LiBBbiBleGNlcHRpb24gaXMgd2UgaGF2ZW4ndCB5ZXQgZm91bmRcbiAgICAgICAgICAvLyB0aGUgdG9wbW9zdCBob3N0IG5vZGUgdG8gZGVsZXRlLCB3aGljaCB3ZSBhbHJlYWR5IHRyYWNrIG9uIHRoZSBzdGFjay5cbiAgICAgICAgICAvLyBCdXQgdGhlIG90aGVyIGNhc2UgaXMgcG9ydGFscywgd2hpY2ggbmVlZCB0byBiZSBkZXRhY2hlZCBubyBtYXR0ZXIgaG93XG4gICAgICAgICAgLy8gZGVlcGx5IHRoZXkgYXJlIG5lc3RlZC4gV2Ugc2hvdWxkIHVzZSBhIHN1YnRyZWUgZmxhZyB0byB0cmFjayB3aGV0aGVyIGFcbiAgICAgICAgICAvLyBzdWJ0cmVlIGluY2x1ZGVzIGEgbmVzdGVkIHBvcnRhbC5cbiAgICAgICAgICB2YXIgcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiB8fCBkZWxldGVkRmliZXIubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVsZXRlZEZpYmVyKTtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0U3VzcGVuc2VDYWxsYmFjayhmaW5pc2hlZFdvcmspIHtcbn1cblxuZnVuY3Rpb24gY29tbWl0U3VzcGVuc2VIeWRyYXRpb25DYWxsYmFja3MoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBuZXdTdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChuZXdTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHZhciBjdXJyZW50ID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZTtcblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG4gICAgICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBzdXNwZW5zZUluc3RhbmNlID0gcHJldlN0YXRlLmRlaHlkcmF0ZWQ7XG5cbiAgICAgICAgaWYgKHN1c3BlbnNlSW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29tbWl0SHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpO1xuXG4gICAgICAgICAgICB2YXIgaHlkcmF0aW9uQ2FsbGJhY2tzLCBvbkh5ZHJhdGVkOyBpZiAoZW5hYmxlU3VzcGVuc2VDYWxsYmFjaykgO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0UmV0cnlDYWNoZShmaW5pc2hlZFdvcmspIHtcbiAgLy8gVE9ETzogVW5pZnkgdGhlIGludGVyZmFjZSBmb3IgdGhlIHJldHJ5IGNhY2hlIHNvIHdlIGRvbid0IGhhdmUgdG8gc3dpdGNoXG4gIC8vIG9uIHRoZSB0YWcgbGlrZSB0aGlzLlxuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgcmV0cnlDYWNoZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKHJldHJ5Q2FjaGUgPT09IG51bGwpIHtcbiAgICAgICAgICByZXRyeUNhY2hlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9IG5ldyBQb3NzaWJseVdlYWtTZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXRyeUNhY2hlO1xuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgIHZhciBfcmV0cnlDYWNoZSA9IGluc3RhbmNlLl9yZXRyeUNhY2hlO1xuXG4gICAgICAgIGlmIChfcmV0cnlDYWNoZSA9PT0gbnVsbCkge1xuICAgICAgICAgIF9yZXRyeUNhY2hlID0gaW5zdGFuY2UuX3JldHJ5Q2FjaGUgPSBuZXcgUG9zc2libHlXZWFrU2V0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX3JldHJ5Q2FjaGU7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIFN1c3BlbnNlIGhhbmRsZXIgdGFnIChcIiArIGZpbmlzaGVkV29yay50YWcgKyBcIikuIFRoaXMgaXMgYSBcIiArICdidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0YWNoT2Zmc2NyZWVuSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgdmFyIGZpYmVyID0gaW5zdGFuY2UuX2N1cnJlbnQ7XG5cbiAgaWYgKGZpYmVyID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIE9mZnNjcmVlbi5kZXRhY2ggYmVmb3JlIGluc3RhbmNlIGhhbmRsZSBoYXMgYmVlbiBzZXQuJyk7XG4gIH1cblxuICBpZiAoKGluc3RhbmNlLl9wZW5kaW5nVmlzaWJpbGl0eSAmIE9mZnNjcmVlbkRldGFjaGVkKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgLy8gVGhlIGluc3RhbmNlIGlzIGFscmVhZHkgZGV0YWNoZWQsIHRoaXMgaXMgYSBub29wLlxuICAgIHJldHVybjtcbiAgfSAvLyBUT0RPOiBUaGVyZSBpcyBhbiBvcHBvcnR1bml0eSB0byBvcHRpbWlzZSB0aGlzIGJ5IG5vdCBlbnRlcmluZyBjb21taXQgcGhhc2VcbiAgLy8gYW5kIHVubW91bnRpbmcgZWZmZWN0cyBkaXJlY3RseS5cblxuXG4gIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBTeW5jTGFuZSk7XG5cbiAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICBpbnN0YW5jZS5fcGVuZGluZ1Zpc2liaWxpdHkgfD0gT2Zmc2NyZWVuRGV0YWNoZWQ7XG4gICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBTeW5jTGFuZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGF0dGFjaE9mZnNjcmVlbkluc3RhbmNlKGluc3RhbmNlKSB7XG4gIHZhciBmaWJlciA9IGluc3RhbmNlLl9jdXJyZW50O1xuXG4gIGlmIChmaWJlciA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyBPZmZzY3JlZW4uZGV0YWNoIGJlZm9yZSBpbnN0YW5jZSBoYW5kbGUgaGFzIGJlZW4gc2V0LicpO1xuICB9XG5cbiAgaWYgKChpbnN0YW5jZS5fcGVuZGluZ1Zpc2liaWxpdHkgJiBPZmZzY3JlZW5EZXRhY2hlZCkgPT09IE5vRmxhZ3MkMSkge1xuICAgIC8vIFRoZSBpbnN0YW5jZSBpcyBhbHJlYWR5IGF0dGFjaGVkLCB0aGlzIGlzIGEgbm9vcC5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgU3luY0xhbmUpO1xuXG4gIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgaW5zdGFuY2UuX3BlbmRpbmdWaXNpYmlsaXR5ICY9IH5PZmZzY3JlZW5EZXRhY2hlZDtcbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaywgd2FrZWFibGVzKSB7XG4gIC8vIElmIHRoaXMgYm91bmRhcnkganVzdCB0aW1lZCBvdXQsIHRoZW4gaXQgd2lsbCBoYXZlIGEgc2V0IG9mIHdha2VhYmxlcy5cbiAgLy8gRm9yIGVhY2ggd2FrZWFibGUsIGF0dGFjaCBhIGxpc3RlbmVyIHNvIHRoYXQgd2hlbiBpdCByZXNvbHZlcywgUmVhY3RcbiAgLy8gYXR0ZW1wdHMgdG8gcmUtcmVuZGVyIHRoZSBib3VuZGFyeSBpbiB0aGUgcHJpbWFyeSAocHJlLXRpbWVvdXQpIHN0YXRlLlxuICB2YXIgcmV0cnlDYWNoZSA9IGdldFJldHJ5Q2FjaGUoZmluaXNoZWRXb3JrKTtcbiAgd2FrZWFibGVzLmZvckVhY2goZnVuY3Rpb24gKHdha2VhYmxlKSB7XG4gICAgLy8gTWVtb2l6ZSB1c2luZyB0aGUgYm91bmRhcnkgZmliZXIgdG8gcHJldmVudCByZWR1bmRhbnQgbGlzdGVuZXJzLlxuICAgIHZhciByZXRyeSA9IHJlc29sdmVSZXRyeVdha2VhYmxlLmJpbmQobnVsbCwgZmluaXNoZWRXb3JrLCB3YWtlYWJsZSk7XG5cbiAgICBpZiAoIXJldHJ5Q2FjaGUuaGFzKHdha2VhYmxlKSkge1xuICAgICAgcmV0cnlDYWNoZS5hZGQod2FrZWFibGUpO1xuXG4gICAgICB7XG4gICAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudCkge1xuICAgICAgICAgIGlmIChpblByb2dyZXNzTGFuZXMgIT09IG51bGwgJiYgaW5Qcm9ncmVzc1Jvb3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgcGVuZGluZyB3b3JrIHN0aWxsLCBhc3NvY2lhdGUgdGhlIG9yaWdpbmFsIHVwZGF0ZXJzIHdpdGggaXQuXG4gICAgICAgICAgICByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKGluUHJvZ3Jlc3NSb290LCBpblByb2dyZXNzTGFuZXMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignRXhwZWN0ZWQgZmluaXNoZWQgcm9vdCBhbmQgbGFuZXMgdG8gYmUgc2V0LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB3YWtlYWJsZS50aGVuKHJldHJ5LCByZXRyeSk7XG4gICAgfVxuICB9KTtcbn0gLy8gVGhpcyBmdW5jdGlvbiBkZXRlY3RzIHdoZW4gYSBTdXNwZW5zZSBib3VuZGFyeSBnb2VzIGZyb20gdmlzaWJsZSB0byBoaWRkZW4uXG5mdW5jdGlvbiBjb21taXRNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcykge1xuICBpblByb2dyZXNzTGFuZXMgPSBjb21taXR0ZWRMYW5lcztcbiAgaW5Qcm9ncmVzc1Jvb3QgPSByb290O1xuICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKGZpbmlzaGVkV29yayk7XG4gIGNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIoZmluaXNoZWRXb3JrLCByb290KTtcbiAgcmVzZXRDdXJyZW50RGVidWdGaWJlckluREVWKCk7XG4gIGluUHJvZ3Jlc3NMYW5lcyA9IG51bGw7XG4gIGluUHJvZ3Jlc3NSb290ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBwYXJlbnRGaWJlciwgbGFuZXMpIHtcbiAgLy8gRGVsZXRpb25zIGVmZmVjdHMgY2FuIGJlIHNjaGVkdWxlZCBvbiBhbnkgZmliZXIgdHlwZS4gVGhleSBuZWVkIHRvIGhhcHBlblxuICAvLyBiZWZvcmUgdGhlIGNoaWxkcmVuIGVmZmVjdHMgaGFlIGZpcmVkLlxuICB2YXIgZGVsZXRpb25zID0gcGFyZW50RmliZXIuZGVsZXRpb25zO1xuXG4gIGlmIChkZWxldGlvbnMgIT09IG51bGwpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRlbGV0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkVG9EZWxldGUgPSBkZWxldGlvbnNbaV07XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbW1pdERlbGV0aW9uRWZmZWN0cyhyb290LCBwYXJlbnRGaWJlciwgY2hpbGRUb0RlbGV0ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjaGlsZFRvRGVsZXRlLCBwYXJlbnRGaWJlciwgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBwcmV2RGVidWdGaWJlciA9IGdldEN1cnJlbnRGaWJlcigpO1xuXG4gIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiBNdXRhdGlvbk1hc2spIHtcbiAgICB2YXIgY2hpbGQgPSBwYXJlbnRGaWJlci5jaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihjaGlsZCk7XG4gICAgICBjb21taXRNdXRhdGlvbkVmZmVjdHNPbkZpYmVyKGNoaWxkLCByb290KTtcbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG4gIH1cblxuICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKHByZXZEZWJ1Z0ZpYmVyKTtcbn1cblxudmFyIGN1cnJlbnRIb2lzdGFibGVSb290ID0gbnVsbDtcblxuZnVuY3Rpb24gY29tbWl0TXV0YXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFdvcmssIHJvb3QsIGxhbmVzKSB7XG4gIHZhciBjdXJyZW50ID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZTtcbiAgdmFyIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzOyAvLyBUaGUgZWZmZWN0IGZsYWcgc2hvdWxkIGJlIGNoZWNrZWQgKmFmdGVyKiB3ZSByZWZpbmUgdGhlIHR5cGUgb2YgZmliZXIsXG4gIC8vIGJlY2F1c2UgdGhlIGZpYmVyIHRhZyBpcyBtb3JlIHNwZWNpZmljLiBBbiBleGNlcHRpb24gaXMgYW55IGZsYWcgcmVsYXRlZFxuICAvLyB0byByZWNvbmNpbGlhdGlvbiwgYmVjYXVzZSB0aG9zZSBjYW4gYmUgc2V0IG9uIGFsbCBmaWJlciB0eXBlcy5cblxuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoSW5zZXJ0aW9uIHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChJbnNlcnRpb24gfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH0gLy8gTGF5b3V0IGVmZmVjdHMgYXJlIGRlc3Ryb3llZCBkdXJpbmcgdGhlIG11dGF0aW9uIHBoYXNlIHNvIHRoYXQgYWxsXG4gICAgICAgICAgLy8gZGVzdHJveSBmdW5jdGlvbnMgZm9yIGFsbCBmaWJlcnMgYXJlIGNhbGxlZCBiZWZvcmUgYW55IGNyZWF0ZSBmdW5jdGlvbnMuXG4gICAgICAgICAgLy8gVGhpcyBwcmV2ZW50cyBzaWJsaW5nIGNvbXBvbmVudCBlZmZlY3RzIGZyb20gaW50ZXJmZXJpbmcgd2l0aCBlYWNoIG90aGVyLFxuICAgICAgICAgIC8vIGUuZy4gYSBkZXN0cm95IGZ1bmN0aW9uIGluIG9uZSBjb21wb25lbnQgc2hvdWxkIG5ldmVyIG92ZXJyaWRlIGEgcmVmIHNldFxuICAgICAgICAgIC8vIGJ5IGEgY3JlYXRlIGZ1bmN0aW9uIGluIGFub3RoZXIgY29tcG9uZW50IGR1cmluZyB0aGUgc2FtZSBjb21taXQuXG5cblxuICAgICAgICAgIGlmIChzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaykpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KExheW91dCB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoTGF5b3V0IHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcblxuICAgICAgICBpZiAoZmxhZ3MgJiBSZWYpIHtcbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIGN1cnJlbnQucmV0dXJuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmxhZ3MgJiBDYWxsYmFjayAmJiBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4pIHtcbiAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG5cbiAgICAgICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGRlZmVySGlkZGVuQ2FsbGJhY2tzKHVwZGF0ZVF1ZXVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RIb2lzdGFibGU6XG4gICAgICB7XG4gICAgICAgIGlmIChzdXBwb3J0c1Jlc291cmNlcykge1xuICAgICAgICAgIC8vIFdlIGNhc3QgYmVjYXVzZSB3ZSBhbHdheXMgc2V0IHRoZSByb290IGF0IHRoZSBSZWFjdCByb290IGFuZCBzbyBpdCBjYW5ub3QgYmVcbiAgICAgICAgICAvLyBudWxsIHdoaWxlIHdlIGFyZSBwcm9jZXNzaW5nIG11dGF0aW9uIGVmZmVjdHNcbiAgICAgICAgICB2YXIgaG9pc3RhYmxlUm9vdCA9IGN1cnJlbnRIb2lzdGFibGVSb290O1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcblxuICAgICAgICAgIGlmIChmbGFncyAmIFJlZikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIGN1cnJlbnQucmV0dXJuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50UmVzb3VyY2UgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFN0YXRlIDogbnVsbDtcbiAgICAgICAgICAgIHZhciBuZXdSZXNvdXJjZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBXZSBhcmUgbW91bnRpbmcgYSBuZXcgSG9zdEhvaXN0YWJsZSBGaWJlci4gV2UgZm9yayB0aGUgbW91bnRcbiAgICAgICAgICAgICAgLy8gYmVoYXZpb3IgYmFzZWQgb24gd2hldGhlciB0aGlzIGluc3RhbmNlIGlzIGEgSG9pc3RhYmxlIEluc3RhbmNlXG4gICAgICAgICAgICAgIC8vIG9yIGEgSG9pc3RhYmxlIFJlc291cmNlXG4gICAgICAgICAgICAgIGlmIChuZXdSZXNvdXJjZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsuc3RhdGVOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlID0gaHlkcmF0ZUhvaXN0YWJsZShob2lzdGFibGVSb290LCBmaW5pc2hlZFdvcmsudHlwZSwgZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG1vdW50SG9pc3RhYmxlKGhvaXN0YWJsZVJvb3QsIGZpbmlzaGVkV29yay50eXBlLCBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9IGFjcXVpcmVSZXNvdXJjZShob2lzdGFibGVSb290LCBuZXdSZXNvdXJjZSwgZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRSZXNvdXJjZSAhPT0gbmV3UmVzb3VyY2UpIHtcbiAgICAgICAgICAgICAgLy8gV2UgYXJlIG1vdmluZyB0byBvciBmcm9tIEhvaXN0YWJsZSBSZXNvdXJjZSwgb3IgYmV0d2VlbiBkaWZmZXJlbnQgSG9pc3RhYmxlIFJlc291cmNlc1xuICAgICAgICAgICAgICBpZiAoY3VycmVudFJlc291cmNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnQuc3RhdGVOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICB1bm1vdW50SG9pc3RhYmxlKGN1cnJlbnQuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVsZWFzZVJlc291cmNlKGN1cnJlbnRSZXNvdXJjZSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAobmV3UmVzb3VyY2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBtb3VudEhvaXN0YWJsZShob2lzdGFibGVSb290LCBmaW5pc2hlZFdvcmsudHlwZSwgZmluaXNoZWRXb3JrLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgYWNxdWlyZVJlc291cmNlKGhvaXN0YWJsZVJvb3QsIG5ld1Jlc291cmNlLCBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAobmV3UmVzb3VyY2UgPT09IG51bGwgJiYgZmluaXNoZWRXb3JrLnN0YXRlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbW1pdFVwZGF0ZShmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLCBmaW5pc2hlZFdvcmsudHlwZSwgY3VycmVudC5tZW1vaXplZFByb3BzLCBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBGYWxsIHRocm91Z2hcblxuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgICAge1xuICAgICAgICBpZiAoc3VwcG9ydHNTaW5nbGV0b25zKSB7XG4gICAgICAgICAgaWYgKGZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNXb3JrID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZTtcblxuICAgICAgICAgICAgaWYgKHByZXZpb3VzV29yayA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgc2luZ2xldG9uID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgdmFyIHByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7IC8vIFRoaXMgd2FzIGEgbmV3IG1vdW50LCB3ZSBuZWVkIHRvIGNsZWFyIGFuZCBzZXQgaW5pdGlhbCBwcm9wZXJ0aWVzXG5cbiAgICAgICAgICAgICAgY2xlYXJTaW5nbGV0b24oc2luZ2xldG9uKTtcbiAgICAgICAgICAgICAgYWNxdWlyZVNpbmdsZXRvbkluc3RhbmNlKGZpbmlzaGVkV29yay50eXBlLCBwcm9wcywgc2luZ2xldG9uLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBGYWxsIHRocm91Z2hcblxuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFJlZikge1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgY3VycmVudC5yZXR1cm4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgICAgICAgLy8gVE9ETzogQ29udGVudFJlc2V0IGdldHMgY2xlYXJlZCBieSB0aGUgY2hpbGRyZW4gZHVyaW5nIHRoZSBjb21taXRcbiAgICAgICAgICAvLyBwaGFzZS4gVGhpcyBpcyBhIHJlZmFjdG9yIGhhemFyZCBiZWNhdXNlIGl0IG1lYW5zIHdlIG11c3QgcmVhZFxuICAgICAgICAgIC8vIGZsYWdzIHRoZSBmbGFncyBhZnRlciBgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzYCBoYXMgYWxyZWFkeSBydW47XG4gICAgICAgICAgLy8gdGhlIG9yZGVyIG1hdHRlcnMuIFdlIHNob3VsZCByZWZhY3RvciBzbyB0aGF0IENvbnRlbnRSZXNldCBkb2VzIG5vdFxuICAgICAgICAgIC8vIHJlbHkgb24gbXV0YXRpbmcgdGhlIGZsYWcgZHVyaW5nIGNvbW1pdC4gTGlrZSBieSBzZXR0aW5nIGEgZmxhZ1xuICAgICAgICAgIC8vIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlIGluc3RlYWQuXG4gICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5mbGFncyAmIENvbnRlbnRSZXNldCkge1xuICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmVzZXRUZXh0Q29udGVudChpbnN0YW5jZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICAgIHZhciBfaW5zdGFuY2UyID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICAgICAgaWYgKF9pbnN0YW5jZTIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBDb21taXQgdGhlIHdvcmsgcHJlcGFyZWQgZWFybGllci5cbiAgICAgICAgICAgICAgdmFyIG5ld1Byb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7IC8vIEZvciBoeWRyYXRpb24gd2UgcmV1c2UgdGhlIHVwZGF0ZSBwYXRoIGJ1dCB3ZSB0cmVhdCB0aGUgb2xkUHJvcHNcbiAgICAgICAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgICAgICAgIC8vIHRoaXMgY2FzZS5cblxuICAgICAgICAgICAgICB2YXIgb2xkUHJvcHMgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbmV3UHJvcHM7XG4gICAgICAgICAgICAgIHZhciB0eXBlID0gZmluaXNoZWRXb3JrLnR5cGU7XG5cbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb21taXRVcGRhdGUoX2luc3RhbmNlMiwgdHlwZSwgb2xkUHJvcHMsIG5ld1Byb3BzLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGZsYWdzICYgRm9ybVJlc2V0KSB7XG4gICAgICAgICAgICBuZWVkc0Zvcm1SZXNldCA9IHRydWU7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay50eXBlICE9PSAnZm9ybScpIHtcbiAgICAgICAgICAgICAgICAvLyBQYXJhbm9pZCBjb2RpbmcuIEluIGNhc2Ugd2UgYWNjaWRlbnRhbGx5IHN0YXJ0IHVzaW5nIHRoZVxuICAgICAgICAgICAgICAgIC8vIEZvcm1SZXNldCBiaXQgZm9yIHNvbWV0aGluZyBlbHNlLlxuICAgICAgICAgICAgICAgIGVycm9yKCdVbmV4cGVjdGVkIGhvc3QgY29tcG9uZW50IHR5cGUuIEV4cGVjdGVkIGEgZm9ybS4gVGhpcyBpcyBhICcgKyAnYnVnIGluIFJlYWN0LicpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcblxuICAgICAgICBpZiAoZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHNob3VsZCBoYXZlIGEgdGV4dCBub2RlIGluaXRpYWxpemVkLiBUaGlzIGVycm9yIGlzIGxpa2VseSAnICsgJ2NhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0ZXh0SW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgdmFyIG5ld1RleHQgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wczsgLy8gRm9yIGh5ZHJhdGlvbiB3ZSByZXVzZSB0aGUgdXBkYXRlIHBhdGggYnV0IHdlIHRyZWF0IHRoZSBvbGRQcm9wc1xuICAgICAgICAgICAgLy8gYXMgdGhlIG5ld1Byb3BzLiBUaGUgdXBkYXRlUGF5bG9hZCB3aWxsIGNvbnRhaW4gdGhlIHJlYWwgY2hhbmdlIGluXG4gICAgICAgICAgICAvLyB0aGlzIGNhc2UuXG5cbiAgICAgICAgICAgIHZhciBvbGRUZXh0ID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyA6IG5ld1RleHQ7XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbW1pdFRleHRVcGRhdGUodGV4dEluc3RhbmNlLCBvbGRUZXh0LCBuZXdUZXh0KTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIGlmIChzdXBwb3J0c1Jlc291cmNlcykge1xuICAgICAgICAgIHByZXBhcmVUb0NvbW1pdEhvaXN0YWJsZXMoKTtcbiAgICAgICAgICB2YXIgcHJldmlvdXNIb2lzdGFibGVSb290ID0gY3VycmVudEhvaXN0YWJsZVJvb3Q7XG4gICAgICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBnZXRIb2lzdGFibGVSb290KHJvb3QuY29udGFpbmVySW5mbyk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290ID0gcHJldmlvdXNIb2lzdGFibGVSb290O1xuICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uICYmIHN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB2YXIgcHJldlJvb3RTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICAgICAgICBpZiAocHJldlJvb3RTdGF0ZS5pc0RlaHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgY29tbWl0SHlkcmF0ZWRDb250YWluZXIocm9vdC5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcbiAgICAgICAgICAgIHZhciBjb250YWluZXJJbmZvID0gcm9vdC5jb250YWluZXJJbmZvO1xuICAgICAgICAgICAgdmFyIHBlbmRpbmdDaGlsZHJlbiA9IHJvb3QucGVuZGluZ0NoaWxkcmVuO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4oY29udGFpbmVySW5mbywgcGVuZGluZ0NoaWxkcmVuKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChuZWVkc0Zvcm1SZXNldCkge1xuICAgICAgICAgIC8vIEEgZm9ybSBjb21wb25lbnQgcmVxdWVzdGVkIHRvIGJlIHJlc2V0IGR1cmluZyB0aGlzIGNvbW1pdC4gV2UgZG8gdGhpc1xuICAgICAgICAgIC8vIGFmdGVyIGFsbCBtdXRhdGlvbnMgaW4gdGhlIHJlc3Qgb2YgdGhlIHRyZWUgc28gdGhhdCBgZGVmYXVsdFZhbHVlYFxuICAgICAgICAgIC8vIHdpbGwgYWxyZWFkeSBiZSB1cGRhdGVkLiBUaGlzIHdheSB5b3UgY2FuIHVwZGF0ZSBgZGVmYXVsdFZhbHVlYCB1c2luZ1xuICAgICAgICAgIC8vIGRhdGEgc2VudCBieSB0aGUgc2VydmVyIGFzIGEgcmVzdWx0IG9mIHRoZSBmb3JtIHN1Ym1pc3Npb24uXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBUaGVvcmV0aWNhbGx5IHdlIGNvdWxkIGNoZWNrIGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3MgJiBGb3JtUmVzZXQsXG4gICAgICAgICAgLy8gYnV0IHRoZSBGb3JtUmVzZXQgYml0IGlzIG92ZXJsb2FkZWQgd2l0aCBvdGhlciBmbGFncyB1c2VkIGJ5IG90aGVyXG4gICAgICAgICAgLy8gZmliZXIgdHlwZXMuIFNvIHRoaXMgZXh0cmEgdmFyaWFibGUgbGV0cyB1cyBza2lwIHRyYXZlcnNpbmcgdGhlIHRyZWVcbiAgICAgICAgICAvLyBleGNlcHQgd2hlbiBhIGZvcm0gd2FzIGFjdHVhbGx5IHN1Ym1pdHRlZC5cbiAgICAgICAgICBuZWVkc0Zvcm1SZXNldCA9IGZhbHNlO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5UmVzZXRGb3JtcyhmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAge1xuICAgICAgICBpZiAoc3VwcG9ydHNSZXNvdXJjZXMpIHtcbiAgICAgICAgICB2YXIgX3ByZXZpb3VzSG9pc3RhYmxlUm9vdCA9IGN1cnJlbnRIb2lzdGFibGVSb290O1xuICAgICAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290ID0gZ2V0SG9pc3RhYmxlUm9vdChmaW5pc2hlZFdvcmsuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCA9IF9wcmV2aW91c0hvaXN0YWJsZVJvb3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgaWYgKHN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcbiAgICAgICAgICAgIHZhciBwb3J0YWwgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgdmFyIF9jb250YWluZXJJbmZvID0gcG9ydGFsLmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICB2YXIgX3BlbmRpbmdDaGlsZHJlbiA9IHBvcnRhbC5wZW5kaW5nQ2hpbGRyZW47XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbihfY29udGFpbmVySW5mbywgX3BlbmRpbmdDaGlsZHJlbik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspOyAvLyBUT0RPOiBXZSBzaG91bGQgbWFyayBhIGZsYWcgb24gdGhlIFN1c3BlbnNlIGZpYmVyIGl0c2VsZiwgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gcmVseWluZyBvbiB0aGUgT2Zmc2NyZWVuIGZpYmVyIGhhdmluZyBhIGZsYWcgYWxzbyBiZWluZyBtYXJrZWQuIFRoZVxuICAgICAgICAvLyByZWFzb24gaXMgdGhhdCB0aGlzIG9mZnNjcmVlbiBmaWJlciBtaWdodCBub3QgYmUgcGFydCBvZiB0aGUgd29yay1pbi1cbiAgICAgICAgLy8gcHJvZ3Jlc3MgdHJlZSEgSXQgY291bGQgaGF2ZSBiZWVuIHJldXNlZCBmcm9tIGEgcHJldmlvdXMgcmVuZGVyLiBUaGlzXG4gICAgICAgIC8vIGRvZXNuJ3QgbGVhZCB0byBpbmNvcnJlY3QgYmVoYXZpb3IgYmVjYXVzZSB3ZSBkb24ndCByZWx5IG9uIHRoZSBmbGFnXG4gICAgICAgIC8vIGNoZWNrIGFsb25lOyB3ZSBhbHNvIGNvbXBhcmUgdGhlIHN0YXRlcyBleHBsaWNpdGx5IGJlbG93LiBCdXQgZm9yXG4gICAgICAgIC8vIG1vZGVsaW5nIHB1cnBvc2VzLCB3ZSBfc2hvdWxkXyBiZSBhYmxlIHRvIHJlbHkgb24gdGhlIGZsYWcgY2hlY2sgYWxvbmUuXG4gICAgICAgIC8vIFNvIHRoaXMgaXMgYSBiaXQgZnJhZ2lsZS5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQWxzbywgYWxsIHRoaXMgbG9naWMgY291bGQvc2hvdWxkIG1vdmUgdG8gdGhlIHBhc3NpdmUgcGhhc2Ugc28gaXRcbiAgICAgICAgLy8gZG9lc24ndCBibG9jayBwYWludC5cblxuICAgICAgICB2YXIgb2Zmc2NyZWVuRmliZXIgPSBmaW5pc2hlZFdvcmsuY2hpbGQ7XG5cbiAgICAgICAgaWYgKG9mZnNjcmVlbkZpYmVyLmZsYWdzICYgVmlzaWJpbGl0eSkge1xuICAgICAgICAgIC8vIFRocm90dGxlIHRoZSBhcHBlYXJhbmNlIGFuZCBkaXNhcHBlYXJhbmNlIG9mIFN1c3BlbnNlIGZhbGxiYWNrcy5cbiAgICAgICAgICB2YXIgaXNTaG93aW5nRmFsbGJhY2sgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgICB2YXIgd2FzU2hvd2luZ0ZhbGxiYWNrID0gY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50Lm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoaXNTaG93aW5nRmFsbGJhY2sgIT09IHdhc1Nob3dpbmdGYWxsYmFjaykge1xuICAgICAgICAgICAgICAvLyBBIGZhbGxiYWNrIGlzIGVpdGhlciBhcHBlYXJpbmcgb3IgZGlzYXBwZWFyaW5nLlxuICAgICAgICAgICAgICBtYXJrQ29tbWl0VGltZU9mRmFsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29tbWl0U3VzcGVuc2VDYWxsYmFjayhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcmV0cnlRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcblxuICAgICAgICAgIGlmIChyZXRyeVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWUgPSBudWxsO1xuICAgICAgICAgICAgYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmssIHJldHJ5UXVldWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBpZiAoZmxhZ3MgJiBSZWYpIHtcbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIGN1cnJlbnQucmV0dXJuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgbmV3U3RhdGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgdmFyIGlzSGlkZGVuID0gbmV3U3RhdGUgIT09IG51bGw7XG4gICAgICAgIHZhciB3YXNIaWRkZW4gPSBjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgICB7XG4gICAgICAgICAgLy8gQmVmb3JlIGNvbW1pdHRpbmcgdGhlIGNoaWxkcmVuLCB0cmFjayBvbiB0aGUgc3RhY2sgd2hldGhlciB0aGlzXG4gICAgICAgICAgLy8gb2Zmc2NyZWVuIHN1YnRyZWUgd2FzIGFscmVhZHkgaGlkZGVuLCBzbyB0aGF0IHdlIGRvbid0IHVubW91bnQgdGhlXG4gICAgICAgICAgLy8gZWZmZWN0cyBhZ2Fpbi5cbiAgICAgICAgICB2YXIgcHJldk9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbjtcbiAgICAgICAgICB2YXIgcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gfHwgaXNIaWRkZW47XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8IHdhc0hpZGRlbjtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgIH1cblxuICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgdmFyIG9mZnNjcmVlbkluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTsgLy8gVE9ETzogQWRkIGV4cGxpY2l0IGVmZmVjdCBmbGFnIHRvIHNldCBfY3VycmVudC5cblxuICAgICAgICBvZmZzY3JlZW5JbnN0YW5jZS5fY3VycmVudCA9IGZpbmlzaGVkV29yazsgLy8gT2Zmc2NyZWVuIHN0b3JlcyBwZW5kaW5nIGNoYW5nZXMgdG8gdmlzaWJpbGl0eSBpbiBgX3BlbmRpbmdWaXNpYmlsaXR5YC4gVGhpcyBpc1xuICAgICAgICAvLyB0byBzdXBwb3J0IGJhdGNoaW5nIG9mIGBhdHRhY2hgIGFuZCBgZGV0YWNoYCBjYWxscy5cblxuICAgICAgICBvZmZzY3JlZW5JbnN0YW5jZS5fdmlzaWJpbGl0eSAmPSB+T2Zmc2NyZWVuRGV0YWNoZWQ7XG4gICAgICAgIG9mZnNjcmVlbkluc3RhbmNlLl92aXNpYmlsaXR5IHw9IG9mZnNjcmVlbkluc3RhbmNlLl9wZW5kaW5nVmlzaWJpbGl0eSAmIE9mZnNjcmVlbkRldGFjaGVkO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFZpc2liaWxpdHkpIHtcbiAgICAgICAgICAvLyBUcmFjayB0aGUgY3VycmVudCBzdGF0ZSBvbiB0aGUgT2Zmc2NyZWVuIGluc3RhbmNlIHNvIHdlIGNhblxuICAgICAgICAgIC8vIHJlYWQgaXQgZHVyaW5nIGFuIGV2ZW50XG4gICAgICAgICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICAgICAgICBvZmZzY3JlZW5JbnN0YW5jZS5fdmlzaWJpbGl0eSAmPSB+T2Zmc2NyZWVuVmlzaWJsZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgb2Zmc2NyZWVuSW5zdGFuY2UuX3Zpc2liaWxpdHkgfD0gT2Zmc2NyZWVuVmlzaWJsZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoaXNIaWRkZW4pIHtcbiAgICAgICAgICAgIHZhciBpc1VwZGF0ZSA9IGN1cnJlbnQgIT09IG51bGw7XG4gICAgICAgICAgICB2YXIgd2FzSGlkZGVuQnlBbmNlc3Rvck9mZnNjcmVlbiA9IG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiB8fCBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuOyAvLyBPbmx5IHRyaWdnZXIgZGlzYXBwZXIgbGF5b3V0IGVmZmVjdHMgaWY6XG4gICAgICAgICAgICAvLyAgIC0gVGhpcyBpcyBhbiB1cGRhdGUsIG5vdCBmaXJzdCBtb3VudC5cbiAgICAgICAgICAgIC8vICAgLSBUaGlzIE9mZnNjcmVlbiB3YXMgbm90IGhpZGRlbiBiZWZvcmUuXG4gICAgICAgICAgICAvLyAgIC0gQW5jZXN0b3IgT2Zmc2NyZWVuIHdhcyBub3QgaGlkZGVuIGluIHByZXZpb3VzIGNvbW1pdC5cblxuICAgICAgICAgICAgaWYgKGlzVXBkYXRlICYmICF3YXNIaWRkZW4gJiYgIXdhc0hpZGRlbkJ5QW5jZXN0b3JPZmZzY3JlZW4pIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIERpc2FwcGVhciB0aGUgbGF5b3V0IGVmZmVjdHMgb2YgYWxsIHRoZSBjaGlsZHJlblxuICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIE9mZnNjcmVlbiB3aXRoIG1hbnVhbCBtb2RlIG1hbmFnZXMgdmlzaWJpbGl0eSBtYW51YWxseS5cblxuXG4gICAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24gJiYgIWlzT2Zmc2NyZWVuTWFudWFsKGZpbmlzaGVkV29yaykpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IFRoaXMgbmVlZHMgdG8gcnVuIHdoZW5ldmVyIHRoZXJlJ3MgYW4gaW5zZXJ0aW9uIG9yIHVwZGF0ZVxuICAgICAgICAgICAgLy8gaW5zaWRlIGEgaGlkZGVuIE9mZnNjcmVlbiB0cmVlLlxuICAgICAgICAgICAgaGlkZU9yVW5oaWRlQWxsQ2hpbGRyZW4oZmluaXNoZWRXb3JrLCBpc0hpZGRlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIFRPRE86IE1vdmUgdG8gcGFzc2l2ZSBwaGFzZVxuXG5cbiAgICAgICAgaWYgKGZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgdmFyIG9mZnNjcmVlblF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgICAgaWYgKG9mZnNjcmVlblF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX3JldHJ5UXVldWUgPSBvZmZzY3JlZW5RdWV1ZS5yZXRyeVF1ZXVlO1xuXG4gICAgICAgICAgICBpZiAoX3JldHJ5UXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgb2Zmc2NyZWVuUXVldWUucmV0cnlRdWV1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIGF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMoZmluaXNoZWRXb3JrLCBfcmV0cnlRdWV1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgdmFyIF9yZXRyeVF1ZXVlMiA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcblxuICAgICAgICAgIGlmIChfcmV0cnlRdWV1ZTIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaywgX3JldHJ5UXVldWUyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKSB7XG4gIC8vIFBsYWNlbWVudCBlZmZlY3RzIChpbnNlcnRpb25zLCByZW9yZGVycykgY2FuIGJlIHNjaGVkdWxlZCBvbiBhbnkgZmliZXJcbiAgLy8gdHlwZS4gVGhleSBuZWVkcyB0byBoYXBwZW4gYWZ0ZXIgdGhlIGNoaWxkcmVuIGVmZmVjdHMgaGF2ZSBmaXJlZCwgYnV0XG4gIC8vIGJlZm9yZSB0aGUgZWZmZWN0cyBvbiB0aGlzIGZpYmVyIGhhdmUgZmlyZWQuXG4gIHZhciBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcblxuICBpZiAoZmxhZ3MgJiBQbGFjZW1lbnQpIHtcbiAgICB0cnkge1xuICAgICAgY29tbWl0UGxhY2VtZW50KGZpbmlzaGVkV29yayk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgIH0gLy8gQ2xlYXIgdGhlIFwicGxhY2VtZW50XCIgZnJvbSBlZmZlY3QgdGFnIHNvIHRoYXQgd2Uga25vdyB0aGF0IHRoaXMgaXNcbiAgICAvLyBpbnNlcnRlZCwgYmVmb3JlIGFueSBsaWZlLWN5Y2xlcyBsaWtlIGNvbXBvbmVudERpZE1vdW50IGdldHMgY2FsbGVkLlxuICAgIC8vIFRPRE86IGZpbmRET01Ob2RlIGRvZXNuJ3QgcmVseSBvbiB0aGlzIGFueSBtb3JlIGJ1dCBpc01vdW50ZWQgZG9lc1xuICAgIC8vIGFuZCBpc01vdW50ZWQgaXMgZGVwcmVjYXRlZCBhbnl3YXkgc28gd2Ugc2hvdWxkIGJlIGFibGUgdG8ga2lsbCB0aGlzLlxuXG5cbiAgICBmaW5pc2hlZFdvcmsuZmxhZ3MgJj0gflBsYWNlbWVudDtcbiAgfVxuXG4gIGlmIChmbGFncyAmIEh5ZHJhdGluZykge1xuICAgIGZpbmlzaGVkV29yay5mbGFncyAmPSB+SHlkcmF0aW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5UmVzZXRGb3JtcyhwYXJlbnRGaWJlcikge1xuICBpZiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgRm9ybVJlc2V0KSB7XG4gICAgdmFyIGNoaWxkID0gcGFyZW50RmliZXIuY2hpbGQ7XG5cbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHJlc2V0Rm9ybU9uRmliZXIoY2hpbGQpO1xuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXNldEZvcm1PbkZpYmVyKGZpYmVyKSB7XG4gIHJlY3Vyc2l2ZWx5UmVzZXRGb3JtcyhmaWJlcik7XG5cbiAgaWYgKGZpYmVyLnRhZyA9PT0gSG9zdENvbXBvbmVudCAmJiBmaWJlci5mbGFncyAmIEZvcm1SZXNldCkge1xuICAgIHZhciBmb3JtSW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG4gICAgcmVzZXRGb3JtSW5zdGFuY2UoZm9ybUluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaywgcm9vdCwgY29tbWl0dGVkTGFuZXMpIHtcbiAgaW5Qcm9ncmVzc0xhbmVzID0gY29tbWl0dGVkTGFuZXM7XG4gIGluUHJvZ3Jlc3NSb290ID0gcm9vdDtcbiAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihmaW5pc2hlZFdvcmspO1xuICB2YXIgY3VycmVudCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG4gIGNvbW1pdExheW91dEVmZmVjdE9uRmliZXIocm9vdCwgY3VycmVudCwgZmluaXNoZWRXb3JrKTtcbiAgcmVzZXRDdXJyZW50RGVidWdGaWJlckluREVWKCk7XG4gIGluUHJvZ3Jlc3NMYW5lcyA9IG51bGw7XG4gIGluUHJvZ3Jlc3NSb290ID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMocm9vdCwgcGFyZW50RmliZXIsIGxhbmVzKSB7XG4gIHZhciBwcmV2RGVidWdGaWJlciA9IGdldEN1cnJlbnRGaWJlcigpO1xuXG4gIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiBMYXlvdXRNYXNrKSB7XG4gICAgdmFyIGNoaWxkID0gcGFyZW50RmliZXIuY2hpbGQ7XG5cbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoY2hpbGQpO1xuICAgICAgdmFyIGN1cnJlbnQgPSBjaGlsZC5hbHRlcm5hdGU7XG4gICAgICBjb21taXRMYXlvdXRFZmZlY3RPbkZpYmVyKHJvb3QsIGN1cnJlbnQsIGNoaWxkKTtcbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG4gIH1cblxuICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKHByZXZEZWJ1Z0ZpYmVyKTtcbn1cblxuZnVuY3Rpb24gZGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspIHtcbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBNZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETyAoT2Zmc2NyZWVuKSBDaGVjazogZmxhZ3MgJiBMYXlvdXRTdGF0aWNcbiAgICAgICAgaWYgKHNob3VsZFByb2ZpbGUoZmluaXNoZWRXb3JrKSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdGFydExheW91dEVmZmVjdFRpbWVyKCk7XG4gICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoTGF5b3V0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoTGF5b3V0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICAvLyBUT0RPIChPZmZzY3JlZW4pIENoZWNrOiBmbGFncyAmIFJlZlN0YXRpY1xuICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgc2FmZWx5Q2FsbENvbXBvbmVudFdpbGxVbm1vdW50KGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgaW5zdGFuY2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RIb2lzdGFibGU6XG4gICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETyAoT2Zmc2NyZWVuKSBDaGVjazogZmxhZ3MgJiBSZWZTdGF0aWNcbiAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIC8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IGZsYWdzICYgUmVmU3RhdGljXG4gICAgICAgIHNhZmVseURldGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICB2YXIgaXNIaWRkZW4gPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgICBpZiAoaXNIaWRkZW4pIDsgZWxzZSB7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMocGFyZW50RmliZXIpIHtcbiAgLy8gVE9ETyAoT2Zmc2NyZWVuKSBDaGVjazogZmxhZ3MgJiAoUmVmU3RhdGljIHwgTGF5b3V0U3RhdGljKVxuICB2YXIgY2hpbGQgPSBwYXJlbnRGaWJlci5jaGlsZDtcblxuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICBkaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGNoaWxkKTtcbiAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgY3VycmVudCwgZmluaXNoZWRXb3JrLCAvLyBUaGlzIGZ1bmN0aW9uIHZpc2l0cyBib3RoIG5ld2x5IGZpbmlzaGVkIHdvcmsgYW5kIG5vZGVzIHRoYXQgd2VyZSByZS11c2VkXG4vLyBmcm9tIGEgcHJldmlvdXNseSBjb21taXR0ZWQgdHJlZS4gV2UgY2Fubm90IGNoZWNrIG5vbi1zdGF0aWMgZmxhZ3MgaWYgdGhlXG4vLyBub2RlIHdhcyByZXVzZWQuXG5pbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzKSB7XG4gIC8vIFR1cm4gb24gbGF5b3V0IGVmZmVjdHMgaW4gYSB0cmVlIHRoYXQgcHJldmlvdXNseSBkaXNhcHBlYXJlZC5cbiAgdmFyIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuXG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyk7IC8vIFRPRE86IENoZWNrIGZsYWdzICYgTGF5b3V0U3RhdGljXG5cbiAgICAgICAgY29tbWl0SG9va0xheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrLCBMYXlvdXQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMpOyAvLyBUT0RPOiBDaGVjayBmb3IgTGF5b3V0U3RhdGljIGZsYWdcblxuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIENvbW1pdCBhbnkgY2FsbGJhY2tzIHRoYXQgd291bGQgaGF2ZSBmaXJlZCB3aGlsZSB0aGUgY29tcG9uZW50XG4gICAgICAgIC8vIHdhcyBoaWRkZW4uXG5cblxuICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG5cbiAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgICAgY29tbWl0SGlkZGVuQ2FsbGJhY2tzKHVwZGF0ZVF1ZXVlLCBpbnN0YW5jZSk7XG4gICAgICAgIH0gLy8gSWYgdGhpcyBpcyBuZXdseSBmaW5pc2hlZCB3b3JrLCBjaGVjayBmb3Igc2V0U3RhdGUgY2FsbGJhY2tzXG5cblxuICAgICAgICBpZiAoaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJiBmbGFncyAmIENhbGxiYWNrKSB7XG4gICAgICAgICAgY29tbWl0Q2xhc3NDYWxsYmFja3MoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfSAvLyBUT0RPOiBDaGVjayBmbGFncyAmIFJlZlN0YXRpY1xuXG5cbiAgICAgICAgc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIC8vIFVubGlrZSBjb21taXRMYXlvdXRFZmZlY3RzT25GaWJlciwgd2UgZG9uJ3QgbmVlZCB0byBoYW5kbGUgSG9zdFJvb3RcbiAgICAvLyBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gb25seSB2aXNpdHMgbm9kZXMgdGhhdCBhcmUgaW5zaWRlIGFuXG4gICAgLy8gT2Zmc2NyZWVuIGZpYmVyLlxuICAgIC8vIGNhc2UgSG9zdFJvb3Q6IHtcbiAgICAvLyAgLi4uXG4gICAgLy8gfVxuXG4gICAgY2FzZSBIb3N0SG9pc3RhYmxlOlxuICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMpOyAvLyBSZW5kZXJlcnMgbWF5IHNjaGVkdWxlIHdvcmsgdG8gYmUgZG9uZSBhZnRlciBob3N0IGNvbXBvbmVudHMgYXJlIG1vdW50ZWRcbiAgICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBtYXkgc2NoZWR1bGUgYXV0by1mb2N1cyBmb3IgaW5wdXRzIGFuZCBmb3JtIGNvbnRyb2xzKS5cbiAgICAgICAgLy8gVGhlc2UgZWZmZWN0cyBzaG91bGQgb25seSBiZSBjb21taXR0ZWQgd2hlbiBjb21wb25lbnRzIGFyZSBmaXJzdCBtb3VudGVkLFxuICAgICAgICAvLyBha2Egd2hlbiB0aGVyZSBpcyBubyBjdXJyZW50L2FsdGVybmF0ZS5cblxuICAgICAgICBpZiAoaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJiBjdXJyZW50ID09PSBudWxsICYmIGZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgY29tbWl0SG9zdENvbXBvbmVudE1vdW50KGZpbmlzaGVkV29yayk7XG4gICAgICAgIH0gLy8gVE9ETzogQ2hlY2sgZmxhZ3MgJiBSZWZcblxuXG4gICAgICAgIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMpOyAvLyBUT0RPOiBGaWd1cmUgb3V0IGhvdyBQcm9maWxlciB1cGRhdGVzIHNob3VsZCB3b3JrIHdpdGggT2Zmc2NyZWVuXG5cbiAgICAgICAgaWYgKGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiYgZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICBjb21taXRQcm9maWxlclVwZGF0ZShmaW5pc2hlZFdvcmssIGN1cnJlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzKTsgLy8gVE9ETzogRmlndXJlIG91dCBob3cgU3VzcGVuc2UgaHlkcmF0aW9uIGNhbGxiYWNrcyBzaG91bGQgd29ya1xuICAgICAgICAvLyB3aXRoIE9mZnNjcmVlbi5cblxuICAgICAgICBpZiAoaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJiBmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIGNvbW1pdFN1c3BlbnNlSHlkcmF0aW9uQ2FsbGJhY2tzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBvZmZzY3JlZW5TdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICB2YXIgaXNIaWRkZW4gPSBvZmZzY3JlZW5TdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgICBpZiAoaXNIaWRkZW4pIDsgZWxzZSB7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyk7XG4gICAgICAgIH0gLy8gVE9ETzogQ2hlY2sgZmxhZ3MgJiBSZWZcblxuXG4gICAgICAgIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgcGFyZW50RmliZXIsIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiB2aXNpdHMgYm90aCBuZXdseSBmaW5pc2hlZCB3b3JrIGFuZCBub2RlcyB0aGF0IHdlcmUgcmUtdXNlZFxuICAvLyBmcm9tIGEgcHJldmlvdXNseSBjb21taXR0ZWQgdHJlZS4gV2UgY2Fubm90IGNoZWNrIG5vbi1zdGF0aWMgZmxhZ3MgaWYgdGhlXG4gIC8vIG5vZGUgd2FzIHJldXNlZC5cbiAgdmFyIGNoaWxkU2hvdWxkSW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyA9IGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIExheW91dE1hc2spICE9PSBOb0ZsYWdzJDE7IC8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IGZsYWdzICYgKFJlZlN0YXRpYyB8IExheW91dFN0YXRpYylcblxuICB2YXIgcHJldkRlYnVnRmliZXIgPSBnZXRDdXJyZW50RmliZXIoKTtcbiAgdmFyIGNoaWxkID0gcGFyZW50RmliZXIuY2hpbGQ7XG5cbiAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBjaGlsZC5hbHRlcm5hdGU7XG4gICAgcmVhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgY3VycmVudCwgY2hpbGQsIGNoaWxkU2hvdWxkSW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyk7XG4gICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICB9XG5cbiAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihwcmV2RGVidWdGaWJlcik7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEhvb2tQYXNzaXZlTW91bnRFZmZlY3RzKGZpbmlzaGVkV29yaywgaG9va0ZsYWdzKSB7XG4gIGlmIChzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaykpIHtcbiAgICBzdGFydFBhc3NpdmVFZmZlY3RUaW1lcigpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoaG9va0ZsYWdzLCBmaW5pc2hlZFdvcmspO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICB9XG5cbiAgICByZWNvcmRQYXNzaXZlRWZmZWN0RHVyYXRpb24oZmluaXNoZWRXb3JrKTtcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChob29rRmxhZ3MsIGZpbmlzaGVkV29yayk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRPZmZzY3JlZW5QYXNzaXZlTW91bnRFZmZlY3RzKGN1cnJlbnQsIGZpbmlzaGVkV29yaywgaW5zdGFuY2UpIHtcbiAge1xuICAgIHZhciBwcmV2aW91c0NhY2hlID0gbnVsbDtcblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCAmJiBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICE9PSBudWxsKSB7XG4gICAgICBwcmV2aW91c0NhY2hlID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sO1xuICAgIH1cblxuICAgIHZhciBuZXh0Q2FjaGUgPSBudWxsO1xuXG4gICAgaWYgKGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICE9PSBudWxsICYmIGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAhPT0gbnVsbCkge1xuICAgICAgbmV4dENhY2hlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2w7XG4gICAgfSAvLyBSZXRhaW4vcmVsZWFzZSB0aGUgY2FjaGUgdXNlZCBmb3IgcGVuZGluZyAoc3VzcGVuZGVkKSBub2Rlcy5cbiAgICAvLyBOb3RlIHRoYXQgdGhpcyBpcyBvbmx5IHJlYWNoZWQgaW4gdGhlIG5vbi1zdXNwZW5kZWQvdmlzaWJsZSBjYXNlOlxuICAgIC8vIHdoZW4gdGhlIGNvbnRlbnQgaXMgc3VzcGVuZGVkL2hpZGRlbiwgdGhlIHJldGFpbi9yZWxlYXNlIG9jY3Vyc1xuICAgIC8vIHZpYSB0aGUgcGFyZW50IFN1c3BlbnNlIGNvbXBvbmVudCAoc2VlIGNhc2UgYWJvdmUpLlxuXG5cbiAgICBpZiAobmV4dENhY2hlICE9PSBwcmV2aW91c0NhY2hlKSB7XG4gICAgICBpZiAobmV4dENhY2hlICE9IG51bGwpIHtcbiAgICAgICAgcmV0YWluQ2FjaGUobmV4dENhY2hlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHByZXZpb3VzQ2FjaGUgIT0gbnVsbCkge1xuICAgICAgICByZWxlYXNlQ2FjaGUocHJldmlvdXNDYWNoZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdENhY2hlUGFzc2l2ZU1vdW50RWZmZWN0KGN1cnJlbnQsIGZpbmlzaGVkV29yaykge1xuICB7XG4gICAgdmFyIHByZXZpb3VzQ2FjaGUgPSBudWxsO1xuXG4gICAgaWYgKGZpbmlzaGVkV29yay5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgIHByZXZpb3VzQ2FjaGUgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUuY2FjaGU7XG4gICAgfVxuXG4gICAgdmFyIG5leHRDYWNoZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlLmNhY2hlOyAvLyBSZXRhaW4vcmVsZWFzZSB0aGUgY2FjaGUuIEluIHRoZW9yeSB0aGUgY2FjaGUgY29tcG9uZW50XG4gICAgLy8gY291bGQgYmUgXCJib3Jyb3dpbmdcIiBhIGNhY2hlIGluc3RhbmNlIG93bmVkIGJ5IHNvbWUgcGFyZW50LFxuICAgIC8vIGluIHdoaWNoIGNhc2Ugd2UgY291bGQgYXZvaWQgcmV0YWluaW5nL3JlbGVhc2luZy4gQnV0IGl0XG4gICAgLy8gaXMgbm9uLXRyaXZpYWwgdG8gZGV0ZXJtaW5lIHdoZW4gdGhhdCBpcyB0aGUgY2FzZSwgc28gd2VcbiAgICAvLyBhbHdheXMgcmV0YWluL3JlbGVhc2UuXG5cbiAgICBpZiAobmV4dENhY2hlICE9PSBwcmV2aW91c0NhY2hlKSB7XG4gICAgICByZXRhaW5DYWNoZShuZXh0Q2FjaGUpO1xuXG4gICAgICBpZiAocHJldmlvdXNDYWNoZSAhPSBudWxsKSB7XG4gICAgICAgIHJlbGVhc2VDYWNoZShwcmV2aW91c0NhY2hlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZU1vdW50RWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucykge1xuICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKGZpbmlzaGVkV29yayk7XG4gIGNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIocm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMpO1xuICByZXNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoKTtcbn1cblxuZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMocm9vdCwgcGFyZW50RmliZXIsIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucykge1xuICB2YXIgcHJldkRlYnVnRmliZXIgPSBnZXRDdXJyZW50RmliZXIoKTtcblxuICBpZiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgUGFzc2l2ZU1hc2spIHtcbiAgICB2YXIgY2hpbGQgPSBwYXJlbnRGaWJlci5jaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihjaGlsZCk7XG4gICAgICBjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyKHJvb3QsIGNoaWxkLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMpO1xuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYocHJldkRlYnVnRmliZXIpO1xufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMpIHtcbiAgLy8gV2hlbiB1cGRhdGluZyB0aGlzIGZ1bmN0aW9uLCBhbHNvIHVwZGF0ZSByZWNvbm5lY3RQYXNzaXZlRWZmZWN0cywgd2hpY2ggZG9lc1xuICAvLyBtb3N0IG9mIHRoZSBzYW1lIHRoaW5ncyB3aGVuIGFuIG9mZnNjcmVlbiB0cmVlIGdvZXMgZnJvbSBoaWRkZW4gLT4gdmlzaWJsZSxcbiAgLy8gb3Igd2hlbiB0b2dnbGluZyBlZmZlY3RzIGluc2lkZSBhIGhpZGRlbiB0cmVlLlxuICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG5cbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zKTtcblxuICAgICAgICBpZiAoZmxhZ3MgJiBQYXNzaXZlJDEpIHtcbiAgICAgICAgICBjb21taXRIb29rUGFzc2l2ZU1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmssIFBhc3NpdmUgfCBIYXNFZmZlY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zKTtcblxuICAgICAgICBpZiAoZmxhZ3MgJiBQYXNzaXZlJDEpIHtcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNDYWNoZSA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHByZXZpb3VzQ2FjaGUgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUuY2FjaGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBuZXh0Q2FjaGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZS5jYWNoZTsgLy8gUmV0YWluL3JlbGVhc2UgdGhlIHJvb3QgY2FjaGUuXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgb24gaW5pdGlhbCBtb3VudCwgcHJldmlvdXNDYWNoZSBhbmQgbmV4dENhY2hlIHdpbGwgYmUgdGhlIHNhbWVcbiAgICAgICAgICAgIC8vIGFuZCB0aGlzIHJldGFpbiB3b24ndCBvY2N1ci4gVG8gY291bnRlciB0aGlzLCB3ZSBpbnN0ZWFkIHJldGFpbiB0aGUgSG9zdFJvb3Qnc1xuICAgICAgICAgICAgLy8gaW5pdGlhbCBjYWNoZSB3aGVuIGNyZWF0aW5nIHRoZSByb290IGl0c2VsZiAoc2VlIGNyZWF0ZUZpYmVyUm9vdCgpIGluXG4gICAgICAgICAgICAvLyBSZWFjdEZpYmVyUm9vdC5qcykuIFN1YnNlcXVlbnQgdXBkYXRlcyB0aGF0IGNoYW5nZSB0aGUgY2FjaGUgYXJlIHJlZmxlY3RlZFxuICAgICAgICAgICAgLy8gaGVyZSwgc3VjaCB0aGF0IHByZXZpb3VzL25leHQgY2FjaGVzIGFyZSByZXRhaW5lZCBjb3JyZWN0bHkuXG5cbiAgICAgICAgICAgIGlmIChuZXh0Q2FjaGUgIT09IHByZXZpb3VzQ2FjaGUpIHtcbiAgICAgICAgICAgICAgcmV0YWluQ2FjaGUobmV4dENhY2hlKTtcblxuICAgICAgICAgICAgICBpZiAocHJldmlvdXNDYWNoZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVsZWFzZUNhY2hlKHByZXZpb3VzQ2FjaGUpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICAvLyBUT0RPOiBQYXNzIGBjdXJyZW50YCBhcyBhcmd1bWVudCB0byB0aGlzIGZ1bmN0aW9uXG4gICAgICAgIHZhciBfaW5zdGFuY2UzID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgdmFyIG5leHRTdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICB2YXIgaXNIaWRkZW4gPSBuZXh0U3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICAgICAgaWYgKF9pbnN0YW5jZTMuX3Zpc2liaWxpdHkgJiBPZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgLy8gVGhlIGVmZmVjdHMgYXJlIGN1cnJlbnRseSBjb25uZWN0ZWQuIFVwZGF0ZSB0aGVtLlxuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gVGhlIGVmZmVjdHMgYXJlIGN1cnJlbnRseSBkaXNjb25uZWN0ZWQuIFNpbmNlIHRoZSB0cmVlIGlzIGhpZGRlbixcbiAgICAgICAgICAgICAgLy8gZG9uJ3QgY29ubmVjdCB0aGVtLiBUaGlzIGFsc28gYXBwbGllcyB0byB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBcIkF0b21pY1wiIGVmZmVjdHMgYXJlIG9uZXMgdGhhdCBuZWVkIHRvIGZpcmUgb24gZXZlcnkgY29tbWl0LFxuICAgICAgICAgICAgICAgIC8vIGV2ZW4gZHVyaW5nIHByZS1yZW5kZXJpbmcuIEFuIGV4YW1wbGUgaXMgdXBkYXRpbmcgdGhlIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgIC8vIGNvdW50IG9uIGNhY2hlIGluc3RhbmNlcy5cbiAgICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRyZWUgaXMgdmlzaWJsZVxuICAgICAgICAgIGlmIChfaW5zdGFuY2UzLl92aXNpYmlsaXR5ICYgT2Zmc2NyZWVuUGFzc2l2ZUVmZmVjdHNDb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIC8vIFRoZSBlZmZlY3RzIGFyZSBjdXJyZW50bHkgY29ubmVjdGVkLiBVcGRhdGUgdGhlbS5cbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGUgZWZmZWN0cyBhcmUgY3VycmVudGx5IGRpc2Nvbm5lY3RlZC4gUmVjb25uZWN0IHRoZW0sIHdoaWxlIGFsc29cbiAgICAgICAgICAgIC8vIGZpcmluZyBlZmZlY3RzIGluc2lkZSBuZXdseSBtb3VudGVkIHRyZWVzLiBUaGlzIGFsc28gYXBwbGllcyB0b1xuICAgICAgICAgICAgLy8gdGhlIGluaXRpYWwgcmVuZGVyLlxuICAgICAgICAgICAgX2luc3RhbmNlMy5fdmlzaWJpbGl0eSB8PSBPZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZDtcbiAgICAgICAgICAgIHZhciBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzID0gKGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3MgJiBQYXNzaXZlTWFzaykgIT09IE5vRmxhZ3MkMTtcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zLCBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmxhZ3MgJiBQYXNzaXZlJDEpIHtcbiAgICAgICAgICB2YXIgX2N1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuICAgICAgICAgIGNvbW1pdE9mZnNjcmVlblBhc3NpdmVNb3VudEVmZmVjdHMoX2N1cnJlbnQsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgQ2FjaGVDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMpO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFBhc3NpdmUkMSkge1xuICAgICAgICAgIC8vIFRPRE86IFBhc3MgYGN1cnJlbnRgIGFzIGFyZ3VtZW50IHRvIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgICB2YXIgX2N1cnJlbnQyID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZTtcbiAgICAgICAgICBjb21taXRDYWNoZVBhc3NpdmVNb3VudEVmZmVjdChfY3VycmVudDIsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgVHJhY2luZ01hcmtlckNvbXBvbmVudDpcblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRSb290LCBwYXJlbnRGaWJlciwgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zLCBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gdmlzaXRzIGJvdGggbmV3bHkgZmluaXNoZWQgd29yayBhbmQgbm9kZXMgdGhhdCB3ZXJlIHJlLXVzZWRcbiAgLy8gZnJvbSBhIHByZXZpb3VzbHkgY29tbWl0dGVkIHRyZWUuIFdlIGNhbm5vdCBjaGVjayBub24tc3RhdGljIGZsYWdzIGlmIHRoZVxuICAvLyBub2RlIHdhcyByZXVzZWQuXG4gIHZhciBjaGlsZFNob3VsZEluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgPSBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiBQYXNzaXZlTWFzaykgIT09IE5vRmxhZ3MkMTsgLy8gVE9ETyAoT2Zmc2NyZWVuKSBDaGVjazogZmxhZ3MgJiAoUmVmU3RhdGljIHwgTGF5b3V0U3RhdGljKVxuXG4gIHZhciBwcmV2RGVidWdGaWJlciA9IGdldEN1cnJlbnRGaWJlcigpO1xuICB2YXIgY2hpbGQgPSBwYXJlbnRGaWJlci5jaGlsZDtcblxuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICByZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFJvb3QsIGNoaWxkLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMsIGNoaWxkU2hvdWxkSW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyk7XG4gICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICB9XG5cbiAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihwcmV2RGVidWdGaWJlcik7XG59XG5cbmZ1bmN0aW9uIHJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMsIC8vIFRoaXMgZnVuY3Rpb24gdmlzaXRzIGJvdGggbmV3bHkgZmluaXNoZWQgd29yayBhbmQgbm9kZXMgdGhhdCB3ZXJlIHJlLXVzZWRcbi8vIGZyb20gYSBwcmV2aW91c2x5IGNvbW1pdHRlZCB0cmVlLiBXZSBjYW5ub3QgY2hlY2sgbm9uLXN0YXRpYyBmbGFncyBpZiB0aGVcbi8vIG5vZGUgd2FzIHJldXNlZC5cbmluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMpIHtcbiAgdmFyIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuXG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMsIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMpOyAvLyBUT0RPOiBDaGVjayBmb3IgUGFzc2l2ZVN0YXRpYyBmbGFnXG5cbiAgICAgICAgY29tbWl0SG9va1Bhc3NpdmVNb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrLCBQYXNzaXZlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgLy8gVW5saWtlIGNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIsIHdlIGRvbid0IG5lZWQgdG8gaGFuZGxlIEhvc3RSb290XG4gICAgLy8gYmVjYXVzZSB0aGlzIGZ1bmN0aW9uIG9ubHkgdmlzaXRzIG5vZGVzIHRoYXQgYXJlIGluc2lkZSBhblxuICAgIC8vIE9mZnNjcmVlbiBmaWJlci5cbiAgICAvLyBjYXNlIEhvc3RSb290OiB7XG4gICAgLy8gIC4uLlxuICAgIC8vIH1cblxuICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfaW5zdGFuY2U0ID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgdmFyIG5leHRTdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICB2YXIgaXNIaWRkZW4gPSBuZXh0U3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICAgICAgaWYgKF9pbnN0YW5jZTQuX3Zpc2liaWxpdHkgJiBPZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgLy8gVGhlIGVmZmVjdHMgYXJlIGN1cnJlbnRseSBjb25uZWN0ZWQuIFVwZGF0ZSB0aGVtLlxuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMsIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vIFRoZSBlZmZlY3RzIGFyZSBjdXJyZW50bHkgZGlzY29ubmVjdGVkLiBTaW5jZSB0aGUgdHJlZSBpcyBoaWRkZW4sXG4gICAgICAgICAgICAgIC8vIGRvbid0IGNvbm5lY3QgdGhlbS4gVGhpcyBhbHNvIGFwcGxpZXMgdG8gdGhlIGluaXRpYWwgcmVuZGVyLlxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gXCJBdG9taWNcIiBlZmZlY3RzIGFyZSBvbmVzIHRoYXQgbmVlZCB0byBmaXJlIG9uIGV2ZXJ5IGNvbW1pdCxcbiAgICAgICAgICAgICAgICAvLyBldmVuIGR1cmluZyBwcmUtcmVuZGVyaW5nLiBBbiBleGFtcGxlIGlzIHVwZGF0aW5nIHRoZSByZWZlcmVuY2VcbiAgICAgICAgICAgICAgICAvLyBjb3VudCBvbiBjYWNoZSBpbnN0YW5jZXMuXG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUcmVlIGlzIHZpc2libGVcbiAgICAgICAgICAvLyBTaW5jZSB3ZSdyZSBhbHJlYWR5IGluc2lkZSBhIHJlY29ubmVjdGluZyB0cmVlLCBpdCBkb2Vzbid0IG1hdHRlclxuICAgICAgICAgIC8vIHdoZXRoZXIgdGhlIGVmZmVjdHMgYXJlIGN1cnJlbnRseSBjb25uZWN0ZWQuIEluIGVpdGhlciBjYXNlLCB3ZSdsbFxuICAgICAgICAgIC8vIGNvbnRpbnVlIHRyYXZlcnNpbmcgdGhlIHRyZWUgYW5kIGZpcmluZyBhbGwgdGhlIGVmZmVjdHMuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBXZSBkbyBuZWVkIHRvIHNldCB0aGUgXCJjb25uZWN0ZWRcIiBmbGFnIG9uIHRoZSBpbnN0YW5jZSwgdGhvdWdoLlxuICAgICAgICAgIF9pbnN0YW5jZTQuX3Zpc2liaWxpdHkgfD0gT2Zmc2NyZWVuUGFzc2l2ZUVmZmVjdHNDb25uZWN0ZWQ7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMsIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiYgZmxhZ3MgJiBQYXNzaXZlJDEpIHtcbiAgICAgICAgICAvLyBUT0RPOiBQYXNzIGBjdXJyZW50YCBhcyBhcmd1bWVudCB0byB0aGlzIGZ1bmN0aW9uXG4gICAgICAgICAgdmFyIF9jdXJyZW50MyA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG4gICAgICAgICAgY29tbWl0T2Zmc2NyZWVuUGFzc2l2ZU1vdW50RWZmZWN0cyhfY3VycmVudDMsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgQ2FjaGVDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zLCBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzKTtcblxuICAgICAgICBpZiAoaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJiBmbGFncyAmIFBhc3NpdmUkMSkge1xuICAgICAgICAgIC8vIFRPRE86IFBhc3MgYGN1cnJlbnRgIGFzIGFyZ3VtZW50IHRvIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgICB2YXIgX2N1cnJlbnQ0ID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZTtcbiAgICAgICAgICBjb21taXRDYWNoZVBhc3NpdmVNb3VudEVmZmVjdChfY3VycmVudDQsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgVHJhY2luZ01hcmtlckNvbXBvbmVudDpcblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zLCBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgcGFyZW50RmliZXIsIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucykge1xuICAvLyBcIkF0b21pY1wiIGVmZmVjdHMgYXJlIG9uZXMgdGhhdCBuZWVkIHRvIGZpcmUgb24gZXZlcnkgY29tbWl0LCBldmVuIGR1cmluZ1xuICAvLyBwcmUtcmVuZGVyaW5nLiBXZSBjYWxsIHRoaXMgZnVuY3Rpb24gd2hlbiB0cmF2ZXJzaW5nIGEgaGlkZGVuIHRyZWUgd2hvc2VcbiAgLy8gcmVndWxhciBlZmZlY3RzIGFyZSBjdXJyZW50bHkgZGlzY29ubmVjdGVkLlxuICB2YXIgcHJldkRlYnVnRmliZXIgPSBnZXRDdXJyZW50RmliZXIoKTsgLy8gVE9ETzogQWRkIHNwZWNpYWwgZmxhZyBmb3IgYXRvbWljIGVmZmVjdHNcblxuICBpZiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgUGFzc2l2ZU1hc2spIHtcbiAgICB2YXIgY2hpbGQgPSBwYXJlbnRGaWJlci5jaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihjaGlsZCk7XG4gICAgICBjb21taXRBdG9taWNQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFJvb3QsIGNoaWxkKTtcbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG4gIH1cblxuICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKHByZXZEZWJ1Z0ZpYmVyKTtcbn1cblxuZnVuY3Rpb24gY29tbWl0QXRvbWljUGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucykge1xuICAvLyBcIkF0b21pY1wiIGVmZmVjdHMgYXJlIG9uZXMgdGhhdCBuZWVkIHRvIGZpcmUgb24gZXZlcnkgY29tbWl0LCBldmVuIGR1cmluZ1xuICAvLyBwcmUtcmVuZGVyaW5nLiBXZSBjYWxsIHRoaXMgZnVuY3Rpb24gd2hlbiB0cmF2ZXJzaW5nIGEgaGlkZGVuIHRyZWUgd2hvc2VcbiAgLy8gcmVndWxhciBlZmZlY3RzIGFyZSBjdXJyZW50bHkgZGlzY29ubmVjdGVkLlxuICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG5cbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgUGFzc2l2ZSQxKSB7XG4gICAgICAgICAgLy8gVE9ETzogUGFzcyBgY3VycmVudGAgYXMgYXJndW1lbnQgdG8gdGhpcyBmdW5jdGlvblxuICAgICAgICAgIHZhciBjdXJyZW50ID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZTtcbiAgICAgICAgICBjb21taXRPZmZzY3JlZW5QYXNzaXZlTW91bnRFZmZlY3RzKGN1cnJlbnQsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgQ2FjaGVDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgUGFzc2l2ZSQxKSB7XG4gICAgICAgICAgLy8gVE9ETzogUGFzcyBgY3VycmVudGAgYXMgYXJndW1lbnQgdG8gdGhpcyBmdW5jdGlvblxuICAgICAgICAgIHZhciBfY3VycmVudDUgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuICAgICAgICAgIGNvbW1pdENhY2hlUGFzc2l2ZU1vdW50RWZmZWN0KF9jdXJyZW50NSwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yaykge1xuICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKGZpbmlzaGVkV29yayk7XG4gIGNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlcihmaW5pc2hlZFdvcmspO1xuICByZXNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoKTtcbn0gLy8gSWYgd2UncmUgaW5zaWRlIGEgYnJhbmQgbmV3IHRyZWUsIG9yIGEgdHJlZSB0aGF0IHdhcyBhbHJlYWR5IHZpc2libGUsIHRoZW4gd2Vcbi8vIHNob3VsZCBvbmx5IHN1c3BlbmQgaG9zdCBjb21wb25lbnRzIHRoYXQgaGF2ZSBhIFNob3VsZFN1c3BlbmRDb21taXQgZmxhZy5cbi8vIENvbXBvbmVudHMgd2l0aG91dCBpdCBoYXZlbid0IGNoYW5nZWQgc2luY2UgdGhlIGxhc3QgY29tbWl0LCBzbyB3ZSBjYW4gc2tpcFxuLy8gb3ZlciB0aG9zZS5cbi8vXG4vLyBXaGVuIHdlIGVudGVyIGEgdHJlZSB0aGF0IGlzIGJlaW5nIHJldmVhbGVkIChnb2luZyBmcm9tIGhpZGRlbiAtPiB2aXNpYmxlKSxcbi8vIHdlIG5lZWQgdG8gc3VzcGVuZCBfYW55XyBjb21wb25lbnQgdGhhdCBfbWF5XyBzdXNwZW5kLiBFdmVuIGlmIHRoZXkncmVcbi8vIGFscmVhZHkgaW4gdGhlIFwiY3VycmVudFwiIHRyZWUuIEJlY2F1c2UgdGhlaXIgdmlzaWJpbGl0eSBoYXMgY2hhbmdlZCwgdGhlXG4vLyBicm93c2VyIG1heSBub3QgaGF2ZSBwcmVyZW5kZXJlZCB0aGVtIHlldC4gU28gd2UgY2hlY2sgdGhlIE1heVN1c3BlbmRDb21taXRcbi8vIGZsYWcgaW5zdGVhZC5cblxudmFyIHN1c3BlbnNleUNvbW1pdEZsYWcgPSBTaG91bGRTdXNwZW5kQ29tbWl0O1xuZnVuY3Rpb24gYWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaW5pc2hlZFdvcmspIHtcbiAgYWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdE9uRmliZXIoZmluaXNoZWRXb3JrKTtcbn1cblxuZnVuY3Rpb24gcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KHBhcmVudEZpYmVyKSB7XG4gIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiBzdXNwZW5zZXlDb21taXRGbGFnKSB7XG4gICAgdmFyIGNoaWxkID0gcGFyZW50RmliZXIuY2hpbGQ7XG5cbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXRPbkZpYmVyKGNoaWxkKTtcbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdE9uRmliZXIoZmliZXIpIHtcbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RIb2lzdGFibGU6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcik7XG5cbiAgICAgICAgaWYgKGZpYmVyLmZsYWdzICYgc3VzcGVuc2V5Q29tbWl0RmxhZykge1xuICAgICAgICAgIGlmIChmaWJlci5tZW1vaXplZFN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzdXNwZW5kUmVzb3VyY2UoIC8vIFRoaXMgc2hvdWxkIGFsd2F5cyBiZSBzZXQgYnkgdmlzaXRpbmcgSG9zdFJvb3QgZmlyc3RcbiAgICAgICAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290LCBmaWJlci5tZW1vaXplZFN0YXRlLCBmaWJlci5tZW1vaXplZFByb3BzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBmaWJlci50eXBlO1xuICAgICAgICAgICAgdmFyIHByb3BzID0gZmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICAgIHN1c3BlbmRJbnN0YW5jZSh0eXBlLCBwcm9wcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcik7XG5cbiAgICAgICAgaWYgKGZpYmVyLmZsYWdzICYgc3VzcGVuc2V5Q29tbWl0RmxhZykge1xuICAgICAgICAgIHZhciBfdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgdmFyIF9wcm9wcyA9IGZpYmVyLm1lbW9pemVkUHJvcHM7XG4gICAgICAgICAgc3VzcGVuZEluc3RhbmNlKF90eXBlLCBfcHJvcHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzUmVzb3VyY2VzKSB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzSG9pc3RhYmxlUm9vdCA9IGN1cnJlbnRIb2lzdGFibGVSb290O1xuICAgICAgICAgIHZhciBjb250YWluZXIgPSBmaWJlci5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCA9IGdldEhvaXN0YWJsZVJvb3QoY29udGFpbmVyKTtcbiAgICAgICAgICByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpO1xuICAgICAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290ID0gcHJldmlvdXNIb2lzdGFibGVSb290O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcik7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgaXNIaWRkZW4gPSBmaWJlci5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuXG4gICAgICAgIGlmIChpc0hpZGRlbikgOyBlbHNlIHtcbiAgICAgICAgICB2YXIgY3VycmVudCA9IGZpYmVyLmFsdGVybmF0ZTtcbiAgICAgICAgICB2YXIgd2FzSGlkZGVuID0gY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50Lm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgICBpZiAod2FzSGlkZGVuKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHRyZWUgaXMgYmVpbmcgcmV2ZWFsZWQuIFZpc2l0IGFsbCBuZXdseSB2aXNpYmxlIHN1c3BlbnNleVxuICAgICAgICAgICAgLy8gaW5zdGFuY2VzLCBldmVuIGlmIHRoZXkncmUgaW4gdGhlIGN1cnJlbnQgdHJlZS5cbiAgICAgICAgICAgIHZhciBwcmV2RmxhZ3MgPSBzdXNwZW5zZXlDb21taXRGbGFnO1xuICAgICAgICAgICAgc3VzcGVuc2V5Q29tbWl0RmxhZyA9IE1heVN1c3BlbmRDb21taXQ7XG4gICAgICAgICAgICByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpO1xuICAgICAgICAgICAgc3VzcGVuc2V5Q29tbWl0RmxhZyA9IHByZXZGbGFncztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpYmVyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcik7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0YWNoQWx0ZXJuYXRlU2libGluZ3MocGFyZW50RmliZXIpIHtcbiAgLy8gQSBmaWJlciB3YXMgZGVsZXRlZCBmcm9tIHRoaXMgcGFyZW50IGZpYmVyLCBidXQgaXQncyBzdGlsbCBwYXJ0IG9mIHRoZVxuICAvLyBwcmV2aW91cyAoYWx0ZXJuYXRlKSBwYXJlbnQgZmliZXIncyBsaXN0IG9mIGNoaWxkcmVuLiBCZWNhdXNlIGNoaWxkcmVuXG4gIC8vIGFyZSBhIGxpbmtlZCBsaXN0LCBhbiBlYXJsaWVyIHNpYmxpbmcgdGhhdCdzIHN0aWxsIGFsaXZlIHdpbGwgYmVcbiAgLy8gY29ubmVjdGVkIHRvIHRoZSBkZWxldGVkIGZpYmVyIHZpYSBpdHMgYGFsdGVybmF0ZWA6XG4gIC8vXG4gIC8vICAgbGl2ZSBmaWJlciAtLWFsdGVybmF0ZS0tPiBwcmV2aW91cyBsaXZlIGZpYmVyIC0tc2libGluZy0tPiBkZWxldGVkXG4gIC8vICAgZmliZXJcbiAgLy9cbiAgLy8gV2UgY2FuJ3QgZGlzY29ubmVjdCBgYWx0ZXJuYXRlYCBvbiBub2RlcyB0aGF0IGhhdmVuJ3QgYmVlbiBkZWxldGVkIHlldCxcbiAgLy8gYnV0IHdlIGNhbiBkaXNjb25uZWN0IHRoZSBgc2libGluZ2AgYW5kIGBjaGlsZGAgcG9pbnRlcnMuXG4gIHZhciBwcmV2aW91c0ZpYmVyID0gcGFyZW50RmliZXIuYWx0ZXJuYXRlO1xuXG4gIGlmIChwcmV2aW91c0ZpYmVyICE9PSBudWxsKSB7XG4gICAgdmFyIGRldGFjaGVkQ2hpbGQgPSBwcmV2aW91c0ZpYmVyLmNoaWxkO1xuXG4gICAgaWYgKGRldGFjaGVkQ2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHByZXZpb3VzRmliZXIuY2hpbGQgPSBudWxsO1xuXG4gICAgICBkbyB7XG4gICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgICB2YXIgZGV0YWNoZWRTaWJsaW5nID0gZGV0YWNoZWRDaGlsZC5zaWJsaW5nOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuICAgICAgICBkZXRhY2hlZENoaWxkLnNpYmxpbmcgPSBudWxsO1xuICAgICAgICBkZXRhY2hlZENoaWxkID0gZGV0YWNoZWRTaWJsaW5nO1xuICAgICAgfSB3aGlsZSAoZGV0YWNoZWRDaGlsZCAhPT0gbnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEhvb2tQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBob29rRmxhZ3MpIHtcbiAgaWYgKHNob3VsZFByb2ZpbGUoZmluaXNoZWRXb3JrKSkge1xuICAgIHN0YXJ0UGFzc2l2ZUVmZmVjdFRpbWVyKCk7XG4gICAgY29tbWl0SG9va0VmZmVjdExpc3RVbm1vdW50KGhvb2tGbGFncywgZmluaXNoZWRXb3JrLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgICByZWNvcmRQYXNzaXZlRWZmZWN0RHVyYXRpb24oZmluaXNoZWRXb3JrKTtcbiAgfSBlbHNlIHtcbiAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoaG9va0ZsYWdzLCBmaW5pc2hlZFdvcmssIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMocGFyZW50RmliZXIpIHtcbiAgLy8gRGVsZXRpb25zIGVmZmVjdHMgY2FuIGJlIHNjaGVkdWxlZCBvbiBhbnkgZmliZXIgdHlwZS4gVGhleSBuZWVkIHRvIGhhcHBlblxuICAvLyBiZWZvcmUgdGhlIGNoaWxkcmVuIGVmZmVjdHMgaGF2ZSBmaXJlZC5cbiAgdmFyIGRlbGV0aW9ucyA9IHBhcmVudEZpYmVyLmRlbGV0aW9ucztcblxuICBpZiAoKHBhcmVudEZpYmVyLmZsYWdzICYgQ2hpbGREZWxldGlvbikgIT09IE5vRmxhZ3MkMSkge1xuICAgIGlmIChkZWxldGlvbnMgIT09IG51bGwpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsZXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZFRvRGVsZXRlID0gZGVsZXRpb25zW2ldOyAvLyBUT0RPOiBDb252ZXJ0IHRoaXMgdG8gdXNlIHJlY3Vyc2lvblxuXG4gICAgICAgIG5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgICAgICBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2JlZ2luKGNoaWxkVG9EZWxldGUsIHBhcmVudEZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZXRhY2hBbHRlcm5hdGVTaWJsaW5ncyhwYXJlbnRGaWJlcik7XG4gIH1cblxuICB2YXIgcHJldkRlYnVnRmliZXIgPSBnZXRDdXJyZW50RmliZXIoKTsgLy8gVE9ETzogU3BsaXQgUGFzc2l2ZU1hc2sgaW50byBzZXBhcmF0ZSBtYXNrcyBmb3IgbW91bnQgYW5kIHVubW91bnQ/XG5cbiAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIFBhc3NpdmVNYXNrKSB7XG4gICAgdmFyIGNoaWxkID0gcGFyZW50RmliZXIuY2hpbGQ7XG5cbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoY2hpbGQpO1xuICAgICAgY29tbWl0UGFzc2l2ZVVubW91bnRPbkZpYmVyKGNoaWxkKTtcbiAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICB9XG4gIH1cblxuICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKHByZXZEZWJ1Z0ZpYmVyKTtcbn1cblxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRPbkZpYmVyKGZpbmlzaGVkV29yaykge1xuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcblxuICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmZsYWdzICYgUGFzc2l2ZSQxKSB7XG4gICAgICAgICAgY29tbWl0SG9va1Bhc3NpdmVVbm1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIFBhc3NpdmUgfCBIYXNFZmZlY3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgdmFyIG5leHRTdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICB2YXIgaXNIaWRkZW4gPSBuZXh0U3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgaWYgKGlzSGlkZGVuICYmIGluc3RhbmNlLl92aXNpYmlsaXR5ICYgT2Zmc2NyZWVuUGFzc2l2ZUVmZmVjdHNDb25uZWN0ZWQgJiYgKCAvLyBGb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGRvbid0IHVubW91bnQgd2hlbiBhIHRyZWUgc3VzcGVuZHMuIEluXG4gICAgICAgIC8vIHRoZSBmdXR1cmUgd2UgbWF5IGNoYW5nZSB0aGlzIHRvIHVubW91bnQgYWZ0ZXIgYSBkZWxheS5cbiAgICAgICAgZmluaXNoZWRXb3JrLnJldHVybiA9PT0gbnVsbCB8fCBmaW5pc2hlZFdvcmsucmV0dXJuLnRhZyAhPT0gU3VzcGVuc2VDb21wb25lbnQpKSB7XG4gICAgICAgICAgLy8gVGhlIGVmZmVjdHMgYXJlIGN1cnJlbnRseSBjb25uZWN0ZWQuIERpc2Nvbm5lY3QgdGhlbS5cbiAgICAgICAgICAvLyBUT0RPOiBBZGQgb3B0aW9uIG9yIGhldXJpc3RpYyB0byBkZWxheSBiZWZvcmUgZGlzY29ubmVjdGluZyB0aGVcbiAgICAgICAgICAvLyBlZmZlY3RzLiBUaGVuIGlmIHRoZSB0cmVlIHJlYXBwZWFycyBiZWZvcmUgdGhlIGRlbGF5IGhhcyBlbGFwc2VkLCB3ZVxuICAgICAgICAgIC8vIGNhbiBza2lwIHRvZ2dsaW5nIHRoZSBlZmZlY3RzIGVudGlyZWx5LlxuICAgICAgICAgIGluc3RhbmNlLl92aXNpYmlsaXR5ICY9IH5PZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZDtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVVbm1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMocGFyZW50RmliZXIpIHtcbiAgLy8gRGVsZXRpb25zIGVmZmVjdHMgY2FuIGJlIHNjaGVkdWxlZCBvbiBhbnkgZmliZXIgdHlwZS4gVGhleSBuZWVkIHRvIGhhcHBlblxuICAvLyBiZWZvcmUgdGhlIGNoaWxkcmVuIGVmZmVjdHMgaGF2ZSBmaXJlZC5cbiAgdmFyIGRlbGV0aW9ucyA9IHBhcmVudEZpYmVyLmRlbGV0aW9ucztcblxuICBpZiAoKHBhcmVudEZpYmVyLmZsYWdzICYgQ2hpbGREZWxldGlvbikgIT09IE5vRmxhZ3MkMSkge1xuICAgIGlmIChkZWxldGlvbnMgIT09IG51bGwpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsZXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjaGlsZFRvRGVsZXRlID0gZGVsZXRpb25zW2ldOyAvLyBUT0RPOiBDb252ZXJ0IHRoaXMgdG8gdXNlIHJlY3Vyc2lvblxuXG4gICAgICAgIG5leHRFZmZlY3QgPSBjaGlsZFRvRGVsZXRlO1xuICAgICAgICBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2JlZ2luKGNoaWxkVG9EZWxldGUsIHBhcmVudEZpYmVyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkZXRhY2hBbHRlcm5hdGVTaWJsaW5ncyhwYXJlbnRGaWJlcik7XG4gIH1cblxuICB2YXIgcHJldkRlYnVnRmliZXIgPSBnZXRDdXJyZW50RmliZXIoKTsgLy8gVE9ETzogQ2hlY2sgUGFzc2l2ZVN0YXRpYyBmbGFnXG5cbiAgdmFyIGNoaWxkID0gcGFyZW50RmliZXIuY2hpbGQ7XG5cbiAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihjaGlsZCk7XG4gICAgZGlzY29ubmVjdFBhc3NpdmVFZmZlY3QoY2hpbGQpO1xuICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgfVxuXG4gIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYocHJldkRlYnVnRmliZXIpO1xufVxuXG5mdW5jdGlvbiBkaXNjb25uZWN0UGFzc2l2ZUVmZmVjdChmaW5pc2hlZFdvcmspIHtcbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICAvLyBUT0RPOiBDaGVjayBQYXNzaXZlU3RhdGljIGZsYWdcbiAgICAgICAgY29tbWl0SG9va1Bhc3NpdmVVbm1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIFBhc3NpdmUpOyAvLyBXaGVuIGRpc2Nvbm5lY3RpbmcgcGFzc2l2ZSBlZmZlY3RzLCB3ZSBmaXJlIHRoZSBlZmZlY3RzIGluIHRoZSBzYW1lXG4gICAgICAgIC8vIG9yZGVyIGFzIGR1cmluZyBhIGRlbGV0aW9uZzogcGFyZW50IGJlZm9yZSBjaGlsZFxuXG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAoaW5zdGFuY2UuX3Zpc2liaWxpdHkgJiBPZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZCkge1xuICAgICAgICAgIGluc3RhbmNlLl92aXNpYmlsaXR5ICY9IH5PZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZDtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbihkZWxldGVkU3VidHJlZVJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0OyAvLyBEZWxldGlvbiBlZmZlY3RzIGZpcmUgaW4gcGFyZW50IC0+IGNoaWxkIG9yZGVyXG4gICAgLy8gVE9ETzogQ2hlY2sgaWYgZmliZXIgaGFzIGEgUGFzc2l2ZVN0YXRpYyBmbGFnXG5cbiAgICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKGZpYmVyKTtcbiAgICBjb21taXRQYXNzaXZlVW5tb3VudEluc2lkZURlbGV0ZWRUcmVlT25GaWJlcihmaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgcmVzZXRDdXJyZW50RGVidWdGaWJlckluREVWKCk7XG4gICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7IC8vIFRPRE86IE9ubHkgdHJhdmVyc2Ugc3VidHJlZSBpZiBpdCBoYXMgYSBQYXNzaXZlU3RhdGljIGZsYWcuXG5cbiAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGNoaWxkLnJldHVybiA9IGZpYmVyO1xuICAgICAgbmV4dEVmZmVjdCA9IGNoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2NvbXBsZXRlKGRlbGV0ZWRTdWJ0cmVlUm9vdCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfY29tcGxldGUoZGVsZXRlZFN1YnRyZWVSb290KSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDtcbiAgICB2YXIgc2libGluZyA9IGZpYmVyLnNpYmxpbmc7XG4gICAgdmFyIHJldHVybkZpYmVyID0gZmliZXIucmV0dXJuOyAvLyBSZWN1cnNpdmVseSB0cmF2ZXJzZSB0aGUgZW50aXJlIGRlbGV0ZWQgdHJlZSBhbmQgY2xlYW4gdXAgZmliZXIgZmllbGRzLlxuICAgIC8vIFRoaXMgaXMgbW9yZSBhZ2dyZXNzaXZlIHRoYW4gaWRlYWwsIGFuZCB0aGUgbG9uZyB0ZXJtIGdvYWwgaXMgdG8gb25seVxuICAgIC8vIGhhdmUgdG8gZGV0YWNoIHRoZSBkZWxldGVkIHRyZWUgYXQgdGhlIHJvb3QuXG5cbiAgICBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cyhmaWJlcik7XG5cbiAgICBpZiAoZmliZXIgPT09IGRlbGV0ZWRTdWJ0cmVlUm9vdCkge1xuICAgICAgbmV4dEVmZmVjdCA9IG51bGw7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgIHNpYmxpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICBuZXh0RWZmZWN0ID0gc2libGluZztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBuZXh0RWZmZWN0ID0gcmV0dXJuRmliZXI7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRJbnNpZGVEZWxldGVkVHJlZU9uRmliZXIoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuICBzd2l0Y2ggKGN1cnJlbnQudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBjb21taXRIb29rUGFzc2l2ZVVubW91bnRFZmZlY3RzKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIFBhc3NpdmUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAvLyBUT0RPOiBydW4gcGFzc2l2ZSB1bm1vdW50IGVmZmVjdHMgd2hlbiB1bm1vdW50aW5nIGEgcm9vdC5cbiAgICAvLyBCZWNhdXNlIHBhc3NpdmUgdW5tb3VudCBlZmZlY3RzIGFyZSBub3QgY3VycmVudGx5IHJ1bixcbiAgICAvLyB0aGUgY2FjaGUgaW5zdGFuY2Ugb3duZWQgYnkgdGhlIHJvb3Qgd2lsbCBuZXZlciBiZSBmcmVlZC5cbiAgICAvLyBXaGVuIGVmZmVjdHMgYXJlIHJ1biwgdGhlIGNhY2hlIHNob3VsZCBiZSBmcmVlZCBoZXJlOlxuICAgIC8vIGNhc2UgSG9zdFJvb3Q6IHtcbiAgICAvLyAgIGlmIChlbmFibGVDYWNoZSkge1xuICAgIC8vICAgICBjb25zdCBjYWNoZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZTtcbiAgICAvLyAgICAgcmVsZWFzZUNhY2hlKGNhY2hlKTtcbiAgICAvLyAgIH1cbiAgICAvLyAgIGJyZWFrO1xuICAgIC8vIH1cblxuICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCAmJiBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgY2FjaGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2w7IC8vIFJldGFpbi9yZWxlYXNlIHRoZSBjYWNoZSB1c2VkIGZvciBwZW5kaW5nIChzdXNwZW5kZWQpIG5vZGVzLlxuICAgICAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgaXMgb25seSByZWFjaGVkIGluIHRoZSBub24tc3VzcGVuZGVkL3Zpc2libGUgY2FzZTpcbiAgICAgICAgICAgIC8vIHdoZW4gdGhlIGNvbnRlbnQgaXMgc3VzcGVuZGVkL2hpZGRlbiwgdGhlIHJldGFpbi9yZWxlYXNlIG9jY3Vyc1xuICAgICAgICAgICAgLy8gdmlhIHRoZSBwYXJlbnQgU3VzcGVuc2UgY29tcG9uZW50IChzZWUgY2FzZSBhYm92ZSkuXG5cbiAgICAgICAgICAgIGlmIChjYWNoZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIHJldGFpbkNhY2hlKGNhY2hlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIENhY2hlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9jYWNoZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZTtcbiAgICAgICAgICByZWxlYXNlQ2FjaGUoX2NhY2hlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldENhY2hlRm9yVHlwZShyZXNvdXJjZVR5cGUpIHtcblxuICB2YXIgY2FjaGUgPSByZWFkQ29udGV4dChDYWNoZUNvbnRleHQpO1xuICB2YXIgY2FjaGVGb3JUeXBlID0gY2FjaGUuZGF0YS5nZXQocmVzb3VyY2VUeXBlKTtcblxuICBpZiAoY2FjaGVGb3JUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICBjYWNoZUZvclR5cGUgPSByZXNvdXJjZVR5cGUoKTtcbiAgICBjYWNoZS5kYXRhLnNldChyZXNvdXJjZVR5cGUsIGNhY2hlRm9yVHlwZSk7XG4gIH1cblxuICByZXR1cm4gY2FjaGVGb3JUeXBlO1xufVxuXG52YXIgRGVmYXVsdEFzeW5jRGlzcGF0Y2hlciA9IHtcbiAgZ2V0Q2FjaGVGb3JUeXBlOiBnZXRDYWNoZUZvclR5cGVcbn07XG5cbntcbiAgRGVmYXVsdEFzeW5jRGlzcGF0Y2hlci5nZXRPd25lciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY3VycmVudDtcbiAgfTtcbn1cblxudmFyIENPTVBPTkVOVF9UWVBFID0gMDtcbnZhciBIQVNfUFNFVURPX0NMQVNTX1RZUEUgPSAxO1xudmFyIFJPTEVfVFlQRSA9IDI7XG52YXIgVEVTVF9OQU1FX1RZUEUgPSAzO1xudmFyIFRFWFRfVFlQRSA9IDQ7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3IpIHtcbiAgdmFyIHN5bWJvbEZvciA9IFN5bWJvbC5mb3I7XG4gIENPTVBPTkVOVF9UWVBFID0gc3ltYm9sRm9yKCdzZWxlY3Rvci5jb21wb25lbnQnKTtcbiAgSEFTX1BTRVVET19DTEFTU19UWVBFID0gc3ltYm9sRm9yKCdzZWxlY3Rvci5oYXNfcHNldWRvX2NsYXNzJyk7XG4gIFJPTEVfVFlQRSA9IHN5bWJvbEZvcignc2VsZWN0b3Iucm9sZScpO1xuICBURVNUX05BTUVfVFlQRSA9IHN5bWJvbEZvcignc2VsZWN0b3IudGVzdF9pZCcpO1xuICBURVhUX1RZUEUgPSBzeW1ib2xGb3IoJ3NlbGVjdG9yLnRleHQnKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tcG9uZW50U2VsZWN0b3IoY29tcG9uZW50KSB7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IENPTVBPTkVOVF9UWVBFLFxuICAgIHZhbHVlOiBjb21wb25lbnRcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUhhc1BzZXVkb0NsYXNzU2VsZWN0b3Ioc2VsZWN0b3JzKSB7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IEhBU19QU0VVRE9fQ0xBU1NfVFlQRSxcbiAgICB2YWx1ZTogc2VsZWN0b3JzXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVSb2xlU2VsZWN0b3Iocm9sZSkge1xuICByZXR1cm4ge1xuICAgICQkdHlwZW9mOiBST0xFX1RZUEUsXG4gICAgdmFsdWU6IHJvbGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRleHRTZWxlY3Rvcih0ZXh0KSB7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IFRFWFRfVFlQRSxcbiAgICB2YWx1ZTogdGV4dFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlVGVzdE5hbWVTZWxlY3RvcihpZCkge1xuICByZXR1cm4ge1xuICAgICQkdHlwZW9mOiBURVNUX05BTUVfVFlQRSxcbiAgICB2YWx1ZTogaWRcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmluZEZpYmVyUm9vdEZvckhvc3RSb290KGhvc3RSb290KSB7XG4gIHZhciBtYXliZUZpYmVyID0gZ2V0SW5zdGFuY2VGcm9tTm9kZShob3N0Um9vdCk7XG5cbiAgaWYgKG1heWJlRmliZXIgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgbWF5YmVGaWJlci5tZW1vaXplZFByb3BzWydkYXRhLXRlc3RuYW1lJ10gIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaG9zdCByb290IHNwZWNpZmllZC4gU2hvdWxkIGJlIGVpdGhlciBhIFJlYWN0IGNvbnRhaW5lciBvciBhIG5vZGUgd2l0aCBhIHRlc3RuYW1lIGF0dHJpYnV0ZS4nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF5YmVGaWJlcjtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZmliZXJSb290ID0gZmluZEZpYmVyUm9vdChob3N0Um9vdCk7XG5cbiAgICBpZiAoZmliZXJSb290ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvdWxkIG5vdCBmaW5kIFJlYWN0IGNvbnRhaW5lciB3aXRoaW4gc3BlY2lmaWVkIGhvc3Qgc3VidHJlZS4nKTtcbiAgICB9IC8vIFRoZSBGbG93IHR5cGUgZm9yIEZpYmVyUm9vdCBpcyBhIGxpdHRsZSBmdW5reS5cbiAgICAvLyBjcmVhdGVGaWJlclJvb3QoKSBjaGVhdHMgdGhpcyBieSB0cmVhdGluZyB0aGUgcm9vdCBhcyA6YW55IGFuZCBhZGRpbmcgc3RhdGVOb2RlIGxhemlseS5cblxuXG4gICAgcmV0dXJuIGZpYmVyUm9vdC5zdGF0ZU5vZGUuY3VycmVudDtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXRjaFNlbGVjdG9yKGZpYmVyLCBzZWxlY3Rvcikge1xuICB2YXIgdGFnID0gZmliZXIudGFnO1xuXG4gIHN3aXRjaCAoc2VsZWN0b3IuJCR0eXBlb2YpIHtcbiAgICBjYXNlIENPTVBPTkVOVF9UWVBFOlxuICAgICAgaWYgKGZpYmVyLnR5cGUgPT09IHNlbGVjdG9yLnZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgSEFTX1BTRVVET19DTEFTU19UWVBFOlxuICAgICAgcmV0dXJuIGhhc01hdGNoaW5nUGF0aHMoZmliZXIsIHNlbGVjdG9yLnZhbHVlKTtcblxuICAgIGNhc2UgUk9MRV9UWVBFOlxuICAgICAgaWYgKHRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCB0YWcgPT09IEhvc3RIb2lzdGFibGUgfHwgdGFnID09PSBIb3N0U2luZ2xldG9uKSB7XG4gICAgICAgIHZhciBub2RlID0gZmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChtYXRjaEFjY2Vzc2liaWxpdHlSb2xlKG5vZGUsIHNlbGVjdG9yLnZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBURVhUX1RZUEU6XG4gICAgICBpZiAodGFnID09PSBIb3N0Q29tcG9uZW50IHx8IHRhZyA9PT0gSG9zdFRleHQgfHwgdGFnID09PSBIb3N0SG9pc3RhYmxlIHx8IHRhZyA9PT0gSG9zdFNpbmdsZXRvbikge1xuICAgICAgICB2YXIgdGV4dENvbnRlbnQgPSBnZXRUZXh0Q29udGVudChmaWJlcik7XG5cbiAgICAgICAgaWYgKHRleHRDb250ZW50ICE9PSBudWxsICYmIHRleHRDb250ZW50LmluZGV4T2Yoc2VsZWN0b3IudmFsdWUpID49IDApIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgVEVTVF9OQU1FX1RZUEU6XG4gICAgICBpZiAodGFnID09PSBIb3N0Q29tcG9uZW50IHx8IHRhZyA9PT0gSG9zdEhvaXN0YWJsZSB8fCB0YWcgPT09IEhvc3RTaW5nbGV0b24pIHtcbiAgICAgICAgdmFyIGRhdGFUZXN0SUQgPSBmaWJlci5tZW1vaXplZFByb3BzWydkYXRhLXRlc3RuYW1lJ107XG5cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhVGVzdElEID09PSAnc3RyaW5nJyAmJiBkYXRhVGVzdElELnRvTG93ZXJDYXNlKCkgPT09IHNlbGVjdG9yLnZhbHVlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc2VsZWN0b3IgdHlwZSBzcGVjaWZpZWQuJyk7XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHNlbGVjdG9yVG9TdHJpbmcoc2VsZWN0b3IpIHtcbiAgc3dpdGNoIChzZWxlY3Rvci4kJHR5cGVvZikge1xuICAgIGNhc2UgQ09NUE9ORU5UX1RZUEU6XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoc2VsZWN0b3IudmFsdWUpIHx8ICdVbmtub3duJztcbiAgICAgIHJldHVybiBcIjxcIiArIGRpc3BsYXlOYW1lICsgXCI+XCI7XG5cbiAgICBjYXNlIEhBU19QU0VVRE9fQ0xBU1NfVFlQRTpcbiAgICAgIHJldHVybiBcIjpoYXMoXCIgKyAoc2VsZWN0b3JUb1N0cmluZyhzZWxlY3RvcikgfHwgJycpICsgXCIpXCI7XG5cbiAgICBjYXNlIFJPTEVfVFlQRTpcbiAgICAgIHJldHVybiBcIltyb2xlPVxcXCJcIiArIHNlbGVjdG9yLnZhbHVlICsgXCJcXFwiXVwiO1xuXG4gICAgY2FzZSBURVhUX1RZUEU6XG4gICAgICByZXR1cm4gXCJcXFwiXCIgKyBzZWxlY3Rvci52YWx1ZSArIFwiXFxcIlwiO1xuXG4gICAgY2FzZSBURVNUX05BTUVfVFlQRTpcbiAgICAgIHJldHVybiBcIltkYXRhLXRlc3RuYW1lPVxcXCJcIiArIHNlbGVjdG9yLnZhbHVlICsgXCJcXFwiXVwiO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciB0eXBlIHNwZWNpZmllZC4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kUGF0aHMocm9vdCwgc2VsZWN0b3JzKSB7XG4gIHZhciBtYXRjaGluZ0ZpYmVycyA9IFtdO1xuICB2YXIgc3RhY2sgPSBbcm9vdCwgMF07XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgd2hpbGUgKGluZGV4IDwgc3RhY2subGVuZ3RoKSB7XG4gICAgdmFyIGZpYmVyID0gc3RhY2tbaW5kZXgrK107XG4gICAgdmFyIHRhZyA9IGZpYmVyLnRhZztcbiAgICB2YXIgc2VsZWN0b3JJbmRleCA9IHN0YWNrW2luZGV4KytdO1xuICAgIHZhciBzZWxlY3RvciA9IHNlbGVjdG9yc1tzZWxlY3RvckluZGV4XTtcblxuICAgIGlmICgodGFnID09PSBIb3N0Q29tcG9uZW50IHx8IHRhZyA9PT0gSG9zdEhvaXN0YWJsZSB8fCB0YWcgPT09IEhvc3RTaW5nbGV0b24pICYmIGlzSGlkZGVuU3VidHJlZShmaWJlcikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoc2VsZWN0b3IgIT0gbnVsbCAmJiBtYXRjaFNlbGVjdG9yKGZpYmVyLCBzZWxlY3RvcikpIHtcbiAgICAgICAgc2VsZWN0b3JJbmRleCsrO1xuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yc1tzZWxlY3RvckluZGV4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0b3JJbmRleCA9PT0gc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgbWF0Y2hpbmdGaWJlcnMucHVzaChmaWJlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgc3RhY2sucHVzaChjaGlsZCwgc2VsZWN0b3JJbmRleCk7XG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWF0Y2hpbmdGaWJlcnM7XG59IC8vIFNhbWUgYXMgZmluZFBhdGhzIGJ1dCB3aXRoIGVhZ2VyIGJhaWxvdXQgb24gZmlyc3QgbWF0Y2hcblxuXG5mdW5jdGlvbiBoYXNNYXRjaGluZ1BhdGhzKHJvb3QsIHNlbGVjdG9ycykge1xuICB2YXIgc3RhY2sgPSBbcm9vdCwgMF07XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgd2hpbGUgKGluZGV4IDwgc3RhY2subGVuZ3RoKSB7XG4gICAgdmFyIGZpYmVyID0gc3RhY2tbaW5kZXgrK107XG4gICAgdmFyIHRhZyA9IGZpYmVyLnRhZztcbiAgICB2YXIgc2VsZWN0b3JJbmRleCA9IHN0YWNrW2luZGV4KytdO1xuICAgIHZhciBzZWxlY3RvciA9IHNlbGVjdG9yc1tzZWxlY3RvckluZGV4XTtcblxuICAgIGlmICgodGFnID09PSBIb3N0Q29tcG9uZW50IHx8IHRhZyA9PT0gSG9zdEhvaXN0YWJsZSB8fCB0YWcgPT09IEhvc3RTaW5nbGV0b24pICYmIGlzSGlkZGVuU3VidHJlZShmaWJlcikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoc2VsZWN0b3IgIT0gbnVsbCAmJiBtYXRjaFNlbGVjdG9yKGZpYmVyLCBzZWxlY3RvcikpIHtcbiAgICAgICAgc2VsZWN0b3JJbmRleCsrO1xuICAgICAgICBzZWxlY3RvciA9IHNlbGVjdG9yc1tzZWxlY3RvckluZGV4XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0b3JJbmRleCA9PT0gc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgc3RhY2sucHVzaChjaGlsZCwgc2VsZWN0b3JJbmRleCk7XG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGZpbmRBbGxOb2Rlcyhob3N0Um9vdCwgc2VsZWN0b3JzKSB7XG4gIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuJyk7XG4gIH1cblxuICB2YXIgcm9vdCA9IGZpbmRGaWJlclJvb3RGb3JIb3N0Um9vdChob3N0Um9vdCk7XG4gIHZhciBtYXRjaGluZ0ZpYmVycyA9IGZpbmRQYXRocyhyb290LCBzZWxlY3RvcnMpO1xuICB2YXIgaW5zdGFuY2VSb290cyA9IFtdO1xuICB2YXIgc3RhY2sgPSBBcnJheS5mcm9tKG1hdGNoaW5nRmliZXJzKTtcbiAgdmFyIGluZGV4ID0gMDtcblxuICB3aGlsZSAoaW5kZXggPCBzdGFjay5sZW5ndGgpIHtcbiAgICB2YXIgbm9kZSA9IHN0YWNrW2luZGV4KytdO1xuICAgIHZhciB0YWcgPSBub2RlLnRhZztcblxuICAgIGlmICh0YWcgPT09IEhvc3RDb21wb25lbnQgfHwgdGFnID09PSBIb3N0SG9pc3RhYmxlIHx8IHRhZyA9PT0gSG9zdFNpbmdsZXRvbikge1xuICAgICAgaWYgKGlzSGlkZGVuU3VidHJlZShub2RlKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaW5zdGFuY2VSb290cy5wdXNoKG5vZGUuc3RhdGVOb2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuICAgICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIHN0YWNrLnB1c2goY2hpbGQpO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGluc3RhbmNlUm9vdHM7XG59XG5mdW5jdGlvbiBnZXRGaW5kQWxsTm9kZXNGYWlsdXJlRGVzY3JpcHRpb24oaG9zdFJvb3QsIHNlbGVjdG9ycykge1xuICBpZiAoIXN1cHBvcnRzVGVzdFNlbGVjdG9ycykge1xuICAgIHRocm93IG5ldyBFcnJvcignVGVzdCBzZWxlY3RvciBBUEkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyLicpO1xuICB9XG5cbiAgdmFyIHJvb3QgPSBmaW5kRmliZXJSb290Rm9ySG9zdFJvb3QoaG9zdFJvb3QpO1xuICB2YXIgbWF4U2VsZWN0b3JJbmRleCA9IDA7XG4gIHZhciBtYXRjaGVkTmFtZXMgPSBbXTsgLy8gVGhlIGxvZ2ljIG9mIHRoaXMgbG9vcCBzaG91bGQgYmUga2VwdCBpbiBzeW5jIHdpdGggZmluZFBhdGhzKClcblxuICB2YXIgc3RhY2sgPSBbcm9vdCwgMF07XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgd2hpbGUgKGluZGV4IDwgc3RhY2subGVuZ3RoKSB7XG4gICAgdmFyIGZpYmVyID0gc3RhY2tbaW5kZXgrK107XG4gICAgdmFyIHRhZyA9IGZpYmVyLnRhZztcbiAgICB2YXIgc2VsZWN0b3JJbmRleCA9IHN0YWNrW2luZGV4KytdO1xuICAgIHZhciBzZWxlY3RvciA9IHNlbGVjdG9yc1tzZWxlY3RvckluZGV4XTtcblxuICAgIGlmICgodGFnID09PSBIb3N0Q29tcG9uZW50IHx8IHRhZyA9PT0gSG9zdEhvaXN0YWJsZSB8fCB0YWcgPT09IEhvc3RTaW5nbGV0b24pICYmIGlzSGlkZGVuU3VidHJlZShmaWJlcikpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hTZWxlY3RvcihmaWJlciwgc2VsZWN0b3IpKSB7XG4gICAgICBtYXRjaGVkTmFtZXMucHVzaChzZWxlY3RvclRvU3RyaW5nKHNlbGVjdG9yKSk7XG4gICAgICBzZWxlY3RvckluZGV4Kys7XG5cbiAgICAgIGlmIChzZWxlY3RvckluZGV4ID4gbWF4U2VsZWN0b3JJbmRleCkge1xuICAgICAgICBtYXhTZWxlY3RvckluZGV4ID0gc2VsZWN0b3JJbmRleDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoc2VsZWN0b3JJbmRleCA8IHNlbGVjdG9ycy5sZW5ndGgpIHtcbiAgICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgc3RhY2sucHVzaChjaGlsZCwgc2VsZWN0b3JJbmRleCk7XG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAobWF4U2VsZWN0b3JJbmRleCA8IHNlbGVjdG9ycy5sZW5ndGgpIHtcbiAgICB2YXIgdW5tYXRjaGVkTmFtZXMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSBtYXhTZWxlY3RvckluZGV4OyBpIDwgc2VsZWN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB1bm1hdGNoZWROYW1lcy5wdXNoKHNlbGVjdG9yVG9TdHJpbmcoc2VsZWN0b3JzW2ldKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuICdmaW5kQWxsTm9kZXMgd2FzIGFibGUgdG8gbWF0Y2ggcGFydCBvZiB0aGUgc2VsZWN0b3I6XFxuJyArIChcIiAgXCIgKyBtYXRjaGVkTmFtZXMuam9pbignID4gJykgKyBcIlxcblxcblwiKSArICdObyBtYXRjaGluZyBjb21wb25lbnQgd2FzIGZvdW5kIGZvcjpcXG4nICsgKFwiICBcIiArIHVubWF0Y2hlZE5hbWVzLmpvaW4oJyA+ICcpKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZmluZEJvdW5kaW5nUmVjdHMoaG9zdFJvb3QsIHNlbGVjdG9ycykge1xuICBpZiAoIXN1cHBvcnRzVGVzdFNlbGVjdG9ycykge1xuICAgIHRocm93IG5ldyBFcnJvcignVGVzdCBzZWxlY3RvciBBUEkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyLicpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlUm9vdHMgPSBmaW5kQWxsTm9kZXMoaG9zdFJvb3QsIHNlbGVjdG9ycyk7XG4gIHZhciBib3VuZGluZ1JlY3RzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnN0YW5jZVJvb3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgYm91bmRpbmdSZWN0cy5wdXNoKGdldEJvdW5kaW5nUmVjdChpbnN0YW5jZVJvb3RzW2ldKSk7XG4gIH1cblxuICBmb3IgKHZhciBfaSA9IGJvdW5kaW5nUmVjdHMubGVuZ3RoIC0gMTsgX2kgPiAwOyBfaS0tKSB7XG4gICAgdmFyIHRhcmdldFJlY3QgPSBib3VuZGluZ1JlY3RzW19pXTtcbiAgICB2YXIgdGFyZ2V0TGVmdCA9IHRhcmdldFJlY3QueDtcbiAgICB2YXIgdGFyZ2V0UmlnaHQgPSB0YXJnZXRMZWZ0ICsgdGFyZ2V0UmVjdC53aWR0aDtcbiAgICB2YXIgdGFyZ2V0VG9wID0gdGFyZ2V0UmVjdC55O1xuICAgIHZhciB0YXJnZXRCb3R0b20gPSB0YXJnZXRUb3AgKyB0YXJnZXRSZWN0LmhlaWdodDtcblxuICAgIGZvciAodmFyIGogPSBfaSAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICBpZiAoX2kgIT09IGopIHtcbiAgICAgICAgdmFyIG90aGVyUmVjdCA9IGJvdW5kaW5nUmVjdHNbal07XG4gICAgICAgIHZhciBvdGhlckxlZnQgPSBvdGhlclJlY3QueDtcbiAgICAgICAgdmFyIG90aGVyUmlnaHQgPSBvdGhlckxlZnQgKyBvdGhlclJlY3Qud2lkdGg7XG4gICAgICAgIHZhciBvdGhlclRvcCA9IG90aGVyUmVjdC55O1xuICAgICAgICB2YXIgb3RoZXJCb3R0b20gPSBvdGhlclRvcCArIG90aGVyUmVjdC5oZWlnaHQ7IC8vIE1lcmdpbmcgYWxsIHJlY3RzIHRvIHRoZSBtaW5pbXVtcyBzZXQgd291bGQgYmUgY29tcGxpY2F0ZWQsXG4gICAgICAgIC8vIGJ1dCB3ZSBjYW4gaGFuZGxlIHRoZSBtb3N0IGNvbW1vbiBjYXNlczpcbiAgICAgICAgLy8gMS4gY29tcGxldGVseSBvdmVybGFwcGluZyByZWN0c1xuICAgICAgICAvLyAyLiBhZGphY2VudCByZWN0cyB0aGF0IGFyZSB0aGUgc2FtZSB3aWR0aCBvciBoZWlnaHQgKGUuZy4gaXRlbXMgaW4gYSBsaXN0KVxuICAgICAgICAvL1xuICAgICAgICAvLyBFdmVuIGdpdmVuIHRoZSBhYm92ZSBjb25zdHJhaW50cyxcbiAgICAgICAgLy8gd2Ugc3RpbGwgd29uJ3QgZW5kIHVwIHdpdGggdGhlIGZld2VzdCBwb3NzaWJsZSByZWN0cyB3aXRob3V0IGRvaW5nIG11bHRpcGxlIHBhc3NlcyxcbiAgICAgICAgLy8gYnV0IGl0J3MgZ29vZCBlbm91Z2ggZm9yIHRoaXMgcHVycG9zZS5cblxuICAgICAgICBpZiAodGFyZ2V0TGVmdCA+PSBvdGhlckxlZnQgJiYgdGFyZ2V0VG9wID49IG90aGVyVG9wICYmIHRhcmdldFJpZ2h0IDw9IG90aGVyUmlnaHQgJiYgdGFyZ2V0Qm90dG9tIDw9IG90aGVyQm90dG9tKSB7XG4gICAgICAgICAgLy8gQ29tcGxldGUgb3ZlcmxhcHBpbmcgcmVjdHM7IHJlbW92ZSB0aGUgaW5uZXIgb25lLlxuICAgICAgICAgIGJvdW5kaW5nUmVjdHMuc3BsaWNlKF9pLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfSBlbHNlIGlmICh0YXJnZXRMZWZ0ID09PSBvdGhlckxlZnQgJiYgdGFyZ2V0UmVjdC53aWR0aCA9PT0gb3RoZXJSZWN0LndpZHRoICYmICEob3RoZXJCb3R0b20gPCB0YXJnZXRUb3ApICYmICEob3RoZXJUb3AgPiB0YXJnZXRCb3R0b20pKSB7XG4gICAgICAgICAgLy8gQWRqYWNlbnQgdmVydGljYWwgcmVjdHM7IG1lcmdlIHRoZW0uXG4gICAgICAgICAgaWYgKG90aGVyVG9wID4gdGFyZ2V0VG9wKSB7XG4gICAgICAgICAgICBvdGhlclJlY3QuaGVpZ2h0ICs9IG90aGVyVG9wIC0gdGFyZ2V0VG9wO1xuICAgICAgICAgICAgb3RoZXJSZWN0LnkgPSB0YXJnZXRUb3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG90aGVyQm90dG9tIDwgdGFyZ2V0Qm90dG9tKSB7XG4gICAgICAgICAgICBvdGhlclJlY3QuaGVpZ2h0ID0gdGFyZ2V0Qm90dG9tIC0gb3RoZXJUb3A7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYm91bmRpbmdSZWN0cy5zcGxpY2UoX2ksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldFRvcCA9PT0gb3RoZXJUb3AgJiYgdGFyZ2V0UmVjdC5oZWlnaHQgPT09IG90aGVyUmVjdC5oZWlnaHQgJiYgIShvdGhlclJpZ2h0IDwgdGFyZ2V0TGVmdCkgJiYgIShvdGhlckxlZnQgPiB0YXJnZXRSaWdodCkpIHtcbiAgICAgICAgICAvLyBBZGphY2VudCBob3Jpem9udGFsIHJlY3RzOyBtZXJnZSB0aGVtLlxuICAgICAgICAgIGlmIChvdGhlckxlZnQgPiB0YXJnZXRMZWZ0KSB7XG4gICAgICAgICAgICBvdGhlclJlY3Qud2lkdGggKz0gb3RoZXJMZWZ0IC0gdGFyZ2V0TGVmdDtcbiAgICAgICAgICAgIG90aGVyUmVjdC54ID0gdGFyZ2V0TGVmdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3RoZXJSaWdodCA8IHRhcmdldFJpZ2h0KSB7XG4gICAgICAgICAgICBvdGhlclJlY3Qud2lkdGggPSB0YXJnZXRSaWdodCAtIG90aGVyTGVmdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBib3VuZGluZ1JlY3RzLnNwbGljZShfaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gYm91bmRpbmdSZWN0cztcbn1cbmZ1bmN0aW9uIGZvY3VzV2l0aGluKGhvc3RSb290LCBzZWxlY3RvcnMpIHtcbiAgaWYgKCFzdXBwb3J0c1Rlc3RTZWxlY3RvcnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rlc3Qgc2VsZWN0b3IgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyByZW5kZXJlci4nKTtcbiAgfVxuXG4gIHZhciByb290ID0gZmluZEZpYmVyUm9vdEZvckhvc3RSb290KGhvc3RSb290KTtcbiAgdmFyIG1hdGNoaW5nRmliZXJzID0gZmluZFBhdGhzKHJvb3QsIHNlbGVjdG9ycyk7XG4gIHZhciBzdGFjayA9IEFycmF5LmZyb20obWF0Y2hpbmdGaWJlcnMpO1xuICB2YXIgaW5kZXggPSAwO1xuXG4gIHdoaWxlIChpbmRleCA8IHN0YWNrLmxlbmd0aCkge1xuICAgIHZhciBmaWJlciA9IHN0YWNrW2luZGV4KytdO1xuICAgIHZhciB0YWcgPSBmaWJlci50YWc7XG5cbiAgICBpZiAoaXNIaWRkZW5TdWJ0cmVlKGZpYmVyKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCB0YWcgPT09IEhvc3RIb2lzdGFibGUgfHwgdGFnID09PSBIb3N0U2luZ2xldG9uKSB7XG4gICAgICB2YXIgbm9kZSA9IGZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgaWYgKHNldEZvY3VzSWZGb2N1c2FibGUobm9kZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7XG5cbiAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN0YWNrLnB1c2goY2hpbGQpO1xuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbnZhciBjb21taXRIb29rcyA9IFtdO1xuZnVuY3Rpb24gb25Db21taXRSb290KCkge1xuICBpZiAoc3VwcG9ydHNUZXN0U2VsZWN0b3JzKSB7XG4gICAgY29tbWl0SG9va3MuZm9yRWFjaChmdW5jdGlvbiAoY29tbWl0SG9vaykge1xuICAgICAgcmV0dXJuIGNvbW1pdEhvb2soKTtcbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gb2JzZXJ2ZVZpc2libGVSZWN0cyhob3N0Um9vdCwgc2VsZWN0b3JzLCBjYWxsYmFjaywgb3B0aW9ucykge1xuICBpZiAoIXN1cHBvcnRzVGVzdFNlbGVjdG9ycykge1xuICAgIHRocm93IG5ldyBFcnJvcignVGVzdCBzZWxlY3RvciBBUEkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyLicpO1xuICB9XG5cbiAgdmFyIGluc3RhbmNlUm9vdHMgPSBmaW5kQWxsTm9kZXMoaG9zdFJvb3QsIHNlbGVjdG9ycyk7XG5cbiAgdmFyIF9zZXR1cEludGVyc2VjdGlvbk9icyA9IHNldHVwSW50ZXJzZWN0aW9uT2JzZXJ2ZXIoaW5zdGFuY2VSb290cywgY2FsbGJhY2ssIG9wdGlvbnMpLFxuICAgICAgZGlzY29ubmVjdCA9IF9zZXR1cEludGVyc2VjdGlvbk9icy5kaXNjb25uZWN0LFxuICAgICAgb2JzZXJ2ZSA9IF9zZXR1cEludGVyc2VjdGlvbk9icy5vYnNlcnZlLFxuICAgICAgdW5vYnNlcnZlID0gX3NldHVwSW50ZXJzZWN0aW9uT2JzLnVub2JzZXJ2ZTsgLy8gV2hlbiBSZWFjdCBtdXRhdGVzIHRoZSBob3N0IGVudmlyb25tZW50LCB3ZSBtYXkgbmVlZCB0byBjaGFuZ2Ugd2hhdCB3ZSdyZSBsaXN0ZW5pbmcgdG8uXG5cblxuICB2YXIgY29tbWl0SG9vayA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbmV4dEluc3RhbmNlUm9vdHMgPSBmaW5kQWxsTm9kZXMoaG9zdFJvb3QsIHNlbGVjdG9ycyk7XG4gICAgaW5zdGFuY2VSb290cy5mb3JFYWNoKGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgIGlmIChuZXh0SW5zdGFuY2VSb290cy5pbmRleE9mKHRhcmdldCkgPCAwKSB7XG4gICAgICAgIHVub2JzZXJ2ZSh0YXJnZXQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG5leHRJbnN0YW5jZVJvb3RzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgaWYgKGluc3RhbmNlUm9vdHMuaW5kZXhPZih0YXJnZXQpIDwgMCkge1xuICAgICAgICBvYnNlcnZlKHRhcmdldCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgY29tbWl0SG9va3MucHVzaChjb21taXRIb29rKTtcbiAgcmV0dXJuIHtcbiAgICBkaXNjb25uZWN0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBTdG9wIGxpc3RlbmluZyBmb3IgUmVhY3QgbXV0YXRpb25zOlxuICAgICAgdmFyIGluZGV4ID0gY29tbWl0SG9va3MuaW5kZXhPZihjb21taXRIb29rKTtcblxuICAgICAgaWYgKGluZGV4ID49IDApIHtcbiAgICAgICAgY29tbWl0SG9va3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH0gLy8gRGlzY29ubmVjdCB0aGUgaG9zdCBvYnNlcnZlcjpcblxuXG4gICAgICBkaXNjb25uZWN0KCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBpc0NvbmN1cnJlbnRBY3RFbnZpcm9ubWVudCgpIHtcbiAge1xuICAgIHZhciBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWwgPSAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC1yZXNvbHZlLW5hbWVdIEZsb3cgZG9lc24ndCBrbm93IGFib3V0IElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCBnbG9iYWxcbiAgICB0eXBlb2YgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UICE9PSAndW5kZWZpbmVkJyA/IC8vICRGbG93Rml4TWVbY2Fubm90LXJlc29sdmUtbmFtZV1cbiAgICBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAoIWlzUmVhY3RBY3RFbnZpcm9ubWVudEdsb2JhbCAmJiBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSW5jbHVkZSBsaW5rIHRvIHJlbGV2YW50IGRvY3VtZW50YXRpb24gcGFnZS5cbiAgICAgIGVycm9yKCdUaGUgY3VycmVudCB0ZXN0aW5nIGVudmlyb25tZW50IGlzIG5vdCBjb25maWd1cmVkIHRvIHN1cHBvcnQgJyArICdhY3QoLi4uKScpO1xuICAgIH1cblxuICAgIHJldHVybiBpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWw7XG4gIH1cbn1cblxudmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbnZhciBOb0NvbnRleHQgPVxuLyogICAgICAgICAgICAgKi9cbjA7XG52YXIgQmF0Y2hlZENvbnRleHQgPVxuLyogICAgICAgICAgICAgICAqL1xuMTtcbnZhciBSZW5kZXJDb250ZXh0ID1cbi8qICAgICAgICAgKi9cbjI7XG52YXIgQ29tbWl0Q29udGV4dCA9XG4vKiAgICAgICAgICovXG40O1xudmFyIFJvb3RJblByb2dyZXNzID0gMDtcbnZhciBSb290RmF0YWxFcnJvcmVkID0gMTtcbnZhciBSb290RXJyb3JlZCA9IDI7XG52YXIgUm9vdFN1c3BlbmRlZCA9IDM7XG52YXIgUm9vdFN1c3BlbmRlZFdpdGhEZWxheSA9IDQ7XG52YXIgUm9vdENvbXBsZXRlZCA9IDU7XG52YXIgUm9vdERpZE5vdENvbXBsZXRlID0gNjsgLy8gRGVzY3JpYmVzIHdoZXJlIHdlIGFyZSBpbiB0aGUgUmVhY3QgZXhlY3V0aW9uIHN0YWNrXG5cbnZhciBleGVjdXRpb25Db250ZXh0ID0gTm9Db250ZXh0OyAvLyBUaGUgcm9vdCB3ZSdyZSB3b3JraW5nIG9uXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsOyAvLyBUaGUgZmliZXIgd2UncmUgd29ya2luZyBvblxuXG52YXIgd29ya0luUHJvZ3Jlc3MgPSBudWxsOyAvLyBUaGUgbGFuZXMgd2UncmUgcmVuZGVyaW5nXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IE5vTGFuZXM7XG52YXIgTm90U3VzcGVuZGVkID0gMDtcbnZhciBTdXNwZW5kZWRPbkVycm9yID0gMTtcbnZhciBTdXNwZW5kZWRPbkRhdGEgPSAyO1xudmFyIFN1c3BlbmRlZE9uSW1tZWRpYXRlID0gMztcbnZhciBTdXNwZW5kZWRPbkluc3RhbmNlID0gNDtcbnZhciBTdXNwZW5kZWRPbkluc3RhbmNlQW5kUmVhZHlUb0NvbnRpbnVlID0gNTtcbnZhciBTdXNwZW5kZWRPbkRlcHJlY2F0ZWRUaHJvd1Byb21pc2UgPSA2O1xudmFyIFN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZSA9IDc7XG52YXIgU3VzcGVuZGVkT25IeWRyYXRpb24gPSA4OyAvLyBXaGVuIHRoaXMgaXMgdHJ1ZSwgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIganVzdCBzdXNwZW5kZWQgKG9yIGVycm9yZWQpIGFuZFxuLy8gd2UndmUgeWV0IHRvIHVud2luZCB0aGUgc3RhY2suIEluIHNvbWUgY2FzZXMsIHdlIG1heSB5aWVsZCB0byB0aGUgbWFpbiB0aHJlYWRcbi8vIGFmdGVyIHRoaXMgaGFwcGVucy4gSWYgdGhlIGZpYmVyIGlzIHBpbmdlZCBiZWZvcmUgd2UgcmVzdW1lLCB3ZSBjYW4gcmV0cnlcbi8vIGltbWVkaWF0ZWx5IGluc3RlYWQgb2YgdW53aW5kaW5nIHRoZSBzdGFjay5cblxudmFyIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xudmFyIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsOyAvLyBXaGV0aGVyIGEgcGluZyBsaXN0ZW5lciB3YXMgYXR0YWNoZWQgZHVyaW5nIHRoaXMgcmVuZGVyLiBUaGlzIGlzIHNsaWdodGx5XG4vLyBkaWZmZXJlbnQgdGhhdCB3aGV0aGVyIHNvbWV0aGluZyBzdXNwZW5kZWQsIGJlY2F1c2Ugd2UgZG9uJ3QgYWRkIG11bHRpcGxlXG4vLyBsaXN0ZW5lcnMgdG8gYSBwcm9taXNlIHdlJ3ZlIGFscmVhZHkgc2VlbiAocGVyIHJvb3QgYW5kIGxhbmUpLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290RGlkQXR0YWNoUGluZ0xpc3RlbmVyID0gZmFsc2U7IC8vIEEgY29udGV4dHVhbCB2ZXJzaW9uIG9mIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzLiBJdCBpcyBhIHN1cGVyc2V0IG9mXG4vLyB0aGUgbGFuZXMgdGhhdCB3ZSBzdGFydGVkIHdvcmtpbmcgb24gYXQgdGhlIHJvb3QuIFdoZW4gd2UgZW50ZXIgYSBzdWJ0cmVlXG4vLyB0aGF0IGlzIGN1cnJlbnRseSBoaWRkZW4sIHdlIGFkZCB0aGUgbGFuZXMgdGhhdCB3b3VsZCBoYXZlIGNvbW1pdHRlZCBpZlxuLy8gdGhlIGhpZGRlbiB0cmVlIGhhZG4ndCBiZWVuIGRlZmVycmVkLiBUaGlzIGlzIG1vZGlmaWVkIGJ5IHRoZVxuLy8gSGlkZGVuQ29udGV4dCBtb2R1bGUuXG4vL1xuLy8gTW9zdCB0aGluZ3MgaW4gdGhlIHdvcmsgbG9vcCBzaG91bGQgZGVhbCB3aXRoIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzLlxuLy8gTW9zdCB0aGluZ3MgaW4gYmVnaW4vY29tcGxldGUgcGhhc2VzIHNob3VsZCBkZWFsIHdpdGggZW50YW5nbGVkUmVuZGVyTGFuZXMuXG5cbnZhciBlbnRhbmdsZWRSZW5kZXJMYW5lcyA9IE5vTGFuZXM7IC8vIFdoZXRoZXIgdG8gcm9vdCBjb21wbGV0ZWQsIGVycm9yZWQsIHN1c3BlbmRlZCwgZXRjLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RJblByb2dyZXNzOyAvLyBUaGUgd29yayBsZWZ0IG92ZXIgYnkgY29tcG9uZW50cyB0aGF0IHdlcmUgdmlzaXRlZCBkdXJpbmcgdGhpcyByZW5kZXIuIE9ubHlcbi8vIGluY2x1ZGVzIHVucHJvY2Vzc2VkIHVwZGF0ZXMsIG5vdCB3b3JrIGluIGJhaWxlZCBvdXQgY2hpbGRyZW4uXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgPSBOb0xhbmVzOyAvLyBMYW5lcyB0aGF0IHdlcmUgdXBkYXRlZCAoaW4gYW4gaW50ZXJsZWF2ZWQgZXZlbnQpIGR1cmluZyB0aGlzIHJlbmRlci5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzID0gTm9MYW5lczsgLy8gTGFuZXMgdGhhdCB3ZXJlIHVwZGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UgKCpub3QqIGFuIGludGVybGVhdmVkIGV2ZW50KS5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzID0gTm9MYW5lczsgLy8gSWYgdGhpcyBsYW5lIHNjaGVkdWxlZCBkZWZlcnJlZCB3b3JrLCB0aGlzIGlzIHRoZSBsYW5lIG9mIHRoZSBkZWZlcnJlZCB0YXNrLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUgPSBOb0xhbmU7IC8vIEVycm9ycyB0aGF0IGFyZSB0aHJvd24gZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzID0gbnVsbDsgLy8gVGhlc2UgYXJlIGVycm9ycyB0aGF0IHdlIHJlY292ZXJlZCBmcm9tIHdpdGhvdXQgc3VyZmFjaW5nIHRoZW0gdG8gdGhlIFVJLlxuLy8gV2Ugd2lsbCBsb2cgdGhlbSBvbmNlIHRoZSB0cmVlIGNvbW1pdHMuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IG51bGw7IC8vIFRyYWNrcyB3aGVuIGFuIHVwZGF0ZSBvY2N1cnMgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlID0gZmFsc2U7IC8vIFRoYWNrcyB3aGVuIGFuIHVwZGF0ZSBvY2N1cnMgZHVyaW5nIHRoZSBjb21taXQgcGhhc2UuIEl0J3MgYSBzZXBhcmF0ZVxuLy8gdmFyaWFibGUgZnJvbSB0aGUgb25lIGZvciByZW5kZXJzIGJlY2F1c2UgdGhlIGNvbW1pdCBwaGFzZSBtYXkgcnVuXG4vLyBjb25jdXJyZW50bHkgdG8gYSByZW5kZXIgcGhhc2UuXG5cbnZhciBkaWRJbmNsdWRlQ29tbWl0UGhhc2VVcGRhdGUgPSBmYWxzZTsgLy8gVGhlIG1vc3QgcmVjZW50IHRpbWUgd2UgZWl0aGVyIGNvbW1pdHRlZCBhIGZhbGxiYWNrLCBvciB3aGVuIGEgZmFsbGJhY2sgd2FzXG4vLyBmaWxsZWQgaW4gd2l0aCB0aGUgcmVzb2x2ZWQgVUkuIFRoaXMgbGV0cyB1cyB0aHJvdHRsZSB0aGUgYXBwZWFyYW5jZSBvZiBuZXdcbi8vIGNvbnRlbnQgYXMgaXQgc3RyZWFtcyBpbiwgdG8gbWluaW1pemUgamFuay5cbi8vIFRPRE86IFRoaW5rIG9mIGEgYmV0dGVyIG5hbWUgZm9yIHRoaXMgdmFyaWFibGU/XG5cbnZhciBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lID0gMDtcbnZhciBGQUxMQkFDS19USFJPVFRMRV9NUyA9IDMwMDsgLy8gVGhlIGFic29sdXRlIHRpbWUgZm9yIHdoZW4gd2Ugc2hvdWxkIHN0YXJ0IGdpdmluZyB1cCBvbiByZW5kZXJpbmdcbi8vIG1vcmUgYW5kIHByZWZlciBDUFUgc3VzcGVuc2UgaGV1cmlzdGljcyBpbnN0ZWFkLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSA9IEluZmluaXR5OyAvLyBIb3cgbG9uZyBhIHJlbmRlciBpcyBzdXBwb3NlZCB0byB0YWtlIGJlZm9yZSB3ZSBzdGFydCBmb2xsb3dpbmcgQ1BVXG4vLyBzdXNwZW5zZSBoZXVyaXN0aWNzIGFuZCBvcHQgb3V0IG9mIHJlbmRlcmluZyBtb3JlIGNvbnRlbnQuXG5cbnZhciBSRU5ERVJfVElNRU9VVF9NUyA9IDUwMDtcbnZhciB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zID0gbnVsbDtcblxuZnVuY3Rpb24gcmVzZXRSZW5kZXJUaW1lcigpIHtcbiAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSA9IG5vdyQxKCkgKyBSRU5ERVJfVElNRU9VVF9NUztcbn1cblxuZnVuY3Rpb24gZ2V0UmVuZGVyVGFyZ2V0VGltZSgpIHtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlclRhcmdldFRpbWU7XG59XG52YXIgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBudWxsO1xudmFyIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gZmFsc2U7XG52YXIgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSBudWxsO1xudmFyIHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzID0gTm9MYW5lcztcbnZhciBwZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0cyA9IFtdO1xudmFyIHBlbmRpbmdQYXNzaXZlRWZmZWN0c1JlbWFpbmluZ0xhbmVzID0gTm9MYW5lcztcbnZhciBwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zID0gbnVsbDsgLy8gVXNlIHRoZXNlIHRvIHByZXZlbnQgYW4gaW5maW5pdGUgbG9vcCBvZiBuZXN0ZWQgdXBkYXRlc1xuXG52YXIgTkVTVEVEX1VQREFURV9MSU1JVCA9IDUwO1xudmFyIG5lc3RlZFVwZGF0ZUNvdW50ID0gMDtcbnZhciByb290V2l0aE5lc3RlZFVwZGF0ZXMgPSBudWxsO1xudmFyIGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xudmFyIGRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHMgPSBmYWxzZTtcbnZhciBORVNURURfUEFTU0lWRV9VUERBVEVfTElNSVQgPSA1MDtcbnZhciBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSAwO1xudmFyIHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMgPSBudWxsO1xudmFyIGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCA9IGZhbHNlO1xuZnVuY3Rpb24gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCkge1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290O1xufVxuZnVuY3Rpb24gZ2V0V29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMoKSB7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcztcbn1cbmZ1bmN0aW9uIGlzV29ya0xvb3BTdXNwZW5kZWRPbkRhdGEoKSB7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9PT0gU3VzcGVuZGVkT25EYXRhO1xufVxuZnVuY3Rpb24gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpIHtcblxuICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAhPT0gTm9Db250ZXh0ICYmIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlbmRlciBwaGFzZSB1cGRhdGUuIFRoZXNlIGFyZSBub3Qgb2ZmaWNpYWxseSBzdXBwb3J0ZWQuIFRoZVxuICAgIC8vIG9sZCBiZWhhdmlvciBpcyB0byBnaXZlIHRoaXMgdGhlIHNhbWUgXCJ0aHJlYWRcIiAobGFuZXMpIGFzXG4gICAgLy8gd2hhdGV2ZXIgaXMgY3VycmVudGx5IHJlbmRlcmluZy4gU28gaWYgeW91IGNhbGwgYHNldFN0YXRlYCBvbiBhIGNvbXBvbmVudFxuICAgIC8vIHRoYXQgaGFwcGVucyBsYXRlciBpbiB0aGUgc2FtZSByZW5kZXIsIGl0IHdpbGwgZmx1c2guIElkZWFsbHksIHdlIHdhbnQgdG9cbiAgICAvLyByZW1vdmUgdGhlIHNwZWNpYWwgY2FzZSBhbmQgdHJlYXQgdGhlbSBhcyBpZiB0aGV5IGNhbWUgZnJvbSBhblxuICAgIC8vIGludGVybGVhdmVkIGV2ZW50LiBSZWdhcmRsZXNzLCB0aGlzIHBhdHRlcm4gaXMgbm90IG9mZmljaWFsbHkgc3VwcG9ydGVkLlxuICAgIC8vIFRoaXMgYmVoYXZpb3IgaXMgb25seSBhIGZhbGxiYWNrLiBUaGUgZmxhZyBvbmx5IGV4aXN0cyB1bnRpbCB3ZSBjYW4gcm9sbFxuICAgIC8vIG91dCB0aGUgc2V0U3RhdGUgd2FybmluZywgc2luY2UgZXhpc3RpbmcgY29kZSBtaWdodCBhY2NpZGVudGFsbHkgcmVseSBvblxuICAgIC8vIHRoZSBjdXJyZW50IGJlaGF2aW9yLlxuICAgIHJldHVybiBwaWNrQXJiaXRyYXJ5TGFuZSh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gIH1cblxuICB2YXIgdHJhbnNpdGlvbiA9IHJlcXVlc3RDdXJyZW50VHJhbnNpdGlvbigpO1xuXG4gIGlmICh0cmFuc2l0aW9uICE9PSBudWxsKSB7XG4gICAge1xuICAgICAgaWYgKCF0cmFuc2l0aW9uLl91cGRhdGVkRmliZXJzKSB7XG4gICAgICAgIHRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgPSBuZXcgU2V0KCk7XG4gICAgICB9XG5cbiAgICAgIHRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuYWRkKGZpYmVyKTtcbiAgICB9XG5cbiAgICB2YXIgYWN0aW9uU2NvcGVMYW5lID0gcGVla0VudGFuZ2xlZEFjdGlvbkxhbmUoKTtcbiAgICByZXR1cm4gYWN0aW9uU2NvcGVMYW5lICE9PSBOb0xhbmUgPyAvLyBXZSdyZSBpbnNpZGUgYW4gYXN5bmMgYWN0aW9uIHNjb3BlLiBSZXVzZSB0aGUgc2FtZSBsYW5lLlxuICAgIGFjdGlvblNjb3BlTGFuZSA6IC8vIFdlIG1heSBvciBtYXkgbm90IGJlIGluc2lkZSBhbiBhc3luYyBhY3Rpb24gc2NvcGUuIElmIHdlIGFyZSwgdGhpc1xuICAgIC8vIGlzIHRoZSBmaXJzdCB1cGRhdGUgaW4gdGhhdCBzY29wZS4gRWl0aGVyIHdheSwgd2UgbmVlZCB0byBnZXQgYVxuICAgIC8vIGZyZXNoIHRyYW5zaXRpb24gbGFuZS5cbiAgICByZXF1ZXN0VHJhbnNpdGlvbkxhbmUoKTtcbiAgfVxuXG4gIHJldHVybiBldmVudFByaW9yaXR5VG9MYW5lKHJlc29sdmVVcGRhdGVQcmlvcml0eSgpKTtcbn1cblxuZnVuY3Rpb24gcmVxdWVzdFJldHJ5TGFuZShmaWJlcikge1xuXG4gIHJldHVybiBjbGFpbU5leHRSZXRyeUxhbmUoKTtcbn1cblxuZnVuY3Rpb24gcmVxdWVzdERlZmVycmVkTGFuZSgpIHtcbiAgaWYgKHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lID09PSBOb0xhbmUpIHtcbiAgICAvLyBJZiB0aGVyZSBhcmUgbXVsdGlwbGUgdXNlRGVmZXJyZWRWYWx1ZSBob29rcyBpbiB0aGUgc2FtZSByZW5kZXIsIHRoZVxuICAgIC8vIHRhc2tzIHRoYXQgdGhleSBzcGF3biBzaG91bGQgYWxsIGJlIGJhdGNoZWQgdG9nZXRoZXIsIHNvIHRoZXkgc2hvdWxkIGFsbFxuICAgIC8vIHJlY2VpdmUgdGhlIHNhbWUgbGFuZS5cbiAgICAvLyBDaGVjayB0aGUgcHJpb3JpdHkgb2YgdGhlIGN1cnJlbnQgcmVuZGVyIHRvIGRlY2lkZSB0aGUgcHJpb3JpdHkgb2YgdGhlXG4gICAgLy8gZGVmZXJyZWQgdGFzay5cbiAgICAvLyBPZmZzY3JlZW5MYW5lIGlzIHVzZWQgZm9yIHByZXJlbmRlcmluZywgYnV0IHdlIGFsc28gdXNlIE9mZnNjcmVlbkxhbmVcbiAgICAvLyBmb3IgaW5jcmVtZW50YWwgaHlkcmF0aW9uLiBJdCdzIGdpdmVuIHRoZSBsb3dlc3QgcHJpb3JpdHkgYmVjYXVzZSB0aGVcbiAgICAvLyBpbml0aWFsIEhUTUwgaXMgdGhlIHNhbWUgYXMgdGhlIGZpbmFsIFVJLiBCdXQgdXNlRGVmZXJyZWRWYWx1ZSBkdXJpbmdcbiAgICAvLyBoeWRyYXRpb24gaXMgYW4gZXhjZXB0aW9uIOKAlCB3ZSBuZWVkIHRvIHVwZ3JhZGUgdGhlIFVJIHRvIHRoZSBmaW5hbFxuICAgIC8vIHZhbHVlLiBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgaHlkcmF0aW5nLCB3ZSB0cmVhdCBpdCBsaWtlIGEgdHJhbnNpdGlvbi5cbiAgICB2YXIgaXNQcmVyZW5kZXJpbmcgPSBpbmNsdWRlc1NvbWVMYW5lKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzLCBPZmZzY3JlZW5MYW5lKSAmJiAhZ2V0SXNIeWRyYXRpbmcoKTtcblxuICAgIGlmIChpc1ByZXJlbmRlcmluZykge1xuICAgICAgLy8gVGhlcmUncyBvbmx5IG9uZSBPZmZzY3JlZW5MYW5lLCBzbyBpZiBpdCBjb250YWlucyBkZWZlcnJlZCB3b3JrLCB3ZVxuICAgICAgLy8gc2hvdWxkIGp1c3QgcmVzY2hlZHVsZSB1c2luZyB0aGUgc2FtZSBsYW5lLlxuICAgICAgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUgPSBPZmZzY3JlZW5MYW5lO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBFdmVyeXRoaW5nIGVsc2UgaXMgc3Bhd25lZCBhcyBhIHRyYW5zaXRpb24uXG4gICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSA9IGNsYWltTmV4dFRyYW5zaXRpb25MYW5lKCk7XG4gICAgfVxuICB9IC8vIE1hcmsgdGhlIHBhcmVudCBTdXNwZW5zZSBib3VuZGFyeSBzbyBpdCBrbm93cyB0byBzcGF3biB0aGUgZGVmZXJyZWQgbGFuZS5cblxuXG4gIHZhciBzdXNwZW5zZUhhbmRsZXIgPSBnZXRTdXNwZW5zZUhhbmRsZXIoKTtcblxuICBpZiAoc3VzcGVuc2VIYW5kbGVyICE9PSBudWxsKSB7XG4gICAgLy8gVE9ETzogQXMgYW4gb3B0aW1pemF0aW9uLCB3ZSBzaG91bGRuJ3QgZW50YW5nbGUgdGhlIGxhbmVzIGF0IHRoZSByb290OyB3ZVxuICAgIC8vIGNhbiBlbnRhbmdsZSB0aGVtIHVzaW5nIHRoZSBiYXNlTGFuZXMgb2YgdGhlIFN1c3BlbnNlIGJvdW5kYXJ5IGluc3RlYWQuXG4gICAgLy8gV2Ugb25seSBuZWVkIHRvIGRvIHNvbWV0aGluZyBzcGVjaWFsIGlmIHRoZXJlJ3Mgbm8gU3VzcGVuc2UgYm91bmRhcnkuXG4gICAgc3VzcGVuc2VIYW5kbGVyLmZsYWdzIHw9IERpZERlZmVyO1xuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lO1xufVxuZnVuY3Rpb24gcGVla0RlZmVycmVkTGFuZSgpIHtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lO1xufVxuZnVuY3Rpb24gc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBsYW5lKSB7XG4gIHtcbiAgICBpZiAoaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0KSB7XG4gICAgICBlcnJvcigndXNlSW5zZXJ0aW9uRWZmZWN0IG11c3Qgbm90IHNjaGVkdWxlIHVwZGF0ZXMuJyk7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIGlmIChpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAgIGRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHMgPSB0cnVlO1xuICAgIH1cbiAgfSAvLyBDaGVjayBpZiB0aGUgd29yayBsb29wIGlzIGN1cnJlbnRseSBzdXNwZW5kZWQgYW5kIHdhaXRpbmcgZm9yIGRhdGEgdG9cbiAgLy8gZmluaXNoIGxvYWRpbmcuXG5cblxuICBpZiAoIC8vIFN1c3BlbmRlZCByZW5kZXIgcGhhc2VcbiAgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ICYmIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID09PSBTdXNwZW5kZWRPbkRhdGEgfHwgLy8gU3VzcGVuZGVkIGNvbW1pdCBwaGFzZVxuICByb290LmNhbmNlbFBlbmRpbmdDb21taXQgIT09IG51bGwpIHtcbiAgICAvLyBUaGUgaW5jb21pbmcgdXBkYXRlIG1pZ2h0IHVuYmxvY2sgdGhlIGN1cnJlbnQgcmVuZGVyLiBJbnRlcnJ1cHQgdGhlXG4gICAgLy8gY3VycmVudCBhdHRlbXB0IGFuZCByZXN0YXJ0IGZyb20gdGhlIHRvcC5cbiAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBOb0xhbmVzKTtcbiAgICBtYXJrUm9vdFN1c3BlbmRlZChyb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUpO1xuICB9IC8vIE1hcmsgdGhhdCB0aGUgcm9vdCBoYXMgYSBwZW5kaW5nIHVwZGF0ZS5cblxuXG4gIG1hcmtSb290VXBkYXRlZChyb290LCBsYW5lKTtcblxuICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAhPT0gTm9MYW5lcyAmJiByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QpIHtcbiAgICAvLyBUaGlzIHVwZGF0ZSB3YXMgZGlzcGF0Y2hlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS4gVGhpcyBpcyBhIG1pc3Rha2VcbiAgICAvLyBpZiB0aGUgdXBkYXRlIG9yaWdpbmF0ZXMgZnJvbSB1c2VyIHNwYWNlICh3aXRoIHRoZSBleGNlcHRpb24gb2YgbG9jYWxcbiAgICAvLyBob29rIHVwZGF0ZXMsIHdoaWNoIGFyZSBoYW5kbGVkIGRpZmZlcmVudGx5IGFuZCBkb24ndCByZWFjaCB0aGlzXG4gICAgLy8gZnVuY3Rpb24pLCBidXQgdGhlcmUgYXJlIHNvbWUgaW50ZXJuYWwgUmVhY3QgZmVhdHVyZXMgdGhhdCB1c2UgdGhpcyBhc1xuICAgIC8vIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCwgbGlrZSBzZWxlY3RpdmUgaHlkcmF0aW9uLlxuICAgIHdhcm5BYm91dFJlbmRlclBoYXNlVXBkYXRlc0luREVWKGZpYmVyKTsgLy8gVHJhY2sgbGFuZXMgdGhhdCB3ZXJlIHVwZGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2VcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIGEgbm9ybWFsIHVwZGF0ZSwgc2NoZWR1bGVkIGZyb20gb3V0c2lkZSB0aGUgcmVuZGVyIHBoYXNlLiBGb3JcbiAgICAvLyBleGFtcGxlLCBkdXJpbmcgYW4gaW5wdXQgZXZlbnQuXG4gICAge1xuICAgICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICAgIGFkZEZpYmVyVG9MYW5lc01hcChyb290LCBmaWJlciwgbGFuZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2FybklmVXBkYXRlc05vdFdyYXBwZWRXaXRoQWN0REVWKGZpYmVyKTtcblxuICAgIGlmIChyb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QpIHtcbiAgICAgIC8vIFJlY2VpdmVkIGFuIHVwZGF0ZSB0byBhIHRyZWUgdGhhdCdzIGluIHRoZSBtaWRkbGUgb2YgcmVuZGVyaW5nLiBNYXJrXG4gICAgICAvLyB0aGF0IHRoZXJlIHdhcyBhbiBpbnRlcmxlYXZlZCB1cGRhdGUgd29yayBvbiB0aGlzIHJvb3QuXG4gICAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSA9PT0gTm9Db250ZXh0KSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzID0gbWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcywgbGFuZSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkV2l0aERlbGF5KSB7XG4gICAgICAgIC8vIFRoZSByb290IGFscmVhZHkgc3VzcGVuZGVkIHdpdGggYSBkZWxheSwgd2hpY2ggbWVhbnMgdGhpcyByZW5kZXJcbiAgICAgICAgLy8gZGVmaW5pdGVseSB3b24ndCBmaW5pc2guIFNpbmNlIHdlIGhhdmUgYSBuZXcgdXBkYXRlLCBsZXQncyBtYXJrIGl0IGFzXG4gICAgICAgIC8vIHN1c3BlbmRlZCBub3csIHJpZ2h0IGJlZm9yZSBtYXJraW5nIHRoZSBpbmNvbWluZyB1cGRhdGUuIFRoaXMgaGFzIHRoZVxuICAgICAgICAvLyBlZmZlY3Qgb2YgaW50ZXJydXB0aW5nIHRoZSBjdXJyZW50IHJlbmRlciBhbmQgc3dpdGNoaW5nIHRvIHRoZSB1cGRhdGUuXG4gICAgICAgIC8vIFRPRE86IE1ha2Ugc3VyZSB0aGlzIGRvZXNuJ3Qgb3ZlcnJpZGUgcGluZ3MgdGhhdCBoYXBwZW4gd2hpbGUgd2UndmVcbiAgICAgICAgLy8gYWxyZWFkeSBzdGFydGVkIHJlbmRlcmluZy5cbiAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQocm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG5cbiAgICBpZiAobGFuZSA9PT0gU3luY0xhbmUgJiYgZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0ICYmICFkaXNhYmxlTGVnYWN5TW9kZSAmJiAoZmliZXIubW9kZSAmIENvbmN1cnJlbnRNb2RlKSA9PT0gTm9Nb2RlKSB7XG4gICAgICBpZiAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuaXNCYXRjaGluZ0xlZ2FjeSkgOyBlbHNlIHtcbiAgICAgICAgLy8gRmx1c2ggdGhlIHN5bmNocm9ub3VzIHdvcmsgbm93LCB1bmxlc3Mgd2UncmUgYWxyZWFkeSB3b3JraW5nIG9yIGluc2lkZVxuICAgICAgICAvLyBhIGJhdGNoLiBUaGlzIGlzIGludGVudGlvbmFsbHkgaW5zaWRlIHNjaGVkdWxlVXBkYXRlT25GaWJlciBpbnN0ZWFkIG9mXG4gICAgICAgIC8vIHNjaGVkdWxlQ2FsbGJhY2tGb3JGaWJlciB0byBwcmVzZXJ2ZSB0aGUgYWJpbGl0eSB0byBzY2hlZHVsZSBhIGNhbGxiYWNrXG4gICAgICAgIC8vIHdpdGhvdXQgaW1tZWRpYXRlbHkgZmx1c2hpbmcgaXQuIFdlIG9ubHkgZG8gdGhpcyBmb3IgdXNlci1pbml0aWF0ZWRcbiAgICAgICAgLy8gdXBkYXRlcywgdG8gcHJlc2VydmUgaGlzdG9yaWNhbCBiZWhhdmlvciBvZiBsZWdhY3kgbW9kZS5cbiAgICAgICAgcmVzZXRSZW5kZXJUaW1lcigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gc2NoZWR1bGVJbml0aWFsSHlkcmF0aW9uT25Sb290KHJvb3QsIGxhbmUpIHtcbiAgLy8gVGhpcyBpcyBhIHNwZWNpYWwgZm9yayBvZiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIgdGhhdCBpcyBvbmx5IHVzZWQgdG9cbiAgLy8gc2NoZWR1bGUgdGhlIGluaXRpYWwgaHlkcmF0aW9uIG9mIGEgcm9vdCB0aGF0IGhhcyBqdXN0IGJlZW4gY3JlYXRlZC4gTW9zdFxuICAvLyBvZiB0aGUgc3R1ZmYgaW4gc2NoZWR1bGVVcGRhdGVPbkZpYmVyIGNhbiBiZSBza2lwcGVkLlxuICAvL1xuICAvLyBUaGUgbWFpbiByZWFzb24gZm9yIHRoaXMgc2VwYXJhdGUgcGF0aCwgdGhvdWdoLCBpcyB0byBkaXN0aW5ndWlzaCB0aGVcbiAgLy8gaW5pdGlhbCBjaGlsZHJlbiBmcm9tIHN1YnNlcXVlbnQgdXBkYXRlcy4gSW4gZnVsbHkgY2xpZW50LXJlbmRlcmVkIHJvb3RzXG4gIC8vIChjcmVhdGVSb290IGluc3RlYWQgb2YgaHlkcmF0ZVJvb3QpLCBhbGwgdG9wLWxldmVsIHJlbmRlcnMgYXJlIG1vZGVsZWQgYXNcbiAgLy8gdXBkYXRlcywgYnV0IGh5ZHJhdGlvbiByb290cyBhcmUgc3BlY2lhbCBiZWNhdXNlIHRoZSBpbml0aWFsIHJlbmRlciBtdXN0XG4gIC8vIG1hdGNoIHdoYXQgd2FzIHJlbmRlcmVkIG9uIHRoZSBzZXJ2ZXIuXG4gIHZhciBjdXJyZW50ID0gcm9vdC5jdXJyZW50O1xuICBjdXJyZW50LmxhbmVzID0gbGFuZTtcbiAgbWFya1Jvb3RVcGRhdGVkKHJvb3QsIGxhbmUpO1xuICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG59XG5mdW5jdGlvbiBpc1Vuc2FmZUNsYXNzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpIHtcbiAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIHJlbmRlciBwaGFzZSB1cGRhdGUuIE9ubHkgY2FsbGVkIGJ5IGNsYXNzIGNvbXBvbmVudHMsXG4gIC8vIHdoaWNoIHNwZWNpYWwgKGRlcHJlY2F0ZWQpIGJlaGF2aW9yIGZvciBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmUgcHJvcHMuXG4gIHJldHVybiAoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpICE9PSBOb0NvbnRleHQ7XG59IC8vIFRoaXMgaXMgdGhlIGVudHJ5IHBvaW50IGZvciBldmVyeSBjb25jdXJyZW50IHRhc2ssIGkuZS4gYW55dGhpbmcgdGhhdFxuLy8gZ29lcyB0aHJvdWdoIFNjaGVkdWxlci5cblxuZnVuY3Rpb24gcGVyZm9ybUNvbmN1cnJlbnRXb3JrT25Sb290KHJvb3QsIGRpZFRpbWVvdXQpIHtcbiAge1xuICAgIHJlc2V0TmVzdGVkVXBkYXRlRmxhZygpO1xuICB9XG5cbiAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5vdCBhbHJlYWR5IGJlIHdvcmtpbmcuJyk7XG4gIH0gLy8gRmx1c2ggYW55IHBlbmRpbmcgcGFzc2l2ZSBlZmZlY3RzIGJlZm9yZSBkZWNpZGluZyB3aGljaCBsYW5lcyB0byB3b3JrIG9uLFxuICAvLyBpbiBjYXNlIHRoZXkgc2NoZWR1bGUgYWRkaXRpb25hbCB3b3JrLlxuXG5cbiAgdmFyIG9yaWdpbmFsQ2FsbGJhY2tOb2RlID0gcm9vdC5jYWxsYmFja05vZGU7XG4gIHZhciBkaWRGbHVzaFBhc3NpdmVFZmZlY3RzID0gZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuXG4gIGlmIChkaWRGbHVzaFBhc3NpdmVFZmZlY3RzKSB7XG4gICAgLy8gU29tZXRoaW5nIGluIHRoZSBwYXNzaXZlIGVmZmVjdCBwaGFzZSBtYXkgaGF2ZSBjYW5jZWxlZCB0aGUgY3VycmVudCB0YXNrLlxuICAgIC8vIENoZWNrIGlmIHRoZSB0YXNrIG5vZGUgZm9yIHRoaXMgcm9vdCB3YXMgY2hhbmdlZC5cbiAgICBpZiAocm9vdC5jYWxsYmFja05vZGUgIT09IG9yaWdpbmFsQ2FsbGJhY2tOb2RlKSB7XG4gICAgICAvLyBUaGUgY3VycmVudCB0YXNrIHdhcyBjYW5jZWxlZC4gRXhpdC4gV2UgZG9uJ3QgbmVlZCB0byBjYWxsXG4gICAgICAvLyBgZW5zdXJlUm9vdElzU2NoZWR1bGVkYCBiZWNhdXNlIHRoZSBjaGVjayBhYm92ZSBpbXBsaWVzIGVpdGhlciB0aGF0XG4gICAgICAvLyB0aGVyZSdzIGEgbmV3IHRhc2ssIG9yIHRoYXQgdGhlcmUncyBubyByZW1haW5pbmcgd29yayBvbiB0aGlzIHJvb3QuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0gLy8gRGV0ZXJtaW5lIHRoZSBuZXh0IGxhbmVzIHRvIHdvcmsgb24sIHVzaW5nIHRoZSBmaWVsZHMgc3RvcmVkXG4gIC8vIG9uIHRoZSByb290LlxuICAvLyBUT0RPOiBUaGlzIHdhcyBhbHJlYWR5IGNvbXB1dGVkIGluIHRoZSBjYWxsZXIuIFBhc3MgaXQgYXMgYW4gYXJndW1lbnQuXG5cblxuICB2YXIgbGFuZXMgPSBnZXROZXh0TGFuZXMocm9vdCwgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ID8gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgOiBOb0xhbmVzKTtcblxuICBpZiAobGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAvLyBEZWZlbnNpdmUgY29kaW5nLiBUaGlzIGlzIG5ldmVyIGV4cGVjdGVkIHRvIGhhcHBlbi5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBXZSBkaXNhYmxlIHRpbWUtc2xpY2luZyBpbiBzb21lIGNhc2VzOiBpZiB0aGUgd29yayBoYXMgYmVlbiBDUFUtYm91bmRcbiAgLy8gZm9yIHRvbyBsb25nIChcImV4cGlyZWRcIiB3b3JrLCB0byBwcmV2ZW50IHN0YXJ2YXRpb24pLCBvciB3ZSdyZSBpblxuICAvLyBzeW5jLXVwZGF0ZXMtYnktZGVmYXVsdCBtb2RlLlxuICAvLyBUT0RPOiBXZSBvbmx5IGNoZWNrIGBkaWRUaW1lb3V0YCBkZWZlbnNpdmVseSwgdG8gYWNjb3VudCBmb3IgYSBTY2hlZHVsZXJcbiAgLy8gYnVnIHdlJ3JlIHN0aWxsIGludmVzdGlnYXRpbmcuIE9uY2UgdGhlIGJ1ZyBpbiBTY2hlZHVsZXIgaXMgZml4ZWQsXG4gIC8vIHdlIGNhbiByZW1vdmUgdGhpcywgc2luY2Ugd2UgdHJhY2sgZXhwaXJhdGlvbiBvdXJzZWx2ZXMuXG5cblxuICB2YXIgc2hvdWxkVGltZVNsaWNlID0gIWluY2x1ZGVzQmxvY2tpbmdMYW5lKHJvb3QsIGxhbmVzKSAmJiAhaW5jbHVkZXNFeHBpcmVkTGFuZShyb290LCBsYW5lcykgJiYgKCFkaWRUaW1lb3V0KTtcbiAgdmFyIGV4aXRTdGF0dXMgPSBzaG91bGRUaW1lU2xpY2UgPyByZW5kZXJSb290Q29uY3VycmVudChyb290LCBsYW5lcykgOiByZW5kZXJSb290U3luYyhyb290LCBsYW5lcyk7XG5cbiAgaWYgKGV4aXRTdGF0dXMgIT09IFJvb3RJblByb2dyZXNzKSB7XG4gICAgdmFyIHJlbmRlcldhc0NvbmN1cnJlbnQgPSBzaG91bGRUaW1lU2xpY2U7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdERpZE5vdENvbXBsZXRlKSB7XG4gICAgICAgIC8vIFRoZSByZW5kZXIgdW53b3VuZCB3aXRob3V0IGNvbXBsZXRpbmcgdGhlIHRyZWUuIFRoaXMgaGFwcGVucyBpbiBzcGVjaWFsXG4gICAgICAgIC8vIGNhc2VzIHdoZXJlIG5lZWQgdG8gZXhpdCB0aGUgY3VycmVudCByZW5kZXIgd2l0aG91dCBwcm9kdWNpbmcgYVxuICAgICAgICAvLyBjb25zaXN0ZW50IHRyZWUgb3IgY29tbWl0dGluZy5cbiAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQocm9vdCwgbGFuZXMsIE5vTGFuZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgcmVuZGVyIGNvbXBsZXRlZC5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyByZW5kZXIgbWF5IGhhdmUgeWllbGRlZCB0byBhIGNvbmN1cnJlbnQgZXZlbnQsIGFuZCBpZiBzbyxcbiAgICAgICAgLy8gY29uZmlybSB0aGF0IGFueSBuZXdseSByZW5kZXJlZCBzdG9yZXMgYXJlIGNvbnNpc3RlbnQuXG4gICAgICAgIC8vIFRPRE86IEl0J3MgcG9zc2libGUgdGhhdCBldmVuIGEgY29uY3VycmVudCByZW5kZXIgbWF5IG5ldmVyIGhhdmUgeWllbGRlZFxuICAgICAgICAvLyB0byB0aGUgbWFpbiB0aHJlYWQsIGlmIGl0IHdhcyBmYXN0IGVub3VnaCwgb3IgaWYgaXQgZXhwaXJlZC4gV2UgY291bGRcbiAgICAgICAgLy8gc2tpcCB0aGUgY29uc2lzdGVuY3kgY2hlY2sgaW4gdGhhdCBjYXNlLCB0b28uXG4gICAgICAgIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmN1cnJlbnQuYWx0ZXJuYXRlO1xuXG4gICAgICAgIGlmIChyZW5kZXJXYXNDb25jdXJyZW50ICYmICFpc1JlbmRlckNvbnNpc3RlbnRXaXRoRXh0ZXJuYWxTdG9yZXMoZmluaXNoZWRXb3JrKSkge1xuICAgICAgICAgIC8vIEEgc3RvcmUgd2FzIG11dGF0ZWQgaW4gYW4gaW50ZXJsZWF2ZWQgZXZlbnQuIFJlbmRlciBhZ2FpbixcbiAgICAgICAgICAvLyBzeW5jaHJvbm91c2x5LCB0byBibG9jayBmdXJ0aGVyIG11dGF0aW9ucy5cbiAgICAgICAgICBleGl0U3RhdHVzID0gcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMpOyAvLyBXZSBhc3N1bWUgdGhlIHRyZWUgaXMgbm93IGNvbnNpc3RlbnQgYmVjYXVzZSB3ZSBkaWRuJ3QgeWllbGQgdG8gYW55XG4gICAgICAgICAgLy8gY29uY3VycmVudCBldmVudHMuXG5cbiAgICAgICAgICByZW5kZXJXYXNDb25jdXJyZW50ID0gZmFsc2U7IC8vIE5lZWQgdG8gY2hlY2sgdGhlIGV4aXQgc3RhdHVzIGFnYWluLlxuXG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gQ2hlY2sgaWYgc29tZXRoaW5nIHRocmV3XG5cblxuICAgICAgICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdEVycm9yZWQpIHtcbiAgICAgICAgICB2YXIgbGFuZXNUaGF0SnVzdEVycm9yZWQgPSBsYW5lcztcbiAgICAgICAgICB2YXIgZXJyb3JSZXRyeUxhbmVzID0gZ2V0TGFuZXNUb1JldHJ5U3luY2hyb25vdXNseU9uRXJyb3Iocm9vdCwgbGFuZXNUaGF0SnVzdEVycm9yZWQpO1xuXG4gICAgICAgICAgaWYgKGVycm9yUmV0cnlMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgICAgICAgbGFuZXMgPSBlcnJvclJldHJ5TGFuZXM7XG4gICAgICAgICAgICBleGl0U3RhdHVzID0gcmVjb3ZlckZyb21Db25jdXJyZW50RXJyb3Iocm9vdCwgbGFuZXNUaGF0SnVzdEVycm9yZWQsIGVycm9yUmV0cnlMYW5lcyk7XG4gICAgICAgICAgICByZW5kZXJXYXNDb25jdXJyZW50ID0gZmFsc2U7IC8vIE5lZWQgdG8gY2hlY2sgdGhlIGV4aXQgc3RhdHVzIGFnYWluLlxuXG4gICAgICAgICAgICBpZiAoZXhpdFN0YXR1cyAhPT0gUm9vdEVycm9yZWQpIHtcbiAgICAgICAgICAgICAgLy8gVGhlIHJvb3QgZGlkIG5vdCBlcnJvciB0aGlzIHRpbWUuIFJlc3RhcnQgdGhlIGV4aXQgYWxnb3JpdGhtXG4gICAgICAgICAgICAgIC8vIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgICAgICAgICAgLy8gVE9ETzogUmVmYWN0b3IgdGhlIGV4aXQgYWxnb3JpdGhtIHRvIGJlIGxlc3MgY29uZnVzaW5nLiBNYXliZVxuICAgICAgICAgICAgICAvLyBtb3JlIGJyYW5jaGVzICsgcmVjdXJzaW9uIGluc3RlYWQgb2YgYSBsb29wLiBJIHRoaW5rIHRoZSBvbmx5XG4gICAgICAgICAgICAgIC8vIHRoaW5nIHRoYXQgY2F1c2VzIGl0IHRvIGJlIGEgbG9vcCBpcyB0aGUgUm9vdERpZE5vdENvbXBsZXRlXG4gICAgICAgICAgICAgIC8vIGNoZWNrLiBJZiB0aGF0J3MgdHJ1ZSwgdGhlbiB3ZSBkb24ndCBuZWVkIGEgbG9vcC9yZWN1cnNpb25cbiAgICAgICAgICAgICAgLy8gYXQgYWxsLlxuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdEZhdGFsRXJyb3JlZCkge1xuICAgICAgICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIE5vTGFuZXMpO1xuICAgICAgICAgIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIGxhbmVzLCBOb0xhbmUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IC8vIFdlIG5vdyBoYXZlIGEgY29uc2lzdGVudCB0cmVlLiBUaGUgbmV4dCBzdGVwIGlzIGVpdGhlciB0byBjb21taXQgaXQsXG4gICAgICAgIC8vIG9yLCBpZiBzb21ldGhpbmcgc3VzcGVuZGVkLCB3YWl0IHRvIGNvbW1pdCBpdCBhZnRlciBhIHRpbWVvdXQuXG5cblxuICAgICAgICByb290LmZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yaztcbiAgICAgICAgcm9vdC5maW5pc2hlZExhbmVzID0gbGFuZXM7XG4gICAgICAgIGZpbmlzaENvbmN1cnJlbnRSZW5kZXIocm9vdCwgZXhpdFN0YXR1cywgZmluaXNoZWRXb3JrLCBsYW5lcyk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH0gd2hpbGUgKHRydWUpO1xuICB9XG5cbiAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICByZXR1cm4gZ2V0Q29udGludWF0aW9uRm9yUm9vdChyb290LCBvcmlnaW5hbENhbGxiYWNrTm9kZSk7XG59XG5cbmZ1bmN0aW9uIHJlY292ZXJGcm9tQ29uY3VycmVudEVycm9yKHJvb3QsIG9yaWdpbmFsbHlBdHRlbXB0ZWRMYW5lcywgZXJyb3JSZXRyeUxhbmVzKSB7XG4gIC8vIElmIGFuIGVycm9yIG9jY3VycmVkIGR1cmluZyBoeWRyYXRpb24sIGRpc2NhcmQgc2VydmVyIHJlc3BvbnNlIGFuZCBmYWxsXG4gIC8vIGJhY2sgdG8gY2xpZW50IHNpZGUgcmVuZGVyLlxuICAvLyBCZWZvcmUgcmVuZGVyaW5nIGFnYWluLCBzYXZlIHRoZSBlcnJvcnMgZnJvbSB0aGUgcHJldmlvdXMgYXR0ZW1wdC5cbiAgdmFyIGVycm9yc0Zyb21GaXJzdEF0dGVtcHQgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzO1xuICB2YXIgd2FzUm9vdERlaHlkcmF0ZWQgPSBzdXBwb3J0c0h5ZHJhdGlvbiAmJiBpc1Jvb3REZWh5ZHJhdGVkKHJvb3QpO1xuXG4gIGlmICh3YXNSb290RGVoeWRyYXRlZCkge1xuICAgIC8vIFRoZSBzaGVsbCBmYWlsZWQgdG8gaHlkcmF0ZS4gU2V0IGEgZmxhZyB0byBmb3JjZSBhIGNsaWVudCByZW5kZXJpbmdcbiAgICAvLyBkdXJpbmcgdGhlIG5leHQgYXR0ZW1wdC4gVG8gZG8gdGhpcywgd2UgY2FsbCBwcmVwYXJlRnJlc2hTdGFjayBub3dcbiAgICAvLyB0byBjcmVhdGUgdGhlIHJvb3Qgd29yay1pbi1wcm9ncmVzcyBmaWJlci4gVGhpcyBpcyBhIGJpdCB3ZWlyZCBpbiB0ZXJtc1xuICAgIC8vIG9mIGZhY3RvcmluZywgYmVjYXVzZSBpdCByZWxpZXMgb24gcmVuZGVyUm9vdFN5bmMgbm90IGNhbGxpbmdcbiAgICAvLyBwcmVwYXJlRnJlc2hTdGFjayBhZ2FpbiBpbiB0aGUgY2FsbCBiZWxvdywgd2hpY2ggaGFwcGVucyBiZWNhdXNlIHRoZVxuICAgIC8vIHJvb3QgYW5kIGxhbmVzIGhhdmVuJ3QgY2hhbmdlZC5cbiAgICAvL1xuICAgIC8vIFRPRE86IEkgdGhpbmsgd2hhdCB3ZSBzaG91bGQgZG8gaXMgc2V0IEZvcmNlQ2xpZW50UmVuZGVyIGluc2lkZVxuICAgIC8vIHRocm93RXhjZXB0aW9uLCBsaWtlIHdlIGRvIGZvciBuZXN0ZWQgU3VzcGVuc2UgYm91bmRhcmllcy4gVGhlIHJlYXNvblxuICAgIC8vIGl0J3MgaGVyZSBpbnN0ZWFkIGlzIHNvIHdlIGNhbiBzd2l0Y2ggdG8gdGhlIHN5bmNocm9ub3VzIHdvcmsgbG9vcCwgdG9vLlxuICAgIC8vIFNvbWV0aGluZyB0byBjb25zaWRlciBmb3IgYSBmdXR1cmUgcmVmYWN0b3IuXG4gICAgdmFyIHJvb3RXb3JrSW5Qcm9ncmVzcyA9IHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIGVycm9yUmV0cnlMYW5lcyk7XG4gICAgcm9vdFdvcmtJblByb2dyZXNzLmZsYWdzIHw9IEZvcmNlQ2xpZW50UmVuZGVyO1xuICB9XG5cbiAgdmFyIGV4aXRTdGF0dXMgPSByZW5kZXJSb290U3luYyhyb290LCBlcnJvclJldHJ5TGFuZXMpO1xuXG4gIGlmIChleGl0U3RhdHVzICE9PSBSb290RXJyb3JlZCkge1xuICAgIC8vIFN1Y2Nlc3NmdWxseSBmaW5pc2hlZCByZW5kZXJpbmcgb24gcmV0cnlcbiAgICBpZiAod29ya0luUHJvZ3Jlc3NSb290RGlkQXR0YWNoUGluZ0xpc3RlbmVyICYmICF3YXNSb290RGVoeWRyYXRlZCkge1xuICAgICAgLy8gRHVyaW5nIHRoZSBzeW5jaHJvbm91cyByZW5kZXIsIHdlIGF0dGFjaGVkIGFkZGl0aW9uYWwgcGluZyBsaXN0ZW5lcnMuXG4gICAgICAvLyBUaGlzIGlzIGhpZ2hseSBzdWdnZXN0aXZlIG9mIGFuIHVuY2FjaGVkIHByb21pc2UgKHRob3VnaCBpdCdzIG5vdCB0aGVcbiAgICAgIC8vIG9ubHkgcmVhc29uIHRoaXMgd291bGQgaGFwcGVuKS4gSWYgaXQgd2FzIGFuIHVuY2FjaGVkIHByb21pc2UsIHRoZW5cbiAgICAgIC8vIGl0IG1heSBoYXZlIG1hc2tlZCBhIGRvd25zdHJlYW0gZXJyb3IgZnJvbSBvY3VycmluZyB3aXRob3V0IGFjdHVhbGx5XG4gICAgICAvLyBmaXhpbmcgaXQuIEV4YW1wbGU6XG4gICAgICAvL1xuICAgICAgLy8gICAgdXNlKFByb21pc2UucmVzb2x2ZSgndW5jYWNoZWQnKSlcbiAgICAgIC8vICAgIHRocm93IG5ldyBFcnJvcignT29wcyEnKVxuICAgICAgLy9cbiAgICAgIC8vIFdoZW4gdGhpcyBoYXBwZW5zLCB0aGVyZSdzIGEgY29uZmxpY3QgYmV0d2VlbiBibG9ja2luZyBwb3RlbnRpYWxcbiAgICAgIC8vIGNvbmN1cnJlbnQgZGF0YSByYWNlcyBhbmQgdW53cmFwcGluZyB1bmNhY2hlZCBwcm9taXNlIHZhbHVlcy4gV2VcbiAgICAgIC8vIGhhdmUgdG8gY2hvb3NlIG9uZSBvciB0aGUgb3RoZXIuIEJlY2F1c2UgdGhlIGRhdGEgcmFjZSByZWNvdmVyeSBpc1xuICAgICAgLy8gYSBsYXN0IGRpdGNoIGVmZm9ydCwgd2UnbGwgZGlzYWJsZSBpdC5cbiAgICAgIHJvb3QuZXJyb3JSZWNvdmVyeURpc2FibGVkTGFuZXMgPSBtZXJnZUxhbmVzKHJvb3QuZXJyb3JSZWNvdmVyeURpc2FibGVkTGFuZXMsIG9yaWdpbmFsbHlBdHRlbXB0ZWRMYW5lcyk7IC8vIE1hcmsgdGhlIGN1cnJlbnQgcmVuZGVyIGFzIHN1c3BlbmRlZCBhbmQgZm9yY2UgaXQgdG8gcmVzdGFydC4gT25jZVxuICAgICAgLy8gdGhlc2UgbGFuZXMgZmluaXNoIHN1Y2Nlc3NmdWxseSwgd2UnbGwgcmUtZW5hYmxlIHRoZSBlcnJvciByZWNvdmVyeVxuICAgICAgLy8gbWVjaGFuaXNtIGZvciBzdWJzZXF1ZW50IHVwZGF0ZXMuXG5cbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzIHw9IG9yaWdpbmFsbHlBdHRlbXB0ZWRMYW5lcztcbiAgICAgIHJldHVybiBSb290U3VzcGVuZGVkV2l0aERlbGF5O1xuICAgIH0gLy8gVGhlIGVycm9ycyBmcm9tIHRoZSBmYWlsZWQgZmlyc3QgYXR0ZW1wdCBoYXZlIGJlZW4gcmVjb3ZlcmVkLiBBZGRcbiAgICAvLyB0aGVtIHRvIHRoZSBjb2xsZWN0aW9uIG9mIHJlY292ZXJhYmxlIGVycm9ycy4gV2UnbGwgbG9nIHRoZW0gaW4gdGhlXG4gICAgLy8gY29tbWl0IHBoYXNlLlxuXG5cbiAgICB2YXIgZXJyb3JzRnJvbVNlY29uZEF0dGVtcHQgPSB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycztcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IGVycm9yc0Zyb21GaXJzdEF0dGVtcHQ7IC8vIFRoZSBlcnJvcnMgZnJvbSB0aGUgc2Vjb25kIGF0dGVtcHQgc2hvdWxkIGJlIHF1ZXVlZCBhZnRlciB0aGUgZXJyb3JzXG4gICAgLy8gZnJvbSB0aGUgZmlyc3QgYXR0ZW1wdCwgdG8gcHJlc2VydmUgdGhlIGNhdXNhbCBzZXF1ZW5jZS5cblxuICAgIGlmIChlcnJvcnNGcm9tU2Vjb25kQXR0ZW1wdCAhPT0gbnVsbCkge1xuICAgICAgcXVldWVSZWNvdmVyYWJsZUVycm9ycyhlcnJvcnNGcm9tU2Vjb25kQXR0ZW1wdCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4aXRTdGF0dXM7XG59XG5cbmZ1bmN0aW9uIHF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMoZXJyb3JzKSB7XG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9PT0gbnVsbCkge1xuICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID0gZXJyb3JzO1xuICB9IGVsc2Uge1xuICAgIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycy5wdXNoLmFwcGx5KHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLCBlcnJvcnMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaENvbmN1cnJlbnRSZW5kZXIocm9vdCwgZXhpdFN0YXR1cywgZmluaXNoZWRXb3JrLCBsYW5lcykge1xuICAvLyBUT0RPOiBUaGUgZmFjdCB0aGF0IG1vc3Qgb2YgdGhlc2UgYnJhbmNoZXMgYXJlIGlkZW50aWNhbCBzdWdnZXN0cyB0aGF0IHNvbWVcbiAgLy8gb2YgdGhlIGV4aXQgc3RhdHVzZXMgYXJlIG5vdCBiZXN0IG1vZGVsZWQgYXMgZXhpdCBzdGF0dXNlcyBhbmQgc2hvdWxkIGJlXG4gIC8vIHRyYWNrZWQgb3J0aG9nb25hbGx5LlxuICBzd2l0Y2ggKGV4aXRTdGF0dXMpIHtcbiAgICBjYXNlIFJvb3RJblByb2dyZXNzOlxuICAgIGNhc2UgUm9vdEZhdGFsRXJyb3JlZDpcbiAgICAgIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSb290IGRpZCBub3QgY29tcGxldGUuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG5cbiAgICBjYXNlIFJvb3RTdXNwZW5kZWRXaXRoRGVsYXk6XG4gICAgICB7XG4gICAgICAgIGlmIChpbmNsdWRlc09ubHlUcmFuc2l0aW9ucyhsYW5lcykpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGEgdHJhbnNpdGlvbiwgc28gd2Ugc2hvdWxkIGV4aXQgd2l0aG91dCBjb21taXR0aW5nIGFcbiAgICAgICAgICAvLyBwbGFjZWhvbGRlciBhbmQgd2l0aG91dCBzY2hlZHVsaW5nIGEgdGltZW91dC4gRGVsYXkgaW5kZWZpbml0ZWx5XG4gICAgICAgICAgLy8gdW50aWwgd2UgcmVjZWl2ZSBtb3JlIGRhdGEuXG4gICAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQocm9vdCwgbGFuZXMsIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gQ29tbWl0IHRoZSBwbGFjZWhvbGRlci5cblxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBSb290RXJyb3JlZDpcbiAgICAgIHtcbiAgICAgICAgLy8gVGhpcyByZW5kZXIgZXJyb3JlZC4gSWdub3JlIGFueSByZWNvdmVyYWJsZSBlcnJvcnMgYmVjYXVzZSB3ZSB3ZXJlbid0IGFjdHVhbGx5XG4gICAgICAgIC8vIGFibGUgdG8gcmVjb3Zlci4gSW5zdGVhZCwgd2hhdGV2ZXIgdGhlIGZpbmFsIGVycm9ycyB3ZXJlIGlzIHRoZSBvbmVzIHdlIGxvZy5cbiAgICAgICAgLy8gVGhpcyBlbnN1cmVzIHRoYXQgd2Ugb25seSBsb2cgdGhlIGFjdHVhbCBjbGllbnQgc2lkZSBlcnJvciBpZiBpdCdzIGp1c3QgYSBwbGFpblxuICAgICAgICAvLyBlcnJvciB0aHJvd24gZnJvbSBhIGNvbXBvbmVudCBvbiB0aGUgc2VydmVyIGFuZCB0aGUgY2xpZW50LlxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBSb290U3VzcGVuZGVkOlxuICAgIGNhc2UgUm9vdENvbXBsZXRlZDpcbiAgICAgIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gcm9vdCBleGl0IHN0YXR1cy4nKTtcbiAgICAgIH1cbiAgfVxuXG4gIGlmIChzaG91bGRGb3JjZUZsdXNoRmFsbGJhY2tzSW5ERVYoKSkge1xuICAgIC8vIFdlJ3JlIGluc2lkZSBhbiBgYWN0YCBzY29wZS4gQ29tbWl0IGltbWVkaWF0ZWx5LlxuICAgIGNvbW1pdFJvb3Qocm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMsIHdvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUsIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoaW5jbHVkZXNPbmx5UmV0cmllcyhsYW5lcykgJiYgKGFsd2F5c1Rocm90dGxlUmV0cmllcyApKSB7XG4gICAgICAvLyBUaGlzIHJlbmRlciBvbmx5IGluY2x1ZGVkIHJldHJpZXMsIG5vIHVwZGF0ZXMuIFRocm90dGxlIGNvbW1pdHRpbmdcbiAgICAgIC8vIHJldHJpZXMgc28gdGhhdCB3ZSBkb24ndCBzaG93IHRvbyBtYW55IGxvYWRpbmcgc3RhdGVzIHRvbyBxdWlja2x5LlxuICAgICAgdmFyIG1zVW50aWxUaW1lb3V0ID0gZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSArIEZBTExCQUNLX1RIUk9UVExFX01TIC0gbm93JDEoKTsgLy8gRG9uJ3QgYm90aGVyIHdpdGggYSB2ZXJ5IHNob3J0IHN1c3BlbnNlIHRpbWUuXG5cbiAgICAgIGlmIChtc1VudGlsVGltZW91dCA+IDEwKSB7XG4gICAgICAgIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIGxhbmVzLCB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSk7XG4gICAgICAgIHZhciBuZXh0TGFuZXMgPSBnZXROZXh0TGFuZXMocm9vdCwgTm9MYW5lcyk7XG5cbiAgICAgICAgaWYgKG5leHRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgICAgIC8vIFRoZXJlJ3MgYWRkaXRpb25hbCB3b3JrIHdlIGNhbiBkbyBvbiB0aGlzIHJvb3QuIFdlIG1pZ2h0IGFzIHdlbGxcbiAgICAgICAgICAvLyBhdHRlbXB0IHRvIHdvcmsgb24gdGhhdCB3aGlsZSB3ZSdyZSBzdXNwZW5kZWQuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIFRoZSByZW5kZXIgaXMgc3VzcGVuZGVkLCBpdCBoYXNuJ3QgdGltZWQgb3V0LCBhbmQgdGhlcmUncyBub1xuICAgICAgICAvLyBsb3dlciBwcmlvcml0eSB3b3JrIHRvIGRvLiBJbnN0ZWFkIG9mIGNvbW1pdHRpbmcgdGhlIGZhbGxiYWNrXG4gICAgICAgIC8vIGltbWVkaWF0ZWx5LCB3YWl0IGZvciBtb3JlIGRhdGEgdG8gYXJyaXZlLlxuICAgICAgICAvLyBUT0RPOiBDb21iaW5lIHJldHJ5IHRocm90dGxpbmcgd2l0aCBTdXNwZW5zZXkgY29tbWl0cy4gUmlnaHQgbm93IHRoZXlcbiAgICAgICAgLy8gcnVuIG9uZSBhZnRlciB0aGUgb3RoZXIuXG5cblxuICAgICAgICByb290LnRpbWVvdXRIYW5kbGUgPSBzY2hlZHVsZVRpbWVvdXQoY29tbWl0Um9vdFdoZW5SZWFkeS5iaW5kKG51bGwsIHJvb3QsIGZpbmlzaGVkV29yaywgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMsIHdvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUsIGxhbmVzLCB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSksIG1zVW50aWxUaW1lb3V0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbW1pdFJvb3RXaGVuUmVhZHkocm9vdCwgZmluaXNoZWRXb3JrLCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycywgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucywgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSwgbGFuZXMsIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRSb290V2hlblJlYWR5KHJvb3QsIGZpbmlzaGVkV29yaywgcmVjb3ZlcmFibGVFcnJvcnMsIHRyYW5zaXRpb25zLCBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUsIGxhbmVzLCBzcGF3bmVkTGFuZSkge1xuICAvLyBUT0RPOiBDb21iaW5lIHJldHJ5IHRocm90dGxpbmcgd2l0aCBTdXNwZW5zZXkgY29tbWl0cy4gUmlnaHQgbm93IHRoZXkgcnVuXG4gIC8vIG9uZSBhZnRlciB0aGUgb3RoZXIuXG4gIHZhciBCb3RoVmlzaWJpbGl0eUFuZE1heVN1c3BlbmRDb21taXQgPSBWaXNpYmlsaXR5IHwgTWF5U3VzcGVuZENvbW1pdDtcbiAgdmFyIHN1YnRyZWVGbGFncyA9IGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3M7XG5cbiAgaWYgKHN1YnRyZWVGbGFncyAmIFNob3VsZFN1c3BlbmRDb21taXQgfHwgKHN1YnRyZWVGbGFncyAmIEJvdGhWaXNpYmlsaXR5QW5kTWF5U3VzcGVuZENvbW1pdCkgPT09IEJvdGhWaXNpYmlsaXR5QW5kTWF5U3VzcGVuZENvbW1pdCkge1xuICAgIC8vIEJlZm9yZSBjb21taXR0aW5nLCBhc2sgdGhlIHJlbmRlcmVyIHdoZXRoZXIgdGhlIGhvc3QgdHJlZSBpcyByZWFkeS5cbiAgICAvLyBJZiBpdCdzIG5vdCwgd2UnbGwgd2FpdCB1bnRpbCBpdCBub3RpZmllcyB1cy5cbiAgICBzdGFydFN1c3BlbmRpbmdDb21taXQoKTsgLy8gVGhpcyB3aWxsIHdhbGsgdGhlIGNvbXBsZXRlZCBmaWJlciB0cmVlIGFuZCBhdHRhY2ggbGlzdGVuZXJzIHRvIGFsbFxuICAgIC8vIHRoZSBzdXNwZW5zZXkgcmVzb3VyY2VzLiBUaGUgcmVuZGVyZXIgaXMgcmVzcG9uc2libGUgZm9yIGFjY3VtdWxhdGluZ1xuICAgIC8vIGFsbCB0aGUgbG9hZCBldmVudHMuIFRoaXMgYWxsIGhhcHBlbnMgaW4gYSBzaW5nbGUgc3luY2hyb25vdXNcbiAgICAvLyB0cmFuc2FjdGlvbiwgc28gaXQgdHJhY2sgc3RhdGUgaW4gaXRzIG93biBtb2R1bGUgc2NvcGUuXG5cbiAgICBhY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpbmlzaGVkV29yayk7IC8vIEF0IHRoZSBlbmQsIGFzayB0aGUgcmVuZGVyZXIgaWYgaXQncyByZWFkeSB0byBjb21taXQsIG9yIGlmIHdlIHNob3VsZFxuICAgIC8vIHN1c3BlbmQuIElmIGl0J3Mgbm90IHJlYWR5LCBpdCB3aWxsIHJldHVybiBhIGNhbGxiYWNrIHRvIHN1YnNjcmliZSB0b1xuICAgIC8vIGEgcmVhZHkgZXZlbnQuXG5cbiAgICB2YXIgc2NoZWR1bGVQZW5kaW5nQ29tbWl0ID0gd2FpdEZvckNvbW1pdFRvQmVSZWFkeSgpO1xuXG4gICAgaWYgKHNjaGVkdWxlUGVuZGluZ0NvbW1pdCAhPT0gbnVsbCkge1xuICAgICAgLy8gTk9URTogd2FpdEZvckNvbW1pdFRvQmVSZWFkeSByZXR1cm5zIGEgc3Vic2NyaWJlIGZ1bmN0aW9uIHNvIHRoYXQgd2VcbiAgICAgIC8vIG9ubHkgYWxsb2NhdGUgYSBmdW5jdGlvbiBpZiB0aGUgY29tbWl0IGlzbid0IHJlYWR5IHlldC4gVGhlIG90aGVyXG4gICAgICAvLyBwYXR0ZXJuIHdvdWxkIGJlIHRvIGFsd2F5cyBwYXNzIGEgY2FsbGJhY2sgdG8gd2FpdEZvckNvbW1pdFRvQmVSZWFkeS5cbiAgICAgIC8vIE5vdCB5ZXQgcmVhZHkgdG8gY29tbWl0LiBEZWxheSB0aGUgY29tbWl0IHVudGlsIHRoZSByZW5kZXJlciBub3RpZmllc1xuICAgICAgLy8gdXMgdGhhdCBpdCdzIHJlYWR5LiBUaGlzIHdpbGwgYmUgY2FuY2VsZWQgaWYgd2Ugc3RhcnQgd29yayBvbiB0aGVcbiAgICAgIC8vIHJvb3QgYWdhaW4uXG4gICAgICByb290LmNhbmNlbFBlbmRpbmdDb21taXQgPSBzY2hlZHVsZVBlbmRpbmdDb21taXQoY29tbWl0Um9vdC5iaW5kKG51bGwsIHJvb3QsIHJlY292ZXJhYmxlRXJyb3JzLCB0cmFuc2l0aW9ucywgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlKSk7XG4gICAgICBtYXJrUm9vdFN1c3BlbmRlZChyb290LCBsYW5lcywgc3Bhd25lZExhbmUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSAvLyBPdGhlcndpc2UsIGNvbW1pdCBpbW1lZGlhdGVseS5cblxuXG4gIGNvbW1pdFJvb3Qocm9vdCwgcmVjb3ZlcmFibGVFcnJvcnMsIHRyYW5zaXRpb25zLCBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUsIHNwYXduZWRMYW5lKTtcbn1cblxuZnVuY3Rpb24gaXNSZW5kZXJDb25zaXN0ZW50V2l0aEV4dGVybmFsU3RvcmVzKGZpbmlzaGVkV29yaykge1xuICAvLyBTZWFyY2ggdGhlIHJlbmRlcmVkIHRyZWUgZm9yIGV4dGVybmFsIHN0b3JlIHJlYWRzLCBhbmQgY2hlY2sgd2hldGhlciB0aGVcbiAgLy8gc3RvcmVzIHdlcmUgbXV0YXRlZCBpbiBhIGNvbmN1cnJlbnQgZXZlbnQuIEludGVudGlvbmFsbHkgdXNpbmcgYW4gaXRlcmF0aXZlXG4gIC8vIGxvb3AgaW5zdGVhZCBvZiByZWN1cnNpb24gc28gd2UgY2FuIGV4aXQgZWFybHkuXG4gIHZhciBub2RlID0gZmluaXNoZWRXb3JrO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgaWYgKG5vZGUuZmxhZ3MgJiBTdG9yZUNvbnNpc3RlbmN5KSB7XG4gICAgICB2YXIgdXBkYXRlUXVldWUgPSBub2RlLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGNoZWNrcyA9IHVwZGF0ZVF1ZXVlLnN0b3JlcztcblxuICAgICAgICBpZiAoY2hlY2tzICE9PSBudWxsKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGVja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaGVjayA9IGNoZWNrc1tpXTtcbiAgICAgICAgICAgIHZhciBnZXRTbmFwc2hvdCA9IGNoZWNrLmdldFNuYXBzaG90O1xuICAgICAgICAgICAgdmFyIHJlbmRlcmVkVmFsdWUgPSBjaGVjay52YWx1ZTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgaWYgKCFvYmplY3RJcyhnZXRTbmFwc2hvdCgpLCByZW5kZXJlZFZhbHVlKSkge1xuICAgICAgICAgICAgICAgIC8vIEZvdW5kIGFuIGluY29uc2lzdGVudCBzdG9yZS5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIC8vIElmIGBnZXRTbmFwc2hvdGAgdGhyb3dzLCByZXR1cm4gYGZhbHNlYC4gVGhpcyB3aWxsIHNjaGVkdWxlXG4gICAgICAgICAgICAgIC8vIGEgcmUtcmVuZGVyLCBhbmQgdGhlIGVycm9yIHdpbGwgYmUgcmV0aHJvd24gZHVyaW5nIHJlbmRlci5cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQ7XG5cbiAgICBpZiAobm9kZS5zdWJ0cmVlRmxhZ3MgJiBTdG9yZUNvbnNpc3RlbmN5ICYmIGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBjaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgbm9kZSA9IGNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG5cbiAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgfSAvLyBGbG93IGRvZXNuJ3Qga25vdyB0aGlzIGlzIHVucmVhY2hhYmxlLCBidXQgZXNsaW50IGRvZXNcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVucmVhY2hhYmxlXG5cblxuICByZXR1cm4gdHJ1ZTtcbn0gLy8gVGhlIGV4dHJhIGluZGlyZWN0aW9ucyBhcm91bmQgbWFya1Jvb3RVcGRhdGVkIGFuZCBtYXJrUm9vdFN1c3BlbmRlZCBpc1xuLy8gbmVlZGVkIHRvIGF2b2lkIGEgY2lyY3VsYXIgZGVwZW5kZW5jeSBiZXR3ZWVuIHRoaXMgbW9kdWxlIGFuZFxuLy8gUmVhY3RGaWJlckxhbmUuIFRoZXJlJ3MgcHJvYmFibHkgYSBiZXR0ZXIgd2F5IHRvIHNwbGl0IHVwIHRoZXNlIG1vZHVsZXMgYW5kXG4vLyBhdm9pZCB0aGlzIHByb2JsZW0uIFBlcmhhcHMgYWxsIHRoZSByb290LW1hcmtpbmcgZnVuY3Rpb25zIHNob3VsZCBtb3ZlIGludG9cbi8vIHRoZSB3b3JrIGxvb3AuXG5cblxuZnVuY3Rpb24gbWFya1Jvb3RVcGRhdGVkKHJvb3QsIHVwZGF0ZWRMYW5lcykge1xuICBtYXJrUm9vdFVwZGF0ZWQkMShyb290LCB1cGRhdGVkTGFuZXMpO1xuXG4gIHtcbiAgICAvLyBDaGVjayBmb3IgcmVjdXJzaXZlIHVwZGF0ZXNcbiAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZXhlY3V0aW9uQ29udGV4dCAmIENvbW1pdENvbnRleHQpIHtcbiAgICAgIGRpZEluY2x1ZGVDb21taXRQaGFzZVVwZGF0ZSA9IHRydWU7XG4gICAgfVxuXG4gICAgdGhyb3dJZkluZmluaXRlVXBkYXRlTG9vcERldGVjdGVkKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1Jvb3RQaW5nZWQocm9vdCwgcGluZ2VkTGFuZXMpIHtcbiAgbWFya1Jvb3RQaW5nZWQkMShyb290LCBwaW5nZWRMYW5lcyk7XG5cbiAge1xuICAgIC8vIENoZWNrIGZvciByZWN1cnNpdmUgcGluZ3MuIFBpbmdzIGFyZSBjb25jZXB0dWFsbHkgZGlmZmVyZW50IGZyb20gdXBkYXRlcyBpblxuICAgIC8vIG90aGVyIGNvbnRleHRzIGJ1dCB3ZSBjYWxsIGl0IGFuIFwidXBkYXRlXCIgaW4gdGhpcyBjb250ZXh0IGJlY2F1c2VcbiAgICAvLyByZXBlYXRlZGx5IHBpbmdpbmcgYSBzdXNwZW5kZWQgcmVuZGVyIGNhbiBjYXVzZSBhIHJlY3Vyc2l2ZSByZW5kZXIgbG9vcC5cbiAgICAvLyBUaGUgcmVsZXZhbnQgcHJvcGVydHkgaXMgdGhhdCBpdCBjYW4gcmVzdWx0IGluIGEgbmV3IHJlbmRlciBhdHRlbXB0XG4gICAgLy8gYmVpbmcgc2NoZWR1bGVkLlxuICAgIGlmIChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChleGVjdXRpb25Db250ZXh0ICYgQ29tbWl0Q29udGV4dCkge1xuICAgICAgZGlkSW5jbHVkZUNvbW1pdFBoYXNlVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aHJvd0lmSW5maW5pdGVVcGRhdGVMb29wRGV0ZWN0ZWQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrUm9vdFN1c3BlbmRlZChyb290LCBzdXNwZW5kZWRMYW5lcywgc3Bhd25lZExhbmUpIHtcbiAgLy8gV2hlbiBzdXNwZW5kaW5nLCB3ZSBzaG91bGQgYWx3YXlzIGV4Y2x1ZGUgbGFuZXMgdGhhdCB3ZXJlIHBpbmdlZCBvciAobW9yZVxuICAvLyByYXJlbHksIHNpbmNlIHdlIHRyeSB0byBhdm9pZCBpdCkgdXBkYXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS5cbiAgc3VzcGVuZGVkTGFuZXMgPSByZW1vdmVMYW5lcyhzdXNwZW5kZWRMYW5lcywgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMpO1xuICBzdXNwZW5kZWRMYW5lcyA9IHJlbW92ZUxhbmVzKHN1c3BlbmRlZExhbmVzLCB3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyk7XG5cbiAgbWFya1Jvb3RTdXNwZW5kZWQkMShyb290LCBzdXNwZW5kZWRMYW5lcywgc3Bhd25lZExhbmUpO1xufSAvLyBUaGlzIGlzIHRoZSBlbnRyeSBwb2ludCBmb3Igc3luY2hyb25vdXMgdGFza3MgdGhhdCBkb24ndCBnb1xuLy8gdGhyb3VnaCBTY2hlZHVsZXJcblxuXG5mdW5jdGlvbiBwZXJmb3JtU3luY1dvcmtPblJvb3Qocm9vdCwgbGFuZXMpIHtcbiAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5vdCBhbHJlYWR5IGJlIHdvcmtpbmcuJyk7XG4gIH1cblxuICB2YXIgZGlkRmx1c2hQYXNzaXZlRWZmZWN0cyA9IGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcblxuICBpZiAoZGlkRmx1c2hQYXNzaXZlRWZmZWN0cykge1xuICAgIC8vIElmIHBhc3NpdmUgZWZmZWN0cyB3ZXJlIGZsdXNoZWQsIGV4aXQgdG8gdGhlIG91dGVyIHdvcmsgbG9vcCBpbiB0aGUgcm9vdFxuICAgIC8vIHNjaGVkdWxlciwgc28gd2UgY2FuIHJlY29tcHV0ZSB0aGUgcHJpb3JpdHkuXG4gICAgLy8gVE9ETzogV2UgZG9uJ3QgYWN0dWFsbHkgbmVlZCB0aGlzIGBlbnN1cmVSb290SXNTY2hlZHVsZWRgIGNhbGwgYmVjYXVzZVxuICAgIC8vIHRoaXMgcGF0aCBpcyBvbmx5IHJlYWNoYWJsZSBpZiB0aGUgcm9vdCBpcyBhbHJlYWR5IHBhcnQgb2YgdGhlIHNjaGVkdWxlLlxuICAgIC8vIEknbSBpbmNsdWRpbmcgaXQgb25seSBmb3IgY29uc2lzdGVuY3kgd2l0aCB0aGUgb3RoZXIgZXhpdCBwb2ludHMgZnJvbVxuICAgIC8vIHRoaXMgZnVuY3Rpb24uIENhbiBhZGRyZXNzIGluIGEgc3Vic2VxdWVudCByZWZhY3Rvci5cbiAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB7XG4gICAgc3luY05lc3RlZFVwZGF0ZUZsYWcoKTtcbiAgfVxuXG4gIHZhciBleGl0U3RhdHVzID0gcmVuZGVyUm9vdFN5bmMocm9vdCwgbGFuZXMpO1xuXG4gIGlmIChleGl0U3RhdHVzID09PSBSb290RXJyb3JlZCkge1xuICAgIC8vIElmIHNvbWV0aGluZyB0aHJldyBhbiBlcnJvciwgdHJ5IHJlbmRlcmluZyBvbmUgbW9yZSB0aW1lLiBXZSdsbCByZW5kZXJcbiAgICAvLyBzeW5jaHJvbm91c2x5IHRvIGJsb2NrIGNvbmN1cnJlbnQgZGF0YSBtdXRhdGlvbnMsIGFuZCB3ZSdsbCBpbmNsdWRlc1xuICAgIC8vIGFsbCBwZW5kaW5nIHVwZGF0ZXMgYXJlIGluY2x1ZGVkLiBJZiBpdCBzdGlsbCBmYWlscyBhZnRlciB0aGUgc2Vjb25kXG4gICAgLy8gYXR0ZW1wdCwgd2UnbGwgZ2l2ZSB1cCBhbmQgY29tbWl0IHRoZSByZXN1bHRpbmcgdHJlZS5cbiAgICB2YXIgb3JpZ2luYWxseUF0dGVtcHRlZExhbmVzID0gbGFuZXM7XG4gICAgdmFyIGVycm9yUmV0cnlMYW5lcyA9IGdldExhbmVzVG9SZXRyeVN5bmNocm9ub3VzbHlPbkVycm9yKHJvb3QsIG9yaWdpbmFsbHlBdHRlbXB0ZWRMYW5lcyk7XG5cbiAgICBpZiAoZXJyb3JSZXRyeUxhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICBsYW5lcyA9IGVycm9yUmV0cnlMYW5lcztcbiAgICAgIGV4aXRTdGF0dXMgPSByZWNvdmVyRnJvbUNvbmN1cnJlbnRFcnJvcihyb290LCBvcmlnaW5hbGx5QXR0ZW1wdGVkTGFuZXMsIGVycm9yUmV0cnlMYW5lcyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RGYXRhbEVycm9yZWQpIHtcbiAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBOb0xhbmVzKTtcbiAgICBtYXJrUm9vdFN1c3BlbmRlZChyb290LCBsYW5lcywgTm9MYW5lKTtcbiAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdERpZE5vdENvbXBsZXRlKSB7XG4gICAgLy8gVGhlIHJlbmRlciB1bndvdW5kIHdpdGhvdXQgY29tcGxldGluZyB0aGUgdHJlZS4gVGhpcyBoYXBwZW5zIGluIHNwZWNpYWxcbiAgICAvLyBjYXNlcyB3aGVyZSBuZWVkIHRvIGV4aXQgdGhlIGN1cnJlbnQgcmVuZGVyIHdpdGhvdXQgcHJvZHVjaW5nIGFcbiAgICAvLyBjb25zaXN0ZW50IHRyZWUgb3IgY29tbWl0dGluZy5cbiAgICBtYXJrUm9vdFN1c3BlbmRlZChyb290LCBsYW5lcywgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUpO1xuICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBXZSBub3cgaGF2ZSBhIGNvbnNpc3RlbnQgdHJlZS4gQmVjYXVzZSB0aGlzIGlzIGEgc3luYyByZW5kZXIsIHdlXG4gIC8vIHdpbGwgY29tbWl0IGl0IGV2ZW4gaWYgc29tZXRoaW5nIHN1c3BlbmRlZC5cblxuXG4gIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmN1cnJlbnQuYWx0ZXJuYXRlO1xuICByb290LmZpbmlzaGVkV29yayA9IGZpbmlzaGVkV29yaztcbiAgcm9vdC5maW5pc2hlZExhbmVzID0gbGFuZXM7XG4gIGNvbW1pdFJvb3Qocm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMsIHdvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUsIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lKTsgLy8gQmVmb3JlIGV4aXRpbmcsIG1ha2Ugc3VyZSB0aGVyZSdzIGEgY2FsbGJhY2sgc2NoZWR1bGVkIGZvciB0aGUgbmV4dFxuICAvLyBwZW5kaW5nIGxldmVsLlxuXG4gIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmbHVzaFJvb3Qocm9vdCwgbGFuZXMpIHtcbiAgaWYgKGxhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgdXBncmFkZVBlbmRpbmdMYW5lc1RvU3luYyhyb290LCBsYW5lcyk7XG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuXG4gICAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgPT09IE5vQ29udGV4dCkge1xuICAgICAgcmVzZXRSZW5kZXJUaW1lcigpOyAvLyBUT0RPOiBGb3IgaGlzdG9yaWNhbCByZWFzb25zIHRoaXMgZmx1c2hlcyBhbGwgc3luYyB3b3JrIGFjcm9zcyBhbGxcbiAgICAgIC8vIHJvb3RzLiBJdCBzaG91bGRuJ3QgcmVhbGx5IG1hdHRlciBlaXRoZXIgd2F5LCBidXQgd2UgY291bGQgY2hhbmdlIHRoaXNcbiAgICAgIC8vIHRvIG9ubHkgZmx1c2ggdGhlIGdpdmVuIHJvb3QuXG5cbiAgICAgIGZsdXNoU3luY1dvcmtPbkFsbFJvb3RzKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRFeGVjdXRpb25Db250ZXh0KCkge1xuICByZXR1cm4gZXhlY3V0aW9uQ29udGV4dDtcbn1cbmZ1bmN0aW9uIGRlZmVycmVkVXBkYXRlcyhmbikge1xuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5UO1xuICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuXG4gIHRyeSB7XG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KERlZmF1bHRFdmVudFByaW9yaXR5KTtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbDtcbiAgICByZXR1cm4gZm4oKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSk7XG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZUcmFuc2l0aW9uO1xuICB9XG59XG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhmbiwgYSkge1xuICB7XG4gICAgLy8gYmF0Y2hlZFVwZGF0ZXMgaXMgYSBuby1vcCBub3csIGJ1dCB0aGVyZSdzIHN0aWxsIHNvbWUgaW50ZXJuYWwgcmVhY3QtZG9tXG4gICAgLy8gY29kZSBjYWxsaW5nIGl0LCB0aGF0IHdlIGNhbid0IHJlbW92ZSB1bnRpbCB3ZSByZW1vdmUgbGVnYWN5IG1vZGUuXG4gICAgcmV0dXJuIGZuKGEpO1xuICB9XG59XG5mdW5jdGlvbiBkaXNjcmV0ZVVwZGF0ZXMoZm4sIGEsIGIsIGMsIGQpIHtcbiAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVDtcbiAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcblxuICB0cnkge1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShEaXNjcmV0ZUV2ZW50UHJpb3JpdHkpO1xuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsO1xuICAgIHJldHVybiBmbihhLCBiLCBjLCBkKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSk7XG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZUcmFuc2l0aW9uO1xuXG4gICAgaWYgKGV4ZWN1dGlvbkNvbnRleHQgPT09IE5vQ29udGV4dCkge1xuICAgICAgcmVzZXRSZW5kZXJUaW1lcigpO1xuICAgIH1cbiAgfVxufSAvLyBPdmVybG9hZCB0aGUgZGVmaW5pdGlvbiB0byB0aGUgdHdvIHZhbGlkIHNpZ25hdHVyZXMuXG4vLyBXYXJuaW5nLCB0aGlzIG9wdHMtb3V0IG9mIGNoZWNraW5nIHRoZSBmdW5jdGlvbiBib2R5LlxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGZsdXNoU3luY0Zyb21SZWNvbmNpbGVyKGZuKSB7XG4gIC8vIEluIGxlZ2FjeSBtb2RlLCB3ZSBmbHVzaCBwZW5kaW5nIHBhc3NpdmUgZWZmZWN0cyBhdCB0aGUgYmVnaW5uaW5nIG9mIHRoZVxuICAvLyBuZXh0IGV2ZW50LCBub3QgYXQgdGhlIGVuZCBvZiB0aGUgcHJldmlvdXMgb25lLlxuICBpZiAocm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgIT09IG51bGwgJiYgIWRpc2FibGVMZWdhY3lNb2RlICYmIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzLnRhZyA9PT0gTGVnYWN5Um9vdCAmJiAoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHQpIHtcbiAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gIH1cblxuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IEJhdGNoZWRDb250ZXh0O1xuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5UO1xuICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuXG4gIHRyeSB7XG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KERpc2NyZXRlRXZlbnRQcmlvcml0eSk7XG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGw7XG5cbiAgICBpZiAoZm4pIHtcbiAgICAgIHJldHVybiBmbigpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSk7XG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZUcmFuc2l0aW9uO1xuICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDsgLy8gRmx1c2ggdGhlIGltbWVkaWF0ZSBjYWxsYmFja3MgdGhhdCB3ZXJlIHNjaGVkdWxlZCBkdXJpbmcgdGhpcyBiYXRjaC5cbiAgICAvLyBOb3RlIHRoYXQgdGhpcyB3aWxsIGhhcHBlbiBldmVuIGlmIGJhdGNoZWRVcGRhdGVzIGlzIGhpZ2hlciB1cFxuICAgIC8vIHRoZSBzdGFjay5cblxuICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHQpIHtcbiAgICAgIGZsdXNoU3luY1dvcmtPbkFsbFJvb3RzKCk7XG4gICAgfVxuICB9XG59IC8vIElmIGNhbGxlZCBvdXRzaWRlIG9mIGEgcmVuZGVyIG9yIGNvbW1pdCB3aWxsIGZsdXNoIGFsbCBzeW5jIHdvcmsgb24gYWxsIHJvb3RzXG4vLyBSZXR1cm5zIHdoZXRoZXIgdGhlIHRoZSBjYWxsIHdhcyBkdXJpbmcgYSByZW5kZXIgb3Igbm90XG5cbmZ1bmN0aW9uIGZsdXNoU3luY1dvcmsoKSB7XG4gIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIChSZW5kZXJDb250ZXh0IHwgQ29tbWl0Q29udGV4dCkpID09PSBOb0NvbnRleHQpIHtcbiAgICBmbHVzaFN5bmNXb3JrT25BbGxSb290cygpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gaXNBbHJlYWR5UmVuZGVyaW5nKCkge1xuICAvLyBVc2VkIGJ5IHRoZSByZW5kZXJlciB0byBwcmludCBhIHdhcm5pbmcgaWYgY2VydGFpbiBBUElzIGFyZSBjYWxsZWQgZnJvbVxuICAvLyB0aGUgd3JvbmcgY29udGV4dC5cbiAgcmV0dXJuIChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dDtcbn1cbi8vIGhpZGRlbiBzdWJ0cmVlLiBUaGUgc3RhY2sgbG9naWMgaXMgbWFuYWdlZCB0aGVyZSBiZWNhdXNlIHRoYXQncyB0aGUgb25seVxuLy8gcGxhY2UgdGhhdCBldmVyIG1vZGlmaWVzIGl0LiBXaGljaCBtb2R1bGUgaXQgbGl2ZXMgaW4gZG9lc24ndCBtYXR0ZXIgZm9yXG4vLyBwZXJmb3JtYW5jZSBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gd2lsbCBnZXQgaW5saW5lZCByZWdhcmRsZXNzXG5cbmZ1bmN0aW9uIHNldEVudGFuZ2xlZFJlbmRlckxhbmVzKG5ld0VudGFuZ2xlZFJlbmRlckxhbmVzKSB7XG4gIGVudGFuZ2xlZFJlbmRlckxhbmVzID0gbmV3RW50YW5nbGVkUmVuZGVyTGFuZXM7XG59XG5mdW5jdGlvbiBnZXRFbnRhbmdsZWRSZW5kZXJMYW5lcygpIHtcbiAgcmV0dXJuIGVudGFuZ2xlZFJlbmRlckxhbmVzO1xufVxuXG5mdW5jdGlvbiByZXNldFdvcmtJblByb2dyZXNzU3RhY2soKSB7XG4gIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gbnVsbCkgcmV0dXJuO1xuICB2YXIgaW50ZXJydXB0ZWRXb3JrO1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9PT0gTm90U3VzcGVuZGVkKSB7XG4gICAgLy8gTm9ybWFsIGNhc2UuIFdvcmstaW4tcHJvZ3Jlc3MgaGFzbid0IHN0YXJ0ZWQgeWV0LiBVbndpbmQgYWxsXG4gICAgLy8gaXRzIHBhcmVudHMuXG4gICAgaW50ZXJydXB0ZWRXb3JrID0gd29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuICB9IGVsc2Uge1xuICAgIC8vIFdvcmstaW4tcHJvZ3Jlc3MgaXMgaW4gc3VzcGVuZGVkIHN0YXRlLiBSZXNldCB0aGUgd29yayBsb29wIGFuZCB1bndpbmRcbiAgICAvLyBib3RoIHRoZSBzdXNwZW5kZWQgZmliZXIgYW5kIGFsbCBpdHMgcGFyZW50cy5cbiAgICByZXNldFN1c3BlbmRlZFdvcmtMb29wT25VbndpbmQod29ya0luUHJvZ3Jlc3MpO1xuICAgIGludGVycnVwdGVkV29yayA9IHdvcmtJblByb2dyZXNzO1xuICB9XG5cbiAgd2hpbGUgKGludGVycnVwdGVkV29yayAhPT0gbnVsbCkge1xuICAgIHZhciBjdXJyZW50ID0gaW50ZXJydXB0ZWRXb3JrLmFsdGVybmF0ZTtcbiAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoY3VycmVudCwgaW50ZXJydXB0ZWRXb3JrKTtcbiAgICBpbnRlcnJ1cHRlZFdvcmsgPSBpbnRlcnJ1cHRlZFdvcmsucmV0dXJuO1xuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcykge1xuICByb290LmZpbmlzaGVkV29yayA9IG51bGw7XG4gIHJvb3QuZmluaXNoZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHZhciB0aW1lb3V0SGFuZGxlID0gcm9vdC50aW1lb3V0SGFuZGxlO1xuXG4gIGlmICh0aW1lb3V0SGFuZGxlICE9PSBub1RpbWVvdXQpIHtcbiAgICAvLyBUaGUgcm9vdCBwcmV2aW91cyBzdXNwZW5kZWQgYW5kIHNjaGVkdWxlZCBhIHRpbWVvdXQgdG8gY29tbWl0IGEgZmFsbGJhY2tcbiAgICAvLyBzdGF0ZS4gTm93IHRoYXQgd2UgaGF2ZSBhZGRpdGlvbmFsIHdvcmssIGNhbmNlbCB0aGUgdGltZW91dC5cbiAgICByb290LnRpbWVvdXRIYW5kbGUgPSBub1RpbWVvdXQ7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdIENvbXBsYWlucyBub1RpbWVvdXQgaXMgbm90IGEgVGltZW91dElELCBkZXNwaXRlIHRoZSBjaGVjayBhYm92ZVxuXG4gICAgY2FuY2VsVGltZW91dCh0aW1lb3V0SGFuZGxlKTtcbiAgfVxuXG4gIHZhciBjYW5jZWxQZW5kaW5nQ29tbWl0ID0gcm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0O1xuXG4gIGlmIChjYW5jZWxQZW5kaW5nQ29tbWl0ICE9PSBudWxsKSB7XG4gICAgcm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0ID0gbnVsbDtcbiAgICBjYW5jZWxQZW5kaW5nQ29tbWl0KCk7XG4gIH1cblxuICByZXNldFdvcmtJblByb2dyZXNzU3RhY2soKTtcbiAgd29ya0luUHJvZ3Jlc3NSb290ID0gcm9vdDtcbiAgdmFyIHJvb3RXb3JrSW5Qcm9ncmVzcyA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKHJvb3QuY3VycmVudCwgbnVsbCk7XG4gIHdvcmtJblByb2dyZXNzID0gcm9vdFdvcmtJblByb2dyZXNzO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IGxhbmVzO1xuICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbiAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzUm9vdERpZEF0dGFjaFBpbmdMaXN0ZW5lciA9IGZhbHNlO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEluUHJvZ3Jlc3M7XG4gIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzID0gTm9MYW5lcztcbiAgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgPSBOb0xhbmVzO1xuICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSA9IE5vTGFuZTtcbiAgd29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSA9IGZhbHNlOyAvLyBHZXQgdGhlIGxhbmVzIHRoYXQgYXJlIGVudGFuZ2xlZCB3aXRoIHdoYXRldmVyIHdlJ3JlIGFib3V0IHRvIHJlbmRlci4gV2VcbiAgLy8gdHJhY2sgdGhlc2Ugc2VwYXJhdGVseSBzbyB3ZSBjYW4gZGlzdGluZ3Vpc2ggdGhlIHByaW9yaXR5IG9mIHRoZSByZW5kZXJcbiAgLy8gdGFzayBmcm9tIHRoZSBwcmlvcml0eSBvZiB0aGUgbGFuZXMgaXQgaXMgZW50YW5nbGVkIHdpdGguIEZvciBleGFtcGxlLCBhXG4gIC8vIHRyYW5zaXRpb24gbWF5IG5vdCBiZSBhbGxvd2VkIHRvIGZpbmlzaCB1bmxlc3MgaXQgaW5jbHVkZXMgdGhlIFN5bmMgbGFuZSxcbiAgLy8gd2hpY2ggaXMgY3VycmVudGx5IHN1c3BlbmRlZC4gV2Ugc2hvdWxkIGJlIGFibGUgdG8gcmVuZGVyIHRoZSBUcmFuc2l0aW9uXG4gIC8vIGFuZCBTeW5jIGxhbmUgaW4gdGhlIHNhbWUgYmF0Y2gsIGJ1dCBhdCBUcmFuc2l0aW9uIHByaW9yaXR5LCBiZWNhdXNlIHRoZVxuICAvLyBTeW5jIGxhbmUgYWxyZWFkeSBzdXNwZW5kZWQuXG5cbiAgZW50YW5nbGVkUmVuZGVyTGFuZXMgPSBnZXRFbnRhbmdsZWRMYW5lcyhyb290LCBsYW5lcyk7XG4gIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKTtcblxuICB7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZGlzY2FyZFBlbmRpbmdXYXJuaW5ncygpO1xuICB9XG5cbiAgcmV0dXJuIHJvb3RXb3JrSW5Qcm9ncmVzcztcbn1cblxuZnVuY3Rpb24gcmVzZXRTdXNwZW5kZWRXb3JrTG9vcE9uVW53aW5kKGZpYmVyKSB7XG4gIC8vIFJlc2V0IG1vZHVsZS1sZXZlbCBzdGF0ZSB0aGF0IHdhcyBzZXQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG4gIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuICByZXNldEhvb2tzT25VbndpbmQoZmliZXIpO1xuICByZXNldENoaWxkUmVjb25jaWxlck9uVW53aW5kKCk7XG59XG5cbmZ1bmN0aW9uIGhhbmRsZVRocm93KHJvb3QsIHRocm93blZhbHVlKSB7XG4gIC8vIEEgY29tcG9uZW50IHRocmV3IGFuIGV4Y2VwdGlvbi4gVXN1YWxseSB0aGlzIGlzIGJlY2F1c2UgaXQgc3VzcGVuZGVkLCBidXRcbiAgLy8gaXQgYWxzbyBpbmNsdWRlcyByZWd1bGFyIHByb2dyYW0gZXJyb3JzLlxuICAvL1xuICAvLyBXZSdyZSBlaXRoZXIgZ29pbmcgdG8gdW53aW5kIHRoZSBzdGFjayB0byBzaG93IGEgU3VzcGVuc2Ugb3IgZXJyb3JcbiAgLy8gYm91bmRhcnksIG9yIHdlJ3JlIGdvaW5nIHRvIHJlcGxheSB0aGUgY29tcG9uZW50IGFnYWluLiBMaWtlIGFmdGVyIGFcbiAgLy8gcHJvbWlzZSByZXNvbHZlcy5cbiAgLy9cbiAgLy8gVW50aWwgd2UgZGVjaWRlIHdoZXRoZXIgd2UncmUgZ29pbmcgdG8gdW53aW5kIG9yIHJlcGxheSwgd2Ugc2hvdWxkIHByZXNlcnZlXG4gIC8vIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSB3b3JrIGxvb3Agd2l0aG91dCByZXNldHRpbmcgYW55dGhpbmcuXG4gIC8vXG4gIC8vIElmIHdlIGRvIGRlY2lkZSB0byB1bndpbmQgdGhlIHN0YWNrLCBtb2R1bGUtbGV2ZWwgdmFyaWFibGVzIHdpbGwgYmUgcmVzZXRcbiAgLy8gaW4gcmVzZXRTdXNwZW5kZWRXb3JrTG9vcE9uVW53aW5kLlxuICAvLyBUaGVzZSBzaG91bGQgYmUgcmVzZXQgaW1tZWRpYXRlbHkgYmVjYXVzZSB0aGV5J3JlIG9ubHkgc3VwcG9zZWQgdG8gYmUgc2V0XG4gIC8vIHdoZW4gUmVhY3QgaXMgZXhlY3V0aW5nIHVzZXIgY29kZS5cbiAgcmVzZXRIb29rc0FmdGVyVGhyb3coKTtcblxuICB7XG4gICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgfVxuXG4gIGlmICh0aHJvd25WYWx1ZSA9PT0gU3VzcGVuc2VFeGNlcHRpb24pIHtcbiAgICAvLyBUaGlzIGlzIGEgc3BlY2lhbCB0eXBlIG9mIGV4Y2VwdGlvbiB1c2VkIGZvciBTdXNwZW5zZS4gRm9yIGhpc3RvcmljYWxcbiAgICAvLyByZWFzb25zLCB0aGUgcmVzdCBvZiB0aGUgU3VzcGVuc2UgaW1wbGVtZW50YXRpb24gZXhwZWN0cyB0aGUgdGhyb3duIHZhbHVlXG4gICAgLy8gdG8gYmUgYSB0aGVuYWJsZSwgYmVjYXVzZSBiZWZvcmUgYHVzZWAgZXhpc3RlZCB0aGF0IHdhcyB0aGUgKHVuc3RhYmxlKVxuICAgIC8vIEFQSSBmb3Igc3VzcGVuZGluZy4gVGhpcyBpbXBsZW1lbnRhdGlvbiBkZXRhaWwgY2FuIGNoYW5nZSBsYXRlciwgb25jZSB3ZVxuICAgIC8vIGRlcHJlY2F0ZSB0aGUgb2xkIEFQSSBpbiBmYXZvciBvZiBgdXNlYC5cbiAgICB0aHJvd25WYWx1ZSA9IGdldFN1c3BlbmRlZFRoZW5hYmxlKCk7XG4gICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBzaG91bGRSZW1haW5PblByZXZpb3VzU2NyZWVuKCkgJiYgLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIG90aGVyIHBlbmRpbmcgdXBkYXRlcyB0aGF0IG1pZ2h0IHBvc3NpYmx5IHVuYmxvY2sgdGhpc1xuICAgIC8vIGNvbXBvbmVudCBmcm9tIHN1c3BlbmRpbmcuIFRoaXMgbWlycm9ycyB0aGUgY2hlY2sgaW5cbiAgICAvLyByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlLiBXZSBzaG91bGQgYXR0ZW1wdCB0byB1bmlmeSB0aGVtIHNvbWVob3cuXG4gICAgLy8gVE9ETzogQ29uc2lkZXIgdW53aW5kaW5nIGltbWVkaWF0ZWx5LCB1c2luZyB0aGVcbiAgICAvLyBTdXNwZW5kZWRPbkh5ZHJhdGlvbiBtZWNoYW5pc20uXG4gICAgIWluY2x1ZGVzTm9uSWRsZVdvcmsod29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzKSAmJiAhaW5jbHVkZXNOb25JZGxlV29yayh3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcykgPyAvLyBTdXNwZW5kIHdvcmsgbG9vcCB1bnRpbCBkYXRhIHJlc29sdmVzXG4gICAgU3VzcGVuZGVkT25EYXRhIDogLy8gRG9uJ3Qgc3VzcGVuZCB3b3JrIGxvb3AsIGV4Y2VwdCB0byBjaGVjayBpZiB0aGUgZGF0YSBoYXNcbiAgICAvLyBpbW1lZGlhdGVseSByZXNvbHZlZCAoaS5lLiBpbiBhIG1pY3JvdGFzaykuIE90aGVyd2lzZSwgdHJpZ2dlciB0aGVcbiAgICAvLyBuZWFyZXN0IFN1c3BlbnNlIGZhbGxiYWNrLlxuICAgIFN1c3BlbmRlZE9uSW1tZWRpYXRlO1xuICB9IGVsc2UgaWYgKHRocm93blZhbHVlID09PSBTdXNwZW5zZXlDb21taXRFeGNlcHRpb24pIHtcbiAgICB0aHJvd25WYWx1ZSA9IGdldFN1c3BlbmRlZFRoZW5hYmxlKCk7XG4gICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBTdXNwZW5kZWRPbkluc3RhbmNlO1xuICB9IGVsc2UgaWYgKHRocm93blZhbHVlID09PSBTZWxlY3RpdmVIeWRyYXRpb25FeGNlcHRpb24pIHtcbiAgICAvLyBBbiB1cGRhdGUgZmxvd2VkIGludG8gYSBkZWh5ZHJhdGVkIGJvdW5kYXJ5LiBCZWZvcmUgd2UgY2FuIGFwcGx5IHRoZVxuICAgIC8vIHVwZGF0ZSwgd2UgbmVlZCB0byBmaW5pc2ggaHlkcmF0aW5nLiBJbnRlcnJ1cHQgdGhlIHdvcmstaW4tcHJvZ3Jlc3NcbiAgICAvLyByZW5kZXIgc28gd2UgY2FuIHJlc3RhcnQgYXQgdGhlIGh5ZHJhdGlvbiBsYW5lLlxuICAgIC8vXG4gICAgLy8gVGhlIGlkZWFsIGltcGxlbWVudGF0aW9uIHdvdWxkIGJlIGFibGUgdG8gc3dpdGNoIGNvbnRleHRzIHdpdGhvdXRcbiAgICAvLyB1bndpbmRpbmcgdGhlIGN1cnJlbnQgc3RhY2suXG4gICAgLy9cbiAgICAvLyBXZSBjb3VsZCBuYW1lIHRoaXMgc29tZXRoaW5nIG1vcmUgZ2VuZXJhbCBidXQgYXMgb2Ygbm93IGl0J3MgdGhlIG9ubHlcbiAgICAvLyBjYXNlIHdoZXJlIHdlIHRoaW5rIHRoaXMgc2hvdWxkIGhhcHBlbi5cbiAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IFN1c3BlbmRlZE9uSHlkcmF0aW9uO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgYSByZWd1bGFyIGVycm9yLlxuICAgIHZhciBpc1dha2VhYmxlID0gdGhyb3duVmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHRocm93blZhbHVlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgdGhyb3duVmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJztcbiAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IGlzV2FrZWFibGUgPyAvLyBBIHdha2VhYmxlIG9iamVjdCB3YXMgdGhyb3duIGJ5IGEgbGVnYWN5IFN1c3BlbnNlIGltcGxlbWVudGF0aW9uLlxuICAgIC8vIFRoaXMgaGFzIHNsaWdodGx5IGRpZmZlcmVudCBiZWhhdmlvciB0aGFuIHN1c3BlbmRpbmcgd2l0aCBgdXNlYC5cbiAgICBTdXNwZW5kZWRPbkRlcHJlY2F0ZWRUaHJvd1Byb21pc2UgOiAvLyBUaGlzIGlzIGEgcmVndWxhciBlcnJvci4gSWYgc29tZXRoaW5nIGVhcmxpZXIgaW4gdGhlIGNvbXBvbmVudCBhbHJlYWR5XG4gICAgLy8gc3VzcGVuZGVkLCB3ZSBtdXN0IGNsZWFyIHRoZSB0aGVuYWJsZSBzdGF0ZSB0byB1bmJsb2NrIHRoZSB3b3JrIGxvb3AuXG4gICAgU3VzcGVuZGVkT25FcnJvcjtcbiAgfVxuXG4gIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSB0aHJvd25WYWx1ZTtcbiAgdmFyIGVycm9yZWRXb3JrID0gd29ya0luUHJvZ3Jlc3M7XG5cbiAgaWYgKGVycm9yZWRXb3JrID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyBhIGZhdGFsIGVycm9yXG4gICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RGYXRhbEVycm9yZWQ7XG4gICAgbG9nVW5jYXVnaHRFcnJvcihyb290LCBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcih0aHJvd25WYWx1ZSwgcm9vdC5jdXJyZW50KSk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGVycm9yZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkge1xuICAgIC8vIFJlY29yZCB0aGUgdGltZSBzcGVudCByZW5kZXJpbmcgYmVmb3JlIGFuIGVycm9yIHdhcyB0aHJvd24uIFRoaXNcbiAgICAvLyBhdm9pZHMgaW5hY2N1cmF0ZSBQcm9maWxlciBkdXJhdGlvbnMgaW4gdGhlIGNhc2Ugb2YgYVxuICAgIC8vIHN1c3BlbmRlZCByZW5kZXIuXG4gICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YShlcnJvcmVkV29yaywgdHJ1ZSk7XG4gIH1cblxuICB7XG4gICAgbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTtcblxuICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24pIHtcbiAgICAgIGNhc2UgU3VzcGVuZGVkT25FcnJvcjpcbiAgICAgICAge1xuICAgICAgICAgIG1hcmtDb21wb25lbnRFcnJvcmVkKGVycm9yZWRXb3JrLCB0aHJvd25WYWx1ZSwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgU3VzcGVuZGVkT25EYXRhOlxuICAgICAgY2FzZSBTdXNwZW5kZWRPbkltbWVkaWF0ZTpcbiAgICAgIGNhc2UgU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlOlxuICAgICAgY2FzZSBTdXNwZW5kZWRBbmRSZWFkeVRvQ29udGludWU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgd2FrZWFibGUgPSB0aHJvd25WYWx1ZTtcbiAgICAgICAgICBtYXJrQ29tcG9uZW50U3VzcGVuZGVkKGVycm9yZWRXb3JrLCB3YWtlYWJsZSwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZFJlbWFpbk9uUHJldmlvdXNTY3JlZW4oKSB7XG4gIC8vIFRoaXMgaXMgYXNraW5nIHdoZXRoZXIgaXQncyBiZXR0ZXIgdG8gc3VzcGVuZCB0aGUgdHJhbnNpdGlvbiBhbmQgcmVtYWluXG4gIC8vIG9uIHRoZSBwcmV2aW91cyBzY3JlZW4sIHZlcnN1cyBzaG93aW5nIGEgZmFsbGJhY2sgYXMgc29vbiBhcyBwb3NzaWJsZS4gSXRcbiAgLy8gdGFrZXMgaW50byBhY2NvdW50IGJvdGggdGhlIHByaW9yaXR5IG9mIHJlbmRlciBhbmQgYWxzbyB3aGV0aGVyIHNob3dpbmcgYVxuICAvLyBmYWxsYmFjayB3b3VsZCBwcm9kdWNlIGEgZGVzaXJhYmxlIHVzZXIgZXhwZXJpZW5jZS5cbiAgdmFyIGhhbmRsZXIgPSBnZXRTdXNwZW5zZUhhbmRsZXIoKTtcblxuICBpZiAoaGFuZGxlciA9PT0gbnVsbCkge1xuICAgIC8vIFRoZXJlJ3Mgbm8gU3VzcGVuc2UgYm91bmRhcnkgdGhhdCBjYW4gcHJvdmlkZSBhIGZhbGxiYWNrLiBXZSBoYXZlIG5vXG4gICAgLy8gY2hvaWNlIGJ1dCB0byByZW1haW4gb24gdGhlIHByZXZpb3VzIHNjcmVlbi5cbiAgICAvLyBOT1RFOiBXZSBkbyB0aGlzIGV2ZW4gZm9yIHN5bmMgdXBkYXRlcywgZm9yIGxhY2sgb2YgYW55IGJldHRlciBvcHRpb24uIEluXG4gICAgLy8gdGhlIGZ1dHVyZSwgd2UgbWF5IGNoYW5nZSBob3cgd2UgaGFuZGxlIHRoaXMsIGxpa2UgYnkgcHV0dGluZyB0aGUgd2hvbGVcbiAgICAvLyByb290IGludG8gYSBcImRldGFjaGVkXCIgbW9kZS5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBUT0RPOiBPbmNlIGB1c2VgIGhhcyBmdWxseSByZXBsYWNlZCB0aGUgYHRocm93IHByb21pc2VgIHBhdHRlcm4sIHdlIHNob3VsZFxuICAvLyBiZSBhYmxlIHRvIHJlbW92ZSB0aGUgZXF1aXZhbGVudCBjaGVjayBpbiBmaW5pc2hDb25jdXJyZW50UmVuZGVyLCBhbmQgcmVseVxuICAvLyBqdXN0IG9uIHRoaXMgb25lLlxuXG5cbiAgaWYgKGluY2x1ZGVzT25seVRyYW5zaXRpb25zKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKSkge1xuICAgIGlmIChnZXRTaGVsbEJvdW5kYXJ5KCkgPT09IG51bGwpIHtcbiAgICAgIC8vIFdlJ3JlIHJlbmRlcmluZyBpbnNpZGUgdGhlIFwic2hlbGxcIiBvZiB0aGUgYXBwLiBBY3RpdmF0aW5nIHRoZSBuZWFyZXN0XG4gICAgICAvLyBmYWxsYmFjayB3b3VsZCBjYXVzZSB2aXNpYmxlIGNvbnRlbnQgdG8gZGlzYXBwZWFyLiBJdCdzIGJldHRlciB0b1xuICAgICAgLy8gc3VzcGVuZCB0aGUgdHJhbnNpdGlvbiBhbmQgcmVtYWluIG9uIHRoZSBwcmV2aW91cyBzY3JlZW4uXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gV2UncmUgcmVuZGVyaW5nIGNvbnRlbnQgdGhhdCB3YXNuJ3QgcGFydCBvZiB0aGUgcHJldmlvdXMgc2NyZWVuLlxuICAgICAgLy8gUmF0aGVyIHRoYW4gYmxvY2sgdGhlIHRyYW5zaXRpb24sIGl0J3MgYmV0dGVyIHRvIHNob3cgYSBmYWxsYmFjayBhc1xuICAgICAgLy8gc29vbiBhcyBwb3NzaWJsZS4gVGhlIGFwcGVhcmFuY2Ugb2YgYW55IG5lc3RlZCBmYWxsYmFja3Mgd2lsbCBiZVxuICAgICAgLy8gdGhyb3R0bGVkIHRvIGF2b2lkIGphbmsuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKGluY2x1ZGVzT25seVJldHJpZXMod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpIHx8IC8vIEluIHRoaXMgY29udGV4dCwgYW4gT2Zmc2NyZWVuTGFuZSBjb3VudHMgYXMgYSBSZXRyeVxuICAvLyBUT0RPOiBJdCdzIGJlY29tZSBpbmNyZWFzaW5nbHkgY2xlYXIgdGhhdCBSZXRyaWVzIGFuZCBPZmZzY3JlZW4gYXJlXG4gIC8vIGRlZXBseSBjb25uZWN0ZWQuIFRoZXkgcHJvYmFibHkgY2FuIGJlIHVuaWZpZWQgZnVydGhlci5cbiAgaW5jbHVkZXNTb21lTGFuZSh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcywgT2Zmc2NyZWVuTGFuZSkpIHtcbiAgICAvLyBEdXJpbmcgYSByZXRyeSwgd2UgY2FuIHN1c3BlbmQgcmVuZGVyaW5nIGlmIHRoZSBuZWFyZXN0IFN1c3BlbnNlIGJvdW5kYXJ5XG4gICAgLy8gaXMgdGhlIGJvdW5kYXJ5IG9mIHRoZSBcInNoZWxsXCIsIGJlY2F1c2Ugd2UncmUgZ3VhcmFudGVlZCBub3QgdG8gYmxvY2tcbiAgICAvLyBhbnkgbmV3IGNvbnRlbnQgZnJvbSBhcHBlYXJpbmcuXG4gICAgLy9cbiAgICAvLyBUaGUgcmVhc29uIHdlIG11c3QgY2hlY2sgaWYgdGhpcyBpcyBhIHJldHJ5IGlzIGJlY2F1c2UgaXQgZ3VhcmFudGVlc1xuICAgIC8vIHRoYXQgc3VzcGVuZGluZyB0aGUgd29yayBsb29wIHdvbid0IGJsb2NrIGFuIGFjdHVhbCB1cGRhdGUsIGJlY2F1c2VcbiAgICAvLyByZXRyaWVzIGRvbid0IFwidXBkYXRlXCIgYW55dGhpbmc7IHRoZXkgZmlsbCBpbiBmYWxsYmFja3MgdGhhdCB3ZXJlIGxlZnRcbiAgICAvLyBiZWhpbmQgYnkgYSBwcmV2aW91cyB0cmFuc2l0aW9uLlxuICAgIHJldHVybiBoYW5kbGVyID09PSBnZXRTaGVsbEJvdW5kYXJ5KCk7XG4gIH0gLy8gRm9yIGFsbCBvdGhlciBMYW5lcyBiZXNpZGVzIFRyYW5zaXRpb25zIGFuZCBSZXRyaWVzLCB3ZSBzaG91bGQgbm90IHdhaXRcbiAgLy8gZm9yIHRoZSBkYXRhIHRvIGxvYWQuXG5cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHB1c2hEaXNwYXRjaGVyKGNvbnRhaW5lcikge1xuICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuXG4gIGlmIChwcmV2RGlzcGF0Y2hlciA9PT0gbnVsbCkge1xuICAgIC8vIFRoZSBSZWFjdCBpc29tb3JwaGljIHBhY2thZ2UgZG9lcyBub3QgaW5jbHVkZSBhIGRlZmF1bHQgZGlzcGF0Y2hlci5cbiAgICAvLyBJbnN0ZWFkIHRoZSBmaXJzdCByZW5kZXJlciB3aWxsIGxhemlseSBhdHRhY2ggb25lLCBpbiBvcmRlciB0byBnaXZlXG4gICAgLy8gbmljZXIgZXJyb3IgbWVzc2FnZXMuXG4gICAgcmV0dXJuIENvbnRleHRPbmx5RGlzcGF0Y2hlcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gcHJldkRpc3BhdGNoZXI7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wRGlzcGF0Y2hlcihwcmV2RGlzcGF0Y2hlcikge1xuICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG59XG5cbmZ1bmN0aW9uIHB1c2hBc3luY0Rpc3BhdGNoZXIoKSB7XG4gIHtcbiAgICB2YXIgcHJldkFzeW5jRGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkE7XG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuQSA9IERlZmF1bHRBc3luY0Rpc3BhdGNoZXI7XG4gICAgcmV0dXJuIHByZXZBc3luY0Rpc3BhdGNoZXI7XG4gIH1cbn1cblxuZnVuY3Rpb24gcG9wQXN5bmNEaXNwYXRjaGVyKHByZXZBc3luY0Rpc3BhdGNoZXIpIHtcbiAge1xuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkEgPSBwcmV2QXN5bmNEaXNwYXRjaGVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtDb21taXRUaW1lT2ZGYWxsYmFjaygpIHtcbiAgZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSA9IG5vdyQxKCk7XG59XG5mdW5jdGlvbiBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKGxhbmUpIHtcbiAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzID0gbWVyZ2VMYW5lcyhsYW5lLCB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMpO1xufVxuZnVuY3Rpb24gcmVuZGVyRGlkU3VzcGVuZCgpIHtcbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RJblByb2dyZXNzKSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RTdXNwZW5kZWQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKSB7XG4gIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290U3VzcGVuZGVkV2l0aERlbGF5OyAvLyBDaGVjayBpZiB0aGVyZSBhcmUgdXBkYXRlcyB0aGF0IHdlIHNraXBwZWQgdHJlZSB0aGF0IG1pZ2h0IGhhdmUgdW5ibG9ja2VkXG4gIC8vIHRoaXMgcmVuZGVyLlxuXG4gIGlmICgoaW5jbHVkZXNOb25JZGxlV29yayh3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMpIHx8IGluY2x1ZGVzTm9uSWRsZVdvcmsod29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMpKSAmJiB3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IG51bGwpIHtcbiAgICAvLyBNYXJrIHRoZSBjdXJyZW50IHJlbmRlciBhcyBzdXNwZW5kZWQgc28gdGhhdCB3ZSBzd2l0Y2ggdG8gd29ya2luZyBvblxuICAgIC8vIHRoZSB1cGRhdGVzIHRoYXQgd2VyZSBza2lwcGVkLiBVc3VhbGx5IHdlIG9ubHkgc3VzcGVuZCBhdCB0aGUgZW5kIG9mXG4gICAgLy8gdGhlIHJlbmRlciBwaGFzZS5cbiAgICAvLyBUT0RPOiBXZSBzaG91bGQgcHJvYmFibHkgYWx3YXlzIG1hcmsgdGhlIHJvb3QgYXMgc3VzcGVuZGVkIGltbWVkaWF0ZWx5XG4gICAgLy8gKGluc2lkZSB0aGlzIGZ1bmN0aW9uKSwgc2luY2UgYnkgc3VzcGVuZGluZyBhdCB0aGUgZW5kIG9mIHRoZSByZW5kZXJcbiAgICAvLyBwaGFzZSBpbnRyb2R1Y2VzIGEgcG90ZW50aWFsIG1pc3Rha2Ugd2hlcmUgd2Ugc3VzcGVuZCBsYW5lcyB0aGF0IHdlcmVcbiAgICAvLyBwaW5nZWQgb3IgdXBkYXRlZCB3aGlsZSB3ZSB3ZXJlIHJlbmRlcmluZy5cbiAgICAvLyBUT0RPOiBDb25zaWRlciB1bndpbmRpbmcgaW1tZWRpYXRlbHksIHVzaW5nIHRoZVxuICAgIC8vIFN1c3BlbmRlZE9uSHlkcmF0aW9uIG1lY2hhbmlzbS5cbiAgICBtYXJrUm9vdFN1c3BlbmRlZCh3b3JrSW5Qcm9ncmVzc1Jvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzLCB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlbmRlckRpZEVycm9yKCkge1xuICBpZiAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyAhPT0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheSkge1xuICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RXJyb3JlZDtcbiAgfVxufVxuZnVuY3Rpb24gcXVldWVDb25jdXJyZW50RXJyb3IoZXJyb3IpIHtcbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMgPT09IG51bGwpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzID0gW2Vycm9yXTtcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzLnB1c2goZXJyb3IpO1xuICB9XG59IC8vIENhbGxlZCBkdXJpbmcgcmVuZGVyIHRvIGRldGVybWluZSBpZiBhbnl0aGluZyBoYXMgc3VzcGVuZGVkLlxuLy8gUmV0dXJucyBmYWxzZSBpZiB3ZSdyZSBub3Qgc3VyZS5cblxuZnVuY3Rpb24gcmVuZGVySGFzTm90U3VzcGVuZGVkWWV0KCkge1xuICAvLyBJZiBzb21ldGhpbmcgZXJyb3JlZCBvciBjb21wbGV0ZWQsIHdlIGNhbid0IHJlYWxseSBiZSBzdXJlLFxuICAvLyBzbyB0aG9zZSBhcmUgZmFsc2UuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290SW5Qcm9ncmVzcztcbn0gLy8gVE9ETzogT3ZlciB0aW1lLCB0aGlzIGZ1bmN0aW9uIGFuZCByZW5kZXJSb290Q29uY3VycmVudCBoYXZlIGJlY29tZSBtb3JlXG4vLyBhbmQgbW9yZSBzaW1pbGFyLiBOb3Qgc3VyZSBpdCBtYWtlcyBzZW5zZSB0byBtYWludGFpbiBmb3JrZWQgcGF0aHMuIENvbnNpZGVyXG4vLyB1bmlmeWluZyB0aGVtIGFnYWluLlxuXG5mdW5jdGlvbiByZW5kZXJSb290U3luYyhyb290LCBsYW5lcykge1xuICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICBleGVjdXRpb25Db250ZXh0IHw9IFJlbmRlckNvbnRleHQ7XG4gIHZhciBwcmV2RGlzcGF0Y2hlciA9IHB1c2hEaXNwYXRjaGVyKCk7XG4gIHZhciBwcmV2QXN5bmNEaXNwYXRjaGVyID0gcHVzaEFzeW5jRGlzcGF0Y2hlcigpOyAvLyBJZiB0aGUgcm9vdCBvciBsYW5lcyBoYXZlIGNoYW5nZWQsIHRocm93IG91dCB0aGUgZXhpc3Rpbmcgc3RhY2tcbiAgLy8gYW5kIHByZXBhcmUgYSBmcmVzaCBvbmUuIE90aGVyd2lzZSB3ZSdsbCBjb250aW51ZSB3aGVyZSB3ZSBsZWZ0IG9mZi5cblxuICBpZiAod29ya0luUHJvZ3Jlc3NSb290ICE9PSByb290IHx8IHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzICE9PSBsYW5lcykge1xuICAgIHtcbiAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudCkge1xuICAgICAgICB2YXIgbWVtb2l6ZWRVcGRhdGVycyA9IHJvb3QubWVtb2l6ZWRVcGRhdGVycztcblxuICAgICAgICBpZiAobWVtb2l6ZWRVcGRhdGVycy5zaXplID4gMCkge1xuICAgICAgICAgIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICAgICAgICAgIG1lbW9pemVkVXBkYXRlcnMuY2xlYXIoKTtcbiAgICAgICAgfSAvLyBBdCB0aGlzIHBvaW50LCBtb3ZlIEZpYmVycyB0aGF0IHNjaGVkdWxlZCB0aGUgdXBjb21pbmcgd29yayBmcm9tIHRoZSBNYXAgdG8gdGhlIFNldC5cbiAgICAgICAgLy8gSWYgd2UgYmFpbG91dCBvbiB0aGlzIHdvcmssIHdlJ2xsIG1vdmUgdGhlbSBiYWNrIChsaWtlIGFib3ZlKS5cbiAgICAgICAgLy8gSXQncyBpbXBvcnRhbnQgdG8gbW92ZSB0aGVtIG5vdyBpbiBjYXNlIHRoZSB3b3JrIHNwYXducyBtb3JlIHdvcmsgYXQgdGhlIHNhbWUgcHJpb3JpdHkgd2l0aCBkaWZmZXJlbnQgdXBkYXRlcnMuXG4gICAgICAgIC8vIFRoYXQgd2F5IHdlIGNhbiBrZWVwIHRoZSBjdXJyZW50IHVwZGF0ZSBhbmQgZnV0dXJlIHVwZGF0ZXMgc2VwYXJhdGUuXG5cblxuICAgICAgICBtb3ZlUGVuZGluZ0ZpYmVyc1RvTWVtb2l6ZWQocm9vdCwgbGFuZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMgPSBnZXRUcmFuc2l0aW9uc0ZvckxhbmVzKCk7XG4gICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgbGFuZXMpO1xuICB9XG5cbiAge1xuICAgIG1hcmtSZW5kZXJTdGFydGVkKGxhbmVzKTtcbiAgfVxuXG4gIHZhciBkaWRTdXNwZW5kSW5TaGVsbCA9IGZhbHNlO1xuXG4gIG91dGVyOiBkbyB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiAhPT0gTm90U3VzcGVuZGVkICYmIHdvcmtJblByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZSB3b3JrIGxvb3AgaXMgc3VzcGVuZGVkLiBEdXJpbmcgYSBzeW5jaHJvbm91cyByZW5kZXIsIHdlIGRvbid0XG4gICAgICAgIC8vIHlpZWxkIHRvIHRoZSBtYWluIHRocmVhZC4gSW1tZWRpYXRlbHkgdW53aW5kIHRoZSBzdGFjay4gVGhpcyB3aWxsXG4gICAgICAgIC8vIHRyaWdnZXIgZWl0aGVyIGEgZmFsbGJhY2sgb3IgYW4gZXJyb3IgYm91bmRhcnkuXG4gICAgICAgIC8vIFRPRE86IEZvciBkaXNjcmV0ZSBhbmQgXCJkZWZhdWx0XCIgdXBkYXRlcyAoYW55dGhpbmcgdGhhdCdzIG5vdFxuICAgICAgICAvLyBmbHVzaFN5bmMpLCB3ZSB3YW50IHRvIHdhaXQgZm9yIHRoZSBtaWNyb3Rhc2tzIHRoZSBmbHVzaCBiZWZvcmVcbiAgICAgICAgLy8gdW53aW5kaW5nLiBXaWxsIHByb2JhYmx5IGltcGxlbWVudCB0aGlzIHVzaW5nIHJlbmRlclJvb3RDb25jdXJyZW50LFxuICAgICAgICAvLyBvciBtZXJnZSByZW5kZXJSb290U3luYyBhbmQgcmVuZGVyUm9vdENvbmN1cnJlbnQgaW50byB0aGUgc2FtZVxuICAgICAgICAvLyBmdW5jdGlvbiBhbmQgZm9yayB0aGUgYmVoYXZpb3Igc29tZSBvdGhlciB3YXkuXG4gICAgICAgIHZhciB1bml0T2ZXb3JrID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIHZhciB0aHJvd25WYWx1ZSA9IHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWU7XG5cbiAgICAgICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbikge1xuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25IeWRyYXRpb246XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vIFNlbGVjdGl2ZSBoeWRyYXRpb24uIEFuIHVwZGF0ZSBmbG93ZWQgaW50byBhIGRlaHlkcmF0ZWQgdHJlZS5cbiAgICAgICAgICAgICAgLy8gSW50ZXJydXB0IHRoZSBjdXJyZW50IHJlbmRlciBzbyB0aGUgd29yayBsb29wIGNhbiBzd2l0Y2ggdG8gdGhlXG4gICAgICAgICAgICAgIC8vIGh5ZHJhdGlvbiBsYW5lLlxuICAgICAgICAgICAgICByZXNldFdvcmtJblByb2dyZXNzU3RhY2soKTtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3REaWROb3RDb21wbGV0ZTtcbiAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSW1tZWRpYXRlOlxuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25EYXRhOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoIWRpZFN1c3BlbmRJblNoZWxsICYmIGdldFN1c3BlbnNlSGFuZGxlcigpID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGlkU3VzcGVuZEluU2hlbGwgPSB0cnVlO1xuICAgICAgICAgICAgICB9IC8vIEludGVudGlvbmFsIGZhbGx0aHJvdWdoXG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vIFVud2luZCB0aGVuIGNvbnRpbnVlIHdpdGggdGhlIG5vcm1hbCB3b3JrIGxvb3AuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgdGhyb3dBbmRVbndpbmRXb3JrTG9vcChyb290LCB1bml0T2ZXb3JrLCB0aHJvd25WYWx1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdvcmtMb29wU3luYygpO1xuICAgICAgYnJlYWs7XG4gICAgfSBjYXRjaCAodGhyb3duVmFsdWUpIHtcbiAgICAgIGhhbmRsZVRocm93KHJvb3QsIHRocm93blZhbHVlKTtcbiAgICB9XG4gIH0gd2hpbGUgKHRydWUpOyAvLyBDaGVjayBpZiBzb21ldGhpbmcgc3VzcGVuZGVkIGluIHRoZSBzaGVsbC4gV2UgdXNlIHRoaXMgdG8gZGV0ZWN0IGFuXG4gIC8vIGluZmluaXRlIHBpbmcgbG9vcCBjYXVzZWQgYnkgYW4gdW5jYWNoZWQgcHJvbWlzZS5cbiAgLy9cbiAgLy8gT25seSBpbmNyZW1lbnQgdGhpcyBjb3VudGVyIG9uY2UgcGVyIHN5bmNocm9ub3VzIHJlbmRlciBhdHRlbXB0IGFjcm9zcyB0aGVcbiAgLy8gd2hvbGUgdHJlZS4gRXZlbiBpZiB0aGVyZSBhcmUgbWFueSBzaWJsaW5nIGNvbXBvbmVudHMgdGhhdCBzdXNwZW5kLCB0aGlzXG4gIC8vIGNvdW50ZXIgb25seSBnZXRzIGluY3JlbWVudGVkIG9uY2UuXG5cblxuICBpZiAoZGlkU3VzcGVuZEluU2hlbGwpIHtcbiAgICByb290LnNoZWxsU3VzcGVuZENvdW50ZXIrKztcbiAgfVxuXG4gIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpO1xuICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG4gIHBvcERpc3BhdGNoZXIocHJldkRpc3BhdGNoZXIpO1xuICBwb3BBc3luY0Rpc3BhdGNoZXIocHJldkFzeW5jRGlzcGF0Y2hlcik7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyBhIHN5bmMgcmVuZGVyLCBzbyB3ZSBzaG91bGQgaGF2ZSBmaW5pc2hlZCB0aGUgd2hvbGUgdHJlZS5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21taXQgYW4gaW5jb21wbGV0ZSByb290LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSAnICsgJ2J1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICB7XG4gICAgbWFya1JlbmRlclN0b3BwZWQoKTtcbiAgfSAvLyBTZXQgdGhpcyB0byBudWxsIHRvIGluZGljYXRlIHRoZXJlJ3Mgbm8gaW4tcHJvZ3Jlc3MgcmVuZGVyLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSBOb0xhbmVzOyAvLyBJdCdzIHNhZmUgdG8gcHJvY2VzcyB0aGUgcXVldWUgbm93IHRoYXQgdGhlIHJlbmRlciBwaGFzZSBpcyBjb21wbGV0ZS5cblxuICBmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzKCk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzO1xufSAvLyBUaGUgd29yayBsb29wIGlzIGFuIGV4dHJlbWVseSBob3QgcGF0aC4gVGVsbCBDbG9zdXJlIG5vdCB0byBpbmxpbmUgaXQuXG5cbi8qKiBAbm9pbmxpbmUgKi9cblxuXG5mdW5jdGlvbiB3b3JrTG9vcFN5bmMoKSB7XG4gIC8vIFBlcmZvcm0gd29yayB3aXRob3V0IGNoZWNraW5nIGlmIHdlIG5lZWQgdG8geWllbGQgYmV0d2VlbiBmaWJlci5cbiAgd2hpbGUgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlclJvb3RDb25jdXJyZW50KHJvb3QsIGxhbmVzKSB7XG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gUmVuZGVyQ29udGV4dDtcbiAgdmFyIHByZXZEaXNwYXRjaGVyID0gcHVzaERpc3BhdGNoZXIoKTtcbiAgdmFyIHByZXZBc3luY0Rpc3BhdGNoZXIgPSBwdXNoQXN5bmNEaXNwYXRjaGVyKCk7IC8vIElmIHRoZSByb290IG9yIGxhbmVzIGhhdmUgY2hhbmdlZCwgdGhyb3cgb3V0IHRoZSBleGlzdGluZyBzdGFja1xuICAvLyBhbmQgcHJlcGFyZSBhIGZyZXNoIG9uZS4gT3RoZXJ3aXNlIHdlJ2xsIGNvbnRpbnVlIHdoZXJlIHdlIGxlZnQgb2ZmLlxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IHJvb3QgfHwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgIT09IGxhbmVzKSB7XG4gICAge1xuICAgICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICAgIHZhciBtZW1vaXplZFVwZGF0ZXJzID0gcm9vdC5tZW1vaXplZFVwZGF0ZXJzO1xuXG4gICAgICAgIGlmIChtZW1vaXplZFVwZGF0ZXJzLnNpemUgPiAwKSB7XG4gICAgICAgICAgcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycy5jbGVhcigpO1xuICAgICAgICB9IC8vIEF0IHRoaXMgcG9pbnQsIG1vdmUgRmliZXJzIHRoYXQgc2NoZWR1bGVkIHRoZSB1cGNvbWluZyB3b3JrIGZyb20gdGhlIE1hcCB0byB0aGUgU2V0LlxuICAgICAgICAvLyBJZiB3ZSBiYWlsb3V0IG9uIHRoaXMgd29yaywgd2UnbGwgbW92ZSB0aGVtIGJhY2sgKGxpa2UgYWJvdmUpLlxuICAgICAgICAvLyBJdCdzIGltcG9ydGFudCB0byBtb3ZlIHRoZW0gbm93IGluIGNhc2UgdGhlIHdvcmsgc3Bhd25zIG1vcmUgd29yayBhdCB0aGUgc2FtZSBwcmlvcml0eSB3aXRoIGRpZmZlcmVudCB1cGRhdGVycy5cbiAgICAgICAgLy8gVGhhdCB3YXkgd2UgY2FuIGtlZXAgdGhlIGN1cnJlbnQgdXBkYXRlIGFuZCBmdXR1cmUgdXBkYXRlcyBzZXBhcmF0ZS5cblxuXG4gICAgICAgIG1vdmVQZW5kaW5nRmliZXJzVG9NZW1vaXplZChyb290LCBsYW5lcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyA9IGdldFRyYW5zaXRpb25zRm9yTGFuZXMoKTtcbiAgICByZXNldFJlbmRlclRpbWVyKCk7XG4gICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgbGFuZXMpO1xuICB9XG5cbiAge1xuICAgIG1hcmtSZW5kZXJTdGFydGVkKGxhbmVzKTtcbiAgfVxuXG4gIG91dGVyOiBkbyB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiAhPT0gTm90U3VzcGVuZGVkICYmIHdvcmtJblByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoZSB3b3JrIGxvb3AgaXMgc3VzcGVuZGVkLiBXZSBuZWVkIHRvIGVpdGhlciB1bndpbmQgdGhlIHN0YWNrIG9yXG4gICAgICAgIC8vIHJlcGxheSB0aGUgc3VzcGVuZGVkIGNvbXBvbmVudC5cbiAgICAgICAgdmFyIHVuaXRPZldvcmsgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgdmFyIHRocm93blZhbHVlID0gd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZTtcblxuICAgICAgICByZXN1bWVPclVud2luZDogc3dpdGNoICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbikge1xuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25FcnJvcjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gVW53aW5kIHRoZW4gY29udGludWUgd2l0aCB0aGUgbm9ybWFsIHdvcmsgbG9vcC5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKHJvb3QsIHVuaXRPZldvcmssIHRocm93blZhbHVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRGF0YTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIHRoZW5hYmxlID0gdGhyb3duVmFsdWU7XG5cbiAgICAgICAgICAgICAgaWYgKGlzVGhlbmFibGVSZXNvbHZlZCh0aGVuYWJsZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZGF0YSByZXNvbHZlZC4gVHJ5IHJlbmRlcmluZyB0aGUgY29tcG9uZW50IGFnYWluLlxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJlcGxheVN1c3BlbmRlZFVuaXRPZldvcmsodW5pdE9mV29yayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH0gLy8gVGhlIHdvcmsgbG9vcCBpcyBzdXNwZW5kZWQgb24gZGF0YS4gV2Ugc2hvdWxkIHdhaXQgZm9yIGl0IHRvXG4gICAgICAgICAgICAgIC8vIHJlc29sdmUgYmVmb3JlIGNvbnRpbnVpbmcgdG8gcmVuZGVyLlxuICAgICAgICAgICAgICAvLyBUT0RPOiBIYW5kbGUgdGhlIGNhc2Ugd2hlcmUgdGhlIHByb21pc2UgcmVzb2x2ZXMgc3luY2hyb25vdXNseS5cbiAgICAgICAgICAgICAgLy8gVXN1YWxseSB0aGlzIGlzIGhhbmRsZWQgd2hlbiB3ZSBpbnN0cnVtZW50IHRoZSBwcm9taXNlIHRvIGFkZCBhXG4gICAgICAgICAgICAgIC8vIGBzdGF0dXNgIGZpZWxkLCBidXQgaWYgdGhlIHByb21pc2UgYWxyZWFkeSBoYXMgYSBzdGF0dXMsIHdlIHdvbid0XG4gICAgICAgICAgICAgIC8vIGhhdmUgYWRkZWQgYSBsaXN0ZW5lciB1bnRpbCByaWdodCBoZXJlLlxuXG5cbiAgICAgICAgICAgICAgdmFyIG9uUmVzb2x1dGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGUgcm9vdCBpcyBzdGlsbCBzdXNwZW5kZWQgb24gdGhpcyBwcm9taXNlLlxuICAgICAgICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9PT0gU3VzcGVuZGVkT25EYXRhICYmIHdvcmtJblByb2dyZXNzUm9vdCA9PT0gcm9vdCkge1xuICAgICAgICAgICAgICAgICAgLy8gTWFyayB0aGUgcm9vdCBhcyByZWFkeSB0byBjb250aW51ZSByZW5kZXJpbmcuXG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IFN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZTtcbiAgICAgICAgICAgICAgICB9IC8vIEVuc3VyZSB0aGUgcm9vdCBpcyBzY2hlZHVsZWQuIFdlIHNob3VsZCBkbyB0aGlzIGV2ZW4gaWYgd2UncmVcbiAgICAgICAgICAgICAgICAvLyBjdXJyZW50bHkgd29ya2luZyBvbiBhIGRpZmZlcmVudCByb290LCBzbyB0aGF0IHdlIHJlc3VtZVxuICAgICAgICAgICAgICAgIC8vIHJlbmRlcmluZyBsYXRlci5cblxuXG4gICAgICAgICAgICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgIHRoZW5hYmxlLnRoZW4ob25SZXNvbHV0aW9uLCBvblJlc29sdXRpb24pO1xuICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25JbW1lZGlhdGU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vIElmIHRoaXMgZmliZXIganVzdCBzdXNwZW5kZWQsIGl0J3MgcG9zc2libGUgdGhlIGRhdGEgaXMgYWxyZWFkeVxuICAgICAgICAgICAgICAvLyBjYWNoZWQuIFlpZWxkIHRvIHRoZSBtYWluIHRocmVhZCB0byBnaXZlIGl0IGEgY2hhbmNlIHRvIHBpbmcuIElmXG4gICAgICAgICAgICAgIC8vIGl0IGRvZXMsIHdlIGNhbiByZXRyeSBpbW1lZGlhdGVseSB3aXRob3V0IHVud2luZGluZyB0aGUgc3RhY2suXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gU3VzcGVuZGVkQW5kUmVhZHlUb0NvbnRpbnVlO1xuICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25JbnN0YW5jZTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBTdXNwZW5kZWRPbkluc3RhbmNlQW5kUmVhZHlUb0NvbnRpbnVlO1xuICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkQW5kUmVhZHlUb0NvbnRpbnVlOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgX3RoZW5hYmxlID0gdGhyb3duVmFsdWU7XG5cbiAgICAgICAgICAgICAgaWYgKGlzVGhlbmFibGVSZXNvbHZlZChfdGhlbmFibGUpKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlIGRhdGEgcmVzb2x2ZWQuIFRyeSByZW5kZXJpbmcgdGhlIGNvbXBvbmVudCBhZ2Fpbi5cbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICByZXBsYXlTdXNwZW5kZWRVbml0T2ZXb3JrKHVuaXRPZldvcmspO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgdW53aW5kIHRoZW4gY29udGludWUgd2l0aCB0aGUgbm9ybWFsIHdvcmsgbG9vcC5cbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKHJvb3QsIHVuaXRPZldvcmssIHRocm93blZhbHVlKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkluc3RhbmNlQW5kUmVhZHlUb0NvbnRpbnVlOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgcmVzb3VyY2UgPSBudWxsO1xuXG4gICAgICAgICAgICAgIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBIb3N0SG9pc3RhYmxlOlxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICByZXNvdXJjZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gaW50ZW50aW9uYWwgZmFsbHRocm91Z2hcblxuICAgICAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgICBjYXNlIEhvc3RTaW5nbGV0b246XG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJlZm9yZSB1bndpbmRpbmcgdGhlIHN0YWNrLCBjaGVjayBvbmUgbW9yZSB0aW1lIGlmIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBpbnN0YW5jZSBpcyByZWFkeS4gSXQgbWF5IGhhdmUgbG9hZGVkIHdoZW4gUmVhY3QgeWllbGRlZCB0b1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbWFpbiB0aHJlYWQuXG4gICAgICAgICAgICAgICAgICAgIC8vIEFzc2lnbmluZyB0aGlzIHRvIGEgY29uc3RhbnQgc28gRmxvdyBrbm93cyB0aGUgYmluZGluZyB3b24ndFxuICAgICAgICAgICAgICAgICAgICAvLyBiZSBtdXRhdGVkIGJ5IGBwcmVsb2FkSW5zdGFuY2VgLlxuICAgICAgICAgICAgICAgICAgICB2YXIgaG9zdEZpYmVyID0gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlID0gaG9zdEZpYmVyLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9wcyA9IGhvc3RGaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc1JlYWR5ID0gcmVzb3VyY2UgPyBwcmVsb2FkUmVzb3VyY2UocmVzb3VyY2UpIDogcHJlbG9hZEluc3RhbmNlKHR5cGUsIHByb3BzKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNSZWFkeSkge1xuICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBkYXRhIHJlc29sdmVkLiBSZXN1bWUgdGhlIHdvcmsgbG9vcCBhcyBpZiBub3RoaW5nXG4gICAgICAgICAgICAgICAgICAgICAgLy8gc3VzcGVuZGVkLiBVbmxpa2Ugd2hlbiBhIHVzZXIgY29tcG9uZW50IHN1c3BlbmRzLCB3ZSBkb24ndFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGhhdmUgdG8gcmVwbGF5IGFueXRoaW5nIGJlY2F1c2UgdGhlIGhvc3QgZmliZXJcbiAgICAgICAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IGNvbXBsZXRlZC5cbiAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbiAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgc2libGluZyA9IGhvc3RGaWJlci5zaWJsaW5nO1xuXG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gc2libGluZztcbiAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJldHVybkZpYmVyID0gaG9zdEZpYmVyLnJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gcmV0dXJuRmliZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlVW5pdE9mV29yayhyZXR1cm5GaWJlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgYnJlYWsgcmVzdW1lT3JVbndpbmQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoaXMgd2lsbCBmYWlsIGdyYWNlZnVsbHkgYnV0IGl0J3Mgbm90IGNvcnJlY3QsIHNvIGxvZyBhXG4gICAgICAgICAgICAgICAgICAgIC8vIHdhcm5pbmcgaW4gZGV2LlxuICAgICAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgIGVycm9yKCdVbmV4cGVjdGVkIHR5cGUgb2YgZmliZXIgdHJpZ2dlcmVkIGEgc3VzcGVuc2V5IGNvbW1pdC4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gLy8gT3RoZXJ3aXNlLCB1bndpbmQgdGhlbiBjb250aW51ZSB3aXRoIHRoZSBub3JtYWwgd29yayBsb29wLlxuXG5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKHJvb3QsIHVuaXRPZldvcmssIHRocm93blZhbHVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gU3VzcGVuZGVkIGJ5IGFuIG9sZCBpbXBsZW1lbnRhdGlvbiB0aGF0IHVzZXMgdGhlIGB0aHJvdyBwcm9taXNlYFxuICAgICAgICAgICAgICAvLyBwYXR0ZXJuLiBUaGUgbmV3ZXIgcmVwbGF5aW5nIGJlaGF2aW9yIGNhbiBjYXVzZSBzdWJ0bGUgaXNzdWVzXG4gICAgICAgICAgICAgIC8vIGxpa2UgaW5maW5pdGUgcGluZyBsb29wcy4gU28gd2UgbWFpbnRhaW4gdGhlIG9sZCBiZWhhdmlvciBhbmRcbiAgICAgICAgICAgICAgLy8gYWx3YXlzIHVud2luZC5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKHJvb3QsIHVuaXRPZldvcmssIHRocm93blZhbHVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSHlkcmF0aW9uOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyBTZWxlY3RpdmUgaHlkcmF0aW9uLiBBbiB1cGRhdGUgZmxvd2VkIGludG8gYSBkZWh5ZHJhdGVkIHRyZWUuXG4gICAgICAgICAgICAgIC8vIEludGVycnVwdCB0aGUgY3VycmVudCByZW5kZXIgc28gdGhlIHdvcmsgbG9vcCBjYW4gc3dpdGNoIHRvIHRoZVxuICAgICAgICAgICAgICAvLyBoeWRyYXRpb24gbGFuZS5cbiAgICAgICAgICAgICAgcmVzZXRXb3JrSW5Qcm9ncmVzc1N0YWNrKCk7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RGlkTm90Q29tcGxldGU7XG4gICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIFN1c3BlbmRlZFJlYXNvbi4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHJ1ZSAmJiBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBgYWN0YCBzcGVjaWFsIGNhc2U6IElmIHdlJ3JlIGluc2lkZSBhbiBgYWN0YCBzY29wZSwgZG9uJ3QgY29uc3VsdFxuICAgICAgICAvLyBgc2hvdWxkWWllbGRgLiBBbHdheXMga2VlcCB3b3JraW5nIHVudGlsIHRoZSByZW5kZXIgaXMgY29tcGxldGUuXG4gICAgICAgIC8vIFRoaXMgaXMgbm90IGp1c3QgYW4gb3B0aW1pemF0aW9uOiBpbiBhIHVuaXQgdGVzdCBlbnZpcm9ubWVudCwgd2VcbiAgICAgICAgLy8gY2FuJ3QgdHJ1c3QgdGhlIHJlc3VsdCBvZiBgc2hvdWxkWWllbGRgLCBiZWNhdXNlIHRoZSBob3N0IEkvTyBpc1xuICAgICAgICAvLyBsaWtlbHkgbW9ja2VkLlxuICAgICAgICB3b3JrTG9vcFN5bmMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdvcmtMb29wQ29uY3VycmVudCgpO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcbiAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgICAgaGFuZGxlVGhyb3cocm9vdCwgdGhyb3duVmFsdWUpO1xuICAgIH1cbiAgfSB3aGlsZSAodHJ1ZSk7XG5cbiAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG4gIHBvcERpc3BhdGNoZXIocHJldkRpc3BhdGNoZXIpO1xuICBwb3BBc3luY0Rpc3BhdGNoZXIocHJldkFzeW5jRGlzcGF0Y2hlcik7XG4gIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcblxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCkge1xuICAgIC8vIFN0aWxsIHdvcmsgcmVtYWluaW5nLlxuICAgIHtcbiAgICAgIG1hcmtSZW5kZXJZaWVsZGVkKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIFJvb3RJblByb2dyZXNzO1xuICB9IGVsc2Uge1xuICAgIC8vIENvbXBsZXRlZCB0aGUgdHJlZS5cbiAgICB7XG4gICAgICBtYXJrUmVuZGVyU3RvcHBlZCgpO1xuICAgIH0gLy8gU2V0IHRoaXMgdG8gbnVsbCB0byBpbmRpY2F0ZSB0aGVyZSdzIG5vIGluLXByb2dyZXNzIHJlbmRlci5cblxuXG4gICAgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IE5vTGFuZXM7IC8vIEl0J3Mgc2FmZSB0byBwcm9jZXNzIHRoZSBxdWV1ZSBub3cgdGhhdCB0aGUgcmVuZGVyIHBoYXNlIGlzIGNvbXBsZXRlLlxuXG4gICAgZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcygpOyAvLyBSZXR1cm4gdGhlIGZpbmFsIGV4aXQgc3RhdHVzLlxuXG4gICAgcmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM7XG4gIH1cbn1cbi8qKiBAbm9pbmxpbmUgKi9cblxuXG5mdW5jdGlvbiB3b3JrTG9vcENvbmN1cnJlbnQoKSB7XG4gIC8vIFBlcmZvcm0gd29yayB1bnRpbCBTY2hlZHVsZXIgYXNrcyB1cyB0byB5aWVsZFxuICB3aGlsZSAod29ya0luUHJvZ3Jlc3MgIT09IG51bGwgJiYgIXNob3VsZFlpZWxkKCkpIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgcGVyZm9ybVVuaXRPZldvcmsod29ya0luUHJvZ3Jlc3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBlcmZvcm1Vbml0T2ZXb3JrKHVuaXRPZldvcmspIHtcbiAgLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS4gSWRlYWxseVxuICAvLyBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmUgbWVhbnMgdGhhdCB3ZSBkb24ndFxuICAvLyBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW4gcHJvZ3Jlc3MuXG4gIHZhciBjdXJyZW50ID0gdW5pdE9mV29yay5hbHRlcm5hdGU7XG4gIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYodW5pdE9mV29yayk7XG4gIHZhciBuZXh0O1xuXG4gIGlmICgodW5pdE9mV29yay5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICBzdGFydFByb2ZpbGVyVGltZXIodW5pdE9mV29yayk7XG4gICAgbmV4dCA9IGJlZ2luV29yayhjdXJyZW50LCB1bml0T2ZXb3JrLCBlbnRhbmdsZWRSZW5kZXJMYW5lcyk7XG4gICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YSh1bml0T2ZXb3JrLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBuZXh0ID0gYmVnaW5Xb3JrKGN1cnJlbnQsIHVuaXRPZldvcmssIGVudGFuZ2xlZFJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHtcbiAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICB9XG5cbiAgdW5pdE9mV29yay5tZW1vaXplZFByb3BzID0gdW5pdE9mV29yay5wZW5kaW5nUHJvcHM7XG5cbiAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAvLyBJZiB0aGlzIGRvZXNuJ3Qgc3Bhd24gbmV3IHdvcmssIGNvbXBsZXRlIHRoZSBjdXJyZW50IHdvcmsuXG4gICAgY29tcGxldGVVbml0T2ZXb3JrKHVuaXRPZldvcmspO1xuICB9IGVsc2Uge1xuICAgIHdvcmtJblByb2dyZXNzID0gbmV4dDtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYXlTdXNwZW5kZWRVbml0T2ZXb3JrKHVuaXRPZldvcmspIHtcbiAgLy8gVGhpcyBpcyBhIGZvcmsgb2YgcGVyZm9ybVVuaXRPZldvcmsgc3BlY2lmY2FsbHkgZm9yIHJlcGxheWluZyBhIGZpYmVyIHRoYXRcbiAgLy8ganVzdCBzdXNwZW5kZWQuXG4gIC8vXG4gIHZhciBjdXJyZW50ID0gdW5pdE9mV29yay5hbHRlcm5hdGU7XG4gIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYodW5pdE9mV29yayk7XG4gIHZhciBuZXh0O1xuICB2YXIgaXNQcm9maWxpbmdNb2RlID0gKHVuaXRPZldvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlO1xuXG4gIGlmIChpc1Byb2ZpbGluZ01vZGUpIHtcbiAgICBzdGFydFByb2ZpbGVyVGltZXIodW5pdE9mV29yayk7XG4gIH1cblxuICBzd2l0Y2ggKHVuaXRPZldvcmsudGFnKSB7XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIC8vIFJlc29sdmUgYGRlZmF1bHRQcm9wc2AuIFRoaXMgbG9naWMgaXMgY29waWVkIGZyb20gYGJlZ2luV29ya2AuXG4gICAgICAgIC8vIFRPRE86IENvbnNpZGVyIG1vdmluZyB0aGlzIHN3aXRjaCBzdGF0ZW1lbnQgaW50byB0aGF0IG1vZHVsZS4gQWxzbyxcbiAgICAgICAgLy8gY291bGQgbWF5YmUgdXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gc2F5IGB1c2VgIGRvZXNuJ3Qgd29yayB3aXRoXG4gICAgICAgIC8vIGBkZWZhdWx0UHJvcHNgIDopXG4gICAgICAgIHZhciBDb21wb25lbnQgPSB1bml0T2ZXb3JrLnR5cGU7XG4gICAgICAgIHZhciB1bnJlc29sdmVkUHJvcHMgPSB1bml0T2ZXb3JrLnBlbmRpbmdQcm9wcztcbiAgICAgICAgdmFyIHJlc29sdmVkUHJvcHMgPSB1bnJlc29sdmVkUHJvcHMgO1xuICAgICAgICB2YXIgY29udGV4dDtcblxuICAgICAgICBuZXh0ID0gcmVwbGF5RnVuY3Rpb25Db21wb25lbnQoY3VycmVudCwgdW5pdE9mV29yaywgcmVzb2x2ZWRQcm9wcywgQ29tcG9uZW50LCBjb250ZXh0LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAge1xuICAgICAgICAvLyBSZXNvbHZlIGBkZWZhdWx0UHJvcHNgLiBUaGlzIGxvZ2ljIGlzIGNvcGllZCBmcm9tIGBiZWdpbldvcmtgLlxuICAgICAgICAvLyBUT0RPOiBDb25zaWRlciBtb3ZpbmcgdGhpcyBzd2l0Y2ggc3RhdGVtZW50IGludG8gdGhhdCBtb2R1bGUuIEFsc28sXG4gICAgICAgIC8vIGNvdWxkIG1heWJlIHVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIHNheSBgdXNlYCBkb2Vzbid0IHdvcmsgd2l0aFxuICAgICAgICAvLyBgZGVmYXVsdFByb3BzYCA6KVxuICAgICAgICB2YXIgX0NvbXBvbmVudCA9IHVuaXRPZldvcmsudHlwZS5yZW5kZXI7XG4gICAgICAgIHZhciBfdW5yZXNvbHZlZFByb3BzID0gdW5pdE9mV29yay5wZW5kaW5nUHJvcHM7XG5cbiAgICAgICAgdmFyIF9yZXNvbHZlZFByb3BzID0gX3VucmVzb2x2ZWRQcm9wcyA7XG5cbiAgICAgICAgbmV4dCA9IHJlcGxheUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQsIHVuaXRPZldvcmssIF9yZXNvbHZlZFByb3BzLCBfQ29tcG9uZW50LCB1bml0T2ZXb3JrLnJlZiwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gU29tZSBob3N0IGNvbXBvbmVudHMgYXJlIHN0YXRlZnVsICh0aGF0J3MgaG93IHdlIGltcGxlbWVudCBmb3JtXG4gICAgICAgIC8vIGFjdGlvbnMpIGJ1dCB3ZSBkb24ndCBib3RoZXIgdG8gcmV1c2UgdGhlIG1lbW9pemVkIHN0YXRlIGJlY2F1c2UgaXQnc1xuICAgICAgICAvLyBub3Qgd29ydGggdGhlIGV4dHJhIGNvZGUuIFRoZSBtYWluIHJlYXNvbiB0byByZXVzZSB0aGUgcHJldmlvdXMgaG9va3NcbiAgICAgICAgLy8gaXMgdG8gcmV1c2UgdW5jYWNoZWQgcHJvbWlzZXMsIGJ1dCB3ZSBoYXBwZW4gdG8ga25vdyB0aGF0IHRoZSBvbmx5XG4gICAgICAgIC8vIHByb21pc2VzIHRoYXQgYSBob3N0IGNvbXBvbmVudCBtaWdodCBzdXNwZW5kIG9uIGFyZSBkZWZpbml0ZWx5IGNhY2hlZFxuICAgICAgICAvLyBiZWNhdXNlIHRoZXkgYXJlIGNvbnRyb2xsZWQgYnkgdXMuIFNvIGRvbid0IGJvdGhlci5cbiAgICAgICAgcmVzZXRIb29rc09uVW53aW5kKHVuaXRPZldvcmspOyAvLyBGYWxsdGhyb3VnaCB0byB0aGUgbmV4dCBicmFuY2guXG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICAvLyBPdGhlciB0eXBlcyBiZXNpZGVzIGZ1bmN0aW9uIGNvbXBvbmVudHMgYXJlIHJlc2V0IGNvbXBsZXRlbHkgYmVmb3JlXG4gICAgICAgIC8vIGJlaW5nIHJlcGxheWVkLiBDdXJyZW50bHkgdGhpcyBvbmx5IGhhcHBlbnMgd2hlbiBhIFVzYWJsZSB0eXBlIGlzXG4gICAgICAgIC8vIHJlY29uY2lsZWQg4oCUIHRoZSByZWNvbmNpbGVyIHdpbGwgc3VzcGVuZC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gV2UgcmVzZXQgdGhlIGZpYmVyIGJhY2sgdG8gaXRzIG9yaWdpbmFsIHN0YXRlOyBob3dldmVyLCB0aGlzIGlzbid0XG4gICAgICAgIC8vIGEgZnVsbCBcInVud2luZFwiIGJlY2F1c2Ugd2UncmUgZ29pbmcgdG8gcmV1c2UgdGhlIHByb21pc2VzIHRoYXQgd2VyZVxuICAgICAgICAvLyByZWNvbmNpbGVkIHByZXZpb3VzbHkuIFNvIGl0J3MgaW50ZW50aW9uYWwgdGhhdCB3ZSBkb24ndCBjYWxsXG4gICAgICAgIC8vIHJlc2V0U3VzcGVuZGVkV29ya0xvb3BPblVud2luZCBoZXJlLlxuICAgICAgICB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoY3VycmVudCwgdW5pdE9mV29yayk7XG4gICAgICAgIHVuaXRPZldvcmsgPSB3b3JrSW5Qcm9ncmVzcyA9IHJlc2V0V29ya0luUHJvZ3Jlc3ModW5pdE9mV29yaywgZW50YW5nbGVkUmVuZGVyTGFuZXMpO1xuICAgICAgICBuZXh0ID0gYmVnaW5Xb3JrKGN1cnJlbnQsIHVuaXRPZldvcmssIGVudGFuZ2xlZFJlbmRlckxhbmVzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cblxuICBpZiAoaXNQcm9maWxpbmdNb2RlKSB7XG4gICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YSh1bml0T2ZXb3JrLCB0cnVlKTtcbiAgfSAvLyBUaGUgYmVnaW4gcGhhc2UgZmluaXNoZWQgc3VjY2Vzc2Z1bGx5IHdpdGhvdXQgc3VzcGVuZGluZy4gUmV0dXJuIHRvIHRoZVxuICAvLyBub3JtYWwgd29yayBsb29wLlxuXG5cbiAge1xuICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gIH1cblxuICB1bml0T2ZXb3JrLm1lbW9pemVkUHJvcHMgPSB1bml0T2ZXb3JrLnBlbmRpbmdQcm9wcztcblxuICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgIC8vIElmIHRoaXMgZG9lc24ndCBzcGF3biBuZXcgd29yaywgY29tcGxldGUgdGhlIGN1cnJlbnQgd29yay5cbiAgICBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yayk7XG4gIH0gZWxzZSB7XG4gICAgd29ya0luUHJvZ3Jlc3MgPSBuZXh0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHRocm93QW5kVW53aW5kV29ya0xvb3Aocm9vdCwgdW5pdE9mV29yaywgdGhyb3duVmFsdWUpIHtcbiAgLy8gVGhpcyBpcyBhIGZvcmsgb2YgcGVyZm9ybVVuaXRPZldvcmsgc3BlY2lmY2FsbHkgZm9yIHVud2luZGluZyBhIGZpYmVyXG4gIC8vIHRoYXQgdGhyZXcgYW4gZXhjZXB0aW9uLlxuICAvL1xuICAvLyBSZXR1cm4gdG8gdGhlIG5vcm1hbCB3b3JrIGxvb3AuIFRoaXMgd2lsbCB1bndpbmQgdGhlIHN0YWNrLCBhbmQgcG90ZW50aWFsbHlcbiAgLy8gcmVzdWx0IGluIHNob3dpbmcgYSBmYWxsYmFjay5cbiAgcmVzZXRTdXNwZW5kZWRXb3JrTG9vcE9uVW53aW5kKHVuaXRPZldvcmspO1xuICB2YXIgcmV0dXJuRmliZXIgPSB1bml0T2ZXb3JrLnJldHVybjtcblxuICB0cnkge1xuICAgIC8vIEZpbmQgYW5kIG1hcmsgdGhlIG5lYXJlc3QgU3VzcGVuc2Ugb3IgZXJyb3IgYm91bmRhcnkgdGhhdCBjYW4gaGFuZGxlXG4gICAgLy8gdGhpcyBcImV4Y2VwdGlvblwiLlxuICAgIHZhciBkaWRGYXRhbCA9IHRocm93RXhjZXB0aW9uKHJvb3QsIHJldHVybkZpYmVyLCB1bml0T2ZXb3JrLCB0aHJvd25WYWx1ZSwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuXG4gICAgaWYgKGRpZEZhdGFsKSB7XG4gICAgICBwYW5pY09uUm9vdEVycm9yKHJvb3QsIHRocm93blZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgLy8gV2UgaGFkIHRyb3VibGUgcHJvY2Vzc2luZyB0aGUgZXJyb3IuIEFuIGV4YW1wbGUgb2YgdGhpcyBoYXBwZW5pbmcgaXNcbiAgICAvLyB3aGVuIGFjY2Vzc2luZyB0aGUgYGNvbXBvbmVudERpZENhdGNoYCBwcm9wZXJ0eSBvZiBhbiBlcnJvciBib3VuZGFyeVxuICAgIC8vIHRocm93cyBhbiBlcnJvci4gQSB3ZWlyZCBlZGdlIGNhc2UuIFRoZXJlJ3MgYSByZWdyZXNzaW9uIHRlc3QgZm9yIHRoaXMuXG4gICAgLy8gVG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wLCBidWJibGUgdGhlIGVycm9yIHVwIHRvIHRoZSBuZXh0IHBhcmVudC5cbiAgICBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzID0gcmV0dXJuRmliZXI7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFuaWNPblJvb3RFcnJvcihyb290LCB0aHJvd25WYWx1ZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9XG5cbiAgaWYgKHVuaXRPZldvcmsuZmxhZ3MgJiBJbmNvbXBsZXRlKSB7XG4gICAgLy8gVW53aW5kIHRoZSBzdGFjayB1bnRpbCB3ZSByZWFjaCB0aGUgbmVhcmVzdCBib3VuZGFyeS5cbiAgICB1bndpbmRVbml0T2ZXb3JrKHVuaXRPZldvcmspO1xuICB9IGVsc2Uge1xuICAgIC8vIEFsdGhvdWdoIHRoZSBmaWJlciBzdXNwZW5kZWQsIHdlJ3JlIGludGVudGlvbmFsbHkgZ29pbmcgdG8gY29tbWl0IGl0IGluXG4gICAgLy8gYW4gaW5jb25zaXN0ZW50IHN0YXRlLiBXZSBjYW4gZG8gdGhpcyBzYWZlbHkgaW4gY2FzZXMgd2hlcmUgd2Uga25vdyB0aGVcbiAgICAvLyBpbmNvbnNpc3RlbnQgdHJlZSB3aWxsIGJlIGhpZGRlbi5cbiAgICAvL1xuICAgIC8vIFRoaXMgY3VycmVudGx5IG9ubHkgYXBwbGllcyB0byBMZWdhY3kgU3VzcGVuc2UgaW1wbGVtZW50YXRpb24sIGJ1dCB3ZSBtYXlcbiAgICAvLyBwb3J0IGEgdmVyc2lvbiBvZiB0aGlzIHRvIGNvbmN1cnJlbnQgcm9vdHMsIHRvbywgd2hlbiBwZXJmb3JtaW5nIGFcbiAgICAvLyBzeW5jaHJvbm91cyByZW5kZXIuIEJlY2F1c2UgdGhhdCB3aWxsIGFsbG93IHVzIHRvIG11dGF0ZSB0aGUgdHJlZSBhcyB3ZVxuICAgIC8vIGdvIGluc3RlYWQgb2YgYnVmZmVyaW5nIG11dGF0aW9ucyB1bnRpbCB0aGUgZW5kLiBUaG91Z2ggaXQncyB1bmNsZWFyIGlmXG4gICAgLy8gdGhpcyBwYXJ0aWN1bGFyIHBhdGggaXMgaG93IHRoYXQgd291bGQgYmUgaW1wbGVtZW50ZWQuXG4gICAgY29tcGxldGVVbml0T2ZXb3JrKHVuaXRPZldvcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhbmljT25Sb290RXJyb3Iocm9vdCwgZXJyb3IpIHtcbiAgLy8gVGhlcmUncyBubyBhbmNlc3RvciB0aGF0IGNhbiBoYW5kbGUgdGhpcyBleGNlcHRpb24uIFRoaXMgc2hvdWxkIG5ldmVyXG4gIC8vIGhhcHBlbiBiZWNhdXNlIHRoZSByb290IGlzIHN1cHBvc2VkIHRvIGNhcHR1cmUgYWxsIGVycm9ycyB0aGF0IHdlcmVuJ3RcbiAgLy8gY2F1Z2h0IGJ5IGFuIGVycm9yIGJvdW5kYXJ5LiBUaGlzIGlzIGEgZmF0YWwgZXJyb3IsIG9yIHBhbmljIGNvbmRpdGlvbixcbiAgLy8gYmVjYXVzZSB3ZSd2ZSBydW4gb3V0IG9mIHdheXMgdG8gcmVjb3Zlci5cbiAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RGYXRhbEVycm9yZWQ7XG4gIGxvZ1VuY2F1Z2h0RXJyb3Iocm9vdCwgY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoZXJyb3IsIHJvb3QuY3VycmVudCkpOyAvLyBTZXQgYHdvcmtJblByb2dyZXNzYCB0byBudWxsLiBUaGlzIHJlcHJlc2VudHMgYWR2YW5jaW5nIHRvIHRoZSBuZXh0XG4gIC8vIHNpYmxpbmcsIG9yIHRoZSBwYXJlbnQgaWYgdGhlcmUgYXJlIG5vIHNpYmxpbmdzLiBCdXQgc2luY2UgdGhlIHJvb3RcbiAgLy8gaGFzIG5vIHNpYmxpbmdzIG5vciBhIHBhcmVudCwgd2Ugc2V0IGl0IHRvIG51bGwuIFVzdWFsbHkgdGhpcyBpc1xuICAvLyBoYW5kbGVkIGJ5IGBjb21wbGV0ZVVuaXRPZldvcmtgIG9yIGB1bndpbmRXb3JrYCwgYnV0IHNpbmNlIHdlJ3JlXG4gIC8vIGludGVudGlvbmFsbHkgbm90IGNhbGxpbmcgdGhvc2UsIHdlIG5lZWQgc2V0IGl0IGhlcmUuXG4gIC8vIFRPRE86IENvbnNpZGVyIGNhbGxpbmcgYHVud2luZFdvcmtgIHRvIHBvcCB0aGUgY29udGV4dHMuXG5cbiAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yaykge1xuICAvLyBBdHRlbXB0IHRvIGNvbXBsZXRlIHRoZSBjdXJyZW50IHVuaXQgb2Ygd29yaywgdGhlbiBtb3ZlIHRvIHRoZSBuZXh0XG4gIC8vIHNpYmxpbmcuIElmIHRoZXJlIGFyZSBubyBtb3JlIHNpYmxpbmdzLCByZXR1cm4gdG8gdGhlIHBhcmVudCBmaWJlci5cbiAgdmFyIGNvbXBsZXRlZFdvcmsgPSB1bml0T2ZXb3JrO1xuXG4gIGRvIHtcbiAgICB7XG4gICAgICBpZiAoKGNvbXBsZXRlZFdvcmsuZmxhZ3MgJiBJbmNvbXBsZXRlKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgIC8vIE5PVEU6IElmIHdlIHJlLWVuYWJsZSBzaWJsaW5nIHByZXJlbmRlcmluZyBpbiBzb21lIGNhc2VzLCB0aGlzIGJyYW5jaFxuICAgICAgICAvLyBpcyB3aGVyZSB3ZSB3b3VsZCBzd2l0Y2ggdG8gdGhlIHVud2luZGluZyBwYXRoLlxuICAgICAgICBlcnJvcignSW50ZXJuYWwgUmVhY3QgZXJyb3I6IEV4cGVjdGVkIHRoaXMgZmliZXIgdG8gYmUgY29tcGxldGUsIGJ1dCAnICsgXCJpdCBpc24ndC4gSXQgc2hvdWxkIGhhdmUgYmVlbiB1bndvdW5kLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LlwiKTtcbiAgICAgIH1cbiAgICB9IC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuIElkZWFsbHlcbiAgICAvLyBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmUgbWVhbnMgdGhhdCB3ZSBkb24ndFxuICAgIC8vIG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpbiBwcm9ncmVzcy5cblxuXG4gICAgdmFyIGN1cnJlbnQgPSBjb21wbGV0ZWRXb3JrLmFsdGVybmF0ZTtcbiAgICB2YXIgcmV0dXJuRmliZXIgPSBjb21wbGV0ZWRXb3JrLnJldHVybjtcbiAgICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKGNvbXBsZXRlZFdvcmspO1xuICAgIHZhciBuZXh0ID0gdm9pZCAwO1xuXG4gICAgaWYgKChjb21wbGV0ZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkgPT09IE5vTW9kZSkge1xuICAgICAgbmV4dCA9IGNvbXBsZXRlV29yayhjdXJyZW50LCBjb21wbGV0ZWRXb3JrLCBlbnRhbmdsZWRSZW5kZXJMYW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0UHJvZmlsZXJUaW1lcihjb21wbGV0ZWRXb3JrKTtcbiAgICAgIG5leHQgPSBjb21wbGV0ZVdvcmsoY3VycmVudCwgY29tcGxldGVkV29yaywgZW50YW5nbGVkUmVuZGVyTGFuZXMpOyAvLyBVcGRhdGUgcmVuZGVyIGR1cmF0aW9uIGFzc3VtaW5nIHdlIGRpZG4ndCBlcnJvci5cblxuICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YShjb21wbGV0ZWRXb3JrLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgcmVzZXRDdXJyZW50RGVidWdGaWJlckluREVWKCk7XG5cbiAgICBpZiAobmV4dCAhPT0gbnVsbCkge1xuICAgICAgLy8gQ29tcGxldGluZyB0aGlzIGZpYmVyIHNwYXduZWQgbmV3IHdvcmsuIFdvcmsgb24gdGhhdCBuZXh0LlxuICAgICAgd29ya0luUHJvZ3Jlc3MgPSBuZXh0O1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzaWJsaW5nRmliZXIgPSBjb21wbGV0ZWRXb3JrLnNpYmxpbmc7XG5cbiAgICBpZiAoc2libGluZ0ZpYmVyICE9PSBudWxsKSB7XG4gICAgICAvLyBJZiB0aGVyZSBpcyBtb3JlIHdvcmsgdG8gZG8gaW4gdGhpcyByZXR1cm5GaWJlciwgZG8gdGhhdCBuZXh0LlxuICAgICAgd29ya0luUHJvZ3Jlc3MgPSBzaWJsaW5nRmliZXI7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBPdGhlcndpc2UsIHJldHVybiB0byB0aGUgcGFyZW50XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gd2UgYmFpbCBvdXQgd2hlbiB3ZSBnZXQgYSBudWxsXG5cblxuICAgIGNvbXBsZXRlZFdvcmsgPSByZXR1cm5GaWJlcjsgLy8gVXBkYXRlIHRoZSBuZXh0IHRoaW5nIHdlJ3JlIHdvcmtpbmcgb24gaW4gY2FzZSBzb21ldGhpbmcgdGhyb3dzLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MgPSBjb21wbGV0ZWRXb3JrO1xuICB9IHdoaWxlIChjb21wbGV0ZWRXb3JrICE9PSBudWxsKTsgLy8gV2UndmUgcmVhY2hlZCB0aGUgcm9vdC5cblxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290SW5Qcm9ncmVzcykge1xuICAgIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290Q29tcGxldGVkO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVud2luZFVuaXRPZldvcmsodW5pdE9mV29yaykge1xuICB2YXIgaW5jb21wbGV0ZVdvcmsgPSB1bml0T2ZXb3JrO1xuXG4gIGRvIHtcbiAgICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLiBJZGVhbGx5XG4gICAgLy8gbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGlzLCBidXQgcmVseWluZyBvbiBpdCBoZXJlIG1lYW5zIHRoYXQgd2UgZG9uJ3RcbiAgICAvLyBuZWVkIGFuIGFkZGl0aW9uYWwgZmllbGQgb24gdGhlIHdvcmsgaW4gcHJvZ3Jlc3MuXG4gICAgdmFyIGN1cnJlbnQgPSBpbmNvbXBsZXRlV29yay5hbHRlcm5hdGU7IC8vIFRoaXMgZmliZXIgZGlkIG5vdCBjb21wbGV0ZSBiZWNhdXNlIHNvbWV0aGluZyB0aHJldy4gUG9wIHZhbHVlcyBvZmZcbiAgICAvLyB0aGUgc3RhY2sgd2l0aG91dCBlbnRlcmluZyB0aGUgY29tcGxldGUgcGhhc2UuIElmIHRoaXMgaXMgYSBib3VuZGFyeSxcbiAgICAvLyBjYXB0dXJlIHZhbHVlcyBpZiBwb3NzaWJsZS5cblxuICAgIHZhciBuZXh0ID0gdW53aW5kV29yayhjdXJyZW50LCBpbmNvbXBsZXRlV29yayk7IC8vIEJlY2F1c2UgdGhpcyBmaWJlciBkaWQgbm90IGNvbXBsZXRlLCBkb24ndCByZXNldCBpdHMgbGFuZXMuXG5cbiAgICBpZiAobmV4dCAhPT0gbnVsbCkge1xuICAgICAgLy8gRm91bmQgYSBib3VuZGFyeSB0aGF0IGNhbiBoYW5kbGUgdGhpcyBleGNlcHRpb24uIFJlLXJlbnRlciB0aGVcbiAgICAgIC8vIGJlZ2luIHBoYXNlLiBUaGlzIGJyYW5jaCB3aWxsIHJldHVybiB1cyB0byB0aGUgbm9ybWFsIHdvcmsgbG9vcC5cbiAgICAgIC8vXG4gICAgICAvLyBTaW5jZSB3ZSdyZSByZXN0YXJ0aW5nLCByZW1vdmUgYW55dGhpbmcgdGhhdCBpcyBub3QgYSBob3N0IGVmZmVjdFxuICAgICAgLy8gZnJvbSB0aGUgZWZmZWN0IHRhZy5cbiAgICAgIG5leHQuZmxhZ3MgJj0gSG9zdEVmZmVjdE1hc2s7XG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IG5leHQ7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBLZWVwIHVud2luZGluZyB1bnRpbCB3ZSByZWFjaCBlaXRoZXIgYSBib3VuZGFyeSBvciB0aGUgcm9vdC5cblxuXG4gICAgaWYgKChpbmNvbXBsZXRlV29yay5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgIC8vIFJlY29yZCB0aGUgcmVuZGVyIGR1cmF0aW9uIGZvciB0aGUgZmliZXIgdGhhdCBlcnJvcmVkLlxuICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YShpbmNvbXBsZXRlV29yaywgZmFsc2UpOyAvLyBJbmNsdWRlIHRoZSB0aW1lIHNwZW50IHdvcmtpbmcgb24gZmFpbGVkIGNoaWxkcmVuIGJlZm9yZSBjb250aW51aW5nLlxuXG4gICAgICB2YXIgYWN0dWFsRHVyYXRpb24gPSBpbmNvbXBsZXRlV29yay5hY3R1YWxEdXJhdGlvbjtcbiAgICAgIHZhciBjaGlsZCA9IGluY29tcGxldGVXb3JrLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVt1bnNhZmUtYWRkaXRpb25dIGFkZGl0aW9uIHdpdGggcG9zc2libGUgbnVsbC91bmRlZmluZWQgdmFsdWVcbiAgICAgICAgYWN0dWFsRHVyYXRpb24gKz0gY2hpbGQuYWN0dWFsRHVyYXRpb247XG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH1cblxuICAgICAgaW5jb21wbGV0ZVdvcmsuYWN0dWFsRHVyYXRpb24gPSBhY3R1YWxEdXJhdGlvbjtcbiAgICB9IC8vIFRPRE86IE9uY2Ugd2Ugc3RvcCBwcmVyZW5kZXJpbmcgc2libGluZ3MsIGluc3RlYWQgb2YgcmVzZXR0aW5nIHRoZSBwYXJlbnRcbiAgICAvLyBvZiB0aGUgbm9kZSBiZWluZyB1bndvdW5kLCB3ZSBzaG91bGQgYmUgYWJsZSB0byByZXNldCBub2RlIGl0c2VsZiBhcyB3ZVxuICAgIC8vIHVud2luZCB0aGUgc3RhY2suIFNhdmVzIGFuIGFkZGl0aW9uYWwgbnVsbCBjaGVjay5cblxuXG4gICAgdmFyIHJldHVybkZpYmVyID0gaW5jb21wbGV0ZVdvcmsucmV0dXJuO1xuXG4gICAgaWYgKHJldHVybkZpYmVyICE9PSBudWxsKSB7XG4gICAgICAvLyBNYXJrIHRoZSBwYXJlbnQgZmliZXIgYXMgaW5jb21wbGV0ZSBhbmQgY2xlYXIgaXRzIHN1YnRyZWUgZmxhZ3MuXG4gICAgICAvLyBUT0RPOiBPbmNlIHdlIHN0b3AgcHJlcmVuZGVyaW5nIHNpYmxpbmdzLCB3ZSBtYXkgYmUgYWJsZSB0byBnZXQgcmlkIG9mXG4gICAgICAvLyB0aGUgSW5jb21wbGV0ZSBmbGFnIGJlY2F1c2UgdW53aW5kaW5nIHRvIHRoZSBuZWFyZXN0IGJvdW5kYXJ5IHdpbGxcbiAgICAgIC8vIGhhcHBlbiBzeW5jaHJvbm91c2x5LlxuICAgICAgcmV0dXJuRmliZXIuZmxhZ3MgfD0gSW5jb21wbGV0ZTtcbiAgICAgIHJldHVybkZpYmVyLnN1YnRyZWVGbGFncyA9IE5vRmxhZ3MkMTtcbiAgICAgIHJldHVybkZpYmVyLmRlbGV0aW9ucyA9IG51bGw7XG4gICAgfSAvLyBOT1RFOiBJZiB3ZSByZS1lbmFibGUgc2libGluZyBwcmVyZW5kZXJpbmcgaW4gc29tZSBjYXNlcywgaGVyZSB3ZVxuICAgIC8vIHdvdWxkIHN3aXRjaCB0byB0aGUgbm9ybWFsIGNvbXBsZXRpb24gcGF0aDogY2hlY2sgaWYgYSBzaWJsaW5nXG4gICAgLy8gZXhpc3RzLCBhbmQgaWYgc28sIGJlZ2luIHdvcmsgb24gaXQuXG4gICAgLy8gT3RoZXJ3aXNlLCByZXR1cm4gdG8gdGhlIHBhcmVudFxuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIHdlIGJhaWwgb3V0IHdoZW4gd2UgZ2V0IGEgbnVsbFxuXG5cbiAgICBpbmNvbXBsZXRlV29yayA9IHJldHVybkZpYmVyOyAvLyBVcGRhdGUgdGhlIG5leHQgdGhpbmcgd2UncmUgd29ya2luZyBvbiBpbiBjYXNlIHNvbWV0aGluZyB0aHJvd3MuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcyA9IGluY29tcGxldGVXb3JrO1xuICB9IHdoaWxlIChpbmNvbXBsZXRlV29yayAhPT0gbnVsbCk7IC8vIFdlJ3ZlIHVud291bmQgYWxsIHRoZSB3YXkgdG8gdGhlIHJvb3QuXG5cblxuICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdERpZE5vdENvbXBsZXRlO1xuICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFJvb3Qocm9vdCwgcmVjb3ZlcmFibGVFcnJvcnMsIHRyYW5zaXRpb25zLCBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUsIHNwYXduZWRMYW5lKSB7XG4gIC8vIFRPRE86IFRoaXMgbm8gbG9uZ2VyIG1ha2VzIGFueSBzZW5zZS4gV2UgYWxyZWFkeSB3cmFwIHRoZSBtdXRhdGlvbiBhbmRcbiAgLy8gbGF5b3V0IHBoYXNlcy4gU2hvdWxkIGJlIGFibGUgdG8gcmVtb3ZlLlxuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5UO1xuICB2YXIgcHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcblxuICB0cnkge1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShEaXNjcmV0ZUV2ZW50UHJpb3JpdHkpO1xuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsO1xuICAgIGNvbW1pdFJvb3RJbXBsKHJvb3QsIHJlY292ZXJhYmxlRXJyb3JzLCB0cmFuc2l0aW9ucywgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLCBwcmV2aW91c1VwZGF0ZUxhbmVQcmlvcml0eSwgc3Bhd25lZExhbmUpO1xuICB9IGZpbmFsbHkge1xuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbjtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNVcGRhdGVMYW5lUHJpb3JpdHkpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFJvb3RJbXBsKHJvb3QsIHJlY292ZXJhYmxlRXJyb3JzLCB0cmFuc2l0aW9ucywgZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlLCByZW5kZXJQcmlvcml0eUxldmVsLCBzcGF3bmVkTGFuZSkge1xuICBkbyB7XG4gICAgLy8gYGZsdXNoUGFzc2l2ZUVmZmVjdHNgIHdpbGwgY2FsbCBgZmx1c2hTeW5jVXBkYXRlUXVldWVgIGF0IHRoZSBlbmQsIHdoaWNoXG4gICAgLy8gbWVhbnMgYGZsdXNoUGFzc2l2ZUVmZmVjdHNgIHdpbGwgc29tZXRpbWVzIHJlc3VsdCBpbiBhZGRpdGlvbmFsXG4gICAgLy8gcGFzc2l2ZSBlZmZlY3RzLiBTbyB3ZSBuZWVkIHRvIGtlZXAgZmx1c2hpbmcgaW4gYSBsb29wIHVudGlsIHRoZXJlIGFyZVxuICAgIC8vIG5vIG1vcmUgcGVuZGluZyBlZmZlY3RzLlxuICAgIC8vIFRPRE86IE1pZ2h0IGJlIGJldHRlciBpZiBgZmx1c2hQYXNzaXZlRWZmZWN0c2AgZGlkIG5vdCBhdXRvbWF0aWNhbGx5XG4gICAgLy8gZmx1c2ggc3luY2hyb25vdXMgd29yayBhdCB0aGUgZW5kLCB0byBhdm9pZCBmYWN0b3JpbmcgaGF6YXJkcyBsaWtlIHRoaXMuXG4gICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICB9IHdoaWxlIChyb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyAhPT0gbnVsbCk7XG5cbiAgZmx1c2hSZW5kZXJQaGFzZVN0cmljdE1vZGVXYXJuaW5nc0luREVWKCk7XG5cbiAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignU2hvdWxkIG5vdCBhbHJlYWR5IGJlIHdvcmtpbmcuJyk7XG4gIH1cblxuICB2YXIgZmluaXNoZWRXb3JrID0gcm9vdC5maW5pc2hlZFdvcms7XG4gIHZhciBsYW5lcyA9IHJvb3QuZmluaXNoZWRMYW5lcztcblxuICB7XG4gICAgbWFya0NvbW1pdFN0YXJ0ZWQobGFuZXMpO1xuICB9XG5cbiAgaWYgKGZpbmlzaGVkV29yayA9PT0gbnVsbCkge1xuXG4gICAge1xuICAgICAgbWFya0NvbW1pdFN0b3BwZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSBlbHNlIHtcbiAgICB7XG4gICAgICBpZiAobGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAgICAgZXJyb3IoJ3Jvb3QuZmluaXNoZWRMYW5lcyBzaG91bGQgbm90IGJlIGVtcHR5IGR1cmluZyBhIGNvbW1pdC4gVGhpcyBpcyBhICcgKyAnYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgcm9vdC5maW5pc2hlZExhbmVzID0gTm9MYW5lcztcblxuICBpZiAoZmluaXNoZWRXb3JrID09PSByb290LmN1cnJlbnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBjb21taXQgdGhlIHNhbWUgdHJlZSBhcyBiZWZvcmUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSAnICsgJ2EgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfSAvLyBjb21taXRSb290IG5ldmVyIHJldHVybnMgYSBjb250aW51YXRpb247IGl0IGFsd2F5cyBmaW5pc2hlcyBzeW5jaHJvbm91c2x5LlxuICAvLyBTbyB3ZSBjYW4gY2xlYXIgdGhlc2Ugbm93IHRvIGFsbG93IGEgbmV3IGNhbGxiYWNrIHRvIGJlIHNjaGVkdWxlZC5cblxuXG4gIHJvb3QuY2FsbGJhY2tOb2RlID0gbnVsbDtcbiAgcm9vdC5jYWxsYmFja1ByaW9yaXR5ID0gTm9MYW5lO1xuICByb290LmNhbmNlbFBlbmRpbmdDb21taXQgPSBudWxsOyAvLyBDaGVjayB3aGljaCBsYW5lcyBubyBsb25nZXIgaGF2ZSBhbnkgd29yayBzY2hlZHVsZWQgb24gdGhlbSwgYW5kIG1hcmtcbiAgLy8gdGhvc2UgYXMgZmluaXNoZWQuXG5cbiAgdmFyIHJlbWFpbmluZ0xhbmVzID0gbWVyZ2VMYW5lcyhmaW5pc2hlZFdvcmsubGFuZXMsIGZpbmlzaGVkV29yay5jaGlsZExhbmVzKTsgLy8gTWFrZSBzdXJlIHRvIGFjY291bnQgZm9yIGxhbmVzIHRoYXQgd2VyZSB1cGRhdGVkIGJ5IGEgY29uY3VycmVudCBldmVudFxuICAvLyBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZTsgZG9uJ3QgbWFyayB0aGVtIGFzIGZpbmlzaGVkLlxuXG4gIHZhciBjb25jdXJyZW50bHlVcGRhdGVkTGFuZXMgPSBnZXRDb25jdXJyZW50bHlVcGRhdGVkTGFuZXMoKTtcbiAgcmVtYWluaW5nTGFuZXMgPSBtZXJnZUxhbmVzKHJlbWFpbmluZ0xhbmVzLCBjb25jdXJyZW50bHlVcGRhdGVkTGFuZXMpO1xuICBtYXJrUm9vdEZpbmlzaGVkKHJvb3QsIHJlbWFpbmluZ0xhbmVzLCBzcGF3bmVkTGFuZSk7IC8vIFJlc2V0IHRoaXMgYmVmb3JlIGZpcmluZyBzaWRlIGVmZmVjdHMgc28gd2UgY2FuIGRldGVjdCByZWN1cnNpdmUgdXBkYXRlcy5cblxuICBkaWRJbmNsdWRlQ29tbWl0UGhhc2VVcGRhdGUgPSBmYWxzZTtcblxuICBpZiAocm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290KSB7XG4gICAgLy8gV2UgY2FuIHJlc2V0IHRoZXNlIG5vdyB0aGF0IHRoZXkgYXJlIGZpbmlzaGVkLlxuICAgIHdvcmtJblByb2dyZXNzUm9vdCA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gTm9MYW5lcztcbiAgfSAvLyBJZiB0aGVyZSBhcmUgcGVuZGluZyBwYXNzaXZlIGVmZmVjdHMsIHNjaGVkdWxlIGEgY2FsbGJhY2sgdG8gcHJvY2VzcyB0aGVtLlxuICAvLyBEbyB0aGlzIGFzIGVhcmx5IGFzIHBvc3NpYmxlLCBzbyBpdCBpcyBxdWV1ZWQgYmVmb3JlIGFueXRoaW5nIGVsc2UgdGhhdFxuICAvLyBtaWdodCBnZXQgc2NoZWR1bGVkIGluIHRoZSBjb21taXQgcGhhc2UuIChTZWUgIzE2NzE0LilcbiAgLy8gVE9ETzogRGVsZXRlIGFsbCBvdGhlciBwbGFjZXMgdGhhdCBzY2hlZHVsZSB0aGUgcGFzc2l2ZSBlZmZlY3QgY2FsbGJhY2tcbiAgLy8gVGhleSdyZSByZWR1bmRhbnQuXG5cblxuICBpZiAoKGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3MgJiBQYXNzaXZlTWFzaykgIT09IE5vRmxhZ3MkMSB8fCAoZmluaXNoZWRXb3JrLmZsYWdzICYgUGFzc2l2ZU1hc2spICE9PSBOb0ZsYWdzJDEpIHtcbiAgICBpZiAoIXJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzKSB7XG4gICAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IHRydWU7XG4gICAgICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW1haW5pbmdMYW5lcyA9IHJlbWFpbmluZ0xhbmVzOyAvLyB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zIG1pZ2h0IGJlIG92ZXJ3cml0dGVuLCBzbyB3ZSB3YW50XG4gICAgICAvLyB0byBzdG9yZSBpdCBpbiBwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zIHVudGlsIHRoZXkgZ2V0IHByb2Nlc3NlZFxuICAgICAgLy8gV2UgbmVlZCB0byBwYXNzIHRoaXMgdGhyb3VnaCBhcyBhbiBhcmd1bWVudCB0byBjb21taXRSb290XG4gICAgICAvLyBiZWNhdXNlIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMgbWlnaHQgaGF2ZSBjaGFuZ2VkIGJldHdlZW5cbiAgICAgIC8vIHRoZSBwcmV2aW91cyByZW5kZXIgYW5kIGNvbW1pdCBpZiB3ZSB0aHJvdHRsZSB0aGUgY29tbWl0XG4gICAgICAvLyB3aXRoIHNldFRpbWVvdXRcblxuICAgICAgcGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucyA9IHRyYW5zaXRpb25zO1xuICAgICAgc2NoZWR1bGVDYWxsYmFjayhOb3JtYWxQcmlvcml0eSQxLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTsgLy8gVGhpcyByZW5kZXIgdHJpZ2dlcmVkIHBhc3NpdmUgZWZmZWN0czogcmVsZWFzZSB0aGUgcm9vdCBjYWNoZSBwb29sXG4gICAgICAgIC8vICphZnRlciogcGFzc2l2ZSBlZmZlY3RzIGZpcmUgdG8gYXZvaWQgZnJlZWluZyBhIGNhY2hlIHBvb2wgdGhhdCBtYXlcbiAgICAgICAgLy8gYmUgcmVmZXJlbmNlZCBieSBhIG5vZGUgaW4gdGhlIHRyZWUgKEhvc3RSb290LCBDYWNoZSBib3VuZGFyeSBldGMpXG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KTtcbiAgICB9XG4gIH0gLy8gQ2hlY2sgaWYgdGhlcmUgYXJlIGFueSBlZmZlY3RzIGluIHRoZSB3aG9sZSB0cmVlLlxuICAvLyBUT0RPOiBUaGlzIGlzIGxlZnQgb3ZlciBmcm9tIHRoZSBlZmZlY3QgbGlzdCBpbXBsZW1lbnRhdGlvbiwgd2hlcmUgd2UgaGFkXG4gIC8vIHRvIGNoZWNrIGZvciB0aGUgZXhpc3RlbmNlIG9mIGBmaXJzdEVmZmVjdGAgdG8gc2F0aXNmeSBGbG93LiBJIHRoaW5rIHRoZVxuICAvLyBvbmx5IG90aGVyIHJlYXNvbiB0aGlzIG9wdGltaXphdGlvbiBleGlzdHMgaXMgYmVjYXVzZSBpdCBhZmZlY3RzIHByb2ZpbGluZy5cbiAgLy8gUmVjb25zaWRlciB3aGV0aGVyIHRoaXMgaXMgbmVjZXNzYXJ5LlxuXG5cbiAgdmFyIHN1YnRyZWVIYXNFZmZlY3RzID0gKGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3MgJiAoQmVmb3JlTXV0YXRpb25NYXNrIHwgTXV0YXRpb25NYXNrIHwgTGF5b3V0TWFzayB8IFBhc3NpdmVNYXNrKSkgIT09IE5vRmxhZ3MkMTtcbiAgdmFyIHJvb3RIYXNFZmZlY3QgPSAoZmluaXNoZWRXb3JrLmZsYWdzICYgKEJlZm9yZU11dGF0aW9uTWFzayB8IE11dGF0aW9uTWFzayB8IExheW91dE1hc2sgfCBQYXNzaXZlTWFzaykpICE9PSBOb0ZsYWdzJDE7XG5cbiAgaWYgKHN1YnRyZWVIYXNFZmZlY3RzIHx8IHJvb3RIYXNFZmZlY3QpIHtcbiAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5UO1xuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KERpc2NyZXRlRXZlbnRQcmlvcml0eSk7XG4gICAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgICBleGVjdXRpb25Db250ZXh0IHw9IENvbW1pdENvbnRleHQ7IC8vIFRoZSBjb21taXQgcGhhc2UgaXMgYnJva2VuIGludG8gc2V2ZXJhbCBzdWItcGhhc2VzLiBXZSBkbyBhIHNlcGFyYXRlIHBhc3NcbiAgICAvLyBvZiB0aGUgZWZmZWN0IGxpc3QgZm9yIGVhY2ggcGhhc2U6IGFsbCBtdXRhdGlvbiBlZmZlY3RzIGNvbWUgYmVmb3JlIGFsbFxuICAgIC8vIGxheW91dCBlZmZlY3RzLCBhbmQgc28gb24uXG4gICAgLy8gVGhlIGZpcnN0IHBoYXNlIGEgXCJiZWZvcmUgbXV0YXRpb25cIiBwaGFzZS4gV2UgdXNlIHRoaXMgcGhhc2UgdG8gcmVhZCB0aGVcbiAgICAvLyBzdGF0ZSBvZiB0aGUgaG9zdCB0cmVlIHJpZ2h0IGJlZm9yZSB3ZSBtdXRhdGUgaXQuIFRoaXMgaXMgd2hlcmVcbiAgICAvLyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSBpcyBjYWxsZWQuXG5cbiAgICBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcblxuICAgIHtcbiAgICAgIC8vIE1hcmsgdGhlIGN1cnJlbnQgY29tbWl0IHRpbWUgdG8gYmUgc2hhcmVkIGJ5IGFsbCBQcm9maWxlcnMgaW4gdGhpc1xuICAgICAgLy8gYmF0Y2guIFRoaXMgZW5hYmxlcyB0aGVtIHRvIGJlIGdyb3VwZWQgbGF0ZXIuXG4gICAgICByZWNvcmRDb21taXRUaW1lKCk7XG4gICAgfSAvLyBUaGUgbmV4dCBwaGFzZSBpcyB0aGUgbXV0YXRpb24gcGhhc2UsIHdoZXJlIHdlIG11dGF0ZSB0aGUgaG9zdCB0cmVlLlxuXG5cbiAgICBjb21taXRNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrLCBsYW5lcyk7XG5cbiAgICByZXNldEFmdGVyQ29tbWl0KHJvb3QuY29udGFpbmVySW5mbyk7IC8vIFRoZSB3b3JrLWluLXByb2dyZXNzIHRyZWUgaXMgbm93IHRoZSBjdXJyZW50IHRyZWUuIFRoaXMgbXVzdCBjb21lIGFmdGVyXG4gICAgLy8gdGhlIG11dGF0aW9uIHBoYXNlLCBzbyB0aGF0IHRoZSBwcmV2aW91cyB0cmVlIGlzIHN0aWxsIGN1cnJlbnQgZHVyaW5nXG4gICAgLy8gY29tcG9uZW50V2lsbFVubW91bnQsIGJ1dCBiZWZvcmUgdGhlIGxheW91dCBwaGFzZSwgc28gdGhhdCB0aGUgZmluaXNoZWRcbiAgICAvLyB3b3JrIGlzIGN1cnJlbnQgZHVyaW5nIGNvbXBvbmVudERpZE1vdW50L1VwZGF0ZS5cblxuICAgIHJvb3QuY3VycmVudCA9IGZpbmlzaGVkV29yazsgLy8gVGhlIG5leHQgcGhhc2UgaXMgdGhlIGxheW91dCBwaGFzZSwgd2hlcmUgd2UgY2FsbCBlZmZlY3RzIHRoYXQgcmVhZFxuXG4gICAge1xuICAgICAgbWFya0xheW91dEVmZmVjdHNTdGFydGVkKGxhbmVzKTtcbiAgICB9XG5cbiAgICBjb21taXRMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaywgcm9vdCwgbGFuZXMpO1xuXG4gICAge1xuICAgICAgbWFya0xheW91dEVmZmVjdHNTdG9wcGVkKCk7XG4gICAgfSAvLyBUZWxsIFNjaGVkdWxlciB0byB5aWVsZCBhdCB0aGUgZW5kIG9mIHRoZSBmcmFtZSwgc28gdGhlIGJyb3dzZXIgaGFzIGFuXG4gICAgLy8gb3Bwb3J0dW5pdHkgdG8gcGFpbnQuXG5cblxuICAgIHJlcXVlc3RQYWludCgpO1xuICAgIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDsgLy8gUmVzZXQgdGhlIHByaW9yaXR5IHRvIHRoZSBwcmV2aW91cyBub24tc3luYyB2YWx1ZS5cblxuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KTtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb247XG4gIH0gZWxzZSB7XG4gICAgLy8gTm8gZWZmZWN0cy5cbiAgICByb290LmN1cnJlbnQgPSBmaW5pc2hlZFdvcms7IC8vIE1lYXN1cmUgdGhlc2UgYW55d2F5IHNvIHRoZSBmbGFtZWdyYXBoIGV4cGxpY2l0bHkgc2hvd3MgdGhhdCB0aGVyZSB3ZXJlXG4gICAgLy8gbm8gZWZmZWN0cy5cbiAgICAvLyBUT0RPOiBNYXliZSB0aGVyZSdzIGEgYmV0dGVyIHdheSB0byByZXBvcnQgdGhpcy5cblxuICAgIHtcbiAgICAgIHJlY29yZENvbW1pdFRpbWUoKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcm9vdERpZEhhdmVQYXNzaXZlRWZmZWN0cyA9IHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzO1xuXG4gIGlmIChyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cykge1xuICAgIC8vIFRoaXMgY29tbWl0IGhhcyBwYXNzaXZlIGVmZmVjdHMuIFN0YXNoIGEgcmVmZXJlbmNlIHRvIHRoZW0uIEJ1dCBkb24ndFxuICAgIC8vIHNjaGVkdWxlIGEgY2FsbGJhY2sgdW50aWwgYWZ0ZXIgZmx1c2hpbmcgbGF5b3V0IHdvcmsuXG4gICAgcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMgPSBmYWxzZTtcbiAgICByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9IHJvb3Q7XG4gICAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgPSBsYW5lcztcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGVyZSB3ZXJlIG5vIHBhc3NpdmUgZWZmZWN0cywgc28gd2UgY2FuIGltbWVkaWF0ZWx5IHJlbGVhc2UgdGhlIGNhY2hlXG4gICAgLy8gcG9vbCBmb3IgdGhpcyByZW5kZXIuXG4gICAgcmVsZWFzZVJvb3RQb29sZWRDYWNoZShyb290LCByZW1haW5pbmdMYW5lcyk7XG5cbiAgICB7XG4gICAgICBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSAwO1xuICAgICAgcm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcyA9IG51bGw7XG4gICAgfVxuICB9IC8vIFJlYWQgdGhpcyBhZ2Fpbiwgc2luY2UgYW4gZWZmZWN0IG1pZ2h0IGhhdmUgdXBkYXRlZCBpdFxuXG5cbiAgcmVtYWluaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lczsgLy8gQ2hlY2sgaWYgdGhlcmUncyByZW1haW5pbmcgd29yayBvbiB0aGlzIHJvb3RcbiAgLy8gVE9ETzogVGhpcyBpcyBwYXJ0IG9mIHRoZSBgY29tcG9uZW50RGlkQ2F0Y2hgIGltcGxlbWVudGF0aW9uLiBJdHMgcHVycG9zZVxuICAvLyBpcyB0byBkZXRlY3Qgd2hldGhlciBzb21ldGhpbmcgbWlnaHQgaGF2ZSBjYWxsZWQgc2V0U3RhdGUgaW5zaWRlXG4gIC8vIGBjb21wb25lbnREaWRDYXRjaGAuIFRoZSBtZWNoYW5pc20gaXMga25vd24gdG8gYmUgZmxhd2VkIGJlY2F1c2UgYHNldFN0YXRlYFxuICAvLyBpbnNpZGUgYGNvbXBvbmVudERpZENhdGNoYCBpcyBpdHNlbGYgZmxhd2VkIOKAlCB0aGF0J3Mgd2h5IHdlIHJlY29tbWVuZFxuICAvLyBgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yYCBpbnN0ZWFkLiBIb3dldmVyLCBpdCBjb3VsZCBiZSBpbXByb3ZlZCBieVxuICAvLyBjaGVja2luZyBpZiByZW1haW5pbmdMYW5lcyBpbmNsdWRlcyBTeW5jIHdvcmssIGluc3RlYWQgb2Ygd2hldGhlciB0aGVyZSdzXG4gIC8vIGFueSB3b3JrIHJlbWFpbmluZyBhdCBhbGwgKHdoaWNoIHdvdWxkIGFsc28gaW5jbHVkZSBzdHVmZiBsaWtlIFN1c3BlbnNlXG4gIC8vIHJldHJpZXMgb3IgdHJhbnNpdGlvbnMpLiBJdCdzIGJlZW4gbGlrZSB0aGlzIGZvciBhIHdoaWxlLCB0aG91Z2gsIHNvIGZpeGluZ1xuICAvLyBpdCBwcm9iYWJseSBpc24ndCB0aGF0IHVyZ2VudC5cblxuICBpZiAocmVtYWluaW5nTGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAvLyBJZiB0aGVyZSdzIG5vIHJlbWFpbmluZyB3b3JrLCB3ZSBjYW4gY2xlYXIgdGhlIHNldCBvZiBhbHJlYWR5IGZhaWxlZFxuICAgIC8vIGVycm9yIGJvdW5kYXJpZXMuXG4gICAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICghcm9vdERpZEhhdmVQYXNzaXZlRWZmZWN0cykge1xuICAgICAgY29tbWl0RG91YmxlSW52b2tlRWZmZWN0c0luREVWKHJvb3QpO1xuICAgIH1cbiAgfVxuXG4gIG9uQ29tbWl0Um9vdCQxKGZpbmlzaGVkV29yay5zdGF0ZU5vZGUsIHJlbmRlclByaW9yaXR5TGV2ZWwpO1xuXG4gIHtcbiAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgIHJvb3QubWVtb2l6ZWRVcGRhdGVycy5jbGVhcigpO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICBvbkNvbW1pdFJvb3QoKTtcbiAgfSAvLyBBbHdheXMgY2FsbCB0aGlzIGJlZm9yZSBleGl0aW5nIGBjb21taXRSb290YCwgdG8gZW5zdXJlIHRoYXQgYW55XG4gIC8vIGFkZGl0aW9uYWwgd29yayBvbiB0aGlzIHJvb3QgaXMgc2NoZWR1bGVkLlxuXG5cbiAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuXG4gIGlmIChyZWNvdmVyYWJsZUVycm9ycyAhPT0gbnVsbCkge1xuICAgIC8vIFRoZXJlIHdlcmUgZXJyb3JzIGR1cmluZyB0aGlzIHJlbmRlciwgYnV0IHJlY292ZXJlZCBmcm9tIHRoZW0gd2l0aG91dFxuICAgIC8vIG5lZWRpbmcgdG8gc3VyZmFjZSBpdCB0byB0aGUgVUkuIFdlIGxvZyB0aGVtIGhlcmUuXG4gICAgdmFyIG9uUmVjb3ZlcmFibGVFcnJvciA9IHJvb3Qub25SZWNvdmVyYWJsZUVycm9yO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZWNvdmVyYWJsZUVycm9ycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHJlY292ZXJhYmxlRXJyb3IgPSByZWNvdmVyYWJsZUVycm9yc1tpXTtcbiAgICAgIHZhciBlcnJvckluZm8gPSBtYWtlRXJyb3JJbmZvKHJlY292ZXJhYmxlRXJyb3Iuc3RhY2spO1xuICAgICAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihyZWNvdmVyYWJsZUVycm9yLnNvdXJjZSk7XG4gICAgICBvblJlY292ZXJhYmxlRXJyb3IocmVjb3ZlcmFibGVFcnJvci52YWx1ZSwgZXJyb3JJbmZvKTtcbiAgICAgIHJlc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVigpO1xuICAgIH1cbiAgfSAvLyBJZiB0aGUgcGFzc2l2ZSBlZmZlY3RzIGFyZSB0aGUgcmVzdWx0IG9mIGEgZGlzY3JldGUgcmVuZGVyLCBmbHVzaCB0aGVtXG4gIC8vIHN5bmNocm9ub3VzbHkgYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCB0YXNrIHNvIHRoYXQgdGhlIHJlc3VsdCBpc1xuICAvLyBpbW1lZGlhdGVseSBvYnNlcnZhYmxlLiBPdGhlcndpc2UsIHdlIGFzc3VtZSB0aGF0IHRoZXkgYXJlIG5vdFxuICAvLyBvcmRlci1kZXBlbmRlbnQgYW5kIGRvIG5vdCBuZWVkIHRvIGJlIG9ic2VydmVkIGJ5IGV4dGVybmFsIHN5c3RlbXMsIHNvIHdlXG4gIC8vIGNhbiB3YWl0IHVudGlsIGFmdGVyIHBhaW50LlxuICAvLyBUT0RPOiBXZSBjYW4gb3B0aW1pemUgdGhpcyBieSBub3Qgc2NoZWR1bGluZyB0aGUgY2FsbGJhY2sgZWFybGllci4gU2luY2Ugd2VcbiAgLy8gY3VycmVudGx5IHNjaGVkdWxlIHRoZSBjYWxsYmFjayBpbiBtdWx0aXBsZSBwbGFjZXMsIHdpbGwgd2FpdCB1bnRpbCB0aG9zZVxuICAvLyBhcmUgY29uc29saWRhdGVkLlxuXG5cbiAgaWYgKGluY2x1ZGVzU3luY0xhbmUocGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMpICYmIChkaXNhYmxlTGVnYWN5TW9kZSApKSB7XG4gICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICB9IC8vIFJlYWQgdGhpcyBhZ2Fpbiwgc2luY2UgYSBwYXNzaXZlIGVmZmVjdCBtaWdodCBoYXZlIHVwZGF0ZWQgaXRcblxuXG4gIHJlbWFpbmluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7IC8vIENoZWNrIGlmIHRoaXMgcmVuZGVyIHNjaGVkdWxlZCBhIGNhc2NhZGluZyBzeW5jaHJvbm91cyB1cGRhdGUuIFRoaXMgaXMgYVxuICAvLyBoZXVyc3RpYyB0byBkZXRlY3QgaW5maW5pdGUgdXBkYXRlIGxvb3BzLiBXZSBhcmUgaW50ZW50aW9uYWxseSBleGNsdWRpbmdcbiAgLy8gaHlkcmF0aW9uIGxhbmVzIGluIHRoaXMgY2hlY2ssIGJlY2F1c2UgcmVuZGVyIHRyaWdnZXJlZCBieSBzZWxlY3RpdmVcbiAgLy8gaHlkcmF0aW9uIGlzIGNvbmNlcHR1YWxseSBub3QgYW4gdXBkYXRlLlxuXG4gIGlmICggLy8gQ2hlY2sgaWYgdGhlcmUgd2FzIGEgcmVjdXJzaXZlIHVwZGF0ZSBzcGF3bmVkIGJ5IHRoaXMgcmVuZGVyLCBpbiBlaXRoZXJcbiAgLy8gdGhlIHJlbmRlciBwaGFzZSBvciB0aGUgY29tbWl0IHBoYXNlLiBXZSB0cmFjayB0aGVzZSBleHBsaWNpdGx5IGJlY2F1c2VcbiAgLy8gd2UgY2FuJ3QgaW5mZXIgZnJvbSB0aGUgcmVtYWluaW5nIGxhbmVzIGFsb25lLlxuICAoZGlkSW5jbHVkZVJlbmRlclBoYXNlVXBkYXRlIHx8IGRpZEluY2x1ZGVDb21taXRQaGFzZVVwZGF0ZSkgfHwgLy8gV2FzIHRoZSBmaW5pc2hlZCByZW5kZXIgdGhlIHJlc3VsdCBvZiBhbiB1cGRhdGUgKG5vdCBoeWRyYXRpb24pP1xuICBpbmNsdWRlc1NvbWVMYW5lKGxhbmVzLCBVcGRhdGVMYW5lcykgJiYgLy8gRGlkIGl0IHNjaGVkdWxlIGEgc3luYyB1cGRhdGU/XG4gIGluY2x1ZGVzU29tZUxhbmUocmVtYWluaW5nTGFuZXMsIFN5bmNVcGRhdGVMYW5lcykpIHtcbiAgICB7XG4gICAgICBtYXJrTmVzdGVkVXBkYXRlU2NoZWR1bGVkKCk7XG4gICAgfSAvLyBDb3VudCB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSByb290IHN5bmNocm9ub3VzbHkgcmUtcmVuZGVycyB3aXRob3V0XG4gICAgLy8gZmluaXNoaW5nLiBJZiB0aGVyZSBhcmUgdG9vIG1hbnksIGl0IGluZGljYXRlcyBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcC5cblxuXG4gICAgaWYgKHJvb3QgPT09IHJvb3RXaXRoTmVzdGVkVXBkYXRlcykge1xuICAgICAgbmVzdGVkVXBkYXRlQ291bnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICAgICAgcm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gcm9vdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICB9IC8vIElmIGxheW91dCB3b3JrIHdhcyBzY2hlZHVsZWQsIGZsdXNoIGl0IG5vdy5cblxuXG4gIGZsdXNoU3luY1dvcmtPbkFsbFJvb3RzKCk7XG5cbiAge1xuICAgIG1hcmtDb21taXRTdG9wcGVkKCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gbWFrZUVycm9ySW5mbyhjb21wb25lbnRTdGFjaykge1xuICB2YXIgZXJyb3JJbmZvID0ge1xuICAgIGNvbXBvbmVudFN0YWNrOiBjb21wb25lbnRTdGFja1xuICB9O1xuXG4gIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXJyb3JJbmZvLCAnZGlnZXN0Jywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVycm9yKCdZb3UgYXJlIGFjY2Vzc2luZyBcImRpZ2VzdFwiIGZyb20gdGhlIGVycm9ySW5mbyBvYmplY3QgcGFzc2VkIHRvIG9uUmVjb3ZlcmFibGVFcnJvci4nICsgJyBUaGlzIHByb3BlcnR5IGlzIG5vIGxvbmdlciBwcm92aWRlZCBhcyBwYXJ0IG9mIGVycm9ySW5mbyBidXQgY2FuIGJlIGFjY2Vzc2VkIGFzIGEgcHJvcGVydHknICsgJyBvZiB0aGUgRXJyb3IgaW5zdGFuY2UgaXRzZWxmLicpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIGVycm9ySW5mbztcbn1cblxuZnVuY3Rpb24gcmVsZWFzZVJvb3RQb29sZWRDYWNoZShyb290LCByZW1haW5pbmdMYW5lcykge1xuICB7XG4gICAgdmFyIHBvb2xlZENhY2hlTGFuZXMgPSByb290LnBvb2xlZENhY2hlTGFuZXMgJj0gcmVtYWluaW5nTGFuZXM7XG5cbiAgICBpZiAocG9vbGVkQ2FjaGVMYW5lcyA9PT0gTm9MYW5lcykge1xuICAgICAgLy8gTm9uZSBvZiB0aGUgcmVtYWluaW5nIHdvcmsgcmVsaWVzIG9uIHRoZSBjYWNoZSBwb29sLiBDbGVhciBpdCBzb1xuICAgICAgLy8gc3Vic2VxdWVudCByZXF1ZXN0cyBnZXQgYSBuZXcgY2FjaGVcbiAgICAgIHZhciBwb29sZWRDYWNoZSA9IHJvb3QucG9vbGVkQ2FjaGU7XG5cbiAgICAgIGlmIChwb29sZWRDYWNoZSAhPSBudWxsKSB7XG4gICAgICAgIHJvb3QucG9vbGVkQ2FjaGUgPSBudWxsO1xuICAgICAgICByZWxlYXNlQ2FjaGUocG9vbGVkQ2FjaGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaFBhc3NpdmVFZmZlY3RzKCkge1xuICAvLyBSZXR1cm5zIHdoZXRoZXIgcGFzc2l2ZSBlZmZlY3RzIHdlcmUgZmx1c2hlZC5cbiAgLy8gVE9ETzogQ29tYmluZSB0aGlzIGNoZWNrIHdpdGggdGhlIG9uZSBpbiBmbHVzaFBhc3NpdmVFRmZlY3RzSW1wbC4gV2Ugc2hvdWxkXG4gIC8vIHByb2JhYmx5IGp1c3QgY29tYmluZSB0aGUgdHdvIGZ1bmN0aW9ucy4gSSBiZWxpZXZlIHRoZXkgd2VyZSBvbmx5IHNlcGFyYXRlXG4gIC8vIGluIHRoZSBmaXJzdCBwbGFjZSBiZWNhdXNlIHdlIHVzZWQgdG8gd3JhcCBpdCB3aXRoXG4gIC8vIGBTY2hlZHVsZXIucnVuV2l0aFByaW9yaXR5YCwgd2hpY2ggYWNjZXB0cyBhIGZ1bmN0aW9uLiBCdXQgbm93IHdlIHRyYWNrIHRoZVxuICAvLyBwcmlvcml0eSB3aXRoaW4gUmVhY3QgaXRzZWxmLCBzbyB3ZSBjYW4gbXV0YXRlIHRoZSB2YXJpYWJsZSBkaXJlY3RseS5cbiAgaWYgKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzICE9PSBudWxsKSB7XG4gICAgLy8gQ2FjaGUgdGhlIHJvb3Qgc2luY2Ugcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgaXMgY2xlYXJlZCBpblxuICAgIC8vIGZsdXNoUGFzc2l2ZUVmZmVjdHNJbXBsXG4gICAgdmFyIHJvb3QgPSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0czsgLy8gQ2FjaGUgYW5kIGNsZWFyIHRoZSByZW1haW5pbmcgbGFuZXMgZmxhZzsgaXQgbXVzdCBiZSByZXNldCBzaW5jZSB0aGlzXG4gICAgLy8gbWV0aG9kIGNhbiBiZSBjYWxsZWQgZnJvbSB2YXJpb3VzIHBsYWNlcywgbm90IGFsd2F5cyBmcm9tIGNvbW1pdFJvb3RcbiAgICAvLyB3aGVyZSB0aGUgcmVtYWluaW5nIGxhbmVzIGFyZSBrbm93blxuXG4gICAgdmFyIHJlbWFpbmluZ0xhbmVzID0gcGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVtYWluaW5nTGFuZXM7XG4gICAgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVtYWluaW5nTGFuZXMgPSBOb0xhbmVzO1xuICAgIHZhciByZW5kZXJQcmlvcml0eSA9IGxhbmVzVG9FdmVudFByaW9yaXR5KHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzKTtcbiAgICB2YXIgcHJpb3JpdHkgPSBsb3dlckV2ZW50UHJpb3JpdHkoRGVmYXVsdEV2ZW50UHJpb3JpdHksIHJlbmRlclByaW9yaXR5KTtcbiAgICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5UO1xuICAgIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cbiAgICB0cnkge1xuICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByaW9yaXR5KTtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsO1xuICAgICAgcmV0dXJuIGZsdXNoUGFzc2l2ZUVmZmVjdHNJbXBsKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KTtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbjsgLy8gT25jZSBwYXNzaXZlIGVmZmVjdHMgaGF2ZSBydW4gZm9yIHRoZSB0cmVlIC0gZ2l2aW5nIGNvbXBvbmVudHMgYVxuICAgICAgLy8gY2hhbmNlIHRvIHJldGFpbiBjYWNoZSBpbnN0YW5jZXMgdGhleSB1c2UgLSByZWxlYXNlIHRoZSBwb29sZWRcbiAgICAgIC8vIGNhY2hlIGF0IHRoZSByb290IChpZiB0aGVyZSBpcyBvbmUpXG5cbiAgICAgIHJlbGVhc2VSb290UG9vbGVkQ2FjaGUocm9vdCwgcmVtYWluaW5nTGFuZXMpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGVucXVldWVQZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0KGZpYmVyKSB7XG4gIHtcbiAgICBwZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0cy5wdXNoKGZpYmVyKTtcblxuICAgIGlmICghcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAgIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gdHJ1ZTtcbiAgICAgIHNjaGVkdWxlQ2FsbGJhY2soTm9ybWFsUHJpb3JpdHkkMSwgZnVuY3Rpb24gKCkge1xuICAgICAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoUGFzc2l2ZUVmZmVjdHNJbXBsKCkge1xuICBpZiAocm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gQ2FjaGUgYW5kIGNsZWFyIHRoZSB0cmFuc2l0aW9ucyBmbGFnXG5cblxuICB2YXIgdHJhbnNpdGlvbnMgPSBwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zO1xuICBwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zID0gbnVsbDtcbiAgdmFyIHJvb3QgPSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cztcbiAgdmFyIGxhbmVzID0gcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXM7XG4gIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gbnVsbDsgLy8gVE9ETzogVGhpcyBpcyBzb21ldGltZXMgb3V0IG9mIHN5bmMgd2l0aCByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cy5cbiAgLy8gRmlndXJlIG91dCB3aHkgYW5kIGZpeCBpdC4gSXQncyBub3QgY2F1c2luZyBhbnkga25vd24gaXNzdWVzIChwcm9iYWJseVxuICAvLyBiZWNhdXNlIGl0J3Mgb25seSB1c2VkIGZvciBwcm9maWxpbmcpLCBidXQgaXQncyBhIHJlZmFjdG9yIGhhemFyZC5cblxuICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyA9IE5vTGFuZXM7XG5cbiAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGZsdXNoIHBhc3NpdmUgZWZmZWN0cyB3aGlsZSBhbHJlYWR5IHJlbmRlcmluZy4nKTtcbiAgfVxuXG4gIHtcbiAgICBpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMgPSB0cnVlO1xuICAgIGRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHMgPSBmYWxzZTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrUGFzc2l2ZUVmZmVjdHNTdGFydGVkKGxhbmVzKTtcbiAgfVxuXG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gQ29tbWl0Q29udGV4dDtcbiAgY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzKHJvb3QuY3VycmVudCk7XG4gIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHMocm9vdCwgcm9vdC5jdXJyZW50LCBsYW5lcywgdHJhbnNpdGlvbnMpOyAvLyBUT0RPOiBNb3ZlIHRvIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNcblxuICB7XG4gICAgdmFyIHByb2ZpbGVyRWZmZWN0cyA9IHBlbmRpbmdQYXNzaXZlUHJvZmlsZXJFZmZlY3RzO1xuICAgIHBlbmRpbmdQYXNzaXZlUHJvZmlsZXJFZmZlY3RzID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb2ZpbGVyRWZmZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGZpYmVyID0gcHJvZmlsZXJFZmZlY3RzW2ldO1xuICAgICAgY29tbWl0UGFzc2l2ZUVmZmVjdER1cmF0aW9ucyhyb290LCBmaWJlcik7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIG1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQoKTtcbiAgfVxuXG4gIHtcbiAgICBjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocm9vdCk7XG4gIH1cblxuICBleGVjdXRpb25Db250ZXh0ID0gcHJldkV4ZWN1dGlvbkNvbnRleHQ7XG4gIGZsdXNoU3luY1dvcmtPbkFsbFJvb3RzKCk7XG5cbiAge1xuICAgIC8vIElmIGFkZGl0aW9uYWwgcGFzc2l2ZSBlZmZlY3RzIHdlcmUgc2NoZWR1bGVkLCBpbmNyZW1lbnQgYSBjb3VudGVyLiBJZiB0aGlzXG4gICAgLy8gZXhjZWVkcyB0aGUgbGltaXQsIHdlJ2xsIGZpcmUgYSB3YXJuaW5nLlxuICAgIGlmIChkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzKSB7XG4gICAgICBpZiAocm9vdCA9PT0gcm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcykge1xuICAgICAgICBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDA7XG4gICAgICAgIHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMgPSByb290O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSAwO1xuICAgIH1cblxuICAgIGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xuICAgIGRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHMgPSBmYWxzZTtcbiAgfSAvLyBUT0RPOiBNb3ZlIHRvIGNvbW1pdFBhc3NpdmVNb3VudEVmZmVjdHNcblxuXG4gIG9uUG9zdENvbW1pdFJvb3Qocm9vdCk7XG5cbiAge1xuICAgIHZhciBzdGF0ZU5vZGUgPSByb290LmN1cnJlbnQuc3RhdGVOb2RlO1xuICAgIHN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgc3RhdGVOb2RlLnBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IDA7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeShpbnN0YW5jZSkge1xuICByZXR1cm4gbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgIT09IG51bGwgJiYgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQuaGFzKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIG1hcmtMZWdhY3lFcnJvckJvdW5kYXJ5QXNGYWlsZWQoaW5zdGFuY2UpIHtcbiAgaWYgKGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkID09PSBudWxsKSB7XG4gICAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPSBuZXcgU2V0KFtpbnN0YW5jZV0pO1xuICB9IGVsc2Uge1xuICAgIGxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkLmFkZChpbnN0YW5jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3Qocm9vdEZpYmVyLCBzb3VyY2VGaWJlciwgZXJyb3IpIHtcbiAgdmFyIGVycm9ySW5mbyA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKGVycm9yLCBzb3VyY2VGaWJlcik7XG4gIHZhciB1cGRhdGUgPSBjcmVhdGVSb290RXJyb3JVcGRhdGUocm9vdEZpYmVyLnN0YXRlTm9kZSwgZXJyb3JJbmZvLCBTeW5jTGFuZSk7XG4gIHZhciByb290ID0gZW5xdWV1ZVVwZGF0ZShyb290RmliZXIsIHVwZGF0ZSwgU3luY0xhbmUpO1xuXG4gIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgbWFya1Jvb3RVcGRhdGVkKHJvb3QsIFN5bmNMYW5lKTtcbiAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3Ioc291cmNlRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yJDEpIHtcbiAge1xuICAgIHNldElzUnVubmluZ0luc2VydGlvbkVmZmVjdChmYWxzZSk7XG4gIH1cblxuICBpZiAoc291cmNlRmliZXIudGFnID09PSBIb3N0Um9vdCkge1xuICAgIC8vIEVycm9yIHdhcyB0aHJvd24gYXQgdGhlIHJvb3QuIFRoZXJlIGlzIG5vIHBhcmVudCwgc28gdGhlIHJvb3RcbiAgICAvLyBpdHNlbGYgc2hvdWxkIGNhcHR1cmUgaXQuXG4gICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3JPblJvb3Qoc291cmNlRmliZXIsIHNvdXJjZUZpYmVyLCBlcnJvciQxKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZmliZXIgPSBuZWFyZXN0TW91bnRlZEFuY2VzdG9yO1xuXG4gIHdoaWxlIChmaWJlciAhPT0gbnVsbCkge1xuICAgIGlmIChmaWJlci50YWcgPT09IEhvc3RSb290KSB7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChmaWJlciwgc291cmNlRmliZXIsIGVycm9yJDEpO1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgdmFyIGN0b3IgPSBmaWJlci50eXBlO1xuICAgICAgdmFyIGluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRDYXRjaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeShpbnN0YW5jZSkpIHtcbiAgICAgICAgdmFyIGVycm9ySW5mbyA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKGVycm9yJDEsIHNvdXJjZUZpYmVyKTtcbiAgICAgICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUoU3luY0xhbmUpO1xuICAgICAgICB2YXIgcm9vdCA9IGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSwgU3luY0xhbmUpO1xuXG4gICAgICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICAgICAgaW5pdGlhbGl6ZUNsYXNzRXJyb3JVcGRhdGUodXBkYXRlLCByb290LCBmaWJlciwgZXJyb3JJbmZvKTtcbiAgICAgICAgICBtYXJrUm9vdFVwZGF0ZWQocm9vdCwgU3luY0xhbmUpO1xuICAgICAgICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmaWJlciA9IGZpYmVyLnJldHVybjtcbiAgfVxuXG4gIHtcbiAgICBlcnJvcignSW50ZXJuYWwgUmVhY3QgZXJyb3I6IEF0dGVtcHRlZCB0byBjYXB0dXJlIGEgY29tbWl0IHBoYXNlIGVycm9yICcgKyAnaW5zaWRlIGEgZGV0YWNoZWQgdHJlZS4gVGhpcyBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QuIFBvdGVudGlhbCAnICsgJ2NhdXNlcyBpbmNsdWRlIGRlbGV0aW5nIHRoZSBzYW1lIGZpYmVyIG1vcmUgdGhhbiBvbmNlLCBjb21taXR0aW5nIGFuICcgKyAnYWxyZWFkeS1maW5pc2hlZCB0cmVlLCBvciBhbiBpbmNvbnNpc3RlbnQgcmV0dXJuIHBvaW50ZXIuXFxuXFxuJyArICdFcnJvciBtZXNzYWdlOlxcblxcbiVzJywgZXJyb3IkMSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB3YWtlYWJsZSwgbGFuZXMpIHtcbiAgLy8gQXR0YWNoIGEgcGluZyBsaXN0ZW5lclxuICAvL1xuICAvLyBUaGUgZGF0YSBtaWdodCByZXNvbHZlIGJlZm9yZSB3ZSBoYXZlIGEgY2hhbmNlIHRvIGNvbW1pdCB0aGUgZmFsbGJhY2suIE9yLFxuICAvLyBpbiB0aGUgY2FzZSBvZiBhIHJlZnJlc2gsIHdlJ2xsIG5ldmVyIGNvbW1pdCBhIGZhbGxiYWNrLiBTbyB3ZSBuZWVkIHRvXG4gIC8vIGF0dGFjaCBhIGxpc3RlbmVyIG5vdy4gV2hlbiBpdCByZXNvbHZlcyAoXCJwaW5nc1wiKSwgd2UgY2FuIGRlY2lkZSB3aGV0aGVyIHRvXG4gIC8vIHRyeSByZW5kZXJpbmcgdGhlIHRyZWUgYWdhaW4uXG4gIC8vXG4gIC8vIE9ubHkgYXR0YWNoIGEgbGlzdGVuZXIgaWYgb25lIGRvZXMgbm90IGFscmVhZHkgZXhpc3QgZm9yIHRoZSBsYW5lc1xuICAvLyB3ZSdyZSBjdXJyZW50bHkgcmVuZGVyaW5nICh3aGljaCBhY3RzIGxpa2UgYSBcInRocmVhZCBJRFwiIGhlcmUpLlxuICAvL1xuICAvLyBXZSBvbmx5IG5lZWQgdG8gZG8gdGhpcyBpbiBjb25jdXJyZW50IG1vZGUuIExlZ2FjeSBTdXNwZW5zZSBhbHdheXNcbiAgLy8gY29tbWl0cyBmYWxsYmFja3Mgc3luY2hyb25vdXNseSwgc28gdGhlcmUgYXJlIG5vIHBpbmdzLlxuICB2YXIgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGU7XG4gIHZhciB0aHJlYWRJRHM7XG5cbiAgaWYgKHBpbmdDYWNoZSA9PT0gbnVsbCkge1xuICAgIHBpbmdDYWNoZSA9IHJvb3QucGluZ0NhY2hlID0gbmV3IFBvc3NpYmx5V2Vha01hcCgpO1xuICAgIHRocmVhZElEcyA9IG5ldyBTZXQoKTtcbiAgICBwaW5nQ2FjaGUuc2V0KHdha2VhYmxlLCB0aHJlYWRJRHMpO1xuICB9IGVsc2Uge1xuICAgIHRocmVhZElEcyA9IHBpbmdDYWNoZS5nZXQod2FrZWFibGUpO1xuXG4gICAgaWYgKHRocmVhZElEcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJlYWRJRHMgPSBuZXcgU2V0KCk7XG4gICAgICBwaW5nQ2FjaGUuc2V0KHdha2VhYmxlLCB0aHJlYWRJRHMpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghdGhyZWFkSURzLmhhcyhsYW5lcykpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRBdHRhY2hQaW5nTGlzdGVuZXIgPSB0cnVlOyAvLyBNZW1vaXplIHVzaW5nIHRoZSB0aHJlYWQgSUQgdG8gcHJldmVudCByZWR1bmRhbnQgbGlzdGVuZXJzLlxuXG4gICAgdGhyZWFkSURzLmFkZChsYW5lcyk7XG4gICAgdmFyIHBpbmcgPSBwaW5nU3VzcGVuZGVkUm9vdC5iaW5kKG51bGwsIHJvb3QsIHdha2VhYmxlLCBsYW5lcyk7XG5cbiAgICB7XG4gICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBwZW5kaW5nIHdvcmsgc3RpbGwsIHJlc3RvcmUgdGhlIG9yaWdpbmFsIHVwZGF0ZXJzXG4gICAgICAgIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMocm9vdCwgbGFuZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHdha2VhYmxlLnRoZW4ocGluZywgcGluZyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGluZ1N1c3BlbmRlZFJvb3Qocm9vdCwgd2FrZWFibGUsIHBpbmdlZExhbmVzKSB7XG4gIHZhciBwaW5nQ2FjaGUgPSByb290LnBpbmdDYWNoZTtcblxuICBpZiAocGluZ0NhY2hlICE9PSBudWxsKSB7XG4gICAgLy8gVGhlIHdha2VhYmxlIHJlc29sdmVkLCBzbyB3ZSBubyBsb25nZXIgbmVlZCB0byBtZW1vaXplLCBiZWNhdXNlIGl0IHdpbGxcbiAgICAvLyBuZXZlciBiZSB0aHJvd24gYWdhaW4uXG4gICAgcGluZ0NhY2hlLmRlbGV0ZSh3YWtlYWJsZSk7XG4gIH1cblxuICBtYXJrUm9vdFBpbmdlZChyb290LCBwaW5nZWRMYW5lcyk7XG4gIHdhcm5JZlN1c3BlbnNlUmVzb2x1dGlvbk5vdFdyYXBwZWRXaXRoQWN0REVWKCk7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdCA9PT0gcm9vdCAmJiBpc1N1YnNldE9mTGFuZXMod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMsIHBpbmdlZExhbmVzKSkge1xuICAgIC8vIFJlY2VpdmVkIGEgcGluZyBhdCB0aGUgc2FtZSBwcmlvcml0eSBsZXZlbCBhdCB3aGljaCB3ZSdyZSBjdXJyZW50bHlcbiAgICAvLyByZW5kZXJpbmcuIFdlIG1pZ2h0IHdhbnQgdG8gcmVzdGFydCB0aGlzIHJlbmRlci4gVGhpcyBzaG91bGQgbWlycm9yXG4gICAgLy8gdGhlIGxvZ2ljIG9mIHdoZXRoZXIgb3Igbm90IGEgcm9vdCBzdXNwZW5kcyBvbmNlIGl0IGNvbXBsZXRlcy5cbiAgICAvLyBUT0RPOiBJZiB3ZSdyZSByZW5kZXJpbmcgc3luYyBlaXRoZXIgZHVlIHRvIFN5bmMsIEJhdGNoZWQgb3IgZXhwaXJlZCxcbiAgICAvLyB3ZSBzaG91bGQgcHJvYmFibHkgbmV2ZXIgcmVzdGFydC5cbiAgICAvLyBJZiB3ZSdyZSBzdXNwZW5kZWQgd2l0aCBkZWxheSwgb3IgaWYgaXQncyBhIHJldHJ5LCB3ZSdsbCBhbHdheXMgc3VzcGVuZFxuICAgIC8vIHNvIHdlIGNhbiBhbHdheXMgcmVzdGFydC5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdFN1c3BlbmRlZFdpdGhEZWxheSB8fCB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkICYmIGluY2x1ZGVzT25seVJldHJpZXMod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpICYmIG5vdyQxKCkgLSBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lIDwgRkFMTEJBQ0tfVEhST1RUTEVfTVMpIHtcbiAgICAgIC8vIEZvcmNlIGEgcmVzdGFydCBmcm9tIHRoZSByb290IGJ5IHVud2luZGluZyB0aGUgc3RhY2suIFVubGVzcyB0aGlzIGlzXG4gICAgICAvLyBiZWluZyBjYWxsZWQgZnJvbSB0aGUgcmVuZGVyIHBoYXNlLCBiZWNhdXNlIHRoYXQgd291bGQgY2F1c2UgYSBjcmFzaC5cbiAgICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpID09PSBOb0NvbnRleHQpIHtcbiAgICAgICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgTm9MYW5lcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEV2ZW4gdGhvdWdoIHdlIGNhbid0IHJlc3RhcnQgcmlnaHQgbm93LCB3ZSBtaWdodCBnZXQgYW5cbiAgICAgIC8vIG9wcG9ydHVuaXR5IGxhdGVyLiBTbyB3ZSBtYXJrIHRoaXMgcmVuZGVyIGFzIGhhdmluZyBhIHBpbmcuXG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyA9IG1lcmdlTGFuZXMod29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMsIHBpbmdlZExhbmVzKTtcbiAgICB9XG4gIH1cblxuICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG59XG5cbmZ1bmN0aW9uIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpIHtcbiAgLy8gVGhlIGJvdW5kYXJ5IGZpYmVyIChhIFN1c3BlbnNlIGNvbXBvbmVudCBvciBTdXNwZW5zZUxpc3QgY29tcG9uZW50KVxuICAvLyBwcmV2aW91c2x5IHdhcyByZW5kZXJlZCBpbiBpdHMgZmFsbGJhY2sgc3RhdGUuIE9uZSBvZiB0aGUgcHJvbWlzZXMgdGhhdFxuICAvLyBzdXNwZW5kZWQgaXQgaGFzIHJlc29sdmVkLCB3aGljaCBtZWFucyBhdCBsZWFzdCBwYXJ0IG9mIHRoZSB0cmVlIHdhc1xuICAvLyBsaWtlbHkgdW5ibG9ja2VkLiBUcnkgcmVuZGVyaW5nIGFnYWluLCBhdCBhIG5ldyBsYW5lcy5cbiAgaWYgKHJldHJ5TGFuZSA9PT0gTm9MYW5lKSB7XG4gICAgLy8gVE9ETzogQXNzaWduIHRoaXMgdG8gYHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lYD8gdG8gYXZvaWRcbiAgICAvLyB1bm5lY2Vzc2FyeSBlbnRhbmdsZW1lbnQ/XG4gICAgcmV0cnlMYW5lID0gcmVxdWVzdFJldHJ5TGFuZSgpO1xuICB9IC8vIFRPRE86IFNwZWNpYWwgY2FzZSBpZGxlIHByaW9yaXR5P1xuXG5cbiAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoYm91bmRhcnlGaWJlciwgcmV0cnlMYW5lKTtcblxuICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgIG1hcmtSb290VXBkYXRlZChyb290LCByZXRyeUxhbmUpO1xuICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXRyeURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIpIHtcbiAgdmFyIHN1c3BlbnNlU3RhdGUgPSBib3VuZGFyeUZpYmVyLm1lbW9pemVkU3RhdGU7XG4gIHZhciByZXRyeUxhbmUgPSBOb0xhbmU7XG5cbiAgaWYgKHN1c3BlbnNlU3RhdGUgIT09IG51bGwpIHtcbiAgICByZXRyeUxhbmUgPSBzdXNwZW5zZVN0YXRlLnJldHJ5TGFuZTtcbiAgfVxuXG4gIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xufVxuZnVuY3Rpb24gcmVzb2x2ZVJldHJ5V2FrZWFibGUoYm91bmRhcnlGaWJlciwgd2FrZWFibGUpIHtcbiAgdmFyIHJldHJ5TGFuZSA9IE5vTGFuZTsgLy8gRGVmYXVsdFxuXG4gIHZhciByZXRyeUNhY2hlO1xuXG4gIHN3aXRjaCAoYm91bmRhcnlGaWJlci50YWcpIHtcbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgcmV0cnlDYWNoZSA9IGJvdW5kYXJ5RmliZXIuc3RhdGVOb2RlO1xuICAgICAgdmFyIHN1c3BlbnNlU3RhdGUgPSBib3VuZGFyeUZpYmVyLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgIGlmIChzdXNwZW5zZVN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIHJldHJ5TGFuZSA9IHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgcmV0cnlDYWNoZSA9IGJvdW5kYXJ5RmliZXIuc3RhdGVOb2RlO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gYm91bmRhcnlGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgIHJldHJ5Q2FjaGUgPSBpbnN0YW5jZS5fcmV0cnlDYWNoZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdQaW5nZWQgdW5rbm93biBzdXNwZW5zZSBib3VuZGFyeSB0eXBlLiAnICsgJ1RoaXMgaXMgcHJvYmFibHkgYSBidWcgaW4gUmVhY3QuJyk7XG4gIH1cblxuICBpZiAocmV0cnlDYWNoZSAhPT0gbnVsbCkge1xuICAgIC8vIFRoZSB3YWtlYWJsZSByZXNvbHZlZCwgc28gd2Ugbm8gbG9uZ2VyIG5lZWQgdG8gbWVtb2l6ZSwgYmVjYXVzZSBpdCB3aWxsXG4gICAgLy8gbmV2ZXIgYmUgdGhyb3duIGFnYWluLlxuICAgIHJldHJ5Q2FjaGUuZGVsZXRlKHdha2VhYmxlKTtcbiAgfVxuXG4gIHJldHJ5VGltZWRPdXRCb3VuZGFyeShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xufVxuZnVuY3Rpb24gdGhyb3dJZkluZmluaXRlVXBkYXRlTG9vcERldGVjdGVkKCkge1xuICBpZiAobmVzdGVkVXBkYXRlQ291bnQgPiBORVNURURfVVBEQVRFX0xJTUlUKSB7XG4gICAgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xuICAgIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDA7XG4gICAgcm9vdFdpdGhOZXN0ZWRVcGRhdGVzID0gbnVsbDtcbiAgICByb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzID0gbnVsbDtcblxuICAgIHtcbiAgICAgIGlmIChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCAmJiB3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IG51bGwpIHtcbiAgICAgICAgLy8gV2UncmUgaW4gdGhlIHJlbmRlciBwaGFzZS4gRGlzYWJsZSB0aGUgY29uY3VycmVudCBlcnJvciByZWNvdmVyeVxuICAgICAgICAvLyBtZWNoYW5pc20gdG8gZW5zdXJlIHRoYXQgdGhlIGVycm9yIHdlJ3JlIGFib3V0IHRvIHRocm93IGdldHMgaGFuZGxlZC5cbiAgICAgICAgLy8gV2UgbmVlZCBpdCB0byB0cmlnZ2VyIHRoZSBuZWFyZXN0IGVycm9yIGJvdW5kYXJ5IHNvIHRoYXQgdGhlIGluZmluaXRlXG4gICAgICAgIC8vIHVwZGF0ZSBsb29wIGlzIGJyb2tlbi5cbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290LmVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzID0gbWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzc1Jvb3QuZXJyb3JSZWNvdmVyeURpc2FibGVkTGFuZXMsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ01heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIGNvbXBvbmVudCAnICsgJ3JlcGVhdGVkbHkgY2FsbHMgc2V0U3RhdGUgaW5zaWRlIGNvbXBvbmVudFdpbGxVcGRhdGUgb3IgJyArICdjb21wb25lbnREaWRVcGRhdGUuIFJlYWN0IGxpbWl0cyB0aGUgbnVtYmVyIG9mIG5lc3RlZCB1cGRhdGVzIHRvICcgKyAncHJldmVudCBpbmZpbml0ZSBsb29wcy4nKTtcbiAgfVxuXG4gIHtcbiAgICBpZiAobmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID4gTkVTVEVEX1BBU1NJVkVfVVBEQVRFX0xJTUlUKSB7XG4gICAgICBuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPSAwO1xuICAgICAgcm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcyA9IG51bGw7XG5cbiAgICAgIGVycm9yKCdNYXhpbXVtIHVwZGF0ZSBkZXB0aCBleGNlZWRlZC4gVGhpcyBjYW4gaGFwcGVuIHdoZW4gYSBjb21wb25lbnQgJyArIFwiY2FsbHMgc2V0U3RhdGUgaW5zaWRlIHVzZUVmZmVjdCwgYnV0IHVzZUVmZmVjdCBlaXRoZXIgZG9lc24ndCBcIiArICdoYXZlIGEgZGVwZW5kZW5jeSBhcnJheSwgb3Igb25lIG9mIHRoZSBkZXBlbmRlbmNpZXMgY2hhbmdlcyBvbiAnICsgJ2V2ZXJ5IHJlbmRlci4nKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hSZW5kZXJQaGFzZVN0cmljdE1vZGVXYXJuaW5nc0luREVWKCkge1xuICB7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZygpO1xuICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLmZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZUFuZERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihyb290LCBwYXJlbnRGaWJlciwgaXNJblN0cmljdE1vZGUpIHtcbiAgaWYgKChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiAoUGxhY2VtZW50REVWIHwgVmlzaWJpbGl0eSkpID09PSBOb0ZsYWdzJDEpIHtcbiAgICAvLyBQYXJlbnQncyBkZXNjZW5kYW50cyBoYXZlIGFscmVhZHkgaGFkIGVmZmVjdHMgZG91YmxlIGludm9rZWQuXG4gICAgLy8gRWFybHkgZXhpdCB0byBhdm9pZCB1bm5lY2Vzc2FyeSB0cmVlIHRyYXZlcnNhbC5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgY2hpbGQgPSBwYXJlbnRGaWJlci5jaGlsZDtcblxuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICBkb3VibGVJbnZva2VFZmZlY3RzSW5ERVZJZk5lY2Vzc2FyeShyb290LCBjaGlsZCwgaXNJblN0cmljdE1vZGUpO1xuICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgfVxufSAvLyBVbmNvbmRpdGlvbmFsbHkgZGlzY29ubmVjdHMgYW5kIGNvbm5lY3RzIHBhc3NpdmUgYW5kIGxheW91dCBlZmZlY3RzLlxuXG5cbmZ1bmN0aW9uIGRvdWJsZUludm9rZUVmZmVjdHNPbkZpYmVyKHJvb3QsIGZpYmVyKSB7XG4gIHZhciBzaG91bGREb3VibGVJbnZva2VQYXNzaXZlRWZmZWN0cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogdHJ1ZTtcbiAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7XG4gIGRpc2FwcGVhckxheW91dEVmZmVjdHMoZmliZXIpO1xuXG4gIGlmIChzaG91bGREb3VibGVJbnZva2VQYXNzaXZlRWZmZWN0cykge1xuICAgIGRpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0KGZpYmVyKTtcbiAgfVxuXG4gIHJlYXBwZWFyTGF5b3V0RWZmZWN0cyhyb290LCBmaWJlci5hbHRlcm5hdGUsIGZpYmVyLCBmYWxzZSk7XG5cbiAgaWYgKHNob3VsZERvdWJsZUludm9rZVBhc3NpdmVFZmZlY3RzKSB7XG4gICAgcmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMocm9vdCwgZmliZXIsIE5vTGFuZXMsIG51bGwsIGZhbHNlKTtcbiAgfVxuXG4gIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbn1cblxuZnVuY3Rpb24gZG91YmxlSW52b2tlRWZmZWN0c0luREVWSWZOZWNlc3Nhcnkocm9vdCwgZmliZXIsIHBhcmVudElzSW5TdHJpY3RNb2RlKSB7XG4gIHZhciBpc1N0cmljdE1vZGVGaWJlciA9IGZpYmVyLnR5cGUgPT09IFJFQUNUX1NUUklDVF9NT0RFX1RZUEU7XG4gIHZhciBpc0luU3RyaWN0TW9kZSA9IHBhcmVudElzSW5TdHJpY3RNb2RlIHx8IGlzU3RyaWN0TW9kZUZpYmVyOyAvLyBGaXJzdCBjYXNlOiB0aGUgZmliZXIgKippcyBub3QqKiBvZiB0eXBlIE9mZnNjcmVlbkNvbXBvbmVudC4gTm9cbiAgLy8gc3BlY2lhbCBydWxlcyBhcHBseSB0byBkb3VibGUgaW52b2tpbmcgZWZmZWN0cy5cblxuICBpZiAoZmliZXIudGFnICE9PSBPZmZzY3JlZW5Db21wb25lbnQpIHtcbiAgICBpZiAoZmliZXIuZmxhZ3MgJiBQbGFjZW1lbnRERVYpIHtcbiAgICAgIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoZmliZXIpO1xuXG4gICAgICBpZiAoaXNJblN0cmljdE1vZGUpIHtcbiAgICAgICAgZG91YmxlSW52b2tlRWZmZWN0c09uRmliZXIocm9vdCwgZmliZXIsIChmaWJlci5tb2RlICYgTm9TdHJpY3RQYXNzaXZlRWZmZWN0c01vZGUpID09PSBOb01vZGUpO1xuICAgICAgfVxuXG4gICAgICByZXNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUFuZERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihyb290LCBmaWJlciwgaXNJblN0cmljdE1vZGUpO1xuICAgIH1cblxuICAgIHJldHVybjtcbiAgfSAvLyBTZWNvbmQgY2FzZTogdGhlIGZpYmVyICoqaXMqKiBvZiB0eXBlIE9mZnNjcmVlbkNvbXBvbmVudC5cbiAgLy8gVGhpcyBicmFuY2ggY29udGFpbnMgY2FzZXMgc3BlY2lmaWMgdG8gT2Zmc2NyZWVuLlxuXG5cbiAgaWYgKGZpYmVyLm1lbW9pemVkU3RhdGUgPT09IG51bGwpIHtcbiAgICAvLyBPbmx5IGNvbnNpZGVyIE9mZnNjcmVlbiB0aGF0IGlzIHZpc2libGUuXG4gICAgLy8gVE9ETyAoT2Zmc2NyZWVuKSBIYW5kbGUgbWFudWFsIG1vZGUuXG4gICAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihmaWJlcik7XG5cbiAgICBpZiAoaXNJblN0cmljdE1vZGUgJiYgZmliZXIuZmxhZ3MgJiBWaXNpYmlsaXR5KSB7XG4gICAgICAvLyBEb3VibGUgaW52b2tlIGVmZmVjdHMgb24gT2Zmc2NyZWVuJ3Mgc3VidHJlZSBvbmx5XG4gICAgICAvLyBpZiBpdCBpcyB2aXNpYmxlIGFuZCBpdHMgdmlzaWJpbGl0eSBoYXMgY2hhbmdlZC5cbiAgICAgIGRvdWJsZUludm9rZUVmZmVjdHNPbkZpYmVyKHJvb3QsIGZpYmVyKTtcbiAgICB9IGVsc2UgaWYgKGZpYmVyLnN1YnRyZWVGbGFncyAmIFBsYWNlbWVudERFVikge1xuICAgICAgLy8gU29tZXRoaW5nIGluIHRoZSBzdWJ0cmVlIGNvdWxkIGhhdmUgYmVlbiBzdXNwZW5kZWQuXG4gICAgICAvLyBXZSBuZWVkIHRvIGNvbnRpbnVlIHRyYXZlcnNhbCBhbmQgZmluZCBuZXdseSBpbnNlcnRlZCBmaWJlcnMuXG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlQW5kRG91YmxlSW52b2tlRWZmZWN0c0luREVWKHJvb3QsIGZpYmVyLCBpc0luU3RyaWN0TW9kZSk7XG4gICAgfVxuXG4gICAgcmVzZXRDdXJyZW50RGVidWdGaWJlckluREVWKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0RG91YmxlSW52b2tlRWZmZWN0c0luREVWKHJvb3QsIGhhc1Bhc3NpdmVFZmZlY3RzKSB7XG4gIHtcbiAgICB7XG4gICAgICB2YXIgZG91YmxlSW52b2tlRWZmZWN0cyA9IHRydWU7XG5cbiAgICAgIGlmICghKHJvb3QuY3VycmVudC5tb2RlICYgKFN0cmljdExlZ2FjeU1vZGUgfCBTdHJpY3RFZmZlY3RzTW9kZSkpKSB7XG4gICAgICAgIGRvdWJsZUludm9rZUVmZmVjdHMgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUFuZERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihyb290LCByb290LmN1cnJlbnQsIGRvdWJsZUludm9rZUVmZmVjdHMpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCA9IG51bGw7XG5mdW5jdGlvbiB3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSAhPT0gTm9Db250ZXh0KSB7XG4gICAgICAvLyBXZSBsZXQgdGhlIG90aGVyIHdhcm5pbmcgYWJvdXQgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgZGVhbCB3aXRoIHRoaXMgb25lLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciB0YWcgPSBmaWJlci50YWc7XG5cbiAgICBpZiAodGFnICE9PSBIb3N0Um9vdCAmJiB0YWcgIT09IENsYXNzQ29tcG9uZW50ICYmIHRhZyAhPT0gRnVuY3Rpb25Db21wb25lbnQgJiYgdGFnICE9PSBGb3J3YXJkUmVmICYmIHRhZyAhPT0gTWVtb0NvbXBvbmVudCAmJiB0YWcgIT09IFNpbXBsZU1lbW9Db21wb25lbnQpIHtcbiAgICAgIC8vIE9ubHkgd2FybiBmb3IgdXNlci1kZWZpbmVkIGNvbXBvbmVudHMsIG5vdCBpbnRlcm5hbCBvbmVzIGxpa2UgU3VzcGVuc2UuXG4gICAgICByZXR1cm47XG4gICAgfSAvLyBXZSBzaG93IHRoZSB3aG9sZSBzdGFjayBidXQgZGVkdXBlIG9uIHRoZSB0b3AgY29tcG9uZW50J3MgbmFtZSBiZWNhdXNlXG4gICAgLy8gdGhlIHByb2JsZW1hdGljIGNvZGUgYWxtb3N0IGFsd2F5cyBsaWVzIGluc2lkZSB0aGF0IGNvbXBvbmVudC5cblxuXG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnUmVhY3RDb21wb25lbnQnO1xuXG4gICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQgIT09IG51bGwpIHtcbiAgICAgIGlmIChkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQuYWRkKGNvbXBvbmVudE5hbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50ID0gbmV3IFNldChbY29tcG9uZW50TmFtZV0pO1xuICAgIH1cblxuICAgIHZhciBwcmV2aW91c0ZpYmVyID0gY3VycmVudDtcblxuICAgIHRyeSB7XG4gICAgICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKGZpYmVyKTtcblxuICAgICAgZXJyb3IoXCJDYW4ndCBwZXJmb3JtIGEgUmVhY3Qgc3RhdGUgdXBkYXRlIG9uIGEgY29tcG9uZW50IHRoYXQgaGFzbid0IG1vdW50ZWQgeWV0LiBcIiArICdUaGlzIGluZGljYXRlcyB0aGF0IHlvdSBoYXZlIGEgc2lkZS1lZmZlY3QgaW4geW91ciByZW5kZXIgZnVuY3Rpb24gdGhhdCAnICsgJ2FzeW5jaHJvbm91c2x5IGxhdGVyIGNhbGxzIHRyaWVzIHRvIHVwZGF0ZSB0aGUgY29tcG9uZW50LiBNb3ZlIHRoaXMgd29yayB0byAnICsgJ3VzZUVmZmVjdCBpbnN0ZWFkLicpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAocHJldmlvdXNGaWJlcikge1xuICAgICAgICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKGZpYmVyKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVigpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxudmFyIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyID0gZmFsc2U7XG52YXIgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50O1xuXG57XG4gIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudCA9IG5ldyBTZXQoKTtcbn1cblxuZnVuY3Rpb24gd2FybkFib3V0UmVuZGVyUGhhc2VVcGRhdGVzSW5ERVYoZmliZXIpIHtcbiAge1xuICAgIGlmIChpc1JlbmRlcmluZykge1xuICAgICAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHJlbmRlcmluZ0NvbXBvbmVudE5hbWUgPSB3b3JrSW5Qcm9ncmVzcyAmJiBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHdvcmtJblByb2dyZXNzKSB8fCAnVW5rbm93bic7IC8vIERlZHVwZSBieSB0aGUgcmVuZGVyaW5nIGNvbXBvbmVudCBiZWNhdXNlIGl0J3MgdGhlIG9uZSB0aGF0IG5lZWRzIHRvIGJlIGZpeGVkLlxuXG4gICAgICAgICAgICB2YXIgZGVkdXBlS2V5ID0gcmVuZGVyaW5nQ29tcG9uZW50TmFtZTtcblxuICAgICAgICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQuaGFzKGRlZHVwZUtleSkpIHtcbiAgICAgICAgICAgICAgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50LmFkZChkZWR1cGVLZXkpO1xuICAgICAgICAgICAgICB2YXIgc2V0U3RhdGVDb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ1Vua25vd24nO1xuXG4gICAgICAgICAgICAgIGVycm9yKCdDYW5ub3QgdXBkYXRlIGEgY29tcG9uZW50IChgJXNgKSB3aGlsZSByZW5kZXJpbmcgYSAnICsgJ2RpZmZlcmVudCBjb21wb25lbnQgKGAlc2ApLiBUbyBsb2NhdGUgdGhlIGJhZCBzZXRTdGF0ZSgpIGNhbGwgaW5zaWRlIGAlc2AsICcgKyAnZm9sbG93IHRoZSBzdGFjayB0cmFjZSBhcyBkZXNjcmliZWQgaW4gaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zZXRzdGF0ZS1pbi1yZW5kZXInLCBzZXRTdGF0ZUNvbXBvbmVudE5hbWUsIHJlbmRlcmluZ0NvbXBvbmVudE5hbWUsIHJlbmRlcmluZ0NvbXBvbmVudE5hbWUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyKSB7XG4gICAgICAgICAgICAgIGVycm9yKCdDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uIChzdWNoIGFzICcgKyAnd2l0aGluIGByZW5kZXJgKS4gUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSAnICsgJ2Z1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4nKTtcblxuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlciA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LCBsYW5lcykge1xuICB7XG4gICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICB2YXIgbWVtb2l6ZWRVcGRhdGVycyA9IHJvb3QubWVtb2l6ZWRVcGRhdGVycztcbiAgICAgIG1lbW9pemVkVXBkYXRlcnMuZm9yRWFjaChmdW5jdGlvbiAoc2NoZWR1bGluZ0ZpYmVyKSB7XG4gICAgICAgIGFkZEZpYmVyVG9MYW5lc01hcChyb290LCBzY2hlZHVsaW5nRmliZXIsIGxhbmVzKTtcbiAgICAgIH0pOyAvLyBUaGlzIGZ1bmN0aW9uIGludGVudGlvbmFsbHkgZG9lcyBub3QgY2xlYXIgbWVtb2l6ZWQgdXBkYXRlcnMuXG4gICAgICAvLyBUaG9zZSBtYXkgc3RpbGwgYmUgcmVsZXZhbnQgdG8gdGhlIGN1cnJlbnQgY29tbWl0XG4gICAgICAvLyBhbmQgYSBmdXR1cmUgb25lIChlLmcuIFN1c3BlbnNlKS5cbiAgICB9XG4gIH1cbn1cbnZhciBmYWtlQWN0Q2FsbGJhY2tOb2RlID0ge307IC8vICRGbG93Rml4TWVbbWlzc2luZy1sb2NhbC1hbm5vdF1cblxuZnVuY3Rpb24gc2NoZWR1bGVDYWxsYmFjayhwcmlvcml0eUxldmVsLCBjYWxsYmFjaykge1xuICB7XG4gICAgLy8gSWYgd2UncmUgY3VycmVudGx5IGluc2lkZSBhbiBgYWN0YCBzY29wZSwgYnlwYXNzIFNjaGVkdWxlciBhbmQgcHVzaCB0b1xuICAgIC8vIHRoZSBgYWN0YCBxdWV1ZSBpbnN0ZWFkLlxuICAgIHZhciBhY3RRdWV1ZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlO1xuXG4gICAgaWYgKGFjdFF1ZXVlICE9PSBudWxsKSB7XG4gICAgICBhY3RRdWV1ZS5wdXNoKGNhbGxiYWNrKTtcbiAgICAgIHJldHVybiBmYWtlQWN0Q2FsbGJhY2tOb2RlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc2NoZWR1bGVDYWxsYmFjayQzKHByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkRm9yY2VGbHVzaEZhbGxiYWNrc0luREVWKCkge1xuICAvLyBOZXZlciBmb3JjZSBmbHVzaCBpbiBwcm9kdWN0aW9uLiBUaGlzIGZ1bmN0aW9uIHNob3VsZCBnZXQgc3RyaXBwZWQgb3V0LlxuICByZXR1cm4gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlVwZGF0ZXNOb3RXcmFwcGVkV2l0aEFjdERFVihmaWJlcikge1xuICB7XG4gICAge1xuICAgICAgaWYgKCFpc0NvbmN1cnJlbnRBY3RFbnZpcm9ubWVudCgpKSB7XG4gICAgICAgIC8vIE5vdCBpbiBhbiBhY3QgZW52aXJvbm1lbnQuIE5vIG5lZWQgdG8gd2Fybi5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgdmFyIHByZXZpb3VzRmliZXIgPSBjdXJyZW50O1xuXG4gICAgICB0cnkge1xuICAgICAgICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKGZpYmVyKTtcblxuICAgICAgICBlcnJvcignQW4gdXBkYXRlIHRvICVzIGluc2lkZSBhIHRlc3Qgd2FzIG5vdCB3cmFwcGVkIGluIGFjdCguLi4pLlxcblxcbicgKyAnV2hlbiB0ZXN0aW5nLCBjb2RlIHRoYXQgY2F1c2VzIFJlYWN0IHN0YXRlIHVwZGF0ZXMgc2hvdWxkIGJlICcgKyAnd3JhcHBlZCBpbnRvIGFjdCguLi4pOlxcblxcbicgKyAnYWN0KCgpID0+IHtcXG4nICsgJyAgLyogZmlyZSBldmVudHMgdGhhdCB1cGRhdGUgc3RhdGUgKi9cXG4nICsgJ30pO1xcbicgKyAnLyogYXNzZXJ0IG9uIHRoZSBvdXRwdXQgKi9cXG5cXG4nICsgXCJUaGlzIGVuc3VyZXMgdGhhdCB5b3UncmUgdGVzdGluZyB0aGUgYmVoYXZpb3IgdGhlIHVzZXIgd291bGQgc2VlIFwiICsgJ2luIHRoZSBicm93c2VyLicgKyAnIExlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93cmFwLXRlc3RzLXdpdGgtYWN0JywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHByZXZpb3VzRmliZXIpIHtcbiAgICAgICAgICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKGZpYmVyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB3YXJuSWZTdXNwZW5zZVJlc29sdXRpb25Ob3RXcmFwcGVkV2l0aEFjdERFVihyb290KSB7XG4gIHtcbiAgICBpZiAoaXNDb25jdXJyZW50QWN0RW52aXJvbm1lbnQoKSAmJiBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgZXJyb3IoJ0Egc3VzcGVuZGVkIHJlc291cmNlIGZpbmlzaGVkIGxvYWRpbmcgaW5zaWRlIGEgdGVzdCwgYnV0IHRoZSBldmVudCAnICsgJ3dhcyBub3Qgd3JhcHBlZCBpbiBhY3QoLi4uKS5cXG5cXG4nICsgJ1doZW4gdGVzdGluZywgY29kZSB0aGF0IHJlc29sdmVzIHN1c3BlbmRlZCBkYXRhIHNob3VsZCBiZSB3cmFwcGVkICcgKyAnaW50byBhY3QoLi4uKTpcXG5cXG4nICsgJ2FjdCgoKSA9PiB7XFxuJyArICcgIC8qIGZpbmlzaCBsb2FkaW5nIHN1c3BlbmRlZCBkYXRhICovXFxuJyArICd9KTtcXG4nICsgJy8qIGFzc2VydCBvbiB0aGUgb3V0cHV0ICovXFxuXFxuJyArIFwiVGhpcyBlbnN1cmVzIHRoYXQgeW91J3JlIHRlc3RpbmcgdGhlIGJlaGF2aW9yIHRoZSB1c2VyIHdvdWxkIHNlZSBcIiArICdpbiB0aGUgYnJvd3Nlci4nICsgJyBMZWFybiBtb3JlIGF0IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvd3JhcC10ZXN0cy13aXRoLWFjdCcpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRJc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QoaXNSdW5uaW5nKSB7XG4gIHtcbiAgICBpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QgPSBpc1J1bm5pbmc7XG4gIH1cbn1cblxuLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2RlcyAqL1xuLy8gVXNlZCBieSBSZWFjdCBSZWZyZXNoIHJ1bnRpbWUgdGhyb3VnaCBEZXZUb29scyBHbG9iYWwgSG9vay5cblxudmFyIHJlc29sdmVGYW1pbHkgPSBudWxsO1xudmFyIGZhaWxlZEJvdW5kYXJpZXMgPSBudWxsO1xudmFyIHNldFJlZnJlc2hIYW5kbGVyID0gZnVuY3Rpb24gKGhhbmRsZXIpIHtcbiAge1xuICAgIHJlc29sdmVGYW1pbHkgPSBoYW5kbGVyO1xuICB9XG59O1xuZnVuY3Rpb24gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpIHtcbiAge1xuICAgIGlmIChyZXNvbHZlRmFtaWx5ID09PSBudWxsKSB7XG4gICAgICAvLyBIb3QgcmVsb2FkaW5nIGlzIGRpc2FibGVkLlxuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuXG4gICAgdmFyIGZhbWlseSA9IHJlc29sdmVGYW1pbHkodHlwZSk7XG5cbiAgICBpZiAoZmFtaWx5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH0gLy8gVXNlIHRoZSBsYXRlc3Qga25vd24gaW1wbGVtZW50YXRpb24uXG5cblxuICAgIHJldHVybiBmYW1pbHkuY3VycmVudDtcbiAgfVxufVxuZnVuY3Rpb24gcmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKHR5cGUpIHtcbiAgLy8gTm8gaW1wbGVtZW50YXRpb24gZGlmZmVyZW5jZXMuXG4gIHJldHVybiByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcodHlwZSk7XG59XG5mdW5jdGlvbiByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyh0eXBlKSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cblxuICAgIHZhciBmYW1pbHkgPSByZXNvbHZlRmFtaWx5KHR5cGUpO1xuXG4gICAgaWYgKGZhbWlseSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSByZWFsIGZvcndhcmRSZWYuIERvbid0IHdhbnQgdG8gY3Jhc2ggZWFybHkuXG4gICAgICBpZiAodHlwZSAhPT0gbnVsbCAmJiB0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIHR5cGUucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIEZvcndhcmRSZWYgaXMgc3BlY2lhbCBiZWNhdXNlIGl0cyByZXNvbHZlZCAudHlwZSBpcyBhbiBvYmplY3QsXG4gICAgICAgIC8vIGJ1dCBpdCdzIHBvc3NpYmxlIHRoYXQgd2Ugb25seSBoYXZlIGl0cyBpbm5lciByZW5kZXIgZnVuY3Rpb24gaW4gdGhlIG1hcC5cbiAgICAgICAgLy8gSWYgdGhhdCBpbm5lciByZW5kZXIgZnVuY3Rpb24gaXMgZGlmZmVyZW50LCB3ZSdsbCBidWlsZCBhIG5ldyBmb3J3YXJkUmVmIHR5cGUuXG4gICAgICAgIHZhciBjdXJyZW50UmVuZGVyID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUucmVuZGVyKTtcblxuICAgICAgICBpZiAodHlwZS5yZW5kZXIgIT09IGN1cnJlbnRSZW5kZXIpIHtcbiAgICAgICAgICB2YXIgc3ludGhldGljVHlwZSA9IHtcbiAgICAgICAgICAgICQkdHlwZW9mOiBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFLFxuICAgICAgICAgICAgcmVuZGVyOiBjdXJyZW50UmVuZGVyXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIGlmICh0eXBlLmRpc3BsYXlOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHN5bnRoZXRpY1R5cGUuZGlzcGxheU5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBzeW50aGV0aWNUeXBlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0eXBlO1xuICAgIH0gLy8gVXNlIHRoZSBsYXRlc3Qga25vd24gaW1wbGVtZW50YXRpb24uXG5cblxuICAgIHJldHVybiBmYW1pbHkuY3VycmVudDtcbiAgfVxufVxuZnVuY3Rpb24gaXNDb21wYXRpYmxlRmFtaWx5Rm9ySG90UmVsb2FkaW5nKGZpYmVyLCBlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgcHJldlR5cGUgPSBmaWJlci5lbGVtZW50VHlwZTtcbiAgICB2YXIgbmV4dFR5cGUgPSBlbGVtZW50LnR5cGU7IC8vIElmIHdlIGdvdCBoZXJlLCB3ZSBrbm93IHR5cGVzIGFyZW4ndCA9PT0gZXF1YWwuXG5cbiAgICB2YXIgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSBmYWxzZTtcbiAgICB2YXIgJCR0eXBlb2ZOZXh0VHlwZSA9IHR5cGVvZiBuZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgbmV4dFR5cGUgIT09IG51bGwgPyBuZXh0VHlwZS4kJHR5cGVvZiA6IG51bGw7XG5cbiAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICh0eXBlb2YgbmV4dFR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuZXh0VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICAgICAgICAvLyBXZSBkb24ndCBrbm93IHRoZSBpbm5lciB0eXBlIHlldC5cbiAgICAgICAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIGFzc3VtZSB0aGF0IHRoZSBsYXp5IGlubmVyIHR5cGUgaXMgc3RhYmxlLFxuICAgICAgICAgICAgLy8gYW5kIHNvIGl0IGlzIHN1ZmZpY2llbnQgdG8gYXZvaWQgcmVjb25jaWxpbmcgaXQgYXdheS5cbiAgICAgICAgICAgIC8vIFdlJ3JlIG5vdCBnb2luZyB0byB1bndyYXAgb3IgYWN0dWFsbHkgdXNlIHRoZSBuZXcgbGF6eSB0eXBlLlxuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAge1xuICAgICAgICAgIGlmICgkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFKSB7XG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmICgkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9MQVpZX1RZUEUpIHtcbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBpZiBpdCB3YXMgYnV0IGNhbiBubyBsb25nZXIgYmUgc2ltcGxlLFxuICAgICAgICAgICAgLy8gd2Ugc2hvdWxkbid0IHNldCB0aGlzLlxuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSBpZiAoJCR0eXBlb2ZOZXh0VHlwZSA9PT0gUkVBQ1RfTEFaWV9UWVBFKSB7XG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gQ2hlY2sgaWYgYm90aCB0eXBlcyBoYXZlIGEgZmFtaWx5IGFuZCBpdCdzIHRoZSBzYW1lIG9uZS5cblxuXG4gICAgaWYgKG5lZWRzQ29tcGFyZUZhbWlsaWVzKSB7XG4gICAgICAvLyBOb3RlOiBtZW1vKCkgYW5kIGZvcndhcmRSZWYoKSB3ZSdsbCBjb21wYXJlIG91dGVyIHJhdGhlciB0aGFuIGlubmVyIHR5cGUuXG4gICAgICAvLyBUaGlzIG1lYW5zIGJvdGggb2YgdGhlbSBuZWVkIHRvIGJlIHJlZ2lzdGVyZWQgdG8gcHJlc2VydmUgc3RhdGUuXG4gICAgICAvLyBJZiB3ZSB1bndyYXBwZWQgYW5kIGNvbXBhcmVkIHRoZSBpbm5lciB0eXBlcyBmb3Igd3JhcHBlcnMgaW5zdGVhZCxcbiAgICAgIC8vIHRoZW4gd2Ugd291bGQgcmlzayBmYWxzZWx5IHNheWluZyB0d28gc2VwYXJhdGUgbWVtbyhGb28pXG4gICAgICAvLyBjYWxscyBhcmUgZXF1aXZhbGVudCBiZWNhdXNlIHRoZXkgd3JhcCB0aGUgc2FtZSBGb28gZnVuY3Rpb24uXG4gICAgICB2YXIgcHJldkZhbWlseSA9IHJlc29sdmVGYW1pbHkocHJldlR5cGUpOyAvLyAkRmxvd0ZpeE1lW25vdC1hLWZ1bmN0aW9uXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cbiAgICAgIGlmIChwcmV2RmFtaWx5ICE9PSB1bmRlZmluZWQgJiYgcHJldkZhbWlseSA9PT0gcmVzb2x2ZUZhbWlseShuZXh0VHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBtYXJrRmFpbGVkRXJyb3JCb3VuZGFyeUZvckhvdFJlbG9hZGluZyhmaWJlcikge1xuICB7XG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIC8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBXZWFrU2V0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGZhaWxlZEJvdW5kYXJpZXMgPT09IG51bGwpIHtcbiAgICAgIGZhaWxlZEJvdW5kYXJpZXMgPSBuZXcgV2Vha1NldCgpO1xuICAgIH1cblxuICAgIGZhaWxlZEJvdW5kYXJpZXMuYWRkKGZpYmVyKTtcbiAgfVxufVxudmFyIHNjaGVkdWxlUmVmcmVzaCA9IGZ1bmN0aW9uIChyb290LCB1cGRhdGUpIHtcbiAge1xuICAgIGlmIChyZXNvbHZlRmFtaWx5ID09PSBudWxsKSB7XG4gICAgICAvLyBIb3QgcmVsb2FkaW5nIGlzIGRpc2FibGVkLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBzdGFsZUZhbWlsaWVzID0gdXBkYXRlLnN0YWxlRmFtaWxpZXMsXG4gICAgICAgIHVwZGF0ZWRGYW1pbGllcyA9IHVwZGF0ZS51cGRhdGVkRmFtaWxpZXM7XG4gICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICAgIHNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkocm9vdC5jdXJyZW50LCB1cGRhdGVkRmFtaWxpZXMsIHN0YWxlRmFtaWxpZXMpO1xuICAgIGZsdXNoU3luY1dvcmsoKTtcbiAgfVxufTtcbnZhciBzY2hlZHVsZVJvb3QgPSBmdW5jdGlvbiAocm9vdCwgZWxlbWVudCkge1xuICB7XG4gICAgaWYgKHJvb3QuY29udGV4dCAhPT0gZW1wdHlDb250ZXh0T2JqZWN0KSB7XG4gICAgICAvLyBTdXBlciBlZGdlIGNhc2U6IHJvb3QgaGFzIGEgbGVnYWN5IF9yZW5kZXJTdWJ0cmVlIGNvbnRleHRcbiAgICAgIC8vIGJ1dCB3ZSBkb24ndCBrbm93IHRoZSBwYXJlbnRDb21wb25lbnQgc28gd2UgY2FuJ3QgcGFzcyBpdC5cbiAgICAgIC8vIEp1c3QgaWdub3JlLiBXZSdsbCBkZWxldGUgdGhpcyB3aXRoIF9yZW5kZXJTdWJ0cmVlIGNvZGUgcGF0aCBsYXRlci5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB1cGRhdGVDb250YWluZXJTeW5jKGVsZW1lbnQsIHJvb3QsIG51bGwsIG51bGwpO1xuICAgIGZsdXNoU3luY1dvcmsoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShmaWJlciwgdXBkYXRlZEZhbWlsaWVzLCBzdGFsZUZhbWlsaWVzKSB7XG4gIHtcbiAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlLFxuICAgICAgICBjaGlsZCA9IGZpYmVyLmNoaWxkLFxuICAgICAgICBzaWJsaW5nID0gZmliZXIuc2libGluZyxcbiAgICAgICAgdGFnID0gZmliZXIudGFnLFxuICAgICAgICB0eXBlID0gZmliZXIudHlwZTtcbiAgICB2YXIgY2FuZGlkYXRlVHlwZSA9IG51bGw7XG5cbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIGNhbmRpZGF0ZVR5cGUgPSB0eXBlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICBjYW5kaWRhdGVUeXBlID0gdHlwZS5yZW5kZXI7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChyZXNvbHZlRmFtaWx5ID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHJlc29sdmVGYW1pbHkgdG8gYmUgc2V0IGR1cmluZyBob3QgcmVsb2FkLicpO1xuICAgIH1cblxuICAgIHZhciBuZWVkc1JlbmRlciA9IGZhbHNlO1xuICAgIHZhciBuZWVkc1JlbW91bnQgPSBmYWxzZTtcblxuICAgIGlmIChjYW5kaWRhdGVUeXBlICE9PSBudWxsKSB7XG4gICAgICB2YXIgZmFtaWx5ID0gcmVzb2x2ZUZhbWlseShjYW5kaWRhdGVUeXBlKTtcblxuICAgICAgaWYgKGZhbWlseSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChzdGFsZUZhbWlsaWVzLmhhcyhmYW1pbHkpKSB7XG4gICAgICAgICAgbmVlZHNSZW1vdW50ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh1cGRhdGVkRmFtaWxpZXMuaGFzKGZhbWlseSkpIHtcbiAgICAgICAgICBpZiAodGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgICAgICAgbmVlZHNSZW1vdW50ID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbmVlZHNSZW5kZXIgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmYWlsZWRCb3VuZGFyaWVzICE9PSBudWxsKSB7XG4gICAgICBpZiAoZmFpbGVkQm91bmRhcmllcy5oYXMoZmliZXIpIHx8IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgYWx0ZXJuYXRlICE9PSBudWxsICYmIGZhaWxlZEJvdW5kYXJpZXMuaGFzKGFsdGVybmF0ZSkpIHtcbiAgICAgICAgbmVlZHNSZW1vdW50ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAobmVlZHNSZW1vdW50KSB7XG4gICAgICBmaWJlci5fZGVidWdOZWVkc1JlbW91bnQgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmIChuZWVkc1JlbW91bnQgfHwgbmVlZHNSZW5kZXIpIHtcbiAgICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBTeW5jTGFuZSk7XG5cbiAgICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgU3luY0xhbmUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjaGlsZCAhPT0gbnVsbCAmJiAhbmVlZHNSZW1vdW50KSB7XG4gICAgICBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KGNoaWxkLCB1cGRhdGVkRmFtaWxpZXMsIHN0YWxlRmFtaWxpZXMpO1xuICAgIH1cblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KHNpYmxpbmcsIHVwZGF0ZWRGYW1pbGllcywgc3RhbGVGYW1pbGllcyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBmaW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2ggPSBmdW5jdGlvbiAocm9vdCwgZmFtaWxpZXMpIHtcbiAge1xuICAgIHZhciBob3N0SW5zdGFuY2VzID0gbmV3IFNldCgpO1xuICAgIHZhciB0eXBlcyA9IG5ldyBTZXQoZmFtaWxpZXMubWFwKGZ1bmN0aW9uIChmYW1pbHkpIHtcbiAgICAgIHJldHVybiBmYW1pbHkuY3VycmVudDtcbiAgICB9KSk7XG4gICAgZmluZEhvc3RJbnN0YW5jZXNGb3JNYXRjaGluZ0ZpYmVyc1JlY3Vyc2l2ZWx5KHJvb3QuY3VycmVudCwgdHlwZXMsIGhvc3RJbnN0YW5jZXMpO1xuICAgIHJldHVybiBob3N0SW5zdGFuY2VzO1xuICB9XG59O1xuXG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlc0Zvck1hdGNoaW5nRmliZXJzUmVjdXJzaXZlbHkoZmliZXIsIHR5cGVzLCBob3N0SW5zdGFuY2VzKSB7XG4gIHtcbiAgICB2YXIgY2hpbGQgPSBmaWJlci5jaGlsZCxcbiAgICAgICAgc2libGluZyA9IGZpYmVyLnNpYmxpbmcsXG4gICAgICAgIHRhZyA9IGZpYmVyLnRhZyxcbiAgICAgICAgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgdmFyIGNhbmRpZGF0ZVR5cGUgPSBudWxsO1xuXG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICBjYW5kaWRhdGVUeXBlID0gdHlwZTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGUucmVuZGVyO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgZGlkTWF0Y2ggPSBmYWxzZTtcblxuICAgIGlmIChjYW5kaWRhdGVUeXBlICE9PSBudWxsKSB7XG4gICAgICBpZiAodHlwZXMuaGFzKGNhbmRpZGF0ZVR5cGUpKSB7XG4gICAgICAgIGRpZE1hdGNoID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZGlkTWF0Y2gpIHtcbiAgICAgIC8vIFdlIGhhdmUgYSBtYXRjaC4gVGhpcyBvbmx5IGRyaWxscyBkb3duIHRvIHRoZSBjbG9zZXN0IGhvc3QgY29tcG9uZW50cy5cbiAgICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBzZWFyY2ggZGVlcGVyIGJlY2F1c2UgZm9yIHRoZSBwdXJwb3NlIG9mIGdpdmluZ1xuICAgICAgLy8gdmlzdWFsIGZlZWRiYWNrLCBcImZsYXNoaW5nXCIgb3V0ZXJtb3N0IHBhcmVudCByZWN0YW5nbGVzIGlzIHN1ZmZpY2llbnQuXG4gICAgICBmaW5kSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5KGZpYmVyLCBob3N0SW5zdGFuY2VzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgdGhlcmUncyBubyBtYXRjaCwgbWF5YmUgdGhlcmUgd2lsbCBiZSBvbmUgZnVydGhlciBkb3duIGluIHRoZSBjaGlsZCB0cmVlLlxuICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIGZpbmRIb3N0SW5zdGFuY2VzRm9yTWF0Y2hpbmdGaWJlcnNSZWN1cnNpdmVseShjaGlsZCwgdHlwZXMsIGhvc3RJbnN0YW5jZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICBmaW5kSG9zdEluc3RhbmNlc0Zvck1hdGNoaW5nRmliZXJzUmVjdXJzaXZlbHkoc2libGluZywgdHlwZXMsIGhvc3RJbnN0YW5jZXMpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5KGZpYmVyLCBob3N0SW5zdGFuY2VzKSB7XG4gIHtcbiAgICB2YXIgZm91bmRIb3N0SW5zdGFuY2VzID0gZmluZENoaWxkSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5KGZpYmVyLCBob3N0SW5zdGFuY2VzKTtcblxuICAgIGlmIChmb3VuZEhvc3RJbnN0YW5jZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIElmIHdlIGRpZG4ndCBmaW5kIGFueSBob3N0IGNoaWxkcmVuLCBmYWxsYmFjayB0byBjbG9zZXN0IGhvc3QgcGFyZW50LlxuXG5cbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHN3aXRjaCAobm9kZS50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAgaG9zdEluc3RhbmNlcy5hZGQobm9kZS5zdGF0ZU5vZGUpO1xuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAgaG9zdEluc3RhbmNlcy5hZGQobm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAgaG9zdEluc3RhbmNlcy5hZGQobm9kZS5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byByZWFjaCByb290IGZpcnN0LicpO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRDaGlsZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseShmaWJlciwgaG9zdEluc3RhbmNlcykge1xuICB7XG4gICAgdmFyIG5vZGUgPSBmaWJlcjtcbiAgICB2YXIgZm91bmRIb3N0SW5zdGFuY2VzID0gZmFsc2U7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0SG9pc3RhYmxlIHx8IChzdXBwb3J0c1NpbmdsZXRvbnMgPyBub2RlLnRhZyA9PT0gSG9zdFNpbmdsZXRvbiA6IGZhbHNlKSkge1xuICAgICAgICAvLyBXZSBnb3QgYSBtYXRjaC5cbiAgICAgICAgZm91bmRIb3N0SW5zdGFuY2VzID0gdHJ1ZTtcbiAgICAgICAgaG9zdEluc3RhbmNlcy5hZGQobm9kZS5zdGF0ZU5vZGUpOyAvLyBUaGVyZSBtYXkgc3RpbGwgYmUgbW9yZSwgc28ga2VlcCBzZWFyY2hpbmcuXG4gICAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlID09PSBmaWJlcikge1xuICAgICAgICByZXR1cm4gZm91bmRIb3N0SW5zdGFuY2VzO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gZmliZXIpIHtcbiAgICAgICAgICByZXR1cm4gZm91bmRIb3N0SW5zdGFuY2VzO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxudmFyIGhhc0JhZE1hcFBvbHlmaWxsO1xuXG57XG4gIGhhc0JhZE1hcFBvbHlmaWxsID0gZmFsc2U7XG5cbiAgdHJ5IHtcbiAgICB2YXIgbm9uRXh0ZW5zaWJsZU9iamVjdCA9IE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh7fSk7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tbmV3ICovXG5cbiAgICBuZXcgTWFwKFtbbm9uRXh0ZW5zaWJsZU9iamVjdCwgbnVsbF1dKTtcbiAgICBuZXcgU2V0KFtub25FeHRlbnNpYmxlT2JqZWN0XSk7XG4gICAgLyogZXNsaW50LWVuYWJsZSBuby1uZXcgKi9cbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRPRE86IENvbnNpZGVyIHdhcm5pbmcgYWJvdXQgYmFkIHBvbHlmaWxsc1xuICAgIGhhc0JhZE1hcFBvbHlmaWxsID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBGaWJlck5vZGUodGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSkge1xuICAvLyBJbnN0YW5jZVxuICB0aGlzLnRhZyA9IHRhZztcbiAgdGhpcy5rZXkgPSBrZXk7XG4gIHRoaXMuZWxlbWVudFR5cGUgPSBudWxsO1xuICB0aGlzLnR5cGUgPSBudWxsO1xuICB0aGlzLnN0YXRlTm9kZSA9IG51bGw7IC8vIEZpYmVyXG5cbiAgdGhpcy5yZXR1cm4gPSBudWxsO1xuICB0aGlzLmNoaWxkID0gbnVsbDtcbiAgdGhpcy5zaWJsaW5nID0gbnVsbDtcbiAgdGhpcy5pbmRleCA9IDA7XG4gIHRoaXMucmVmID0gbnVsbDtcbiAgdGhpcy5yZWZDbGVhbnVwID0gbnVsbDtcbiAgdGhpcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHM7XG4gIHRoaXMubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gIHRoaXMudXBkYXRlUXVldWUgPSBudWxsO1xuICB0aGlzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICB0aGlzLmRlcGVuZGVuY2llcyA9IG51bGw7XG4gIHRoaXMubW9kZSA9IG1vZGU7IC8vIEVmZmVjdHNcblxuICB0aGlzLmZsYWdzID0gTm9GbGFncyQxO1xuICB0aGlzLnN1YnRyZWVGbGFncyA9IE5vRmxhZ3MkMTtcbiAgdGhpcy5kZWxldGlvbnMgPSBudWxsO1xuICB0aGlzLmxhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5jaGlsZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5hbHRlcm5hdGUgPSBudWxsO1xuXG4gIHtcbiAgICAvLyBOb3RlOiBUaGUgZm9sbG93aW5nIGlzIGRvbmUgdG8gYXZvaWQgYSB2OCBwZXJmb3JtYW5jZSBjbGlmZi5cbiAgICAvL1xuICAgIC8vIEluaXRpYWxpemluZyB0aGUgZmllbGRzIGJlbG93IHRvIHNtaXMgYW5kIGxhdGVyIHVwZGF0aW5nIHRoZW0gd2l0aFxuICAgIC8vIGRvdWJsZSB2YWx1ZXMgd2lsbCBjYXVzZSBGaWJlcnMgdG8gZW5kIHVwIGhhdmluZyBzZXBhcmF0ZSBzaGFwZXMuXG4gICAgLy8gVGhpcyBiZWhhdmlvci9idWcgaGFzIHNvbWV0aGluZyB0byBkbyB3aXRoIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9uKCkuXG4gICAgLy8gRm9ydHVuYXRlbHkgdGhpcyBvbmx5IGltcGFjdHMgREVWIGJ1aWxkcy5cbiAgICAvLyBVbmZvcnR1bmF0ZWx5IGl0IG1ha2VzIFJlYWN0IHVudXNhYmx5IHNsb3cgZm9yIHNvbWUgYXBwbGljYXRpb25zLlxuICAgIC8vIFRvIHdvcmsgYXJvdW5kIHRoaXMsIGluaXRpYWxpemUgdGhlIGZpZWxkcyBiZWxvdyB3aXRoIGRvdWJsZXMuXG4gICAgLy9cbiAgICAvLyBMZWFybiBtb3JlIGFib3V0IHRoaXMgaGVyZTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE0MzY1XG4gICAgLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9ODUzOFxuICAgIHRoaXMuYWN0dWFsRHVyYXRpb24gPSBOdW1iZXIuTmFOO1xuICAgIHRoaXMuYWN0dWFsU3RhcnRUaW1lID0gTnVtYmVyLk5hTjtcbiAgICB0aGlzLnNlbGZCYXNlRHVyYXRpb24gPSBOdW1iZXIuTmFOO1xuICAgIHRoaXMudHJlZUJhc2VEdXJhdGlvbiA9IE51bWJlci5OYU47IC8vIEl0J3Mgb2theSB0byByZXBsYWNlIHRoZSBpbml0aWFsIGRvdWJsZXMgd2l0aCBzbWlzIGFmdGVyIGluaXRpYWxpemF0aW9uLlxuICAgIC8vIFRoaXMgd29uJ3QgdHJpZ2dlciB0aGUgcGVyZm9ybWFuY2UgY2xpZmYgbWVudGlvbmVkIGFib3ZlLFxuICAgIC8vIGFuZCBpdCBzaW1wbGlmaWVzIG90aGVyIHByb2ZpbGVyIGNvZGUgKGluY2x1ZGluZyBEZXZUb29scykuXG5cbiAgICB0aGlzLmFjdHVhbER1cmF0aW9uID0gMDtcbiAgICB0aGlzLmFjdHVhbFN0YXJ0VGltZSA9IC0xO1xuICAgIHRoaXMuc2VsZkJhc2VEdXJhdGlvbiA9IDA7XG4gICAgdGhpcy50cmVlQmFzZUR1cmF0aW9uID0gMDtcbiAgfVxuXG4gIHtcbiAgICAvLyBUaGlzIGlzbid0IGRpcmVjdGx5IHVzZWQgYnV0IGlzIGhhbmR5IGZvciBkZWJ1Z2dpbmcgaW50ZXJuYWxzOlxuICAgIHRoaXMuX2RlYnVnSW5mbyA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdPd25lciA9IG51bGw7XG4gICAgdGhpcy5fZGVidWdOZWVkc1JlbW91bnQgPSBmYWxzZTtcbiAgICB0aGlzLl9kZWJ1Z0hvb2tUeXBlcyA9IG51bGw7XG5cbiAgICBpZiAoIWhhc0JhZE1hcFBvbHlmaWxsICYmIHR5cGVvZiBPYmplY3QucHJldmVudEV4dGVuc2lvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyh0aGlzKTtcbiAgICB9XG4gIH1cbn0gLy8gVGhpcyBpcyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uLCByYXRoZXIgdGhhbiBhIFBPSk8gY29uc3RydWN0b3IsIHN0aWxsXG4vLyBwbGVhc2UgZW5zdXJlIHdlIGRvIHRoZSBmb2xsb3dpbmc6XG4vLyAxKSBOb2JvZHkgc2hvdWxkIGFkZCBhbnkgaW5zdGFuY2UgbWV0aG9kcyBvbiB0aGlzLiBJbnN0YW5jZSBtZXRob2RzIGNhbiBiZVxuLy8gICAgbW9yZSBkaWZmaWN1bHQgdG8gcHJlZGljdCB3aGVuIHRoZXkgZ2V0IG9wdGltaXplZCBhbmQgdGhleSBhcmUgYWxtb3N0XG4vLyAgICBuZXZlciBpbmxpbmVkIHByb3Blcmx5IGluIHN0YXRpYyBjb21waWxlcnMuXG4vLyAyKSBOb2JvZHkgc2hvdWxkIHJlbHkgb24gYGluc3RhbmNlb2YgRmliZXJgIGZvciB0eXBlIHRlc3RpbmcuIFdlIHNob3VsZFxuLy8gICAgYWx3YXlzIGtub3cgd2hlbiBpdCBpcyBhIGZpYmVyLlxuLy8gMykgV2UgbWlnaHQgd2FudCB0byBleHBlcmltZW50IHdpdGggdXNpbmcgbnVtZXJpYyBrZXlzIHNpbmNlIHRoZXkgYXJlIGVhc2llclxuLy8gICAgdG8gb3B0aW1pemUgaW4gYSBub24tSklUIGVudmlyb25tZW50LlxuLy8gNCkgV2UgY2FuIGVhc2lseSBnbyBmcm9tIGEgY29uc3RydWN0b3IgdG8gYSBjcmVhdGVGaWJlciBvYmplY3QgbGl0ZXJhbCBpZiB0aGF0XG4vLyAgICBpcyBmYXN0ZXIuXG4vLyA1KSBJdCBzaG91bGQgYmUgZWFzeSB0byBwb3J0IHRoaXMgdG8gYSBDIHN0cnVjdCBhbmQga2VlcCBhIEMgaW1wbGVtZW50YXRpb25cbi8vICAgIGNvbXBhdGlibGUuXG5cblxuZnVuY3Rpb24gY3JlYXRlRmliZXIodGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSkge1xuICAvLyAkRmxvd0ZpeE1lW2ludmFsaWQtY29uc3RydWN0b3JdOiB0aGUgc2hhcGVzIGFyZSBleGFjdCBoZXJlIGJ1dCBGbG93IGRvZXNuJ3QgbGlrZSBjb25zdHJ1Y3RvcnNcbiAgcmV0dXJuIG5ldyBGaWJlck5vZGUodGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBpc1NpbXBsZUZ1bmN0aW9uQ29tcG9uZW50KHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nICYmICFzaG91bGRDb25zdHJ1Y3QodHlwZSkgJiYgdHlwZS5kZWZhdWx0UHJvcHMgPT09IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIGlzRnVuY3Rpb25DbGFzc0NvbXBvbmVudCh0eXBlKSB7XG4gIHJldHVybiBzaG91bGRDb25zdHJ1Y3QodHlwZSk7XG59IC8vIFRoaXMgaXMgdXNlZCB0byBjcmVhdGUgYW4gYWx0ZXJuYXRlIGZpYmVyIHRvIGRvIHdvcmsgb24uXG5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmtJblByb2dyZXNzKGN1cnJlbnQsIHBlbmRpbmdQcm9wcykge1xuICB2YXIgd29ya0luUHJvZ3Jlc3MgPSBjdXJyZW50LmFsdGVybmF0ZTtcblxuICBpZiAod29ya0luUHJvZ3Jlc3MgPT09IG51bGwpIHtcbiAgICAvLyBXZSB1c2UgYSBkb3VibGUgYnVmZmVyaW5nIHBvb2xpbmcgdGVjaG5pcXVlIGJlY2F1c2Ugd2Uga25vdyB0aGF0IHdlJ2xsXG4gICAgLy8gb25seSBldmVyIG5lZWQgYXQgbW9zdCB0d28gdmVyc2lvbnMgb2YgYSB0cmVlLiBXZSBwb29sIHRoZSBcIm90aGVyXCIgdW51c2VkXG4gICAgLy8gbm9kZSB0aGF0IHdlJ3JlIGZyZWUgdG8gcmV1c2UuIFRoaXMgaXMgbGF6aWx5IGNyZWF0ZWQgdG8gYXZvaWQgYWxsb2NhdGluZ1xuICAgIC8vIGV4dHJhIG9iamVjdHMgZm9yIHRoaW5ncyB0aGF0IGFyZSBuZXZlciB1cGRhdGVkLiBJdCBhbHNvIGFsbG93IHVzIHRvXG4gICAgLy8gcmVjbGFpbSB0aGUgZXh0cmEgbWVtb3J5IGlmIG5lZWRlZC5cbiAgICB3b3JrSW5Qcm9ncmVzcyA9IGNyZWF0ZUZpYmVyKGN1cnJlbnQudGFnLCBwZW5kaW5nUHJvcHMsIGN1cnJlbnQua2V5LCBjdXJyZW50Lm1vZGUpO1xuICAgIHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlID0gY3VycmVudC5lbGVtZW50VHlwZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlO1xuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuXG4gICAge1xuICAgICAgLy8gREVWLW9ubHkgZmllbGRzXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdPd25lciA9IGN1cnJlbnQuX2RlYnVnT3duZXI7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdIb29rVHlwZXMgPSBjdXJyZW50Ll9kZWJ1Z0hvb2tUeXBlcztcbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGUgPSBjdXJyZW50O1xuICAgIGN1cnJlbnQuYWx0ZXJuYXRlID0gd29ya0luUHJvZ3Jlc3M7XG4gIH0gZWxzZSB7XG4gICAgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzID0gcGVuZGluZ1Byb3BzOyAvLyBOZWVkZWQgYmVjYXVzZSBCbG9ja3Mgc3RvcmUgZGF0YSBvbiB0eXBlLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZTsgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGFsdGVybmF0ZS5cbiAgICAvLyBSZXNldCB0aGUgZWZmZWN0IHRhZy5cblxuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzID0gTm9GbGFncyQxOyAvLyBUaGUgZWZmZWN0cyBhcmUgbm8gbG9uZ2VyIHZhbGlkLlxuXG4gICAgd29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzID0gTm9GbGFncyQxO1xuICAgIHdvcmtJblByb2dyZXNzLmRlbGV0aW9ucyA9IG51bGw7XG5cbiAgICB7XG4gICAgICAvLyBXZSBpbnRlbnRpb25hbGx5IHJlc2V0LCByYXRoZXIgdGhhbiBjb3B5LCBhY3R1YWxEdXJhdGlvbiAmIGFjdHVhbFN0YXJ0VGltZS5cbiAgICAgIC8vIFRoaXMgcHJldmVudHMgdGltZSBmcm9tIGVuZGxlc3NseSBhY2N1bXVsYXRpbmcgaW4gbmV3IGNvbW1pdHMuXG4gICAgICAvLyBUaGlzIGhhcyB0aGUgZG93bnNpZGUgb2YgcmVzZXR0aW5nIHZhbHVlcyBmb3IgZGlmZmVyZW50IHByaW9yaXR5IHJlbmRlcnMsXG4gICAgICAvLyBCdXQgd29ya3MgZm9yIHlpZWxkaW5nICh0aGUgY29tbW9uIGNhc2UpIGFuZCBzaG91bGQgc3VwcG9ydCByZXN1bWluZy5cbiAgICAgIHdvcmtJblByb2dyZXNzLmFjdHVhbER1cmF0aW9uID0gMDtcbiAgICAgIHdvcmtJblByb2dyZXNzLmFjdHVhbFN0YXJ0VGltZSA9IC0xO1xuICAgIH1cbiAgfSAvLyBSZXNldCBhbGwgZWZmZWN0cyBleGNlcHQgc3RhdGljIG9uZXMuXG4gIC8vIFN0YXRpYyBlZmZlY3RzIGFyZSBub3Qgc3BlY2lmaWMgdG8gYSByZW5kZXIuXG5cblxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IGN1cnJlbnQuZmxhZ3MgJiBTdGF0aWNNYXNrO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gY3VycmVudC5jaGlsZExhbmVzO1xuICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGN1cnJlbnQubGFuZXM7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlOyAvLyBDbG9uZSB0aGUgZGVwZW5kZW5jaWVzIG9iamVjdC4gVGhpcyBpcyBtdXRhdGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLCBzb1xuICAvLyBpdCBjYW5ub3QgYmUgc2hhcmVkIHdpdGggdGhlIGN1cnJlbnQgZmliZXIuXG5cbiAgdmFyIGN1cnJlbnREZXBlbmRlbmNpZXMgPSBjdXJyZW50LmRlcGVuZGVuY2llcztcbiAgd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID0gY3VycmVudERlcGVuZGVuY2llcyA9PT0gbnVsbCA/IG51bGwgOiB7XG4gICAgbGFuZXM6IGN1cnJlbnREZXBlbmRlbmNpZXMubGFuZXMsXG4gICAgZmlyc3RDb250ZXh0OiBjdXJyZW50RGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dFxuICB9OyAvLyBUaGVzZSB3aWxsIGJlIG92ZXJyaWRkZW4gZHVyaW5nIHRoZSBwYXJlbnQncyByZWNvbmNpbGlhdGlvblxuXG4gIHdvcmtJblByb2dyZXNzLnNpYmxpbmcgPSBjdXJyZW50LnNpYmxpbmc7XG4gIHdvcmtJblByb2dyZXNzLmluZGV4ID0gY3VycmVudC5pbmRleDtcbiAgd29ya0luUHJvZ3Jlc3MucmVmID0gY3VycmVudC5yZWY7XG4gIHdvcmtJblByb2dyZXNzLnJlZkNsZWFudXAgPSBjdXJyZW50LnJlZkNsZWFudXA7XG5cbiAge1xuICAgIHdvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb24gPSBjdXJyZW50LnNlbGZCYXNlRHVyYXRpb247XG4gICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiA9IGN1cnJlbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgfVxuXG4gIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5fZGVidWdJbmZvID0gY3VycmVudC5fZGVidWdJbmZvO1xuICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z05lZWRzUmVtb3VudCA9IGN1cnJlbnQuX2RlYnVnTmVlZHNSZW1vdW50O1xuXG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcoY3VycmVudC50eXBlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlQ2xhc3NGb3JIb3RSZWxvYWRpbmcoY3VycmVudC50eXBlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKGN1cnJlbnQudHlwZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbn0gLy8gVXNlZCB0byByZXVzZSBhIEZpYmVyIGZvciBhIHNlY29uZCBwYXNzLlxuXG5mdW5jdGlvbiByZXNldFdvcmtJblByb2dyZXNzKHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAvLyBUaGlzIHJlc2V0cyB0aGUgRmliZXIgdG8gd2hhdCBjcmVhdGVGaWJlciBvciBjcmVhdGVXb3JrSW5Qcm9ncmVzcyB3b3VsZFxuICAvLyBoYXZlIHNldCB0aGUgdmFsdWVzIHRvIGJlZm9yZSBkdXJpbmcgdGhlIGZpcnN0IHBhc3MuIElkZWFsbHkgdGhpcyB3b3VsZG4ndFxuICAvLyBiZSBuZWNlc3NhcnkgYnV0IHVuZm9ydHVuYXRlbHkgbWFueSBjb2RlIHBhdGhzIHJlYWRzIGZyb20gdGhlIHdvcmtJblByb2dyZXNzXG4gIC8vIHdoZW4gdGhleSBzaG91bGQgYmUgcmVhZGluZyBmcm9tIGN1cnJlbnQgYW5kIHdyaXRpbmcgdG8gd29ya0luUHJvZ3Jlc3MuXG4gIC8vIFdlIGFzc3VtZSBwZW5kaW5nUHJvcHMsIGluZGV4LCBrZXksIHJlZiwgcmV0dXJuIGFyZSBzdGlsbCB1bnRvdWNoZWQgdG9cbiAgLy8gYXZvaWQgZG9pbmcgYW5vdGhlciByZWNvbmNpbGlhdGlvbi5cbiAgLy8gUmVzZXQgdGhlIGVmZmVjdCBmbGFncyBidXQga2VlcCBhbnkgUGxhY2VtZW50IHRhZ3MsIHNpbmNlIHRoYXQncyBzb21ldGhpbmdcbiAgLy8gdGhhdCBjaGlsZCBmaWJlciBpcyBzZXR0aW5nLCBub3QgdGhlIHJlY29uY2lsaWF0aW9uLlxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSBTdGF0aWNNYXNrIHwgUGxhY2VtZW50OyAvLyBUaGUgZWZmZWN0cyBhcmUgbm8gbG9uZ2VyIHZhbGlkLlxuXG4gIHZhciBjdXJyZW50ID0gd29ya0luUHJvZ3Jlc3MuYWx0ZXJuYXRlO1xuXG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgLy8gUmVzZXQgdG8gY3JlYXRlRmliZXIncyBpbml0aWFsIHZhbHVlcy5cbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gTm9MYW5lcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHJlbmRlckxhbmVzO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzJDE7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcyA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gbnVsbDtcblxuICAgIHtcbiAgICAgIC8vIE5vdGU6IFdlIGRvbid0IHJlc2V0IHRoZSBhY3R1YWxUaW1lIGNvdW50cy4gSXQncyB1c2VmdWwgdG8gYWNjdW11bGF0ZVxuICAgICAgLy8gYWN0dWFsIHRpbWUgYWNyb3NzIG11bHRpcGxlIHJlbmRlciBwYXNzZXMuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uID0gMDtcbiAgICAgIHdvcmtJblByb2dyZXNzLnRyZWVCYXNlRHVyYXRpb24gPSAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBSZXNldCB0byB0aGUgY2xvbmVkIHZhbHVlcyB0aGF0IGNyZWF0ZVdvcmtJblByb2dyZXNzIHdvdWxkJ3ZlLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBjdXJyZW50LmNoaWxkTGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBjdXJyZW50LmxhbmVzO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY3VycmVudC5jaGlsZDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzJDE7XG4gICAgd29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlOyAvLyBOZWVkZWQgYmVjYXVzZSBCbG9ja3Mgc3RvcmUgZGF0YSBvbiB0eXBlLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IGN1cnJlbnQudHlwZTsgLy8gQ2xvbmUgdGhlIGRlcGVuZGVuY2llcyBvYmplY3QuIFRoaXMgaXMgbXV0YXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSwgc29cbiAgICAvLyBpdCBjYW5ub3QgYmUgc2hhcmVkIHdpdGggdGhlIGN1cnJlbnQgZmliZXIuXG5cbiAgICB2YXIgY3VycmVudERlcGVuZGVuY2llcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzO1xuICAgIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IGN1cnJlbnREZXBlbmRlbmNpZXMgPT09IG51bGwgPyBudWxsIDoge1xuICAgICAgbGFuZXM6IGN1cnJlbnREZXBlbmRlbmNpZXMubGFuZXMsXG4gICAgICBmaXJzdENvbnRleHQ6IGN1cnJlbnREZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0XG4gICAgfTtcblxuICAgIHtcbiAgICAgIC8vIE5vdGU6IFdlIGRvbid0IHJlc2V0IHRoZSBhY3R1YWxUaW1lIGNvdW50cy4gSXQncyB1c2VmdWwgdG8gYWNjdW11bGF0ZVxuICAgICAgLy8gYWN0dWFsIHRpbWUgYWNyb3NzIG11bHRpcGxlIHJlbmRlciBwYXNzZXMuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zZWxmQmFzZUR1cmF0aW9uID0gY3VycmVudC5zZWxmQmFzZUR1cmF0aW9uO1xuICAgICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiA9IGN1cnJlbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG59XG5mdW5jdGlvbiBjcmVhdGVIb3N0Um9vdEZpYmVyKHRhZywgaXNTdHJpY3RNb2RlLCBjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlKSB7XG4gIHZhciBtb2RlO1xuXG4gIHtcbiAgICBtb2RlID0gQ29uY3VycmVudE1vZGU7XG5cbiAgICBpZiAoaXNTdHJpY3RNb2RlID09PSB0cnVlKSB7XG4gICAgICBtb2RlIHw9IFN0cmljdExlZ2FjeU1vZGUgfCBTdHJpY3RFZmZlY3RzTW9kZTtcbiAgICB9XG4gIH1cblxuICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAvLyBBbHdheXMgY29sbGVjdCBwcm9maWxlIHRpbWluZ3Mgd2hlbiBEZXZUb29scyBhcmUgcHJlc2VudC5cbiAgICAvLyBUaGlzIGVuYWJsZXMgRGV2VG9vbHMgdG8gc3RhcnQgY2FwdHVyaW5nIHRpbWluZyBhdCBhbnkgcG9pbnTigJNcbiAgICAvLyBXaXRob3V0IHNvbWUgbm9kZXMgaW4gdGhlIHRyZWUgaGF2aW5nIGVtcHR5IGJhc2UgdGltZXMuXG4gICAgbW9kZSB8PSBQcm9maWxlTW9kZTtcbiAgfVxuXG4gIHJldHVybiBjcmVhdGVGaWJlcihIb3N0Um9vdCwgbnVsbCwgbnVsbCwgbW9kZSk7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHModHlwZSwgLy8gUmVhY3QkRWxlbWVudFR5cGVcbmtleSwgcGVuZGluZ1Byb3BzLCBvd25lciwgbW9kZSwgbGFuZXMpIHtcbiAgdmFyIGZpYmVyVGFnID0gRnVuY3Rpb25Db21wb25lbnQ7IC8vIFRoZSByZXNvbHZlZCB0eXBlIGlzIHNldCBpZiB3ZSBrbm93IHdoYXQgdGhlIGZpbmFsIHR5cGUgd2lsbCBiZS4gSS5lLiBpdCdzIG5vdCBsYXp5LlxuXG4gIHZhciByZXNvbHZlZFR5cGUgPSB0eXBlO1xuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChzaG91bGRDb25zdHJ1Y3QodHlwZSkpIHtcbiAgICAgIGZpYmVyVGFnID0gQ2xhc3NDb21wb25lbnQ7XG5cbiAgICAgIHtcbiAgICAgICAgcmVzb2x2ZWRUeXBlID0gcmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHtcbiAgICAgICAgcmVzb2x2ZWRUeXBlID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIGlmIChzdXBwb3J0c1Jlc291cmNlcyAmJiBzdXBwb3J0c1NpbmdsZXRvbnMpIHtcbiAgICAgIHZhciBob3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICBmaWJlclRhZyA9IGlzSG9zdEhvaXN0YWJsZVR5cGUodHlwZSwgcGVuZGluZ1Byb3BzLCBob3N0Q29udGV4dCkgPyBIb3N0SG9pc3RhYmxlIDogaXNIb3N0U2luZ2xldG9uVHlwZSh0eXBlKSA/IEhvc3RTaW5nbGV0b24gOiBIb3N0Q29tcG9uZW50O1xuICAgIH0gZWxzZSBpZiAoc3VwcG9ydHNSZXNvdXJjZXMpIHtcbiAgICAgIHZhciBfaG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuXG4gICAgICBmaWJlclRhZyA9IGlzSG9zdEhvaXN0YWJsZVR5cGUodHlwZSwgcGVuZGluZ1Byb3BzLCBfaG9zdENvbnRleHQpID8gSG9zdEhvaXN0YWJsZSA6IEhvc3RDb21wb25lbnQ7XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0c1NpbmdsZXRvbnMpIHtcbiAgICAgIGZpYmVyVGFnID0gaXNIb3N0U2luZ2xldG9uVHlwZSh0eXBlKSA/IEhvc3RTaW5nbGV0b24gOiBIb3N0Q29tcG9uZW50O1xuICAgIH0gZWxzZSB7XG4gICAgICBmaWJlclRhZyA9IEhvc3RDb21wb25lbnQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGdldFRhZzogc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZSQUdNRU5UX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChwZW5kaW5nUHJvcHMuY2hpbGRyZW4sIG1vZGUsIGxhbmVzLCBrZXkpO1xuXG4gICAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICAgIGZpYmVyVGFnID0gTW9kZTtcbiAgICAgICAgbW9kZSB8PSBTdHJpY3RMZWdhY3lNb2RlO1xuXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBTdHJpY3QgZWZmZWN0cyBzaG91bGQgbmV2ZXIgcnVuIG9uIGxlZ2FjeSByb290c1xuICAgICAgICAgIG1vZGUgfD0gU3RyaWN0RWZmZWN0c01vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tUHJvZmlsZXIocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tU3VzcGVuc2UocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21TdXNwZW5zZUxpc3QocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KTtcblxuICAgICAgY2FzZSBSRUFDVF9PRkZTQ1JFRU5fVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpO1xuXG4gICAgICBjYXNlIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRTpcblxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICAgIGNhc2UgUkVBQ1RfU0NPUEVfVFlQRTpcblxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICAgIGNhc2UgUkVBQ1RfVFJBQ0lOR19NQVJLRVJfVFlQRTpcblxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICAgIGNhc2UgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEU6XG5cbiAgICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuXG4gICAgICAgICAgICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gQ29udGV4dFByb3ZpZGVyO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgZmliZXJUYWcgPSBDb250ZXh0Q29uc3VtZXI7XG4gICAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgICAgICAgICBmaWJlclRhZyA9IEZvcndhcmRSZWY7XG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICByZXNvbHZlZFR5cGUgPSByZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyhyZXNvbHZlZFR5cGUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcblxuICAgICAgICAgICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgICAgICAgICBmaWJlclRhZyA9IE1lbW9Db21wb25lbnQ7XG4gICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gTGF6eUNvbXBvbmVudDtcbiAgICAgICAgICAgICAgICByZXNvbHZlZFR5cGUgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgaW5mbyA9ICcnO1xuICAgICAgICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0eXBlKSkge1xuICAgICAgICAgICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICAgICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICAgICAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG93bmVyTmFtZSA9IG93bmVyID8gZ2V0Q29tcG9uZW50TmFtZUZyb21Pd25lcihvd25lcikgOiBudWxsO1xuXG4gICAgICAgICAgICBpZiAob3duZXJOYW1lKSB7XG4gICAgICAgICAgICAgIGluZm8gKz0gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgb3duZXJOYW1lICsgJ2AuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluICcgKyAnY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSAnICsgKFwiYnV0IGdvdDogXCIgKyB0eXBlU3RyaW5nICsgXCIuXCIgKyBpbmZvKSk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihmaWJlclRhZywgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuICBmaWJlci5lbGVtZW50VHlwZSA9IHR5cGU7XG4gIGZpYmVyLnR5cGUgPSByZXNvbHZlZFR5cGU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG5cbiAge1xuICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gb3duZXI7XG4gIH1cblxuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIG1vZGUsIGxhbmVzKSB7XG4gIHZhciBvd25lciA9IG51bGw7XG5cbiAge1xuICAgIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICB2YXIgcGVuZGluZ1Byb3BzID0gZWxlbWVudC5wcm9wcztcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKHR5cGUsIGtleSwgcGVuZGluZ1Byb3BzLCBvd25lciwgbW9kZSwgbGFuZXMpO1xuXG4gIHtcbiAgICBmaWJlci5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICB9XG5cbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoRnJhZ21lbnQsIGVsZW1lbnRzLCBrZXksIG1vZGUpO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVByb2ZpbGVyKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBwZW5kaW5nUHJvcHMuaWQgIT09ICdzdHJpbmcnKSB7XG4gICAgICBlcnJvcignUHJvZmlsZXIgbXVzdCBzcGVjaWZ5IGFuIFwiaWRcIiBvZiB0eXBlIGBzdHJpbmdgIGFzIGEgcHJvcC4gUmVjZWl2ZWQgdGhlIHR5cGUgYCVzYCBpbnN0ZWFkLicsIHR5cGVvZiBwZW5kaW5nUHJvcHMuaWQpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKFByb2ZpbGVyLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSB8IFByb2ZpbGVNb2RlKTtcbiAgZmliZXIuZWxlbWVudFR5cGUgPSBSRUFDVF9QUk9GSUxFUl9UWVBFO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuXG4gIHtcbiAgICBmaWJlci5zdGF0ZU5vZGUgPSB7XG4gICAgICBlZmZlY3REdXJhdGlvbjogMCxcbiAgICAgIHBhc3NpdmVFZmZlY3REdXJhdGlvbjogMFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihTdXNwZW5zZUNvbXBvbmVudCwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuICBmaWJlci5lbGVtZW50VHlwZSA9IFJFQUNUX1NVU1BFTlNFX1RZUEU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlTGlzdChwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoU3VzcGVuc2VMaXN0Q29tcG9uZW50LCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4ocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKE9mZnNjcmVlbkNvbXBvbmVudCwgcGVuZGluZ1Byb3BzLCBrZXksIG1vZGUpO1xuICBmaWJlci5lbGVtZW50VHlwZSA9IFJFQUNUX09GRlNDUkVFTl9UWVBFO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICB2YXIgcHJpbWFyeUNoaWxkSW5zdGFuY2UgPSB7XG4gICAgX3Zpc2liaWxpdHk6IE9mZnNjcmVlblZpc2libGUsXG4gICAgX3BlbmRpbmdWaXNpYmlsaXR5OiBPZmZzY3JlZW5WaXNpYmxlLFxuICAgIF9wZW5kaW5nTWFya2VyczogbnVsbCxcbiAgICBfcmV0cnlDYWNoZTogbnVsbCxcbiAgICBfdHJhbnNpdGlvbnM6IG51bGwsXG4gICAgX2N1cnJlbnQ6IG51bGwsXG4gICAgZGV0YWNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZGV0YWNoT2Zmc2NyZWVuSW5zdGFuY2UocHJpbWFyeUNoaWxkSW5zdGFuY2UpO1xuICAgIH0sXG4gICAgYXR0YWNoOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gYXR0YWNoT2Zmc2NyZWVuSW5zdGFuY2UocHJpbWFyeUNoaWxkSW5zdGFuY2UpO1xuICAgIH1cbiAgfTtcbiAgZmliZXIuc3RhdGVOb2RlID0gcHJpbWFyeUNoaWxkSW5zdGFuY2U7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVRleHQoY29udGVudCwgbW9kZSwgbGFuZXMpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoSG9zdFRleHQsIGNvbnRlbnQsIG51bGwsIG1vZGUpO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21EZWh5ZHJhdGVkRnJhZ21lbnQoZGVoeWRyYXRlZE5vZGUpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoRGVoeWRyYXRlZEZyYWdtZW50LCBudWxsLCBudWxsLCBOb01vZGUpO1xuICBmaWJlci5zdGF0ZU5vZGUgPSBkZWh5ZHJhdGVkTm9kZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUG9ydGFsKHBvcnRhbCwgbW9kZSwgbGFuZXMpIHtcbiAgdmFyIHBlbmRpbmdQcm9wcyA9IHBvcnRhbC5jaGlsZHJlbiAhPT0gbnVsbCA/IHBvcnRhbC5jaGlsZHJlbiA6IFtdO1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0UG9ydGFsLCBwZW5kaW5nUHJvcHMsIHBvcnRhbC5rZXksIG1vZGUpO1xuICBmaWJlci5sYW5lcyA9IGxhbmVzO1xuICBmaWJlci5zdGF0ZU5vZGUgPSB7XG4gICAgY29udGFpbmVySW5mbzogcG9ydGFsLmNvbnRhaW5lckluZm8sXG4gICAgcGVuZGluZ0NoaWxkcmVuOiBudWxsLFxuICAgIC8vIFVzZWQgYnkgcGVyc2lzdGVudCB1cGRhdGVzXG4gICAgaW1wbGVtZW50YXRpb246IHBvcnRhbC5pbXBsZW1lbnRhdGlvblxuICB9O1xuICByZXR1cm4gZmliZXI7XG59XG5cbmZ1bmN0aW9uIEZpYmVyUm9vdE5vZGUoY29udGFpbmVySW5mbywgLy8gJEZsb3dGaXhNZVttaXNzaW5nLWxvY2FsLWFubm90XVxudGFnLCBoeWRyYXRlLCBpZGVudGlmaWVyUHJlZml4LCBvblVuY2F1Z2h0RXJyb3IsIG9uQ2F1Z2h0RXJyb3IsIG9uUmVjb3ZlcmFibGVFcnJvciwgZm9ybVN0YXRlKSB7XG4gIHRoaXMudGFnID0gQ29uY3VycmVudFJvb3QgO1xuICB0aGlzLmNvbnRhaW5lckluZm8gPSBjb250YWluZXJJbmZvO1xuICB0aGlzLnBlbmRpbmdDaGlsZHJlbiA9IG51bGw7XG4gIHRoaXMuY3VycmVudCA9IG51bGw7XG4gIHRoaXMucGluZ0NhY2hlID0gbnVsbDtcbiAgdGhpcy5maW5pc2hlZFdvcmsgPSBudWxsO1xuICB0aGlzLnRpbWVvdXRIYW5kbGUgPSBub1RpbWVvdXQ7XG4gIHRoaXMuY2FuY2VsUGVuZGluZ0NvbW1pdCA9IG51bGw7XG4gIHRoaXMuY29udGV4dCA9IG51bGw7XG4gIHRoaXMucGVuZGluZ0NvbnRleHQgPSBudWxsO1xuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmNhbGxiYWNrTm9kZSA9IG51bGw7XG4gIHRoaXMuY2FsbGJhY2tQcmlvcml0eSA9IE5vTGFuZTtcbiAgdGhpcy5leHBpcmF0aW9uVGltZXMgPSBjcmVhdGVMYW5lTWFwKE5vVGltZXN0YW1wKTtcbiAgdGhpcy5wZW5kaW5nTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLnN1c3BlbmRlZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5waW5nZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuZXhwaXJlZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5maW5pc2hlZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuc2hlbGxTdXNwZW5kQ291bnRlciA9IDA7XG4gIHRoaXMuZW50YW5nbGVkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLmVudGFuZ2xlbWVudHMgPSBjcmVhdGVMYW5lTWFwKE5vTGFuZXMpO1xuICB0aGlzLmhpZGRlblVwZGF0ZXMgPSBjcmVhdGVMYW5lTWFwKG51bGwpO1xuICB0aGlzLmlkZW50aWZpZXJQcmVmaXggPSBpZGVudGlmaWVyUHJlZml4O1xuICB0aGlzLm9uVW5jYXVnaHRFcnJvciA9IG9uVW5jYXVnaHRFcnJvcjtcbiAgdGhpcy5vbkNhdWdodEVycm9yID0gb25DYXVnaHRFcnJvcjtcbiAgdGhpcy5vblJlY292ZXJhYmxlRXJyb3IgPSBvblJlY292ZXJhYmxlRXJyb3I7XG5cbiAge1xuICAgIHRoaXMucG9vbGVkQ2FjaGUgPSBudWxsO1xuICAgIHRoaXMucG9vbGVkQ2FjaGVMYW5lcyA9IE5vTGFuZXM7XG4gIH1cblxuICB0aGlzLmZvcm1TdGF0ZSA9IGZvcm1TdGF0ZTtcbiAgdGhpcy5pbmNvbXBsZXRlVHJhbnNpdGlvbnMgPSBuZXcgTWFwKCk7XG5cbiAge1xuICAgIHRoaXMuZWZmZWN0RHVyYXRpb24gPSAwO1xuICAgIHRoaXMucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gMDtcbiAgfVxuXG4gIHtcbiAgICB0aGlzLm1lbW9pemVkVXBkYXRlcnMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIHBlbmRpbmdVcGRhdGVyc0xhbmVNYXAgPSB0aGlzLnBlbmRpbmdVcGRhdGVyc0xhbmVNYXAgPSBbXTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBUb3RhbExhbmVzOyBfaSsrKSB7XG4gICAgICBwZW5kaW5nVXBkYXRlcnNMYW5lTWFwLnB1c2gobmV3IFNldCgpKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAge1xuICAgICAgLy8gVE9ETzogVGhpcyB2YXJpZXMgYnkgZWFjaCByZW5kZXJlci5cbiAgICAgIHRoaXMuX2RlYnVnUm9vdFR5cGUgPSBoeWRyYXRlID8gJ2h5ZHJhdGVSb290KCknIDogJ2NyZWF0ZVJvb3QoKSc7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLCB0YWcsIGh5ZHJhdGUsIGluaXRpYWxDaGlsZHJlbiwgaHlkcmF0aW9uQ2FsbGJhY2tzLCBpc1N0cmljdE1vZGUsIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsIC8vIFRPRE86IFdlIGhhdmUgc2V2ZXJhbCBvZiB0aGVzZSBhcmd1bWVudHMgdGhhdCBhcmUgY29uY2VwdHVhbGx5IHBhcnQgb2YgdGhlXG4vLyBob3N0IGNvbmZpZywgYnV0IGJlY2F1c2UgdGhleSBhcmUgcGFzc2VkIGluIGF0IHJ1bnRpbWUsIHdlIGhhdmUgdG8gdGhyZWFkXG4vLyB0aGVtIHRocm91Z2ggdGhlIHJvb3QgY29uc3RydWN0b3IuIFBlcmhhcHMgd2Ugc2hvdWxkIHB1dCB0aGVtIGFsbCBpbnRvIGFcbi8vIHNpbmdsZSB0eXBlLCBsaWtlIGEgRHluYW1pY0hvc3RDb25maWcgdGhhdCBpcyBkZWZpbmVkIGJ5IHRoZSByZW5kZXJlci5cbmlkZW50aWZpZXJQcmVmaXgsIG9uVW5jYXVnaHRFcnJvciwgb25DYXVnaHRFcnJvciwgb25SZWNvdmVyYWJsZUVycm9yLCB0cmFuc2l0aW9uQ2FsbGJhY2tzLCBmb3JtU3RhdGUpIHtcbiAgLy8gJEZsb3dGaXhNZVtpbnZhbGlkLWNvbnN0cnVjdG9yXSBGbG93IG5vIGxvbmdlciBzdXBwb3J0cyBjYWxsaW5nIG5ldyBvbiBmdW5jdGlvbnNcbiAgdmFyIHJvb3QgPSBuZXcgRmliZXJSb290Tm9kZShjb250YWluZXJJbmZvLCB0YWcsIGh5ZHJhdGUsIGlkZW50aWZpZXJQcmVmaXgsIG9uVW5jYXVnaHRFcnJvciwgb25DYXVnaHRFcnJvciwgb25SZWNvdmVyYWJsZUVycm9yLCBmb3JtU3RhdGUpO1xuICAvLyBzdGF0ZU5vZGUgaXMgYW55LlxuXG5cbiAgdmFyIHVuaW5pdGlhbGl6ZWRGaWJlciA9IGNyZWF0ZUhvc3RSb290RmliZXIodGFnLCBpc1N0cmljdE1vZGUpO1xuICByb290LmN1cnJlbnQgPSB1bmluaXRpYWxpemVkRmliZXI7XG4gIHVuaW5pdGlhbGl6ZWRGaWJlci5zdGF0ZU5vZGUgPSByb290O1xuXG4gIHtcbiAgICB2YXIgaW5pdGlhbENhY2hlID0gY3JlYXRlQ2FjaGUoKTtcbiAgICByZXRhaW5DYWNoZShpbml0aWFsQ2FjaGUpOyAvLyBUaGUgcG9vbGVkQ2FjaGUgaXMgYSBmcmVzaCBjYWNoZSBpbnN0YW5jZSB0aGF0IGlzIHVzZWQgdGVtcG9yYXJpbHlcbiAgICAvLyBmb3IgbmV3bHkgbW91bnRlZCBib3VuZGFyaWVzIGR1cmluZyBhIHJlbmRlci4gSW4gZ2VuZXJhbCwgdGhlXG4gICAgLy8gcG9vbGVkQ2FjaGUgaXMgYWx3YXlzIGNsZWFyZWQgZnJvbSB0aGUgcm9vdCBhdCB0aGUgZW5kIG9mIGEgcmVuZGVyOlxuICAgIC8vIGl0IGlzIGVpdGhlciByZWxlYXNlZCB3aGVuIHJlbmRlciBjb21taXRzLCBvciBtb3ZlZCB0byBhbiBPZmZzY3JlZW5cbiAgICAvLyBjb21wb25lbnQgaWYgcmVuZGVyaW5nIHN1c3BlbmRzLiBCZWNhdXNlIHRoZSBsaWZldGltZSBvZiB0aGUgcG9vbGVkXG4gICAgLy8gY2FjaGUgaXMgZGlzdGluY3QgZnJvbSB0aGUgbWFpbiBtZW1vaXplZFN0YXRlLmNhY2hlLCBpdCBtdXN0IGJlXG4gICAgLy8gcmV0YWluZWQgc2VwYXJhdGVseS5cblxuICAgIHJvb3QucG9vbGVkQ2FjaGUgPSBpbml0aWFsQ2FjaGU7XG4gICAgcmV0YWluQ2FjaGUoaW5pdGlhbENhY2hlKTtcbiAgICB2YXIgaW5pdGlhbFN0YXRlID0ge1xuICAgICAgZWxlbWVudDogaW5pdGlhbENoaWxkcmVuLFxuICAgICAgaXNEZWh5ZHJhdGVkOiBoeWRyYXRlLFxuICAgICAgY2FjaGU6IGluaXRpYWxDYWNoZVxuICAgIH07XG4gICAgdW5pbml0aWFsaXplZEZpYmVyLm1lbW9pemVkU3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gIH1cblxuICBpbml0aWFsaXplVXBkYXRlUXVldWUodW5pbml0aWFsaXplZEZpYmVyKTtcbiAgcmV0dXJuIHJvb3Q7XG59XG5cbnZhciBSZWFjdFZlcnNpb24gPSAnMTkuMC4wLXJjLTkzNTE4MGM3ZTAtMjAyNDA1MjQnO1xuXG4vKlxuICogVGhlIGAnJyArIHZhbHVlYCBwYXR0ZXJuICh1c2VkIGluIHBlcmYtc2Vuc2l0aXZlIGNvZGUpIHRocm93cyBmb3IgU3ltYm9sXG4gKiBhbmQgVGVtcG9yYWwuKiB0eXBlcy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzIyMDY0LlxuICpcbiAqIFRoZSBmdW5jdGlvbnMgaW4gdGhpcyBtb2R1bGUgd2lsbCB0aHJvdyBhbiBlYXNpZXItdG8tdW5kZXJzdGFuZCxcbiAqIGVhc2llci10by1kZWJ1ZyBleGNlcHRpb24gd2l0aCBhIGNsZWFyIGVycm9ycyBtZXNzYWdlIG1lc3NhZ2UgZXhwbGFpbmluZyB0aGVcbiAqIHByb2JsZW0uIChJbnN0ZWFkIG9mIGEgY29uZnVzaW5nIGV4Y2VwdGlvbiB0aHJvd24gaW5zaWRlIHRoZSBpbXBsZW1lbnRhdGlvblxuICogb2YgdGhlIGB2YWx1ZWAgb2JqZWN0KS5cbiAqL1xuLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cbmZ1bmN0aW9uIHR5cGVOYW1lKHZhbHVlKSB7XG4gIHtcbiAgICAvLyB0b1N0cmluZ1RhZyBpcyBuZWVkZWQgZm9yIG5hbWVzcGFjZWQgdHlwZXMgbGlrZSBUZW1wb3JhbC5JbnN0YW50XG4gICAgdmFyIGhhc1RvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWc7XG4gICAgdmFyIHR5cGUgPSBoYXNUb1N0cmluZ1RhZyAmJiB2YWx1ZVtTeW1ib2wudG9TdHJpbmdUYWddIHx8IHZhbHVlLmNvbnN0cnVjdG9yLm5hbWUgfHwgJ09iamVjdCc7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cblxuICAgIHJldHVybiB0eXBlO1xuICB9XG59IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl0gb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5cblxuZnVuY3Rpb24gd2lsbENvZXJjaW9uVGhyb3codmFsdWUpIHtcbiAge1xuICAgIHRyeSB7XG4gICAgICB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0ZXN0U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAgLy8gSWYgeW91IGVuZGVkIHVwIGhlcmUgYnkgZm9sbG93aW5nIGFuIGV4Y2VwdGlvbiBjYWxsIHN0YWNrLCBoZXJlJ3Mgd2hhdCdzXG4gIC8vIGhhcHBlbmVkOiB5b3Ugc3VwcGxpZWQgYW4gb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBSZWFjdCAoYXMgYSBwcm9wLCBrZXksXG4gIC8vIERPTSBhdHRyaWJ1dGUsIENTUyBwcm9wZXJ0eSwgc3RyaW5nIHJlZiwgZXRjLikgYW5kIHdoZW4gUmVhY3QgdHJpZWQgdG9cbiAgLy8gY29lcmNlIGl0IHRvIGEgc3RyaW5nIHVzaW5nIGAnJyArIHZhbHVlYCwgYW4gZXhjZXB0aW9uIHdhcyB0aHJvd24uXG4gIC8vXG4gIC8vIFRoZSBtb3N0IGNvbW1vbiB0eXBlcyB0aGF0IHdpbGwgY2F1c2UgdGhpcyBleGNlcHRpb24gYXJlIGBTeW1ib2xgIGluc3RhbmNlc1xuICAvLyBhbmQgVGVtcG9yYWwgb2JqZWN0cyBsaWtlIGBUZW1wb3JhbC5JbnN0YW50YC4gQnV0IGFueSBvYmplY3QgdGhhdCBoYXMgYVxuICAvLyBgdmFsdWVPZmAgb3IgYFtTeW1ib2wudG9QcmltaXRpdmVdYCBtZXRob2QgdGhhdCB0aHJvd3Mgd2lsbCBhbHNvIGNhdXNlIHRoaXNcbiAgLy8gZXhjZXB0aW9uLiAoTGlicmFyeSBhdXRob3JzIGRvIHRoaXMgdG8gcHJldmVudCB1c2VycyBmcm9tIHVzaW5nIGJ1aWx0LWluXG4gIC8vIG51bWVyaWMgb3BlcmF0b3JzIGxpa2UgYCtgIG9yIGNvbXBhcmlzb24gb3BlcmF0b3JzIGxpa2UgYD49YCBiZWNhdXNlIGN1c3RvbVxuICAvLyBtZXRob2RzIGFyZSBuZWVkZWQgdG8gcGVyZm9ybSBhY2N1cmF0ZSBhcml0aG1ldGljIG9yIGNvbXBhcmlzb24uKVxuICAvL1xuICAvLyBUbyBmaXggdGhlIHByb2JsZW0sIGNvZXJjZSB0aGlzIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcgYmVmb3JlXG4gIC8vIHBhc3NpbmcgaXQgdG8gUmVhY3QuIFRoZSBtb3N0IHJlbGlhYmxlIHdheSBpcyB1c3VhbGx5IGBTdHJpbmcodmFsdWUpYC5cbiAgLy9cbiAgLy8gVG8gZmluZCB3aGljaCB2YWx1ZSBpcyB0aHJvd2luZywgY2hlY2sgdGhlIGJyb3dzZXIgb3IgZGVidWdnZXIgY29uc29sZS5cbiAgLy8gQmVmb3JlIHRoaXMgZXhjZXB0aW9uIHdhcyB0aHJvd24sIHRoZXJlIHNob3VsZCBiZSBgY29uc29sZS5lcnJvcmAgb3V0cHV0XG4gIC8vIHRoYXQgc2hvd3MgdGhlIHR5cGUgKFN5bWJvbCwgVGVtcG9yYWwuUGxhaW5EYXRlLCBldGMuKSB0aGF0IGNhdXNlZCB0aGVcbiAgLy8gcHJvYmxlbSBhbmQgaG93IHRoYXQgdHlwZSB3YXMgdXNlZDoga2V5LCBhdHJyaWJ1dGUsIGlucHV0IHZhbHVlIHByb3AsIGV0Yy5cbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBjb25zb2xlIG91dHB1dCBhbHNvIHNob3dzIHRoZSBjb21wb25lbnQgYW5kIGl0c1xuICAvLyBhbmNlc3RvciBjb21wb25lbnRzIHdoZXJlIHRoZSBleGNlcHRpb24gaGFwcGVuZWQuXG4gIC8vXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuICByZXR1cm4gJycgKyB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24odmFsdWUpIHtcbiAge1xuICAgIGlmICh3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkpIHtcbiAgICAgIGVycm9yKCdUaGUgcHJvdmlkZWQga2V5IGlzIGFuIHVuc3VwcG9ydGVkIHR5cGUgJXMuJyArICcgVGhpcyB2YWx1ZSBtdXN0IGJlIGNvZXJjZWQgdG8gYSBzdHJpbmcgYmVmb3JlIHVzaW5nIGl0IGhlcmUuJywgdHlwZU5hbWUodmFsdWUpKTtcblxuICAgICAgcmV0dXJuIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7IC8vIHRocm93ICh0byBoZWxwIGNhbGxlcnMgZmluZCB0cm91Ymxlc2hvb3RpbmcgY29tbWVudHMpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBvcnRhbChjaGlsZHJlbiwgY29udGFpbmVySW5mbywgLy8gVE9ETzogZmlndXJlIG91dCB0aGUgQVBJIGZvciBjcm9zcy1yZW5kZXJlciBpbXBsZW1lbnRhdGlvbi5cbmltcGxlbWVudGF0aW9uKSB7XG4gIHZhciBrZXkgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG5cbiAge1xuICAgIGNoZWNrS2V5U3RyaW5nQ29lcmNpb24oa2V5KTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3cgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IFBvcnRhbFxuICAgICQkdHlwZW9mOiBSRUFDVF9QT1JUQUxfVFlQRSxcbiAgICBrZXk6IGtleSA9PSBudWxsID8gbnVsbCA6ICcnICsga2V5LFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBjb250YWluZXJJbmZvOiBjb250YWluZXJJbmZvLFxuICAgIGltcGxlbWVudGF0aW9uOiBpbXBsZW1lbnRhdGlvblxuICB9O1xufVxuXG4vLyBNaWdodCBhZGQgUFJPRklMRSBsYXRlci5cblxudmFyIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXM7XG52YXIgZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGU7XG5cbntcbiAgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9IGZhbHNlO1xuICBkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZSA9IHt9O1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0Rm9yU3VidHJlZShwYXJlbnRDb21wb25lbnQpIHtcbiAgaWYgKCFwYXJlbnRDb21wb25lbnQpIHtcbiAgICByZXR1cm4gZW1wdHlDb250ZXh0T2JqZWN0O1xuICB9XG5cbiAgdmFyIGZpYmVyID0gZ2V0KHBhcmVudENvbXBvbmVudCk7XG4gIHZhciBwYXJlbnRDb250ZXh0ID0gZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQoKTtcblxuICBpZiAoZmliZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgIHZhciBDb21wb25lbnQgPSBmaWJlci50eXBlO1xuXG4gICAgaWYgKGlzQ29udGV4dFByb3ZpZGVyKCkpIHtcbiAgICAgIHJldHVybiBwcm9jZXNzQ2hpbGRDb250ZXh0KGZpYmVyLCBDb21wb25lbnQsIHBhcmVudENvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXJlbnRDb250ZXh0O1xufVxuXG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlKGNvbXBvbmVudCkge1xuICB2YXIgZmliZXIgPSBnZXQoY29tcG9uZW50KTtcblxuICBpZiAoZmliZXIgPT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgY29tcG9uZW50LnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29tcG9uZW50KS5qb2luKCcsJyk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudCBhcHBlYXJzIHRvIG5vdCBiZSBhIFJlYWN0Q29tcG9uZW50LiBLZXlzOiBcIiArIGtleXMpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG5cbiAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGhvc3RGaWJlci5zdGF0ZU5vZGUpO1xufVxuXG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlV2l0aFdhcm5pbmcoY29tcG9uZW50LCBtZXRob2ROYW1lKSB7XG4gIHtcbiAgICB2YXIgZmliZXIgPSBnZXQoY29tcG9uZW50KTtcblxuICAgIGlmIChmaWJlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAodHlwZW9mIGNvbXBvbmVudC5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGNvbXBvbmVudCkuam9pbignLCcpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJBcmd1bWVudCBhcHBlYXJzIHRvIG5vdCBiZSBhIFJlYWN0Q29tcG9uZW50LiBLZXlzOiBcIiArIGtleXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG5cbiAgICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoaG9zdEZpYmVyLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgdmFyIHByZXZpb3VzRmliZXIgPSBjdXJyZW50O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihob3N0RmliZXIpO1xuXG4gICAgICAgICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgICAgICBlcnJvcignJXMgaXMgZGVwcmVjYXRlZCBpbiBTdHJpY3RNb2RlLiAnICsgJyVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggaXMgaW5zaWRlIFN0cmljdE1vZGUuICcgKyAnSW5zdGVhZCwgYWRkIGEgcmVmIGRpcmVjdGx5IHRvIHRoZSBlbGVtZW50IHlvdSB3YW50IHRvIHJlZmVyZW5jZS4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9zdHJpY3QtbW9kZS1maW5kLW5vZGUnLCBtZXRob2ROYW1lLCBtZXRob2ROYW1lLCBjb21wb25lbnROYW1lKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJyVzIGlzIGRlcHJlY2F0ZWQgaW4gU3RyaWN0TW9kZS4gJyArICclcyB3YXMgcGFzc2VkIGFuIGluc3RhbmNlIG9mICVzIHdoaWNoIHJlbmRlcnMgU3RyaWN0TW9kZSBjaGlsZHJlbi4gJyArICdJbnN0ZWFkLCBhZGQgYSByZWYgZGlyZWN0bHkgdG8gdGhlIGVsZW1lbnQgeW91IHdhbnQgdG8gcmVmZXJlbmNlLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0LmRldi9saW5rL3N0cmljdC1tb2RlLWZpbmQtbm9kZScsIG1ldGhvZE5hbWUsIG1ldGhvZE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAvLyBJZGVhbGx5IHRoaXMgc2hvdWxkIHJlc2V0IHRvIHByZXZpb3VzIGJ1dCB0aGlzIHNob3VsZG4ndCBiZSBjYWxsZWQgaW5cbiAgICAgICAgICAvLyByZW5kZXIgYW5kIHRoZXJlJ3MgYW5vdGhlciB3YXJuaW5nIGZvciB0aGF0IGFueXdheS5cbiAgICAgICAgICBpZiAocHJldmlvdXNGaWJlcikge1xuICAgICAgICAgICAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihwcmV2aW91c0ZpYmVyKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzZXRDdXJyZW50RGVidWdGaWJlckluREVWKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGhvc3RGaWJlci5zdGF0ZU5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbnRhaW5lcihjb250YWluZXJJbmZvLCB0YWcsIGh5ZHJhdGlvbkNhbGxiYWNrcywgaXNTdHJpY3RNb2RlLCBjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlLCBpZGVudGlmaWVyUHJlZml4LCBvblVuY2F1Z2h0RXJyb3IsIG9uQ2F1Z2h0RXJyb3IsIG9uUmVjb3ZlcmFibGVFcnJvciwgdHJhbnNpdGlvbkNhbGxiYWNrcykge1xuICB2YXIgaHlkcmF0ZSA9IGZhbHNlO1xuICB2YXIgaW5pdGlhbENoaWxkcmVuID0gbnVsbDtcbiAgcmV0dXJuIGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLCB0YWcsIGh5ZHJhdGUsIGluaXRpYWxDaGlsZHJlbiwgaHlkcmF0aW9uQ2FsbGJhY2tzLCBpc1N0cmljdE1vZGUsIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsIGlkZW50aWZpZXJQcmVmaXgsIG9uVW5jYXVnaHRFcnJvciwgb25DYXVnaHRFcnJvciwgb25SZWNvdmVyYWJsZUVycm9yLCB0cmFuc2l0aW9uQ2FsbGJhY2tzLCBudWxsKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUh5ZHJhdGlvbkNvbnRhaW5lcihpbml0aWFsQ2hpbGRyZW4sIC8vIFRPRE86IFJlbW92ZSBgY2FsbGJhY2tgIHdoZW4gd2UgZGVsZXRlIGxlZ2FjeSBtb2RlLlxuY2FsbGJhY2ssIGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0aW9uQ2FsbGJhY2tzLCBpc1N0cmljdE1vZGUsIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsIGlkZW50aWZpZXJQcmVmaXgsIG9uVW5jYXVnaHRFcnJvciwgb25DYXVnaHRFcnJvciwgb25SZWNvdmVyYWJsZUVycm9yLCB0cmFuc2l0aW9uQ2FsbGJhY2tzLCBmb3JtU3RhdGUpIHtcbiAgdmFyIGh5ZHJhdGUgPSB0cnVlO1xuICB2YXIgcm9vdCA9IGNyZWF0ZUZpYmVyUm9vdChjb250YWluZXJJbmZvLCB0YWcsIGh5ZHJhdGUsIGluaXRpYWxDaGlsZHJlbiwgaHlkcmF0aW9uQ2FsbGJhY2tzLCBpc1N0cmljdE1vZGUsIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsIGlkZW50aWZpZXJQcmVmaXgsIG9uVW5jYXVnaHRFcnJvciwgb25DYXVnaHRFcnJvciwgb25SZWNvdmVyYWJsZUVycm9yLCB0cmFuc2l0aW9uQ2FsbGJhY2tzLCBmb3JtU3RhdGUpOyAvLyBUT0RPOiBNb3ZlIHRoaXMgdG8gRmliZXJSb290IGNvbnN0cnVjdG9yXG5cbiAgcm9vdC5jb250ZXh0ID0gZ2V0Q29udGV4dEZvclN1YnRyZWUobnVsbCk7IC8vIFNjaGVkdWxlIHRoZSBpbml0aWFsIHJlbmRlci4gSW4gYSBoeWRyYXRpb24gcm9vdCwgdGhpcyBpcyBkaWZmZXJlbnQgZnJvbVxuICAvLyBhIHJlZ3VsYXIgdXBkYXRlIGJlY2F1c2UgdGhlIGluaXRpYWwgcmVuZGVyIG11c3QgbWF0Y2ggd2FzIHdhcyByZW5kZXJlZFxuICAvLyBvbiB0aGUgc2VydmVyLlxuICAvLyBOT1RFOiBUaGlzIHVwZGF0ZSBpbnRlbnRpb25hbGx5IGRvZXNuJ3QgaGF2ZSBhIHBheWxvYWQuIFdlJ3JlIG9ubHkgdXNpbmdcbiAgLy8gdGhlIHVwZGF0ZSB0byBzY2hlZHVsZSB3b3JrIG9uIHRoZSByb290IGZpYmVyIChhbmQsIGZvciBsZWdhY3kgcm9vdHMsIHRvXG4gIC8vIGVucXVldWUgdGhlIGNhbGxiYWNrIGlmIG9uZSBpcyBwcm92aWRlZCkuXG5cbiAgdmFyIGN1cnJlbnQgPSByb290LmN1cnJlbnQ7XG4gIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoY3VycmVudCk7XG4gIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwgPyBjYWxsYmFjayA6IG51bGw7XG4gIGVucXVldWVVcGRhdGUoY3VycmVudCwgdXBkYXRlLCBsYW5lKTtcbiAgc2NoZWR1bGVJbml0aWFsSHlkcmF0aW9uT25Sb290KHJvb3QsIGxhbmUpO1xuICByZXR1cm4gcm9vdDtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRhaW5lcihlbGVtZW50LCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgY2FsbGJhY2spIHtcbiAgdmFyIGN1cnJlbnQgPSBjb250YWluZXIuY3VycmVudDtcbiAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShjdXJyZW50KTtcbiAgdXBkYXRlQ29udGFpbmVySW1wbChjdXJyZW50LCBsYW5lLCBlbGVtZW50LCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgY2FsbGJhY2spO1xuICByZXR1cm4gbGFuZTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRhaW5lclN5bmMoZWxlbWVudCwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKSB7XG4gIGlmIChjb250YWluZXIudGFnID09PSBMZWdhY3lSb290KSB7XG4gICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuICB9XG5cbiAgdmFyIGN1cnJlbnQgPSBjb250YWluZXIuY3VycmVudDtcbiAgdXBkYXRlQ29udGFpbmVySW1wbChjdXJyZW50LCBTeW5jTGFuZSwgZWxlbWVudCwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgcmV0dXJuIFN5bmNMYW5lO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb250YWluZXJJbXBsKHJvb3RGaWJlciwgbGFuZSwgZWxlbWVudCwgY29udGFpbmVyLCBwYXJlbnRDb21wb25lbnQsIGNhbGxiYWNrKSB7XG4gIHtcbiAgICBvblNjaGVkdWxlUm9vdChjb250YWluZXIsIGVsZW1lbnQpO1xuICB9XG5cbiAge1xuICAgIG1hcmtSZW5kZXJTY2hlZHVsZWQobGFuZSk7XG4gIH1cblxuICB2YXIgY29udGV4dCA9IGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCk7XG5cbiAgaWYgKGNvbnRhaW5lci5jb250ZXh0ID09PSBudWxsKSB7XG4gICAgY29udGFpbmVyLmNvbnRleHQgPSBjb250ZXh0O1xuICB9IGVsc2Uge1xuICAgIGNvbnRhaW5lci5wZW5kaW5nQ29udGV4dCA9IGNvbnRleHQ7XG4gIH1cblxuICB7XG4gICAgaWYgKGlzUmVuZGVyaW5nICYmIGN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMpIHtcbiAgICAgIGRpZFdhcm5BYm91dE5lc3RlZFVwZGF0ZXMgPSB0cnVlO1xuXG4gICAgICBlcnJvcignUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGU7ICcgKyAndHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgaXMgbm90IGFsbG93ZWQuICcgKyAnSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluIGNvbXBvbmVudERpZFVwZGF0ZS5cXG5cXG4nICsgJ0NoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mICVzLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoY3VycmVudCkgfHwgJ1Vua25vd24nKTtcbiAgICB9XG4gIH1cblxuICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGxhbmUpOyAvLyBDYXV0aW9uOiBSZWFjdCBEZXZUb29scyBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByb3BlcnR5XG4gIC8vIGJlaW5nIGNhbGxlZCBcImVsZW1lbnRcIi5cblxuICB1cGRhdGUucGF5bG9hZCA9IHtcbiAgICBlbGVtZW50OiBlbGVtZW50XG4gIH07XG4gIGNhbGxiYWNrID0gY2FsbGJhY2sgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjYWxsYmFjaztcblxuICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVycm9yKCdFeHBlY3RlZCB0aGUgbGFzdCBvcHRpb25hbCBgY2FsbGJhY2tgIGFyZ3VtZW50IHRvIGJlIGEgJyArICdmdW5jdGlvbi4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY2FsbGJhY2spO1xuICAgICAgfVxuICAgIH1cblxuICAgIHVwZGF0ZS5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICB9XG5cbiAgdmFyIHJvb3QgPSBlbnF1ZXVlVXBkYXRlKHJvb3RGaWJlciwgdXBkYXRlLCBsYW5lKTtcblxuICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCByb290RmliZXIsIGxhbmUpO1xuICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgcm9vdEZpYmVyLCBsYW5lKTtcbiAgfVxufVxuZnVuY3Rpb24gZ2V0UHVibGljUm9vdEluc3RhbmNlKGNvbnRhaW5lcikge1xuICB2YXIgY29udGFpbmVyRmliZXIgPSBjb250YWluZXIuY3VycmVudDtcblxuICBpZiAoIWNvbnRhaW5lckZpYmVyLmNoaWxkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKGNvbnRhaW5lckZpYmVyLmNoaWxkLnRhZykge1xuICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlKTtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gY29udGFpbmVyRmliZXIuY2hpbGQuc3RhdGVOb2RlO1xuICB9XG59XG5mdW5jdGlvbiBhdHRlbXB0U3luY2hyb25vdXNIeWRyYXRpb24oZmliZXIpIHtcbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICB2YXIgcm9vdCA9IGZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAoaXNSb290RGVoeWRyYXRlZChyb290KSkge1xuICAgICAgICAgIC8vIEZsdXNoIHRoZSBmaXJzdCBzY2hlZHVsZWQgXCJ1cGRhdGVcIi5cbiAgICAgICAgICB2YXIgbGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlQZW5kaW5nTGFuZXMocm9vdCk7XG4gICAgICAgICAgZmx1c2hSb290KHJvb3QsIGxhbmVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9yb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBTeW5jTGFuZSk7XG5cbiAgICAgICAgaWYgKF9yb290ICE9PSBudWxsKSB7XG4gICAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKF9yb290LCBmaWJlciwgU3luY0xhbmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZmx1c2hTeW5jV29yaygpOyAvLyBJZiB3ZSdyZSBzdGlsbCBibG9ja2VkIGFmdGVyIHRoaXMsIHdlIG5lZWQgdG8gaW5jcmVhc2VcbiAgICAgICAgLy8gdGhlIHByaW9yaXR5IG9mIGFueSBwcm9taXNlcyByZXNvbHZpbmcgd2l0aGluIHRoaXNcbiAgICAgICAgLy8gYm91bmRhcnkgc28gdGhhdCB0aGV5IG5leHQgYXR0ZW1wdCBhbHNvIGhhcyBoaWdoZXIgcHJpLlxuXG4gICAgICAgIHZhciByZXRyeUxhbmUgPSBTeW5jTGFuZTtcbiAgICAgICAgbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIHJldHJ5TGFuZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtSZXRyeUxhbmVJbXBsKGZpYmVyLCByZXRyeUxhbmUpIHtcbiAgdmFyIHN1c3BlbnNlU3RhdGUgPSBmaWJlci5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChzdXNwZW5zZVN0YXRlICE9PSBudWxsICYmIHN1c3BlbnNlU3RhdGUuZGVoeWRyYXRlZCAhPT0gbnVsbCkge1xuICAgIHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lID0gaGlnaGVyUHJpb3JpdHlMYW5lKHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lLCByZXRyeUxhbmUpO1xuICB9XG59IC8vIEluY3JlYXNlcyB0aGUgcHJpb3JpdHkgb2YgdGhlbmFibGVzIHdoZW4gdGhleSByZXNvbHZlIHdpdGhpbiB0aGlzIGJvdW5kYXJ5LlxuXG5cbmZ1bmN0aW9uIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCByZXRyeUxhbmUpIHtcbiAgbWFya1JldHJ5TGFuZUltcGwoZmliZXIsIHJldHJ5TGFuZSk7XG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSkge1xuICAgIG1hcmtSZXRyeUxhbmVJbXBsKGFsdGVybmF0ZSwgcmV0cnlMYW5lKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbihmaWJlcikge1xuICBpZiAoZmliZXIudGFnICE9PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgIC8vIFdlIGlnbm9yZSBIb3N0Um9vdHMgaGVyZSBiZWNhdXNlIHdlIGNhbid0IGluY3JlYXNlXG4gICAgLy8gdGhlaXIgcHJpb3JpdHkgYW5kIHRoZXkgc2hvdWxkIG5vdCBzdXNwZW5kIG9uIEkvTyxcbiAgICAvLyBzaW5jZSB5b3UgaGF2ZSB0byB3cmFwIGFueXRoaW5nIHRoYXQgbWlnaHQgc3VzcGVuZCBpblxuICAgIC8vIFN1c3BlbnNlLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBsYW5lID0gU2VsZWN0aXZlSHlkcmF0aW9uTGFuZTtcbiAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIGxhbmUpO1xuXG4gIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBsYW5lKTtcbiAgfVxuXG4gIG1hcmtSZXRyeUxhbmVJZk5vdEh5ZHJhdGVkKGZpYmVyLCBsYW5lKTtcbn1cbmZ1bmN0aW9uIGF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eShmaWJlcikge1xuICBpZiAoZmliZXIudGFnICE9PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgIC8vIFdlIGlnbm9yZSBIb3N0Um9vdHMgaGVyZSBiZWNhdXNlIHdlIGNhbid0IGluY3JlYXNlXG4gICAgLy8gdGhlaXIgcHJpb3JpdHkgb3RoZXIgdGhhbiBzeW5jaHJvbm91c2x5IGZsdXNoIGl0LlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgbGFuZSk7XG5cbiAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIGxhbmUpO1xuICB9XG5cbiAgbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIGxhbmUpO1xufVxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMoZmliZXIpIHtcbiAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFscyhmaWJlcik7XG5cbiAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGdldFB1YmxpY0luc3RhbmNlKGhvc3RGaWJlci5zdGF0ZU5vZGUpO1xufVxuXG52YXIgc2hvdWxkRXJyb3JJbXBsID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gIHJldHVybiBudWxsO1xufTtcblxuZnVuY3Rpb24gc2hvdWxkRXJyb3IoZmliZXIpIHtcbiAgcmV0dXJuIHNob3VsZEVycm9ySW1wbChmaWJlcik7XG59XG5cbnZhciBzaG91bGRTdXNwZW5kSW1wbCA9IGZ1bmN0aW9uIChmaWJlcikge1xuICByZXR1cm4gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiBzaG91bGRTdXNwZW5kKGZpYmVyKSB7XG4gIHJldHVybiBzaG91bGRTdXNwZW5kSW1wbChmaWJlcik7XG59XG52YXIgb3ZlcnJpZGVIb29rU3RhdGUgPSBudWxsO1xudmFyIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCA9IG51bGw7XG52YXIgb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoID0gbnVsbDtcbnZhciBvdmVycmlkZVByb3BzID0gbnVsbDtcbnZhciBvdmVycmlkZVByb3BzRGVsZXRlUGF0aCA9IG51bGw7XG52YXIgb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGggPSBudWxsO1xudmFyIHNjaGVkdWxlVXBkYXRlID0gbnVsbDtcbnZhciBzZXRFcnJvckhhbmRsZXIgPSBudWxsO1xudmFyIHNldFN1c3BlbnNlSGFuZGxlciA9IG51bGw7XG5cbntcbiAgdmFyIGNvcHlXaXRoRGVsZXRlSW1wbCA9IGZ1bmN0aW9uIChvYmosIHBhdGgsIGluZGV4KSB7XG4gICAgdmFyIGtleSA9IHBhdGhbaW5kZXhdO1xuICAgIHZhciB1cGRhdGVkID0gaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBhc3NpZ24oe30sIG9iaik7XG5cbiAgICBpZiAoaW5kZXggKyAxID09PSBwYXRoLmxlbmd0aCkge1xuICAgICAgaWYgKGlzQXJyYXkodXBkYXRlZCkpIHtcbiAgICAgICAgdXBkYXRlZC5zcGxpY2Uoa2V5LCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlbGV0ZSB1cGRhdGVkW2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuXG5cbiAgICB1cGRhdGVkW2tleV0gPSBjb3B5V2l0aERlbGV0ZUltcGwob2JqW2tleV0sIHBhdGgsIGluZGV4ICsgMSk7XG4gICAgcmV0dXJuIHVwZGF0ZWQ7XG4gIH07XG5cbiAgdmFyIGNvcHlXaXRoRGVsZXRlID0gZnVuY3Rpb24gKG9iaiwgcGF0aCkge1xuICAgIHJldHVybiBjb3B5V2l0aERlbGV0ZUltcGwob2JqLCBwYXRoLCAwKTtcbiAgfTtcblxuICB2YXIgY29weVdpdGhSZW5hbWVJbXBsID0gZnVuY3Rpb24gKG9iaiwgb2xkUGF0aCwgbmV3UGF0aCwgaW5kZXgpIHtcbiAgICB2YXIgb2xkS2V5ID0gb2xkUGF0aFtpbmRleF07XG4gICAgdmFyIHVwZGF0ZWQgPSBpc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IGFzc2lnbih7fSwgb2JqKTtcblxuICAgIGlmIChpbmRleCArIDEgPT09IG9sZFBhdGgubGVuZ3RoKSB7XG4gICAgICB2YXIgbmV3S2V5ID0gbmV3UGF0aFtpbmRleF07IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcblxuICAgICAgdXBkYXRlZFtuZXdLZXldID0gdXBkYXRlZFtvbGRLZXldO1xuXG4gICAgICBpZiAoaXNBcnJheSh1cGRhdGVkKSkge1xuICAgICAgICB1cGRhdGVkLnNwbGljZShvbGRLZXksIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHVwZGF0ZWRbb2xkS2V5XTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuICAgICAgdXBkYXRlZFtvbGRLZXldID0gY29weVdpdGhSZW5hbWVJbXBsKCAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG4gICAgICBvYmpbb2xkS2V5XSwgb2xkUGF0aCwgbmV3UGF0aCwgaW5kZXggKyAxKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXBkYXRlZDtcbiAgfTtcblxuICB2YXIgY29weVdpdGhSZW5hbWUgPSBmdW5jdGlvbiAob2JqLCBvbGRQYXRoLCBuZXdQYXRoKSB7XG4gICAgaWYgKG9sZFBhdGgubGVuZ3RoICE9PSBuZXdQYXRoLmxlbmd0aCkge1xuICAgICAgd2FybignY29weVdpdGhSZW5hbWUoKSBleHBlY3RzIHBhdGhzIG9mIHRoZSBzYW1lIGxlbmd0aCcpO1xuXG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3UGF0aC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgaWYgKG9sZFBhdGhbaV0gIT09IG5ld1BhdGhbaV0pIHtcbiAgICAgICAgICB3YXJuKCdjb3B5V2l0aFJlbmFtZSgpIGV4cGVjdHMgcGF0aHMgdG8gYmUgdGhlIHNhbWUgZXhjZXB0IGZvciB0aGUgZGVlcGVzdCBrZXknKTtcblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBjb3B5V2l0aFJlbmFtZUltcGwob2JqLCBvbGRQYXRoLCBuZXdQYXRoLCAwKTtcbiAgfTtcblxuICB2YXIgY29weVdpdGhTZXRJbXBsID0gZnVuY3Rpb24gKG9iaiwgcGF0aCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgaWYgKGluZGV4ID49IHBhdGgubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgdmFyIGtleSA9IHBhdGhbaW5kZXhdO1xuICAgIHZhciB1cGRhdGVkID0gaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBhc3NpZ24oe30sIG9iaik7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcblxuICAgIHVwZGF0ZWRba2V5XSA9IGNvcHlXaXRoU2V0SW1wbChvYmpba2V5XSwgcGF0aCwgaW5kZXggKyAxLCB2YWx1ZSk7XG4gICAgcmV0dXJuIHVwZGF0ZWQ7XG4gIH07XG5cbiAgdmFyIGNvcHlXaXRoU2V0ID0gZnVuY3Rpb24gKG9iaiwgcGF0aCwgdmFsdWUpIHtcbiAgICByZXR1cm4gY29weVdpdGhTZXRJbXBsKG9iaiwgcGF0aCwgMCwgdmFsdWUpO1xuICB9O1xuXG4gIHZhciBmaW5kSG9vayA9IGZ1bmN0aW9uIChmaWJlciwgaWQpIHtcbiAgICAvLyBGb3Igbm93LCB0aGUgXCJpZFwiIG9mIHN0YXRlZnVsIGhvb2tzIGlzIGp1c3QgdGhlIHN0YXRlZnVsIGhvb2sgaW5kZXguXG4gICAgLy8gVGhpcyBtYXkgY2hhbmdlIGluIHRoZSBmdXR1cmUgd2l0aCBlLmcuIG5lc3RlZCBob29rcy5cbiAgICB2YXIgY3VycmVudEhvb2sgPSBmaWJlci5tZW1vaXplZFN0YXRlO1xuXG4gICAgd2hpbGUgKGN1cnJlbnRIb29rICE9PSBudWxsICYmIGlkID4gMCkge1xuICAgICAgY3VycmVudEhvb2sgPSBjdXJyZW50SG9vay5uZXh0O1xuICAgICAgaWQtLTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3VycmVudEhvb2s7XG4gIH07IC8vIFN1cHBvcnQgRGV2VG9vbHMgZWRpdGFibGUgdmFsdWVzIGZvciB1c2VTdGF0ZSBhbmQgdXNlUmVkdWNlci5cblxuXG4gIG92ZXJyaWRlSG9va1N0YXRlID0gZnVuY3Rpb24gKGZpYmVyLCBpZCwgcGF0aCwgdmFsdWUpIHtcbiAgICB2YXIgaG9vayA9IGZpbmRIb29rKGZpYmVyLCBpZCk7XG5cbiAgICBpZiAoaG9vayAhPT0gbnVsbCkge1xuICAgICAgdmFyIG5ld1N0YXRlID0gY29weVdpdGhTZXQoaG9vay5tZW1vaXplZFN0YXRlLCBwYXRoLCB2YWx1ZSk7XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgIGhvb2suYmFzZVN0YXRlID0gbmV3U3RhdGU7IC8vIFdlIGFyZW4ndCBhY3R1YWxseSBhZGRpbmcgYW4gdXBkYXRlIHRvIHRoZSBxdWV1ZSxcbiAgICAgIC8vIGJlY2F1c2UgdGhlcmUgaXMgbm8gdXBkYXRlIHdlIGNhbiBhZGQgZm9yIHVzZVJlZHVjZXIgaG9va3MgdGhhdCB3b24ndCB0cmlnZ2VyIGFuIGVycm9yLlxuICAgICAgLy8gKFRoZXJlJ3Mgbm8gYXBwcm9wcmlhdGUgYWN0aW9uIHR5cGUgZm9yIERldlRvb2xzIG92ZXJyaWRlcy4pXG4gICAgICAvLyBBcyBhIHJlc3VsdCB0aG91Z2gsIFJlYWN0IHdpbGwgc2VlIHRoZSBzY2hlZHVsZWQgdXBkYXRlIGFzIGEgbm9vcCBhbmQgYmFpbG91dC5cbiAgICAgIC8vIFNoYWxsb3cgY2xvbmluZyBwcm9wcyB3b3JrcyBhcyBhIHdvcmthcm91bmQgZm9yIG5vdyB0byBieXBhc3MgdGhlIGJhaWxvdXQgY2hlY2suXG5cbiAgICAgIGZpYmVyLm1lbW9pemVkUHJvcHMgPSBhc3NpZ24oe30sIGZpYmVyLm1lbW9pemVkUHJvcHMpO1xuICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIFN5bmNMYW5lKTtcblxuICAgICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBTeW5jTGFuZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aCA9IGZ1bmN0aW9uIChmaWJlciwgaWQsIHBhdGgpIHtcbiAgICB2YXIgaG9vayA9IGZpbmRIb29rKGZpYmVyLCBpZCk7XG5cbiAgICBpZiAoaG9vayAhPT0gbnVsbCkge1xuICAgICAgdmFyIG5ld1N0YXRlID0gY29weVdpdGhEZWxldGUoaG9vay5tZW1vaXplZFN0YXRlLCBwYXRoKTtcbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgaG9vay5iYXNlU3RhdGUgPSBuZXdTdGF0ZTsgLy8gV2UgYXJlbid0IGFjdHVhbGx5IGFkZGluZyBhbiB1cGRhdGUgdG8gdGhlIHF1ZXVlLFxuICAgICAgLy8gYmVjYXVzZSB0aGVyZSBpcyBubyB1cGRhdGUgd2UgY2FuIGFkZCBmb3IgdXNlUmVkdWNlciBob29rcyB0aGF0IHdvbid0IHRyaWdnZXIgYW4gZXJyb3IuXG4gICAgICAvLyAoVGhlcmUncyBubyBhcHByb3ByaWF0ZSBhY3Rpb24gdHlwZSBmb3IgRGV2VG9vbHMgb3ZlcnJpZGVzLilcbiAgICAgIC8vIEFzIGEgcmVzdWx0IHRob3VnaCwgUmVhY3Qgd2lsbCBzZWUgdGhlIHNjaGVkdWxlZCB1cGRhdGUgYXMgYSBub29wIGFuZCBiYWlsb3V0LlxuICAgICAgLy8gU2hhbGxvdyBjbG9uaW5nIHByb3BzIHdvcmtzIGFzIGEgd29ya2Fyb3VuZCBmb3Igbm93IHRvIGJ5cGFzcyB0aGUgYmFpbG91dCBjaGVjay5cblxuICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyA9IGFzc2lnbih7fSwgZmliZXIubWVtb2l6ZWRQcm9wcyk7XG4gICAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgU3luY0xhbmUpO1xuXG4gICAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBpZCwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgIHZhciBob29rID0gZmluZEhvb2soZmliZXIsIGlkKTtcblxuICAgIGlmIChob29rICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV3U3RhdGUgPSBjb3B5V2l0aFJlbmFtZShob29rLm1lbW9pemVkU3RhdGUsIG9sZFBhdGgsIG5ld1BhdGgpO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlOyAvLyBXZSBhcmVuJ3QgYWN0dWFsbHkgYWRkaW5nIGFuIHVwZGF0ZSB0byB0aGUgcXVldWUsXG4gICAgICAvLyBiZWNhdXNlIHRoZXJlIGlzIG5vIHVwZGF0ZSB3ZSBjYW4gYWRkIGZvciB1c2VSZWR1Y2VyIGhvb2tzIHRoYXQgd29uJ3QgdHJpZ2dlciBhbiBlcnJvci5cbiAgICAgIC8vIChUaGVyZSdzIG5vIGFwcHJvcHJpYXRlIGFjdGlvbiB0eXBlIGZvciBEZXZUb29scyBvdmVycmlkZXMuKVxuICAgICAgLy8gQXMgYSByZXN1bHQgdGhvdWdoLCBSZWFjdCB3aWxsIHNlZSB0aGUgc2NoZWR1bGVkIHVwZGF0ZSBhcyBhIG5vb3AgYW5kIGJhaWxvdXQuXG4gICAgICAvLyBTaGFsbG93IGNsb25pbmcgcHJvcHMgd29ya3MgYXMgYSB3b3JrYXJvdW5kIGZvciBub3cgdG8gYnlwYXNzIHRoZSBiYWlsb3V0IGNoZWNrLlxuXG4gICAgICBmaWJlci5tZW1vaXplZFByb3BzID0gYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKTtcbiAgICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBTeW5jTGFuZSk7XG5cbiAgICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgU3luY0xhbmUpO1xuICAgICAgfVxuICAgIH1cbiAgfTsgLy8gU3VwcG9ydCBEZXZUb29scyBwcm9wcyBmb3IgZnVuY3Rpb24gY29tcG9uZW50cywgZm9yd2FyZFJlZiwgbWVtbywgaG9zdCBjb21wb25lbnRzLCBldGMuXG5cblxuICBvdmVycmlkZVByb3BzID0gZnVuY3Rpb24gKGZpYmVyLCBwYXRoLCB2YWx1ZSkge1xuICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGNvcHlXaXRoU2V0KGZpYmVyLm1lbW9pemVkUHJvcHMsIHBhdGgsIHZhbHVlKTtcblxuICAgIGlmIChmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIFN5bmNMYW5lKTtcblxuICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lKTtcbiAgICB9XG4gIH07XG5cbiAgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIHBhdGgpIHtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aERlbGV0ZShmaWJlci5tZW1vaXplZFByb3BzLCBwYXRoKTtcblxuICAgIGlmIChmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIFN5bmNMYW5lKTtcblxuICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lKTtcbiAgICB9XG4gIH07XG5cbiAgb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIG9sZFBhdGgsIG5ld1BhdGgpIHtcbiAgICBmaWJlci5wZW5kaW5nUHJvcHMgPSBjb3B5V2l0aFJlbmFtZShmaWJlci5tZW1vaXplZFByb3BzLCBvbGRQYXRoLCBuZXdQYXRoKTtcblxuICAgIGlmIChmaWJlci5hbHRlcm5hdGUpIHtcbiAgICAgIGZpYmVyLmFsdGVybmF0ZS5wZW5kaW5nUHJvcHMgPSBmaWJlci5wZW5kaW5nUHJvcHM7XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIFN5bmNMYW5lKTtcblxuICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lKTtcbiAgICB9XG4gIH07XG5cbiAgc2NoZWR1bGVVcGRhdGUgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgU3luY0xhbmUpO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgU3luY0xhbmUpO1xuICAgIH1cbiAgfTtcblxuICBzZXRFcnJvckhhbmRsZXIgPSBmdW5jdGlvbiAobmV3U2hvdWxkRXJyb3JJbXBsKSB7XG4gICAgc2hvdWxkRXJyb3JJbXBsID0gbmV3U2hvdWxkRXJyb3JJbXBsO1xuICB9O1xuXG4gIHNldFN1c3BlbnNlSGFuZGxlciA9IGZ1bmN0aW9uIChuZXdTaG91bGRTdXNwZW5kSW1wbCkge1xuICAgIHNob3VsZFN1c3BlbmRJbXBsID0gbmV3U2hvdWxkU3VzcGVuZEltcGw7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyKGZpYmVyKSB7XG4gIHZhciBob3N0RmliZXIgPSBmaW5kQ3VycmVudEhvc3RGaWJlcihmaWJlcik7XG5cbiAgaWYgKGhvc3RGaWJlciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGhvc3RGaWJlci5zdGF0ZU5vZGU7XG59XG5cbmZ1bmN0aW9uIGVtcHR5RmluZEZpYmVyQnlIb3N0SW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRGaWJlckZvckRldlRvb2xzKCkge1xuICByZXR1cm4gY3VycmVudDtcbn1cblxuZnVuY3Rpb24gaW5qZWN0SW50b0RldlRvb2xzKGRldlRvb2xzQ29uZmlnKSB7XG4gIHZhciBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSA9IGRldlRvb2xzQ29uZmlnLmZpbmRGaWJlckJ5SG9zdEluc3RhbmNlO1xuICByZXR1cm4gaW5qZWN0SW50ZXJuYWxzKHtcbiAgICBidW5kbGVUeXBlOiBkZXZUb29sc0NvbmZpZy5idW5kbGVUeXBlLFxuICAgIHZlcnNpb246IGRldlRvb2xzQ29uZmlnLnZlcnNpb24sXG4gICAgcmVuZGVyZXJQYWNrYWdlTmFtZTogZGV2VG9vbHNDb25maWcucmVuZGVyZXJQYWNrYWdlTmFtZSxcbiAgICByZW5kZXJlckNvbmZpZzogZGV2VG9vbHNDb25maWcucmVuZGVyZXJDb25maWcsXG4gICAgb3ZlcnJpZGVIb29rU3RhdGU6IG92ZXJyaWRlSG9va1N0YXRlLFxuICAgIG92ZXJyaWRlSG9va1N0YXRlRGVsZXRlUGF0aDogb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoLFxuICAgIG92ZXJyaWRlSG9va1N0YXRlUmVuYW1lUGF0aDogb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoLFxuICAgIG92ZXJyaWRlUHJvcHM6IG92ZXJyaWRlUHJvcHMsXG4gICAgb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGg6IG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoLFxuICAgIG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoOiBvdmVycmlkZVByb3BzUmVuYW1lUGF0aCxcbiAgICBzZXRFcnJvckhhbmRsZXI6IHNldEVycm9ySGFuZGxlcixcbiAgICBzZXRTdXNwZW5zZUhhbmRsZXI6IHNldFN1c3BlbnNlSGFuZGxlcixcbiAgICBzY2hlZHVsZVVwZGF0ZTogc2NoZWR1bGVVcGRhdGUsXG4gICAgY3VycmVudERpc3BhdGNoZXJSZWY6IFJlYWN0U2hhcmVkSW50ZXJuYWxzLFxuICAgIGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyOiBmaW5kSG9zdEluc3RhbmNlQnlGaWJlcixcbiAgICBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZTogZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UgfHwgZW1wdHlGaW5kRmliZXJCeUhvc3RJbnN0YW5jZSxcbiAgICAvLyBSZWFjdCBSZWZyZXNoXG4gICAgZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoOiBmaW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2ggLFxuICAgIHNjaGVkdWxlUmVmcmVzaDogc2NoZWR1bGVSZWZyZXNoICxcbiAgICBzY2hlZHVsZVJvb3Q6IHNjaGVkdWxlUm9vdCAsXG4gICAgc2V0UmVmcmVzaEhhbmRsZXI6IHNldFJlZnJlc2hIYW5kbGVyICxcbiAgICAvLyBFbmFibGVzIERldlRvb2xzIHRvIGFwcGVuZCBvd25lciBzdGFja3MgdG8gZXJyb3IgbWVzc2FnZXMgaW4gREVWIG1vZGUuXG4gICAgZ2V0Q3VycmVudEZpYmVyOiBnZXRDdXJyZW50RmliZXJGb3JEZXZUb29scyAsXG4gICAgLy8gRW5hYmxlcyBEZXZUb29scyB0byBkZXRlY3QgcmVjb25jaWxlciB2ZXJzaW9uIHJhdGhlciB0aGFuIHJlbmRlcmVyIHZlcnNpb25cbiAgICAvLyB3aGljaCBtYXkgbm90IG1hdGNoIGZvciB0aGlyZCBwYXJ0eSByZW5kZXJlcnMuXG4gICAgcmVjb25jaWxlclZlcnNpb246IFJlYWN0VmVyc2lvblxuICB9KTtcbn1cblxuZXhwb3J0cy5hdHRlbXB0Q29udGludW91c0h5ZHJhdGlvbiA9IGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uO1xuZXhwb3J0cy5hdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkgPSBhdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHk7XG5leHBvcnRzLmF0dGVtcHRTeW5jaHJvbm91c0h5ZHJhdGlvbiA9IGF0dGVtcHRTeW5jaHJvbm91c0h5ZHJhdGlvbjtcbmV4cG9ydHMuYmF0Y2hlZFVwZGF0ZXMgPSBiYXRjaGVkVXBkYXRlcztcbmV4cG9ydHMuY3JlYXRlQ29tcG9uZW50U2VsZWN0b3IgPSBjcmVhdGVDb21wb25lbnRTZWxlY3RvcjtcbmV4cG9ydHMuY3JlYXRlQ29udGFpbmVyID0gY3JlYXRlQ29udGFpbmVyO1xuZXhwb3J0cy5jcmVhdGVIYXNQc2V1ZG9DbGFzc1NlbGVjdG9yID0gY3JlYXRlSGFzUHNldWRvQ2xhc3NTZWxlY3RvcjtcbmV4cG9ydHMuY3JlYXRlSHlkcmF0aW9uQ29udGFpbmVyID0gY3JlYXRlSHlkcmF0aW9uQ29udGFpbmVyO1xuZXhwb3J0cy5jcmVhdGVQb3J0YWwgPSBjcmVhdGVQb3J0YWw7XG5leHBvcnRzLmNyZWF0ZVJvbGVTZWxlY3RvciA9IGNyZWF0ZVJvbGVTZWxlY3RvcjtcbmV4cG9ydHMuY3JlYXRlVGVzdE5hbWVTZWxlY3RvciA9IGNyZWF0ZVRlc3ROYW1lU2VsZWN0b3I7XG5leHBvcnRzLmNyZWF0ZVRleHRTZWxlY3RvciA9IGNyZWF0ZVRleHRTZWxlY3RvcjtcbmV4cG9ydHMuZGVmYXVsdE9uQ2F1Z2h0RXJyb3IgPSBkZWZhdWx0T25DYXVnaHRFcnJvcjtcbmV4cG9ydHMuZGVmYXVsdE9uUmVjb3ZlcmFibGVFcnJvciA9IGRlZmF1bHRPblJlY292ZXJhYmxlRXJyb3I7XG5leHBvcnRzLmRlZmF1bHRPblVuY2F1Z2h0RXJyb3IgPSBkZWZhdWx0T25VbmNhdWdodEVycm9yO1xuZXhwb3J0cy5kZWZlcnJlZFVwZGF0ZXMgPSBkZWZlcnJlZFVwZGF0ZXM7XG5leHBvcnRzLmRpc2NyZXRlVXBkYXRlcyA9IGRpc2NyZXRlVXBkYXRlcztcbmV4cG9ydHMuZmluZEFsbE5vZGVzID0gZmluZEFsbE5vZGVzO1xuZXhwb3J0cy5maW5kQm91bmRpbmdSZWN0cyA9IGZpbmRCb3VuZGluZ1JlY3RzO1xuZXhwb3J0cy5maW5kSG9zdEluc3RhbmNlID0gZmluZEhvc3RJbnN0YW5jZTtcbmV4cG9ydHMuZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMgPSBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscztcbmV4cG9ydHMuZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nID0gZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nO1xuZXhwb3J0cy5mbHVzaFBhc3NpdmVFZmZlY3RzID0gZmx1c2hQYXNzaXZlRWZmZWN0cztcbmV4cG9ydHMuZmx1c2hTeW5jRnJvbVJlY29uY2lsZXIgPSBmbHVzaFN5bmNGcm9tUmVjb25jaWxlcjtcbmV4cG9ydHMuZmx1c2hTeW5jV29yayA9IGZsdXNoU3luY1dvcms7XG5leHBvcnRzLmZvY3VzV2l0aGluID0gZm9jdXNXaXRoaW47XG5leHBvcnRzLmdldEZpbmRBbGxOb2Rlc0ZhaWx1cmVEZXNjcmlwdGlvbiA9IGdldEZpbmRBbGxOb2Rlc0ZhaWx1cmVEZXNjcmlwdGlvbjtcbmV4cG9ydHMuZ2V0UHVibGljUm9vdEluc3RhbmNlID0gZ2V0UHVibGljUm9vdEluc3RhbmNlO1xuZXhwb3J0cy5pbmplY3RJbnRvRGV2VG9vbHMgPSBpbmplY3RJbnRvRGV2VG9vbHM7XG5leHBvcnRzLmlzQWxyZWFkeVJlbmRlcmluZyA9IGlzQWxyZWFkeVJlbmRlcmluZztcbmV4cG9ydHMub2JzZXJ2ZVZpc2libGVSZWN0cyA9IG9ic2VydmVWaXNpYmxlUmVjdHM7XG5leHBvcnRzLnNob3VsZEVycm9yID0gc2hvdWxkRXJyb3I7XG5leHBvcnRzLnNob3VsZFN1c3BlbmQgPSBzaG91bGRTdXNwZW5kO1xuZXhwb3J0cy5zdGFydEhvc3RUcmFuc2l0aW9uID0gc3RhcnRIb3N0VHJhbnNpdGlvbjtcbmV4cG9ydHMudXBkYXRlQ29udGFpbmVyID0gdXBkYXRlQ29udGFpbmVyO1xuZXhwb3J0cy51cGRhdGVDb250YWluZXJTeW5jID0gdXBkYXRlQ29udGFpbmVyU3luYztcbiAgICByZXR1cm4gZXhwb3J0cztcbiAgfTtcbiAgbW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IG1vZHVsZS5leHBvcnRzO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkobW9kdWxlLmV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJtb2R1bGUiLCJleHBvcnRzIiwiJCQkcmVjb25jaWxlciIsIiQkJGNvbmZpZyIsIlJlYWN0IiwicmVxdWlyZSIsIlNjaGVkdWxlciIsIlJlYWN0U2hhcmVkSW50ZXJuYWxzIiwiX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFIiwic3VwcHJlc3NXYXJuaW5nIiwic2V0U3VwcHJlc3NXYXJuaW5nIiwibmV3U3VwcHJlc3NXYXJuaW5nIiwid2FybiIsImZvcm1hdCIsIl9sZW4iLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJhcmdzIiwiQXJyYXkiLCJfa2V5IiwicHJpbnRXYXJuaW5nIiwiZXJyb3IiLCJfbGVuMiIsIl9rZXkyIiwibGV2ZWwiLCJpc0Vycm9yTG9nZ2VyIiwiZ2V0Q3VycmVudFN0YWNrIiwic3RhY2siLCJjb25jYXQiLCJ1bnNoaWZ0IiwibWFwIiwiaXRlbSIsIlN0cmluZyIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsImFzc2lnbiIsIk9iamVjdCIsIkxlZ2FjeVJvb3QiLCJDb25jdXJyZW50Um9vdCIsImdldCIsImtleSIsIl9yZWFjdEludGVybmFscyIsInNldCIsInZhbHVlIiwiZmF2b3JTYWZldHlPdmVySHlkcmF0aW9uUGVyZiIsImVuYWJsZUFzeW5jQWN0aW9ucyIsImRpc2FibGVEZWZhdWx0UHJvcHNFeGNlcHRGb3JDbGFzc2VzIiwiZW5hYmxlU3VzcGVuc2VDYWxsYmFjayIsImVuYWJsZUFzeW5jSXRlcmFibGVDaGlsZHJlbiIsImVuYWJsZUxhenlDb250ZXh0UHJvcGFnYXRpb24iLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJhbHdheXNUaHJvdHRsZVJldHJpZXMiLCJwYXNzQ2hpbGRyZW5XaGVuQ2xvbmluZ1BlcnNpc3RlZE5vZGVzIiwic3luY0xhbmVFeHBpcmF0aW9uTXMiLCJ0cmFuc2l0aW9uTGFuZUV4cGlyYXRpb25NcyIsImRpc2FibGVMZWdhY3lNb2RlIiwiZW5hYmxlU2NoZWR1bGluZ1Byb2ZpbGVyIiwiZW5hYmxlUHJvZmlsZXJUaW1lciIsImVuYWJsZVByb2ZpbGVyQ29tbWl0SG9va3MiLCJlbmFibGVQcm9maWxlck5lc3RlZFVwZGF0ZVBoYXNlIiwiRnVuY3Rpb25Db21wb25lbnQiLCJDbGFzc0NvbXBvbmVudCIsIkhvc3RSb290IiwiSG9zdFBvcnRhbCIsIkhvc3RDb21wb25lbnQiLCJIb3N0VGV4dCIsIkZyYWdtZW50IiwiTW9kZSIsIkNvbnRleHRDb25zdW1lciIsIkNvbnRleHRQcm92aWRlciIsIkZvcndhcmRSZWYiLCJQcm9maWxlciIsIlN1c3BlbnNlQ29tcG9uZW50IiwiTWVtb0NvbXBvbmVudCIsIlNpbXBsZU1lbW9Db21wb25lbnQiLCJMYXp5Q29tcG9uZW50IiwiSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50IiwiRGVoeWRyYXRlZEZyYWdtZW50IiwiU3VzcGVuc2VMaXN0Q29tcG9uZW50IiwiU2NvcGVDb21wb25lbnQiLCJPZmZzY3JlZW5Db21wb25lbnQiLCJMZWdhY3lIaWRkZW5Db21wb25lbnQiLCJDYWNoZUNvbXBvbmVudCIsIlRyYWNpbmdNYXJrZXJDb21wb25lbnQiLCJIb3N0SG9pc3RhYmxlIiwiSG9zdFNpbmdsZXRvbiIsIkluY29tcGxldGVGdW5jdGlvbkNvbXBvbmVudCIsIlJFQUNUX0xFR0FDWV9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05TVU1FUl9UWVBFIiwiUkVBQ1RfQ09OVEVYVF9UWVBFIiwiUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX1RZUEUiLCJSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUiLCJSRUFDVF9NRU1PX1RZUEUiLCJSRUFDVF9MQVpZX1RZUEUiLCJSRUFDVF9TQ09QRV9UWVBFIiwiUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUiLCJSRUFDVF9PRkZTQ1JFRU5fVFlQRSIsIlJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSIsIlJFQUNUX1RSQUNJTkdfTUFSS0VSX1RZUEUiLCJSRUFDVF9NRU1PX0NBQ0hFX1NFTlRJTkVMIiwiTUFZQkVfSVRFUkFUT1JfU1lNQk9MIiwiaXRlcmF0b3IiLCJGQVVYX0lURVJBVE9SX1NZTUJPTCIsImdldEl0ZXJhdG9yRm4iLCJtYXliZUl0ZXJhYmxlIiwibWF5YmVJdGVyYXRvciIsImdldFdyYXBwZWROYW1lJDEiLCJvdXRlclR5cGUiLCJpbm5lclR5cGUiLCJ3cmFwcGVyTmFtZSIsImRpc3BsYXlOYW1lIiwiZnVuY3Rpb25OYW1lIiwibmFtZSIsImdldENvbnRleHROYW1lJDEiLCJ0eXBlIiwiUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsIiQkdHlwZW9mIiwidGFnIiwiY29udGV4dCIsImNvbnN1bWVyIiwiX2NvbnRleHQiLCJyZW5kZXIiLCJvdXRlck5hbWUiLCJsYXp5Q29tcG9uZW50IiwicGF5bG9hZCIsIl9wYXlsb2FkIiwiaW5pdCIsIl9pbml0IiwieCIsImdldFdyYXBwZWROYW1lIiwiZ2V0Q29udGV4dE5hbWUiLCJnZXRDb21wb25lbnROYW1lRnJvbU93bmVyIiwib3duZXIiLCJnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyIiwiZmliZXIiLCJOb0ZsYWdzJDEiLCJQZXJmb3JtZWRXb3JrIiwiUGxhY2VtZW50IiwiRGlkQ2FwdHVyZSIsIkh5ZHJhdGluZyIsIlVwZGF0ZSIsIkNoaWxkRGVsZXRpb24iLCJDb250ZW50UmVzZXQiLCJDYWxsYmFjayIsIkZvcmNlQ2xpZW50UmVuZGVyIiwiUmVmIiwiU25hcHNob3QiLCJQYXNzaXZlJDEiLCJWaXNpYmlsaXR5IiwiU3RvcmVDb25zaXN0ZW5jeSIsIlNjaGVkdWxlUmV0cnkiLCJTaG91bGRTdXNwZW5kQ29tbWl0IiwiRGlkRGVmZXIiLCJGb3JtUmVzZXQiLCJIb3N0RWZmZWN0TWFzayIsIkluY29tcGxldGUiLCJTaG91bGRDYXB0dXJlIiwiRm9yY2VVcGRhdGVGb3JMZWdhY3lTdXNwZW5zZSIsIkZvcmtlZCIsIlJlZlN0YXRpYyIsIkxheW91dFN0YXRpYyIsIlBhc3NpdmVTdGF0aWMiLCJNYXlTdXNwZW5kQ29tbWl0IiwiUGxhY2VtZW50REVWIiwiTW91bnRMYXlvdXREZXYiLCJNb3VudFBhc3NpdmVEZXYiLCJCZWZvcmVNdXRhdGlvbk1hc2siLCJNdXRhdGlvbk1hc2siLCJMYXlvdXRNYXNrIiwiUGFzc2l2ZU1hc2siLCJTdGF0aWNNYXNrIiwiZGlzYWJsZWREZXB0aCIsInByZXZMb2ciLCJwcmV2SW5mbyIsInByZXZXYXJuIiwicHJldkVycm9yIiwicHJldkdyb3VwIiwicHJldkdyb3VwQ29sbGFwc2VkIiwicHJldkdyb3VwRW5kIiwiZGlzYWJsZWRMb2ciLCJfX3JlYWN0RGlzYWJsZWRMb2ciLCJkaXNhYmxlTG9ncyIsImxvZyIsImluZm8iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJwcm9wcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsImRlZmluZVByb3BlcnRpZXMiLCJyZWVuYWJsZUxvZ3MiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInVuZGVmaW5lZCIsIkVycm9yIiwibWF0Y2giLCJ0cmltIiwiZGVzY3JpYmVEZWJ1Z0luZm9GcmFtZSIsImVudiIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwJDEiLCJXZWFrTWFwIiwiTWFwIiwiZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSIsImZuIiwiY29uc3RydWN0IiwiZnJhbWUiLCJwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlIiwicHJlcGFyZVN0YWNrVHJhY2UiLCJwcmV2aW91c0Rpc3BhdGNoZXIiLCJIIiwiUnVuSW5Sb290RnJhbWUiLCJEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QiLCJjb250cm9sIiwiRmFrZSIsImRlZmluZVByb3BlcnR5IiwiUmVmbGVjdCIsIm1heWJlUHJvbWlzZSIsImNhdGNoIiwic2FtcGxlIiwibmFtZVByb3BEZXNjcmlwdG9yIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiX1J1bkluUm9vdEZyYW1lJERldGVyIiwic2FtcGxlU3RhY2siLCJjb250cm9sU3RhY2siLCJzYW1wbGVMaW5lcyIsInNwbGl0IiwiY29udHJvbExpbmVzIiwicyIsImMiLCJpbmNsdWRlcyIsIl9mcmFtZSIsInJlcGxhY2UiLCJzeW50aGV0aWNGcmFtZSIsImRlc2NyaWJlQ2xhc3NDb21wb25lbnRGcmFtZSIsImN0b3IiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJkZXNjcmliZUZpYmVyIiwiZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kIiwid29ya0luUHJvZ3Jlc3MiLCJub2RlIiwiZGVidWdJbmZvIiwiX2RlYnVnSW5mbyIsImkiLCJlbnRyeSIsInJldHVybiIsIm1lc3NhZ2UiLCJjdXJyZW50IiwiaXNSZW5kZXJpbmciLCJnZXRDdXJyZW50RmliZXJTdGFja0luRGV2IiwicmVzZXRDdXJyZW50RGVidWdGaWJlckluREVWIiwicmVzZXRDdXJyZW50RmliZXIiLCJzZXRDdXJyZW50RGVidWdGaWJlckluREVWIiwic2V0Q3VycmVudEZpYmVyIiwiZ2V0Q3VycmVudEZpYmVyIiwic2V0SXNSZW5kZXJpbmciLCJyZW5kZXJpbmciLCJnZXROZWFyZXN0TW91bnRlZEZpYmVyIiwibmVhcmVzdE1vdW50ZWQiLCJhbHRlcm5hdGUiLCJuZXh0Tm9kZSIsImZsYWdzIiwiaXNNb3VudGVkIiwiY29tcG9uZW50Iiwib3duZXJGaWJlciIsImluc3RhbmNlIiwic3RhdGVOb2RlIiwiX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyIiwiYXNzZXJ0SXNNb3VudGVkIiwiZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgiLCJhIiwiYiIsInBhcmVudEEiLCJwYXJlbnRCIiwibmV4dFBhcmVudCIsImNoaWxkIiwic2libGluZyIsImRpZEZpbmRDaGlsZCIsIl9jaGlsZCIsImZpbmRDdXJyZW50SG9zdEZpYmVyIiwicGFyZW50IiwiY3VycmVudFBhcmVudCIsImZpbmRDdXJyZW50SG9zdEZpYmVySW1wbCIsImZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFscyIsImZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFsc0ltcGwiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJnZXRQdWJsaWNJbnN0YW5jZSIsImdldFJvb3RIb3N0Q29udGV4dCIsImdldENoaWxkSG9zdENvbnRleHQiLCJwcmVwYXJlRm9yQ29tbWl0IiwicmVzZXRBZnRlckNvbW1pdCIsImNyZWF0ZUluc3RhbmNlIiwiYXBwZW5kSW5pdGlhbENoaWxkIiwiZmluYWxpemVJbml0aWFsQ2hpbGRyZW4iLCJzaG91bGRTZXRUZXh0Q29udGVudCIsImNyZWF0ZVRleHRJbnN0YW5jZSIsInNjaGVkdWxlVGltZW91dCIsImNhbmNlbFRpbWVvdXQiLCJub1RpbWVvdXQiLCJpc1ByaW1hcnlSZW5kZXJlciIsIndhcm5zSWZOb3RBY3RpbmciLCJzdXBwb3J0c011dGF0aW9uIiwic3VwcG9ydHNQZXJzaXN0ZW5jZSIsInN1cHBvcnRzSHlkcmF0aW9uIiwiZ2V0SW5zdGFuY2VGcm9tTm9kZSIsImJlZm9yZUFjdGl2ZUluc3RhbmNlQmx1ciIsImFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyIiwicHJlcGFyZVBvcnRhbE1vdW50IiwicHJlcGFyZVNjb3BlVXBkYXRlIiwiZ2V0SW5zdGFuY2VGcm9tU2NvcGUiLCJzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkiLCJnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkiLCJyZXNvbHZlVXBkYXRlUHJpb3JpdHkiLCJzaG91bGRBdHRlbXB0RWFnZXJUcmFuc2l0aW9uIiwiZGV0YWNoRGVsZXRlZEluc3RhbmNlIiwicmVxdWVzdFBvc3RQYWludENhbGxiYWNrIiwibWF5U3VzcGVuZENvbW1pdCIsInByZWxvYWRJbnN0YW5jZSIsInN0YXJ0U3VzcGVuZGluZ0NvbW1pdCIsInN1c3BlbmRJbnN0YW5jZSIsIndhaXRGb3JDb21taXRUb0JlUmVhZHkiLCJOb3RQZW5kaW5nVHJhbnNpdGlvbiIsInJlc2V0Rm9ybUluc3RhbmNlIiwic3VwcG9ydHNNaWNyb3Rhc2tzIiwic2NoZWR1bGVNaWNyb3Rhc2siLCJzdXBwb3J0c1Rlc3RTZWxlY3RvcnMiLCJmaW5kRmliZXJSb290IiwiZ2V0Qm91bmRpbmdSZWN0IiwiZ2V0VGV4dENvbnRlbnQiLCJpc0hpZGRlblN1YnRyZWUiLCJtYXRjaEFjY2Vzc2liaWxpdHlSb2xlIiwic2V0Rm9jdXNJZkZvY3VzYWJsZSIsInNldHVwSW50ZXJzZWN0aW9uT2JzZXJ2ZXIiLCJhcHBlbmRDaGlsZCIsImFwcGVuZENoaWxkVG9Db250YWluZXIiLCJjb21taXRUZXh0VXBkYXRlIiwiY29tbWl0TW91bnQiLCJjb21taXRVcGRhdGUiLCJpbnNlcnRCZWZvcmUiLCJpbnNlcnRJbkNvbnRhaW5lckJlZm9yZSIsInJlbW92ZUNoaWxkIiwicmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyIiwicmVzZXRUZXh0Q29udGVudCIsImhpZGVJbnN0YW5jZSIsImhpZGVUZXh0SW5zdGFuY2UiLCJ1bmhpZGVJbnN0YW5jZSIsInVuaGlkZVRleHRJbnN0YW5jZSIsImNsZWFyQ29udGFpbmVyIiwiY2xvbmVJbnN0YW5jZSIsImNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0IiwiYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0IiwiZmluYWxpemVDb250YWluZXJDaGlsZHJlbiIsInJlcGxhY2VDb250YWluZXJDaGlsZHJlbiIsImNsb25lSGlkZGVuSW5zdGFuY2UiLCJjbG9uZUhpZGRlblRleHRJbnN0YW5jZSIsImlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmciLCJpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayIsImdldFN1c3BlbnNlSW5zdGFuY2VGYWxsYmFja0Vycm9yRGV0YWlscyIsInJlZ2lzdGVyU3VzcGVuc2VJbnN0YW5jZVJldHJ5IiwiY2FuSHlkcmF0ZUZvcm1TdGF0ZU1hcmtlciIsImlzRm9ybVN0YXRlTWFya2VyTWF0Y2hpbmciLCJnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmciLCJnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCIsImdldEZpcnN0SHlkcmF0YWJsZUNoaWxkV2l0aGluQ29udGFpbmVyIiwiZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5TdXNwZW5zZUluc3RhbmNlIiwiY2FuSHlkcmF0ZUluc3RhbmNlIiwiY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSIsImNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlIiwiaHlkcmF0ZUluc3RhbmNlIiwiaHlkcmF0ZVRleHRJbnN0YW5jZSIsImh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlIiwiZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZSIsImNvbW1pdEh5ZHJhdGVkQ29udGFpbmVyIiwiY29tbWl0SHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlIiwiY2xlYXJTdXNwZW5zZUJvdW5kYXJ5IiwiY2xlYXJTdXNwZW5zZUJvdW5kYXJ5RnJvbUNvbnRhaW5lciIsInNob3VsZERlbGV0ZVVuaHlkcmF0ZWRUYWlsSW5zdGFuY2VzIiwiZGlmZkh5ZHJhdGVkUHJvcHNGb3JEZXZXYXJuaW5ncyIsImRpZmZIeWRyYXRlZFRleHRGb3JEZXZXYXJuaW5ncyIsImRlc2NyaWJlSHlkcmF0YWJsZUluc3RhbmNlRm9yRGV2V2FybmluZ3MiLCJ2YWxpZGF0ZUh5ZHJhdGFibGVJbnN0YW5jZSIsInZhbGlkYXRlSHlkcmF0YWJsZVRleHRJbnN0YW5jZSIsInN1cHBvcnRzUmVzb3VyY2VzIiwiaXNIb3N0SG9pc3RhYmxlVHlwZSIsImdldEhvaXN0YWJsZVJvb3QiLCJnZXRSZXNvdXJjZSIsImFjcXVpcmVSZXNvdXJjZSIsInJlbGVhc2VSZXNvdXJjZSIsImh5ZHJhdGVIb2lzdGFibGUiLCJtb3VudEhvaXN0YWJsZSIsInVubW91bnRIb2lzdGFibGUiLCJjcmVhdGVIb2lzdGFibGVJbnN0YW5jZSIsInByZXBhcmVUb0NvbW1pdEhvaXN0YWJsZXMiLCJtYXlSZXNvdXJjZVN1c3BlbmRDb21taXQiLCJwcmVsb2FkUmVzb3VyY2UiLCJzdXNwZW5kUmVzb3VyY2UiLCJzdXBwb3J0c1NpbmdsZXRvbnMiLCJyZXNvbHZlU2luZ2xldG9uSW5zdGFuY2UiLCJjbGVhclNpbmdsZXRvbiIsImFjcXVpcmVTaW5nbGV0b25JbnN0YW5jZSIsInJlbGVhc2VTaW5nbGV0b25JbnN0YW5jZSIsImlzSG9zdFNpbmdsZXRvblR5cGUiLCJ2YWx1ZVN0YWNrIiwiZmliZXJTdGFjayIsImluZGV4IiwiY3JlYXRlQ3Vyc29yIiwiZGVmYXVsdFZhbHVlIiwicG9wIiwiY3Vyc29yIiwicHVzaCIsImVtcHR5Q29udGV4dE9iamVjdCIsImZyZWV6ZSIsImhhc0NvbnRleHRDaGFuZ2VkIiwiaXNDb250ZXh0UHJvdmlkZXIiLCJwcm9jZXNzQ2hpbGRDb250ZXh0IiwicGFyZW50Q29udGV4dCIsImZpbmRDdXJyZW50VW5tYXNrZWRDb250ZXh0IiwiT2Zmc2NyZWVuVmlzaWJsZSIsIk9mZnNjcmVlbkRldGFjaGVkIiwiT2Zmc2NyZWVuUGFzc2l2ZUVmZmVjdHNDb25uZWN0ZWQiLCJpc09mZnNjcmVlbk1hbnVhbCIsIm9mZnNjcmVlbkZpYmVyIiwibWVtb2l6ZWRQcm9wcyIsIm1vZGUiLCJOb01vZGUiLCJDb25jdXJyZW50TW9kZSIsIlByb2ZpbGVNb2RlIiwiU3RyaWN0TGVnYWN5TW9kZSIsIlN0cmljdEVmZmVjdHNNb2RlIiwiTm9TdHJpY3RQYXNzaXZlRWZmZWN0c01vZGUiLCJjbHozMiIsIk1hdGgiLCJjbHozMkZhbGxiYWNrIiwibG9nJDEiLCJMTjIiLCJhc1VpbnQiLCJUb3RhbExhbmVzIiwiTm9MYW5lcyIsIk5vTGFuZSIsIlN5bmNIeWRyYXRpb25MYW5lIiwiU3luY0xhbmUiLCJTeW5jTGFuZUluZGV4IiwiSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZSIsIklucHV0Q29udGludW91c0xhbmUiLCJEZWZhdWx0SHlkcmF0aW9uTGFuZSIsIkRlZmF1bHRMYW5lIiwiU3luY1VwZGF0ZUxhbmVzIiwiVHJhbnNpdGlvbkh5ZHJhdGlvbkxhbmUiLCJUcmFuc2l0aW9uTGFuZXMiLCJUcmFuc2l0aW9uTGFuZTEiLCJUcmFuc2l0aW9uTGFuZTIiLCJUcmFuc2l0aW9uTGFuZTMiLCJUcmFuc2l0aW9uTGFuZTQiLCJUcmFuc2l0aW9uTGFuZTUiLCJUcmFuc2l0aW9uTGFuZTYiLCJUcmFuc2l0aW9uTGFuZTciLCJUcmFuc2l0aW9uTGFuZTgiLCJUcmFuc2l0aW9uTGFuZTkiLCJUcmFuc2l0aW9uTGFuZTEwIiwiVHJhbnNpdGlvbkxhbmUxMSIsIlRyYW5zaXRpb25MYW5lMTIiLCJUcmFuc2l0aW9uTGFuZTEzIiwiVHJhbnNpdGlvbkxhbmUxNCIsIlRyYW5zaXRpb25MYW5lMTUiLCJSZXRyeUxhbmVzIiwiUmV0cnlMYW5lMSIsIlJldHJ5TGFuZTIiLCJSZXRyeUxhbmUzIiwiUmV0cnlMYW5lNCIsIlNvbWVSZXRyeUxhbmUiLCJTZWxlY3RpdmVIeWRyYXRpb25MYW5lIiwiTm9uSWRsZUxhbmVzIiwiSWRsZUh5ZHJhdGlvbkxhbmUiLCJJZGxlTGFuZSIsIk9mZnNjcmVlbkxhbmUiLCJEZWZlcnJlZExhbmUiLCJVcGRhdGVMYW5lcyIsImdldExhYmVsRm9yTGFuZSIsImxhbmUiLCJOb1RpbWVzdGFtcCIsIm5leHRUcmFuc2l0aW9uTGFuZSIsIm5leHRSZXRyeUxhbmUiLCJnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyIsImxhbmVzIiwicGVuZGluZ1N5bmNMYW5lcyIsImdldEhpZ2hlc3RQcmlvcml0eUxhbmUiLCJnZXROZXh0TGFuZXMiLCJyb290Iiwid2lwTGFuZXMiLCJwZW5kaW5nTGFuZXMiLCJuZXh0TGFuZXMiLCJzdXNwZW5kZWRMYW5lcyIsInBpbmdlZExhbmVzIiwibm9uSWRsZVBlbmRpbmdMYW5lcyIsIm5vbklkbGVVbmJsb2NrZWRMYW5lcyIsIm5vbklkbGVQaW5nZWRMYW5lcyIsInVuYmxvY2tlZExhbmVzIiwibmV4dExhbmUiLCJ3aXBMYW5lIiwiZ2V0RW50YW5nbGVkTGFuZXMiLCJyZW5kZXJMYW5lcyIsImVudGFuZ2xlZExhbmVzIiwiYWxsRW50YW5nbGVkTGFuZXMiLCJlbnRhbmdsZW1lbnRzIiwicGlja0FyYml0cmFyeUxhbmVJbmRleCIsImNvbXB1dGVFeHBpcmF0aW9uVGltZSIsImN1cnJlbnRUaW1lIiwibWFya1N0YXJ2ZWRMYW5lc0FzRXhwaXJlZCIsImV4cGlyYXRpb25UaW1lcyIsImV4cGlyYXRpb25UaW1lIiwiZXhwaXJlZExhbmVzIiwiZ2V0SGlnaGVzdFByaW9yaXR5UGVuZGluZ0xhbmVzIiwiZ2V0TGFuZXNUb1JldHJ5U3luY2hyb25vdXNseU9uRXJyb3IiLCJvcmlnaW5hbGx5QXR0ZW1wdGVkTGFuZXMiLCJlcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyIsImV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW4iLCJpbmNsdWRlc1N5bmNMYW5lIiwiaW5jbHVkZXNOb25JZGxlV29yayIsImluY2x1ZGVzT25seVJldHJpZXMiLCJpbmNsdWRlc09ubHlOb25VcmdlbnRMYW5lcyIsIlVyZ2VudExhbmVzIiwiaW5jbHVkZXNPbmx5VHJhbnNpdGlvbnMiLCJpbmNsdWRlc0Jsb2NraW5nTGFuZSIsIlN5bmNEZWZhdWx0TGFuZXMiLCJpbmNsdWRlc0V4cGlyZWRMYW5lIiwiaXNUcmFuc2l0aW9uTGFuZSIsImNsYWltTmV4dFRyYW5zaXRpb25MYW5lIiwiY2xhaW1OZXh0UmV0cnlMYW5lIiwicGlja0FyYml0cmFyeUxhbmUiLCJsYW5lVG9JbmRleCIsImluY2x1ZGVzU29tZUxhbmUiLCJpc1N1YnNldE9mTGFuZXMiLCJzdWJzZXQiLCJtZXJnZUxhbmVzIiwicmVtb3ZlTGFuZXMiLCJpbnRlcnNlY3RMYW5lcyIsImxhbmVUb0xhbmVzIiwiaGlnaGVyUHJpb3JpdHlMYW5lIiwiY3JlYXRlTGFuZU1hcCIsImluaXRpYWwiLCJsYW5lTWFwIiwibWFya1Jvb3RVcGRhdGVkJDEiLCJ1cGRhdGVMYW5lIiwibWFya1Jvb3RTdXNwZW5kZWQkMSIsInNwYXduZWRMYW5lIiwibWFya1NwYXduZWREZWZlcnJlZExhbmUiLCJtYXJrUm9vdFBpbmdlZCQxIiwibWFya1Jvb3RGaW5pc2hlZCIsInJlbWFpbmluZ0xhbmVzIiwibm9Mb25nZXJQZW5kaW5nTGFuZXMiLCJzaGVsbFN1c3BlbmRDb3VudGVyIiwiaGlkZGVuVXBkYXRlcyIsImhpZGRlblVwZGF0ZXNGb3JMYW5lIiwidXBkYXRlIiwic3Bhd25lZExhbmVJbmRleCIsIm1hcmtSb290RW50YW5nbGVkIiwicm9vdEVudGFuZ2xlZExhbmVzIiwidXBncmFkZVBlbmRpbmdMYW5lVG9TeW5jIiwidXBncmFkZVBlbmRpbmdMYW5lc1RvU3luYyIsImxhbmVzVG9VcGdyYWRlIiwibWFya0hpZGRlblVwZGF0ZSIsImdldEJ1bXBlZExhbmVGb3JIeWRyYXRpb24iLCJyZW5kZXJMYW5lIiwiYWRkRmliZXJUb0xhbmVzTWFwIiwiaXNEZXZUb29sc1ByZXNlbnQiLCJwZW5kaW5nVXBkYXRlcnNMYW5lTWFwIiwidXBkYXRlcnMiLCJhZGQiLCJtb3ZlUGVuZGluZ0ZpYmVyc1RvTWVtb2l6ZWQiLCJtZW1vaXplZFVwZGF0ZXJzIiwic2l6ZSIsImZvckVhY2giLCJoYXMiLCJjbGVhciIsImdldFRyYW5zaXRpb25zRm9yTGFuZXMiLCJEaXNjcmV0ZUV2ZW50UHJpb3JpdHkiLCJDb250aW51b3VzRXZlbnRQcmlvcml0eSIsIkRlZmF1bHRFdmVudFByaW9yaXR5IiwiSWRsZUV2ZW50UHJpb3JpdHkiLCJoaWdoZXJFdmVudFByaW9yaXR5IiwibG93ZXJFdmVudFByaW9yaXR5IiwiaXNIaWdoZXJFdmVudFByaW9yaXR5IiwiZXZlbnRQcmlvcml0eVRvTGFuZSIsInVwZGF0ZVByaW9yaXR5IiwibGFuZXNUb0V2ZW50UHJpb3JpdHkiLCJzY2hlZHVsZUNhbGxiYWNrJDMiLCJ1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrIiwiY2FuY2VsQ2FsbGJhY2skMSIsInVuc3RhYmxlX2NhbmNlbENhbGxiYWNrIiwic2hvdWxkWWllbGQiLCJ1bnN0YWJsZV9zaG91bGRZaWVsZCIsInJlcXVlc3RQYWludCIsInVuc3RhYmxlX3JlcXVlc3RQYWludCIsIm5vdyQxIiwidW5zdGFibGVfbm93IiwiSW1tZWRpYXRlUHJpb3JpdHkiLCJ1bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSIsIlVzZXJCbG9ja2luZ1ByaW9yaXR5IiwidW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHkiLCJOb3JtYWxQcmlvcml0eSQxIiwidW5zdGFibGVfTm9ybWFsUHJpb3JpdHkiLCJJZGxlUHJpb3JpdHkiLCJ1bnN0YWJsZV9JZGxlUHJpb3JpdHkiLCJ1bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZSIsInJlbmRlcmVySUQiLCJpbmplY3RlZEhvb2siLCJpbmplY3RlZFByb2ZpbGluZ0hvb2tzIiwiaGFzTG9nZ2VkRXJyb3IiLCJfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJpbmplY3RJbnRlcm5hbHMiLCJpbnRlcm5hbHMiLCJob29rIiwiaXNEaXNhYmxlZCIsInN1cHBvcnRzRmliZXIiLCJnZXRMYW5lTGFiZWxNYXAiLCJpbmplY3RQcm9maWxpbmdIb29rcyIsImluamVjdCIsImVyciIsImNoZWNrRENFIiwib25TY2hlZHVsZVJvb3QiLCJjaGlsZHJlbiIsIm9uU2NoZWR1bGVGaWJlclJvb3QiLCJvbkNvbW1pdFJvb3QkMSIsImV2ZW50UHJpb3JpdHkiLCJvbkNvbW1pdEZpYmVyUm9vdCIsImRpZEVycm9yIiwic2NoZWR1bGVyUHJpb3JpdHkiLCJvblBvc3RDb21taXRSb290Iiwib25Qb3N0Q29tbWl0RmliZXJSb290Iiwib25Db21taXRVbm1vdW50Iiwib25Db21taXRGaWJlclVubW91bnQiLCJzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyIsIm5ld0lzU3RyaWN0TW9kZSIsInNldFN0cmljdE1vZGUiLCJwcm9maWxpbmdIb29rcyIsImxhYmVsIiwibWFya0NvbW1pdFN0YXJ0ZWQiLCJtYXJrQ29tbWl0U3RvcHBlZCIsIm1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkIiwibWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQiLCJtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RhcnRlZCIsIm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkIiwibWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RhcnRlZCIsIm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkIiwibWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RvcHBlZCIsIm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RhcnRlZCIsIm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCIsIm1hcmtDb21wb25lbnRFcnJvcmVkIiwidGhyb3duVmFsdWUiLCJtYXJrQ29tcG9uZW50U3VzcGVuZGVkIiwid2FrZWFibGUiLCJtYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQiLCJtYXJrTGF5b3V0RWZmZWN0c1N0b3BwZWQiLCJtYXJrUGFzc2l2ZUVmZmVjdHNTdGFydGVkIiwibWFya1Bhc3NpdmVFZmZlY3RzU3RvcHBlZCIsIm1hcmtSZW5kZXJTdGFydGVkIiwibWFya1JlbmRlcllpZWxkZWQiLCJtYXJrUmVuZGVyU3RvcHBlZCIsIm1hcmtSZW5kZXJTY2hlZHVsZWQiLCJtYXJrRm9yY2VVcGRhdGVTY2hlZHVsZWQiLCJtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQiLCJpcyIsInkiLCJvYmplY3RJcyIsImlzUm9vdERlaHlkcmF0ZWQiLCJjdXJyZW50U3RhdGUiLCJtZW1vaXplZFN0YXRlIiwiaXNEZWh5ZHJhdGVkIiwiQ2FwdHVyZWRTdGFja3MiLCJjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlciIsInNvdXJjZSIsImNhcHR1cmVkU3RhY2siLCJjcmVhdGVDYXB0dXJlZFZhbHVlRnJvbUVycm9yIiwiZm9ya1N0YWNrIiwiZm9ya1N0YWNrSW5kZXgiLCJ0cmVlRm9ya1Byb3ZpZGVyIiwidHJlZUZvcmtDb3VudCIsImlkU3RhY2siLCJpZFN0YWNrSW5kZXgiLCJ0cmVlQ29udGV4dFByb3ZpZGVyIiwidHJlZUNvbnRleHRJZCIsInRyZWVDb250ZXh0T3ZlcmZsb3ciLCJpc0ZvcmtlZENoaWxkIiwid2FybklmTm90SHlkcmF0aW5nIiwiZ2V0Rm9ya3NBdExldmVsIiwiZ2V0VHJlZUlkIiwib3ZlcmZsb3ciLCJpZFdpdGhMZWFkaW5nQml0IiwiaWQiLCJnZXRMZWFkaW5nQml0IiwidG9TdHJpbmciLCJwdXNoVHJlZUZvcmsiLCJ0b3RhbENoaWxkcmVuIiwicHVzaFRyZWVJZCIsImJhc2VJZFdpdGhMZWFkaW5nQml0IiwiYmFzZU92ZXJmbG93IiwiYmFzZUxlbmd0aCIsImdldEJpdExlbmd0aCIsImJhc2VJZCIsInNsb3QiLCJudW1iZXJPZk92ZXJmbG93Qml0cyIsIm5ld092ZXJmbG93Qml0cyIsIm5ld092ZXJmbG93IiwicmVzdE9mQmFzZUlkIiwicmVzdE9mQmFzZUxlbmd0aCIsInJlc3RPZkxlbmd0aCIsInJlc3RPZk5ld0JpdHMiLCJuZXdCaXRzIiwiX2lkIiwiX292ZXJmbG93IiwicHVzaE1hdGVyaWFsaXplZFRyZWVJZCIsInJldHVybkZpYmVyIiwibnVtYmVyT2ZGb3JrcyIsInNsb3RJbmRleCIsIm51bWJlciIsInBvcFRyZWVDb250ZXh0IiwiZ2V0U3VzcGVuZGVkVHJlZUNvbnRleHQiLCJyZXN0b3JlU3VzcGVuZGVkVHJlZUNvbnRleHQiLCJzdXNwZW5kZWRDb250ZXh0IiwiZ2V0SXNIeWRyYXRpbmciLCJjb250ZXh0U3RhY2tDdXJzb3IiLCJjb250ZXh0RmliZXJTdGFja0N1cnNvciIsInJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yIiwiaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvciIsIkhvc3RUcmFuc2l0aW9uQ29udGV4dCIsIlByb3ZpZGVyIiwiQ29uc3VtZXIiLCJfY3VycmVudFZhbHVlIiwiX2N1cnJlbnRWYWx1ZTIiLCJfdGhyZWFkQ291bnQiLCJyZXF1aXJlZENvbnRleHQiLCJnZXRSb290SG9zdENvbnRhaW5lciIsInJvb3RJbnN0YW5jZSIsInB1c2hIb3N0Q29udGFpbmVyIiwibmV4dFJvb3RJbnN0YW5jZSIsIm5leHRSb290Q29udGV4dCIsInBvcEhvc3RDb250YWluZXIiLCJnZXRIb3N0Q29udGV4dCIsInB1c2hIb3N0Q29udGV4dCIsInN0YXRlSG9vayIsIm5leHRDb250ZXh0IiwicG9wSG9zdENvbnRleHQiLCJtYXhSb3dMZW5ndGgiLCJpZGVhbERlcHRoIiwiZmluZE5vdGFibGVOb2RlIiwiaW5kZW50Iiwic2VydmVyUHJvcHMiLCJzZXJ2ZXJUYWlsIiwiZGlzdGFuY2VGcm9tTGVhZiIsImluZGVudGF0aW9uIiwicmVwZWF0IiwiYWRkZWQiLCJyZW1vdmVkIiwiZGVzY3JpYmVGaWJlclR5cGUiLCJjdHIiLCJuZWVkc0VzY2FwaW5nIiwiZGVzY3JpYmVUZXh0Tm9kZSIsImNvbnRlbnQiLCJtYXhMZW5ndGgiLCJ0ZXN0IiwiZW5jb2RlZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJzbGljZSIsImRlc2NyaWJlVGV4dERpZmYiLCJjbGllbnRUZXh0Iiwic2VydmVyVGV4dCIsImZpcnN0RGlmZiIsImNoYXJDb2RlQXQiLCJvYmplY3ROYW1lIiwib2JqZWN0IiwibSIsInAwIiwiZGVzY3JpYmVWYWx1ZSIsInByb3BlcnRpZXMiLCJwcm9wTmFtZSIsImhhc093blByb3BlcnR5IiwianNvblByb3BOYW1lIiwicHJvcFZhbHVlIiwiX25hbWUiLCJkZXNjcmliZVByb3BWYWx1ZSIsImRlc2NyaWJlQ29sbGFwc2VkRWxlbWVudCIsImRlc2NyaWJlRXhwYW5kZWRFbGVtZW50Iiwicm93UHJlZml4IiwicmVtYWluaW5nUm93TGVuZ3RoIiwiam9pbiIsImRlc2NyaWJlUHJvcGVydGllc0RpZmYiLCJjbGllbnRPYmplY3QiLCJzZXJ2ZXJPYmplY3QiLCJyZW1haW5pbmdTZXJ2ZXJQcm9wZXJ0aWVzIiwiY2xpZW50VmFsdWUiLCJjbGllbnRQcm9wVmFsdWUiLCJzZXJ2ZXJWYWx1ZSIsInNlcnZlclByb3BWYWx1ZSIsIl9wcm9wTmFtZSIsIl9tYXhMZW5ndGgiLCJfc2VydmVyVmFsdWUiLCJfc2VydmVyUHJvcFZhbHVlIiwiZGVzY3JpYmVFbGVtZW50RGlmZiIsImNsaWVudFByb3BzIiwic2VydmVyUHJvcE5hbWVzIiwidG9Mb3dlckNhc2UiLCJfcHJvcE5hbWUyIiwic2VydmVyUHJvcE5hbWUiLCJkZWxldGUiLCJrZXlzIiwiaW5kZXhPZiIsInNlcnZlckNoaWxkcmVuIiwiY2xpZW50Q2hpbGRyZW4iLCJkZXNjcmliZVNpYmxpbmdGaWJlciIsImZsYXRDb250ZW50IiwiY2hpbGRGaWJlciIsImRlc2NyaWJlTm9kZSIsInNraXBUb05vZGUiLCJwYXJlbnRDb250ZW50Iiwic2VydmVyQ29tcG9uZW50TmFtZSIsInNlbGZDb250ZW50IiwicGVuZGluZ1Byb3BzIiwiY2hpbGRDb250ZW50IiwiZGlmZklkeCIsImNoaWxkTm9kZSIsIl9pIiwidGFpbE5vZGUiLCJkZXNjcmliZURpZmYiLCJyb290Tm9kZSIsImh5ZHJhdGlvblBhcmVudEZpYmVyIiwibmV4dEh5ZHJhdGFibGVJbnN0YW5jZSIsImlzSHlkcmF0aW5nIiwiZGlkU3VzcGVuZE9yRXJyb3JERVYiLCJoeWRyYXRpb25EaWZmUm9vdERFViIsImh5ZHJhdGlvbkVycm9ycyIsInJvb3RPclNpbmdsZXRvbkNvbnRleHQiLCJidWlsZEh5ZHJhdGlvbkRpZmZOb2RlIiwic2libGluZ3MiLCJleGlzdGluZyIsIm5ld05vZGUiLCJ3YXJuSWZIeWRyYXRpbmciLCJtYXJrRGlkVGhyb3dXaGlsZUh5ZHJhdGluZ0RFViIsImVudGVySHlkcmF0aW9uU3RhdGUiLCJwYXJlbnRJbnN0YW5jZSIsImNvbnRhaW5lckluZm8iLCJyZWVudGVySHlkcmF0aW9uU3RhdGVGcm9tRGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UiLCJzdXNwZW5zZUluc3RhbmNlIiwidHJlZUNvbnRleHQiLCJ3YXJuTm9uSHlkcmF0ZWRJbnN0YW5jZSIsInJlamVjdGVkQ2FuZGlkYXRlIiwiZGlmZk5vZGUiLCJkZXNjcmlwdGlvbiIsInRyeUh5ZHJhdGVJbnN0YW5jZSIsIm5leHRJbnN0YW5jZSIsImhvc3RDb250ZXh0IiwiZGlmZmVyZW5jZXMiLCJ0cnlIeWRyYXRlVGV4dCIsInRleHQiLCJ0ZXh0SW5zdGFuY2UiLCJ0cnlIeWRyYXRlU3VzcGVuc2UiLCJzdXNwZW5zZVN0YXRlIiwiZGVoeWRyYXRlZCIsInJldHJ5TGFuZSIsImRlaHlkcmF0ZWRGcmFnbWVudCIsImNyZWF0ZUZpYmVyRnJvbURlaHlkcmF0ZWRGcmFnbWVudCIsIkh5ZHJhdGlvbk1pc21hdGNoRXhjZXB0aW9uIiwidGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoIiwiZGlmZiIsImRpZmZSb290IiwicXVldWVIeWRyYXRpb25FcnJvciIsImNsYWltSHlkcmF0YWJsZVNpbmdsZXRvbiIsImN1cnJlbnRSb290Q29udGFpbmVyIiwiY3VycmVudEhvc3RDb250ZXh0IiwidHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlSW5zdGFuY2UiLCJzaG91bGRLZWVwV2FybmluZyIsInRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZVRleHRJbnN0YW5jZSIsInRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZVN1c3BlbnNlSW5zdGFuY2UiLCJ0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVGb3JtTWFya2VySW5zdGFuY2UiLCJtYXJrZXJJbnN0YW5jZSIsInByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UiLCJkaWRIeWRyYXRlIiwicHJlcGFyZVRvSHlkcmF0ZUhvc3RUZXh0SW5zdGFuY2UiLCJ0ZXh0Q29udGVudCIsInNob3VsZFdhcm5JZk1pc21hdGNoRGV2IiwicGFyZW50UHJvcHMiLCJkaWZmZXJlbmNlIiwiX2RpZmZlcmVuY2UiLCJfZGlmZk5vZGUiLCJwcmVwYXJlVG9IeWRyYXRlSG9zdFN1c3BlbnNlSW5zdGFuY2UiLCJza2lwUGFzdERlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlIiwicG9wVG9OZXh0SG9zdFBhcmVudCIsInBvcEh5ZHJhdGlvblN0YXRlIiwic2hvdWxkQ2xlYXIiLCJ3YXJuSWZVbmh5ZHJhdGVkVGFpbE5vZGVzIiwicmVzZXRIeWRyYXRpb25TdGF0ZSIsInVwZ3JhZGVIeWRyYXRpb25FcnJvcnNUb1JlY292ZXJhYmxlIiwicXVldWVSZWNvdmVyYWJsZUVycm9ycyIsImVtaXRQZW5kaW5nSHlkcmF0aW9uV2FybmluZ3MiLCJjb25jdXJyZW50UXVldWVzIiwiY29uY3VycmVudFF1ZXVlc0luZGV4IiwiY29uY3VycmVudGx5VXBkYXRlZExhbmVzIiwiZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcyIsImVuZEluZGV4IiwicXVldWUiLCJwZW5kaW5nIiwibmV4dCIsIm1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290IiwiZ2V0Q29uY3VycmVudGx5VXBkYXRlZExhbmVzIiwiZW5xdWV1ZVVwZGF0ZSQxIiwiZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlIiwiY29uY3VycmVudFF1ZXVlIiwiY29uY3VycmVudFVwZGF0ZSIsImdldFJvb3RGb3JVcGRhdGVkRmliZXIiLCJlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGVBbmRFYWdlcmx5QmFpbG91dCIsImlzQ29uY3VycmVudGx5UmVuZGVyaW5nIiwiZ2V0V29ya0luUHJvZ3Jlc3NSb290IiwiZW5xdWV1ZUNvbmN1cnJlbnRDbGFzc1VwZGF0ZSIsImVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZSIsInVuc2FmZV9tYXJrVXBkYXRlTGFuZUZyb21GaWJlclRvUm9vdCIsInNvdXJjZUZpYmVyIiwiaXNIaWRkZW4iLCJjaGlsZExhbmVzIiwib2Zmc2NyZWVuSW5zdGFuY2UiLCJfdmlzaWJpbGl0eSIsInRocm93SWZJbmZpbml0ZVVwZGF0ZUxvb3BEZXRlY3RlZCIsImRldGVjdFVwZGF0ZU9uVW5tb3VudGVkRmliZXIiLCJ3YXJuQWJvdXRVcGRhdGVPbk5vdFlldE1vdW50ZWRGaWJlckluREVWIiwiZmlyc3RTY2hlZHVsZWRSb290IiwibGFzdFNjaGVkdWxlZFJvb3QiLCJkaWRTY2hlZHVsZU1pY3JvdGFzayIsImRpZFNjaGVkdWxlTWljcm90YXNrX2FjdCIsIm1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yayIsImlzRmx1c2hpbmdXb3JrIiwiY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUiLCJlbnN1cmVSb290SXNTY2hlZHVsZWQiLCJhY3RRdWV1ZSIsInNjaGVkdWxlSW1tZWRpYXRlVGFzayIsInByb2Nlc3NSb290U2NoZWR1bGVJbk1pY3JvdGFzayIsImZsdXNoU3luY1dvcmtPbkFsbFJvb3RzIiwiZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwiLCJvbmx5TGVnYWN5IiwiZGlkUGVyZm9ybVNvbWVXb3JrIiwid29ya0luUHJvZ3Jlc3NSb290Iiwid29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMiLCJnZXRXb3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyIsInBlcmZvcm1TeW5jV29ya09uUm9vdCIsInByZXYiLCJzY2hlZHVsZVRhc2tGb3JSb290RHVyaW5nTWljcm90YXNrIiwiZXhpc3RpbmdDYWxsYmFja05vZGUiLCJjYWxsYmFja05vZGUiLCJpc1dvcmtMb29wU3VzcGVuZGVkT25EYXRhIiwiY2FuY2VsUGVuZGluZ0NvbW1pdCIsImNhbmNlbENhbGxiYWNrIiwiY2FsbGJhY2tQcmlvcml0eSIsImV4aXN0aW5nQ2FsbGJhY2tQcmlvcml0eSIsIm5ld0NhbGxiYWNrUHJpb3JpdHkiLCJmYWtlQWN0Q2FsbGJhY2tOb2RlJDEiLCJzY2hlZHVsZXJQcmlvcml0eUxldmVsIiwibmV3Q2FsbGJhY2tOb2RlIiwic2NoZWR1bGVDYWxsYmFjayQyIiwicGVyZm9ybUNvbmN1cnJlbnRXb3JrT25Sb290IiwiYmluZCIsImdldENvbnRpbnVhdGlvbkZvclJvb3QiLCJvcmlnaW5hbENhbGxiYWNrTm9kZSIsInByaW9yaXR5TGV2ZWwiLCJjYWxsYmFjayIsImNiIiwiZXhlY3V0aW9uQ29udGV4dCIsImdldEV4ZWN1dGlvbkNvbnRleHQiLCJSZW5kZXJDb250ZXh0IiwiQ29tbWl0Q29udGV4dCIsIk5vQ29udGV4dCIsInJlcXVlc3RUcmFuc2l0aW9uTGFuZSIsInRyYW5zaXRpb24iLCJjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzIiwiY3VycmVudEVudGFuZ2xlZFBlbmRpbmdDb3VudCIsImN1cnJlbnRFbnRhbmdsZWRMYW5lIiwiY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlIiwiZW50YW5nbGVBc3luY0FjdGlvbiIsInRoZW5hYmxlIiwiZW50YW5nbGVkTGlzdGVuZXJzIiwiZW50YW5nbGVkVGhlbmFibGUiLCJzdGF0dXMiLCJ0aGVuIiwicmVzb2x2ZSIsInBpbmdFbmd0YW5nbGVkQWN0aW9uU2NvcGUiLCJmdWxmaWxsZWRUaGVuYWJsZSIsImxpc3RlbmVycyIsImxpc3RlbmVyIiwiY2hhaW5UaGVuYWJsZVZhbHVlIiwicmVzdWx0IiwidGhlbmFibGVXaXRoT3ZlcnJpZGUiLCJyZWFzb24iLCJyZWplY3RlZFRoZW5hYmxlIiwicGVla0VudGFuZ2xlZEFjdGlvbkxhbmUiLCJwZWVrRW50YW5nbGVkQWN0aW9uVGhlbmFibGUiLCJVcGRhdGVTdGF0ZSIsIlJlcGxhY2VTdGF0ZSIsIkZvcmNlVXBkYXRlIiwiQ2FwdHVyZVVwZGF0ZSIsImhhc0ZvcmNlVXBkYXRlIiwiZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSIsImN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSIsImluaXRpYWxpemVVcGRhdGVRdWV1ZSIsImJhc2VTdGF0ZSIsImZpcnN0QmFzZVVwZGF0ZSIsImxhc3RCYXNlVXBkYXRlIiwic2hhcmVkIiwiaGlkZGVuQ2FsbGJhY2tzIiwiY2FsbGJhY2tzIiwidXBkYXRlUXVldWUiLCJjbG9uZVVwZGF0ZVF1ZXVlIiwiY3VycmVudFF1ZXVlIiwiY2xvbmUiLCJjcmVhdGVVcGRhdGUiLCJlbnF1ZXVlVXBkYXRlIiwic2hhcmVkUXVldWUiLCJjb21wb25lbnROYW1lIiwiaXNVbnNhZmVDbGFzc1JlbmRlclBoYXNlVXBkYXRlIiwiZW50YW5nbGVUcmFuc2l0aW9ucyIsInF1ZXVlTGFuZXMiLCJuZXdRdWV1ZUxhbmVzIiwiZW5xdWV1ZUNhcHR1cmVkVXBkYXRlIiwiY2FwdHVyZWRVcGRhdGUiLCJuZXdGaXJzdCIsIm5ld0xhc3QiLCJnZXRTdGF0ZUZyb21VcGRhdGUiLCJwcmV2U3RhdGUiLCJuZXh0UHJvcHMiLCJlbnRlckRpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWIiwibmV4dFN0YXRlIiwiZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWIiwicGFydGlhbFN0YXRlIiwiZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiIsInN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24iLCJlbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSIsInByb2Nlc3NVcGRhdGVRdWV1ZSIsInBlbmRpbmdRdWV1ZSIsImxhc3RQZW5kaW5nVXBkYXRlIiwiZmlyc3RQZW5kaW5nVXBkYXRlIiwiY3VycmVudExhc3RCYXNlVXBkYXRlIiwibmV3U3RhdGUiLCJuZXdMYW5lcyIsIm5ld0Jhc2VTdGF0ZSIsIm5ld0ZpcnN0QmFzZVVwZGF0ZSIsIm5ld0xhc3RCYXNlVXBkYXRlIiwiaXNIaWRkZW5VcGRhdGUiLCJzaG91bGRTa2lwVXBkYXRlIiwiX2Nsb25lIiwiX2xhc3RQZW5kaW5nVXBkYXRlIiwiX2ZpcnN0UGVuZGluZ1VwZGF0ZSIsIm1hcmtTa2lwcGVkVXBkYXRlTGFuZXMiLCJjYWxsQ2FsbGJhY2siLCJyZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZyIsImNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmciLCJkZWZlckhpZGRlbkNhbGxiYWNrcyIsIm5ld0hpZGRlbkNhbGxiYWNrcyIsImV4aXN0aW5nSGlkZGVuQ2FsbGJhY2tzIiwiY29tbWl0SGlkZGVuQ2FsbGJhY2tzIiwiY29tbWl0Q2FsbGJhY2tzIiwic2hhbGxvd0VxdWFsIiwib2JqQSIsIm9iakIiLCJrZXlzQSIsImtleXNCIiwiY3VycmVudEtleSIsIlJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzIiwicmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MiLCJmbHVzaFBlbmRpbmdVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyIsInJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nIiwiZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZyIsImRpc2NhcmRQZW5kaW5nV2FybmluZ3MiLCJmaW5kU3RyaWN0Um9vdCIsIm1heWJlU3RyaWN0Um9vdCIsInNldFRvU29ydGVkU3RyaW5nIiwiYXJyYXkiLCJzb3J0IiwicGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzIiwicGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsTW91bnRXYXJuaW5ncyIsInBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MiLCJwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyIsInBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MiLCJwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyIsImRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMiLCJTZXQiLCJjb21wb25lbnRXaWxsTW91bnQiLCJfX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCIsImNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudFdpbGxVcGRhdGUiLCJVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZSIsImNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzIiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyIsImNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMiLCJzb3J0ZWROYW1lcyIsIl9zb3J0ZWROYW1lcyIsIl9zb3J0ZWROYW1lczIiLCJfc29ydGVkTmFtZXMzIiwiX3NvcnRlZE5hbWVzNCIsIl9zb3J0ZWROYW1lczUiLCJwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmciLCJkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0Iiwic3RyaWN0Um9vdCIsIndhcm5pbmdzRm9yUm9vdCIsImNvbnRleHRUeXBlcyIsImNoaWxkQ29udGV4dFR5cGVzIiwiZ2V0Q2hpbGRDb250ZXh0IiwiZmliZXJBcnJheSIsImZpcnN0RmliZXIiLCJ1bmlxdWVOYW1lcyIsImdldFRoZW5hYmxlc0Zyb21TdGF0ZSIsInN0YXRlIiwiZGV2U3RhdGUiLCJ0aGVuYWJsZXMiLCJTdXNwZW5zZUV4Y2VwdGlvbiIsIlN1c3BlbnNleUNvbW1pdEV4Y2VwdGlvbiIsIm5vb3BTdXNwZW5zZXlDb21taXRUaGVuYWJsZSIsImNyZWF0ZVRoZW5hYmxlU3RhdGUiLCJkaWRXYXJuQWJvdXRVbmNhY2hlZFByb21pc2UiLCJpc1RoZW5hYmxlUmVzb2x2ZWQiLCJub29wJDEiLCJ0cmFja1VzZWRUaGVuYWJsZSIsInRoZW5hYmxlU3RhdGUiLCJkaWRVc2VQcm9taXNlIiwidHJhY2tlZFRoZW5hYmxlcyIsInByZXZpb3VzIiwidGhlbmFibGVTdGF0ZURldiIsImZ1bGZpbGxlZFZhbHVlIiwicmVqZWN0ZWRFcnJvciIsImNoZWNrSWZVc2VXcmFwcGVkSW5Bc3luY0NhdGNoIiwicGVuZGluZ1RoZW5hYmxlIiwiX3JlamVjdGVkRXJyb3IiLCJzdXNwZW5kZWRUaGVuYWJsZSIsIm5lZWRzVG9SZXNldFN1c3BlbmRlZFRoZW5hYmxlREVWIiwic3VzcGVuZENvbW1pdCIsImdldFN1c3BlbmRlZFRoZW5hYmxlIiwiY2hlY2tJZlVzZVdyYXBwZWRJblRyeUNhdGNoIiwicmVqZWN0ZWRSZWFzb24iLCJ0aGVuYWJsZVN0YXRlJDEiLCJ0aGVuYWJsZUluZGV4Q291bnRlciQxIiwibWVyZ2VEZWJ1Z0luZm8iLCJvdXRlciIsImlubmVyIiwiZGlkV2FybkFib3V0TWFwcyIsImRpZFdhcm5BYm91dEdlbmVyYXRvcnMiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmciLCJvd25lckhhc1N5bWJvbFR5cGVXYXJuaW5nIiwid2FybkZvck1pc3NpbmdLZXkiLCJfc3RvcmUiLCJ2YWxpZGF0ZWQiLCJjb21wb25lbnRLZXkiLCJjaGlsZE93bmVyIiwiX293bmVyIiwicGFyZW50T3duZXIiLCJfZGVidWdPd25lciIsImN1cnJlbnRDb21wb25lbnRFcnJvckluZm8iLCJjaGlsZE93bmVyQXBwZW5kaXgiLCJvd25lck5hbWUiLCJjcmVhdGVGaWJlckZyb21FbGVtZW50IiwicHJldkRlYnVnRmliZXIiLCJ2YWxpZGF0ZUZyYWdtZW50UHJvcHMiLCJlbGVtZW50IiwidW53cmFwVGhlbmFibGUiLCJjb2VyY2VSZWYiLCJyZWYiLCJyZWZQcm9wIiwidGhyb3dPbkludmFsaWRPYmplY3RUeXBlIiwibmV3Q2hpbGQiLCJjaGlsZFN0cmluZyIsIndhcm5PbkZ1bmN0aW9uVHlwZSIsImludmFsaWRDaGlsZCIsInBhcmVudE5hbWUiLCJ3YXJuT25TeW1ib2xUeXBlIiwicmVzb2x2ZUxhenkiLCJsYXp5VHlwZSIsImNyZWF0ZUNoaWxkUmVjb25jaWxlciIsInNob3VsZFRyYWNrU2lkZUVmZmVjdHMiLCJkZWxldGVDaGlsZCIsImNoaWxkVG9EZWxldGUiLCJkZWxldGlvbnMiLCJkZWxldGVSZW1haW5pbmdDaGlsZHJlbiIsImN1cnJlbnRGaXJzdENoaWxkIiwibWFwUmVtYWluaW5nQ2hpbGRyZW4iLCJleGlzdGluZ0NoaWxkcmVuIiwiZXhpc3RpbmdDaGlsZCIsInVzZUZpYmVyIiwiY3JlYXRlV29ya0luUHJvZ3Jlc3MiLCJwbGFjZUNoaWxkIiwibmV3RmliZXIiLCJsYXN0UGxhY2VkSW5kZXgiLCJuZXdJbmRleCIsIm9sZEluZGV4IiwicGxhY2VTaW5nbGVDaGlsZCIsInVwZGF0ZVRleHROb2RlIiwiY3JlYXRlZCIsImNyZWF0ZUZpYmVyRnJvbVRleHQiLCJ1cGRhdGVFbGVtZW50IiwiZWxlbWVudFR5cGUiLCJ1cGRhdGVkIiwidXBkYXRlRnJhZ21lbnQiLCJpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmciLCJ1cGRhdGVQb3J0YWwiLCJwb3J0YWwiLCJpbXBsZW1lbnRhdGlvbiIsImNyZWF0ZUZpYmVyRnJvbVBvcnRhbCIsImZyYWdtZW50IiwiY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQiLCJjcmVhdGVDaGlsZCIsIl9jcmVhdGVkIiwiX2NyZWF0ZWQyIiwiX2NyZWF0ZWQzIiwicmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbiIsInVwZGF0ZVNsb3QiLCJvbGRGaWJlciIsInVwZGF0ZUZyb21NYXAiLCJuZXdJZHgiLCJtYXRjaGVkRmliZXIiLCJfbWF0Y2hlZEZpYmVyIiwiX21hdGNoZWRGaWJlcjIiLCJfbWF0Y2hlZEZpYmVyMyIsIndhcm5PbkludmFsaWRLZXkiLCJrbm93bktleXMiLCJyZWNvbmNpbGVDaGlsZHJlbkFycmF5IiwibmV3Q2hpbGRyZW4iLCJyZXN1bHRpbmdGaXJzdENoaWxkIiwicHJldmlvdXNOZXdGaWJlciIsIm5leHRPbGRGaWJlciIsIl9uZXdGaWJlciIsIl9udW1iZXJPZkZvcmtzIiwiX25ld0ZpYmVyMiIsIl9udW1iZXJPZkZvcmtzMiIsInJlY29uY2lsZUNoaWxkcmVuSXRlcmF0YWJsZSIsIm5ld0NoaWxkcmVuSXRlcmFibGUiLCJpdGVyYXRvckZuIiwiaXNHZW5lcmF0b3JDb21wb25lbnQiLCJlbnRyaWVzIiwicmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRvciIsInN0ZXAiLCJkb25lIiwiX25ld0ZpYmVyMyIsIl9udW1iZXJPZkZvcmtzMyIsIl9uZXdGaWJlcjQiLCJfbnVtYmVyT2ZGb3JrczQiLCJyZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZSIsInJlY29uY2lsZVNpbmdsZUVsZW1lbnQiLCJfZXhpc3RpbmciLCJfY3JlYXRlZDQiLCJyZWNvbmNpbGVTaW5nbGVQb3J0YWwiLCJyZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwiLCJpc1Vua2V5ZWRUb3BMZXZlbEZyYWdtZW50IiwicmVjb25jaWxlQ2hpbGRGaWJlcnMiLCJmaXJzdENoaWxkRmliZXIiLCJtb3VudENoaWxkRmliZXJzIiwicmVzZXRDaGlsZFJlY29uY2lsZXJPblVud2luZCIsImNsb25lQ2hpbGRGaWJlcnMiLCJjdXJyZW50Q2hpbGQiLCJyZXNldENoaWxkRmliZXJzIiwicmVzZXRXb3JrSW5Qcm9ncmVzcyIsImN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IiLCJwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXNDdXJzb3IiLCJwdXNoSGlkZGVuQ29udGV4dCIsInByZXZFbnRhbmdsZWRSZW5kZXJMYW5lcyIsImdldEVudGFuZ2xlZFJlbmRlckxhbmVzIiwic2V0RW50YW5nbGVkUmVuZGVyTGFuZXMiLCJiYXNlTGFuZXMiLCJyZXVzZUhpZGRlbkNvbnRleHRPblN0YWNrIiwicG9wSGlkZGVuQ29udGV4dCIsImlzQ3VycmVudFRyZWVIaWRkZW4iLCJzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvciIsInNoZWxsQm91bmRhcnkiLCJnZXRTaGVsbEJvdW5kYXJ5IiwicHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyIiwiaGFuZGxlciIsInB1c2hTdXNwZW5zZUxpc3RDb250ZXh0Iiwic2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUxpc3RDb250ZXh0Iiwic3VzcGVuc2VTdGFja0N1cnNvciIsInB1c2hGYWxsYmFja1RyZWVTdXNwZW5zZUhhbmRsZXIiLCJyZXVzZVN1c3BlbnNlSGFuZGxlck9uU3RhY2siLCJwdXNoT2Zmc2NyZWVuU3VzcGVuc2VIYW5kbGVyIiwiZ2V0U3VzcGVuc2VIYW5kbGVyIiwicG9wU3VzcGVuc2VIYW5kbGVyIiwicG9wU3VzcGVuc2VMaXN0Q29udGV4dCIsIkRlZmF1bHRTdXNwZW5zZUNvbnRleHQiLCJTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzayIsIkZvcmNlU3VzcGVuc2VGYWxsYmFjayIsImhhc1N1c3BlbnNlTGlzdENvbnRleHQiLCJmbGFnIiwic2V0U2hhbGxvd1N1c3BlbnNlTGlzdENvbnRleHQiLCJzaGFsbG93Q29udGV4dCIsIm5ld0NvbnRleHQiLCJmaW5kRmlyc3RTdXNwZW5kZWQiLCJyb3ciLCJyZXZlYWxPcmRlciIsImRpZFN1c3BlbmQiLCJOb0ZsYWdzIiwiSGFzRWZmZWN0IiwiSW5zZXJ0aW9uIiwiTGF5b3V0IiwiUGFzc2l2ZSIsImRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudCIsImRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90IiwiZGlkV2FybkFib3V0VXNlV3JhcHBlZEluVHJ5Q2F0Y2giLCJkaWRXYXJuQWJvdXRBc3luY0NsaWVudENvbXBvbmVudCIsImRpZFdhcm5BYm91dFVzZUZvcm1TdGF0ZSIsImN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEiLCJjdXJyZW50SG9vayIsIndvcmtJblByb2dyZXNzSG9vayIsImRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUiLCJkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MiLCJzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFViIsImxvY2FsSWRDb3VudGVyIiwidGhlbmFibGVJbmRleENvdW50ZXIiLCJnbG9iYWxDbGllbnRJZENvdW50ZXIiLCJSRV9SRU5ERVJfTElNSVQiLCJjdXJyZW50SG9va05hbWVJbkRldiIsImhvb2tUeXBlc0RldiIsImhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2IiwiaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMiLCJtb3VudEhvb2tUeXBlc0RldiIsImhvb2tOYW1lIiwidXBkYXRlSG9va1R5cGVzRGV2Iiwid2Fybk9uSG9va01pc21hdGNoSW5EZXYiLCJjaGVja0RlcHNBcmVBcnJheURldiIsImRlcHMiLCJjdXJyZW50SG9va05hbWUiLCJ0YWJsZSIsInNlY29uZENvbHVtblN0YXJ0Iiwib2xkSG9va05hbWUiLCJuZXdIb29rTmFtZSIsIndhcm5PblVzZUZvcm1TdGF0ZUluRGV2Iiwid2FybklmQXN5bmNDbGllbnRDb21wb25lbnQiLCJDb21wb25lbnQiLCJpc0FzeW5jRnVuY3Rpb24iLCJ0aHJvd0ludmFsaWRIb29rRXJyb3IiLCJhcmVIb29rSW5wdXRzRXF1YWwiLCJuZXh0RGVwcyIsInByZXZEZXBzIiwicmVuZGVyV2l0aEhvb2tzIiwic2Vjb25kQXJnIiwibmV4dFJlbmRlckxhbmVzIiwiX2RlYnVnSG9va1R5cGVzIiwiSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViIsIkhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYiLCJIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYiLCJzaG91bGREb3VibGVSZW5kZXJERVYiLCJyZW5kZXJXaXRoSG9va3NBZ2FpbiIsImZpbmlzaFJlbmRlcmluZ0hvb2tzIiwiQ29udGV4dE9ubHlEaXNwYXRjaGVyIiwiZGlkUmVuZGVyVG9vRmV3SG9va3MiLCJyZXBsYXlTdXNwZW5kZWRDb21wb25lbnRXaXRoSG9va3MiLCJudW1iZXJPZlJlUmVuZGVycyIsIkhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViIsInJlbmRlclRyYW5zaXRpb25Bd2FyZUhvc3RDb21wb25lbnRXaXRoSG9va3MiLCJUcmFuc2l0aW9uQXdhcmVIb3N0Q29tcG9uZW50IiwiZGlzcGF0Y2hlciIsIl9kaXNwYXRjaGVyJHVzZVN0YXRlIiwidXNlU3RhdGUiLCJtYXliZVRoZW5hYmxlIiwidXNlVGhlbmFibGUiLCJfZGlzcGF0Y2hlciR1c2VTdGF0ZTIiLCJuZXh0UmVzZXRTdGF0ZSIsInByZXZSZXNldFN0YXRlIiwiY2hlY2tEaWRSZW5kZXJJZEhvb2siLCJkaWRSZW5kZXJJZEhvb2siLCJiYWlsb3V0SG9va3MiLCJyZXNldEhvb2tzQWZ0ZXJUaHJvdyIsInJlc2V0SG9va3NPblVud2luZCIsIm1vdW50V29ya0luUHJvZ3Jlc3NIb29rIiwiYmFzZVF1ZXVlIiwidXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rIiwibmV4dEN1cnJlbnRIb29rIiwibmV4dFdvcmtJblByb2dyZXNzSG9vayIsImN1cnJlbnRGaWJlciIsIm5ld0hvb2siLCJjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlIiwibGFzdEVmZmVjdCIsImV2ZW50cyIsInN0b3JlcyIsIm1lbW9DYWNoZSIsInVzZSIsInVzYWJsZSIsInJlYWRDb250ZXh0IiwidXNlTWVtb0NhY2hlIiwiY3VycmVudFVwZGF0ZVF1ZXVlIiwiY3VycmVudE1lbW9DYWNoZSIsImRhdGEiLCJiYXNpY1N0YXRlUmVkdWNlciIsImFjdGlvbiIsIm1vdW50UmVkdWNlciIsInJlZHVjZXIiLCJpbml0aWFsQXJnIiwiaW5pdGlhbFN0YXRlIiwiZGlzcGF0Y2giLCJsYXN0UmVuZGVyZWRSZWR1Y2VyIiwibGFzdFJlbmRlcmVkU3RhdGUiLCJkaXNwYXRjaFJlZHVjZXJBY3Rpb24iLCJ1cGRhdGVSZWR1Y2VyIiwidXBkYXRlUmVkdWNlckltcGwiLCJiYXNlRmlyc3QiLCJwZW5kaW5nRmlyc3QiLCJmaXJzdCIsIm5ld0Jhc2VRdWV1ZUZpcnN0IiwibmV3QmFzZVF1ZXVlTGFzdCIsInJldmVydExhbmUiLCJoYXNFYWdlclN0YXRlIiwiZWFnZXJTdGF0ZSIsIl9jbG9uZTIiLCJtYXJrV29ya0luUHJvZ3Jlc3NSZWNlaXZlZFVwZGF0ZSIsInJlcmVuZGVyUmVkdWNlciIsImxhc3RSZW5kZXJQaGFzZVVwZGF0ZSIsImZpcnN0UmVuZGVyUGhhc2VVcGRhdGUiLCJtb3VudFN5bmNFeHRlcm5hbFN0b3JlIiwic3Vic2NyaWJlIiwiZ2V0U25hcHNob3QiLCJnZXRTZXJ2ZXJTbmFwc2hvdCIsIm5leHRTbmFwc2hvdCIsImNhY2hlZFNuYXBzaG90Iiwicm9vdFJlbmRlckxhbmVzIiwicHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayIsImluc3QiLCJtb3VudEVmZmVjdCIsInN1YnNjcmliZVRvU3RvcmUiLCJwdXNoRWZmZWN0IiwidXBkYXRlU3RvcmVJbnN0YW5jZSIsImNyZWF0ZUVmZmVjdEluc3RhbmNlIiwidXBkYXRlU3luY0V4dGVybmFsU3RvcmUiLCJwcmV2U25hcHNob3QiLCJzbmFwc2hvdENoYW5nZWQiLCJ1cGRhdGVFZmZlY3QiLCJyZW5kZXJlZFNuYXBzaG90IiwiY2hlY2siLCJjb21wb25lbnRVcGRhdGVRdWV1ZSIsImNoZWNrSWZTbmFwc2hvdENoYW5nZWQiLCJmb3JjZVN0b3JlUmVyZW5kZXIiLCJoYW5kbGVTdG9yZUNoYW5nZSIsImxhdGVzdEdldFNuYXBzaG90IiwicHJldlZhbHVlIiwibmV4dFZhbHVlIiwic2NoZWR1bGVVcGRhdGVPbkZpYmVyIiwibW91bnRTdGF0ZUltcGwiLCJpbml0aWFsU3RhdGVJbml0aWFsaXplciIsIm1vdW50U3RhdGUiLCJkaXNwYXRjaFNldFN0YXRlIiwidXBkYXRlU3RhdGUiLCJyZXJlbmRlclN0YXRlIiwibW91bnRPcHRpbWlzdGljIiwicGFzc3Rocm91Z2giLCJkaXNwYXRjaE9wdGltaXN0aWNTZXRTdGF0ZSIsInVwZGF0ZU9wdGltaXN0aWMiLCJ1cGRhdGVPcHRpbWlzdGljSW1wbCIsInJlc29sdmVkUmVkdWNlciIsInJlcmVuZGVyT3B0aW1pc3RpYyIsImRpc3BhdGNoQWN0aW9uU3RhdGUiLCJhY3Rpb25RdWV1ZSIsInNldFBlbmRpbmdTdGF0ZSIsInNldFN0YXRlIiwiaXNSZW5kZXJQaGFzZVVwZGF0ZSIsImxhc3QiLCJydW5BY3Rpb25TdGF0ZUFjdGlvbiIsIl9uZXdMYXN0IiwicHJldlRyYW5zaXRpb24iLCJUIiwiY3VycmVudFRyYW5zaXRpb24iLCJfdXBkYXRlZEZpYmVycyIsInJldHVyblZhbHVlIiwib25TdGFydFRyYW5zaXRpb25GaW5pc2giLCJTIiwiZmluaXNoUnVubmluZ0FjdGlvblN0YXRlQWN0aW9uIiwidXBkYXRlZEZpYmVyc0NvdW50IiwiYWN0aW9uU3RhdGVSZWR1Y2VyIiwib2xkU3RhdGUiLCJtb3VudEFjdGlvblN0YXRlIiwiaW5pdGlhbFN0YXRlUHJvcCIsInBlcm1hbGluayIsInNzckZvcm1TdGF0ZSIsImZvcm1TdGF0ZSIsImlzTWF0Y2hpbmciLCJzdGF0ZVF1ZXVlIiwicGVuZGluZ1N0YXRlSG9vayIsImFjdGlvblF1ZXVlSG9vayIsInVwZGF0ZUFjdGlvblN0YXRlIiwiY3VycmVudFN0YXRlSG9vayIsInVwZGF0ZUFjdGlvblN0YXRlSW1wbCIsIl91cGRhdGVSZWR1Y2VySW1wbCIsImFjdGlvblJlc3VsdCIsIl91cGRhdGVTdGF0ZSIsImlzUGVuZGluZyIsInByZXZBY3Rpb24iLCJhY3Rpb25TdGF0ZUFjdGlvbkVmZmVjdCIsInJlcmVuZGVyQWN0aW9uU3RhdGUiLCJjcmVhdGUiLCJlZmZlY3QiLCJmaXJzdEVmZmVjdCIsImRlc3Ryb3kiLCJtb3VudFJlZiIsImluaXRpYWxWYWx1ZSIsInVwZGF0ZVJlZiIsIm1vdW50RWZmZWN0SW1wbCIsImZpYmVyRmxhZ3MiLCJob29rRmxhZ3MiLCJ1cGRhdGVFZmZlY3RJbXBsIiwicHJldkVmZmVjdCIsIm1vdW50SW5zZXJ0aW9uRWZmZWN0IiwidXBkYXRlSW5zZXJ0aW9uRWZmZWN0IiwibW91bnRMYXlvdXRFZmZlY3QiLCJ1cGRhdGVMYXlvdXRFZmZlY3QiLCJpbXBlcmF0aXZlSGFuZGxlRWZmZWN0IiwicmVmQ2FsbGJhY2siLCJyZWZDbGVhbnVwIiwicmVmT2JqZWN0IiwiX2luc3QiLCJtb3VudEltcGVyYXRpdmVIYW5kbGUiLCJlZmZlY3REZXBzIiwidXBkYXRlSW1wZXJhdGl2ZUhhbmRsZSIsIm1vdW50RGVidWdWYWx1ZSIsImZvcm1hdHRlckZuIiwidXBkYXRlRGVidWdWYWx1ZSIsIm1vdW50Q2FsbGJhY2siLCJ1cGRhdGVDYWxsYmFjayIsIm1vdW50TWVtbyIsIm5leHRDcmVhdGUiLCJ1cGRhdGVNZW1vIiwibW91bnREZWZlcnJlZFZhbHVlIiwibW91bnREZWZlcnJlZFZhbHVlSW1wbCIsInVwZGF0ZURlZmVycmVkVmFsdWUiLCJyZXNvbHZlZEN1cnJlbnRIb29rIiwidXBkYXRlRGVmZXJyZWRWYWx1ZUltcGwiLCJyZXJlbmRlckRlZmVycmVkVmFsdWUiLCJkZWZlcnJlZExhbmUiLCJyZXF1ZXN0RGVmZXJyZWRMYW5lIiwicmVzdWx0VmFsdWUiLCJzaG91bGREZWZlclZhbHVlIiwic3RhcnRUcmFuc2l0aW9uIiwicGVuZGluZ1N0YXRlIiwiZmluaXNoZWRTdGF0ZSIsIm9wdGlvbnMiLCJwcmV2aW91c1ByaW9yaXR5IiwidGhlbmFibGVGb3JGaW5pc2hlZFN0YXRlIiwibm9vcCIsInN0YXJ0SG9zdFRyYW5zaXRpb24iLCJmb3JtRmliZXIiLCJmb3JtRGF0YSIsImVuc3VyZUZvcm1Db21wb25lbnRJc1N0YXRlZnVsIiwicmVxdWVzdEZvcm1SZXNldCIsImV4aXN0aW5nU3RhdGVIb29rIiwibmV3UXVldWUiLCJpbml0aWFsUmVzZXRTdGF0ZSIsIm5ld1Jlc2V0U3RhdGVRdWV1ZSIsInJlc2V0U3RhdGVIb29rIiwicmVxdWVzdEN1cnJlbnRUcmFuc2l0aW9uIiwibmV3UmVzZXRTdGF0ZSIsInJlc2V0U3RhdGVRdWV1ZSIsIm1vdW50VHJhbnNpdGlvbiIsInN0YXJ0IiwidXBkYXRlVHJhbnNpdGlvbiIsIl91cGRhdGVTdGF0ZTIiLCJib29sZWFuT3JUaGVuYWJsZSIsInJlcmVuZGVyVHJhbnNpdGlvbiIsIl9yZXJlbmRlclN0YXRlIiwidXNlSG9zdFRyYW5zaXRpb25TdGF0dXMiLCJtb3VudElkIiwiaWRlbnRpZmllclByZWZpeCIsInRyZWVJZCIsImxvY2FsSWQiLCJnbG9iYWxDbGllbnRJZCIsInVwZGF0ZUlkIiwibW91bnRSZWZyZXNoIiwicmVmcmVzaCIsInJlZnJlc2hDYWNoZSIsInVwZGF0ZVJlZnJlc2giLCJzZWVkS2V5Iiwic2VlZFZhbHVlIiwicHJvdmlkZXIiLCJyZXF1ZXN0VXBkYXRlTGFuZSIsInJlZnJlc2hVcGRhdGUiLCJzZWVkZWRDYWNoZSIsImNyZWF0ZUNhY2hlIiwiY2FjaGUiLCJlbnF1ZXVlUmVuZGVyUGhhc2VVcGRhdGUiLCJlbnRhbmdsZVRyYW5zaXRpb25VcGRhdGUiLCJtYXJrVXBkYXRlSW5EZXZUb29scyIsInByZXZEaXNwYXRjaGVyIiwiSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYiLCJ0aHJvd0lmRHVyaW5nUmVuZGVyIiwidXNlQ2FsbGJhY2siLCJ1c2VDb250ZXh0IiwidXNlRWZmZWN0IiwidXNlSW1wZXJhdGl2ZUhhbmRsZSIsInVzZUxheW91dEVmZmVjdCIsInVzZUluc2VydGlvbkVmZmVjdCIsInVzZU1lbW8iLCJ1c2VSZWR1Y2VyIiwidXNlUmVmIiwidXNlRGVidWdWYWx1ZSIsInVzZURlZmVycmVkVmFsdWUiLCJ1c2VUcmFuc2l0aW9uIiwidXNlU3luY0V4dGVybmFsU3RvcmUiLCJ1c2VJZCIsInVzZUNhY2hlUmVmcmVzaCIsInVzZUZvcm1TdGF0ZSIsInVzZUFjdGlvblN0YXRlIiwidXNlT3B0aW1pc3RpYyIsIkludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYiLCJJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWIiwid2FybkludmFsaWRDb250ZXh0QWNjZXNzIiwid2FybkludmFsaWRIb29rQWNjZXNzIiwibm93IiwiY29tbWl0VGltZSIsImxheW91dEVmZmVjdFN0YXJ0VGltZSIsInByb2ZpbGVyU3RhcnRUaW1lIiwicGFzc2l2ZUVmZmVjdFN0YXJ0VGltZSIsImN1cnJlbnRVcGRhdGVJc05lc3RlZCIsIm5lc3RlZFVwZGF0ZVNjaGVkdWxlZCIsImlzQ3VycmVudFVwZGF0ZU5lc3RlZCIsIm1hcmtOZXN0ZWRVcGRhdGVTY2hlZHVsZWQiLCJyZXNldE5lc3RlZFVwZGF0ZUZsYWciLCJzeW5jTmVzdGVkVXBkYXRlRmxhZyIsImdldENvbW1pdFRpbWUiLCJyZWNvcmRDb21taXRUaW1lIiwic3RhcnRQcm9maWxlclRpbWVyIiwiYWN0dWFsU3RhcnRUaW1lIiwic3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmciLCJzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhIiwib3ZlcnJpZGVCYXNlVGltZSIsImVsYXBzZWRUaW1lIiwiYWN0dWFsRHVyYXRpb24iLCJzZWxmQmFzZUR1cmF0aW9uIiwicmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24iLCJwYXJlbnRGaWJlciIsImVmZmVjdER1cmF0aW9uIiwicGFyZW50U3RhdGVOb2RlIiwicmVjb3JkUGFzc2l2ZUVmZmVjdER1cmF0aW9uIiwicGFzc2l2ZUVmZmVjdER1cmF0aW9uIiwic3RhcnRMYXlvdXRFZmZlY3RUaW1lciIsInN0YXJ0UGFzc2l2ZUVmZmVjdFRpbWVyIiwidHJhbnNmZXJBY3R1YWxEdXJhdGlvbiIsImZha2VJbnRlcm5hbEluc3RhbmNlIiwiZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50IiwiZGlkV2FybkFib3V0VW5pbml0aWFsaXplZFN0YXRlIiwiZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlIiwiZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZSIsImRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSIsImRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlIiwiZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlIiwiZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrIiwid2Fybk9uSW52YWxpZENhbGxiYWNrIiwid2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlIiwiYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJjbGFzc0NvbXBvbmVudFVwZGF0ZXIiLCJlbnF1ZXVlU2V0U3RhdGUiLCJlbnF1ZXVlUmVwbGFjZVN0YXRlIiwiZW5xdWV1ZUZvcmNlVXBkYXRlIiwiY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUiLCJvbGRQcm9wcyIsIm5ld1Byb3BzIiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwic2hvdWxkVXBkYXRlIiwiaXNQdXJlUmVhY3RDb21wb25lbnQiLCJjaGVja0NsYXNzSW5zdGFuY2UiLCJyZW5kZXJQcmVzZW50IiwiZ2V0SW5pdGlhbFN0YXRlIiwiaXNSZWFjdENsYXNzQXBwcm92ZWQiLCJnZXREZWZhdWx0UHJvcHMiLCJwcm9wVHlwZXMiLCJjb250ZXh0VHlwZSIsImNvbXBvbmVudFNob3VsZFVwZGF0ZSIsImNvbXBvbmVudERpZFVubW91bnQiLCJjb21wb25lbnREaWRSZWNlaXZlUHJvcHMiLCJjb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJoYXNNdXRhdGVkUHJvcHMiLCJkZWZhdWx0UHJvcHMiLCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsImNvbXBvbmVudERpZFVwZGF0ZSIsImdldERlcml2ZWRTdGF0ZUZyb21FcnJvciIsImNvbnN0cnVjdENsYXNzSW5zdGFuY2UiLCJpc1ZhbGlkIiwiYWRkZW5kdW0iLCJ1cGRhdGVyIiwiX3JlYWN0SW50ZXJuYWxJbnN0YW5jZSIsImZvdW5kV2lsbE1vdW50TmFtZSIsImZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUiLCJmb3VuZFdpbGxVcGRhdGVOYW1lIiwiX2NvbXBvbmVudE5hbWUiLCJuZXdBcGlOYW1lIiwiY2FsbENvbXBvbmVudFdpbGxNb3VudCIsImNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwibW91bnRDbGFzc0luc3RhbmNlIiwicmVmcyIsImNvbXBvbmVudERpZE1vdW50IiwicmVzdW1lTW91bnRDbGFzc0luc3RhbmNlIiwidW5yZXNvbHZlZE9sZFByb3BzIiwicmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMiLCJvbGRDb250ZXh0IiwiaGFzTmV3TGlmZWN5Y2xlcyIsInVucmVzb2x2ZWROZXdQcm9wcyIsImRpZFJlY2VpdmVOZXdQcm9wcyIsInVwZGF0ZUNsYXNzSW5zdGFuY2UiLCJiYXNlUHJvcHMiLCJhbHJlYWR5UmVzb2x2ZWREZWZhdWx0UHJvcHMiLCJyZXBvcnRHbG9iYWxFcnJvciIsInJlcG9ydEVycm9yIiwid2luZG93IiwiRXJyb3JFdmVudCIsImV2ZW50IiwiYnViYmxlcyIsImNhbmNlbGFibGUiLCJzaG91bGRMb2ciLCJkaXNwYXRjaEV2ZW50IiwiZW1pdCIsImVycm9yQm91bmRhcnlOYW1lIiwiZGVmYXVsdE9uVW5jYXVnaHRFcnJvciIsImVycm9ySW5mbyIsImNvbXBvbmVudE5hbWVNZXNzYWdlIiwiZXJyb3JCb3VuZGFyeU1lc3NhZ2UiLCJjb21wb25lbnRTdGFjayIsImRlZmF1bHRPbkNhdWdodEVycm9yIiwiZXJyb3IkMSIsInJlY3JlYXRlTWVzc2FnZSIsImRlZmF1bHRPblJlY292ZXJhYmxlRXJyb3IiLCJsb2dVbmNhdWdodEVycm9yIiwidGhyb3duRXJyb3JzIiwib25VbmNhdWdodEVycm9yIiwiZSIsInNldFRpbWVvdXQiLCJsb2dDYXVnaHRFcnJvciIsImJvdW5kYXJ5Iiwib25DYXVnaHRFcnJvciIsImVycm9yQm91bmRhcnkiLCJjcmVhdGVSb290RXJyb3JVcGRhdGUiLCJwcmV2RmliZXIiLCJjcmVhdGVDbGFzc0Vycm9yVXBkYXRlIiwiaW5pdGlhbGl6ZUNsYXNzRXJyb3JVcGRhdGUiLCJtYXJrRmFpbGVkRXJyb3JCb3VuZGFyeUZvckhvdFJlbG9hZGluZyIsImNvbXBvbmVudERpZENhdGNoIiwibWFya0xlZ2FjeUVycm9yQm91bmRhcnlBc0ZhaWxlZCIsIm1hcmtTdXNwZW5zZUJvdW5kYXJ5U2hvdWxkQ2FwdHVyZSIsInN1c3BlbnNlQm91bmRhcnkiLCJ0aHJvd0V4Y2VwdGlvbiIsInJlc3RvcmVQZW5kaW5nVXBkYXRlcnMiLCJyZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlIiwicmVuZGVyRGlkU3VzcGVuZCIsImlzU3VzcGVuc2V5UmVzb3VyY2UiLCJyZXRyeVF1ZXVlIiwiYXR0YWNoUGluZ0xpc3RlbmVyIiwiX2lzU3VzcGVuc2V5UmVzb3VyY2UiLCJvZmZzY3JlZW5RdWV1ZSIsIm5ld09mZnNjcmVlblF1ZXVlIiwidHJhbnNpdGlvbnMiLCJtYXJrZXJJbnN0YW5jZXMiLCJfcmV0cnlRdWV1ZSIsIl9zdXNwZW5zZUJvdW5kYXJ5IiwiX3dyYXBwZXJFcnJvciIsImNhdXNlIiwiX3dyYXBwZXJFcnJvcjIiLCJfd29ya0luUHJvZ3Jlc3MiLCJyb290RXJyb3JJbmZvIiwicmVuZGVyRGlkRXJyb3IiLCJ3cmFwcGVyRXJyb3IiLCJxdWV1ZUNvbmN1cnJlbnRFcnJvciIsIl9sYW5lIiwiX3VwZGF0ZSIsImlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkiLCJfbGFuZTIiLCJfdXBkYXRlMiIsIlNlbGVjdGl2ZUh5ZHJhdGlvbkV4Y2VwdGlvbiIsImRpZFJlY2VpdmVVcGRhdGUiLCJkaWRXYXJuQWJvdXRCYWRDbGFzcyIsImRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudCIsImRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnQiLCJkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzIiwiZGlkV2FybkFib3V0UmV2ZWFsT3JkZXIiLCJkaWRXYXJuQWJvdXRUYWlsT3B0aW9ucyIsInJlY29uY2lsZUNoaWxkcmVuIiwibmV4dENoaWxkcmVuIiwiZm9yY2VVbm1vdW50Q3VycmVudEFuZFJlY29uY2lsZSIsInVwZGF0ZUZvcndhcmRSZWYiLCJwcm9wc1dpdGhvdXRSZWYiLCJoYXNJZCIsInByZXBhcmVUb1JlYWRDb250ZXh0IiwiYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayIsInVwZGF0ZU1lbW9Db21wb25lbnQiLCJpc1NpbXBsZUZ1bmN0aW9uQ29tcG9uZW50IiwiY29tcGFyZSIsInJlc29sdmVkVHlwZSIsInJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyIsInZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldiIsInVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQiLCJjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHMiLCJoYXNTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQiLCJjaGVja1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCIsInByZXZQcm9wcyIsInVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50IiwidXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50IiwibmV4dElzRGV0YWNoZWQiLCJfcGVuZGluZ1Zpc2liaWxpdHkiLCJtYXJrUmVmIiwibmV4dEJhc2VMYW5lcyIsImN1cnJlbnRDaGlsZExhbmVzIiwibGFuZXNXZUp1c3RBdHRlbXB0ZWQiLCJyZW1haW5pbmdDaGlsZExhbmVzIiwiZGVmZXJIaWRkZW5PZmZzY3JlZW5Db21wb25lbnQiLCJfbmV4dEJhc2VMYW5lcyIsIl9uZXh0U3RhdGUiLCJjYWNoZVBvb2wiLCJwcmV2Q2FjaGVQb29sIiwicHVzaFRyYW5zaXRpb24iLCJfcHJldkNhY2hlUG9vbCIsImdldE9mZnNjcmVlbkRlZmVycmVkQ2FjaGUiLCJ1cGRhdGVDYWNoZUNvbXBvbmVudCIsInBhcmVudENhY2hlIiwiQ2FjaGVDb250ZXh0IiwiZnJlc2hDYWNoZSIsInJlcXVlc3RDYWNoZUZyb21Qb29sIiwicHVzaENhY2hlUHJvdmlkZXIiLCJkZXJpdmVkU3RhdGUiLCJuZXh0Q2FjaGUiLCJwcm9wYWdhdGVDb250ZXh0Q2hhbmdlIiwidXBkYXRlTW9kZSIsInVwZGF0ZVByb2ZpbGVyIiwicmVwbGF5RnVuY3Rpb25Db21wb25lbnQiLCJ1cGRhdGVDbGFzc0NvbXBvbmVudCIsInNob3VsZEVycm9yIiwiX2luc3RhbmNlIiwidGVtcEluc3RhbmNlIiwiaGFzQ29udGV4dCIsIm5leHRVbml0T2ZXb3JrIiwiZmluaXNoQ2xhc3NDb21wb25lbnQiLCJkaWRDYXB0dXJlRXJyb3IiLCJwdXNoSG9zdFJvb3RDb250ZXh0IiwidXBkYXRlSG9zdFJvb3QiLCJwcmV2Q2hpbGRyZW4iLCJvdmVycmlkZVN0YXRlIiwibW91bnRIb3N0Um9vdFdpdGhvdXRIeWRyYXRpbmciLCJyZWNvdmVyYWJsZUVycm9yIiwidXBkYXRlSG9zdENvbXBvbmVudCQxIiwiaXNEaXJlY3RUZXh0Q2hpbGQiLCJvbGRTdGF0ZUhvb2siLCJ1cGRhdGVIb3N0SG9pc3RhYmxlIiwiY3VycmVudFByb3BzIiwicmVzb3VyY2UiLCJ1cGRhdGVIb3N0U2luZ2xldG9uIiwidXBkYXRlSG9zdFRleHQkMSIsIm1vdW50TGF6eUNvbXBvbmVudCIsIl9jdXJyZW50IiwiaXNGdW5jdGlvbkNsYXNzQ29tcG9uZW50IiwicmVzb2x2ZWRQcm9wcyIsInJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyIsIl9yZXNvbHZlZFByb3BzIiwiX3Jlc29sdmVkUHJvcHMyIiwicmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmciLCJfcmVzb2x2ZWRQcm9wczMiLCJoaW50IiwiX2NvbXBvbmVudE5hbWUyIiwiX2NvbXBvbmVudE5hbWUzIiwiU1VTUEVOREVEX01BUktFUiIsIm1vdW50U3VzcGVuc2VPZmZzY3JlZW5TdGF0ZSIsImdldFN1c3BlbmRlZENhY2hlIiwidXBkYXRlU3VzcGVuc2VPZmZzY3JlZW5TdGF0ZSIsInByZXZPZmZzY3JlZW5TdGF0ZSIsInBvb2wiLCJzaG91bGRSZW1haW5PbkZhbGxiYWNrIiwic3VzcGVuc2VDb250ZXh0IiwiZ2V0UmVtYWluaW5nV29ya0luUHJpbWFyeVRyZWUiLCJwcmltYXJ5VHJlZURpZERlZmVyIiwicGVla0RlZmVycmVkTGFuZSIsInVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50Iiwic2hvdWxkU3VzcGVuZCIsInNob3dGYWxsYmFjayIsImRpZFByaW1hcnlDaGlsZHJlbkRlZmVyIiwibW91bnREZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQiLCJuZXh0UHJpbWFyeUNoaWxkcmVuIiwibmV4dEZhbGxiYWNrQ2hpbGRyZW4iLCJmYWxsYmFjayIsImZhbGxiYWNrRnJhZ21lbnQiLCJtb3VudFN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbiIsInByaW1hcnlDaGlsZEZyYWdtZW50IiwibW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbiIsIl9kZWh5ZHJhdGVkIiwidXBkYXRlRGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50IiwiX25leHRGYWxsYmFja0NoaWxkcmVuIiwiX25leHRQcmltYXJ5Q2hpbGRyZW4iLCJmYWxsYmFja0NoaWxkRnJhZ21lbnQiLCJ1cGRhdGVTdXNwZW5zZUZhbGxiYWNrQ2hpbGRyZW4iLCJfcHJpbWFyeUNoaWxkRnJhZ21lbnQyIiwiX25leHRQcmltYXJ5Q2hpbGRyZW4yIiwiX3ByaW1hcnlDaGlsZEZyYWdtZW50MyIsInVwZGF0ZVN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuIiwicHJpbWFyeUNoaWxkcmVuIiwicHJpbWFyeUNoaWxkUHJvcHMiLCJtb3VudFdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIiLCJmYWxsYmFja0NoaWxkcmVuIiwib2Zmc2NyZWVuUHJvcHMiLCJjcmVhdGVGaWJlckZyb21PZmZzY3JlZW4iLCJ1cGRhdGVXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyIiwiY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50IiwiY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCIsInN1YnRyZWVGbGFncyIsInJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nIiwibW91bnRTdXNwZW5zZUZhbGxiYWNrQWZ0ZXJSZXRyeVdpdGhvdXRIeWRyYXRpbmciLCJmaWJlck1vZGUiLCJkaWdlc3QiLCJfZ2V0U3VzcGVuc2VJbnN0YW5jZUYiLCJjYXB0dXJlZFZhbHVlIiwiYXR0ZW1wdEh5ZHJhdGlvbkF0TGFuZSIsInJldHJ5IiwicmV0cnlEZWh5ZHJhdGVkU3VzcGVuc2VCb3VuZGFyeSIsIl9wcmltYXJ5Q2hpbGRGcmFnbWVudDQiLCJzY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIiLCJwcm9wYWdhdGlvblJvb3QiLCJzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoIiwicHJvcGFnYXRlU3VzcGVuc2VDb250ZXh0Q2hhbmdlIiwiZmlyc3RDaGlsZCIsImZpbmRMYXN0Q29udGVudFJvdyIsImxhc3RDb250ZW50Um93IiwiY3VycmVudFJvdyIsInZhbGlkYXRlUmV2ZWFsT3JkZXIiLCJ2YWxpZGF0ZVRhaWxPcHRpb25zIiwidGFpbE1vZGUiLCJ2YWxpZGF0ZVN1c3BlbnNlTGlzdE5lc3RlZENoaWxkIiwiY2hpbGRTbG90IiwiaXNBbkFycmF5IiwiaXNJdGVyYWJsZSIsInZhbGlkYXRlU3VzcGVuc2VMaXN0Q2hpbGRyZW4iLCJjaGlsZHJlbkl0ZXJhdG9yIiwiaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlIiwiaXNCYWNrd2FyZHMiLCJ0YWlsIiwicmVuZGVyU3RhdGUiLCJyZW5kZXJpbmdTdGFydFRpbWUiLCJ1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQiLCJzaG91bGRGb3JjZUZhbGxiYWNrIiwiZGlkU3VzcGVuZEJlZm9yZSIsIl90YWlsIiwibmV4dFJvdyIsInVwZGF0ZVBvcnRhbENvbXBvbmVudCIsImhhc1dhcm5lZEFib3V0VXNpbmdOb1ZhbHVlUHJvcE9uQ29udGV4dFByb3ZpZGVyIiwidXBkYXRlQ29udGV4dFByb3ZpZGVyIiwibmV3VmFsdWUiLCJwdXNoUHJvdmlkZXIiLCJvbGRWYWx1ZSIsInVwZGF0ZUNvbnRleHRDb25zdW1lciIsImNvbnN1bWVyVHlwZSIsImRlcGVuZGVuY2llcyIsInJlbW91bnRGaWJlciIsIm9sZFdvcmtJblByb2dyZXNzIiwibmV3V29ya0luUHJvZ3Jlc3MiLCJwcmV2U2libGluZyIsInVwZGF0ZUxhbmVzIiwiYXR0ZW1wdEVhcmx5QmFpbG91dElmTm9TY2hlZHVsZWRVcGRhdGUiLCJoYXNDaGlsZFdvcmsiLCJwcmltYXJ5Q2hpbGRMYW5lcyIsIl9oYXNDaGlsZFdvcmsiLCJfY2FjaGUiLCJiZWdpbldvcmsiLCJfZGVidWdOZWVkc1JlbW91bnQiLCJ1bnJlc29sdmVkUHJvcHMiLCJfQ29tcG9uZW50IiwiX3VucmVzb2x2ZWRQcm9wcyIsIl9yZXNvbHZlZFByb3BzNCIsIl91bnJlc29sdmVkUHJvcHMyIiwiX3Jlc29sdmVkUHJvcHM1IiwiX3R5cGUiLCJfdW5yZXNvbHZlZFByb3BzMyIsIl9yZXNvbHZlZFByb3BzNiIsInZhbHVlQ3Vyc29yIiwicmVuZGVyZXJDdXJzb3JERVYiLCJyZW5kZXJlcjJDdXJzb3JERVYiLCJyZW5kZXJlclNpZ2lsIiwiY3VycmVudGx5UmVuZGVyaW5nRmliZXIiLCJsYXN0Q29udGV4dERlcGVuZGVuY3kiLCJsYXN0RnVsbHlPYnNlcnZlZENvbnRleHQiLCJpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWIiwicmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzIiwicHJvdmlkZXJGaWJlciIsIl9jdXJyZW50UmVuZGVyZXIiLCJfY3VycmVudFJlbmRlcmVyMiIsInBvcFByb3ZpZGVyIiwiY3VycmVudFZhbHVlIiwiY3VycmVudFJlbmRlcmVyIiwiY3VycmVudFJlbmRlcmVyMiIsInByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VfZWFnZXIiLCJuZXh0RmliZXIiLCJsaXN0IiwiZGVwZW5kZW5jeSIsImZpcnN0Q29udGV4dCIsInBhcmVudFN1c3BlbnNlIiwiX2FsdGVybmF0ZSIsInJlYWRDb250ZXh0Rm9yQ29uc3VtZXIiLCJjb250ZXh0SXRlbSIsIm1lbW9pemVkVmFsdWUiLCJBYm9ydENvbnRyb2xsZXJMb2NhbCIsIkFib3J0Q29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlclNoaW0iLCJzaWduYWwiLCJhYm9ydGVkIiwiYWRkRXZlbnRMaXN0ZW5lciIsImFib3J0Iiwic2NoZWR1bGVDYWxsYmFjayQxIiwiTm9ybWFsUHJpb3JpdHkiLCJjb250cm9sbGVyIiwicmVmQ291bnQiLCJyZXRhaW5DYWNoZSIsInJlbGVhc2VDYWNoZSIsInBvcENhY2hlUHJvdmlkZXIiLCJwcmV2T25TdGFydFRyYW5zaXRpb25GaW5pc2giLCJvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaEZvclJlY29uY2lsZXIiLCJyZXN1bWVkQ2FjaGUiLCJwZWVrQ2FjaGVGcm9tUG9vbCIsImNhY2hlUmVzdW1lZEZyb21QcmV2aW91c1JlbmRlciIsImNhY2hlRnJvbVJvb3RDYWNoZVBvb2wiLCJwb29sZWRDYWNoZSIsImNhY2hlRnJvbVBvb2wiLCJwb29sZWRDYWNoZUxhbmVzIiwib2Zmc2NyZWVuV29ya0luUHJvZ3Jlc3MiLCJuZXdUcmFuc2l0aW9ucyIsInBvcFRyYW5zaXRpb24iLCJtYXJrVXBkYXRlIiwiZG9lc1JlcXVpcmVDbG9uZSIsImNvbXBsZXRlZFdvcmsiLCJkaWRCYWlsb3V0IiwiYXBwZW5kQWxsQ2hpbGRyZW4iLCJuZWVkc1Zpc2liaWxpdHlUb2dnbGUiLCJfbm9kZSIsImFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIiLCJjb250YWluZXJDaGlsZFNldCIsIl9pbnN0YW5jZTIiLCJfbmVlZHNWaXNpYmlsaXR5VG9nZ2xlIiwidXBkYXRlSG9zdENvbnRhaW5lciIsInBvcnRhbE9yUm9vdCIsImNvbnRhaW5lciIsIm5ld0NoaWxkU2V0IiwicGVuZGluZ0NoaWxkcmVuIiwidXBkYXRlSG9zdENvbXBvbmVudCIsImN1cnJlbnRJbnN0YW5jZSIsIl9vbGRQcm9wcyIsInJlcXVpcmVzQ2xvbmUiLCJuZXdJbnN0YW5jZSIsInByZWxvYWRJbnN0YW5jZUFuZFN1c3BlbmRJZk5lZWRlZCIsImlzUmVhZHkiLCJzaG91bGRSZW1haW5PblByZXZpb3VzU2NyZWVuIiwicHJlbG9hZFJlc291cmNlQW5kU3VzcGVuZElmTmVlZGVkIiwic2NoZWR1bGVSZXRyeUVmZmVjdCIsIndha2VhYmxlcyIsInVwZGF0ZUhvc3RUZXh0Iiwib2xkVGV4dCIsIm5ld1RleHQiLCJyb290Q29udGFpbmVySW5zdGFuY2UiLCJjdXRPZmZUYWlsSWZOZWVkZWQiLCJoYXNSZW5kZXJlZEFUYWlsRmFsbGJhY2siLCJsYXN0VGFpbE5vZGUiLCJfdGFpbE5vZGUiLCJfbGFzdFRhaWxOb2RlIiwiYnViYmxlUHJvcGVydGllcyIsIm5ld0NoaWxkTGFuZXMiLCJ0cmVlQmFzZUR1cmF0aW9uIiwiX3RyZWVCYXNlRHVyYXRpb24iLCJfY2hpbGQyIiwiX2NoaWxkMyIsImNvbXBsZXRlRGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkiLCJ3YXNIeWRyYXRlZCIsImlzVGltZWRPdXRTdXNwZW5zZSIsIl9pc1RpbWVkT3V0U3VzcGVuc2UiLCJfcHJpbWFyeUNoaWxkRnJhZ21lbnQiLCJjb21wbGV0ZVdvcmsiLCJmaWJlclJvb3QiLCJwcmV2aW91c0NhY2hlIiwicGVuZGluZ0NvbnRleHQiLCJuZXh0UmVzb3VyY2UiLCJjdXJyZW50UmVzb3VyY2UiLCJfb2xkUHJvcHMyIiwiX3dhc0h5ZHJhdGVkIiwiX3R5cGUyIiwiX2N1cnJlbnRIb3N0Q29udGV4dCIsIl93YXNIeWRyYXRlZDIiLCJfcm9vdENvbnRhaW5lckluc3RhbmNlIiwiX2luc3RhbmNlMyIsIl9yb290Q29udGFpbmVySW5zdGFuY2UyIiwiX2N1cnJlbnRIb3N0Q29udGV4dDIiLCJfd2FzSHlkcmF0ZWQzIiwiZmFsbHRocm91Z2hUb05vcm1hbFN1c3BlbnNlUGF0aCIsIm5leHREaWRUaW1lb3V0IiwicHJldkRpZFRpbWVvdXQiLCJfcHJldmlvdXNDYWNoZSIsIl9vZmZzY3JlZW5GaWJlcjIiLCJkaWRTdXNwZW5kQWxyZWFkeSIsInJlbmRlcmVkVGFpbCIsImNhbm5vdEJlU3VzcGVuZGVkIiwicmVuZGVySGFzTm90U3VzcGVuZGVkWWV0Iiwic3VzcGVuZGVkIiwiZ2V0UmVuZGVyVGFyZ2V0VGltZSIsIl9zdXNwZW5kZWQiLCJfcmV0cnlRdWV1ZTIiLCJwcmV2aW91c1NpYmxpbmciLCJuZXh0SXNIaWRkZW4iLCJfcHJldlN0YXRlIiwicHJldklzSGlkZGVuIiwiX3JldHJ5UXVldWUzIiwiX3ByZXZpb3VzQ2FjaGUyIiwiX2NhY2hlMiIsIl9wcmV2aW91c0NhY2hlMyIsIl9jYWNoZTMiLCJ1bndpbmRXb3JrIiwiX2ZsYWdzIiwiX2ZsYWdzMiIsIl9mbGFnczMiLCJ1bndpbmRJbnRlcnJ1cHRlZFdvcmsiLCJpbnRlcnJ1cHRlZFdvcmsiLCJkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsIm9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiIsIm9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4iLCJuZWVkc0Zvcm1SZXNldCIsIlBvc3NpYmx5V2Vha1NldCIsIldlYWtTZXQiLCJuZXh0RWZmZWN0IiwiaW5Qcm9ncmVzc0xhbmVzIiwiaW5Qcm9ncmVzc1Jvb3QiLCJzaG91bGRQcm9maWxlIiwiY2FsbENvbXBvbmVudFdpbGxVbm1vdW50V2l0aFRpbWVyIiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQiLCJuZWFyZXN0TW91bnRlZEFuY2VzdG9yIiwiY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IiLCJzYWZlbHlBdHRhY2hSZWYiLCJjb21taXRBdHRhY2hSZWYiLCJzYWZlbHlEZXRhY2hSZWYiLCJmaW5pc2hlZFdvcmsiLCJzYWZlbHlDYWxsRGVzdHJveSIsInNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciIsImNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyIsImNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c19iZWdpbiIsInNob3VsZEZpcmUiLCJjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHNfY29tcGxldGUiLCJjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHNPbkZpYmVyIiwic25hcHNob3QiLCJkaWRXYXJuU2V0IiwiX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUiLCJjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQiLCJzZXRJc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QiLCJjb21taXRIb29rRWZmZWN0TGlzdE1vdW50IiwiY29tbWl0UGFzc2l2ZUVmZmVjdER1cmF0aW9ucyIsImZpbmlzaGVkUm9vdCIsIl9maW5pc2hlZFdvcmskbWVtb2l6ZSIsIm9uUG9zdENvbW1pdCIsInBoYXNlIiwiY29tbWl0SG9va0xheW91dEVmZmVjdHMiLCJjb21taXRDbGFzc0xheW91dExpZmVjeWNsZXMiLCJjb21taXRDbGFzc0NhbGxiYWNrcyIsImNvbW1pdEhvc3RDb21wb25lbnRNb3VudCIsImNvbW1pdFByb2ZpbGVyVXBkYXRlIiwiX2ZpbmlzaGVkV29yayRtZW1vaXplMiIsIm9uQ29tbWl0Iiwib25SZW5kZXIiLCJlbnF1ZXVlUGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdCIsImNvbW1pdExheW91dEVmZmVjdE9uRmliZXIiLCJjb21taXR0ZWRMYW5lcyIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzIiwiY29tbWl0U3VzcGVuc2VIeWRyYXRpb25DYWxsYmFja3MiLCJpc01vZGVyblJvb3QiLCJuZXdPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4iLCJ3YXNIaWRkZW4iLCJuZXdPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIiwicHJldk9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiIsInByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIiwiaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMiLCJoaWRlT3JVbmhpZGVBbGxDaGlsZHJlbiIsImhvc3RTdWJ0cmVlUm9vdCIsImluc3RhbmNlVG9Vc2UiLCJkZXRhY2hGaWJlck11dGF0aW9uIiwiZGV0YWNoRmliZXJBZnRlckVmZmVjdHMiLCJob3N0SW5zdGFuY2UiLCJlbXB0eVBvcnRhbENvbnRhaW5lciIsImVtcHR5Q2hpbGRTZXQiLCJnZXRIb3N0UGFyZW50RmliZXIiLCJpc0hvc3RQYXJlbnQiLCJnZXRIb3N0U2libGluZyIsImNvbW1pdFBsYWNlbWVudCIsImJlZm9yZSIsImluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZSIsIl9wYXJlbnQiLCJfYmVmb3JlIiwiX3BhcmVudDIiLCJfYmVmb3JlMiIsImluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIiLCJpc0hvc3QiLCJob3N0UGFyZW50IiwiaG9zdFBhcmVudElzQ29udGFpbmVyIiwiY29tbWl0RGVsZXRpb25FZmZlY3RzIiwiZGVsZXRlZEZpYmVyIiwiZmluZFBhcmVudCIsImNvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIiLCJyZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzIiwicHJldkhvc3RQYXJlbnQiLCJwcmV2SG9zdFBhcmVudElzQ29udGFpbmVyIiwiX3ByZXZIb3N0UGFyZW50IiwiX3ByZXZIb3N0UGFyZW50SXNDb250YWluZXIiLCJfcHJldkhvc3RQYXJlbnQyIiwiX3ByZXZIb3N0UGFyZW50SXNDb250YWluZXIyIiwiY29tbWl0U3VzcGVuc2VDYWxsYmFjayIsImh5ZHJhdGlvbkNhbGxiYWNrcyIsIm9uSHlkcmF0ZWQiLCJnZXRSZXRyeUNhY2hlIiwicmV0cnlDYWNoZSIsIl9yZXRyeUNhY2hlIiwiZGV0YWNoT2Zmc2NyZWVuSW5zdGFuY2UiLCJhdHRhY2hPZmZzY3JlZW5JbnN0YW5jZSIsImF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMiLCJyZXNvbHZlUmV0cnlXYWtlYWJsZSIsImNvbW1pdE11dGF0aW9uRWZmZWN0cyIsImNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIiLCJyZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzIiwiY3VycmVudEhvaXN0YWJsZVJvb3QiLCJjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMiLCJob2lzdGFibGVSb290IiwibmV3UmVzb3VyY2UiLCJwcmV2aW91c1dvcmsiLCJzaW5nbGV0b24iLCJwcmV2aW91c0hvaXN0YWJsZVJvb3QiLCJwcmV2Um9vdFN0YXRlIiwicmVjdXJzaXZlbHlSZXNldEZvcm1zIiwiX3ByZXZpb3VzSG9pc3RhYmxlUm9vdCIsIl9jb250YWluZXJJbmZvIiwiX3BlbmRpbmdDaGlsZHJlbiIsImlzU2hvd2luZ0ZhbGxiYWNrIiwid2FzU2hvd2luZ0ZhbGxiYWNrIiwibWFya0NvbW1pdFRpbWVPZkZhbGxiYWNrIiwiaXNVcGRhdGUiLCJ3YXNIaWRkZW5CeUFuY2VzdG9yT2Zmc2NyZWVuIiwicmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMiLCJyZXNldEZvcm1PbkZpYmVyIiwiZm9ybUluc3RhbmNlIiwiY29tbWl0TGF5b3V0RWZmZWN0cyIsImRpc2FwcGVhckxheW91dEVmZmVjdHMiLCJyZWFwcGVhckxheW91dEVmZmVjdHMiLCJvZmZzY3JlZW5TdGF0ZSIsImNoaWxkU2hvdWxkSW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyIsImNvbW1pdEhvb2tQYXNzaXZlTW91bnRFZmZlY3RzIiwiY29tbWl0T2Zmc2NyZWVuUGFzc2l2ZU1vdW50RWZmZWN0cyIsImNvbW1pdENhY2hlUGFzc2l2ZU1vdW50RWZmZWN0IiwiY29tbWl0UGFzc2l2ZU1vdW50RWZmZWN0cyIsImNvbW1pdHRlZFRyYW5zaXRpb25zIiwiY29tbWl0UGFzc2l2ZU1vdW50T25GaWJlciIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzIiwicmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzIiwicmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzIiwiX2N1cnJlbnQyIiwicmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMiLCJfaW5zdGFuY2U0IiwiX2N1cnJlbnQzIiwiX2N1cnJlbnQ0IiwiY29tbWl0QXRvbWljUGFzc2l2ZUVmZmVjdHMiLCJfY3VycmVudDUiLCJjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHMiLCJjb21taXRQYXNzaXZlVW5tb3VudE9uRmliZXIiLCJzdXNwZW5zZXlDb21taXRGbGFnIiwiYWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdCIsImFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXRPbkZpYmVyIiwicmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0IiwiX3Byb3BzIiwicHJldkZsYWdzIiwiZGV0YWNoQWx0ZXJuYXRlU2libGluZ3MiLCJwcmV2aW91c0ZpYmVyIiwiZGV0YWNoZWRDaGlsZCIsImRldGFjaGVkU2libGluZyIsImNvbW1pdEhvb2tQYXNzaXZlVW5tb3VudEVmZmVjdHMiLCJyZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzIiwiY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9iZWdpbiIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMiLCJkaXNjb25uZWN0UGFzc2l2ZUVmZmVjdCIsImRlbGV0ZWRTdWJ0cmVlUm9vdCIsImNvbW1pdFBhc3NpdmVVbm1vdW50SW5zaWRlRGVsZXRlZFRyZWVPbkZpYmVyIiwiY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9jb21wbGV0ZSIsImdldENhY2hlRm9yVHlwZSIsInJlc291cmNlVHlwZSIsImNhY2hlRm9yVHlwZSIsIkRlZmF1bHRBc3luY0Rpc3BhdGNoZXIiLCJnZXRPd25lciIsIkNPTVBPTkVOVF9UWVBFIiwiSEFTX1BTRVVET19DTEFTU19UWVBFIiwiUk9MRV9UWVBFIiwiVEVTVF9OQU1FX1RZUEUiLCJURVhUX1RZUEUiLCJzeW1ib2xGb3IiLCJjcmVhdGVDb21wb25lbnRTZWxlY3RvciIsImNyZWF0ZUhhc1BzZXVkb0NsYXNzU2VsZWN0b3IiLCJzZWxlY3RvcnMiLCJjcmVhdGVSb2xlU2VsZWN0b3IiLCJyb2xlIiwiY3JlYXRlVGV4dFNlbGVjdG9yIiwiY3JlYXRlVGVzdE5hbWVTZWxlY3RvciIsImZpbmRGaWJlclJvb3RGb3JIb3N0Um9vdCIsImhvc3RSb290IiwibWF5YmVGaWJlciIsIm1hdGNoU2VsZWN0b3IiLCJzZWxlY3RvciIsImhhc01hdGNoaW5nUGF0aHMiLCJkYXRhVGVzdElEIiwic2VsZWN0b3JUb1N0cmluZyIsImZpbmRQYXRocyIsIm1hdGNoaW5nRmliZXJzIiwic2VsZWN0b3JJbmRleCIsImZpbmRBbGxOb2RlcyIsImluc3RhbmNlUm9vdHMiLCJmcm9tIiwiZ2V0RmluZEFsbE5vZGVzRmFpbHVyZURlc2NyaXB0aW9uIiwibWF4U2VsZWN0b3JJbmRleCIsIm1hdGNoZWROYW1lcyIsInVubWF0Y2hlZE5hbWVzIiwiZmluZEJvdW5kaW5nUmVjdHMiLCJib3VuZGluZ1JlY3RzIiwidGFyZ2V0UmVjdCIsInRhcmdldExlZnQiLCJ0YXJnZXRSaWdodCIsIndpZHRoIiwidGFyZ2V0VG9wIiwidGFyZ2V0Qm90dG9tIiwiaGVpZ2h0IiwiaiIsIm90aGVyUmVjdCIsIm90aGVyTGVmdCIsIm90aGVyUmlnaHQiLCJvdGhlclRvcCIsIm90aGVyQm90dG9tIiwic3BsaWNlIiwiZm9jdXNXaXRoaW4iLCJjb21taXRIb29rcyIsIm9uQ29tbWl0Um9vdCIsImNvbW1pdEhvb2siLCJvYnNlcnZlVmlzaWJsZVJlY3RzIiwiX3NldHVwSW50ZXJzZWN0aW9uT2JzIiwiZGlzY29ubmVjdCIsIm9ic2VydmUiLCJ1bm9ic2VydmUiLCJuZXh0SW5zdGFuY2VSb290cyIsInRhcmdldCIsImlzQ29uY3VycmVudEFjdEVudmlyb25tZW50IiwiaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsIiwiSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UIiwiUG9zc2libHlXZWFrTWFwIiwiQmF0Y2hlZENvbnRleHQiLCJSb290SW5Qcm9ncmVzcyIsIlJvb3RGYXRhbEVycm9yZWQiLCJSb290RXJyb3JlZCIsIlJvb3RTdXNwZW5kZWQiLCJSb290U3VzcGVuZGVkV2l0aERlbGF5IiwiUm9vdENvbXBsZXRlZCIsIlJvb3REaWROb3RDb21wbGV0ZSIsIk5vdFN1c3BlbmRlZCIsIlN1c3BlbmRlZE9uRXJyb3IiLCJTdXNwZW5kZWRPbkRhdGEiLCJTdXNwZW5kZWRPbkltbWVkaWF0ZSIsIlN1c3BlbmRlZE9uSW5zdGFuY2UiLCJTdXNwZW5kZWRPbkluc3RhbmNlQW5kUmVhZHlUb0NvbnRpbnVlIiwiU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlIiwiU3VzcGVuZGVkQW5kUmVhZHlUb0NvbnRpbnVlIiwiU3VzcGVuZGVkT25IeWRyYXRpb24iLCJ3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiIsIndvcmtJblByb2dyZXNzVGhyb3duVmFsdWUiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3REaWRBdHRhY2hQaW5nTGlzdGVuZXIiLCJlbnRhbmdsZWRSZW5kZXJMYW5lcyIsIndvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcyIsIndvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzIiwid29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzIiwid29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlIiwiZGlkSW5jbHVkZUNvbW1pdFBoYXNlVXBkYXRlIiwiZ2xvYmFsTW9zdFJlY2VudEZhbGxiYWNrVGltZSIsIkZBTExCQUNLX1RIUk9UVExFX01TIiwid29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZSIsIkluZmluaXR5IiwiUkVOREVSX1RJTUVPVVRfTVMiLCJ3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zIiwicmVzZXRSZW5kZXJUaW1lciIsImxlZ2FjeUVycm9yQm91bmRhcmllc1RoYXRBbHJlYWR5RmFpbGVkIiwicm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMiLCJyb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyIsInBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzIiwicGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdHMiLCJwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW1haW5pbmdMYW5lcyIsInBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMiLCJORVNURURfVVBEQVRFX0xJTUlUIiwibmVzdGVkVXBkYXRlQ291bnQiLCJyb290V2l0aE5lc3RlZFVwZGF0ZXMiLCJpc0ZsdXNoaW5nUGFzc2l2ZUVmZmVjdHMiLCJkaWRTY2hlZHVsZVVwZGF0ZUR1cmluZ1Bhc3NpdmVFZmZlY3RzIiwiTkVTVEVEX1BBU1NJVkVfVVBEQVRFX0xJTUlUIiwibmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50Iiwicm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcyIsImlzUnVubmluZ0luc2VydGlvbkVmZmVjdCIsImFjdGlvblNjb3BlTGFuZSIsInJlcXVlc3RSZXRyeUxhbmUiLCJpc1ByZXJlbmRlcmluZyIsInN1c3BlbnNlSGFuZGxlciIsInByZXBhcmVGcmVzaFN0YWNrIiwibWFya1Jvb3RTdXNwZW5kZWQiLCJtYXJrUm9vdFVwZGF0ZWQiLCJ3YXJuQWJvdXRSZW5kZXJQaGFzZVVwZGF0ZXNJbkRFViIsIndhcm5JZlVwZGF0ZXNOb3RXcmFwcGVkV2l0aEFjdERFViIsImlzQmF0Y2hpbmdMZWdhY3kiLCJzY2hlZHVsZUluaXRpYWxIeWRyYXRpb25PblJvb3QiLCJkaWRUaW1lb3V0IiwiZGlkRmx1c2hQYXNzaXZlRWZmZWN0cyIsImZsdXNoUGFzc2l2ZUVmZmVjdHMiLCJzaG91bGRUaW1lU2xpY2UiLCJleGl0U3RhdHVzIiwicmVuZGVyUm9vdENvbmN1cnJlbnQiLCJyZW5kZXJSb290U3luYyIsInJlbmRlcldhc0NvbmN1cnJlbnQiLCJpc1JlbmRlckNvbnNpc3RlbnRXaXRoRXh0ZXJuYWxTdG9yZXMiLCJsYW5lc1RoYXRKdXN0RXJyb3JlZCIsImVycm9yUmV0cnlMYW5lcyIsInJlY292ZXJGcm9tQ29uY3VycmVudEVycm9yIiwiZmluaXNoZWRMYW5lcyIsImZpbmlzaENvbmN1cnJlbnRSZW5kZXIiLCJlcnJvcnNGcm9tRmlyc3RBdHRlbXB0Iiwid2FzUm9vdERlaHlkcmF0ZWQiLCJyb290V29ya0luUHJvZ3Jlc3MiLCJlcnJvcnNGcm9tU2Vjb25kQXR0ZW1wdCIsImVycm9ycyIsInNob3VsZEZvcmNlRmx1c2hGYWxsYmFja3NJbkRFViIsImNvbW1pdFJvb3QiLCJtc1VudGlsVGltZW91dCIsInRpbWVvdXRIYW5kbGUiLCJjb21taXRSb290V2hlblJlYWR5IiwicmVjb3ZlcmFibGVFcnJvcnMiLCJkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUiLCJCb3RoVmlzaWJpbGl0eUFuZE1heVN1c3BlbmRDb21taXQiLCJzY2hlZHVsZVBlbmRpbmdDb21taXQiLCJjaGVja3MiLCJyZW5kZXJlZFZhbHVlIiwidXBkYXRlZExhbmVzIiwibWFya1Jvb3RQaW5nZWQiLCJmbHVzaFJvb3QiLCJkZWZlcnJlZFVwZGF0ZXMiLCJiYXRjaGVkVXBkYXRlcyIsImRpc2NyZXRlVXBkYXRlcyIsImQiLCJmbHVzaFN5bmNGcm9tUmVjb25jaWxlciIsInByZXZFeGVjdXRpb25Db250ZXh0IiwiZmx1c2hTeW5jV29yayIsImlzQWxyZWFkeVJlbmRlcmluZyIsIm5ld0VudGFuZ2xlZFJlbmRlckxhbmVzIiwicmVzZXRXb3JrSW5Qcm9ncmVzc1N0YWNrIiwicmVzZXRTdXNwZW5kZWRXb3JrTG9vcE9uVW53aW5kIiwiaGFuZGxlVGhyb3ciLCJpc1dha2VhYmxlIiwiZXJyb3JlZFdvcmsiLCJwdXNoRGlzcGF0Y2hlciIsInBvcERpc3BhdGNoZXIiLCJwdXNoQXN5bmNEaXNwYXRjaGVyIiwicHJldkFzeW5jRGlzcGF0Y2hlciIsIkEiLCJwb3BBc3luY0Rpc3BhdGNoZXIiLCJkaWRTdXNwZW5kSW5TaGVsbCIsInVuaXRPZldvcmsiLCJ0aHJvd0FuZFVud2luZFdvcmtMb29wIiwid29ya0xvb3BTeW5jIiwicGVyZm9ybVVuaXRPZldvcmsiLCJyZXN1bWVPclVud2luZCIsInJlcGxheVN1c3BlbmRlZFVuaXRPZldvcmsiLCJvblJlc29sdXRpb24iLCJfdGhlbmFibGUiLCJob3N0RmliZXIiLCJjb21wbGV0ZVVuaXRPZldvcmsiLCJ3b3JrTG9vcENvbmN1cnJlbnQiLCJpc1Byb2ZpbGluZ01vZGUiLCJkaWRGYXRhbCIsInBhbmljT25Sb290RXJyb3IiLCJ1bndpbmRVbml0T2ZXb3JrIiwic2libGluZ0ZpYmVyIiwiaW5jb21wbGV0ZVdvcmsiLCJwcmV2aW91c1VwZGF0ZUxhbmVQcmlvcml0eSIsImNvbW1pdFJvb3RJbXBsIiwicmVuZGVyUHJpb3JpdHlMZXZlbCIsImZsdXNoUmVuZGVyUGhhc2VTdHJpY3RNb2RlV2FybmluZ3NJbkRFViIsInNjaGVkdWxlQ2FsbGJhY2siLCJzdWJ0cmVlSGFzRWZmZWN0cyIsInJvb3RIYXNFZmZlY3QiLCJyb290RGlkSGF2ZVBhc3NpdmVFZmZlY3RzIiwicmVsZWFzZVJvb3RQb29sZWRDYWNoZSIsImNvbW1pdERvdWJsZUludm9rZUVmZmVjdHNJbkRFViIsIm9uUmVjb3ZlcmFibGVFcnJvciIsIm1ha2VFcnJvckluZm8iLCJyZW5kZXJQcmlvcml0eSIsInByaW9yaXR5IiwiZmx1c2hQYXNzaXZlRWZmZWN0c0ltcGwiLCJwcm9maWxlckVmZmVjdHMiLCJjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdCIsInJvb3RGaWJlciIsInBpbmdDYWNoZSIsInRocmVhZElEcyIsInBpbmciLCJwaW5nU3VzcGVuZGVkUm9vdCIsIndhcm5JZlN1c3BlbnNlUmVzb2x1dGlvbk5vdFdyYXBwZWRXaXRoQWN0REVWIiwicmV0cnlUaW1lZE91dEJvdW5kYXJ5IiwiYm91bmRhcnlGaWJlciIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VBbmREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYiLCJpc0luU3RyaWN0TW9kZSIsImRvdWJsZUludm9rZUVmZmVjdHNJbkRFVklmTmVjZXNzYXJ5IiwiZG91YmxlSW52b2tlRWZmZWN0c09uRmliZXIiLCJzaG91bGREb3VibGVJbnZva2VQYXNzaXZlRWZmZWN0cyIsInBhcmVudElzSW5TdHJpY3RNb2RlIiwiaXNTdHJpY3RNb2RlRmliZXIiLCJoYXNQYXNzaXZlRWZmZWN0cyIsImRvdWJsZUludm9rZUVmZmVjdHMiLCJkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50IiwiZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXIiLCJkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQiLCJyZW5kZXJpbmdDb21wb25lbnROYW1lIiwiZGVkdXBlS2V5Iiwic2V0U3RhdGVDb21wb25lbnROYW1lIiwic2NoZWR1bGluZ0ZpYmVyIiwiZmFrZUFjdENhbGxiYWNrTm9kZSIsImlzUnVubmluZyIsInJlc29sdmVGYW1pbHkiLCJmYWlsZWRCb3VuZGFyaWVzIiwic2V0UmVmcmVzaEhhbmRsZXIiLCJmYW1pbHkiLCJjdXJyZW50UmVuZGVyIiwic3ludGhldGljVHlwZSIsInByZXZUeXBlIiwibmV4dFR5cGUiLCJuZWVkc0NvbXBhcmVGYW1pbGllcyIsIiQkdHlwZW9mTmV4dFR5cGUiLCJwcmV2RmFtaWx5Iiwic2NoZWR1bGVSZWZyZXNoIiwic3RhbGVGYW1pbGllcyIsInVwZGF0ZWRGYW1pbGllcyIsInNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkiLCJzY2hlZHVsZVJvb3QiLCJ1cGRhdGVDb250YWluZXJTeW5jIiwiY2FuZGlkYXRlVHlwZSIsIm5lZWRzUmVuZGVyIiwibmVlZHNSZW1vdW50IiwiZmluZEhvc3RJbnN0YW5jZXNGb3JSZWZyZXNoIiwiZmFtaWxpZXMiLCJob3N0SW5zdGFuY2VzIiwidHlwZXMiLCJmaW5kSG9zdEluc3RhbmNlc0Zvck1hdGNoaW5nRmliZXJzUmVjdXJzaXZlbHkiLCJkaWRNYXRjaCIsImZpbmRIb3N0SW5zdGFuY2VzRm9yRmliZXJTaGFsbG93bHkiLCJmb3VuZEhvc3RJbnN0YW5jZXMiLCJmaW5kQ2hpbGRIb3N0SW5zdGFuY2VzRm9yRmliZXJTaGFsbG93bHkiLCJoYXNCYWRNYXBQb2x5ZmlsbCIsIm5vbkV4dGVuc2libGVPYmplY3QiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsIkZpYmVyTm9kZSIsIk51bWJlciIsIk5hTiIsImNyZWF0ZUZpYmVyIiwic2hvdWxkQ29uc3RydWN0IiwiaXNSZWFjdENvbXBvbmVudCIsImN1cnJlbnREZXBlbmRlbmNpZXMiLCJjcmVhdGVIb3N0Um9vdEZpYmVyIiwiaXNTdHJpY3RNb2RlIiwiY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSIsImZpYmVyVGFnIiwiX2hvc3RDb250ZXh0IiwiZ2V0VGFnIiwiY3JlYXRlRmliZXJGcm9tUHJvZmlsZXIiLCJjcmVhdGVGaWJlckZyb21TdXNwZW5zZSIsImNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlTGlzdCIsInR5cGVTdHJpbmciLCJlbGVtZW50cyIsInByaW1hcnlDaGlsZEluc3RhbmNlIiwiX3BlbmRpbmdNYXJrZXJzIiwiX3RyYW5zaXRpb25zIiwiZGV0YWNoIiwiYXR0YWNoIiwiZGVoeWRyYXRlZE5vZGUiLCJGaWJlclJvb3ROb2RlIiwiaHlkcmF0ZSIsImluY29tcGxldGVUcmFuc2l0aW9ucyIsIl9kZWJ1Z1Jvb3RUeXBlIiwiY3JlYXRlRmliZXJSb290IiwiaW5pdGlhbENoaWxkcmVuIiwidHJhbnNpdGlvbkNhbGxiYWNrcyIsInVuaW5pdGlhbGl6ZWRGaWJlciIsImluaXRpYWxDYWNoZSIsIlJlYWN0VmVyc2lvbiIsInR5cGVOYW1lIiwiaGFzVG9TdHJpbmdUYWciLCJ0b1N0cmluZ1RhZyIsImNvbnN0cnVjdG9yIiwid2lsbENvZXJjaW9uVGhyb3ciLCJ0ZXN0U3RyaW5nQ29lcmNpb24iLCJjaGVja0tleVN0cmluZ0NvZXJjaW9uIiwiY3JlYXRlUG9ydGFsIiwiZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyIsImRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlIiwiZ2V0Q29udGV4dEZvclN1YnRyZWUiLCJwYXJlbnRDb21wb25lbnQiLCJmaW5kSG9zdEluc3RhbmNlIiwiZmluZEhvc3RJbnN0YW5jZVdpdGhXYXJuaW5nIiwibWV0aG9kTmFtZSIsImNyZWF0ZUNvbnRhaW5lciIsImNyZWF0ZUh5ZHJhdGlvbkNvbnRhaW5lciIsInVwZGF0ZUNvbnRhaW5lciIsInVwZGF0ZUNvbnRhaW5lckltcGwiLCJnZXRQdWJsaWNSb290SW5zdGFuY2UiLCJjb250YWluZXJGaWJlciIsImF0dGVtcHRTeW5jaHJvbm91c0h5ZHJhdGlvbiIsIl9yb290IiwibWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQiLCJtYXJrUmV0cnlMYW5lSW1wbCIsImF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uIiwiYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5IiwiZmluZEhvc3RJbnN0YW5jZVdpdGhOb1BvcnRhbHMiLCJzaG91bGRFcnJvckltcGwiLCJzaG91bGRTdXNwZW5kSW1wbCIsIm92ZXJyaWRlSG9va1N0YXRlIiwib3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoIiwib3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoIiwib3ZlcnJpZGVQcm9wcyIsIm92ZXJyaWRlUHJvcHNEZWxldGVQYXRoIiwib3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGgiLCJzY2hlZHVsZVVwZGF0ZSIsInNldEVycm9ySGFuZGxlciIsInNldFN1c3BlbnNlSGFuZGxlciIsImNvcHlXaXRoRGVsZXRlSW1wbCIsIm9iaiIsInBhdGgiLCJjb3B5V2l0aERlbGV0ZSIsImNvcHlXaXRoUmVuYW1lSW1wbCIsIm9sZFBhdGgiLCJuZXdQYXRoIiwib2xkS2V5IiwibmV3S2V5IiwiY29weVdpdGhSZW5hbWUiLCJjb3B5V2l0aFNldEltcGwiLCJjb3B5V2l0aFNldCIsImZpbmRIb29rIiwibmV3U2hvdWxkRXJyb3JJbXBsIiwibmV3U2hvdWxkU3VzcGVuZEltcGwiLCJmaW5kSG9zdEluc3RhbmNlQnlGaWJlciIsImVtcHR5RmluZEZpYmVyQnlIb3N0SW5zdGFuY2UiLCJnZXRDdXJyZW50RmliZXJGb3JEZXZUb29scyIsImluamVjdEludG9EZXZUb29scyIsImRldlRvb2xzQ29uZmlnIiwiZmluZEZpYmVyQnlIb3N0SW5zdGFuY2UiLCJidW5kbGVUeXBlIiwidmVyc2lvbiIsInJlbmRlcmVyUGFja2FnZU5hbWUiLCJyZW5kZXJlckNvbmZpZyIsImN1cnJlbnREaXNwYXRjaGVyUmVmIiwicmVjb25jaWxlclZlcnNpb24iLCJkZWZhdWx0Il0sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0/node_modules/react-reconciler/cjs/react-reconciler.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0/node_modules/react-reconciler/constants.js":
/*!***********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0/node_modules/react-reconciler/constants.js ***!
  \***********************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-reconciler-constants.development.js */ \"(ssr)/./node_modules/.pnpm/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0/node_modules/react-reconciler/cjs/react-reconciler-constants.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtcmVjb25jaWxlckAwLjMxLjAtcmMtOTM1MTgwYzdlMC0yMDI0MDUyNF9yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL3JlYWN0LXJlY29uY2lsZXIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSxpUUFBMkU7QUFDN0UiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taG1kL0RvY3VtZW50cy9HaXRIdWIvQVdNLUxhYmVlYi1BaS9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtcmVjb25jaWxlckAwLjMxLjAtcmMtOTM1MTgwYzdlMC0yMDI0MDUyNF9yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL3JlYWN0LXJlY29uY2lsZXIvY29uc3RhbnRzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLWNvbnN0YW50cy5wcm9kdWN0aW9uLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LXJlY29uY2lsZXItY29uc3RhbnRzLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0/node_modules/react-reconciler/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0/node_modules/react-reconciler/index.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0/node_modules/react-reconciler/index.js ***!
  \*******************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-reconciler.development.js */ \"(ssr)/./node_modules/.pnpm/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0/node_modules/react-reconciler/cjs/react-reconciler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtcmVjb25jaWxlckAwLjMxLjAtcmMtOTM1MTgwYzdlMC0yMDI0MDUyNF9yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL3JlYWN0LXJlY29uY2lsZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLDZPQUFpRTtBQUNuRSIsInNvdXJjZXMiOlsiL1VzZXJzL21obWQvRG9jdW1lbnRzL0dpdEh1Yi9BV00tTGFiZWViLUFpL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1yZWNvbmNpbGVyQDAuMzEuMC1yYy05MzUxODBjN2UwLTIwMjQwNTI0X3JlYWN0QDE5LjAuMC9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtcmVjb25jaWxlci5wcm9kdWN0aW9uLmpzJyk7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LXJlY29uY2lsZXIuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0/node_modules/react-reconciler/index.js\n");

/***/ })

};
;