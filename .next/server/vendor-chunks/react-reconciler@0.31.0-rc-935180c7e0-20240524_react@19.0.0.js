"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0";
exports.ids = ["vendor-chunks/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0/node_modules/react-reconciler/cjs/react-reconciler-constants.development.js":
/*!********************************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0/node_modules/react-reconciler/cjs/react-reconciler-constants.development.js ***!
  \********************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * react-reconciler-constants.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar NoLane =\n/*                          */\n0;\nvar SyncLane =\n/*                        */\n2;\nvar InputContinuousLane =\n/*             */\n8;\nvar DefaultLane =\n/*                     */\n32;\nvar IdleLane =\n/*                        */\n268435456;\n\nvar NoEventPriority = NoLane;\nvar DiscreteEventPriority = SyncLane;\nvar ContinuousEventPriority = InputContinuousLane;\nvar DefaultEventPriority = DefaultLane;\nvar IdleEventPriority = IdleLane;\n\nvar LegacyRoot = 0;\nvar ConcurrentRoot = 1;\n\nexports.ConcurrentRoot = ConcurrentRoot;\nexports.ContinuousEventPriority = ContinuousEventPriority;\nexports.DefaultEventPriority = DefaultEventPriority;\nexports.DiscreteEventPriority = DiscreteEventPriority;\nexports.IdleEventPriority = IdleEventPriority;\nexports.LegacyRoot = LegacyRoot;\nexports.NoEventPriority = NoEventPriority;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtcmVjb25jaWxlckAwLjMxLjAtcmMtOTM1MTgwYzdlMC0yMDI0MDUyNF9yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL3JlYWN0LXJlY29uY2lsZXIvY2pzL3JlYWN0LXJlY29uY2lsZXItY29uc3RhbnRzLmRldmVsb3BtZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEIsK0JBQStCO0FBQy9CLDRCQUE0QjtBQUM1Qiw2QkFBNkI7QUFDN0IseUJBQXlCO0FBQ3pCLGtCQUFrQjtBQUNsQix1QkFBdUI7QUFDdkIsR0FBRztBQUNIIiwic291cmNlcyI6WyIvVXNlcnMvbWhtZC9Eb2N1bWVudHMvR2l0SHViL0FXTS1kYXRhdGhvbi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtcmVjb25jaWxlckAwLjMxLjAtcmMtOTM1MTgwYzdlMC0yMDI0MDUyNF9yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL3JlYWN0LXJlY29uY2lsZXIvY2pzL3JlYWN0LXJlY29uY2lsZXItY29uc3RhbnRzLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LXJlY29uY2lsZXItY29uc3RhbnRzLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTm9MYW5lID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuMDtcbnZhciBTeW5jTGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG4yO1xudmFyIElucHV0Q29udGludW91c0xhbmUgPVxuLyogICAgICAgICAgICAgKi9cbjg7XG52YXIgRGVmYXVsdExhbmUgPVxuLyogICAgICAgICAgICAgICAgICAgICAqL1xuMzI7XG52YXIgSWRsZUxhbmUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMjY4NDM1NDU2O1xuXG52YXIgTm9FdmVudFByaW9yaXR5ID0gTm9MYW5lO1xudmFyIERpc2NyZXRlRXZlbnRQcmlvcml0eSA9IFN5bmNMYW5lO1xudmFyIENvbnRpbnVvdXNFdmVudFByaW9yaXR5ID0gSW5wdXRDb250aW51b3VzTGFuZTtcbnZhciBEZWZhdWx0RXZlbnRQcmlvcml0eSA9IERlZmF1bHRMYW5lO1xudmFyIElkbGVFdmVudFByaW9yaXR5ID0gSWRsZUxhbmU7XG5cbnZhciBMZWdhY3lSb290ID0gMDtcbnZhciBDb25jdXJyZW50Um9vdCA9IDE7XG5cbmV4cG9ydHMuQ29uY3VycmVudFJvb3QgPSBDb25jdXJyZW50Um9vdDtcbmV4cG9ydHMuQ29udGludW91c0V2ZW50UHJpb3JpdHkgPSBDb250aW51b3VzRXZlbnRQcmlvcml0eTtcbmV4cG9ydHMuRGVmYXVsdEV2ZW50UHJpb3JpdHkgPSBEZWZhdWx0RXZlbnRQcmlvcml0eTtcbmV4cG9ydHMuRGlzY3JldGVFdmVudFByaW9yaXR5ID0gRGlzY3JldGVFdmVudFByaW9yaXR5O1xuZXhwb3J0cy5JZGxlRXZlbnRQcmlvcml0eSA9IElkbGVFdmVudFByaW9yaXR5O1xuZXhwb3J0cy5MZWdhY3lSb290ID0gTGVnYWN5Um9vdDtcbmV4cG9ydHMuTm9FdmVudFByaW9yaXR5ID0gTm9FdmVudFByaW9yaXR5O1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0/node_modules/react-reconciler/cjs/react-reconciler-constants.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0/node_modules/react-reconciler/cjs/react-reconciler.development.js":
/*!**********************************************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0/node_modules/react-reconciler/cjs/react-reconciler.development.js ***!
  \**********************************************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @license React\n * react-reconciler.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    module.exports = function $$$reconciler($$$config) {\n        var exports = {};\n        'use strict';\n        var React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/.pnpm/next@15.1.7_react-dom@19.0.0_react@19.0.0/node_modules/next/dist/server/route-modules/app-page/vendored/ssr/react.js\");\n        var Scheduler = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/.pnpm/scheduler@0.25.0-rc-935180c7e0-20240524/node_modules/scheduler/index.js\");\n        var ReactSharedInternals = React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;\n        var suppressWarning = false;\n        function setSuppressWarning(newSuppressWarning) {\n            {\n                suppressWarning = newSuppressWarning;\n            }\n        } // In DEV, calls to console.warn and console.error get replaced\n        // by calls to these methods by a Babel plugin.\n        //\n        // In PROD (or in packages without access to React internals),\n        // they are left as they are instead.\n        function warn(format) {\n            {\n                if (!suppressWarning) {\n                    for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n                        args[_key - 1] = arguments[_key];\n                    }\n                    printWarning('warn', format, args);\n                }\n            }\n        }\n        function error(format) {\n            {\n                if (!suppressWarning) {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning('error', format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var isErrorLogger = format === '%s\\n\\n%s\\n' || format === '%o\\n\\n%s\\n\\n%s\\n';\n                if (ReactSharedInternals.getCurrentStack) {\n                    var stack = ReactSharedInternals.getCurrentStack();\n                    if (stack !== '') {\n                        format += '%s';\n                        args = args.concat([\n                            stack\n                        ]);\n                    }\n                }\n                if (isErrorLogger) {\n                    // Don't prefix our default logging formatting in ReactFiberErrorLoggger.\n                    // Don't toString the arguments.\n                    args.unshift(format);\n                } else {\n                    // TODO: Remove this prefix and stop toStringing in the wrapper and\n                    // instead do it at each callsite as needed.\n                    // Careful: RN currently depends on this prefix\n                    // eslint-disable-next-line react-internal/safe-string-coercion\n                    args = args.map(function(item) {\n                        return String(item);\n                    });\n                    args.unshift('Warning: ' + format);\n                } // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, args);\n            }\n        }\n        var assign = Object.assign;\n        var LegacyRoot = 0;\n        var ConcurrentRoot = 1;\n        /**\n * `ReactInstanceMap` maintains a mapping from a public facing stateful\n * instance (key) and the internal representation (value). This allows public\n * methods to accept the user facing instance as an argument and map them back\n * to internal methods.\n *\n * Note that this module is currently shared and assumed to be stateless.\n * If this becomes an actual Map, that will break.\n */ function get(key) {\n            return key._reactInternals;\n        }\n        function set(key, value) {\n            key._reactInternals = value;\n        }\n        // -----------------------------------------------------------------------------\n        // Killswitch\n        //\n        // Flags that exist solely to turn off a change in case it causes a regression\n        // when it rolls out to prod. We should remove these as soon as possible.\n        // -----------------------------------------------------------------------------\n        // -----------------------------------------------------------------------------\n        // Land or remove (moderate effort)\n        //\n        // Flags that can be probably deleted or landed, but might require extra effort\n        // like migrating internal callers or performance testing.\n        // -----------------------------------------------------------------------------\n        // TODO: Finish rolling out in www\n        var favorSafetyOverHydrationPerf = true;\n        var enableAsyncActions = true; // Need to remove didTimeout argument from Scheduler before landing\n        var disableDefaultPropsExceptForClasses = true; // -----------------------------------------------------------------------------\n        // Slated for removal in the future (significant effort)\n        //\n        // These are experiments that didn't work out, and never shipped, but we can't\n        // delete from the codebase until we migrate internal callers.\n        // -----------------------------------------------------------------------------\n        // Add a callback property to suspense to notify which promises are currently\n        // in the update queue. This allows reporting and tracing of what is causing\n        // the user to see a loading state.\n        //\n        // Also allows hydration callbacks to fire when a dehydrated boundary gets\n        // hydrated or deleted.\n        //\n        // This will eventually be replaced by the Transition Tracing proposal.\n        var enableSuspenseCallback = false; // Experimental Scope support.\n        var enableAsyncIterableChildren = false;\n        var enableLazyContextPropagation = false; // FB-only usage. The new API has different semantics.\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        var alwaysThrottleRetries = true;\n        var passChildrenWhenCloningPersistedNodes = false;\n        var syncLaneExpirationMs = 250;\n        var transitionLaneExpirationMs = 5000; // -----------------------------------------------------------------------------\n        // This allows us to land breaking changes to remove legacy mode APIs in experimental builds\n        // before removing them in stable in the next Major\n        var disableLegacyMode = true;\n        // Debugging and DevTools\n        // -----------------------------------------------------------------------------\n        // Adds user timing marks for e.g. state updates, suspense, and work loop stuff,\n        // for an experimental timeline tool.\n        var enableSchedulingProfiler = true; // Helps identify side effects in render-phase lifecycle hooks and setState\n        var enableProfilerTimer = true; // Record durations for commit and passive effects phases.\n        var enableProfilerCommitHooks = true; // Phase param passed to onRender callback differentiates between an \"update\" and a \"cascading-update\".\n        var enableProfilerNestedUpdatePhase = true; // Adds verbose console logging for e.g. state updates, suspense, and work loop\n        var FunctionComponent = 0;\n        var ClassComponent = 1;\n        var HostRoot = 3; // Root of a host tree. Could be nested inside another node.\n        var HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\n        var HostComponent = 5;\n        var HostText = 6;\n        var Fragment = 7;\n        var Mode = 8;\n        var ContextConsumer = 9;\n        var ContextProvider = 10;\n        var ForwardRef = 11;\n        var Profiler = 12;\n        var SuspenseComponent = 13;\n        var MemoComponent = 14;\n        var SimpleMemoComponent = 15;\n        var LazyComponent = 16;\n        var IncompleteClassComponent = 17;\n        var DehydratedFragment = 18;\n        var SuspenseListComponent = 19;\n        var ScopeComponent = 21;\n        var OffscreenComponent = 22;\n        var LegacyHiddenComponent = 23;\n        var CacheComponent = 24;\n        var TracingMarkerComponent = 25;\n        var HostHoistable = 26;\n        var HostSingleton = 27;\n        var IncompleteFunctionComponent = 28;\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_LEGACY_ELEMENT_TYPE = Symbol.for('react.element');\n        var REACT_ELEMENT_TYPE = Symbol.for('react.transitional.element');\n        var REACT_PORTAL_TYPE = Symbol.for('react.portal');\n        var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\n        var REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\n        var REACT_PROFILER_TYPE = Symbol.for('react.profiler');\n        var REACT_PROVIDER_TYPE = Symbol.for('react.provider'); // TODO: Delete with enableRenderableContext\n        var REACT_CONSUMER_TYPE = Symbol.for('react.consumer');\n        var REACT_CONTEXT_TYPE = Symbol.for('react.context');\n        var REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\n        var REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\n        var REACT_MEMO_TYPE = Symbol.for('react.memo');\n        var REACT_LAZY_TYPE = Symbol.for('react.lazy');\n        var REACT_SCOPE_TYPE = Symbol.for('react.scope');\n        var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for('react.debug_trace_mode');\n        var REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\n        var REACT_LEGACY_HIDDEN_TYPE = Symbol.for('react.legacy_hidden');\n        var REACT_TRACING_MARKER_TYPE = Symbol.for('react.tracing_marker');\n        var REACT_MEMO_CACHE_SENTINEL = Symbol.for('react.memo_cache_sentinel');\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = '@@iterator';\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== 'object') {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === 'function') {\n                return maybeIterator;\n            }\n            return null;\n        }\n        function getWrappedName$1(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || '';\n            return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName$1(type) {\n            return type.displayName || 'Context';\n        }\n        var REACT_CLIENT_REFERENCE = Symbol.for('react.client.reference'); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            if (typeof type === 'function') {\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    // TODO: Create a convention for naming client references with debug info.\n                    return null;\n                }\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === 'string') {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return 'Fragment';\n                case REACT_PORTAL_TYPE:\n                    return 'Portal';\n                case REACT_PROFILER_TYPE:\n                    return 'Profiler';\n                case REACT_STRICT_MODE_TYPE:\n                    return 'StrictMode';\n                case REACT_SUSPENSE_TYPE:\n                    return 'Suspense';\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return 'SuspenseList';\n            }\n            if (typeof type === 'object') {\n                {\n                    if (typeof type.tag === 'number') {\n                        error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n                    }\n                }\n                switch(type.$$typeof){\n                    case REACT_PROVIDER_TYPE:\n                        {\n                            return null;\n                        }\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        {\n                            return getContextName$1(context) + '.Provider';\n                        }\n                    case REACT_CONSUMER_TYPE:\n                        {\n                            var consumer = type;\n                            return getContextName$1(consumer._context) + '.Consumer';\n                        }\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName$1(type, type.render, 'ForwardRef');\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || 'Memo';\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var functionName = innerType.displayName || innerType.name || '';\n            return outerType.displayName || (functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\n        } // Keep in sync with shared/getComponentNameFromType\n        function getContextName(type) {\n            return type.displayName || 'Context';\n        }\n        function getComponentNameFromOwner(owner) {\n            if (typeof owner.tag === 'number') {\n                return getComponentNameFromFiber(owner);\n            }\n            if (typeof owner.name === 'string') {\n                return owner.name;\n            }\n            return null;\n        }\n        function getComponentNameFromFiber(fiber) {\n            var tag = fiber.tag, type = fiber.type;\n            switch(tag){\n                case CacheComponent:\n                    return 'Cache';\n                case ContextConsumer:\n                    {\n                        var consumer = type;\n                        return getContextName(consumer._context) + '.Consumer';\n                    }\n                case ContextProvider:\n                    {\n                        var _context = type;\n                        return getContextName(_context) + '.Provider';\n                    }\n                case DehydratedFragment:\n                    return 'DehydratedFragment';\n                case ForwardRef:\n                    return getWrappedName(type, type.render, 'ForwardRef');\n                case Fragment:\n                    return 'Fragment';\n                case HostHoistable:\n                case HostSingleton:\n                case HostComponent:\n                    // Host component type is the display name (e.g. \"div\", \"View\")\n                    return type;\n                case HostPortal:\n                    return 'Portal';\n                case HostRoot:\n                    return 'Root';\n                case HostText:\n                    return 'Text';\n                case LazyComponent:\n                    // Name comes from the type in this case; we don't have a tag.\n                    return getComponentNameFromType(type);\n                case Mode:\n                    if (type === REACT_STRICT_MODE_TYPE) {\n                        // Don't be less specific than shared/getComponentNameFromType\n                        return 'StrictMode';\n                    }\n                    return 'Mode';\n                case OffscreenComponent:\n                    return 'Offscreen';\n                case Profiler:\n                    return 'Profiler';\n                case ScopeComponent:\n                    return 'Scope';\n                case SuspenseComponent:\n                    return 'Suspense';\n                case SuspenseListComponent:\n                    return 'SuspenseList';\n                case TracingMarkerComponent:\n                    return 'TracingMarker';\n                // The display name for these tags come from the user-provided type:\n                case IncompleteClassComponent:\n                case IncompleteFunctionComponent:\n                    {\n                        break;\n                    }\n                // Fallthrough\n                case ClassComponent:\n                case FunctionComponent:\n                case MemoComponent:\n                case SimpleMemoComponent:\n                    if (typeof type === 'function') {\n                        return type.displayName || type.name || null;\n                    }\n                    if (typeof type === 'string') {\n                        return type;\n                    }\n                    break;\n            }\n            return null;\n        }\n        var NoFlags$1 = /*                      */ 0;\n        var PerformedWork = /*                */ 1;\n        var Placement = /*                    */ 2;\n        var DidCapture = /*                   */ 128;\n        var Hydrating = /*                    */ 4096; // You can change the rest (and add more).\n        var Update = /*                       */ 4;\n        /* Skipped value:                                 0b0000000000000000000000001000; */ var ChildDeletion = /*                */ 16;\n        var ContentReset = /*                 */ 32;\n        var Callback = /*                     */ 64;\n        /* Used by DidCapture:                            0b0000000000000000000010000000; */ var ForceClientRender = /*            */ 256;\n        var Ref = /*                          */ 512;\n        var Snapshot = /*                     */ 1024;\n        var Passive$1 = /*                      */ 2048;\n        /* Used by Hydrating:                             0b0000000000000001000000000000; */ var Visibility = /*                   */ 8192;\n        var StoreConsistency = /*             */ 16384; // It's OK to reuse these bits because these flags are mutually exclusive for\n        // different fiber types. We should really be doing this for as many flags as\n        // possible, because we're about to run out of bits.\n        var ScheduleRetry = StoreConsistency;\n        var ShouldSuspendCommit = Visibility;\n        var DidDefer = ContentReset;\n        var FormReset = Snapshot;\n        var HostEffectMask = /*               */ 32767; // These are not really side effects, but we still reuse this field.\n        var Incomplete = /*                   */ 32768;\n        var ShouldCapture = /*                */ 65536;\n        var ForceUpdateForLegacySuspense = /* */ 131072;\n        var Forked = /*                       */ 1048576; // Static tags describe aspects of a fiber that are not specific to a render,\n        // e.g. a fiber uses a passive effect (even if there are no updates on this particular render).\n        // This enables us to defer more work in the unmount case,\n        // since we can defer traversing the tree during layout to look for Passive effects,\n        // and instead rely on the static flag as a signal that there may be cleanup work.\n        var RefStatic = /*                    */ 2097152;\n        var LayoutStatic = /*                 */ 4194304;\n        var PassiveStatic = /*                */ 8388608;\n        var MaySuspendCommit = /*             */ 16777216; // Flag used to identify newly inserted fibers. It isn't reset after commit unlike `Placement`.\n        var PlacementDEV = /*                 */ 33554432;\n        var MountLayoutDev = /*               */ 67108864;\n        var MountPassiveDev = /*              */ 134217728; // Groups of flags that are used in the commit phase to skip over trees that\n        // don't contain effects, by checking subtreeFlags.\n        var BeforeMutationMask = // flag logic (see #20043)\n        Update | Snapshot | 0;\n        var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility | FormReset;\n        var LayoutMask = Update | Callback | Ref | Visibility; // TODO: Split into PassiveMountMask and PassiveUnmountMask\n        var PassiveMask = Passive$1 | Visibility | ChildDeletion; // Union of tags that don't get reset on clones.\n        // This allows certain concepts to persist without recalculating them,\n        // e.g. whether a subtree contains passive effects or portals.\n        var StaticMask = LayoutStatic | PassiveStatic | RefStatic | MaySuspendCommit;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n                }\n            }\n        }\n        var prefix;\n        function describeBuiltInComponentFrame(name) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || '';\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return '\\n' + prefix + name;\n            }\n        }\n        function describeDebugInfoFrame(name, env) {\n            return describeBuiltInComponentFrame(name + (env ? ' (' + env + ')' : ''));\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap$1 = typeof WeakMap === 'function' ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap$1();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return '';\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher = null;\n            {\n                previousDispatcher = ReactSharedInternals.H; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactSharedInternals.H = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, 'props', {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === 'object' && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === 'function') {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === 'string') {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = 'DetermineComponentFrameRoot';\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, 'name'); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                'name', {\n                    value: 'DetermineComponentFrameRoot'\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split('\\n');\n                    var controlLines = controlStack.split('\\n');\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes('DetermineComponentFrameRoot')){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes('DetermineComponentFrameRoot')){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes('<anonymous>')) {\n                                            _frame = _frame.replace('<anonymous>', fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === 'function') {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactSharedInternals.H = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : '';\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n            {\n                if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeClassComponentFrame(ctor) {\n            {\n                return describeNativeComponentFrame(ctor, true);\n            }\n        }\n        function describeFunctionComponentFrame(fn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function describeFiber(fiber) {\n            switch(fiber.tag){\n                case HostHoistable:\n                case HostSingleton:\n                case HostComponent:\n                    return describeBuiltInComponentFrame(fiber.type);\n                case LazyComponent:\n                    return describeBuiltInComponentFrame('Lazy');\n                case SuspenseComponent:\n                    return describeBuiltInComponentFrame('Suspense');\n                case SuspenseListComponent:\n                    return describeBuiltInComponentFrame('SuspenseList');\n                case FunctionComponent:\n                case SimpleMemoComponent:\n                    return describeFunctionComponentFrame(fiber.type);\n                case ForwardRef:\n                    return describeFunctionComponentFrame(fiber.type.render);\n                case ClassComponent:\n                    return describeClassComponentFrame(fiber.type);\n                default:\n                    return '';\n            }\n        }\n        function getStackByFiberInDevAndProd(workInProgress) {\n            try {\n                var info = '';\n                var node = workInProgress;\n                do {\n                    info += describeFiber(node);\n                    if (true) {\n                        // Add any Server Component stack frames in reverse order.\n                        var debugInfo = node._debugInfo;\n                        if (debugInfo) {\n                            for(var i = debugInfo.length - 1; i >= 0; i--){\n                                var entry = debugInfo[i];\n                                if (typeof entry.name === 'string') {\n                                    info += describeDebugInfoFrame(entry.name, entry.env);\n                                }\n                            }\n                        }\n                    } // $FlowFixMe[incompatible-type] we bail out when we get a null\n                    node = node.return;\n                }while (node);\n                return info;\n            } catch (x) {\n                return '\\nError generating stack: ' + x.message + '\\n' + x.stack;\n            }\n        }\n        var current = null;\n        var isRendering = false;\n        function getCurrentFiberStackInDev() {\n            {\n                if (current === null) {\n                    return '';\n                } // Safe because if current fiber exists, we are reconciling,\n                // and it is guaranteed to be the work-in-progress version.\n                return getStackByFiberInDevAndProd(current);\n            }\n        }\n        function resetCurrentDebugFiberInDEV() {\n            {\n                resetCurrentFiber();\n            }\n        }\n        function setCurrentDebugFiberInDEV(fiber) {\n            {\n                setCurrentFiber(fiber);\n            }\n        }\n        function resetCurrentFiber() {\n            {\n                ReactSharedInternals.getCurrentStack = null;\n                isRendering = false;\n            }\n            current = null;\n        }\n        function setCurrentFiber(fiber) {\n            {\n                ReactSharedInternals.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;\n                isRendering = false;\n            }\n            current = fiber;\n        }\n        function getCurrentFiber() {\n            {\n                return current;\n            }\n        }\n        function setIsRendering(rendering) {\n            {\n                isRendering = rendering;\n            }\n        }\n        function getNearestMountedFiber(fiber) {\n            var node = fiber;\n            var nearestMounted = fiber;\n            if (!fiber.alternate) {\n                // If there is no alternate, this might be a new tree that isn't inserted\n                // yet. If it is, then it will have a pending insertion effect on it.\n                var nextNode = node;\n                do {\n                    node = nextNode;\n                    if ((node.flags & (Placement | Hydrating)) !== NoFlags$1) {\n                        // This is an insertion or in-progress hydration. The nearest possible\n                        // mounted fiber is the parent but we need to continue to figure out\n                        // if that one is still mounted.\n                        nearestMounted = node.return;\n                    } // $FlowFixMe[incompatible-type] we bail out when we get a null\n                    nextNode = node.return;\n                }while (nextNode);\n            } else {\n                while(node.return){\n                    node = node.return;\n                }\n            }\n            if (node.tag === HostRoot) {\n                // TODO: Check if this was a nested HostRoot when used with\n                // renderContainerIntoSubtree.\n                return nearestMounted;\n            } // If we didn't hit the root, that means that we're in an disconnected tree\n            // that has been unmounted.\n            return null;\n        }\n        function isMounted(component) {\n            {\n                var owner = current;\n                if (owner !== null && isRendering && owner.tag === ClassComponent) {\n                    var ownerFiber = owner;\n                    var instance = ownerFiber.stateNode;\n                    if (!instance._warnedAboutRefsInRender) {\n                        error('%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', getComponentNameFromFiber(ownerFiber) || 'A component');\n                    }\n                    instance._warnedAboutRefsInRender = true;\n                }\n            }\n            var fiber = get(component);\n            if (!fiber) {\n                return false;\n            }\n            return getNearestMountedFiber(fiber) === fiber;\n        }\n        function assertIsMounted(fiber) {\n            if (getNearestMountedFiber(fiber) !== fiber) {\n                throw new Error('Unable to find node on an unmounted component.');\n            }\n        }\n        function findCurrentFiberUsingSlowPath(fiber) {\n            var alternate = fiber.alternate;\n            if (!alternate) {\n                // If there is no alternate, then we only need to check if it is mounted.\n                var nearestMounted = getNearestMountedFiber(fiber);\n                if (nearestMounted === null) {\n                    throw new Error('Unable to find node on an unmounted component.');\n                }\n                if (nearestMounted !== fiber) {\n                    return null;\n                }\n                return fiber;\n            } // If we have two possible branches, we'll walk backwards up to the root\n            // to see what path the root points to. On the way we may hit one of the\n            // special cases and we'll deal with them.\n            var a = fiber;\n            var b = alternate;\n            while(true){\n                var parentA = a.return;\n                if (parentA === null) {\n                    break;\n                }\n                var parentB = parentA.alternate;\n                if (parentB === null) {\n                    // There is no alternate. This is an unusual case. Currently, it only\n                    // happens when a Suspense component is hidden. An extra fragment fiber\n                    // is inserted in between the Suspense fiber and its children. Skip\n                    // over this extra fragment fiber and proceed to the next parent.\n                    var nextParent = parentA.return;\n                    if (nextParent !== null) {\n                        a = b = nextParent;\n                        continue;\n                    } // If there's no parent, we're at the root.\n                    break;\n                } // If both copies of the parent fiber point to the same child, we can\n                // assume that the child is current. This happens when we bailout on low\n                // priority: the bailed out fiber's child reuses the current child.\n                if (parentA.child === parentB.child) {\n                    var child = parentA.child;\n                    while(child){\n                        if (child === a) {\n                            // We've determined that A is the current branch.\n                            assertIsMounted(parentA);\n                            return fiber;\n                        }\n                        if (child === b) {\n                            // We've determined that B is the current branch.\n                            assertIsMounted(parentA);\n                            return alternate;\n                        }\n                        child = child.sibling;\n                    } // We should never have an alternate for any mounting node. So the only\n                    // way this could possibly happen is if this was unmounted, if at all.\n                    throw new Error('Unable to find node on an unmounted component.');\n                }\n                if (a.return !== b.return) {\n                    // The return pointer of A and the return pointer of B point to different\n                    // fibers. We assume that return pointers never criss-cross, so A must\n                    // belong to the child set of A.return, and B must belong to the child\n                    // set of B.return.\n                    a = parentA;\n                    b = parentB;\n                } else {\n                    // The return pointers point to the same fiber. We'll have to use the\n                    // default, slow path: scan the child sets of each parent alternate to see\n                    // which child belongs to which set.\n                    //\n                    // Search parent A's child set\n                    var didFindChild = false;\n                    var _child = parentA.child;\n                    while(_child){\n                        if (_child === a) {\n                            didFindChild = true;\n                            a = parentA;\n                            b = parentB;\n                            break;\n                        }\n                        if (_child === b) {\n                            didFindChild = true;\n                            b = parentA;\n                            a = parentB;\n                            break;\n                        }\n                        _child = _child.sibling;\n                    }\n                    if (!didFindChild) {\n                        // Search parent B's child set\n                        _child = parentB.child;\n                        while(_child){\n                            if (_child === a) {\n                                didFindChild = true;\n                                a = parentB;\n                                b = parentA;\n                                break;\n                            }\n                            if (_child === b) {\n                                didFindChild = true;\n                                b = parentB;\n                                a = parentA;\n                                break;\n                            }\n                            _child = _child.sibling;\n                        }\n                        if (!didFindChild) {\n                            throw new Error('Child was not found in either parent set. This indicates a bug ' + 'in React related to the return pointer. Please file an issue.');\n                        }\n                    }\n                }\n                if (a.alternate !== b) {\n                    throw new Error(\"Return fibers should always be each others' alternates. \" + 'This error is likely caused by a bug in React. Please file an issue.');\n                }\n            } // If the root is not a host container, we're in a disconnected tree. I.e.\n            // unmounted.\n            if (a.tag !== HostRoot) {\n                throw new Error('Unable to find node on an unmounted component.');\n            }\n            if (a.stateNode.current === a) {\n                // We've determined that A is the current branch.\n                return fiber;\n            } // Otherwise B has to be current branch.\n            return alternate;\n        }\n        function findCurrentHostFiber(parent) {\n            var currentParent = findCurrentFiberUsingSlowPath(parent);\n            return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;\n        }\n        function findCurrentHostFiberImpl(node) {\n            // Next we'll drill down this component to find the first HostComponent/Text.\n            var tag = node.tag;\n            if (tag === HostComponent || tag === HostHoistable || tag === HostSingleton || tag === HostText) {\n                return node;\n            }\n            var child = node.child;\n            while(child !== null){\n                var match = findCurrentHostFiberImpl(child);\n                if (match !== null) {\n                    return match;\n                }\n                child = child.sibling;\n            }\n            return null;\n        }\n        function findCurrentHostFiberWithNoPortals(parent) {\n            var currentParent = findCurrentFiberUsingSlowPath(parent);\n            return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;\n        }\n        function findCurrentHostFiberWithNoPortalsImpl(node) {\n            // Next we'll drill down this component to find the first HostComponent/Text.\n            var tag = node.tag;\n            if (tag === HostComponent || tag === HostHoistable || tag === HostSingleton || tag === HostText) {\n                return node;\n            }\n            var child = node.child;\n            while(child !== null){\n                if (child.tag !== HostPortal) {\n                    var match = findCurrentHostFiberWithNoPortalsImpl(child);\n                    if (match !== null) {\n                        return match;\n                    }\n                }\n                child = child.sibling;\n            }\n            return null;\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        // This is a host config that's used for the `react-reconciler` package on npm.\n        // It is only used by third-party renderers.\n        //\n        // Its API lets you pass the host config as an argument.\n        // However, inside the `react-reconciler` we treat host config as a module.\n        // This file is a shim between two worlds.\n        //\n        // It works because the `react-reconciler` bundle is wrapped in something like:\n        //\n        // module.exports = function ($$$config) {\n        //   /* reconciler code */\n        // }\n        //\n        // So `$$$config` looks like a global variable, but it's\n        // really an argument to a top-level wrapping function.\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        // eslint-disable-line no-undef\n        var getPublicInstance = $$$config.getPublicInstance;\n        var getRootHostContext = $$$config.getRootHostContext;\n        var getChildHostContext = $$$config.getChildHostContext;\n        var prepareForCommit = $$$config.prepareForCommit;\n        var resetAfterCommit = $$$config.resetAfterCommit;\n        var createInstance = $$$config.createInstance;\n        var appendInitialChild = $$$config.appendInitialChild;\n        var finalizeInitialChildren = $$$config.finalizeInitialChildren;\n        var shouldSetTextContent = $$$config.shouldSetTextContent;\n        var createTextInstance = $$$config.createTextInstance;\n        var scheduleTimeout = $$$config.scheduleTimeout;\n        var cancelTimeout = $$$config.cancelTimeout;\n        var noTimeout = $$$config.noTimeout;\n        var isPrimaryRenderer = $$$config.isPrimaryRenderer;\n        $$$config.warnsIfNotActing;\n        var supportsMutation = $$$config.supportsMutation;\n        var supportsPersistence = $$$config.supportsPersistence;\n        var supportsHydration = $$$config.supportsHydration;\n        var getInstanceFromNode = $$$config.getInstanceFromNode;\n        $$$config.beforeActiveInstanceBlur;\n        $$$config.afterActiveInstanceBlur;\n        var preparePortalMount = $$$config.preparePortalMount;\n        $$$config.prepareScopeUpdate;\n        $$$config.getInstanceFromScope;\n        var setCurrentUpdatePriority = $$$config.setCurrentUpdatePriority;\n        var getCurrentUpdatePriority = $$$config.getCurrentUpdatePriority;\n        var resolveUpdatePriority = $$$config.resolveUpdatePriority;\n        var shouldAttemptEagerTransition = $$$config.shouldAttemptEagerTransition;\n        var detachDeletedInstance = $$$config.detachDeletedInstance;\n        $$$config.requestPostPaintCallback;\n        var maySuspendCommit = $$$config.maySuspendCommit;\n        var preloadInstance = $$$config.preloadInstance;\n        var startSuspendingCommit = $$$config.startSuspendingCommit;\n        var suspendInstance = $$$config.suspendInstance;\n        var waitForCommitToBeReady = $$$config.waitForCommitToBeReady;\n        var NotPendingTransition = $$$config.NotPendingTransition;\n        var resetFormInstance = $$$config.resetFormInstance; // -------------------\n        //      Microtasks\n        //     (optional)\n        // -------------------\n        var supportsMicrotasks = $$$config.supportsMicrotasks;\n        var scheduleMicrotask = $$$config.scheduleMicrotask; // -------------------\n        //      Test selectors\n        //     (optional)\n        // -------------------\n        var supportsTestSelectors = $$$config.supportsTestSelectors;\n        var findFiberRoot = $$$config.findFiberRoot;\n        var getBoundingRect = $$$config.getBoundingRect;\n        var getTextContent = $$$config.getTextContent;\n        var isHiddenSubtree = $$$config.isHiddenSubtree;\n        var matchAccessibilityRole = $$$config.matchAccessibilityRole;\n        var setFocusIfFocusable = $$$config.setFocusIfFocusable;\n        var setupIntersectionObserver = $$$config.setupIntersectionObserver; // -------------------\n        //      Mutation\n        //     (optional)\n        // -------------------\n        var appendChild = $$$config.appendChild;\n        var appendChildToContainer = $$$config.appendChildToContainer;\n        var commitTextUpdate = $$$config.commitTextUpdate;\n        var commitMount = $$$config.commitMount;\n        var commitUpdate = $$$config.commitUpdate;\n        var insertBefore = $$$config.insertBefore;\n        var insertInContainerBefore = $$$config.insertInContainerBefore;\n        var removeChild = $$$config.removeChild;\n        var removeChildFromContainer = $$$config.removeChildFromContainer;\n        var resetTextContent = $$$config.resetTextContent;\n        var hideInstance = $$$config.hideInstance;\n        var hideTextInstance = $$$config.hideTextInstance;\n        var unhideInstance = $$$config.unhideInstance;\n        var unhideTextInstance = $$$config.unhideTextInstance;\n        var clearContainer = $$$config.clearContainer; // -------------------\n        //     Persistence\n        //     (optional)\n        // -------------------\n        var cloneInstance = $$$config.cloneInstance;\n        var createContainerChildSet = $$$config.createContainerChildSet;\n        var appendChildToContainerChildSet = $$$config.appendChildToContainerChildSet;\n        var finalizeContainerChildren = $$$config.finalizeContainerChildren;\n        var replaceContainerChildren = $$$config.replaceContainerChildren;\n        var cloneHiddenInstance = $$$config.cloneHiddenInstance;\n        var cloneHiddenTextInstance = $$$config.cloneHiddenTextInstance; // -------------------\n        //     Hydration\n        //     (optional)\n        // -------------------\n        var isSuspenseInstancePending = $$$config.isSuspenseInstancePending;\n        var isSuspenseInstanceFallback = $$$config.isSuspenseInstanceFallback;\n        var getSuspenseInstanceFallbackErrorDetails = $$$config.getSuspenseInstanceFallbackErrorDetails;\n        var registerSuspenseInstanceRetry = $$$config.registerSuspenseInstanceRetry;\n        var canHydrateFormStateMarker = $$$config.canHydrateFormStateMarker;\n        var isFormStateMarkerMatching = $$$config.isFormStateMarkerMatching;\n        var getNextHydratableSibling = $$$config.getNextHydratableSibling;\n        var getFirstHydratableChild = $$$config.getFirstHydratableChild;\n        var getFirstHydratableChildWithinContainer = $$$config.getFirstHydratableChildWithinContainer;\n        var getFirstHydratableChildWithinSuspenseInstance = $$$config.getFirstHydratableChildWithinSuspenseInstance;\n        var canHydrateInstance = $$$config.canHydrateInstance;\n        var canHydrateTextInstance = $$$config.canHydrateTextInstance;\n        var canHydrateSuspenseInstance = $$$config.canHydrateSuspenseInstance;\n        var hydrateInstance = $$$config.hydrateInstance;\n        var hydrateTextInstance = $$$config.hydrateTextInstance;\n        var hydrateSuspenseInstance = $$$config.hydrateSuspenseInstance;\n        var getNextHydratableInstanceAfterSuspenseInstance = $$$config.getNextHydratableInstanceAfterSuspenseInstance;\n        var commitHydratedContainer = $$$config.commitHydratedContainer;\n        var commitHydratedSuspenseInstance = $$$config.commitHydratedSuspenseInstance;\n        var clearSuspenseBoundary = $$$config.clearSuspenseBoundary;\n        var clearSuspenseBoundaryFromContainer = $$$config.clearSuspenseBoundaryFromContainer;\n        var shouldDeleteUnhydratedTailInstances = $$$config.shouldDeleteUnhydratedTailInstances;\n        var diffHydratedPropsForDevWarnings = $$$config.diffHydratedPropsForDevWarnings;\n        var diffHydratedTextForDevWarnings = $$$config.diffHydratedTextForDevWarnings;\n        var describeHydratableInstanceForDevWarnings = $$$config.describeHydratableInstanceForDevWarnings;\n        var validateHydratableInstance = $$$config.validateHydratableInstance;\n        var validateHydratableTextInstance = $$$config.validateHydratableTextInstance; // -------------------\n        //     Resources\n        //     (optional)\n        // -------------------\n        // eslint-disable-line no-undef\n        var supportsResources = $$$config.supportsResources;\n        var isHostHoistableType = $$$config.isHostHoistableType;\n        var getHoistableRoot = $$$config.getHoistableRoot;\n        var getResource = $$$config.getResource;\n        var acquireResource = $$$config.acquireResource;\n        var releaseResource = $$$config.releaseResource;\n        var hydrateHoistable = $$$config.hydrateHoistable;\n        var mountHoistable = $$$config.mountHoistable;\n        var unmountHoistable = $$$config.unmountHoistable;\n        var createHoistableInstance = $$$config.createHoistableInstance;\n        var prepareToCommitHoistables = $$$config.prepareToCommitHoistables;\n        var mayResourceSuspendCommit = $$$config.mayResourceSuspendCommit;\n        var preloadResource = $$$config.preloadResource;\n        var suspendResource = $$$config.suspendResource; // -------------------\n        //     Singletons\n        //     (optional)\n        // -------------------\n        var supportsSingletons = $$$config.supportsSingletons;\n        var resolveSingletonInstance = $$$config.resolveSingletonInstance;\n        var clearSingleton = $$$config.clearSingleton;\n        var acquireSingletonInstance = $$$config.acquireSingletonInstance;\n        var releaseSingletonInstance = $$$config.releaseSingletonInstance;\n        var isHostSingletonType = $$$config.isHostSingletonType;\n        var valueStack = [];\n        var fiberStack;\n        {\n            fiberStack = [];\n        }\n        var index = -1;\n        function createCursor(defaultValue) {\n            return {\n                current: defaultValue\n            };\n        }\n        function pop(cursor, fiber) {\n            if (index < 0) {\n                {\n                    error('Unexpected pop.');\n                }\n                return;\n            }\n            {\n                if (fiber !== fiberStack[index]) {\n                    error('Unexpected Fiber popped.');\n                }\n            }\n            cursor.current = valueStack[index];\n            valueStack[index] = null;\n            {\n                fiberStack[index] = null;\n            }\n            index--;\n        }\n        function push(cursor, value, fiber) {\n            index++;\n            valueStack[index] = cursor.current;\n            {\n                fiberStack[index] = fiber;\n            }\n            cursor.current = value;\n        }\n        var emptyContextObject = {};\n        {\n            Object.freeze(emptyContextObject);\n        }\n        function hasContextChanged() {\n            {\n                return false;\n            }\n        }\n        function isContextProvider(type) {\n            {\n                return false;\n            }\n        }\n        function processChildContext(fiber, type, parentContext) {\n            {\n                return parentContext;\n            }\n        }\n        function findCurrentUnmaskedContext(fiber) {\n            {\n                return emptyContextObject;\n            }\n        }\n        // We use the existence of the state object as an indicator that the component\n        // is hidden.\n        var OffscreenVisible = /*                     */ 1;\n        var OffscreenDetached = /*                    */ 2;\n        var OffscreenPassiveEffectsConnected = /*     */ 4;\n        function isOffscreenManual(offscreenFiber) {\n            return offscreenFiber.memoizedProps !== null && offscreenFiber.memoizedProps.mode === 'manual';\n        }\n        var NoMode = /*                         */ 0; // TODO: Remove ConcurrentMode by reading from the root tag instead\n        var ConcurrentMode = /*                 */ 1;\n        var ProfileMode = /*                    */ 2;\n        var StrictLegacyMode = /*               */ 8;\n        var StrictEffectsMode = /*              */ 16;\n        var NoStrictPassiveEffectsMode = /*     */ 64;\n        // TODO: This is pretty well supported by browsers. Maybe we can drop it.\n        var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback; // Count leading zeros.\n        // Based on:\n        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n        var log$1 = Math.log;\n        var LN2 = Math.LN2;\n        function clz32Fallback(x) {\n            var asUint = x >>> 0;\n            if (asUint === 0) {\n                return 32;\n            }\n            return 31 - (log$1(asUint) / LN2 | 0) | 0;\n        }\n        // If those values are changed that package should be rebuilt and redeployed.\n        var TotalLanes = 31;\n        var NoLanes = /*                        */ 0;\n        var NoLane = /*                          */ 0;\n        var SyncHydrationLane = /*               */ 1;\n        var SyncLane = /*                        */ 2;\n        var SyncLaneIndex = 1;\n        var InputContinuousHydrationLane = /*    */ 4;\n        var InputContinuousLane = /*             */ 8;\n        var DefaultHydrationLane = /*            */ 16;\n        var DefaultLane = /*                     */ 32;\n        var SyncUpdateLanes = SyncLane | InputContinuousLane | DefaultLane;\n        var TransitionHydrationLane = /*                */ 64;\n        var TransitionLanes = /*                       */ 4194176;\n        var TransitionLane1 = /*                        */ 128;\n        var TransitionLane2 = /*                        */ 256;\n        var TransitionLane3 = /*                        */ 512;\n        var TransitionLane4 = /*                        */ 1024;\n        var TransitionLane5 = /*                        */ 2048;\n        var TransitionLane6 = /*                        */ 4096;\n        var TransitionLane7 = /*                        */ 8192;\n        var TransitionLane8 = /*                        */ 16384;\n        var TransitionLane9 = /*                        */ 32768;\n        var TransitionLane10 = /*                       */ 65536;\n        var TransitionLane11 = /*                       */ 131072;\n        var TransitionLane12 = /*                       */ 262144;\n        var TransitionLane13 = /*                       */ 524288;\n        var TransitionLane14 = /*                       */ 1048576;\n        var TransitionLane15 = /*                       */ 2097152;\n        var RetryLanes = /*                            */ 62914560;\n        var RetryLane1 = /*                             */ 4194304;\n        var RetryLane2 = /*                             */ 8388608;\n        var RetryLane3 = /*                             */ 16777216;\n        var RetryLane4 = /*                             */ 33554432;\n        var SomeRetryLane = RetryLane1;\n        var SelectiveHydrationLane = /*          */ 67108864;\n        var NonIdleLanes = /*                          */ 134217727;\n        var IdleHydrationLane = /*               */ 134217728;\n        var IdleLane = /*                        */ 268435456;\n        var OffscreenLane = /*                   */ 536870912;\n        var DeferredLane = /*                    */ 1073741824; // Any lane that might schedule an update. This is used to detect infinite\n        // update loops, so it doesn't include hydration lanes or retries.\n        var UpdateLanes = SyncLane | InputContinuousLane | DefaultLane | TransitionLanes; // This function is used for the experimental timeline (react-devtools-timeline)\n        // It should be kept in sync with the Lanes values above.\n        function getLabelForLane(lane) {\n            {\n                if (lane & SyncHydrationLane) {\n                    return 'SyncHydrationLane';\n                }\n                if (lane & SyncLane) {\n                    return 'Sync';\n                }\n                if (lane & InputContinuousHydrationLane) {\n                    return 'InputContinuousHydration';\n                }\n                if (lane & InputContinuousLane) {\n                    return 'InputContinuous';\n                }\n                if (lane & DefaultHydrationLane) {\n                    return 'DefaultHydration';\n                }\n                if (lane & DefaultLane) {\n                    return 'Default';\n                }\n                if (lane & TransitionHydrationLane) {\n                    return 'TransitionHydration';\n                }\n                if (lane & TransitionLanes) {\n                    return 'Transition';\n                }\n                if (lane & RetryLanes) {\n                    return 'Retry';\n                }\n                if (lane & SelectiveHydrationLane) {\n                    return 'SelectiveHydration';\n                }\n                if (lane & IdleHydrationLane) {\n                    return 'IdleHydration';\n                }\n                if (lane & IdleLane) {\n                    return 'Idle';\n                }\n                if (lane & OffscreenLane) {\n                    return 'Offscreen';\n                }\n                if (lane & DeferredLane) {\n                    return 'Deferred';\n                }\n            }\n        }\n        var NoTimestamp = -1;\n        var nextTransitionLane = TransitionLane1;\n        var nextRetryLane = RetryLane1;\n        function getHighestPriorityLanes(lanes) {\n            {\n                var pendingSyncLanes = lanes & SyncUpdateLanes;\n                if (pendingSyncLanes !== 0) {\n                    return pendingSyncLanes;\n                }\n            }\n            switch(getHighestPriorityLane(lanes)){\n                case SyncHydrationLane:\n                    return SyncHydrationLane;\n                case SyncLane:\n                    return SyncLane;\n                case InputContinuousHydrationLane:\n                    return InputContinuousHydrationLane;\n                case InputContinuousLane:\n                    return InputContinuousLane;\n                case DefaultHydrationLane:\n                    return DefaultHydrationLane;\n                case DefaultLane:\n                    return DefaultLane;\n                case TransitionHydrationLane:\n                    return TransitionHydrationLane;\n                case TransitionLane1:\n                case TransitionLane2:\n                case TransitionLane3:\n                case TransitionLane4:\n                case TransitionLane5:\n                case TransitionLane6:\n                case TransitionLane7:\n                case TransitionLane8:\n                case TransitionLane9:\n                case TransitionLane10:\n                case TransitionLane11:\n                case TransitionLane12:\n                case TransitionLane13:\n                case TransitionLane14:\n                case TransitionLane15:\n                    return lanes & TransitionLanes;\n                case RetryLane1:\n                case RetryLane2:\n                case RetryLane3:\n                case RetryLane4:\n                    return lanes & RetryLanes;\n                case SelectiveHydrationLane:\n                    return SelectiveHydrationLane;\n                case IdleHydrationLane:\n                    return IdleHydrationLane;\n                case IdleLane:\n                    return IdleLane;\n                case OffscreenLane:\n                    return OffscreenLane;\n                case DeferredLane:\n                    // This shouldn't be reachable because deferred work is always entangled\n                    // with something else.\n                    return NoLanes;\n                default:\n                    {\n                        error('Should have found matching lanes. This is a bug in React.');\n                    }\n                    return lanes;\n            }\n        }\n        function getNextLanes(root, wipLanes) {\n            // Early bailout if there's no pending work left.\n            var pendingLanes = root.pendingLanes;\n            if (pendingLanes === NoLanes) {\n                return NoLanes;\n            }\n            var nextLanes = NoLanes;\n            var suspendedLanes = root.suspendedLanes;\n            var pingedLanes = root.pingedLanes; // Do not work on any idle work until all the non-idle work has finished,\n            // even if the work is suspended.\n            var nonIdlePendingLanes = pendingLanes & NonIdleLanes;\n            if (nonIdlePendingLanes !== NoLanes) {\n                var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;\n                if (nonIdleUnblockedLanes !== NoLanes) {\n                    nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);\n                } else {\n                    var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;\n                    if (nonIdlePingedLanes !== NoLanes) {\n                        nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);\n                    }\n                }\n            } else {\n                // The only remaining work is Idle.\n                var unblockedLanes = pendingLanes & ~suspendedLanes;\n                if (unblockedLanes !== NoLanes) {\n                    nextLanes = getHighestPriorityLanes(unblockedLanes);\n                } else {\n                    if (pingedLanes !== NoLanes) {\n                        nextLanes = getHighestPriorityLanes(pingedLanes);\n                    }\n                }\n            }\n            if (nextLanes === NoLanes) {\n                // This should only be reachable if we're suspended\n                // TODO: Consider warning in this path if a fallback timer is not scheduled.\n                return NoLanes;\n            } // If we're already in the middle of a render, switching lanes will interrupt\n            // it and we'll lose our progress. We should only do this if the new lanes are\n            // higher priority.\n            if (wipLanes !== NoLanes && wipLanes !== nextLanes && // If we already suspended with a delay, then interrupting is fine. Don't\n            // bother waiting until the root is complete.\n            (wipLanes & suspendedLanes) === NoLanes) {\n                var nextLane = getHighestPriorityLane(nextLanes);\n                var wipLane = getHighestPriorityLane(wipLanes);\n                if (// one. This works because the bits decrease in priority as you go left.\n                nextLane >= wipLane || // Default priority updates should not interrupt transition updates. The\n                // only difference between default updates and transition updates is that\n                // default updates do not support refresh transitions.\n                nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes) {\n                    // Keep working on the existing in-progress tree. Do not interrupt.\n                    return wipLanes;\n                }\n            }\n            return nextLanes;\n        }\n        function getEntangledLanes(root, renderLanes) {\n            var entangledLanes = renderLanes;\n            if ((entangledLanes & InputContinuousLane) !== NoLanes) {\n                // When updates are sync by default, we entangle continuous priority updates\n                // and default updates, so they render in the same batch. The only reason\n                // they use separate lanes is because continuous updates should interrupt\n                // transitions, but default updates should not.\n                entangledLanes |= entangledLanes & DefaultLane;\n            } // Check for entangled lanes and add them to the batch.\n            //\n            // A lane is said to be entangled with another when it's not allowed to render\n            // in a batch that does not also include the other lane. Typically we do this\n            // when multiple updates have the same source, and we only want to respond to\n            // the most recent event from that source.\n            //\n            // Note that we apply entanglements *after* checking for partial work above.\n            // This means that if a lane is entangled during an interleaved event while\n            // it's already rendering, we won't interrupt it. This is intentional, since\n            // entanglement is usually \"best effort\": we'll try our best to render the\n            // lanes in the same batch, but it's not worth throwing out partially\n            // completed work in order to do it.\n            // TODO: Reconsider this. The counter-argument is that the partial work\n            // represents an intermediate state, which we don't want to show to the user.\n            // And by spending extra time finishing it, we're increasing the amount of\n            // time it takes to show the final state, which is what they are actually\n            // waiting for.\n            //\n            // For those exceptions where entanglement is semantically important,\n            // we should ensure that there is no partial work at the\n            // time we apply the entanglement.\n            var allEntangledLanes = root.entangledLanes;\n            if (allEntangledLanes !== NoLanes) {\n                var entanglements = root.entanglements;\n                var lanes = entangledLanes & allEntangledLanes;\n                while(lanes > 0){\n                    var index = pickArbitraryLaneIndex(lanes);\n                    var lane = 1 << index;\n                    entangledLanes |= entanglements[index];\n                    lanes &= ~lane;\n                }\n            }\n            return entangledLanes;\n        }\n        function computeExpirationTime(lane, currentTime) {\n            switch(lane){\n                case SyncHydrationLane:\n                case SyncLane:\n                case InputContinuousHydrationLane:\n                case InputContinuousLane:\n                    // User interactions should expire slightly more quickly.\n                    //\n                    // NOTE: This is set to the corresponding constant as in Scheduler.js.\n                    // When we made it larger, a product metric in www regressed, suggesting\n                    // there's a user interaction that's being starved by a series of\n                    // synchronous updates. If that theory is correct, the proper solution is\n                    // to fix the starvation. However, this scenario supports the idea that\n                    // expiration times are an important safeguard when starvation\n                    // does happen.\n                    return currentTime + syncLaneExpirationMs;\n                case DefaultHydrationLane:\n                case DefaultLane:\n                case TransitionHydrationLane:\n                case TransitionLane1:\n                case TransitionLane2:\n                case TransitionLane3:\n                case TransitionLane4:\n                case TransitionLane5:\n                case TransitionLane6:\n                case TransitionLane7:\n                case TransitionLane8:\n                case TransitionLane9:\n                case TransitionLane10:\n                case TransitionLane11:\n                case TransitionLane12:\n                case TransitionLane13:\n                case TransitionLane14:\n                case TransitionLane15:\n                    return currentTime + transitionLaneExpirationMs;\n                case RetryLane1:\n                case RetryLane2:\n                case RetryLane3:\n                case RetryLane4:\n                    // TODO: Retries should be allowed to expire if they are CPU bound for\n                    // too long, but when I made this change it caused a spike in browser\n                    // crashes. There must be some other underlying bug; not super urgent but\n                    // ideally should figure out why and fix it. Unfortunately we don't have\n                    // a repro for the crashes, only detected via production metrics.\n                    return NoTimestamp;\n                case SelectiveHydrationLane:\n                case IdleHydrationLane:\n                case IdleLane:\n                case OffscreenLane:\n                case DeferredLane:\n                    // Anything idle priority or lower should never expire.\n                    return NoTimestamp;\n                default:\n                    {\n                        error('Should have found matching lanes. This is a bug in React.');\n                    }\n                    return NoTimestamp;\n            }\n        }\n        function markStarvedLanesAsExpired(root, currentTime) {\n            // TODO: This gets called every time we yield. We can optimize by storing\n            // the earliest expiration time on the root. Then use that to quickly bail out\n            // of this function.\n            var pendingLanes = root.pendingLanes;\n            var suspendedLanes = root.suspendedLanes;\n            var pingedLanes = root.pingedLanes;\n            var expirationTimes = root.expirationTimes; // Iterate through the pending lanes and check if we've reached their\n            // expiration time. If so, we'll assume the update is being starved and mark\n            // it as expired to force it to finish.\n            // TODO: We should be able to replace this with upgradePendingLanesToSync\n            //\n            // We exclude retry lanes because those must always be time sliced, in order\n            // to unwrap uncached promises.\n            // TODO: Write a test for this\n            var lanes = pendingLanes & ~RetryLanes;\n            while(lanes > 0){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                var expirationTime = expirationTimes[index];\n                if (expirationTime === NoTimestamp) {\n                    // Found a pending lane with no expiration time. If it's not suspended, or\n                    // if it's pinged, assume it's CPU-bound. Compute a new expiration time\n                    // using the current time.\n                    if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {\n                        // Assumes timestamps are monotonically increasing.\n                        expirationTimes[index] = computeExpirationTime(lane, currentTime);\n                    }\n                } else if (expirationTime <= currentTime) {\n                    // This lane expired\n                    root.expiredLanes |= lane;\n                }\n                lanes &= ~lane;\n            }\n        } // This returns the highest priority pending lanes regardless of whether they\n        // are suspended.\n        function getHighestPriorityPendingLanes(root) {\n            return getHighestPriorityLanes(root.pendingLanes);\n        }\n        function getLanesToRetrySynchronouslyOnError(root, originallyAttemptedLanes) {\n            if (root.errorRecoveryDisabledLanes & originallyAttemptedLanes) {\n                // The error recovery mechanism is disabled until these lanes are cleared.\n                return NoLanes;\n            }\n            var everythingButOffscreen = root.pendingLanes & ~OffscreenLane;\n            if (everythingButOffscreen !== NoLanes) {\n                return everythingButOffscreen;\n            }\n            if (everythingButOffscreen & OffscreenLane) {\n                return OffscreenLane;\n            }\n            return NoLanes;\n        }\n        function includesSyncLane(lanes) {\n            return (lanes & (SyncLane | SyncHydrationLane)) !== NoLanes;\n        }\n        function includesNonIdleWork(lanes) {\n            return (lanes & NonIdleLanes) !== NoLanes;\n        }\n        function includesOnlyRetries(lanes) {\n            return (lanes & RetryLanes) === lanes;\n        }\n        function includesOnlyNonUrgentLanes(lanes) {\n            // TODO: Should hydration lanes be included here? This function is only\n            // used in `updateDeferredValueImpl`.\n            var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;\n            return (lanes & UrgentLanes) === NoLanes;\n        }\n        function includesOnlyTransitions(lanes) {\n            return (lanes & TransitionLanes) === lanes;\n        }\n        function includesBlockingLane(root, lanes) {\n            var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;\n            return (lanes & SyncDefaultLanes) !== NoLanes;\n        }\n        function includesExpiredLane(root, lanes) {\n            // This is a separate check from includesBlockingLane because a lane can\n            // expire after a render has already started.\n            return (lanes & root.expiredLanes) !== NoLanes;\n        }\n        function isTransitionLane(lane) {\n            return (lane & TransitionLanes) !== NoLanes;\n        }\n        function claimNextTransitionLane() {\n            // Cycle through the lanes, assigning each new transition to the next lane.\n            // In most cases, this means every transition gets its own lane, until we\n            // run out of lanes and cycle back to the beginning.\n            var lane = nextTransitionLane;\n            nextTransitionLane <<= 1;\n            if ((nextTransitionLane & TransitionLanes) === NoLanes) {\n                nextTransitionLane = TransitionLane1;\n            }\n            return lane;\n        }\n        function claimNextRetryLane() {\n            var lane = nextRetryLane;\n            nextRetryLane <<= 1;\n            if ((nextRetryLane & RetryLanes) === NoLanes) {\n                nextRetryLane = RetryLane1;\n            }\n            return lane;\n        }\n        function getHighestPriorityLane(lanes) {\n            return lanes & -lanes;\n        }\n        function pickArbitraryLane(lanes) {\n            // This wrapper function gets inlined. Only exists so to communicate that it\n            // doesn't matter which bit is selected; you can pick any bit without\n            // affecting the algorithms where its used. Here I'm using\n            // getHighestPriorityLane because it requires the fewest operations.\n            return getHighestPriorityLane(lanes);\n        }\n        function pickArbitraryLaneIndex(lanes) {\n            return 31 - clz32(lanes);\n        }\n        function laneToIndex(lane) {\n            return pickArbitraryLaneIndex(lane);\n        }\n        function includesSomeLane(a, b) {\n            return (a & b) !== NoLanes;\n        }\n        function isSubsetOfLanes(set, subset) {\n            return (set & subset) === subset;\n        }\n        function mergeLanes(a, b) {\n            return a | b;\n        }\n        function removeLanes(set, subset) {\n            return set & ~subset;\n        }\n        function intersectLanes(a, b) {\n            return a & b;\n        } // Seems redundant, but it changes the type from a single lane (used for\n        // updates) to a group of lanes (used for flushing work).\n        function laneToLanes(lane) {\n            return lane;\n        }\n        function higherPriorityLane(a, b) {\n            // This works because the bit ranges decrease in priority as you go left.\n            return a !== NoLane && a < b ? a : b;\n        }\n        function createLaneMap(initial) {\n            // Intentionally pushing one by one.\n            // https://v8.dev/blog/elements-kinds#avoid-creating-holes\n            var laneMap = [];\n            for(var i = 0; i < TotalLanes; i++){\n                laneMap.push(initial);\n            }\n            return laneMap;\n        }\n        function markRootUpdated$1(root, updateLane) {\n            root.pendingLanes |= updateLane; // If there are any suspended transitions, it's possible this new update\n            // could unblock them. Clear the suspended lanes so that we can try rendering\n            // them again.\n            //\n            // TODO: We really only need to unsuspend only lanes that are in the\n            // `subtreeLanes` of the updated fiber, or the update lanes of the return\n            // path. This would exclude suspended updates in an unrelated sibling tree,\n            // since there's no way for this update to unblock it.\n            //\n            // We don't do this if the incoming update is idle, because we never process\n            // idle updates until after all the regular updates have finished; there's no\n            // way it could unblock a transition.\n            if (updateLane !== IdleLane) {\n                root.suspendedLanes = NoLanes;\n                root.pingedLanes = NoLanes;\n            }\n        }\n        function markRootSuspended$1(root, suspendedLanes, spawnedLane) {\n            root.suspendedLanes |= suspendedLanes;\n            root.pingedLanes &= ~suspendedLanes; // The suspended lanes are no longer CPU-bound. Clear their expiration times.\n            var expirationTimes = root.expirationTimes;\n            var lanes = suspendedLanes;\n            while(lanes > 0){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                expirationTimes[index] = NoTimestamp;\n                lanes &= ~lane;\n            }\n            if (spawnedLane !== NoLane) {\n                markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);\n            }\n        }\n        function markRootPinged$1(root, pingedLanes) {\n            root.pingedLanes |= root.suspendedLanes & pingedLanes;\n        }\n        function markRootFinished(root, remainingLanes, spawnedLane) {\n            var noLongerPendingLanes = root.pendingLanes & ~remainingLanes;\n            root.pendingLanes = remainingLanes; // Let's try everything again\n            root.suspendedLanes = NoLanes;\n            root.pingedLanes = NoLanes;\n            root.expiredLanes &= remainingLanes;\n            root.entangledLanes &= remainingLanes;\n            root.errorRecoveryDisabledLanes &= remainingLanes;\n            root.shellSuspendCounter = 0;\n            var entanglements = root.entanglements;\n            var expirationTimes = root.expirationTimes;\n            var hiddenUpdates = root.hiddenUpdates; // Clear the lanes that no longer have pending work\n            var lanes = noLongerPendingLanes;\n            while(lanes > 0){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                entanglements[index] = NoLanes;\n                expirationTimes[index] = NoTimestamp;\n                var hiddenUpdatesForLane = hiddenUpdates[index];\n                if (hiddenUpdatesForLane !== null) {\n                    hiddenUpdates[index] = null; // \"Hidden\" updates are updates that were made to a hidden component. They\n                    // have special logic associated with them because they may be entangled\n                    // with updates that occur outside that tree. But once the outer tree\n                    // commits, they behave like regular updates.\n                    for(var i = 0; i < hiddenUpdatesForLane.length; i++){\n                        var update = hiddenUpdatesForLane[i];\n                        if (update !== null) {\n                            update.lane &= ~OffscreenLane;\n                        }\n                    }\n                }\n                lanes &= ~lane;\n            }\n            if (spawnedLane !== NoLane) {\n                markSpawnedDeferredLane(root, spawnedLane, // to entangle the spawned task with the parent task.\n                NoLanes);\n            }\n        }\n        function markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {\n            // This render spawned a deferred task. Mark it as pending.\n            root.pendingLanes |= spawnedLane;\n            root.suspendedLanes &= ~spawnedLane; // Entangle the spawned lane with the DeferredLane bit so that we know it\n            // was the result of another render. This lets us avoid a useDeferredValue\n            // waterfall — only the first level will defer.\n            var spawnedLaneIndex = laneToIndex(spawnedLane);\n            root.entangledLanes |= spawnedLane;\n            root.entanglements[spawnedLaneIndex] |= DeferredLane | // If the parent render task suspended, we must also entangle those lanes\n            // with the spawned task, so that the deferred task includes all the same\n            // updates that the parent task did. We can exclude any lane that is not\n            // used for updates (e.g. Offscreen).\n            entangledLanes & UpdateLanes;\n        }\n        function markRootEntangled(root, entangledLanes) {\n            // In addition to entangling each of the given lanes with each other, we also\n            // have to consider _transitive_ entanglements. For each lane that is already\n            // entangled with *any* of the given lanes, that lane is now transitively\n            // entangled with *all* the given lanes.\n            //\n            // Translated: If C is entangled with A, then entangling A with B also\n            // entangles C with B.\n            //\n            // If this is hard to grasp, it might help to intentionally break this\n            // function and look at the tests that fail in ReactTransition-test.js. Try\n            // commenting out one of the conditions below.\n            var rootEntangledLanes = root.entangledLanes |= entangledLanes;\n            var entanglements = root.entanglements;\n            var lanes = rootEntangledLanes;\n            while(lanes){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                if (lane & entangledLanes | // Is this lane transitively entangled with the newly entangled lanes?\n                entanglements[index] & entangledLanes) {\n                    entanglements[index] |= entangledLanes;\n                }\n                lanes &= ~lane;\n            }\n        }\n        function upgradePendingLaneToSync(root, lane) {\n            // Since we're upgrading the priority of the given lane, there is now pending\n            // sync work.\n            root.pendingLanes |= SyncLane; // Entangle the sync lane with the lane we're upgrading. This means SyncLane\n            // will not be allowed to finish without also finishing the given lane.\n            root.entangledLanes |= SyncLane;\n            root.entanglements[SyncLaneIndex] |= lane;\n        }\n        function upgradePendingLanesToSync(root, lanesToUpgrade) {\n            // Same as upgradePendingLaneToSync but accepts multiple lanes, so it's a\n            // bit slower.\n            root.pendingLanes |= SyncLane;\n            root.entangledLanes |= SyncLane;\n            var lanes = lanesToUpgrade;\n            while(lanes){\n                var index = pickArbitraryLaneIndex(lanes);\n                var lane = 1 << index;\n                root.entanglements[SyncLaneIndex] |= lane;\n                lanes &= ~lane;\n            }\n        }\n        function markHiddenUpdate(root, update, lane) {\n            var index = laneToIndex(lane);\n            var hiddenUpdates = root.hiddenUpdates;\n            var hiddenUpdatesForLane = hiddenUpdates[index];\n            if (hiddenUpdatesForLane === null) {\n                hiddenUpdates[index] = [\n                    update\n                ];\n            } else {\n                hiddenUpdatesForLane.push(update);\n            }\n            update.lane = lane | OffscreenLane;\n        }\n        function getBumpedLaneForHydration(root, renderLanes) {\n            var renderLane = getHighestPriorityLane(renderLanes);\n            var lane;\n            if ((renderLane & SyncUpdateLanes) !== NoLane) {\n                lane = SyncHydrationLane;\n            } else {\n                switch(renderLane){\n                    case SyncLane:\n                        lane = SyncHydrationLane;\n                        break;\n                    case InputContinuousLane:\n                        lane = InputContinuousHydrationLane;\n                        break;\n                    case DefaultLane:\n                        lane = DefaultHydrationLane;\n                        break;\n                    case TransitionLane1:\n                    case TransitionLane2:\n                    case TransitionLane3:\n                    case TransitionLane4:\n                    case TransitionLane5:\n                    case TransitionLane6:\n                    case TransitionLane7:\n                    case TransitionLane8:\n                    case TransitionLane9:\n                    case TransitionLane10:\n                    case TransitionLane11:\n                    case TransitionLane12:\n                    case TransitionLane13:\n                    case TransitionLane14:\n                    case TransitionLane15:\n                    case RetryLane1:\n                    case RetryLane2:\n                    case RetryLane3:\n                    case RetryLane4:\n                        lane = TransitionHydrationLane;\n                        break;\n                    case IdleLane:\n                        lane = IdleHydrationLane;\n                        break;\n                    default:\n                        // Everything else is already either a hydration lane, or shouldn't\n                        // be retried at a hydration lane.\n                        lane = NoLane;\n                        break;\n                }\n            } // Check if the lane we chose is suspended. If so, that indicates that we\n            // already attempted and failed to hydrate at that level. Also check if we're\n            // already rendering that lane, which is rare but could happen.\n            if ((lane & (root.suspendedLanes | renderLanes)) !== NoLane) {\n                // Give up trying to hydrate and fall back to client render.\n                return NoLane;\n            }\n            return lane;\n        }\n        function addFiberToLanesMap(root, fiber, lanes) {\n            if (!isDevToolsPresent) {\n                return;\n            }\n            var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n            while(lanes > 0){\n                var index = laneToIndex(lanes);\n                var lane = 1 << index;\n                var updaters = pendingUpdatersLaneMap[index];\n                updaters.add(fiber);\n                lanes &= ~lane;\n            }\n        }\n        function movePendingFibersToMemoized(root, lanes) {\n            if (!isDevToolsPresent) {\n                return;\n            }\n            var pendingUpdatersLaneMap = root.pendingUpdatersLaneMap;\n            var memoizedUpdaters = root.memoizedUpdaters;\n            while(lanes > 0){\n                var index = laneToIndex(lanes);\n                var lane = 1 << index;\n                var updaters = pendingUpdatersLaneMap[index];\n                if (updaters.size > 0) {\n                    updaters.forEach(function(fiber) {\n                        var alternate = fiber.alternate;\n                        if (alternate === null || !memoizedUpdaters.has(alternate)) {\n                            memoizedUpdaters.add(fiber);\n                        }\n                    });\n                    updaters.clear();\n                }\n                lanes &= ~lane;\n            }\n        }\n        function getTransitionsForLanes(root, lanes) {\n            {\n                return null;\n            }\n        }\n        var DiscreteEventPriority = SyncLane;\n        var ContinuousEventPriority = InputContinuousLane;\n        var DefaultEventPriority = DefaultLane;\n        var IdleEventPriority = IdleLane;\n        function higherEventPriority(a, b) {\n            return a !== 0 && a < b ? a : b;\n        }\n        function lowerEventPriority(a, b) {\n            return a === 0 || a > b ? a : b;\n        }\n        function isHigherEventPriority(a, b) {\n            return a !== 0 && a < b;\n        }\n        function eventPriorityToLane(updatePriority) {\n            return updatePriority;\n        }\n        function lanesToEventPriority(lanes) {\n            var lane = getHighestPriorityLane(lanes);\n            if (!isHigherEventPriority(DiscreteEventPriority, lane)) {\n                return DiscreteEventPriority;\n            }\n            if (!isHigherEventPriority(ContinuousEventPriority, lane)) {\n                return ContinuousEventPriority;\n            }\n            if (includesNonIdleWork(lane)) {\n                return DefaultEventPriority;\n            }\n            return IdleEventPriority;\n        }\n        // This module only exists as an ESM wrapper around the external CommonJS\n        var scheduleCallback$3 = Scheduler.unstable_scheduleCallback;\n        var cancelCallback$1 = Scheduler.unstable_cancelCallback;\n        var shouldYield = Scheduler.unstable_shouldYield;\n        var requestPaint = Scheduler.unstable_requestPaint;\n        var now$1 = Scheduler.unstable_now;\n        var ImmediatePriority = Scheduler.unstable_ImmediatePriority;\n        var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;\n        var NormalPriority$1 = Scheduler.unstable_NormalPriority;\n        var IdlePriority = Scheduler.unstable_IdlePriority; // this doesn't actually exist on the scheduler, but it *does*\n        // on scheduler/unstable_mock, which we'll need for internal testing\n        var log = Scheduler.log;\n        var unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue;\n        var rendererID = null;\n        var injectedHook = null;\n        var injectedProfilingHooks = null;\n        var hasLoggedError = false;\n        var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined';\n        function injectInternals(internals) {\n            if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {\n                // No DevTools\n                return false;\n            }\n            var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n            if (hook.isDisabled) {\n                // This isn't a real property on the hook, but it can be set to opt out\n                // of DevTools integration and associated warnings and logs.\n                // https://github.com/facebook/react/issues/3877\n                return true;\n            }\n            if (!hook.supportsFiber) {\n                {\n                    error('The installed version of React DevTools is too old and will not work ' + 'with the current version of React. Please update React DevTools. ' + 'https://react.dev/link/react-devtools');\n                }\n                return true;\n            }\n            try {\n                if (enableSchedulingProfiler) {\n                    // Conditionally inject these hooks only if Timeline profiler is supported by this build.\n                    // This gives DevTools a way to feature detect that isn't tied to version number\n                    // (since profiling and timeline are controlled by different feature flags).\n                    internals = assign({}, internals, {\n                        getLaneLabelMap: getLaneLabelMap,\n                        injectProfilingHooks: injectProfilingHooks\n                    });\n                }\n                rendererID = hook.inject(internals); // We have successfully injected, so now it is safe to set up hooks.\n                injectedHook = hook;\n            } catch (err) {\n                // Catch all errors because it is unsafe to throw during initialization.\n                {\n                    error('React instrumentation encountered an error: %s.', err);\n                }\n            }\n            if (hook.checkDCE) {\n                // This is the real DevTools.\n                return true;\n            } else {\n                // This is likely a hook installed by Fast Refresh runtime.\n                return false;\n            }\n        }\n        function onScheduleRoot(root, children) {\n            {\n                if (injectedHook && typeof injectedHook.onScheduleFiberRoot === 'function') {\n                    try {\n                        injectedHook.onScheduleFiberRoot(rendererID, root, children);\n                    } catch (err) {\n                        if (!hasLoggedError) {\n                            hasLoggedError = true;\n                            error('React instrumentation encountered an error: %s', err);\n                        }\n                    }\n                }\n            }\n        }\n        function onCommitRoot$1(root, eventPriority) {\n            if (injectedHook && typeof injectedHook.onCommitFiberRoot === 'function') {\n                try {\n                    var didError = (root.current.flags & DidCapture) === DidCapture;\n                    if (enableProfilerTimer) {\n                        var schedulerPriority;\n                        switch(eventPriority){\n                            case DiscreteEventPriority:\n                                schedulerPriority = ImmediatePriority;\n                                break;\n                            case ContinuousEventPriority:\n                                schedulerPriority = UserBlockingPriority;\n                                break;\n                            case DefaultEventPriority:\n                                schedulerPriority = NormalPriority$1;\n                                break;\n                            case IdleEventPriority:\n                                schedulerPriority = IdlePriority;\n                                break;\n                            default:\n                                schedulerPriority = NormalPriority$1;\n                                break;\n                        }\n                        injectedHook.onCommitFiberRoot(rendererID, root, schedulerPriority, didError);\n                    }\n                } catch (err) {\n                    {\n                        if (!hasLoggedError) {\n                            hasLoggedError = true;\n                            error('React instrumentation encountered an error: %s', err);\n                        }\n                    }\n                }\n            }\n        }\n        function onPostCommitRoot(root) {\n            if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === 'function') {\n                try {\n                    injectedHook.onPostCommitFiberRoot(rendererID, root);\n                } catch (err) {\n                    {\n                        if (!hasLoggedError) {\n                            hasLoggedError = true;\n                            error('React instrumentation encountered an error: %s', err);\n                        }\n                    }\n                }\n            }\n        }\n        function onCommitUnmount(fiber) {\n            if (injectedHook && typeof injectedHook.onCommitFiberUnmount === 'function') {\n                try {\n                    injectedHook.onCommitFiberUnmount(rendererID, fiber);\n                } catch (err) {\n                    {\n                        if (!hasLoggedError) {\n                            hasLoggedError = true;\n                            error('React instrumentation encountered an error: %s', err);\n                        }\n                    }\n                }\n            }\n        }\n        function setIsStrictModeForDevtools(newIsStrictMode) {\n            {\n                if (typeof log === 'function') {\n                    // We're in a test because Scheduler.log only exists\n                    // in SchedulerMock. To reduce the noise in strict mode tests,\n                    // suppress warnings and disable scheduler yielding during the double render\n                    unstable_setDisableYieldValue(newIsStrictMode);\n                    setSuppressWarning(newIsStrictMode);\n                }\n                if (injectedHook && typeof injectedHook.setStrictMode === 'function') {\n                    try {\n                        injectedHook.setStrictMode(rendererID, newIsStrictMode);\n                    } catch (err) {\n                        {\n                            if (!hasLoggedError) {\n                                hasLoggedError = true;\n                                error('React instrumentation encountered an error: %s', err);\n                            }\n                        }\n                    }\n                }\n            }\n        } // Profiler API hooks\n        function injectProfilingHooks(profilingHooks) {\n            injectedProfilingHooks = profilingHooks;\n        }\n        function getLaneLabelMap() {\n            {\n                var map = new Map();\n                var lane = 1;\n                for(var index = 0; index < TotalLanes; index++){\n                    var label = getLabelForLane(lane);\n                    map.set(lane, label);\n                    lane *= 2;\n                }\n                return map;\n            }\n        }\n        function markCommitStarted(lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === 'function') {\n                    injectedProfilingHooks.markCommitStarted(lanes);\n                }\n            }\n        }\n        function markCommitStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === 'function') {\n                    injectedProfilingHooks.markCommitStopped();\n                }\n            }\n        }\n        function markComponentRenderStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === 'function') {\n                    injectedProfilingHooks.markComponentRenderStarted(fiber);\n                }\n            }\n        }\n        function markComponentRenderStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === 'function') {\n                    injectedProfilingHooks.markComponentRenderStopped();\n                }\n            }\n        }\n        function markComponentPassiveEffectMountStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === 'function') {\n                    injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);\n                }\n            }\n        }\n        function markComponentPassiveEffectMountStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === 'function') {\n                    injectedProfilingHooks.markComponentPassiveEffectMountStopped();\n                }\n            }\n        }\n        function markComponentPassiveEffectUnmountStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === 'function') {\n                    injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);\n                }\n            }\n        }\n        function markComponentPassiveEffectUnmountStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === 'function') {\n                    injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();\n                }\n            }\n        }\n        function markComponentLayoutEffectMountStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === 'function') {\n                    injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);\n                }\n            }\n        }\n        function markComponentLayoutEffectMountStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === 'function') {\n                    injectedProfilingHooks.markComponentLayoutEffectMountStopped();\n                }\n            }\n        }\n        function markComponentLayoutEffectUnmountStarted(fiber) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === 'function') {\n                    injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);\n                }\n            }\n        }\n        function markComponentLayoutEffectUnmountStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === 'function') {\n                    injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();\n                }\n            }\n        }\n        function markComponentErrored(fiber, thrownValue, lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === 'function') {\n                    injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);\n                }\n            }\n        }\n        function markComponentSuspended(fiber, wakeable, lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === 'function') {\n                    injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);\n                }\n            }\n        }\n        function markLayoutEffectsStarted(lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === 'function') {\n                    injectedProfilingHooks.markLayoutEffectsStarted(lanes);\n                }\n            }\n        }\n        function markLayoutEffectsStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === 'function') {\n                    injectedProfilingHooks.markLayoutEffectsStopped();\n                }\n            }\n        }\n        function markPassiveEffectsStarted(lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === 'function') {\n                    injectedProfilingHooks.markPassiveEffectsStarted(lanes);\n                }\n            }\n        }\n        function markPassiveEffectsStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === 'function') {\n                    injectedProfilingHooks.markPassiveEffectsStopped();\n                }\n            }\n        }\n        function markRenderStarted(lanes) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === 'function') {\n                    injectedProfilingHooks.markRenderStarted(lanes);\n                }\n            }\n        }\n        function markRenderYielded() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === 'function') {\n                    injectedProfilingHooks.markRenderYielded();\n                }\n            }\n        }\n        function markRenderStopped() {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === 'function') {\n                    injectedProfilingHooks.markRenderStopped();\n                }\n            }\n        }\n        function markRenderScheduled(lane) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === 'function') {\n                    injectedProfilingHooks.markRenderScheduled(lane);\n                }\n            }\n        }\n        function markForceUpdateScheduled(fiber, lane) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === 'function') {\n                    injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);\n                }\n            }\n        }\n        function markStateUpdateScheduled(fiber, lane) {\n            {\n                if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === 'function') {\n                    injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);\n                }\n            }\n        }\n        /**\n * inlined Object.is polyfill to avoid requiring consumers ship their own\n * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is\n */ function is(x, y) {\n            return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y // eslint-disable-line no-self-compare\n            ;\n        }\n        var objectIs = typeof Object.is === 'function' ? Object.is : is;\n        // This is imported by the event replaying implementation in React DOM. It's\n        // in a separate file to break a circular dependency between the renderer and\n        // the reconciler.\n        function isRootDehydrated(root) {\n            var currentState = root.current.memoizedState;\n            return currentState.isDehydrated;\n        }\n        var CapturedStacks = new WeakMap();\n        function createCapturedValueAtFiber(value, source) {\n            // If the value is an error, call this function immediately after it is thrown\n            // so the stack is accurate.\n            var stack;\n            if (typeof value === 'object' && value !== null) {\n                var capturedStack = CapturedStacks.get(value);\n                if (typeof capturedStack === 'string') {\n                    stack = capturedStack;\n                } else {\n                    stack = getStackByFiberInDevAndProd(source);\n                    CapturedStacks.set(value, stack);\n                }\n            } else {\n                stack = getStackByFiberInDevAndProd(source);\n            }\n            return {\n                value: value,\n                source: source,\n                stack: stack\n            };\n        }\n        function createCapturedValueFromError(value, stack) {\n            if (typeof stack === 'string') {\n                CapturedStacks.set(value, stack);\n            }\n            return {\n                value: value,\n                source: null,\n                stack: stack\n            };\n        }\n        // Intentionally not using it yet to derisk the initial implementation, because\n        // the way we push/pop these values is a bit unusual. If there's a mistake, I'd\n        // rather the ids be wrong than crash the whole reconciler.\n        var forkStack = [];\n        var forkStackIndex = 0;\n        var treeForkProvider = null;\n        var treeForkCount = 0;\n        var idStack = [];\n        var idStackIndex = 0;\n        var treeContextProvider = null;\n        var treeContextId = 1;\n        var treeContextOverflow = '';\n        function isForkedChild(workInProgress) {\n            warnIfNotHydrating();\n            return (workInProgress.flags & Forked) !== NoFlags$1;\n        }\n        function getForksAtLevel(workInProgress) {\n            warnIfNotHydrating();\n            return treeForkCount;\n        }\n        function getTreeId() {\n            var overflow = treeContextOverflow;\n            var idWithLeadingBit = treeContextId;\n            var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);\n            return id.toString(32) + overflow;\n        }\n        function pushTreeFork(workInProgress, totalChildren) {\n            // This is called right after we reconcile an array (or iterator) of child\n            // fibers, because that's the only place where we know how many children in\n            // the whole set without doing extra work later, or storing addtional\n            // information on the fiber.\n            //\n            // That's why this function is separate from pushTreeId — it's called during\n            // the render phase of the fork parent, not the child, which is where we push\n            // the other context values.\n            //\n            // In the Fizz implementation this is much simpler because the child is\n            // rendered in the same callstack as the parent.\n            //\n            // It might be better to just add a `forks` field to the Fiber type. It would\n            // make this module simpler.\n            warnIfNotHydrating();\n            forkStack[forkStackIndex++] = treeForkCount;\n            forkStack[forkStackIndex++] = treeForkProvider;\n            treeForkProvider = workInProgress;\n            treeForkCount = totalChildren;\n        }\n        function pushTreeId(workInProgress, totalChildren, index) {\n            warnIfNotHydrating();\n            idStack[idStackIndex++] = treeContextId;\n            idStack[idStackIndex++] = treeContextOverflow;\n            idStack[idStackIndex++] = treeContextProvider;\n            treeContextProvider = workInProgress;\n            var baseIdWithLeadingBit = treeContextId;\n            var baseOverflow = treeContextOverflow; // The leftmost 1 marks the end of the sequence, non-inclusive. It's not part\n            // of the id; we use it to account for leading 0s.\n            var baseLength = getBitLength(baseIdWithLeadingBit) - 1;\n            var baseId = baseIdWithLeadingBit & ~(1 << baseLength);\n            var slot = index + 1;\n            var length = getBitLength(totalChildren) + baseLength; // 30 is the max length we can store without overflowing, taking into\n            // consideration the leading 1 we use to mark the end of the sequence.\n            if (length > 30) {\n                // We overflowed the bitwise-safe range. Fall back to slower algorithm.\n                // This branch assumes the length of the base id is greater than 5; it won't\n                // work for smaller ids, because you need 5 bits per character.\n                //\n                // We encode the id in multiple steps: first the base id, then the\n                // remaining digits.\n                //\n                // Each 5 bit sequence corresponds to a single base 32 character. So for\n                // example, if the current id is 23 bits long, we can convert 20 of those\n                // bits into a string of 4 characters, with 3 bits left over.\n                //\n                // First calculate how many bits in the base id represent a complete\n                // sequence of characters.\n                var numberOfOverflowBits = baseLength - baseLength % 5; // Then create a bitmask that selects only those bits.\n                var newOverflowBits = (1 << numberOfOverflowBits) - 1; // Select the bits, and convert them to a base 32 string.\n                var newOverflow = (baseId & newOverflowBits).toString(32); // Now we can remove those bits from the base id.\n                var restOfBaseId = baseId >> numberOfOverflowBits;\n                var restOfBaseLength = baseLength - numberOfOverflowBits; // Finally, encode the rest of the bits using the normal algorithm. Because\n                // we made more room, this time it won't overflow.\n                var restOfLength = getBitLength(totalChildren) + restOfBaseLength;\n                var restOfNewBits = slot << restOfBaseLength;\n                var id = restOfNewBits | restOfBaseId;\n                var overflow = newOverflow + baseOverflow;\n                treeContextId = 1 << restOfLength | id;\n                treeContextOverflow = overflow;\n            } else {\n                // Normal path\n                var newBits = slot << baseLength;\n                var _id = newBits | baseId;\n                var _overflow = baseOverflow;\n                treeContextId = 1 << length | _id;\n                treeContextOverflow = _overflow;\n            }\n        }\n        function pushMaterializedTreeId(workInProgress) {\n            warnIfNotHydrating(); // This component materialized an id. This will affect any ids that appear\n            // in its children.\n            var returnFiber = workInProgress.return;\n            if (returnFiber !== null) {\n                var numberOfForks = 1;\n                var slotIndex = 0;\n                pushTreeFork(workInProgress, numberOfForks);\n                pushTreeId(workInProgress, numberOfForks, slotIndex);\n            }\n        }\n        function getBitLength(number) {\n            return 32 - clz32(number);\n        }\n        function getLeadingBit(id) {\n            return 1 << getBitLength(id) - 1;\n        }\n        function popTreeContext(workInProgress) {\n            // Restore the previous values.\n            // This is a bit more complicated than other context-like modules in Fiber\n            // because the same Fiber may appear on the stack multiple times and for\n            // different reasons. We have to keep popping until the work-in-progress is\n            // no longer at the top of the stack.\n            while(workInProgress === treeForkProvider){\n                treeForkProvider = forkStack[--forkStackIndex];\n                forkStack[forkStackIndex] = null;\n                treeForkCount = forkStack[--forkStackIndex];\n                forkStack[forkStackIndex] = null;\n            }\n            while(workInProgress === treeContextProvider){\n                treeContextProvider = idStack[--idStackIndex];\n                idStack[idStackIndex] = null;\n                treeContextOverflow = idStack[--idStackIndex];\n                idStack[idStackIndex] = null;\n                treeContextId = idStack[--idStackIndex];\n                idStack[idStackIndex] = null;\n            }\n        }\n        function getSuspendedTreeContext() {\n            warnIfNotHydrating();\n            if (treeContextProvider !== null) {\n                return {\n                    id: treeContextId,\n                    overflow: treeContextOverflow\n                };\n            } else {\n                return null;\n            }\n        }\n        function restoreSuspendedTreeContext(workInProgress, suspendedContext) {\n            warnIfNotHydrating();\n            idStack[idStackIndex++] = treeContextId;\n            idStack[idStackIndex++] = treeContextOverflow;\n            idStack[idStackIndex++] = treeContextProvider;\n            treeContextId = suspendedContext.id;\n            treeContextOverflow = suspendedContext.overflow;\n            treeContextProvider = workInProgress;\n        }\n        function warnIfNotHydrating() {\n            {\n                if (!getIsHydrating()) {\n                    error('Expected to be hydrating. This is a bug in React. Please file ' + 'an issue.');\n                }\n            }\n        }\n        var contextStackCursor = createCursor(null);\n        var contextFiberStackCursor = createCursor(null);\n        var rootInstanceStackCursor = createCursor(null); // Represents the nearest host transition provider (in React DOM, a <form />)\n        // NOTE: Since forms cannot be nested, and this feature is only implemented by\n        // React DOM, we don't technically need this to be a stack. It could be a single\n        // module variable instead.\n        var hostTransitionProviderCursor = createCursor(null); // TODO: This should initialize to NotPendingTransition, a constant\n        // imported from the fiber config. However, because of a cycle in the module\n        // graph, that value isn't defined during this module's initialization. I can't\n        // think of a way to work around this without moving that value out of the\n        // fiber config. For now, the \"no provider\" case is handled when reading,\n        // inside useHostTransitionStatus.\n        var HostTransitionContext = {\n            $$typeof: REACT_CONTEXT_TYPE,\n            Provider: null,\n            Consumer: null,\n            _currentValue: null,\n            _currentValue2: null,\n            _threadCount: 0\n        };\n        function requiredContext(c) {\n            {\n                if (c === null) {\n                    error('Expected host context to exist. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n                }\n            }\n            return c;\n        }\n        function getRootHostContainer() {\n            var rootInstance = requiredContext(rootInstanceStackCursor.current);\n            return rootInstance;\n        }\n        function pushHostContainer(fiber, nextRootInstance) {\n            // Push current root instance onto the stack;\n            // This allows us to reset root when portals are popped.\n            push(rootInstanceStackCursor, nextRootInstance, fiber); // Track the context and the Fiber that provided it.\n            // This enables us to pop only Fibers that provide unique contexts.\n            push(contextFiberStackCursor, fiber, fiber); // Finally, we need to push the host context to the stack.\n            // However, we can't just call getRootHostContext() and push it because\n            // we'd have a different number of entries on the stack depending on\n            // whether getRootHostContext() throws somewhere in renderer code or not.\n            // So we push an empty value first. This lets us safely unwind on errors.\n            push(contextStackCursor, null, fiber);\n            var nextRootContext = getRootHostContext(nextRootInstance); // Now that we know this function doesn't throw, replace it.\n            pop(contextStackCursor, fiber);\n            push(contextStackCursor, nextRootContext, fiber);\n        }\n        function popHostContainer(fiber) {\n            pop(contextStackCursor, fiber);\n            pop(contextFiberStackCursor, fiber);\n            pop(rootInstanceStackCursor, fiber);\n        }\n        function getHostContext() {\n            var context = requiredContext(contextStackCursor.current);\n            return context;\n        }\n        function pushHostContext(fiber) {\n            {\n                var stateHook = fiber.memoizedState;\n                if (stateHook !== null) {\n                    // Only provide context if this fiber has been upgraded by a host\n                    // transition. We use the same optimization for regular host context below.\n                    push(hostTransitionProviderCursor, fiber, fiber);\n                }\n            }\n            var context = requiredContext(contextStackCursor.current);\n            var nextContext = getChildHostContext(context, fiber.type); // Don't push this Fiber's context unless it's unique.\n            if (context !== nextContext) {\n                // Track the context and the Fiber that provided it.\n                // This enables us to pop only Fibers that provide unique contexts.\n                push(contextFiberStackCursor, fiber, fiber);\n                push(contextStackCursor, nextContext, fiber);\n            }\n        }\n        function popHostContext(fiber) {\n            if (contextFiberStackCursor.current === fiber) {\n                // Do not pop unless this Fiber provided the current context.\n                // pushHostContext() only pushes Fibers that provide unique contexts.\n                pop(contextStackCursor, fiber);\n                pop(contextFiberStackCursor, fiber);\n            }\n            {\n                if (hostTransitionProviderCursor.current === fiber) {\n                    // Do not pop unless this Fiber provided the current context. This is mostly\n                    // a performance optimization, but conveniently it also prevents a potential\n                    // data race where a host provider is upgraded (i.e. memoizedState becomes\n                    // non-null) during a concurrent event. This is a bit of a flaw in the way\n                    // we upgrade host components, but because we're accounting for it here, it\n                    // should be fine.\n                    pop(hostTransitionProviderCursor, fiber); // When popping the transition provider, we reset the context value back\n                    // to `null`. We can do this because you're not allowd to nest forms. If\n                    // we allowed for multiple nested host transition providers, then we'd\n                    // need to reset this to the parent provider's status.\n                    if (isPrimaryRenderer) {\n                        HostTransitionContext._currentValue = null;\n                    } else {\n                        HostTransitionContext._currentValue2 = null;\n                    }\n                }\n            }\n        }\n        var maxRowLength = 120;\n        var idealDepth = 15;\n        function findNotableNode(node, indent) {\n            if (node.serverProps === undefined && node.serverTail.length === 0 && node.children.length === 1 && node.distanceFromLeaf > 3 && node.distanceFromLeaf > idealDepth - indent) {\n                // This is not an interesting node for contextual purposes so we can skip it.\n                var child = node.children[0];\n                return findNotableNode(child, indent);\n            }\n            return node;\n        }\n        function indentation(indent) {\n            return '  ' + '  '.repeat(indent);\n        }\n        function added(indent) {\n            return '+ ' + '  '.repeat(indent);\n        }\n        function removed(indent) {\n            return '- ' + '  '.repeat(indent);\n        }\n        function describeFiberType(fiber) {\n            switch(fiber.tag){\n                case HostHoistable:\n                case HostSingleton:\n                case HostComponent:\n                    return fiber.type;\n                case LazyComponent:\n                    return 'Lazy';\n                case SuspenseComponent:\n                    return 'Suspense';\n                case SuspenseListComponent:\n                    return 'SuspenseList';\n                case FunctionComponent:\n                case SimpleMemoComponent:\n                    var fn = fiber.type;\n                    return fn.displayName || fn.name || null;\n                case ForwardRef:\n                    var render = fiber.type.render;\n                    return render.displayName || render.name || null;\n                case ClassComponent:\n                    var ctr = fiber.type;\n                    return ctr.displayName || ctr.name || null;\n                default:\n                    // Skip\n                    return null;\n            }\n        }\n        var needsEscaping = /[\"'&<>\\n\\t]/;\n        function describeTextNode(content, maxLength) {\n            if (needsEscaping.test(content)) {\n                var encoded = JSON.stringify(content);\n                if (encoded.length > maxLength - 2) {\n                    if (maxLength < 8) {\n                        return '{\"...\"}';\n                    }\n                    return '{' + encoded.slice(0, maxLength - 7) + '...\"}';\n                }\n                return '{' + encoded + '}';\n            } else {\n                if (content.length > maxLength) {\n                    if (maxLength < 5) {\n                        return '{\"...\"}';\n                    }\n                    return content.slice(0, maxLength - 3) + '...';\n                }\n                return content;\n            }\n        }\n        function describeTextDiff(clientText, serverProps, indent) {\n            var maxLength = maxRowLength - indent * 2;\n            if (serverProps === null) {\n                return added(indent) + describeTextNode(clientText, maxLength) + '\\n';\n            } else if (typeof serverProps === 'string') {\n                var serverText = serverProps;\n                var firstDiff = 0;\n                for(; firstDiff < serverText.length && firstDiff < clientText.length; firstDiff++){\n                    if (serverText.charCodeAt(firstDiff) !== clientText.charCodeAt(firstDiff)) {\n                        break;\n                    }\n                }\n                if (firstDiff > maxLength - 8 && firstDiff > 10) {\n                    // The first difference between the two strings would be cut off, so cut off in\n                    // the beginning instead.\n                    clientText = '...' + clientText.slice(firstDiff - 8);\n                    serverText = '...' + serverText.slice(firstDiff - 8);\n                }\n                return added(indent) + describeTextNode(clientText, maxLength) + '\\n' + removed(indent) + describeTextNode(serverText, maxLength) + '\\n';\n            } else {\n                return indentation(indent) + describeTextNode(clientText, maxLength) + '\\n';\n            }\n        }\n        function objectName(object) {\n            // $FlowFixMe[method-unbinding]\n            var name = Object.prototype.toString.call(object);\n            return name.replace(/^\\[object (.*)\\]$/, function(m, p0) {\n                return p0;\n            });\n        }\n        function describeValue(value, maxLength) {\n            switch(typeof value){\n                case 'string':\n                    {\n                        var encoded = JSON.stringify(value);\n                        if (encoded.length > maxLength) {\n                            if (maxLength < 5) {\n                                return '\"...\"';\n                            }\n                            return encoded.slice(0, maxLength - 4) + '...\"';\n                        }\n                        return encoded;\n                    }\n                case 'object':\n                    {\n                        if (value === null) {\n                            return 'null';\n                        }\n                        if (isArray(value)) {\n                            return '[...]';\n                        }\n                        if (value.$$typeof === REACT_ELEMENT_TYPE) {\n                            var type = getComponentNameFromType(value.type);\n                            return type ? '<' + type + '>' : '<...>';\n                        }\n                        var name = objectName(value);\n                        if (name === 'Object') {\n                            var properties = '';\n                            maxLength -= 2;\n                            for(var propName in value){\n                                if (!value.hasOwnProperty(propName)) {\n                                    continue;\n                                }\n                                var jsonPropName = JSON.stringify(propName);\n                                if (jsonPropName !== '\"' + propName + '\"') {\n                                    propName = jsonPropName;\n                                }\n                                maxLength -= propName.length - 2;\n                                var propValue = describeValue(value[propName], maxLength < 15 ? maxLength : 15);\n                                maxLength -= propValue.length;\n                                if (maxLength < 0) {\n                                    properties += properties === '' ? '...' : ', ...';\n                                    break;\n                                }\n                                properties += (properties === '' ? '' : ',') + propName + ':' + propValue;\n                            }\n                            return '{' + properties + '}';\n                        }\n                        return name;\n                    }\n                case 'function':\n                    {\n                        var _name = value.displayName || value.name;\n                        return _name ? 'function ' + _name : 'function';\n                    }\n                default:\n                    // eslint-disable-next-line react-internal/safe-string-coercion\n                    return String(value);\n            }\n        }\n        function describePropValue(value, maxLength) {\n            if (typeof value === 'string' && !needsEscaping.test(value)) {\n                if (value.length > maxLength - 2) {\n                    if (maxLength < 5) {\n                        return '\"...\"';\n                    }\n                    return '\"' + value.slice(0, maxLength - 5) + '...\"';\n                }\n                return '\"' + value + '\"';\n            }\n            return '{' + describeValue(value, maxLength - 2) + '}';\n        }\n        function describeCollapsedElement(type, props, indent) {\n            // This function tries to fit the props into a single line for non-essential elements.\n            // We also ignore children because we're not going deeper.\n            var maxLength = maxRowLength - indent * 2 - type.length - 2;\n            var content = '';\n            for(var propName in props){\n                if (!props.hasOwnProperty(propName)) {\n                    continue;\n                }\n                if (propName === 'children') {\n                    continue;\n                }\n                var propValue = describePropValue(props[propName], 15);\n                maxLength -= propName.length + propValue.length + 2;\n                if (maxLength < 0) {\n                    content += ' ...';\n                    break;\n                }\n                content += ' ' + propName + '=' + propValue;\n            }\n            return indentation(indent) + '<' + type + content + '>\\n';\n        }\n        function describeExpandedElement(type, props, rowPrefix) {\n            // This function tries to fit the props into a single line for non-essential elements.\n            // We also ignore children because we're not going deeper.\n            var remainingRowLength = maxRowLength - rowPrefix.length - type.length; // We add the properties to a set so we can choose later whether we'll put it on one\n            // line or multiple lines.\n            var properties = [];\n            for(var propName in props){\n                if (!props.hasOwnProperty(propName)) {\n                    continue;\n                }\n                if (propName === 'children') {\n                    continue;\n                }\n                var maxLength = maxRowLength - rowPrefix.length - propName.length - 1;\n                var propValue = describePropValue(props[propName], maxLength);\n                remainingRowLength -= propName.length + propValue.length + 2;\n                properties.push(propName + '=' + propValue);\n            }\n            if (properties.length === 0) {\n                return rowPrefix + '<' + type + '>\\n';\n            } else if (remainingRowLength > 0) {\n                // We can fit all on one row.\n                return rowPrefix + '<' + type + ' ' + properties.join(' ') + '>\\n';\n            } else {\n                // Split into one row per property:\n                return rowPrefix + '<' + type + '\\n' + rowPrefix + '  ' + properties.join('\\n' + rowPrefix + '  ') + '\\n' + rowPrefix + '>\\n';\n            }\n        }\n        function describePropertiesDiff(clientObject, serverObject, indent) {\n            var properties = '';\n            var remainingServerProperties = assign({}, serverObject);\n            for(var propName in clientObject){\n                if (!clientObject.hasOwnProperty(propName)) {\n                    continue;\n                }\n                delete remainingServerProperties[propName];\n                var maxLength = maxRowLength - indent * 2 - propName.length - 2;\n                var clientValue = clientObject[propName];\n                var clientPropValue = describeValue(clientValue, maxLength);\n                if (serverObject.hasOwnProperty(propName)) {\n                    var serverValue = serverObject[propName];\n                    var serverPropValue = describeValue(serverValue, maxLength);\n                    properties += added(indent) + propName + ': ' + clientPropValue + '\\n';\n                    properties += removed(indent) + propName + ': ' + serverPropValue + '\\n';\n                } else {\n                    properties += added(indent) + propName + ': ' + clientPropValue + '\\n';\n                }\n            }\n            for(var _propName in remainingServerProperties){\n                if (!remainingServerProperties.hasOwnProperty(_propName)) {\n                    continue;\n                }\n                var _maxLength = maxRowLength - indent * 2 - _propName.length - 2;\n                var _serverValue = remainingServerProperties[_propName];\n                var _serverPropValue = describeValue(_serverValue, _maxLength);\n                properties += removed(indent) + _propName + ': ' + _serverPropValue + '\\n';\n            }\n            return properties;\n        }\n        function describeElementDiff(type, clientProps, serverProps, indent) {\n            var content = ''; // Maps any previously unmatched lower case server prop name to its full prop name\n            var serverPropNames = new Map();\n            for(var propName in serverProps){\n                if (!serverProps.hasOwnProperty(propName)) {\n                    continue;\n                }\n                serverPropNames.set(propName.toLowerCase(), propName);\n            }\n            if (serverPropNames.size === 1 && serverPropNames.has('children')) {\n                content += describeExpandedElement(type, clientProps, indentation(indent));\n            } else {\n                for(var _propName2 in clientProps){\n                    if (!clientProps.hasOwnProperty(_propName2)) {\n                        continue;\n                    }\n                    if (_propName2 === 'children') {\n                        continue;\n                    }\n                    var maxLength = maxRowLength - (indent + 1) * 2 - _propName2.length - 1;\n                    var serverPropName = serverPropNames.get(_propName2.toLowerCase());\n                    if (serverPropName !== undefined) {\n                        serverPropNames.delete(_propName2.toLowerCase()); // There's a diff here.\n                        var clientValue = clientProps[_propName2];\n                        var serverValue = serverProps[serverPropName];\n                        var clientPropValue = describePropValue(clientValue, maxLength);\n                        var serverPropValue = describePropValue(serverValue, maxLength);\n                        if (typeof clientValue === 'object' && clientValue !== null && typeof serverValue === 'object' && serverValue !== null && objectName(clientValue) === 'Object' && objectName(serverValue) === 'Object' && (Object.keys(clientValue).length > 2 || Object.keys(serverValue).length > 2 || clientPropValue.indexOf('...') > -1 || serverPropValue.indexOf('...') > -1)) {\n                            // We're comparing two plain objects. We can diff the nested objects instead.\n                            content += indentation(indent + 1) + _propName2 + '={{\\n' + describePropertiesDiff(clientValue, serverValue, indent + 2) + indentation(indent + 1) + '}}\\n';\n                        } else {\n                            content += added(indent + 1) + _propName2 + '=' + clientPropValue + '\\n';\n                            content += removed(indent + 1) + _propName2 + '=' + serverPropValue + '\\n';\n                        }\n                    } else {\n                        // Considered equal.\n                        content += indentation(indent + 1) + _propName2 + '=' + describePropValue(clientProps[_propName2], maxLength) + '\\n';\n                    }\n                }\n                serverPropNames.forEach(function(propName) {\n                    if (propName === 'children') {\n                        // Handled below.\n                        return;\n                    }\n                    var maxLength = maxRowLength - (indent + 1) * 2 - propName.length - 1;\n                    content += removed(indent + 1) + propName + '=' + describePropValue(serverProps[propName], maxLength) + '\\n';\n                });\n                if (content === '') {\n                    // No properties\n                    content = indentation(indent) + '<' + type + '>\\n';\n                } else {\n                    // Had properties\n                    content = indentation(indent) + '<' + type + '\\n' + content + indentation(indent) + '>\\n';\n                }\n            }\n            var serverChildren = serverProps.children;\n            var clientChildren = clientProps.children;\n            if (typeof serverChildren === 'string' || typeof serverChildren === 'number' || typeof serverChildren === 'bigint') {\n                // There's a diff of the children.\n                // $FlowFixMe[unsafe-addition]\n                var serverText = '' + serverChildren;\n                var clientText = '';\n                if (typeof clientChildren === 'string' || typeof clientChildren === 'number' || typeof clientChildren === 'bigint') {\n                    // $FlowFixMe[unsafe-addition]\n                    clientText = '' + clientChildren;\n                }\n                content += describeTextDiff(clientText, serverText, indent + 1);\n            } else if (typeof clientChildren === 'string' || typeof clientChildren === 'number' || typeof clientChildren === 'bigint') {\n                // The client has children but it's not considered a difference from the server.\n                // $FlowFixMe[unsafe-addition]\n                content += describeTextDiff('' + clientChildren, undefined, indent + 1);\n            }\n            return content;\n        }\n        function describeSiblingFiber(fiber, indent) {\n            var type = describeFiberType(fiber);\n            if (type === null) {\n                // Skip this type of fiber. We currently treat this as a fragment\n                // so it's just part of the parent's children.\n                var flatContent = '';\n                var childFiber = fiber.child;\n                while(childFiber){\n                    flatContent += describeSiblingFiber(childFiber, indent);\n                    childFiber = childFiber.sibling;\n                }\n                return flatContent;\n            }\n            return indentation(indent) + '<' + type + '>' + '\\n';\n        }\n        function describeNode(node, indent) {\n            var skipToNode = findNotableNode(node, indent);\n            if (skipToNode !== node && (node.children.length !== 1 || node.children[0] !== skipToNode)) {\n                return indentation(indent) + '...\\n' + describeNode(skipToNode, indent + 1);\n            } // Prefix with any server components for context\n            var parentContent = '';\n            var debugInfo = node.fiber._debugInfo;\n            if (debugInfo) {\n                for(var i = 0; i < debugInfo.length; i++){\n                    var serverComponentName = debugInfo[i].name;\n                    if (typeof serverComponentName === 'string') {\n                        parentContent += indentation(indent) + '<' + serverComponentName + '>' + '\\n';\n                        indent++;\n                    }\n                }\n            } // Self\n            var selfContent = ''; // We use the pending props since we might be generating a diff before the complete phase\n            // when something throws.\n            var clientProps = node.fiber.pendingProps;\n            if (node.fiber.tag === HostText) {\n                // Text Node\n                selfContent = describeTextDiff(clientProps, node.serverProps, indent);\n            } else {\n                var type = describeFiberType(node.fiber);\n                if (type !== null) {\n                    // Element Node\n                    if (node.serverProps === undefined) {\n                        // Just a reference node for context.\n                        selfContent = describeCollapsedElement(type, clientProps, indent);\n                        indent++;\n                    } else if (node.serverProps === null) {\n                        selfContent = describeExpandedElement(type, clientProps, added(indent)); // If this was an insertion we won't step down further. Any tail\n                    // are considered siblings so we don't indent.\n                    // TODO: Model this a little better.\n                    } else if (typeof node.serverProps === 'string') {\n                        {\n                            error('Should not have matched a non HostText fiber to a Text node. This is a bug in React.');\n                        }\n                    } else {\n                        selfContent = describeElementDiff(type, clientProps, node.serverProps, indent);\n                        indent++;\n                    }\n                }\n            } // Compute children\n            var childContent = '';\n            var childFiber = node.fiber.child;\n            var diffIdx = 0;\n            while(childFiber && diffIdx < node.children.length){\n                var childNode = node.children[diffIdx];\n                if (childNode.fiber === childFiber) {\n                    // This was a match in the diff.\n                    childContent += describeNode(childNode, indent);\n                    diffIdx++;\n                } else {\n                    // This is an unrelated previous sibling.\n                    childContent += describeSiblingFiber(childFiber, indent);\n                }\n                childFiber = childFiber.sibling;\n            }\n            if (childFiber && node.children.length > 0) {\n                // If we had any further siblings after the last mismatch, we can't be sure if it's\n                // actually a valid match since it might not have found a match. So we exclude next\n                // siblings to avoid confusion.\n                childContent += indentation(indent) + '...' + '\\n';\n            } // Deleted tail nodes\n            var serverTail = node.serverTail;\n            for(var _i = 0; _i < serverTail.length; _i++){\n                var tailNode = serverTail[_i];\n                if (typeof tailNode === 'string') {\n                    // Removed text node\n                    childContent += removed(indent) + describeTextNode(tailNode, maxRowLength - indent * 2) + '\\n';\n                } else {\n                    // Removed element\n                    childContent += describeExpandedElement(tailNode.type, tailNode.props, removed(indent));\n                }\n            }\n            return parentContent + selfContent + childContent;\n        }\n        function describeDiff(rootNode) {\n            try {\n                return '\\n\\n' + describeNode(rootNode, 0);\n            } catch (x) {\n                return '';\n            }\n        }\n        // This may have been an insertion or a hydration.\n        var hydrationParentFiber = null;\n        var nextHydratableInstance = null;\n        var isHydrating = false; // This flag allows for warning supression when we expect there to be mismatches\n        // due to earlier mismatches or a suspended fiber.\n        var didSuspendOrErrorDEV = false; // Hydration differences found that haven't yet been logged.\n        var hydrationDiffRootDEV = null; // Hydration errors that were thrown inside this boundary\n        var hydrationErrors = null;\n        var rootOrSingletonContext = false; // Builds a common ancestor tree from the root down for collecting diffs.\n        function buildHydrationDiffNode(fiber, distanceFromLeaf) {\n            if (fiber.return === null) {\n                // We're at the root.\n                if (hydrationDiffRootDEV === null) {\n                    hydrationDiffRootDEV = {\n                        fiber: fiber,\n                        children: [],\n                        serverProps: undefined,\n                        serverTail: [],\n                        distanceFromLeaf: distanceFromLeaf\n                    };\n                } else if (hydrationDiffRootDEV.fiber !== fiber) {\n                    throw new Error('Saw multiple hydration diff roots in a pass. This is a bug in React.');\n                } else if (hydrationDiffRootDEV.distanceFromLeaf > distanceFromLeaf) {\n                    hydrationDiffRootDEV.distanceFromLeaf = distanceFromLeaf;\n                }\n                return hydrationDiffRootDEV;\n            }\n            var siblings = buildHydrationDiffNode(fiber.return, distanceFromLeaf + 1).children; // The same node may already exist in the parent. Since we currently always render depth first\n            // and rerender if we suspend or terminate early, if a shared ancestor was added we should still\n            // be inside of that shared ancestor which means it was the last one to be added. If this changes\n            // we may have to scan the whole set.\n            if (siblings.length > 0 && siblings[siblings.length - 1].fiber === fiber) {\n                var existing = siblings[siblings.length - 1];\n                if (existing.distanceFromLeaf > distanceFromLeaf) {\n                    existing.distanceFromLeaf = distanceFromLeaf;\n                }\n                return existing;\n            }\n            var newNode = {\n                fiber: fiber,\n                children: [],\n                serverProps: undefined,\n                serverTail: [],\n                distanceFromLeaf: distanceFromLeaf\n            };\n            siblings.push(newNode);\n            return newNode;\n        }\n        function warnIfHydrating() {\n            {\n                if (isHydrating) {\n                    error('We should not be hydrating here. This is a bug in React. Please file a bug.');\n                }\n            }\n        }\n        function markDidThrowWhileHydratingDEV() {\n            {\n                didSuspendOrErrorDEV = true;\n            }\n        }\n        function enterHydrationState(fiber) {\n            if (!supportsHydration) {\n                return false;\n            }\n            var parentInstance = fiber.stateNode.containerInfo;\n            nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);\n            hydrationParentFiber = fiber;\n            isHydrating = true;\n            hydrationErrors = null;\n            didSuspendOrErrorDEV = false;\n            hydrationDiffRootDEV = null;\n            rootOrSingletonContext = true;\n            return true;\n        }\n        function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {\n            if (!supportsHydration) {\n                return false;\n            }\n            nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);\n            hydrationParentFiber = fiber;\n            isHydrating = true;\n            hydrationErrors = null;\n            didSuspendOrErrorDEV = false;\n            hydrationDiffRootDEV = null;\n            rootOrSingletonContext = false;\n            if (treeContext !== null) {\n                restoreSuspendedTreeContext(fiber, treeContext);\n            }\n            return true;\n        }\n        function warnNonHydratedInstance(fiber, rejectedCandidate) {\n            {\n                if (didSuspendOrErrorDEV) {\n                    // Inside a boundary that already suspended. We're currently rendering the\n                    // siblings of a suspended node. The mismatch may be due to the missing\n                    // data, so it's probably a false positive.\n                    return;\n                } // Add this fiber to the diff tree.\n                var diffNode = buildHydrationDiffNode(fiber, 0); // We use null as a signal that there was no node to match.\n                diffNode.serverProps = null;\n                if (rejectedCandidate !== null) {\n                    var description = describeHydratableInstanceForDevWarnings(rejectedCandidate);\n                    diffNode.serverTail.push(description);\n                }\n            }\n        }\n        function tryHydrateInstance(fiber, nextInstance, hostContext) {\n            // fiber is a HostComponent Fiber\n            var instance = canHydrateInstance(nextInstance, fiber.type, fiber.pendingProps, rootOrSingletonContext);\n            if (instance !== null) {\n                fiber.stateNode = instance;\n                {\n                    if (!didSuspendOrErrorDEV) {\n                        var differences = diffHydratedPropsForDevWarnings(instance, fiber.type, fiber.pendingProps, hostContext);\n                        if (differences !== null) {\n                            var diffNode = buildHydrationDiffNode(fiber, 0);\n                            diffNode.serverProps = differences;\n                        }\n                    }\n                }\n                hydrationParentFiber = fiber;\n                nextHydratableInstance = getFirstHydratableChild(instance);\n                rootOrSingletonContext = false;\n                return true;\n            }\n            return false;\n        }\n        function tryHydrateText(fiber, nextInstance) {\n            // fiber is a HostText Fiber\n            var text = fiber.pendingProps;\n            var textInstance = canHydrateTextInstance(nextInstance, text, rootOrSingletonContext);\n            if (textInstance !== null) {\n                fiber.stateNode = textInstance;\n                hydrationParentFiber = fiber; // Text Instances don't have children so there's nothing to hydrate.\n                nextHydratableInstance = null;\n                return true;\n            }\n            return false;\n        }\n        function tryHydrateSuspense(fiber, nextInstance) {\n            // fiber is a SuspenseComponent Fiber\n            var suspenseInstance = canHydrateSuspenseInstance(nextInstance, rootOrSingletonContext);\n            if (suspenseInstance !== null) {\n                var suspenseState = {\n                    dehydrated: suspenseInstance,\n                    treeContext: getSuspendedTreeContext(),\n                    retryLane: OffscreenLane\n                };\n                fiber.memoizedState = suspenseState; // Store the dehydrated fragment as a child fiber.\n                // This simplifies the code for getHostSibling and deleting nodes,\n                // since it doesn't have to consider all Suspense boundaries and\n                // check if they're dehydrated ones or not.\n                var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);\n                dehydratedFragment.return = fiber;\n                fiber.child = dehydratedFragment;\n                hydrationParentFiber = fiber; // While a Suspense Instance does have children, we won't step into\n                // it during the first pass. Instead, we'll reenter it later.\n                nextHydratableInstance = null;\n                return true;\n            }\n            return false;\n        }\n        var HydrationMismatchException = new Error('Hydration Mismatch Exception: This is not a real error, and should not leak into ' + \"userspace. If you're seeing this, it's likely a bug in React.\");\n        function throwOnHydrationMismatch(fiber) {\n            var diff = '';\n            {\n                // Consume the diff root for this mismatch.\n                // Any other errors will get their own diffs.\n                var diffRoot = hydrationDiffRootDEV;\n                if (diffRoot !== null) {\n                    hydrationDiffRootDEV = null;\n                    diff = describeDiff(diffRoot);\n                }\n            }\n            var error = new Error(\"Hydration failed because the server rendered HTML didn't match the client. As a result this tree will be regenerated on the client. This can happen if a SSR-ed Client Component used:\\n\" + '\\n' + \"- A server/client branch `if (typeof window !== 'undefined')`.\\n\" + \"- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\\n\" + \"- Date formatting in a user's locale which doesn't match the server.\\n\" + '- External changing data without sending a snapshot of it along with the HTML.\\n' + '- Invalid HTML tag nesting.\\n' + '\\n' + 'It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\\n' + '\\n' + 'https://react.dev/link/hydration-mismatch' + diff);\n            queueHydrationError(createCapturedValueAtFiber(error, fiber));\n            throw HydrationMismatchException;\n        }\n        function claimHydratableSingleton(fiber) {\n            if (supportsSingletons) {\n                if (!isHydrating) {\n                    return;\n                }\n                var currentRootContainer = getRootHostContainer();\n                var currentHostContext = getHostContext();\n                var instance = fiber.stateNode = resolveSingletonInstance(fiber.type, fiber.pendingProps, currentRootContainer, currentHostContext, false);\n                {\n                    if (!didSuspendOrErrorDEV) {\n                        var differences = diffHydratedPropsForDevWarnings(instance, fiber.type, fiber.pendingProps, currentHostContext);\n                        if (differences !== null) {\n                            var diffNode = buildHydrationDiffNode(fiber, 0);\n                            diffNode.serverProps = differences;\n                        }\n                    }\n                }\n                hydrationParentFiber = fiber;\n                rootOrSingletonContext = true;\n                nextHydratableInstance = getFirstHydratableChild(instance);\n            }\n        }\n        function tryToClaimNextHydratableInstance(fiber) {\n            if (!isHydrating) {\n                return;\n            } // Validate that this is ok to render here before any mismatches.\n            var currentHostContext = getHostContext();\n            var shouldKeepWarning = validateHydratableInstance(fiber.type, fiber.pendingProps, currentHostContext);\n            var nextInstance = nextHydratableInstance;\n            if (!nextInstance || !tryHydrateInstance(fiber, nextInstance, currentHostContext)) {\n                if (shouldKeepWarning) {\n                    warnNonHydratedInstance(fiber, nextInstance);\n                }\n                throwOnHydrationMismatch(fiber);\n            }\n        }\n        function tryToClaimNextHydratableTextInstance(fiber) {\n            if (!isHydrating) {\n                return;\n            }\n            var text = fiber.pendingProps;\n            var shouldKeepWarning = true; // Validate that this is ok to render here before any mismatches.\n            var currentHostContext = getHostContext();\n            shouldKeepWarning = validateHydratableTextInstance(text, currentHostContext);\n            var nextInstance = nextHydratableInstance;\n            if (!nextInstance || !tryHydrateText(fiber, nextInstance)) {\n                if (shouldKeepWarning) {\n                    warnNonHydratedInstance(fiber, nextInstance);\n                }\n                throwOnHydrationMismatch(fiber);\n            }\n        }\n        function tryToClaimNextHydratableSuspenseInstance(fiber) {\n            if (!isHydrating) {\n                return;\n            }\n            var nextInstance = nextHydratableInstance;\n            if (!nextInstance || !tryHydrateSuspense(fiber, nextInstance)) {\n                warnNonHydratedInstance(fiber, nextInstance);\n                throwOnHydrationMismatch(fiber);\n            }\n        }\n        function tryToClaimNextHydratableFormMarkerInstance(fiber) {\n            if (!isHydrating) {\n                return false;\n            }\n            if (nextHydratableInstance) {\n                var markerInstance = canHydrateFormStateMarker(nextHydratableInstance, rootOrSingletonContext);\n                if (markerInstance) {\n                    // Found the marker instance.\n                    nextHydratableInstance = getNextHydratableSibling(markerInstance); // Return true if this marker instance should use the state passed\n                    // to hydrateRoot.\n                    // TODO: As an optimization, Fizz should only emit these markers if form\n                    // state is passed at the root.\n                    return isFormStateMarkerMatching(markerInstance);\n                }\n            } // Should have found a marker instance. Throw an error to trigger client\n            // rendering. We don't bother to check if we're in a concurrent root because\n            // useActionState is a new API, so backwards compat is not an issue.\n            throwOnHydrationMismatch(fiber);\n            return false;\n        }\n        function prepareToHydrateHostInstance(fiber, hostContext) {\n            if (!supportsHydration) {\n                throw new Error('Expected prepareToHydrateHostInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n            }\n            var instance = fiber.stateNode;\n            var didHydrate = hydrateInstance(instance, fiber.type, fiber.memoizedProps, hostContext, fiber);\n            if (!didHydrate && favorSafetyOverHydrationPerf) {\n                throwOnHydrationMismatch(fiber);\n            }\n        }\n        function prepareToHydrateHostTextInstance(fiber) {\n            if (!supportsHydration) {\n                throw new Error('Expected prepareToHydrateHostTextInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n            }\n            var textInstance = fiber.stateNode;\n            var textContent = fiber.memoizedProps;\n            var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;\n            var parentProps = null; // We assume that prepareToHydrateHostTextInstance is called in a context where the\n            // hydration parent is the parent host component of this host text.\n            var returnFiber = hydrationParentFiber;\n            if (returnFiber !== null) {\n                switch(returnFiber.tag){\n                    case HostRoot:\n                        {\n                            {\n                                if (shouldWarnIfMismatchDev) {\n                                    var difference = diffHydratedTextForDevWarnings(textInstance, textContent, parentProps);\n                                    if (difference !== null) {\n                                        var diffNode = buildHydrationDiffNode(fiber, 0);\n                                        diffNode.serverProps = difference;\n                                    }\n                                }\n                            }\n                            break;\n                        }\n                    case HostSingleton:\n                    case HostComponent:\n                        {\n                            parentProps = returnFiber.memoizedProps;\n                            {\n                                if (shouldWarnIfMismatchDev) {\n                                    var _difference = diffHydratedTextForDevWarnings(textInstance, textContent, parentProps);\n                                    if (_difference !== null) {\n                                        var _diffNode = buildHydrationDiffNode(fiber, 0);\n                                        _diffNode.serverProps = _difference;\n                                    }\n                                }\n                            }\n                            break;\n                        }\n                } // TODO: What if it's a SuspenseInstance?\n            }\n            var didHydrate = hydrateTextInstance(textInstance, textContent, fiber, parentProps);\n            if (!didHydrate && favorSafetyOverHydrationPerf) {\n                throwOnHydrationMismatch(fiber);\n            }\n        }\n        function prepareToHydrateHostSuspenseInstance(fiber) {\n            if (!supportsHydration) {\n                throw new Error('Expected prepareToHydrateHostSuspenseInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n            }\n            var suspenseState = fiber.memoizedState;\n            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n            if (!suspenseInstance) {\n                throw new Error('Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n            }\n            hydrateSuspenseInstance(suspenseInstance, fiber);\n        }\n        function skipPastDehydratedSuspenseInstance(fiber) {\n            if (!supportsHydration) {\n                throw new Error('Expected skipPastDehydratedSuspenseInstance() to never be called. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n            }\n            var suspenseState = fiber.memoizedState;\n            var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;\n            if (!suspenseInstance) {\n                throw new Error('Expected to have a hydrated suspense instance. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n            }\n            return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);\n        }\n        function popToNextHostParent(fiber) {\n            hydrationParentFiber = fiber.return;\n            while(hydrationParentFiber){\n                switch(hydrationParentFiber.tag){\n                    case HostRoot:\n                    case HostSingleton:\n                        rootOrSingletonContext = true;\n                        return;\n                    case HostComponent:\n                    case SuspenseComponent:\n                        rootOrSingletonContext = false;\n                        return;\n                    default:\n                        hydrationParentFiber = hydrationParentFiber.return;\n                }\n            }\n        }\n        function popHydrationState(fiber) {\n            if (!supportsHydration) {\n                return false;\n            }\n            if (fiber !== hydrationParentFiber) {\n                // We're deeper than the current hydration context, inside an inserted\n                // tree.\n                return false;\n            }\n            if (!isHydrating) {\n                // If we're not currently hydrating but we're in a hydration context, then\n                // we were an insertion and now need to pop up reenter hydration of our\n                // siblings.\n                popToNextHostParent(fiber);\n                isHydrating = true;\n                return false;\n            }\n            var shouldClear = false;\n            if (supportsSingletons) {\n                // With float we never clear the Root, or Singleton instances. We also do not clear Instances\n                // that have singleton text content\n                if (fiber.tag !== HostRoot && fiber.tag !== HostSingleton && !(fiber.tag === HostComponent && (!shouldDeleteUnhydratedTailInstances(fiber.type) || shouldSetTextContent(fiber.type, fiber.memoizedProps)))) {\n                    shouldClear = true;\n                }\n            } else {\n                // If we have any remaining hydratable nodes, we need to delete them now.\n                // We only do this deeper than head and body since they tend to have random\n                // other nodes in them. We also ignore components with pure text content in\n                // side of them. We also don't delete anything inside the root container.\n                if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {\n                    shouldClear = true;\n                }\n            }\n            if (shouldClear) {\n                var nextInstance = nextHydratableInstance;\n                if (nextInstance) {\n                    warnIfUnhydratedTailNodes(fiber);\n                    throwOnHydrationMismatch(fiber);\n                }\n            }\n            popToNextHostParent(fiber);\n            if (fiber.tag === SuspenseComponent) {\n                nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);\n            } else {\n                nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;\n            }\n            return true;\n        }\n        function warnIfUnhydratedTailNodes(fiber) {\n            {\n                var nextInstance = nextHydratableInstance;\n                while(nextInstance){\n                    var diffNode = buildHydrationDiffNode(fiber, 0);\n                    var description = describeHydratableInstanceForDevWarnings(nextInstance);\n                    diffNode.serverTail.push(description);\n                    if (description.type === 'Suspense') {\n                        var suspenseInstance = nextInstance;\n                        nextInstance = getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);\n                    } else {\n                        nextInstance = getNextHydratableSibling(nextInstance);\n                    }\n                }\n            }\n        }\n        function resetHydrationState() {\n            if (!supportsHydration) {\n                return;\n            }\n            hydrationParentFiber = null;\n            nextHydratableInstance = null;\n            isHydrating = false;\n            didSuspendOrErrorDEV = false;\n        }\n        function upgradeHydrationErrorsToRecoverable() {\n            if (hydrationErrors !== null) {\n                // Successfully completed a forced client render. The errors that occurred\n                // during the hydration attempt are now recovered. We will log them in\n                // commit phase, once the entire tree has finished.\n                queueRecoverableErrors(hydrationErrors);\n                hydrationErrors = null;\n            }\n        }\n        function getIsHydrating() {\n            return isHydrating;\n        }\n        function queueHydrationError(error) {\n            if (hydrationErrors === null) {\n                hydrationErrors = [\n                    error\n                ];\n            } else {\n                hydrationErrors.push(error);\n            }\n        }\n        function emitPendingHydrationWarnings() {\n            {\n                // If we haven't yet thrown any hydration errors by the time we reach the end we've successfully\n                // hydrated, however, we might still have DEV-only mismatches that we log now.\n                var diffRoot = hydrationDiffRootDEV;\n                if (diffRoot !== null) {\n                    hydrationDiffRootDEV = null;\n                    var diff = describeDiff(diffRoot);\n                    error(\"A tree hydrated but some attributes of the server rendered HTML didn't match the client properties. This won't be patched up. \" + 'This can happen if a SSR-ed Client Component used:\\n' + '\\n' + \"- A server/client branch `if (typeof window !== 'undefined')`.\\n\" + \"- Variable input such as `Date.now()` or `Math.random()` which changes each time it's called.\\n\" + \"- Date formatting in a user's locale which doesn't match the server.\\n\" + '- External changing data without sending a snapshot of it along with the HTML.\\n' + '- Invalid HTML tag nesting.\\n' + '\\n' + 'It can also happen if the client has a browser extension installed which messes with the HTML before React loaded.\\n' + '\\n' + '%s%s', 'https://react.dev/link/hydration-mismatch', diff);\n                }\n            }\n        }\n        // we wait until the current render is over (either finished or interrupted)\n        // before adding it to the fiber/hook queue. Push to this array so we can\n        // access the queue, fiber, update, et al later.\n        var concurrentQueues = [];\n        var concurrentQueuesIndex = 0;\n        var concurrentlyUpdatedLanes = NoLanes;\n        function finishQueueingConcurrentUpdates() {\n            var endIndex = concurrentQueuesIndex;\n            concurrentQueuesIndex = 0;\n            concurrentlyUpdatedLanes = NoLanes;\n            var i = 0;\n            while(i < endIndex){\n                var fiber = concurrentQueues[i];\n                concurrentQueues[i++] = null;\n                var queue = concurrentQueues[i];\n                concurrentQueues[i++] = null;\n                var update = concurrentQueues[i];\n                concurrentQueues[i++] = null;\n                var lane = concurrentQueues[i];\n                concurrentQueues[i++] = null;\n                if (queue !== null && update !== null) {\n                    var pending = queue.pending;\n                    if (pending === null) {\n                        // This is the first update. Create a circular list.\n                        update.next = update;\n                    } else {\n                        update.next = pending.next;\n                        pending.next = update;\n                    }\n                    queue.pending = update;\n                }\n                if (lane !== NoLane) {\n                    markUpdateLaneFromFiberToRoot(fiber, update, lane);\n                }\n            }\n        }\n        function getConcurrentlyUpdatedLanes() {\n            return concurrentlyUpdatedLanes;\n        }\n        function enqueueUpdate$1(fiber, queue, update, lane) {\n            // Don't update the `childLanes` on the return path yet. If we already in\n            // the middle of rendering, wait until after it has completed.\n            concurrentQueues[concurrentQueuesIndex++] = fiber;\n            concurrentQueues[concurrentQueuesIndex++] = queue;\n            concurrentQueues[concurrentQueuesIndex++] = update;\n            concurrentQueues[concurrentQueuesIndex++] = lane;\n            concurrentlyUpdatedLanes = mergeLanes(concurrentlyUpdatedLanes, lane); // The fiber's `lane` field is used in some places to check if any work is\n            // scheduled, to perform an eager bailout, so we need to update it immediately.\n            // TODO: We should probably move this to the \"shared\" queue instead.\n            fiber.lanes = mergeLanes(fiber.lanes, lane);\n            var alternate = fiber.alternate;\n            if (alternate !== null) {\n                alternate.lanes = mergeLanes(alternate.lanes, lane);\n            }\n        }\n        function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {\n            var concurrentQueue = queue;\n            var concurrentUpdate = update;\n            enqueueUpdate$1(fiber, concurrentQueue, concurrentUpdate, lane);\n            return getRootForUpdatedFiber(fiber);\n        }\n        function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update) {\n            // This function is used to queue an update that doesn't need a rerender. The\n            // only reason we queue it is in case there's a subsequent higher priority\n            // update that causes it to be rebased.\n            var lane = NoLane;\n            var concurrentQueue = queue;\n            var concurrentUpdate = update;\n            enqueueUpdate$1(fiber, concurrentQueue, concurrentUpdate, lane); // Usually we can rely on the upcoming render phase to process the concurrent\n            // queue. However, since this is a bail out, we're not scheduling any work\n            // here. So the update we just queued will leak until something else happens\n            // to schedule work (if ever).\n            //\n            // Check if we're currently in the middle of rendering a tree, and if not,\n            // process the queue immediately to prevent a leak.\n            var isConcurrentlyRendering = getWorkInProgressRoot() !== null;\n            if (!isConcurrentlyRendering) {\n                finishQueueingConcurrentUpdates();\n            }\n        }\n        function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {\n            var concurrentQueue = queue;\n            var concurrentUpdate = update;\n            enqueueUpdate$1(fiber, concurrentQueue, concurrentUpdate, lane);\n            return getRootForUpdatedFiber(fiber);\n        }\n        function enqueueConcurrentRenderForLane(fiber, lane) {\n            enqueueUpdate$1(fiber, null, null, lane);\n            return getRootForUpdatedFiber(fiber);\n        } // Calling this function outside this module should only be done for backwards\n        // compatibility and should always be accompanied by a warning.\n        function unsafe_markUpdateLaneFromFiberToRoot(sourceFiber, lane) {\n            // NOTE: For Hyrum's Law reasons, if an infinite update loop is detected, it\n            // should throw before `markUpdateLaneFromFiberToRoot` is called. But this is\n            // undefined behavior and we can change it if we need to; it just so happens\n            // that, at the time of this writing, there's an internal product test that\n            // happens to rely on this.\n            var root = getRootForUpdatedFiber(sourceFiber);\n            markUpdateLaneFromFiberToRoot(sourceFiber, null, lane);\n            return root;\n        }\n        function markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {\n            // Update the source fiber's lanes\n            sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);\n            var alternate = sourceFiber.alternate;\n            if (alternate !== null) {\n                alternate.lanes = mergeLanes(alternate.lanes, lane);\n            } // Walk the parent path to the root and update the child lanes.\n            var isHidden = false;\n            var parent = sourceFiber.return;\n            var node = sourceFiber;\n            while(parent !== null){\n                parent.childLanes = mergeLanes(parent.childLanes, lane);\n                alternate = parent.alternate;\n                if (alternate !== null) {\n                    alternate.childLanes = mergeLanes(alternate.childLanes, lane);\n                }\n                if (parent.tag === OffscreenComponent) {\n                    // Check if this offscreen boundary is currently hidden.\n                    //\n                    // The instance may be null if the Offscreen parent was unmounted. Usually\n                    // the parent wouldn't be reachable in that case because we disconnect\n                    // fibers from the tree when they are deleted. However, there's a weird\n                    // edge case where setState is called on a fiber that was interrupted\n                    // before it ever mounted. Because it never mounts, it also never gets\n                    // deleted. Because it never gets deleted, its return pointer never gets\n                    // disconnected. Which means it may be attached to a deleted Offscreen\n                    // parent node. (This discovery suggests it may be better for memory usage\n                    // if we don't attach the `return` pointer until the commit phase, though\n                    // in order to do that we'd need some other way to track the return\n                    // pointer during the initial render, like on the stack.)\n                    //\n                    // This case is always accompanied by a warning, but we still need to\n                    // account for it. (There may be other cases that we haven't discovered,\n                    // too.)\n                    var offscreenInstance = parent.stateNode;\n                    if (offscreenInstance !== null && !(offscreenInstance._visibility & OffscreenVisible)) {\n                        isHidden = true;\n                    }\n                }\n                node = parent;\n                parent = parent.return;\n            }\n            if (isHidden && update !== null && node.tag === HostRoot) {\n                var root = node.stateNode;\n                markHiddenUpdate(root, update, lane);\n            }\n        }\n        function getRootForUpdatedFiber(sourceFiber) {\n            // TODO: We will detect and infinite update loop and throw even if this fiber\n            // has already unmounted. This isn't really necessary but it happens to be the\n            // current behavior we've used for several release cycles. Consider not\n            // performing this check if the updated fiber already unmounted, since it's\n            // not possible for that to cause an infinite update loop.\n            throwIfInfiniteUpdateLoopDetected(); // When a setState happens, we must ensure the root is scheduled. Because\n            // update queues do not have a backpointer to the root, the only way to do\n            // this currently is to walk up the return path. This used to not be a big\n            // deal because we would have to walk up the return path to set\n            // the `childLanes`, anyway, but now those two traversals happen at\n            // different times.\n            // TODO: Consider adding a `root` backpointer on the update queue.\n            detectUpdateOnUnmountedFiber(sourceFiber, sourceFiber);\n            var node = sourceFiber;\n            var parent = node.return;\n            while(parent !== null){\n                detectUpdateOnUnmountedFiber(sourceFiber, node);\n                node = parent;\n                parent = node.return;\n            }\n            return node.tag === HostRoot ? node.stateNode : null;\n        }\n        function detectUpdateOnUnmountedFiber(sourceFiber, parent) {\n            {\n                var alternate = parent.alternate;\n                if (alternate === null && (parent.flags & (Placement | Hydrating)) !== NoFlags$1) {\n                    warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);\n                }\n            }\n        }\n        // there's only a single root, but we do support multi root apps, hence this\n        // extra complexity. But this module is optimized for the single root case.\n        var firstScheduledRoot = null;\n        var lastScheduledRoot = null; // Used to prevent redundant mircotasks from being scheduled.\n        var didScheduleMicrotask = false; // `act` \"microtasks\" are scheduled on the `act` queue instead of an actual\n        // microtask, so we have to dedupe those separately. This wouldn't be an issue\n        // if we required all `act` calls to be awaited, which we might in the future.\n        var didScheduleMicrotask_act = false; // Used to quickly bail out of flushSync if there's no sync work to do.\n        var mightHavePendingSyncWork = false;\n        var isFlushingWork = false;\n        var currentEventTransitionLane = NoLane;\n        function ensureRootIsScheduled(root) {\n            // This function is called whenever a root receives an update. It does two\n            // things 1) it ensures the root is in the root schedule, and 2) it ensures\n            // there's a pending microtask to process the root schedule.\n            //\n            // Most of the actual scheduling logic does not happen until\n            // `scheduleTaskForRootDuringMicrotask` runs.\n            // Add the root to the schedule\n            if (root === lastScheduledRoot || root.next !== null) ;\n            else {\n                if (lastScheduledRoot === null) {\n                    firstScheduledRoot = lastScheduledRoot = root;\n                } else {\n                    lastScheduledRoot.next = root;\n                    lastScheduledRoot = root;\n                }\n            } // Any time a root received an update, we set this to true until the next time\n            // we process the schedule. If it's false, then we can quickly exit flushSync\n            // without consulting the schedule.\n            mightHavePendingSyncWork = true; // At the end of the current event, go through each of the roots and ensure\n            // there's a task scheduled for each one at the correct priority.\n            if (ReactSharedInternals.actQueue !== null) {\n                // We're inside an `act` scope.\n                if (!didScheduleMicrotask_act) {\n                    didScheduleMicrotask_act = true;\n                    scheduleImmediateTask(processRootScheduleInMicrotask);\n                }\n            } else {\n                if (!didScheduleMicrotask) {\n                    didScheduleMicrotask = true;\n                    scheduleImmediateTask(processRootScheduleInMicrotask);\n                }\n            }\n        }\n        function flushSyncWorkOnAllRoots() {\n            // This is allowed to be called synchronously, but the caller should check\n            // the execution context first.\n            flushSyncWorkAcrossRoots_impl(false);\n        }\n        function flushSyncWorkAcrossRoots_impl(onlyLegacy) {\n            if (isFlushingWork) {\n                // Prevent reentrancy.\n                // TODO: Is this overly defensive? The callers must check the execution\n                // context first regardless.\n                return;\n            }\n            if (!mightHavePendingSyncWork) {\n                // Fast path. There's no sync work to do.\n                return;\n            } // There may or may not be synchronous work scheduled. Let's check.\n            var didPerformSomeWork;\n            isFlushingWork = true;\n            do {\n                didPerformSomeWork = false;\n                var root = firstScheduledRoot;\n                while(root !== null){\n                    if (onlyLegacy && disableLegacyMode) ;\n                    else {\n                        var workInProgressRoot = getWorkInProgressRoot();\n                        var workInProgressRootRenderLanes = getWorkInProgressRootRenderLanes();\n                        var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n                        if (includesSyncLane(nextLanes)) {\n                            // This root has pending sync work. Flush it now.\n                            didPerformSomeWork = true;\n                            performSyncWorkOnRoot(root, nextLanes);\n                        }\n                    }\n                    root = root.next;\n                }\n            }while (didPerformSomeWork);\n            isFlushingWork = false;\n        }\n        function processRootScheduleInMicrotask() {\n            // This function is always called inside a microtask. It should never be\n            // called synchronously.\n            didScheduleMicrotask = false;\n            {\n                didScheduleMicrotask_act = false;\n            }\n            mightHavePendingSyncWork = false;\n            var currentTime = now$1();\n            var prev = null;\n            var root = firstScheduledRoot;\n            while(root !== null){\n                var next = root.next;\n                if (currentEventTransitionLane !== NoLane && shouldAttemptEagerTransition()) {\n                    // A transition was scheduled during an event, but we're going to try to\n                    // render it synchronously anyway. We do this during a popstate event to\n                    // preserve the scroll position of the previous page.\n                    upgradePendingLaneToSync(root, currentEventTransitionLane);\n                }\n                var nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);\n                if (nextLanes === NoLane) {\n                    // This root has no more pending work. Remove it from the schedule. To\n                    // guard against subtle reentrancy bugs, this microtask is the only place\n                    // we do this — you can add roots to the schedule whenever, but you can\n                    // only remove them here.\n                    // Null this out so we know it's been removed from the schedule.\n                    root.next = null;\n                    if (prev === null) {\n                        // This is the new head of the list\n                        firstScheduledRoot = next;\n                    } else {\n                        prev.next = next;\n                    }\n                    if (next === null) {\n                        // This is the new tail of the list\n                        lastScheduledRoot = prev;\n                    }\n                } else {\n                    // This root still has work. Keep it in the list.\n                    prev = root;\n                    if (includesSyncLane(nextLanes)) {\n                        mightHavePendingSyncWork = true;\n                    }\n                }\n                root = next;\n            }\n            currentEventTransitionLane = NoLane; // At the end of the microtask, flush any pending synchronous work. This has\n            // to come at the end, because it does actual rendering work that might throw.\n            flushSyncWorkOnAllRoots();\n        }\n        function scheduleTaskForRootDuringMicrotask(root, currentTime) {\n            // This function is always called inside a microtask, or at the very end of a\n            // rendering task right before we yield to the main thread. It should never be\n            // called synchronously.\n            //\n            // TODO: Unless enableDeferRootSchedulingToMicrotask is off. We need to land\n            // that ASAP to unblock additional features we have planned.\n            //\n            // This function also never performs React work synchronously; it should\n            // only schedule work to be performed later, in a separate task or microtask.\n            // Check if any lanes are being starved by other work. If so, mark them as\n            // expired so we know to work on those next.\n            markStarvedLanesAsExpired(root, currentTime); // Determine the next lanes to work on, and their priority.\n            var workInProgressRoot = getWorkInProgressRoot();\n            var workInProgressRootRenderLanes = getWorkInProgressRootRenderLanes();\n            var nextLanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n            var existingCallbackNode = root.callbackNode;\n            if (nextLanes === NoLanes || // If this root is currently suspended and waiting for data to resolve, don't\n            // schedule a task to render it. We'll either wait for a ping, or wait to\n            // receive an update.\n            //\n            // Suspended render phase\n            root === workInProgressRoot && isWorkLoopSuspendedOnData() || // Suspended commit phase\n            root.cancelPendingCommit !== null) {\n                // Fast path: There's nothing to work on.\n                if (existingCallbackNode !== null) {\n                    cancelCallback(existingCallbackNode);\n                }\n                root.callbackNode = null;\n                root.callbackPriority = NoLane;\n                return NoLane;\n            } // Schedule a new callback in the host environment.\n            if (includesSyncLane(nextLanes)) {\n                // Synchronous work is always flushed at the end of the microtask, so we\n                // don't need to schedule an additional task.\n                if (existingCallbackNode !== null) {\n                    cancelCallback(existingCallbackNode);\n                }\n                root.callbackPriority = SyncLane;\n                root.callbackNode = null;\n                return SyncLane;\n            } else {\n                // We use the highest priority lane to represent the priority of the callback.\n                var existingCallbackPriority = root.callbackPriority;\n                var newCallbackPriority = getHighestPriorityLane(nextLanes);\n                if (newCallbackPriority === existingCallbackPriority && // Special case related to `act`. If the currently scheduled task is a\n                // Scheduler task, rather than an `act` task, cancel it and re-schedule\n                // on the `act` queue.\n                !(ReactSharedInternals.actQueue !== null && existingCallbackNode !== fakeActCallbackNode$1)) {\n                    // The priority hasn't changed. We can reuse the existing task.\n                    return newCallbackPriority;\n                } else {\n                    // Cancel the existing callback. We'll schedule a new one below.\n                    cancelCallback(existingCallbackNode);\n                }\n                var schedulerPriorityLevel;\n                switch(lanesToEventPriority(nextLanes)){\n                    case DiscreteEventPriority:\n                        schedulerPriorityLevel = ImmediatePriority;\n                        break;\n                    case ContinuousEventPriority:\n                        schedulerPriorityLevel = UserBlockingPriority;\n                        break;\n                    case DefaultEventPriority:\n                        schedulerPriorityLevel = NormalPriority$1;\n                        break;\n                    case IdleEventPriority:\n                        schedulerPriorityLevel = IdlePriority;\n                        break;\n                    default:\n                        schedulerPriorityLevel = NormalPriority$1;\n                        break;\n                }\n                var newCallbackNode = scheduleCallback$2(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root));\n                root.callbackPriority = newCallbackPriority;\n                root.callbackNode = newCallbackNode;\n                return newCallbackPriority;\n            }\n        }\n        function getContinuationForRoot(root, originalCallbackNode) {\n            // This is called at the end of `performConcurrentWorkOnRoot` to determine\n            // if we need to schedule a continuation task.\n            //\n            // Usually `scheduleTaskForRootDuringMicrotask` only runs inside a microtask;\n            // however, since most of the logic for determining if we need a continuation\n            // versus a new task is the same, we cheat a bit and call it here. This is\n            // only safe to do because we know we're at the end of the browser task.\n            // So although it's not an actual microtask, it might as well be.\n            scheduleTaskForRootDuringMicrotask(root, now$1());\n            if (root.callbackNode === originalCallbackNode) {\n                // The task node scheduled for this root is the same one that's\n                // currently executed. Need to return a continuation.\n                return performConcurrentWorkOnRoot.bind(null, root);\n            }\n            return null;\n        }\n        var fakeActCallbackNode$1 = {};\n        function scheduleCallback$2(priorityLevel, callback) {\n            if (ReactSharedInternals.actQueue !== null) {\n                // Special case: We're inside an `act` scope (a testing utility).\n                // Instead of scheduling work in the host environment, add it to a\n                // fake internal queue that's managed by the `act` implementation.\n                ReactSharedInternals.actQueue.push(callback);\n                return fakeActCallbackNode$1;\n            } else {\n                return scheduleCallback$3(priorityLevel, callback);\n            }\n        }\n        function cancelCallback(callbackNode) {\n            if (callbackNode === fakeActCallbackNode$1) ;\n            else if (callbackNode !== null) {\n                cancelCallback$1(callbackNode);\n            }\n        }\n        function scheduleImmediateTask(cb) {\n            if (ReactSharedInternals.actQueue !== null) {\n                // Special case: Inside an `act` scope, we push microtasks to the fake `act`\n                // callback queue. This is because we currently support calling `act`\n                // without awaiting the result. The plan is to deprecate that, and require\n                // that you always await the result so that the microtasks have a chance to\n                // run. But it hasn't happened yet.\n                ReactSharedInternals.actQueue.push(function() {\n                    cb();\n                    return null;\n                });\n            } // TODO: Can we land supportsMicrotasks? Which environments don't support it?\n            // Alternatively, can we move this check to the host config?\n            if (supportsMicrotasks) {\n                scheduleMicrotask(function() {\n                    // In Safari, appending an iframe forces microtasks to run.\n                    // https://github.com/facebook/react/issues/22459\n                    // We don't support running callbacks in the middle of render\n                    // or commit so we need to check against that.\n                    var executionContext = getExecutionContext();\n                    if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                        // Note that this would still prematurely flush the callbacks\n                        // if this happens outside render or commit phase (e.g. in an event).\n                        // Intentionally using a macrotask instead of a microtask here. This is\n                        // wrong semantically but it prevents an infinite loop. The bug is\n                        // Safari's, not ours, so we just do our best to not crash even though\n                        // the behavior isn't completely correct.\n                        scheduleCallback$3(ImmediatePriority, cb);\n                        return;\n                    }\n                    cb();\n                });\n            } else {\n                // If microtasks are not supported, use Scheduler.\n                scheduleCallback$3(ImmediatePriority, cb);\n            }\n        }\n        function requestTransitionLane(// check that it's inside a transition before calling this function.\n        // TODO: Make this non-nullable. Requires a tweak to useOptimistic.\n        transition) {\n            // The algorithm for assigning an update to a lane should be stable for all\n            // updates at the same priority within the same event. To do this, the\n            // inputs to the algorithm must be the same.\n            //\n            // The trick we use is to cache the first of each of these inputs within an\n            // event. Then reset the cached values once we can be sure the event is\n            // over. Our heuristic for that is whenever we enter a concurrent work loop.\n            if (currentEventTransitionLane === NoLane) {\n                // All transitions within the same event are assigned the same lane.\n                currentEventTransitionLane = claimNextTransitionLane();\n            }\n            return currentEventTransitionLane;\n        }\n        // transition updates that occur while the async action is still in progress\n        // are treated as part of the action.\n        //\n        // The ideal behavior would be to treat each async function as an independent\n        // action. However, without a mechanism like AsyncContext, we can't tell which\n        // action an update corresponds to. So instead, we entangle them all into one.\n        // The listeners to notify once the entangled scope completes.\n        var currentEntangledListeners = null; // The number of pending async actions in the entangled scope.\n        var currentEntangledPendingCount = 0; // The transition lane shared by all updates in the entangled scope.\n        var currentEntangledLane = NoLane; // A thenable that resolves when the entangled scope completes. It does not\n        // resolve to a particular value because it's only used for suspending the UI\n        // until the async action scope has completed.\n        var currentEntangledActionThenable = null;\n        function entangleAsyncAction(transition, thenable) {\n            // `thenable` is the return value of the async action scope function. Create\n            // a combined thenable that resolves once every entangled scope function\n            // has finished.\n            if (currentEntangledListeners === null) {\n                // There's no outer async action scope. Create a new one.\n                var entangledListeners = currentEntangledListeners = [];\n                currentEntangledPendingCount = 0;\n                currentEntangledLane = requestTransitionLane();\n                var entangledThenable = {\n                    status: 'pending',\n                    value: undefined,\n                    then: function(resolve) {\n                        entangledListeners.push(resolve);\n                    }\n                };\n                currentEntangledActionThenable = entangledThenable;\n            }\n            currentEntangledPendingCount++;\n            thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);\n            return thenable;\n        }\n        function pingEngtangledActionScope() {\n            if (currentEntangledListeners !== null && --currentEntangledPendingCount === 0) {\n                // All the actions have finished. Close the entangled async action scope\n                // and notify all the listeners.\n                if (currentEntangledActionThenable !== null) {\n                    var fulfilledThenable = currentEntangledActionThenable;\n                    fulfilledThenable.status = 'fulfilled';\n                }\n                var listeners = currentEntangledListeners;\n                currentEntangledListeners = null;\n                currentEntangledLane = NoLane;\n                currentEntangledActionThenable = null;\n                for(var i = 0; i < listeners.length; i++){\n                    var listener = listeners[i];\n                    listener();\n                }\n            }\n        }\n        function chainThenableValue(thenable, result) {\n            // Equivalent to: Promise.resolve(thenable).then(() => result), except we can\n            // cheat a bit since we know that that this thenable is only ever consumed\n            // by React.\n            //\n            // We don't technically require promise support on the client yet, hence this\n            // extra code.\n            var listeners = [];\n            var thenableWithOverride = {\n                status: 'pending',\n                value: null,\n                reason: null,\n                then: function(resolve) {\n                    listeners.push(resolve);\n                }\n            };\n            thenable.then(function(value) {\n                var fulfilledThenable = thenableWithOverride;\n                fulfilledThenable.status = 'fulfilled';\n                fulfilledThenable.value = result;\n                for(var i = 0; i < listeners.length; i++){\n                    var listener = listeners[i];\n                    listener(result);\n                }\n            }, function(error) {\n                var rejectedThenable = thenableWithOverride;\n                rejectedThenable.status = 'rejected';\n                rejectedThenable.reason = error;\n                for(var i = 0; i < listeners.length; i++){\n                    var listener = listeners[i]; // This is a perf hack where we call the `onFulfill` ping function\n                    // instead of `onReject`, because we know that React is the only\n                    // consumer of these promises, and it passes the same listener to both.\n                    // We also know that it will read the error directly off the\n                    // `.reason` field.\n                    listener(undefined);\n                }\n            });\n            return thenableWithOverride;\n        }\n        function peekEntangledActionLane() {\n            return currentEntangledLane;\n        }\n        function peekEntangledActionThenable() {\n            return currentEntangledActionThenable;\n        }\n        var UpdateState = 0;\n        var ReplaceState = 1;\n        var ForceUpdate = 2;\n        var CaptureUpdate = 3; // Global state that is reset at the beginning of calling `processUpdateQueue`.\n        // It should only be read right after calling `processUpdateQueue`, via\n        // `checkHasForceUpdateAfterProcessing`.\n        var hasForceUpdate = false;\n        var didWarnUpdateInsideUpdate;\n        var currentlyProcessingQueue;\n        {\n            didWarnUpdateInsideUpdate = false;\n            currentlyProcessingQueue = null;\n        }\n        function initializeUpdateQueue(fiber) {\n            var queue = {\n                baseState: fiber.memoizedState,\n                firstBaseUpdate: null,\n                lastBaseUpdate: null,\n                shared: {\n                    pending: null,\n                    lanes: NoLanes,\n                    hiddenCallbacks: null\n                },\n                callbacks: null\n            };\n            fiber.updateQueue = queue;\n        }\n        function cloneUpdateQueue(current, workInProgress) {\n            // Clone the update queue from current. Unless it's already a clone.\n            var queue = workInProgress.updateQueue;\n            var currentQueue = current.updateQueue;\n            if (queue === currentQueue) {\n                var clone = {\n                    baseState: currentQueue.baseState,\n                    firstBaseUpdate: currentQueue.firstBaseUpdate,\n                    lastBaseUpdate: currentQueue.lastBaseUpdate,\n                    shared: currentQueue.shared,\n                    callbacks: null\n                };\n                workInProgress.updateQueue = clone;\n            }\n        }\n        function createUpdate(lane) {\n            var update = {\n                lane: lane,\n                tag: UpdateState,\n                payload: null,\n                callback: null,\n                next: null\n            };\n            return update;\n        }\n        function enqueueUpdate(fiber, update, lane) {\n            var updateQueue = fiber.updateQueue;\n            if (updateQueue === null) {\n                // Only occurs if the fiber has been unmounted.\n                return null;\n            }\n            var sharedQueue = updateQueue.shared;\n            {\n                if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {\n                    var componentName = getComponentNameFromFiber(fiber);\n                    error('An update (setState, replaceState, or forceUpdate) was scheduled ' + 'from inside an update function. Update functions should be pure, ' + 'with zero side-effects. Consider using componentDidUpdate or a ' + 'callback.\\n\\nPlease update the following component: %s', componentName);\n                    didWarnUpdateInsideUpdate = true;\n                }\n            }\n            if (isUnsafeClassRenderPhaseUpdate()) {\n                // This is an unsafe render phase update. Add directly to the update\n                // queue so we can process it immediately during the current render.\n                var pending = sharedQueue.pending;\n                if (pending === null) {\n                    // This is the first update. Create a circular list.\n                    update.next = update;\n                } else {\n                    update.next = pending.next;\n                    pending.next = update;\n                }\n                sharedQueue.pending = update; // Update the childLanes even though we're most likely already rendering\n                // this fiber. This is for backwards compatibility in the case where you\n                // update a different component during render phase than the one that is\n                // currently renderings (a pattern that is accompanied by a warning).\n                return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);\n            } else {\n                return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);\n            }\n        }\n        function entangleTransitions(root, fiber, lane) {\n            var updateQueue = fiber.updateQueue;\n            if (updateQueue === null) {\n                // Only occurs if the fiber has been unmounted.\n                return;\n            }\n            var sharedQueue = updateQueue.shared;\n            if (isTransitionLane(lane)) {\n                var queueLanes = sharedQueue.lanes; // If any entangled lanes are no longer pending on the root, then they must\n                // have finished. We can remove them from the shared queue, which represents\n                // a superset of the actually pending lanes. In some cases we may entangle\n                // more than we need to, but that's OK. In fact it's worse if we *don't*\n                // entangle when we should.\n                queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.\n                var newQueueLanes = mergeLanes(queueLanes, lane);\n                sharedQueue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if\n                // the lane finished since the last time we entangled it. So we need to\n                // entangle it again, just to be sure.\n                markRootEntangled(root, newQueueLanes);\n            }\n        }\n        function enqueueCapturedUpdate(workInProgress, capturedUpdate) {\n            // Captured updates are updates that are thrown by a child during the render\n            // phase. They should be discarded if the render is aborted. Therefore,\n            // we should only put them on the work-in-progress queue, not the current one.\n            var queue = workInProgress.updateQueue; // Check if the work-in-progress queue is a clone.\n            var current = workInProgress.alternate;\n            if (current !== null) {\n                var currentQueue = current.updateQueue;\n                if (queue === currentQueue) {\n                    // The work-in-progress queue is the same as current. This happens when\n                    // we bail out on a parent fiber that then captures an error thrown by\n                    // a child. Since we want to append the update only to the work-in\n                    // -progress queue, we need to clone the updates. We usually clone during\n                    // processUpdateQueue, but that didn't happen in this case because we\n                    // skipped over the parent when we bailed out.\n                    var newFirst = null;\n                    var newLast = null;\n                    var firstBaseUpdate = queue.firstBaseUpdate;\n                    if (firstBaseUpdate !== null) {\n                        // Loop through the updates and clone them.\n                        var update = firstBaseUpdate;\n                        do {\n                            var clone = {\n                                lane: update.lane,\n                                tag: update.tag,\n                                payload: update.payload,\n                                // When this update is rebased, we should not fire its\n                                // callback again.\n                                callback: null,\n                                next: null\n                            };\n                            if (newLast === null) {\n                                newFirst = newLast = clone;\n                            } else {\n                                newLast.next = clone;\n                                newLast = clone;\n                            } // $FlowFixMe[incompatible-type] we bail out when we get a null\n                            update = update.next;\n                        }while (update !== null); // Append the captured update the end of the cloned list.\n                        if (newLast === null) {\n                            newFirst = newLast = capturedUpdate;\n                        } else {\n                            newLast.next = capturedUpdate;\n                            newLast = capturedUpdate;\n                        }\n                    } else {\n                        // There are no base updates.\n                        newFirst = newLast = capturedUpdate;\n                    }\n                    queue = {\n                        baseState: currentQueue.baseState,\n                        firstBaseUpdate: newFirst,\n                        lastBaseUpdate: newLast,\n                        shared: currentQueue.shared,\n                        callbacks: currentQueue.callbacks\n                    };\n                    workInProgress.updateQueue = queue;\n                    return;\n                }\n            } // Append the update to the end of the list.\n            var lastBaseUpdate = queue.lastBaseUpdate;\n            if (lastBaseUpdate === null) {\n                queue.firstBaseUpdate = capturedUpdate;\n            } else {\n                lastBaseUpdate.next = capturedUpdate;\n            }\n            queue.lastBaseUpdate = capturedUpdate;\n        }\n        function getStateFromUpdate(workInProgress, queue, update, prevState, nextProps, instance) {\n            switch(update.tag){\n                case ReplaceState:\n                    {\n                        var payload = update.payload;\n                        if (typeof payload === 'function') {\n                            // Updater function\n                            {\n                                enterDisallowedContextReadInDEV();\n                            }\n                            var nextState = payload.call(instance, prevState, nextProps);\n                            {\n                                if (workInProgress.mode & StrictLegacyMode) {\n                                    setIsStrictModeForDevtools(true);\n                                    try {\n                                        payload.call(instance, prevState, nextProps);\n                                    } finally{\n                                        setIsStrictModeForDevtools(false);\n                                    }\n                                }\n                                exitDisallowedContextReadInDEV();\n                            }\n                            return nextState;\n                        } // State object\n                        return payload;\n                    }\n                case CaptureUpdate:\n                    {\n                        workInProgress.flags = workInProgress.flags & ~ShouldCapture | DidCapture;\n                    }\n                // Intentional fallthrough\n                case UpdateState:\n                    {\n                        var _payload = update.payload;\n                        var partialState;\n                        if (typeof _payload === 'function') {\n                            // Updater function\n                            {\n                                enterDisallowedContextReadInDEV();\n                            }\n                            partialState = _payload.call(instance, prevState, nextProps);\n                            {\n                                if (workInProgress.mode & StrictLegacyMode) {\n                                    setIsStrictModeForDevtools(true);\n                                    try {\n                                        _payload.call(instance, prevState, nextProps);\n                                    } finally{\n                                        setIsStrictModeForDevtools(false);\n                                    }\n                                }\n                                exitDisallowedContextReadInDEV();\n                            }\n                        } else {\n                            // Partial state object\n                            partialState = _payload;\n                        }\n                        if (partialState === null || partialState === undefined) {\n                            // Null and undefined are treated as no-ops.\n                            return prevState;\n                        } // Merge the partial state and the previous state.\n                        return assign({}, prevState, partialState);\n                    }\n                case ForceUpdate:\n                    {\n                        hasForceUpdate = true;\n                        return prevState;\n                    }\n            }\n            return prevState;\n        }\n        var didReadFromEntangledAsyncAction = false; // Each call to processUpdateQueue should be accompanied by a call to this. It's\n        // only in a separate function because in updateHostRoot, it must happen after\n        // all the context stacks have been pushed to, to prevent a stack mismatch. A\n        // bit unfortunate.\n        function suspendIfUpdateReadFromEntangledAsyncAction() {\n            // Check if this update is part of a pending async action. If so, we'll\n            // need to suspend until the action has finished, so that it's batched\n            // together with future updates in the same action.\n            // TODO: Once we support hooks inside useMemo (or an equivalent\n            // memoization boundary like Forget), hoist this logic so that it only\n            // suspends if the memo boundary produces a new value.\n            if (didReadFromEntangledAsyncAction) {\n                var entangledActionThenable = peekEntangledActionThenable();\n                if (entangledActionThenable !== null) {\n                    // TODO: Instead of the throwing the thenable directly, throw a\n                    // special object like `use` does so we can detect if it's captured\n                    // by userspace.\n                    throw entangledActionThenable;\n                }\n            }\n        }\n        function processUpdateQueue(workInProgress, props, instance, renderLanes) {\n            didReadFromEntangledAsyncAction = false; // This is always non-null on a ClassComponent or HostRoot\n            var queue = workInProgress.updateQueue;\n            hasForceUpdate = false;\n            {\n                currentlyProcessingQueue = queue.shared;\n            }\n            var firstBaseUpdate = queue.firstBaseUpdate;\n            var lastBaseUpdate = queue.lastBaseUpdate; // Check if there are pending updates. If so, transfer them to the base queue.\n            var pendingQueue = queue.shared.pending;\n            if (pendingQueue !== null) {\n                queue.shared.pending = null; // The pending queue is circular. Disconnect the pointer between first\n                // and last so that it's non-circular.\n                var lastPendingUpdate = pendingQueue;\n                var firstPendingUpdate = lastPendingUpdate.next;\n                lastPendingUpdate.next = null; // Append pending updates to base queue\n                if (lastBaseUpdate === null) {\n                    firstBaseUpdate = firstPendingUpdate;\n                } else {\n                    lastBaseUpdate.next = firstPendingUpdate;\n                }\n                lastBaseUpdate = lastPendingUpdate; // If there's a current queue, and it's different from the base queue, then\n                // we need to transfer the updates to that queue, too. Because the base\n                // queue is a singly-linked list with no cycles, we can append to both\n                // lists and take advantage of structural sharing.\n                // TODO: Pass `current` as argument\n                var current = workInProgress.alternate;\n                if (current !== null) {\n                    // This is always non-null on a ClassComponent or HostRoot\n                    var currentQueue = current.updateQueue;\n                    var currentLastBaseUpdate = currentQueue.lastBaseUpdate;\n                    if (currentLastBaseUpdate !== lastBaseUpdate) {\n                        if (currentLastBaseUpdate === null) {\n                            currentQueue.firstBaseUpdate = firstPendingUpdate;\n                        } else {\n                            currentLastBaseUpdate.next = firstPendingUpdate;\n                        }\n                        currentQueue.lastBaseUpdate = lastPendingUpdate;\n                    }\n                }\n            } // These values may change as we process the queue.\n            if (firstBaseUpdate !== null) {\n                // Iterate through the list of updates to compute the result.\n                var newState = queue.baseState; // TODO: Don't need to accumulate this. Instead, we can remove renderLanes\n                // from the original lanes.\n                var newLanes = NoLanes;\n                var newBaseState = null;\n                var newFirstBaseUpdate = null;\n                var newLastBaseUpdate = null;\n                var update = firstBaseUpdate;\n                do {\n                    // An extra OffscreenLane bit is added to updates that were made to\n                    // a hidden tree, so that we can distinguish them from updates that were\n                    // already there when the tree was hidden.\n                    var updateLane = removeLanes(update.lane, OffscreenLane);\n                    var isHiddenUpdate = updateLane !== update.lane; // Check if this update was made while the tree was hidden. If so, then\n                    // it's not a \"base\" update and we should disregard the extra base lanes\n                    // that were added to renderLanes when we entered the Offscreen tree.\n                    var shouldSkipUpdate = isHiddenUpdate ? !isSubsetOfLanes(getWorkInProgressRootRenderLanes(), updateLane) : !isSubsetOfLanes(renderLanes, updateLane);\n                    if (shouldSkipUpdate) {\n                        // Priority is insufficient. Skip this update. If this is the first\n                        // skipped update, the previous update/state is the new base\n                        // update/state.\n                        var clone = {\n                            lane: updateLane,\n                            tag: update.tag,\n                            payload: update.payload,\n                            callback: update.callback,\n                            next: null\n                        };\n                        if (newLastBaseUpdate === null) {\n                            newFirstBaseUpdate = newLastBaseUpdate = clone;\n                            newBaseState = newState;\n                        } else {\n                            newLastBaseUpdate = newLastBaseUpdate.next = clone;\n                        } // Update the remaining priority in the queue.\n                        newLanes = mergeLanes(newLanes, updateLane);\n                    } else {\n                        // This update does have sufficient priority.\n                        // Check if this update is part of a pending async action. If so,\n                        // we'll need to suspend until the action has finished, so that it's\n                        // batched together with future updates in the same action.\n                        if (updateLane !== NoLane && updateLane === peekEntangledActionLane()) {\n                            didReadFromEntangledAsyncAction = true;\n                        }\n                        if (newLastBaseUpdate !== null) {\n                            var _clone = {\n                                // This update is going to be committed so we never want uncommit\n                                // it. Using NoLane works because 0 is a subset of all bitmasks, so\n                                // this will never be skipped by the check above.\n                                lane: NoLane,\n                                tag: update.tag,\n                                payload: update.payload,\n                                // When this update is rebased, we should not fire its\n                                // callback again.\n                                callback: null,\n                                next: null\n                            };\n                            newLastBaseUpdate = newLastBaseUpdate.next = _clone;\n                        } // Process this update.\n                        newState = getStateFromUpdate(workInProgress, queue, update, newState, props, instance);\n                        var callback = update.callback;\n                        if (callback !== null) {\n                            workInProgress.flags |= Callback;\n                            if (isHiddenUpdate) {\n                                workInProgress.flags |= Visibility;\n                            }\n                            var callbacks = queue.callbacks;\n                            if (callbacks === null) {\n                                queue.callbacks = [\n                                    callback\n                                ];\n                            } else {\n                                callbacks.push(callback);\n                            }\n                        }\n                    } // $FlowFixMe[incompatible-type] we bail out when we get a null\n                    update = update.next;\n                    if (update === null) {\n                        pendingQueue = queue.shared.pending;\n                        if (pendingQueue === null) {\n                            break;\n                        } else {\n                            // An update was scheduled from inside a reducer. Add the new\n                            // pending updates to the end of the list and keep processing.\n                            var _lastPendingUpdate = pendingQueue; // Intentionally unsound. Pending updates form a circular list, but we\n                            // unravel them when transferring them to the base queue.\n                            var _firstPendingUpdate = _lastPendingUpdate.next;\n                            _lastPendingUpdate.next = null;\n                            update = _firstPendingUpdate;\n                            queue.lastBaseUpdate = _lastPendingUpdate;\n                            queue.shared.pending = null;\n                        }\n                    }\n                }while (true);\n                if (newLastBaseUpdate === null) {\n                    newBaseState = newState;\n                }\n                queue.baseState = newBaseState;\n                queue.firstBaseUpdate = newFirstBaseUpdate;\n                queue.lastBaseUpdate = newLastBaseUpdate;\n                if (firstBaseUpdate === null) {\n                    // `queue.lanes` is used for entangling transitions. We can set it back to\n                    // zero once the queue is empty.\n                    queue.shared.lanes = NoLanes;\n                } // Set the remaining expiration time to be whatever is remaining in the queue.\n                // This should be fine because the only two other things that contribute to\n                // expiration time are props and context. We're already in the middle of the\n                // begin phase by the time we start processing the queue, so we've already\n                // dealt with the props. Context in components that specify\n                // shouldComponentUpdate is tricky; but we'll have to account for\n                // that regardless.\n                markSkippedUpdateLanes(newLanes);\n                workInProgress.lanes = newLanes;\n                workInProgress.memoizedState = newState;\n            }\n            {\n                currentlyProcessingQueue = null;\n            }\n        }\n        function callCallback(callback, context) {\n            if (typeof callback !== 'function') {\n                throw new Error('Invalid argument passed as callback. Expected a function. Instead ' + (\"received: \" + callback));\n            }\n            callback.call(context);\n        }\n        function resetHasForceUpdateBeforeProcessing() {\n            hasForceUpdate = false;\n        }\n        function checkHasForceUpdateAfterProcessing() {\n            return hasForceUpdate;\n        }\n        function deferHiddenCallbacks(updateQueue) {\n            // When an update finishes on a hidden component, its callback should not\n            // be fired until/unless the component is made visible again. Stash the\n            // callback on the shared queue object so it can be fired later.\n            var newHiddenCallbacks = updateQueue.callbacks;\n            if (newHiddenCallbacks !== null) {\n                var existingHiddenCallbacks = updateQueue.shared.hiddenCallbacks;\n                if (existingHiddenCallbacks === null) {\n                    updateQueue.shared.hiddenCallbacks = newHiddenCallbacks;\n                } else {\n                    updateQueue.shared.hiddenCallbacks = existingHiddenCallbacks.concat(newHiddenCallbacks);\n                }\n            }\n        }\n        function commitHiddenCallbacks(updateQueue, context) {\n            // This component is switching from hidden -> visible. Commit any callbacks\n            // that were previously deferred.\n            var hiddenCallbacks = updateQueue.shared.hiddenCallbacks;\n            if (hiddenCallbacks !== null) {\n                updateQueue.shared.hiddenCallbacks = null;\n                for(var i = 0; i < hiddenCallbacks.length; i++){\n                    var callback = hiddenCallbacks[i];\n                    callCallback(callback, context);\n                }\n            }\n        }\n        function commitCallbacks(updateQueue, context) {\n            var callbacks = updateQueue.callbacks;\n            if (callbacks !== null) {\n                updateQueue.callbacks = null;\n                for(var i = 0; i < callbacks.length; i++){\n                    var callback = callbacks[i];\n                    callCallback(callback, context);\n                }\n            }\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        /**\n * Performs equality by iterating through keys on an object and returning false\n * when any key has values which are not strictly equal between the arguments.\n * Returns true when the values of all keys are strictly equal.\n */ function shallowEqual(objA, objB) {\n            if (objectIs(objA, objB)) {\n                return true;\n            }\n            if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {\n                return false;\n            }\n            var keysA = Object.keys(objA);\n            var keysB = Object.keys(objB);\n            if (keysA.length !== keysB.length) {\n                return false;\n            } // Test for A's keys different from B.\n            for(var i = 0; i < keysA.length; i++){\n                var currentKey = keysA[i];\n                if (!hasOwnProperty.call(objB, currentKey) || // $FlowFixMe[incompatible-use] lost refinement of `objB`\n                !objectIs(objA[currentKey], objB[currentKey])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        var ReactStrictModeWarnings = {\n            recordUnsafeLifecycleWarnings: function(fiber, instance) {},\n            flushPendingUnsafeLifecycleWarnings: function() {},\n            recordLegacyContextWarning: function(fiber, instance) {},\n            flushLegacyContextWarning: function() {},\n            discardPendingWarnings: function() {}\n        };\n        {\n            var findStrictRoot = function(fiber) {\n                var maybeStrictRoot = null;\n                var node = fiber;\n                while(node !== null){\n                    if (node.mode & StrictLegacyMode) {\n                        maybeStrictRoot = node;\n                    }\n                    node = node.return;\n                }\n                return maybeStrictRoot;\n            };\n            var setToSortedString = function(set) {\n                var array = [];\n                set.forEach(function(value) {\n                    array.push(value);\n                });\n                return array.sort().join(', ');\n            };\n            var pendingComponentWillMountWarnings = [];\n            var pendingUNSAFE_ComponentWillMountWarnings = [];\n            var pendingComponentWillReceivePropsWarnings = [];\n            var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n            var pendingComponentWillUpdateWarnings = [];\n            var pendingUNSAFE_ComponentWillUpdateWarnings = []; // Tracks components we have already warned about.\n            var didWarnAboutUnsafeLifecycles = new Set();\n            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {\n                // Dedupe strategy: Warn once per component.\n                if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {\n                    return;\n                }\n                if (typeof instance.componentWillMount === 'function' && // Don't warn about react-lifecycles-compat polyfilled components.\n                instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                    pendingComponentWillMountWarnings.push(fiber);\n                }\n                if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === 'function') {\n                    pendingUNSAFE_ComponentWillMountWarnings.push(fiber);\n                }\n                if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n                    pendingComponentWillReceivePropsWarnings.push(fiber);\n                }\n                if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n                    pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);\n                }\n                if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n                    pendingComponentWillUpdateWarnings.push(fiber);\n                }\n                if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === 'function') {\n                    pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);\n                }\n            };\n            ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {\n                // We do an initial pass to gather component names\n                var componentWillMountUniqueNames = new Set();\n                if (pendingComponentWillMountWarnings.length > 0) {\n                    pendingComponentWillMountWarnings.forEach(function(fiber) {\n                        componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingComponentWillMountWarnings = [];\n                }\n                var UNSAFE_componentWillMountUniqueNames = new Set();\n                if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {\n                    pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {\n                        UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingUNSAFE_ComponentWillMountWarnings = [];\n                }\n                var componentWillReceivePropsUniqueNames = new Set();\n                if (pendingComponentWillReceivePropsWarnings.length > 0) {\n                    pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {\n                        componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingComponentWillReceivePropsWarnings = [];\n                }\n                var UNSAFE_componentWillReceivePropsUniqueNames = new Set();\n                if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {\n                    pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {\n                        UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n                }\n                var componentWillUpdateUniqueNames = new Set();\n                if (pendingComponentWillUpdateWarnings.length > 0) {\n                    pendingComponentWillUpdateWarnings.forEach(function(fiber) {\n                        componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingComponentWillUpdateWarnings = [];\n                }\n                var UNSAFE_componentWillUpdateUniqueNames = new Set();\n                if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {\n                    pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {\n                        UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n                        didWarnAboutUnsafeLifecycles.add(fiber.type);\n                    });\n                    pendingUNSAFE_ComponentWillUpdateWarnings = [];\n                } // Finally, we flush all the warnings\n                // UNSAFE_ ones before the deprecated ones, since they'll be 'louder'\n                if (UNSAFE_componentWillMountUniqueNames.size > 0) {\n                    var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);\n                    error('Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. ' + 'See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n' + '\\nPlease update the following components: %s', sortedNames);\n                }\n                if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {\n                    var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);\n                    error('Using UNSAFE_componentWillReceiveProps in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + \"* If you're updating state whenever props change, \" + 'refactor your code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\\n' + '\\nPlease update the following components: %s', _sortedNames);\n                }\n                if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {\n                    var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);\n                    error('Using UNSAFE_componentWillUpdate in strict mode is not recommended ' + 'and may indicate bugs in your code. ' + 'See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + '\\nPlease update the following components: %s', _sortedNames2);\n                }\n                if (componentWillMountUniqueNames.size > 0) {\n                    var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);\n                    warn('componentWillMount has been renamed, and is not recommended for use. ' + 'See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move code with side effects to componentDidMount, and set initial state in the constructor.\\n' + '* Rename componentWillMount to UNSAFE_componentWillMount to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n' + '\\nPlease update the following components: %s', _sortedNames3);\n                }\n                if (componentWillReceivePropsUniqueNames.size > 0) {\n                    var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);\n                    warn('componentWillReceiveProps has been renamed, and is not recommended for use. ' + 'See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + \"* If you're updating state whenever props change, refactor your \" + 'code to use memoization techniques or move it to ' + 'static getDerivedStateFromProps. Learn more at: https://react.dev/link/derived-state\\n' + '* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n' + '\\nPlease update the following components: %s', _sortedNames4);\n                }\n                if (componentWillUpdateUniqueNames.size > 0) {\n                    var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);\n                    warn('componentWillUpdate has been renamed, and is not recommended for use. ' + 'See https://react.dev/link/unsafe-component-lifecycles for details.\\n\\n' + '* Move data fetching code or side effects to componentDidUpdate.\\n' + '* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress ' + 'this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. ' + 'To rename all deprecated lifecycles to their new names, you can run ' + '`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\\n' + '\\nPlease update the following components: %s', _sortedNames5);\n                }\n            };\n            var pendingLegacyContextWarning = new Map(); // Tracks components we have already warned about.\n            var didWarnAboutLegacyContext = new Set();\n            ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {\n                var strictRoot = findStrictRoot(fiber);\n                if (strictRoot === null) {\n                    error('Expected to find a StrictMode component in a strict mode tree. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n                    return;\n                } // Dedup strategy: Warn once per component.\n                if (didWarnAboutLegacyContext.has(fiber.type)) {\n                    return;\n                }\n                var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);\n                if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === 'function') {\n                    if (warningsForRoot === undefined) {\n                        warningsForRoot = [];\n                        pendingLegacyContextWarning.set(strictRoot, warningsForRoot);\n                    }\n                    warningsForRoot.push(fiber);\n                }\n            };\n            ReactStrictModeWarnings.flushLegacyContextWarning = function() {\n                pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {\n                    if (fiberArray.length === 0) {\n                        return;\n                    }\n                    var firstFiber = fiberArray[0];\n                    var uniqueNames = new Set();\n                    fiberArray.forEach(function(fiber) {\n                        uniqueNames.add(getComponentNameFromFiber(fiber) || 'Component');\n                        didWarnAboutLegacyContext.add(fiber.type);\n                    });\n                    var sortedNames = setToSortedString(uniqueNames);\n                    try {\n                        setCurrentDebugFiberInDEV(firstFiber);\n                        error('Legacy context API has been detected within a strict-mode tree.' + '\\n\\nThe old API will be supported in all 16.x releases, but applications ' + 'using it should migrate to the new version.' + '\\n\\nPlease update the following components: %s' + '\\n\\nLearn more about this warning here: https://react.dev/link/legacy-context', sortedNames);\n                    } finally{\n                        resetCurrentDebugFiberInDEV();\n                    }\n                });\n            };\n            ReactStrictModeWarnings.discardPendingWarnings = function() {\n                pendingComponentWillMountWarnings = [];\n                pendingUNSAFE_ComponentWillMountWarnings = [];\n                pendingComponentWillReceivePropsWarnings = [];\n                pendingUNSAFE_ComponentWillReceivePropsWarnings = [];\n                pendingComponentWillUpdateWarnings = [];\n                pendingUNSAFE_ComponentWillUpdateWarnings = [];\n                pendingLegacyContextWarning = new Map();\n            };\n        }\n        function getThenablesFromState(state) {\n            {\n                var devState = state;\n                return devState.thenables;\n            }\n        } // An error that is thrown (e.g. by `use`) to trigger Suspense. If we\n        // detect this is caught by userspace, we'll log a warning in development.\n        var SuspenseException = new Error(\"Suspense Exception: This is not a real error! It's an implementation \" + 'detail of `use` to interrupt the current render. You must either ' + 'rethrow it immediately, or move the `use` call outside of the ' + '`try/catch` block. Capturing without rethrowing will lead to ' + 'unexpected behavior.\\n\\n' + 'To handle async errors, wrap your component in an error boundary, or ' + \"call the promise's `.catch` method and pass the result to `use`\");\n        var SuspenseyCommitException = new Error('Suspense Exception: This is not a real error, and should not leak into ' + \"userspace. If you're seeing this, it's likely a bug in React.\"); // This is a noop thenable that we use to trigger a fallback in throwException.\n        // TODO: It would be better to refactor throwException into multiple functions\n        // so we can trigger a fallback directly without having to check the type. But\n        // for now this will do.\n        var noopSuspenseyCommitThenable = {\n            then: function() {\n                {\n                    error('Internal React error: A listener was unexpectedly attached to a ' + '\"noop\" thenable. This is a bug in React. Please file an issue.');\n                }\n            }\n        };\n        function createThenableState() {\n            // The ThenableState is created the first time a component suspends. If it\n            // suspends again, we'll reuse the same state.\n            {\n                return {\n                    didWarnAboutUncachedPromise: false,\n                    thenables: []\n                };\n            }\n        }\n        function isThenableResolved(thenable) {\n            var status = thenable.status;\n            return status === 'fulfilled' || status === 'rejected';\n        }\n        function noop$1() {}\n        function trackUsedThenable(thenableState, thenable, index) {\n            if (ReactSharedInternals.actQueue !== null) {\n                ReactSharedInternals.didUsePromise = true;\n            }\n            var trackedThenables = getThenablesFromState(thenableState);\n            var previous = trackedThenables[index];\n            if (previous === undefined) {\n                trackedThenables.push(thenable);\n            } else {\n                if (previous !== thenable) {\n                    // Reuse the previous thenable, and drop the new one. We can assume\n                    // they represent the same value, because components are idempotent.\n                    {\n                        var thenableStateDev = thenableState;\n                        if (!thenableStateDev.didWarnAboutUncachedPromise) {\n                            // We should only warn the first time an uncached thenable is\n                            // discovered per component, because if there are multiple, the\n                            // subsequent ones are likely derived from the first.\n                            //\n                            // We track this on the thenableState instead of deduping using the\n                            // component name like we usually do, because in the case of a\n                            // promise-as-React-node, the owner component is likely different from\n                            // the parent that's currently being reconciled. We'd have to track\n                            // the owner using state, which we're trying to move away from. Though\n                            // since this is dev-only, maybe that'd be OK.\n                            //\n                            // However, another benefit of doing it this way is we might\n                            // eventually have a thenableState per memo/Forget boundary instead\n                            // of per component, so this would allow us to have more\n                            // granular warnings.\n                            thenableStateDev.didWarnAboutUncachedPromise = true; // TODO: This warning should link to a corresponding docs page.\n                            error('A component was suspended by an uncached promise. Creating ' + 'promises inside a Client Component or hook is not yet ' + 'supported, except via a Suspense-compatible library or framework.');\n                        }\n                    }\n                    // intentionally ignore.\n                    thenable.then(noop$1, noop$1);\n                    thenable = previous;\n                }\n            } // We use an expando to track the status and result of a thenable so that we\n            // can synchronously unwrap the value. Think of this as an extension of the\n            // Promise API, or a custom interface that is a superset of Thenable.\n            //\n            // If the thenable doesn't have a status, set it to \"pending\" and attach\n            // a listener that will update its status and result when it resolves.\n            switch(thenable.status){\n                case 'fulfilled':\n                    {\n                        var fulfilledValue = thenable.value;\n                        return fulfilledValue;\n                    }\n                case 'rejected':\n                    {\n                        var rejectedError = thenable.reason;\n                        checkIfUseWrappedInAsyncCatch(rejectedError);\n                        throw rejectedError;\n                    }\n                default:\n                    {\n                        if (typeof thenable.status === 'string') {\n                            // Only instrument the thenable if the status if not defined. If\n                            // it's defined, but an unknown value, assume it's been instrumented by\n                            // some custom userspace implementation. We treat it as \"pending\".\n                            // Attach a dummy listener, to ensure that any lazy initialization can\n                            // happen. Flight lazily parses JSON when the value is actually awaited.\n                            thenable.then(noop$1, noop$1);\n                        } else {\n                            // This is an uncached thenable that we haven't seen before.\n                            // Detect infinite ping loops caused by uncached promises.\n                            var root = getWorkInProgressRoot();\n                            if (root !== null && root.shellSuspendCounter > 100) {\n                                // This root has suspended repeatedly in the shell without making any\n                                // progress (i.e. committing something). This is highly suggestive of\n                                // an infinite ping loop, often caused by an accidental Async Client\n                                // Component.\n                                //\n                                // During a transition, we can suspend the work loop until the promise\n                                // to resolve, but this is a sync render, so that's not an option. We\n                                // also can't show a fallback, because none was provided. So our last\n                                // resort is to throw an error.\n                                //\n                                // TODO: Remove this error in a future release. Other ways of handling\n                                // this case include forcing a concurrent render, or putting the whole\n                                // root into offscreen mode.\n                                throw new Error('async/await is not yet supported in Client Components, only ' + 'Server Components. This error is often caused by accidentally ' + \"adding `'use client'` to a module that was originally written \" + 'for the server.');\n                            }\n                            var pendingThenable = thenable;\n                            pendingThenable.status = 'pending';\n                            pendingThenable.then(function(fulfilledValue) {\n                                if (thenable.status === 'pending') {\n                                    var fulfilledThenable = thenable;\n                                    fulfilledThenable.status = 'fulfilled';\n                                    fulfilledThenable.value = fulfilledValue;\n                                }\n                            }, function(error) {\n                                if (thenable.status === 'pending') {\n                                    var rejectedThenable = thenable;\n                                    rejectedThenable.status = 'rejected';\n                                    rejectedThenable.reason = error;\n                                }\n                            });\n                        } // Check one more time in case the thenable resolved synchronously.\n                        switch(thenable.status){\n                            case 'fulfilled':\n                                {\n                                    var fulfilledThenable = thenable;\n                                    return fulfilledThenable.value;\n                                }\n                            case 'rejected':\n                                {\n                                    var rejectedThenable = thenable;\n                                    var _rejectedError = rejectedThenable.reason;\n                                    checkIfUseWrappedInAsyncCatch(_rejectedError);\n                                    throw _rejectedError;\n                                }\n                        } // Suspend.\n                        //\n                        // Throwing here is an implementation detail that allows us to unwind the\n                        // call stack. But we shouldn't allow it to leak into userspace. Throw an\n                        // opaque placeholder value instead of the actual thenable. If it doesn't\n                        // get captured by the work loop, log a warning, because that means\n                        // something in userspace must have caught it.\n                        suspendedThenable = thenable;\n                        {\n                            needsToResetSuspendedThenableDEV = true;\n                        }\n                        throw SuspenseException;\n                    }\n            }\n        }\n        function suspendCommit() {\n            // This extra indirection only exists so it can handle passing\n            // noopSuspenseyCommitThenable through to throwException.\n            // TODO: Factor the thenable check out of throwException\n            suspendedThenable = noopSuspenseyCommitThenable;\n            throw SuspenseyCommitException;\n        } // This is used to track the actual thenable that suspended so it can be\n        // passed to the rest of the Suspense implementation — which, for historical\n        // reasons, expects to receive a thenable.\n        var suspendedThenable = null;\n        var needsToResetSuspendedThenableDEV = false;\n        function getSuspendedThenable() {\n            // This is called right after `use` suspends by throwing an exception. `use`\n            // throws an opaque value instead of the thenable itself so that it can't be\n            // caught in userspace. Then the work loop accesses the actual thenable using\n            // this function.\n            if (suspendedThenable === null) {\n                throw new Error('Expected a suspended thenable. This is a bug in React. Please file ' + 'an issue.');\n            }\n            var thenable = suspendedThenable;\n            suspendedThenable = null;\n            {\n                needsToResetSuspendedThenableDEV = false;\n            }\n            return thenable;\n        }\n        function checkIfUseWrappedInTryCatch() {\n            {\n                // This was set right before SuspenseException was thrown, and it should\n                // have been cleared when the exception was handled. If it wasn't,\n                // it must have been caught by userspace.\n                if (needsToResetSuspendedThenableDEV) {\n                    needsToResetSuspendedThenableDEV = false;\n                    return true;\n                }\n            }\n            return false;\n        }\n        function checkIfUseWrappedInAsyncCatch(rejectedReason) {\n            // This check runs in prod, too, because it prevents a more confusing\n            // downstream error, where SuspenseException is caught by a promise and\n            // thrown asynchronously.\n            // TODO: Another way to prevent SuspenseException from leaking into an async\n            // execution context is to check the dispatcher every time `use` is called,\n            // or some equivalent. That might be preferable for other reasons, too, since\n            // it matches how we prevent similar mistakes for other hooks.\n            if (rejectedReason === SuspenseException) {\n                throw new Error('Hooks are not supported inside an async component. This ' + \"error is often caused by accidentally adding `'use client'` \" + 'to a module that was originally written for the server.');\n            }\n        }\n        var thenableState$1 = null;\n        var thenableIndexCounter$1 = 0;\n        function mergeDebugInfo(outer, inner) {\n            if (inner == null) {\n                return outer;\n            } else if (outer === null) {\n                return inner;\n            } else {\n                // If we have two debugInfo, we need to create a new one. This makes the array no longer\n                // live so we'll miss any future updates if we received more so ideally we should always\n                // do this after both have fully resolved/unsuspended.\n                return outer.concat(inner);\n            }\n        }\n        var didWarnAboutMaps;\n        var didWarnAboutGenerators;\n        var ownerHasKeyUseWarning;\n        var ownerHasFunctionTypeWarning;\n        var ownerHasSymbolTypeWarning;\n        var warnForMissingKey = function(child, returnFiber) {};\n        {\n            didWarnAboutMaps = false;\n            didWarnAboutGenerators = false;\n            /**\n   * Warn if there's no key explicitly set on dynamic arrays of children or\n   * object keys are not valid. This allows us to keep track of children between\n   * updates.\n   */ ownerHasKeyUseWarning = {};\n            ownerHasFunctionTypeWarning = {};\n            ownerHasSymbolTypeWarning = {};\n            warnForMissingKey = function(child, returnFiber) {\n                if (child === null || typeof child !== 'object') {\n                    return;\n                }\n                if (!child._store || (child._store.validated || child.key != null) && child._store.validated !== 2) {\n                    return;\n                }\n                if (typeof child._store !== 'object') {\n                    throw new Error('React Component in warnForMissingKey should have a _store. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n                } // $FlowFixMe[cannot-write] unable to narrow type from mixed to writable object\n                child._store.validated = 1;\n                var componentName = getComponentNameFromFiber(returnFiber);\n                var componentKey = componentName || 'null';\n                if (ownerHasKeyUseWarning[componentKey]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[componentKey] = true;\n                var childOwner = child._owner;\n                var parentOwner = returnFiber._debugOwner;\n                var currentComponentErrorInfo = '';\n                if (parentOwner && typeof parentOwner.tag === 'number') {\n                    var name = getComponentNameFromFiber(parentOwner);\n                    if (name) {\n                        currentComponentErrorInfo = '\\n\\nCheck the render method of `' + name + '`.';\n                    }\n                }\n                if (!currentComponentErrorInfo) {\n                    if (componentName) {\n                        currentComponentErrorInfo = \"\\n\\nCheck the top-level render call using <\" + componentName + \">.\";\n                    }\n                } // Usually the current owner is the offender, but if it accepts children as a\n                // property, it may be the creator of the child that's responsible for\n                // assigning it a key.\n                var childOwnerAppendix = '';\n                if (childOwner != null && parentOwner !== childOwner) {\n                    var ownerName = null;\n                    if (typeof childOwner.tag === 'number') {\n                        ownerName = getComponentNameFromFiber(childOwner);\n                    } else if (typeof childOwner.name === 'string') {\n                        ownerName = childOwner.name;\n                    }\n                    if (ownerName) {\n                        // Give the component that originally created this child.\n                        childOwnerAppendix = \" It was passed a child from \" + ownerName + \".\";\n                    }\n                } // We create a fake Fiber for the child to log the stack trace from.\n                // TODO: Refactor the warnForMissingKey calls to happen after fiber creation\n                // so that we can get access to the fiber that will eventually be created.\n                // That way the log can show up associated with the right instance in DevTools.\n                var fiber = createFiberFromElement(child, returnFiber.mode, 0);\n                fiber.return = returnFiber;\n                var prevDebugFiber = getCurrentFiber();\n                setCurrentFiber(fiber);\n                error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://react.dev/link/warning-keys for more information.', currentComponentErrorInfo, childOwnerAppendix);\n                setCurrentFiber(prevDebugFiber);\n            };\n        }\n        // We do this here instead of BeginWork because the Fragment fiber doesn't have\n        // the whole props object, only the children and is shared with arrays.\n        function validateFragmentProps(element, fiber, returnFiber) {\n            {\n                var keys = Object.keys(element.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== 'children' && key !== 'key') {\n                        if (fiber === null) {\n                            // For unkeyed root fragments there's no Fiber. We create a fake one just for\n                            // error stack handling.\n                            fiber = createFiberFromElement(element, returnFiber.mode, 0);\n                            fiber.return = returnFiber;\n                        }\n                        var prevDebugFiber = getCurrentFiber();\n                        setCurrentFiber(fiber);\n                        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n                        setCurrentFiber(prevDebugFiber);\n                        break;\n                    }\n                }\n            }\n        }\n        function unwrapThenable(thenable) {\n            var index = thenableIndexCounter$1;\n            thenableIndexCounter$1 += 1;\n            if (thenableState$1 === null) {\n                thenableState$1 = createThenableState();\n            }\n            return trackUsedThenable(thenableState$1, thenable, index);\n        }\n        function coerceRef(returnFiber, current, workInProgress, element) {\n            var ref;\n            {\n                // TODO: This is a temporary, intermediate step. When enableRefAsProp is on,\n                // we should resolve the `ref` prop during the begin phase of the component\n                // it's attached to (HostComponent, ClassComponent, etc).\n                var refProp = element.props.ref;\n                ref = refProp !== undefined ? refProp : null;\n            }\n            // should always read the ref from the prop.\n            workInProgress.ref = ref;\n        }\n        function throwOnInvalidObjectType(returnFiber, newChild) {\n            if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE) {\n                throw new Error('A React Element from an older version of React was rendered. ' + 'This is not supported. It can happen if:\\n' + '- Multiple copies of the \"react\" package is used.\\n' + '- A library pre-bundled an old copy of \"react\" or \"react/jsx-runtime\".\\n' + '- A compiler tries to \"inline\" JSX instead of using the runtime.');\n            } // $FlowFixMe[method-unbinding]\n            var childString = Object.prototype.toString.call(newChild);\n            throw new Error(\"Objects are not valid as a React child (found: \" + (childString === '[object Object]' ? 'object with keys {' + Object.keys(newChild).join(', ') + '}' : childString) + \"). \" + 'If you meant to render a collection of children, use an array ' + 'instead.');\n        }\n        function warnOnFunctionType(returnFiber, invalidChild) {\n            {\n                var parentName = getComponentNameFromFiber(returnFiber) || 'Component';\n                if (ownerHasFunctionTypeWarning[parentName]) {\n                    return;\n                }\n                ownerHasFunctionTypeWarning[parentName] = true;\n                var name = invalidChild.displayName || invalidChild.name || 'Component';\n                if (returnFiber.tag === HostRoot) {\n                    error('Functions are not valid as a React child. This may happen if ' + 'you return %s instead of <%s /> from render. ' + 'Or maybe you meant to call this function rather than return it.\\n' + '  root.render(%s)', name, name, name);\n                } else {\n                    error('Functions are not valid as a React child. This may happen if ' + 'you return %s instead of <%s /> from render. ' + 'Or maybe you meant to call this function rather than return it.\\n' + '  <%s>{%s}</%s>', name, name, parentName, name, parentName);\n                }\n            }\n        }\n        function warnOnSymbolType(returnFiber, invalidChild) {\n            {\n                var parentName = getComponentNameFromFiber(returnFiber) || 'Component';\n                if (ownerHasSymbolTypeWarning[parentName]) {\n                    return;\n                }\n                ownerHasSymbolTypeWarning[parentName] = true; // eslint-disable-next-line react-internal/safe-string-coercion\n                var name = String(invalidChild);\n                if (returnFiber.tag === HostRoot) {\n                    error('Symbols are not valid as a React child.\\n' + '  root.render(%s)', name);\n                } else {\n                    error('Symbols are not valid as a React child.\\n' + '  <%s>%s</%s>', parentName, name, parentName);\n                }\n            }\n        }\n        function resolveLazy(lazyType) {\n            var payload = lazyType._payload;\n            var init = lazyType._init;\n            return init(payload);\n        } // This wrapper function exists because I expect to clone the code in each path\n        // to be able to optimize each path individually by branching early. This needs\n        // a compiler or we can do it manually. Helpers that don't need this branching\n        // live outside of this function.\n        function createChildReconciler(shouldTrackSideEffects) {\n            function deleteChild(returnFiber, childToDelete) {\n                if (!shouldTrackSideEffects) {\n                    // Noop.\n                    return;\n                }\n                var deletions = returnFiber.deletions;\n                if (deletions === null) {\n                    returnFiber.deletions = [\n                        childToDelete\n                    ];\n                    returnFiber.flags |= ChildDeletion;\n                } else {\n                    deletions.push(childToDelete);\n                }\n            }\n            function deleteRemainingChildren(returnFiber, currentFirstChild) {\n                if (!shouldTrackSideEffects) {\n                    // Noop.\n                    return null;\n                } // TODO: For the shouldClone case, this could be micro-optimized a bit by\n                // assuming that after the first child we've already added everything.\n                var childToDelete = currentFirstChild;\n                while(childToDelete !== null){\n                    deleteChild(returnFiber, childToDelete);\n                    childToDelete = childToDelete.sibling;\n                }\n                return null;\n            }\n            function mapRemainingChildren(currentFirstChild) {\n                // Add the remaining children to a temporary map so that we can find them by\n                // keys quickly. Implicit (null) keys get added to this set with their index\n                // instead.\n                var existingChildren = new Map();\n                var existingChild = currentFirstChild;\n                while(existingChild !== null){\n                    if (existingChild.key !== null) {\n                        existingChildren.set(existingChild.key, existingChild);\n                    } else {\n                        existingChildren.set(existingChild.index, existingChild);\n                    }\n                    existingChild = existingChild.sibling;\n                }\n                return existingChildren;\n            }\n            function useFiber(fiber, pendingProps) {\n                // We currently set sibling to null and index to 0 here because it is easy\n                // to forget to do before returning it. E.g. for the single child case.\n                var clone = createWorkInProgress(fiber, pendingProps);\n                clone.index = 0;\n                clone.sibling = null;\n                return clone;\n            }\n            function placeChild(newFiber, lastPlacedIndex, newIndex) {\n                newFiber.index = newIndex;\n                if (!shouldTrackSideEffects) {\n                    // During hydration, the useId algorithm needs to know which fibers are\n                    // part of a list of children (arrays, iterators).\n                    newFiber.flags |= Forked;\n                    return lastPlacedIndex;\n                }\n                var current = newFiber.alternate;\n                if (current !== null) {\n                    var oldIndex = current.index;\n                    if (oldIndex < lastPlacedIndex) {\n                        // This is a move.\n                        newFiber.flags |= Placement | PlacementDEV;\n                        return lastPlacedIndex;\n                    } else {\n                        // This item can stay in place.\n                        return oldIndex;\n                    }\n                } else {\n                    // This is an insertion.\n                    newFiber.flags |= Placement | PlacementDEV;\n                    return lastPlacedIndex;\n                }\n            }\n            function placeSingleChild(newFiber) {\n                // This is simpler for the single child case. We only need to do a\n                // placement for inserting new children.\n                if (shouldTrackSideEffects && newFiber.alternate === null) {\n                    newFiber.flags |= Placement | PlacementDEV;\n                }\n                return newFiber;\n            }\n            function updateTextNode(returnFiber, current, textContent, lanes, debugInfo) {\n                if (current === null || current.tag !== HostText) {\n                    // Insert\n                    var created = createFiberFromText(textContent, returnFiber.mode, lanes);\n                    created.return = returnFiber;\n                    {\n                        created._debugInfo = debugInfo;\n                    }\n                    return created;\n                } else {\n                    // Update\n                    var existing = useFiber(current, textContent);\n                    existing.return = returnFiber;\n                    {\n                        existing._debugInfo = debugInfo;\n                    }\n                    return existing;\n                }\n            }\n            function updateElement(returnFiber, current, element, lanes, debugInfo) {\n                var elementType = element.type;\n                if (elementType === REACT_FRAGMENT_TYPE) {\n                    var updated = updateFragment(returnFiber, current, element.props.children, lanes, element.key, debugInfo);\n                    validateFragmentProps(element, updated, returnFiber);\n                    return updated;\n                }\n                if (current !== null) {\n                    if (current.elementType === elementType || isCompatibleFamilyForHotReloading(current, element) || // Lazy types should reconcile their resolved type.\n                    // We need to do this after the Hot Reloading check above,\n                    // because hot reloading has different semantics than prod because\n                    // it doesn't resuspend. So we can't let the call below suspend.\n                    typeof elementType === 'object' && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current.type) {\n                        // Move based on index\n                        var existing = useFiber(current, element.props);\n                        coerceRef(returnFiber, current, existing, element);\n                        existing.return = returnFiber;\n                        {\n                            existing._debugOwner = element._owner;\n                            existing._debugInfo = debugInfo;\n                        }\n                        return existing;\n                    }\n                } // Insert\n                var created = createFiberFromElement(element, returnFiber.mode, lanes);\n                coerceRef(returnFiber, current, created, element);\n                created.return = returnFiber;\n                {\n                    created._debugInfo = debugInfo;\n                }\n                return created;\n            }\n            function updatePortal(returnFiber, current, portal, lanes, debugInfo) {\n                if (current === null || current.tag !== HostPortal || current.stateNode.containerInfo !== portal.containerInfo || current.stateNode.implementation !== portal.implementation) {\n                    // Insert\n                    var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n                    created.return = returnFiber;\n                    {\n                        created._debugInfo = debugInfo;\n                    }\n                    return created;\n                } else {\n                    // Update\n                    var existing = useFiber(current, portal.children || []);\n                    existing.return = returnFiber;\n                    {\n                        existing._debugInfo = debugInfo;\n                    }\n                    return existing;\n                }\n            }\n            function updateFragment(returnFiber, current, fragment, lanes, key, debugInfo) {\n                if (current === null || current.tag !== Fragment) {\n                    // Insert\n                    var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);\n                    created.return = returnFiber;\n                    {\n                        created._debugInfo = debugInfo;\n                    }\n                    return created;\n                } else {\n                    // Update\n                    var existing = useFiber(current, fragment);\n                    existing.return = returnFiber;\n                    {\n                        existing._debugInfo = debugInfo;\n                    }\n                    return existing;\n                }\n            }\n            function createChild(returnFiber, newChild, lanes, debugInfo) {\n                if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number' || typeof newChild === 'bigint') {\n                    // Text nodes don't have keys. If the previous node is implicitly keyed\n                    // we can continue to replace it without aborting even if it is not a text\n                    // node.\n                    var created = createFiberFromText('' + newChild, returnFiber.mode, lanes);\n                    created.return = returnFiber;\n                    {\n                        created._debugInfo = debugInfo;\n                    }\n                    return created;\n                }\n                if (typeof newChild === 'object' && newChild !== null) {\n                    switch(newChild.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            {\n                                var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);\n                                coerceRef(returnFiber, null, _created, newChild);\n                                _created.return = returnFiber;\n                                {\n                                    _created._debugInfo = mergeDebugInfo(debugInfo, newChild._debugInfo);\n                                }\n                                return _created;\n                            }\n                        case REACT_PORTAL_TYPE:\n                            {\n                                var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);\n                                _created2.return = returnFiber;\n                                {\n                                    _created2._debugInfo = debugInfo;\n                                }\n                                return _created2;\n                            }\n                        case REACT_LAZY_TYPE:\n                            {\n                                var payload = newChild._payload;\n                                var init = newChild._init;\n                                return createChild(returnFiber, init(payload), lanes, mergeDebugInfo(debugInfo, newChild._debugInfo) // call merge after init\n                                );\n                            }\n                    }\n                    if (isArray(newChild) || getIteratorFn(newChild) || enableAsyncIterableChildren) {\n                        var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);\n                        _created3.return = returnFiber;\n                        {\n                            _created3._debugInfo = mergeDebugInfo(debugInfo, newChild._debugInfo);\n                        }\n                        return _created3;\n                    } // Usable node types\n                    //\n                    // Unwrap the inner value and recursively call this function again.\n                    if (typeof newChild.then === 'function') {\n                        var thenable = newChild;\n                        return createChild(returnFiber, unwrapThenable(thenable), lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                    }\n                    if (newChild.$$typeof === REACT_CONTEXT_TYPE) {\n                        var context = newChild;\n                        return createChild(returnFiber, readContextDuringReconciliation(returnFiber, context, lanes), lanes, debugInfo);\n                    }\n                    throwOnInvalidObjectType(returnFiber, newChild);\n                }\n                {\n                    if (typeof newChild === 'function') {\n                        warnOnFunctionType(returnFiber, newChild);\n                    }\n                    if (typeof newChild === 'symbol') {\n                        warnOnSymbolType(returnFiber, newChild);\n                    }\n                }\n                return null;\n            }\n            function updateSlot(returnFiber, oldFiber, newChild, lanes, debugInfo) {\n                // Update the fiber if the keys match, otherwise return null.\n                var key = oldFiber !== null ? oldFiber.key : null;\n                if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number' || typeof newChild === 'bigint') {\n                    // Text nodes don't have keys. If the previous node is implicitly keyed\n                    // we can continue to replace it without aborting even if it is not a text\n                    // node.\n                    if (key !== null) {\n                        return null;\n                    }\n                    return updateTextNode(returnFiber, oldFiber, '' + newChild, lanes, debugInfo);\n                }\n                if (typeof newChild === 'object' && newChild !== null) {\n                    switch(newChild.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            {\n                                if (newChild.key === key) {\n                                    return updateElement(returnFiber, oldFiber, newChild, lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                                } else {\n                                    return null;\n                                }\n                            }\n                        case REACT_PORTAL_TYPE:\n                            {\n                                if (newChild.key === key) {\n                                    return updatePortal(returnFiber, oldFiber, newChild, lanes, debugInfo);\n                                } else {\n                                    return null;\n                                }\n                            }\n                        case REACT_LAZY_TYPE:\n                            {\n                                var payload = newChild._payload;\n                                var init = newChild._init;\n                                return updateSlot(returnFiber, oldFiber, init(payload), lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                            }\n                    }\n                    if (isArray(newChild) || getIteratorFn(newChild) || enableAsyncIterableChildren) {\n                        if (key !== null) {\n                            return null;\n                        }\n                        return updateFragment(returnFiber, oldFiber, newChild, lanes, null, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                    } // Usable node types\n                    //\n                    // Unwrap the inner value and recursively call this function again.\n                    if (typeof newChild.then === 'function') {\n                        var thenable = newChild;\n                        return updateSlot(returnFiber, oldFiber, unwrapThenable(thenable), lanes, debugInfo);\n                    }\n                    if (newChild.$$typeof === REACT_CONTEXT_TYPE) {\n                        var context = newChild;\n                        return updateSlot(returnFiber, oldFiber, readContextDuringReconciliation(returnFiber, context, lanes), lanes, debugInfo);\n                    }\n                    throwOnInvalidObjectType(returnFiber, newChild);\n                }\n                {\n                    if (typeof newChild === 'function') {\n                        warnOnFunctionType(returnFiber, newChild);\n                    }\n                    if (typeof newChild === 'symbol') {\n                        warnOnSymbolType(returnFiber, newChild);\n                    }\n                }\n                return null;\n            }\n            function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes, debugInfo) {\n                if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number' || typeof newChild === 'bigint') {\n                    // Text nodes don't have keys, so we neither have to check the old nor\n                    // new node for the key. If both are text nodes, they match.\n                    var matchedFiber = existingChildren.get(newIdx) || null;\n                    return updateTextNode(returnFiber, matchedFiber, '' + newChild, lanes, debugInfo);\n                }\n                if (typeof newChild === 'object' && newChild !== null) {\n                    switch(newChild.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            {\n                                var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n                                return updateElement(returnFiber, _matchedFiber, newChild, lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                            }\n                        case REACT_PORTAL_TYPE:\n                            {\n                                var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;\n                                return updatePortal(returnFiber, _matchedFiber2, newChild, lanes, debugInfo);\n                            }\n                        case REACT_LAZY_TYPE:\n                            var payload = newChild._payload;\n                            var init = newChild._init;\n                            return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                    }\n                    if (isArray(newChild) || getIteratorFn(newChild) || enableAsyncIterableChildren) {\n                        var _matchedFiber3 = existingChildren.get(newIdx) || null;\n                        return updateFragment(returnFiber, _matchedFiber3, newChild, lanes, null, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                    } // Usable node types\n                    //\n                    // Unwrap the inner value and recursively call this function again.\n                    if (typeof newChild.then === 'function') {\n                        var thenable = newChild;\n                        return updateFromMap(existingChildren, returnFiber, newIdx, unwrapThenable(thenable), lanes, debugInfo);\n                    }\n                    if (newChild.$$typeof === REACT_CONTEXT_TYPE) {\n                        var context = newChild;\n                        return updateFromMap(existingChildren, returnFiber, newIdx, readContextDuringReconciliation(returnFiber, context, lanes), lanes, debugInfo);\n                    }\n                    throwOnInvalidObjectType(returnFiber, newChild);\n                }\n                {\n                    if (typeof newChild === 'function') {\n                        warnOnFunctionType(returnFiber, newChild);\n                    }\n                    if (typeof newChild === 'symbol') {\n                        warnOnSymbolType(returnFiber, newChild);\n                    }\n                }\n                return null;\n            }\n            /**\n   * Warns if there is a duplicate or missing key\n   */ function warnOnInvalidKey(child, knownKeys, returnFiber) {\n                {\n                    if (typeof child !== 'object' || child === null) {\n                        return knownKeys;\n                    }\n                    switch(child.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                        case REACT_PORTAL_TYPE:\n                            warnForMissingKey(child, returnFiber);\n                            var key = child.key;\n                            if (typeof key !== 'string') {\n                                break;\n                            }\n                            if (knownKeys === null) {\n                                knownKeys = new Set();\n                                knownKeys.add(key);\n                                break;\n                            }\n                            if (!knownKeys.has(key)) {\n                                knownKeys.add(key);\n                                break;\n                            }\n                            error('Encountered two children with the same key, `%s`. ' + 'Keys should be unique so that components maintain their identity ' + 'across updates. Non-unique keys may cause children to be ' + 'duplicated and/or omitted — the behavior is unsupported and ' + 'could change in a future version.', key);\n                            break;\n                        case REACT_LAZY_TYPE:\n                            var payload = child._payload;\n                            var init = child._init;\n                            warnOnInvalidKey(init(payload), knownKeys, returnFiber);\n                            break;\n                    }\n                }\n                return knownKeys;\n            }\n            function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes, debugInfo) {\n                // This algorithm can't optimize by searching from both ends since we\n                // don't have backpointers on fibers. I'm trying to see how far we can get\n                // with that model. If it ends up not being worth the tradeoffs, we can\n                // add it later.\n                // Even with a two ended optimization, we'd want to optimize for the case\n                // where there are few changes and brute force the comparison instead of\n                // going for the Map. It'd like to explore hitting that path first in\n                // forward-only mode and only go for the Map once we notice that we need\n                // lots of look ahead. This doesn't handle reversal as well as two ended\n                // search but that's unusual. Besides, for the two ended optimization to\n                // work on Iterables, we'd need to copy the whole set.\n                // In this first iteration, we'll just live with hitting the bad case\n                // (adding everything to a Map) in for every insert/move.\n                // If you change this code, also update reconcileChildrenIterator() which\n                // uses the same algorithm.\n                {\n                    // First, validate keys.\n                    var knownKeys = null;\n                    for(var i = 0; i < newChildren.length; i++){\n                        var child = newChildren[i];\n                        knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);\n                    }\n                }\n                var resultingFirstChild = null;\n                var previousNewFiber = null;\n                var oldFiber = currentFirstChild;\n                var lastPlacedIndex = 0;\n                var newIdx = 0;\n                var nextOldFiber = null;\n                for(; oldFiber !== null && newIdx < newChildren.length; newIdx++){\n                    if (oldFiber.index > newIdx) {\n                        nextOldFiber = oldFiber;\n                        oldFiber = null;\n                    } else {\n                        nextOldFiber = oldFiber.sibling;\n                    }\n                    var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes, debugInfo);\n                    if (newFiber === null) {\n                        // TODO: This breaks on empty slots like null children. That's\n                        // unfortunate because it triggers the slow path all the time. We need\n                        // a better way to communicate whether this was a miss or null,\n                        // boolean, undefined, etc.\n                        if (oldFiber === null) {\n                            oldFiber = nextOldFiber;\n                        }\n                        break;\n                    }\n                    if (shouldTrackSideEffects) {\n                        if (oldFiber && newFiber.alternate === null) {\n                            // We matched the slot, but we didn't reuse the existing fiber, so we\n                            // need to delete the existing child.\n                            deleteChild(returnFiber, oldFiber);\n                        }\n                    }\n                    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n                    if (previousNewFiber === null) {\n                        // TODO: Move out of the loop. This only happens for the first run.\n                        resultingFirstChild = newFiber;\n                    } else {\n                        // TODO: Defer siblings if we're not at the right index for this slot.\n                        // I.e. if we had null values before, then we want to defer this\n                        // for each null value. However, we also don't want to call updateSlot\n                        // with the previous one.\n                        previousNewFiber.sibling = newFiber;\n                    }\n                    previousNewFiber = newFiber;\n                    oldFiber = nextOldFiber;\n                }\n                if (newIdx === newChildren.length) {\n                    // We've reached the end of the new children. We can delete the rest.\n                    deleteRemainingChildren(returnFiber, oldFiber);\n                    if (getIsHydrating()) {\n                        var numberOfForks = newIdx;\n                        pushTreeFork(returnFiber, numberOfForks);\n                    }\n                    return resultingFirstChild;\n                }\n                if (oldFiber === null) {\n                    // If we don't have any more existing children we can choose a fast path\n                    // since the rest will all be insertions.\n                    for(; newIdx < newChildren.length; newIdx++){\n                        var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes, debugInfo);\n                        if (_newFiber === null) {\n                            continue;\n                        }\n                        lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);\n                        if (previousNewFiber === null) {\n                            // TODO: Move out of the loop. This only happens for the first run.\n                            resultingFirstChild = _newFiber;\n                        } else {\n                            previousNewFiber.sibling = _newFiber;\n                        }\n                        previousNewFiber = _newFiber;\n                    }\n                    if (getIsHydrating()) {\n                        var _numberOfForks = newIdx;\n                        pushTreeFork(returnFiber, _numberOfForks);\n                    }\n                    return resultingFirstChild;\n                } // Add all children to a key map for quick lookups.\n                var existingChildren = mapRemainingChildren(oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n                for(; newIdx < newChildren.length; newIdx++){\n                    var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes, debugInfo);\n                    if (_newFiber2 !== null) {\n                        if (shouldTrackSideEffects) {\n                            if (_newFiber2.alternate !== null) {\n                                // The new fiber is a work in progress, but if there exists a\n                                // current, that means that we reused the fiber. We need to delete\n                                // it from the child list so that we don't add it to the deletion\n                                // list.\n                                existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);\n                            }\n                        }\n                        lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);\n                        if (previousNewFiber === null) {\n                            resultingFirstChild = _newFiber2;\n                        } else {\n                            previousNewFiber.sibling = _newFiber2;\n                        }\n                        previousNewFiber = _newFiber2;\n                    }\n                }\n                if (shouldTrackSideEffects) {\n                    // Any existing children that weren't consumed above were deleted. We need\n                    // to add them to the deletion list.\n                    existingChildren.forEach(function(child) {\n                        return deleteChild(returnFiber, child);\n                    });\n                }\n                if (getIsHydrating()) {\n                    var _numberOfForks2 = newIdx;\n                    pushTreeFork(returnFiber, _numberOfForks2);\n                }\n                return resultingFirstChild;\n            }\n            function reconcileChildrenIteratable(returnFiber, currentFirstChild, newChildrenIterable, lanes, debugInfo) {\n                // This is the same implementation as reconcileChildrenArray(),\n                // but using the iterator instead.\n                var iteratorFn = getIteratorFn(newChildrenIterable);\n                if (typeof iteratorFn !== 'function') {\n                    throw new Error('An object is not an iterable. This error is likely caused by a bug in ' + 'React. Please file an issue.');\n                }\n                var newChildren = iteratorFn.call(newChildrenIterable);\n                {\n                    if (newChildren === newChildrenIterable) {\n                        // We don't support rendering Generators as props because it's a mutation.\n                        // See https://github.com/facebook/react/issues/12995\n                        // We do support generators if they were created by a GeneratorFunction component\n                        // as its direct child since we can recreate those by rerendering the component\n                        // as needed.\n                        var isGeneratorComponent = returnFiber.tag === FunctionComponent && // $FlowFixMe[method-unbinding]\n                        Object.prototype.toString.call(returnFiber.type) === '[object GeneratorFunction]' && // $FlowFixMe[method-unbinding]\n                        Object.prototype.toString.call(newChildren) === '[object Generator]';\n                        if (!isGeneratorComponent) {\n                            if (!didWarnAboutGenerators) {\n                                error('Using Iterators as children is unsupported and will likely yield ' + 'unexpected results because enumerating a generator mutates it. ' + 'You may convert it to an array with `Array.from()` or the ' + '`[...spread]` operator before rendering. You can also use an ' + 'Iterable that can iterate multiple times over the same items.');\n                            }\n                            didWarnAboutGenerators = true;\n                        }\n                    } else if (newChildrenIterable.entries === iteratorFn) {\n                        // Warn about using Maps as children\n                        if (!didWarnAboutMaps) {\n                            error('Using Maps as children is not supported. ' + 'Use an array of keyed ReactElements instead.');\n                            didWarnAboutMaps = true;\n                        }\n                    }\n                }\n                return reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes, debugInfo);\n            }\n            function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildren, lanes, debugInfo) {\n                if (newChildren == null) {\n                    throw new Error('An iterable object provided no iterator.');\n                }\n                var resultingFirstChild = null;\n                var previousNewFiber = null;\n                var oldFiber = currentFirstChild;\n                var lastPlacedIndex = 0;\n                var newIdx = 0;\n                var nextOldFiber = null;\n                var knownKeys = null;\n                var step = newChildren.next();\n                {\n                    knownKeys = warnOnInvalidKey(step.value, knownKeys, returnFiber);\n                }\n                for(; oldFiber !== null && !step.done; newIdx++, step = newChildren.next(), knownKeys = warnOnInvalidKey(step.value, knownKeys, returnFiber)){\n                    if (oldFiber.index > newIdx) {\n                        nextOldFiber = oldFiber;\n                        oldFiber = null;\n                    } else {\n                        nextOldFiber = oldFiber.sibling;\n                    }\n                    var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes, debugInfo);\n                    if (newFiber === null) {\n                        // TODO: This breaks on empty slots like null children. That's\n                        // unfortunate because it triggers the slow path all the time. We need\n                        // a better way to communicate whether this was a miss or null,\n                        // boolean, undefined, etc.\n                        if (oldFiber === null) {\n                            oldFiber = nextOldFiber;\n                        }\n                        break;\n                    }\n                    if (shouldTrackSideEffects) {\n                        if (oldFiber && newFiber.alternate === null) {\n                            // We matched the slot, but we didn't reuse the existing fiber, so we\n                            // need to delete the existing child.\n                            deleteChild(returnFiber, oldFiber);\n                        }\n                    }\n                    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);\n                    if (previousNewFiber === null) {\n                        // TODO: Move out of the loop. This only happens for the first run.\n                        resultingFirstChild = newFiber;\n                    } else {\n                        // TODO: Defer siblings if we're not at the right index for this slot.\n                        // I.e. if we had null values before, then we want to defer this\n                        // for each null value. However, we also don't want to call updateSlot\n                        // with the previous one.\n                        previousNewFiber.sibling = newFiber;\n                    }\n                    previousNewFiber = newFiber;\n                    oldFiber = nextOldFiber;\n                }\n                if (step.done) {\n                    // We've reached the end of the new children. We can delete the rest.\n                    deleteRemainingChildren(returnFiber, oldFiber);\n                    if (getIsHydrating()) {\n                        var numberOfForks = newIdx;\n                        pushTreeFork(returnFiber, numberOfForks);\n                    }\n                    return resultingFirstChild;\n                }\n                if (oldFiber === null) {\n                    // If we don't have any more existing children we can choose a fast path\n                    // since the rest will all be insertions.\n                    for(; !step.done; newIdx++, step = newChildren.next(), knownKeys = warnOnInvalidKey(step.value, knownKeys, returnFiber)){\n                        var _newFiber3 = createChild(returnFiber, step.value, lanes, debugInfo);\n                        if (_newFiber3 === null) {\n                            continue;\n                        }\n                        lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);\n                        if (previousNewFiber === null) {\n                            // TODO: Move out of the loop. This only happens for the first run.\n                            resultingFirstChild = _newFiber3;\n                        } else {\n                            previousNewFiber.sibling = _newFiber3;\n                        }\n                        previousNewFiber = _newFiber3;\n                    }\n                    if (getIsHydrating()) {\n                        var _numberOfForks3 = newIdx;\n                        pushTreeFork(returnFiber, _numberOfForks3);\n                    }\n                    return resultingFirstChild;\n                } // Add all children to a key map for quick lookups.\n                var existingChildren = mapRemainingChildren(oldFiber); // Keep scanning and use the map to restore deleted items as moves.\n                for(; !step.done; newIdx++, step = newChildren.next(), knownKeys = warnOnInvalidKey(step.value, knownKeys, returnFiber)){\n                    var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes, debugInfo);\n                    if (_newFiber4 !== null) {\n                        if (shouldTrackSideEffects) {\n                            if (_newFiber4.alternate !== null) {\n                                // The new fiber is a work in progress, but if there exists a\n                                // current, that means that we reused the fiber. We need to delete\n                                // it from the child list so that we don't add it to the deletion\n                                // list.\n                                existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);\n                            }\n                        }\n                        lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);\n                        if (previousNewFiber === null) {\n                            resultingFirstChild = _newFiber4;\n                        } else {\n                            previousNewFiber.sibling = _newFiber4;\n                        }\n                        previousNewFiber = _newFiber4;\n                    }\n                }\n                if (shouldTrackSideEffects) {\n                    // Any existing children that weren't consumed above were deleted. We need\n                    // to add them to the deletion list.\n                    existingChildren.forEach(function(child) {\n                        return deleteChild(returnFiber, child);\n                    });\n                }\n                if (getIsHydrating()) {\n                    var _numberOfForks4 = newIdx;\n                    pushTreeFork(returnFiber, _numberOfForks4);\n                }\n                return resultingFirstChild;\n            }\n            function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {\n                // There's no need to check for keys on text nodes since we don't have a\n                // way to define them.\n                if (currentFirstChild !== null && currentFirstChild.tag === HostText) {\n                    // We already have an existing node so let's just update it and delete\n                    // the rest.\n                    deleteRemainingChildren(returnFiber, currentFirstChild.sibling);\n                    var existing = useFiber(currentFirstChild, textContent);\n                    existing.return = returnFiber;\n                    return existing;\n                } // The existing first child is not a text node so we need to create one\n                // and delete the existing ones.\n                deleteRemainingChildren(returnFiber, currentFirstChild);\n                var created = createFiberFromText(textContent, returnFiber.mode, lanes);\n                created.return = returnFiber;\n                return created;\n            }\n            function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes, debugInfo) {\n                var key = element.key;\n                var child = currentFirstChild;\n                while(child !== null){\n                    // TODO: If key === null and child.key === null, then this only applies to\n                    // the first item in the list.\n                    if (child.key === key) {\n                        var elementType = element.type;\n                        if (elementType === REACT_FRAGMENT_TYPE) {\n                            if (child.tag === Fragment) {\n                                deleteRemainingChildren(returnFiber, child.sibling);\n                                var existing = useFiber(child, element.props.children);\n                                existing.return = returnFiber;\n                                {\n                                    existing._debugOwner = element._owner;\n                                    existing._debugInfo = debugInfo;\n                                }\n                                validateFragmentProps(element, existing, returnFiber);\n                                return existing;\n                            }\n                        } else {\n                            if (child.elementType === elementType || isCompatibleFamilyForHotReloading(child, element) || // Lazy types should reconcile their resolved type.\n                            // We need to do this after the Hot Reloading check above,\n                            // because hot reloading has different semantics than prod because\n                            // it doesn't resuspend. So we can't let the call below suspend.\n                            typeof elementType === 'object' && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {\n                                deleteRemainingChildren(returnFiber, child.sibling);\n                                var _existing = useFiber(child, element.props);\n                                coerceRef(returnFiber, child, _existing, element);\n                                _existing.return = returnFiber;\n                                {\n                                    _existing._debugOwner = element._owner;\n                                    _existing._debugInfo = debugInfo;\n                                }\n                                return _existing;\n                            }\n                        } // Didn't match.\n                        deleteRemainingChildren(returnFiber, child);\n                        break;\n                    } else {\n                        deleteChild(returnFiber, child);\n                    }\n                    child = child.sibling;\n                }\n                if (element.type === REACT_FRAGMENT_TYPE) {\n                    var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);\n                    created.return = returnFiber;\n                    {\n                        created._debugInfo = debugInfo;\n                    }\n                    validateFragmentProps(element, created, returnFiber);\n                    return created;\n                } else {\n                    var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);\n                    coerceRef(returnFiber, currentFirstChild, _created4, element);\n                    _created4.return = returnFiber;\n                    {\n                        _created4._debugInfo = debugInfo;\n                    }\n                    return _created4;\n                }\n            }\n            function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes, debugInfo) {\n                var key = portal.key;\n                var child = currentFirstChild;\n                while(child !== null){\n                    // TODO: If key === null and child.key === null, then this only applies to\n                    // the first item in the list.\n                    if (child.key === key) {\n                        if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {\n                            deleteRemainingChildren(returnFiber, child.sibling);\n                            var existing = useFiber(child, portal.children || []);\n                            existing.return = returnFiber;\n                            return existing;\n                        } else {\n                            deleteRemainingChildren(returnFiber, child);\n                            break;\n                        }\n                    } else {\n                        deleteChild(returnFiber, child);\n                    }\n                    child = child.sibling;\n                }\n                var created = createFiberFromPortal(portal, returnFiber.mode, lanes);\n                created.return = returnFiber;\n                return created;\n            } // This API will tag the children with the side-effect of the reconciliation\n            // itself. They will be added to the side-effect list as we pass through the\n            // children and the parent.\n            function reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes, debugInfo) {\n                // This function is only recursive for Usables/Lazy and not nested arrays.\n                // That's so that using a Lazy wrapper is unobservable to the Fragment\n                // convention.\n                // If the top level item is an array, we treat it as a set of children,\n                // not as a fragment. Nested arrays on the other hand will be treated as\n                // fragment nodes. Recursion happens at the normal flow.\n                // Handle top level unkeyed fragments as if they were arrays.\n                // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n                // We treat the ambiguous cases above the same.\n                // We don't use recursion here because a fragment inside a fragment\n                // is no longer considered \"top level\" for these purposes.\n                var isUnkeyedTopLevelFragment = typeof newChild === 'object' && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;\n                if (isUnkeyedTopLevelFragment) {\n                    validateFragmentProps(newChild, null, returnFiber);\n                    newChild = newChild.props.children;\n                } // Handle object types\n                if (typeof newChild === 'object' && newChild !== null) {\n                    switch(newChild.$$typeof){\n                        case REACT_ELEMENT_TYPE:\n                            return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes, mergeDebugInfo(debugInfo, newChild._debugInfo)));\n                        case REACT_PORTAL_TYPE:\n                            return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));\n                        case REACT_LAZY_TYPE:\n                            var payload = newChild._payload;\n                            var init = newChild._init;\n                            return reconcileChildFibersImpl(returnFiber, currentFirstChild, init(payload), lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                    }\n                    if (isArray(newChild)) {\n                        return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                    }\n                    if (getIteratorFn(newChild)) {\n                        return reconcileChildrenIteratable(returnFiber, currentFirstChild, newChild, lanes, mergeDebugInfo(debugInfo, newChild._debugInfo));\n                    }\n                    // a child position, it unwraps it using the same algorithm as `use`. For\n                    // example, for promises, React will throw an exception to unwind the\n                    // stack, then replay the component once the promise resolves.\n                    //\n                    // A difference from `use` is that React will keep unwrapping the value\n                    // until it reaches a non-Usable type.\n                    //\n                    // e.g. Usable<Usable<Usable<T>>> should resolve to T\n                    //\n                    // The structure is a bit unfortunate. Ideally, we shouldn't need to\n                    // replay the entire begin phase of the parent fiber in order to reconcile\n                    // the children again. This would require a somewhat significant refactor,\n                    // because reconcilation happens deep within the begin phase, and\n                    // depending on the type of work, not always at the end. We should\n                    // consider as an future improvement.\n                    if (typeof newChild.then === 'function') {\n                        var thenable = newChild;\n                        return reconcileChildFibersImpl(returnFiber, currentFirstChild, unwrapThenable(thenable), lanes, mergeDebugInfo(debugInfo, thenable._debugInfo));\n                    }\n                    if (newChild.$$typeof === REACT_CONTEXT_TYPE) {\n                        var context = newChild;\n                        return reconcileChildFibersImpl(returnFiber, currentFirstChild, readContextDuringReconciliation(returnFiber, context, lanes), lanes, debugInfo);\n                    }\n                    throwOnInvalidObjectType(returnFiber, newChild);\n                }\n                if (typeof newChild === 'string' && newChild !== '' || typeof newChild === 'number' || typeof newChild === 'bigint') {\n                    return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, '' + newChild, lanes));\n                }\n                {\n                    if (typeof newChild === 'function') {\n                        warnOnFunctionType(returnFiber, newChild);\n                    }\n                    if (typeof newChild === 'symbol') {\n                        warnOnSymbolType(returnFiber, newChild);\n                    }\n                }\n                return deleteRemainingChildren(returnFiber, currentFirstChild);\n            }\n            function reconcileChildFibers(returnFiber, currentFirstChild, newChild, lanes) {\n                // This indirection only exists so we can reset `thenableState` at the end.\n                // It should get inlined by Closure.\n                thenableIndexCounter$1 = 0;\n                var firstChildFiber = reconcileChildFibersImpl(returnFiber, currentFirstChild, newChild, lanes, null // debugInfo\n                );\n                thenableState$1 = null; // Don't bother to reset `thenableIndexCounter` to 0 because it always gets\n                // set at the beginning.\n                return firstChildFiber;\n            }\n            return reconcileChildFibers;\n        }\n        var reconcileChildFibers = createChildReconciler(true);\n        var mountChildFibers = createChildReconciler(false);\n        function resetChildReconcilerOnUnwind() {\n            // On unwind, clear any pending thenables that were used.\n            thenableState$1 = null;\n            thenableIndexCounter$1 = 0;\n        }\n        function cloneChildFibers(current, workInProgress) {\n            if (current !== null && workInProgress.child !== current.child) {\n                throw new Error('Resuming work not yet implemented.');\n            }\n            if (workInProgress.child === null) {\n                return;\n            }\n            var currentChild = workInProgress.child;\n            var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);\n            workInProgress.child = newChild;\n            newChild.return = workInProgress;\n            while(currentChild.sibling !== null){\n                currentChild = currentChild.sibling;\n                newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);\n                newChild.return = workInProgress;\n            }\n            newChild.sibling = null;\n        } // Reset a workInProgress child set to prepare it for a second pass.\n        function resetChildFibers(workInProgress, lanes) {\n            var child = workInProgress.child;\n            while(child !== null){\n                resetWorkInProgress(child, lanes);\n                child = child.sibling;\n            }\n        }\n        // TODO: This isn't being used yet, but it's intended to replace the\n        // InvisibleParentContext that is currently managed by SuspenseContext.\n        var currentTreeHiddenStackCursor = createCursor(null);\n        var prevEntangledRenderLanesCursor = createCursor(NoLanes);\n        function pushHiddenContext(fiber, context) {\n            var prevEntangledRenderLanes = getEntangledRenderLanes();\n            push(prevEntangledRenderLanesCursor, prevEntangledRenderLanes, fiber);\n            push(currentTreeHiddenStackCursor, context, fiber); // When rendering a subtree that's currently hidden, we must include all\n            // lanes that would have rendered if the hidden subtree hadn't been deferred.\n            // That is, in order to reveal content from hidden -> visible, we must commit\n            // all the updates that we skipped when we originally hid the tree.\n            setEntangledRenderLanes(mergeLanes(prevEntangledRenderLanes, context.baseLanes));\n        }\n        function reuseHiddenContextOnStack(fiber) {\n            // This subtree is not currently hidden, so we don't need to add any lanes\n            // to the render lanes. But we still need to push something to avoid a\n            // context mismatch. Reuse the existing context on the stack.\n            push(prevEntangledRenderLanesCursor, getEntangledRenderLanes(), fiber);\n            push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current, fiber);\n        }\n        function popHiddenContext(fiber) {\n            // Restore the previous render lanes from the stack\n            setEntangledRenderLanes(prevEntangledRenderLanesCursor.current);\n            pop(currentTreeHiddenStackCursor, fiber);\n            pop(prevEntangledRenderLanesCursor, fiber);\n        }\n        function isCurrentTreeHidden() {\n            return currentTreeHiddenStackCursor.current !== null;\n        }\n        // suspends, i.e. it's the nearest `catch` block on the stack.\n        var suspenseHandlerStackCursor = createCursor(null); // Represents the outermost boundary that is not visible in the current tree.\n        // Everything above this is the \"shell\". When this is null, it means we're\n        // rendering in the shell of the app. If it's non-null, it means we're rendering\n        // deeper than the shell, inside a new tree that wasn't already visible.\n        //\n        // The main way we use this concept is to determine whether showing a fallback\n        // would result in a desirable or undesirable loading state. Activing a fallback\n        // in the shell is considered an undersirable loading state, because it would\n        // mean hiding visible (albeit stale) content in the current tree — we prefer to\n        // show the stale content, rather than switch to a fallback. But showing a\n        // fallback in a new tree is fine, because there's no stale content to\n        // prefer instead.\n        var shellBoundary = null;\n        function getShellBoundary() {\n            return shellBoundary;\n        }\n        function pushPrimaryTreeSuspenseHandler(handler) {\n            // TODO: Pass as argument\n            var current = handler.alternate;\n            // propagated a single level. For example, when ForceSuspenseFallback is set,\n            // it should only force the nearest Suspense boundary into fallback mode.\n            pushSuspenseListContext(handler, setDefaultShallowSuspenseListContext(suspenseStackCursor.current)); // Experimental feature: Some Suspense boundaries are marked as having an\n            // to push a nested Suspense handler, because it will get replaced by the\n            // outer fallback, anyway. Consider this as a future optimization.\n            push(suspenseHandlerStackCursor, handler, handler);\n            if (shellBoundary === null) {\n                if (current === null || isCurrentTreeHidden()) {\n                    // This boundary is not visible in the current UI.\n                    shellBoundary = handler;\n                } else {\n                    var prevState = current.memoizedState;\n                    if (prevState !== null) {\n                        // This boundary is showing a fallback in the current UI.\n                        shellBoundary = handler;\n                    }\n                }\n            }\n        }\n        function pushFallbackTreeSuspenseHandler(fiber) {\n            // We're about to render the fallback. If something in the fallback suspends,\n            // it's akin to throwing inside of a `catch` block. This boundary should not\n            // capture. Reuse the existing handler on the stack.\n            reuseSuspenseHandlerOnStack(fiber);\n        }\n        function pushOffscreenSuspenseHandler(fiber) {\n            if (fiber.tag === OffscreenComponent) {\n                // A SuspenseList context is only pushed here to avoid a push/pop mismatch.\n                // Reuse the current value on the stack.\n                // TODO: We can avoid needing to push here by by forking popSuspenseHandler\n                // into separate functions for Suspense and Offscreen.\n                pushSuspenseListContext(fiber, suspenseStackCursor.current);\n                push(suspenseHandlerStackCursor, fiber, fiber);\n                if (shellBoundary !== null) ;\n                else {\n                    var current = fiber.alternate;\n                    if (current !== null) {\n                        var prevState = current.memoizedState;\n                        if (prevState !== null) {\n                            // This is the first boundary in the stack that's already showing\n                            // a fallback. So everything outside is considered the shell.\n                            shellBoundary = fiber;\n                        }\n                    }\n                }\n            } else {\n                // This is a LegacyHidden component.\n                reuseSuspenseHandlerOnStack(fiber);\n            }\n        }\n        function reuseSuspenseHandlerOnStack(fiber) {\n            pushSuspenseListContext(fiber, suspenseStackCursor.current);\n            push(suspenseHandlerStackCursor, getSuspenseHandler(), fiber);\n        }\n        function getSuspenseHandler() {\n            return suspenseHandlerStackCursor.current;\n        }\n        function popSuspenseHandler(fiber) {\n            pop(suspenseHandlerStackCursor, fiber);\n            if (shellBoundary === fiber) {\n                // Popping back into the shell.\n                shellBoundary = null;\n            }\n            popSuspenseListContext(fiber);\n        } // SuspenseList context\n        // TODO: Move to a separate module? We may change the SuspenseList\n        // implementation to hide/show in the commit phase, anyway.\n        var DefaultSuspenseContext = 0;\n        var SubtreeSuspenseContextMask = 1; // ForceSuspenseFallback can be used by SuspenseList to force newly added\n        // items into their fallback state during one of the render passes.\n        var ForceSuspenseFallback = 2;\n        var suspenseStackCursor = createCursor(DefaultSuspenseContext);\n        function hasSuspenseListContext(parentContext, flag) {\n            return (parentContext & flag) !== 0;\n        }\n        function setDefaultShallowSuspenseListContext(parentContext) {\n            return parentContext & SubtreeSuspenseContextMask;\n        }\n        function setShallowSuspenseListContext(parentContext, shallowContext) {\n            return parentContext & SubtreeSuspenseContextMask | shallowContext;\n        }\n        function pushSuspenseListContext(fiber, newContext) {\n            push(suspenseStackCursor, newContext, fiber);\n        }\n        function popSuspenseListContext(fiber) {\n            pop(suspenseStackCursor, fiber);\n        }\n        // A non-null SuspenseState means that it is blocked for one reason or another.\n        // - A non-null dehydrated field means it's blocked pending hydration.\n        //   - A non-null dehydrated field can use isSuspenseInstancePending or\n        //     isSuspenseInstanceFallback to query the reason for being dehydrated.\n        // - A null dehydrated field means it's blocked by something suspending and\n        //   we're currently showing a fallback instead.\n        function findFirstSuspended(row) {\n            var node = row;\n            while(node !== null){\n                if (node.tag === SuspenseComponent) {\n                    var state = node.memoizedState;\n                    if (state !== null) {\n                        var dehydrated = state.dehydrated;\n                        if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {\n                            return node;\n                        }\n                    }\n                } else if (node.tag === SuspenseListComponent && // revealOrder undefined can't be trusted because it don't\n                // keep track of whether it suspended or not.\n                node.memoizedProps.revealOrder !== undefined) {\n                    var didSuspend = (node.flags & DidCapture) !== NoFlags$1;\n                    if (didSuspend) {\n                        return node;\n                    }\n                } else if (node.child !== null) {\n                    node.child.return = node;\n                    node = node.child;\n                    continue;\n                }\n                if (node === row) {\n                    return null;\n                }\n                while(node.sibling === null){\n                    if (node.return === null || node.return === row) {\n                        return null;\n                    }\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            }\n            return null;\n        }\n        var NoFlags = /*   */ 0; // Represents whether effect should fire.\n        var HasEffect = /* */ 1; // Represents the phase in which the effect (not the clean-up) fires.\n        var Insertion = /* */ 2;\n        var Layout = /*    */ 4;\n        var Passive = /*   */ 8;\n        var didWarnAboutMismatchedHooksForComponent;\n        var didWarnUncachedGetSnapshot;\n        var didWarnAboutUseWrappedInTryCatch;\n        var didWarnAboutAsyncClientComponent;\n        var didWarnAboutUseFormState;\n        {\n            didWarnAboutMismatchedHooksForComponent = new Set();\n            didWarnAboutUseWrappedInTryCatch = new Set();\n            didWarnAboutAsyncClientComponent = new Set();\n            didWarnAboutUseFormState = new Set();\n        }\n        // lifetime of an effect. In Rust terms, a RefCell. We use it to store the\n        // \"destroy\" function that is returned from an effect, because that is stateful.\n        // The field is `undefined` if the effect is unmounted, or if the effect ran\n        // but is not stateful. We don't explicitly track whether the effect is mounted\n        // or unmounted because that can be inferred by the hiddenness of the fiber in\n        // the tree, i.e. whether there is a hidden Offscreen fiber above it.\n        //\n        // It's unfortunate that this is stored on a separate object, because it adds\n        // more memory per effect instance, but it's conceptually sound. I think there's\n        // likely a better data structure we could use for effects; perhaps just one\n        // array of effect instances per fiber. But I think this is OK for now despite\n        // the additional memory and we can follow up with performance\n        // optimizations later.\n        // These are set right before calling the component.\n        var renderLanes = NoLanes; // The work-in-progress fiber. I've named it differently to distinguish it from\n        // the work-in-progress hook.\n        var currentlyRenderingFiber$1 = null; // Hooks are stored as a linked list on the fiber's memoizedState field. The\n        // current hook list is the list that belongs to the current fiber. The\n        // work-in-progress hook list is a new list that will be added to the\n        // work-in-progress fiber.\n        var currentHook = null;\n        var workInProgressHook = null; // Whether an update was scheduled at any point during the render phase. This\n        // does not get reset if we do another render pass; only when we're completely\n        // finished evaluating this component. This is an optimization so we know\n        // whether we need to clear render phase updates after a throw.\n        var didScheduleRenderPhaseUpdate = false; // Where an update was scheduled only during the current render pass. This\n        // gets reset after each attempt.\n        // TODO: Maybe there's some way to consolidate this with\n        // `didScheduleRenderPhaseUpdate`. Or with `numberOfReRenders`.\n        var didScheduleRenderPhaseUpdateDuringThisPass = false;\n        var shouldDoubleInvokeUserFnsInHooksDEV = false; // Counts the number of useId hooks in this component.\n        var localIdCounter = 0; // Counts number of `use`-d thenables\n        var thenableIndexCounter = 0;\n        var thenableState = null; // Used for ids that are generated completely client-side (i.e. not during\n        // hydration). This counter is global, so client ids are not stable across\n        // render attempts.\n        var globalClientIdCounter = 0;\n        var RE_RENDER_LIMIT = 25; // In DEV, this is the name of the currently executing primitive hook\n        var currentHookNameInDev = null; // In DEV, this list ensures that hooks are called in the same order between renders.\n        // The list stores the order of hooks used during the initial render (mount).\n        // Subsequent renders (updates) reference this list.\n        var hookTypesDev = null;\n        var hookTypesUpdateIndexDev = -1; // In DEV, this tracks whether currently rendering component needs to ignore\n        // the dependencies for Hooks that need them (e.g. useEffect or useMemo).\n        // When true, such Hooks will always be \"remounted\". Only used during hot reload.\n        var ignorePreviousDependencies = false;\n        function mountHookTypesDev() {\n            {\n                var hookName = currentHookNameInDev;\n                if (hookTypesDev === null) {\n                    hookTypesDev = [\n                        hookName\n                    ];\n                } else {\n                    hookTypesDev.push(hookName);\n                }\n            }\n        }\n        function updateHookTypesDev() {\n            {\n                var hookName = currentHookNameInDev;\n                if (hookTypesDev !== null) {\n                    hookTypesUpdateIndexDev++;\n                    if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {\n                        warnOnHookMismatchInDev(hookName);\n                    }\n                }\n            }\n        }\n        function checkDepsAreArrayDev(deps) {\n            {\n                if (deps !== undefined && deps !== null && !isArray(deps)) {\n                    // Verify deps, but only on mount to avoid extra checks.\n                    // It's unlikely their type would change as usually you define them inline.\n                    error('%s received a final argument that is not an array (instead, received `%s`). When ' + 'specified, the final argument must be an array.', currentHookNameInDev, typeof deps);\n                }\n            }\n        }\n        function warnOnHookMismatchInDev(currentHookName) {\n            {\n                var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n                if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {\n                    didWarnAboutMismatchedHooksForComponent.add(componentName);\n                    if (hookTypesDev !== null) {\n                        var table = '';\n                        var secondColumnStart = 30;\n                        for(var i = 0; i <= hookTypesUpdateIndexDev; i++){\n                            var oldHookName = hookTypesDev[i];\n                            var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;\n                            var row = i + 1 + \". \" + oldHookName; // Extra space so second column lines up\n                            // lol @ IE not supporting String#repeat\n                            while(row.length < secondColumnStart){\n                                row += ' ';\n                            }\n                            row += newHookName + '\\n';\n                            table += row;\n                        }\n                        error('React has detected a change in the order of Hooks called by %s. ' + 'This will lead to bugs and errors if not fixed. ' + 'For more information, read the Rules of Hooks: https://react.dev/link/rules-of-hooks\\n\\n' + '   Previous render            Next render\\n' + '   ------------------------------------------------------\\n' + '%s' + '   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\\n', componentName, table);\n                    }\n                }\n            }\n        }\n        function warnOnUseFormStateInDev() {\n            {\n                var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n                if (!didWarnAboutUseFormState.has(componentName)) {\n                    didWarnAboutUseFormState.add(componentName);\n                    error('ReactDOM.useFormState has been renamed to React.useActionState. ' + 'Please update %s to use React.useActionState.', componentName);\n                }\n            }\n        }\n        function warnIfAsyncClientComponent(Component) {\n            {\n                // This dev-only check only works for detecting native async functions,\n                // not transpiled ones. There's also a prod check that we use to prevent\n                // async client components from crashing the app; the prod one works even\n                // for transpiled async functions. Neither mechanism is completely\n                // bulletproof but together they cover the most common cases.\n                var isAsyncFunction = Object.prototype.toString.call(Component) === '[object AsyncFunction]' || // $FlowIgnore[method-unbinding]\n                Object.prototype.toString.call(Component) === '[object AsyncGeneratorFunction]';\n                if (isAsyncFunction) {\n                    // Encountered an async Client Component. This is not yet supported.\n                    var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);\n                    if (!didWarnAboutAsyncClientComponent.has(componentName)) {\n                        didWarnAboutAsyncClientComponent.add(componentName);\n                        error('async/await is not yet supported in Client Components, only ' + 'Server Components. This error is often caused by accidentally ' + \"adding `'use client'` to a module that was originally written \" + 'for the server.');\n                    }\n                }\n            }\n        }\n        function throwInvalidHookError() {\n            throw new Error('Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for' + ' one of the following reasons:\\n' + '1. You might have mismatching versions of React and the renderer (such as React DOM)\\n' + '2. You might be breaking the Rules of Hooks\\n' + '3. You might have more than one copy of React in the same app\\n' + 'See https://react.dev/link/invalid-hook-call for tips about how to debug and fix this problem.');\n        }\n        function areHookInputsEqual(nextDeps, prevDeps) {\n            {\n                if (ignorePreviousDependencies) {\n                    // Only true when this component is being hot reloaded.\n                    return false;\n                }\n            }\n            if (prevDeps === null) {\n                {\n                    error('%s received a final argument during this render, but not during ' + 'the previous render. Even though the final argument is optional, ' + 'its type cannot change between renders.', currentHookNameInDev);\n                }\n                return false;\n            }\n            {\n                // Don't bother comparing lengths in prod because these arrays should be\n                // passed inline.\n                if (nextDeps.length !== prevDeps.length) {\n                    error('The final argument passed to %s changed size between renders. The ' + 'order and size of this array must remain constant.\\n\\n' + 'Previous: %s\\n' + 'Incoming: %s', currentHookNameInDev, \"[\" + prevDeps.join(', ') + \"]\", \"[\" + nextDeps.join(', ') + \"]\");\n                }\n            }\n            for(var i = 0; i < prevDeps.length && i < nextDeps.length; i++){\n                // $FlowFixMe[incompatible-use] found when upgrading Flow\n                if (objectIs(nextDeps[i], prevDeps[i])) {\n                    continue;\n                }\n                return false;\n            }\n            return true;\n        }\n        function renderWithHooks(current, workInProgress, Component, props, secondArg, nextRenderLanes) {\n            renderLanes = nextRenderLanes;\n            currentlyRenderingFiber$1 = workInProgress;\n            {\n                hookTypesDev = current !== null ? current._debugHookTypes : null;\n                hookTypesUpdateIndexDev = -1; // Used for hot reloading:\n                ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;\n                warnIfAsyncClientComponent(Component);\n            }\n            workInProgress.memoizedState = null;\n            workInProgress.updateQueue = null;\n            workInProgress.lanes = NoLanes; // The following should have already been reset\n            // currentHook = null;\n            // workInProgressHook = null;\n            // didScheduleRenderPhaseUpdate = false;\n            // localIdCounter = 0;\n            // thenableIndexCounter = 0;\n            // thenableState = null;\n            // TODO Warn if no hooks are used at all during mount, then some are used during update.\n            // Currently we will identify the update render as a mount because memoizedState === null.\n            // This is tricky because it's valid for certain types of components (e.g. React.lazy)\n            // Using memoizedState to differentiate between mount/update only works if at least one stateful hook is used.\n            // Non-stateful hooks (e.g. context) don't get added to memoizedState,\n            // so memoizedState would be null during updates and mounts.\n            {\n                if (current !== null && current.memoizedState !== null) {\n                    ReactSharedInternals.H = HooksDispatcherOnUpdateInDEV;\n                } else if (hookTypesDev !== null) {\n                    // This dispatcher handles an edge case where a component is updating,\n                    // but no stateful hooks have been used.\n                    // We want to match the production code behavior (which will use HooksDispatcherOnMount),\n                    // but with the extra DEV validation to ensure hooks ordering hasn't changed.\n                    // This dispatcher does that.\n                    ReactSharedInternals.H = HooksDispatcherOnMountWithHookTypesInDEV;\n                } else {\n                    ReactSharedInternals.H = HooksDispatcherOnMountInDEV;\n                }\n            }\n            // help detect side effects. The logic for how this is implemented for in\n            // hook components is a bit complex so let's break it down.\n            //\n            // We will invoke the entire component function twice. However, during the\n            // second invocation of the component, the hook state from the first\n            // invocation will be reused. That means things like `useMemo` functions won't\n            // run again, because the deps will match and the memoized result will\n            // be reused.\n            //\n            // We want memoized functions to run twice, too, so account for this, user\n            // functions are double invoked during the *first* invocation of the component\n            // function, and are *not* double invoked during the second incovation:\n            //\n            // - First execution of component function: user functions are double invoked\n            // - Second execution of component function (in Strict Mode, during\n            //   development): user functions are not double invoked.\n            //\n            // This is intentional for a few reasons; most importantly, it's because of\n            // how `use` works when something suspends: it reuses the promise that was\n            // passed during the first attempt. This is itself a form of memoization.\n            // We need to be able to memoize the reactive inputs to the `use` call using\n            // a hook (i.e. `useMemo`), which means, the reactive inputs to `use` must\n            // come from the same component invocation as the output.\n            //\n            // There are plenty of tests to ensure this behavior is correct.\n            var shouldDoubleRenderDEV = (workInProgress.mode & StrictLegacyMode) !== NoMode;\n            shouldDoubleInvokeUserFnsInHooksDEV = shouldDoubleRenderDEV;\n            var children = Component(props, secondArg);\n            shouldDoubleInvokeUserFnsInHooksDEV = false; // Check if there was a render phase update\n            if (didScheduleRenderPhaseUpdateDuringThisPass) {\n                // Keep rendering until the component stabilizes (there are no more render\n                // phase updates).\n                children = renderWithHooksAgain(workInProgress, Component, props, secondArg);\n            }\n            if (shouldDoubleRenderDEV) {\n                // In development, components are invoked twice to help detect side effects.\n                setIsStrictModeForDevtools(true);\n                try {\n                    children = renderWithHooksAgain(workInProgress, Component, props, secondArg);\n                } finally{\n                    setIsStrictModeForDevtools(false);\n                }\n            }\n            finishRenderingHooks(current, workInProgress);\n            return children;\n        }\n        function finishRenderingHooks(current, workInProgress, Component) {\n            {\n                workInProgress._debugHookTypes = hookTypesDev;\n            }\n            // at the beginning of the render phase and there's no re-entrance.\n            ReactSharedInternals.H = ContextOnlyDispatcher; // This check uses currentHook so that it works the same in DEV and prod bundles.\n            // hookTypesDev could catch more cases (e.g. context) but only in DEV bundles.\n            var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;\n            renderLanes = NoLanes;\n            currentlyRenderingFiber$1 = null;\n            currentHook = null;\n            workInProgressHook = null;\n            {\n                currentHookNameInDev = null;\n                hookTypesDev = null;\n                hookTypesUpdateIndexDev = -1; // Confirm that a static flag was not added or removed since the last\n                // render. If this fires, it suggests that we incorrectly reset the static\n                // flags in some other part of the codebase. This has happened before, for\n                // example, in the SuspenseList implementation.\n                if (current !== null && (current.flags & StaticMask) !== (workInProgress.flags & StaticMask) && // and creates false positives. To make this work in legacy mode, we'd\n                // need to mark fibers that commit in an incomplete state, somehow. For\n                // now I'll disable the warning that most of the bugs that would trigger\n                // it are either exclusive to concurrent mode or exist in both.\n                disableLegacyMode) {\n                    error('Internal React error: Expected static flag was missing. Please ' + 'notify the React team.');\n                }\n            }\n            didScheduleRenderPhaseUpdate = false; // This is reset by checkDidRenderIdHook\n            // localIdCounter = 0;\n            thenableIndexCounter = 0;\n            thenableState = null;\n            if (didRenderTooFewHooks) {\n                throw new Error('Rendered fewer hooks than expected. This may be caused by an accidental ' + 'early return statement.');\n            }\n            {\n                if (checkIfUseWrappedInTryCatch()) {\n                    var componentName = getComponentNameFromFiber(workInProgress) || 'Unknown';\n                    if (!didWarnAboutUseWrappedInTryCatch.has(componentName) && // This warning also fires if you suspend with `use` inside an\n                    // async component. Since we warn for that above, we'll silence this\n                    // second warning by checking here.\n                    !didWarnAboutAsyncClientComponent.has(componentName)) {\n                        didWarnAboutUseWrappedInTryCatch.add(componentName);\n                        error('`use` was called from inside a try/catch block. This is not allowed ' + 'and can lead to unexpected behavior. To handle errors triggered ' + 'by `use`, wrap your component in a error boundary.');\n                    }\n                }\n            }\n        }\n        function replaySuspendedComponentWithHooks(current, workInProgress, Component, props, secondArg) {\n            // This function is used to replay a component that previously suspended,\n            // after its data resolves.\n            //\n            // It's a simplified version of renderWithHooks, but it doesn't need to do\n            // most of the set up work because they weren't reset when we suspended; they\n            // only get reset when the component either completes (finishRenderingHooks)\n            // or unwinds (resetHooksOnUnwind).\n            {\n                hookTypesUpdateIndexDev = -1; // Used for hot reloading:\n                ignorePreviousDependencies = current !== null && current.type !== workInProgress.type;\n            }\n            var children = renderWithHooksAgain(workInProgress, Component, props, secondArg);\n            finishRenderingHooks(current, workInProgress);\n            return children;\n        }\n        function renderWithHooksAgain(workInProgress, Component, props, secondArg) {\n            // This is used to perform another render pass. It's used when setState is\n            // called during render, and for double invoking components in Strict Mode\n            // during development.\n            //\n            // The state from the previous pass is reused whenever possible. So, state\n            // updates that were already processed are not processed again, and memoized\n            // functions (`useMemo`) are not invoked again.\n            //\n            // Keep rendering in a loop for as long as render phase updates continue to\n            // be scheduled. Use a counter to prevent infinite loops.\n            currentlyRenderingFiber$1 = workInProgress;\n            var numberOfReRenders = 0;\n            var children;\n            do {\n                if (didScheduleRenderPhaseUpdateDuringThisPass) {\n                    // It's possible that a use() value depended on a state that was updated in\n                    // this rerender, so we need to watch for different thenables this time.\n                    thenableState = null;\n                }\n                thenableIndexCounter = 0;\n                didScheduleRenderPhaseUpdateDuringThisPass = false;\n                if (numberOfReRenders >= RE_RENDER_LIMIT) {\n                    throw new Error('Too many re-renders. React limits the number of renders to prevent ' + 'an infinite loop.');\n                }\n                numberOfReRenders += 1;\n                {\n                    // Even when hot reloading, allow dependencies to stabilize\n                    // after first render to prevent infinite render phase updates.\n                    ignorePreviousDependencies = false;\n                }\n                currentHook = null;\n                workInProgressHook = null;\n                workInProgress.updateQueue = null;\n                {\n                    // Also validate hook order for cascading updates.\n                    hookTypesUpdateIndexDev = -1;\n                }\n                ReactSharedInternals.H = HooksDispatcherOnRerenderInDEV;\n                children = Component(props, secondArg);\n            }while (didScheduleRenderPhaseUpdateDuringThisPass);\n            return children;\n        }\n        function renderTransitionAwareHostComponentWithHooks(current, workInProgress, lanes) {\n            return renderWithHooks(current, workInProgress, TransitionAwareHostComponent, null, null, lanes);\n        }\n        function TransitionAwareHostComponent() {\n            var dispatcher = ReactSharedInternals.H;\n            var _dispatcher$useState = dispatcher.useState(), maybeThenable = _dispatcher$useState[0];\n            var nextState;\n            if (typeof maybeThenable.then === 'function') {\n                var thenable = maybeThenable;\n                nextState = useThenable(thenable);\n            } else {\n                var status = maybeThenable;\n                nextState = status;\n            } // The \"reset state\" is an object. If it changes, that means something\n            // requested that we reset the form.\n            var _dispatcher$useState2 = dispatcher.useState(), nextResetState = _dispatcher$useState2[0];\n            var prevResetState = currentHook !== null ? currentHook.memoizedState : null;\n            if (prevResetState !== nextResetState) {\n                // Schedule a form reset\n                currentlyRenderingFiber$1.flags |= FormReset;\n            }\n            return nextState;\n        }\n        function checkDidRenderIdHook() {\n            // This should be called immediately after every renderWithHooks call.\n            // Conceptually, it's part of the return value of renderWithHooks; it's only a\n            // separate function to avoid using an array tuple.\n            var didRenderIdHook = localIdCounter !== 0;\n            localIdCounter = 0;\n            return didRenderIdHook;\n        }\n        function bailoutHooks(current, workInProgress, lanes) {\n            workInProgress.updateQueue = current.updateQueue; // TODO: Don't need to reset the flags here, because they're reset in the\n            // complete phase (bubbleProperties).\n            if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                workInProgress.flags &= ~(MountPassiveDev | MountLayoutDev | Passive$1 | Update);\n            } else {\n                workInProgress.flags &= ~(Passive$1 | Update);\n            }\n            current.lanes = removeLanes(current.lanes, lanes);\n        }\n        function resetHooksAfterThrow() {\n            // This is called immediaetly after a throw. It shouldn't reset the entire\n            // module state, because the work loop might decide to replay the component\n            // again without rewinding.\n            //\n            // It should only reset things like the current dispatcher, to prevent hooks\n            // from being called outside of a component.\n            currentlyRenderingFiber$1 = null; // We can assume the previous dispatcher is always this one, since we set it\n            // at the beginning of the render phase and there's no re-entrance.\n            ReactSharedInternals.H = ContextOnlyDispatcher;\n        }\n        function resetHooksOnUnwind(workInProgress) {\n            if (didScheduleRenderPhaseUpdate) {\n                // There were render phase updates. These are only valid for this render\n                // phase, which we are now aborting. Remove the updates from the queues so\n                // they do not persist to the next render. Do not remove updates from hooks\n                // that weren't processed.\n                //\n                // Only reset the updates from the queue if it has a clone. If it does\n                // not have a clone, that means it wasn't processed, and the updates were\n                // scheduled before we entered the render phase.\n                var hook = workInProgress.memoizedState;\n                while(hook !== null){\n                    var queue = hook.queue;\n                    if (queue !== null) {\n                        queue.pending = null;\n                    }\n                    hook = hook.next;\n                }\n                didScheduleRenderPhaseUpdate = false;\n            }\n            renderLanes = NoLanes;\n            currentlyRenderingFiber$1 = null;\n            currentHook = null;\n            workInProgressHook = null;\n            {\n                hookTypesDev = null;\n                hookTypesUpdateIndexDev = -1;\n                currentHookNameInDev = null;\n            }\n            didScheduleRenderPhaseUpdateDuringThisPass = false;\n            localIdCounter = 0;\n            thenableIndexCounter = 0;\n            thenableState = null;\n        }\n        function mountWorkInProgressHook() {\n            var hook = {\n                memoizedState: null,\n                baseState: null,\n                baseQueue: null,\n                queue: null,\n                next: null\n            };\n            if (workInProgressHook === null) {\n                // This is the first hook in the list\n                currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;\n            } else {\n                // Append to the end of the list\n                workInProgressHook = workInProgressHook.next = hook;\n            }\n            return workInProgressHook;\n        }\n        function updateWorkInProgressHook() {\n            // This function is used both for updates and for re-renders triggered by a\n            // render phase update. It assumes there is either a current hook we can\n            // clone, or a work-in-progress hook from a previous render pass that we can\n            // use as a base.\n            var nextCurrentHook;\n            if (currentHook === null) {\n                var current = currentlyRenderingFiber$1.alternate;\n                if (current !== null) {\n                    nextCurrentHook = current.memoizedState;\n                } else {\n                    nextCurrentHook = null;\n                }\n            } else {\n                nextCurrentHook = currentHook.next;\n            }\n            var nextWorkInProgressHook;\n            if (workInProgressHook === null) {\n                nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;\n            } else {\n                nextWorkInProgressHook = workInProgressHook.next;\n            }\n            if (nextWorkInProgressHook !== null) {\n                // There's already a work-in-progress. Reuse it.\n                workInProgressHook = nextWorkInProgressHook;\n                nextWorkInProgressHook = workInProgressHook.next;\n                currentHook = nextCurrentHook;\n            } else {\n                // Clone from the current hook.\n                if (nextCurrentHook === null) {\n                    var currentFiber = currentlyRenderingFiber$1.alternate;\n                    if (currentFiber === null) {\n                        // This is the initial render. This branch is reached when the component\n                        // suspends, resumes, then renders an additional hook.\n                        // Should never be reached because we should switch to the mount dispatcher first.\n                        throw new Error('Update hook called on initial render. This is likely a bug in React. Please file an issue.');\n                    } else {\n                        // This is an update. We should always have a current hook.\n                        throw new Error('Rendered more hooks than during the previous render.');\n                    }\n                }\n                currentHook = nextCurrentHook;\n                var newHook = {\n                    memoizedState: currentHook.memoizedState,\n                    baseState: currentHook.baseState,\n                    baseQueue: currentHook.baseQueue,\n                    queue: currentHook.queue,\n                    next: null\n                };\n                if (workInProgressHook === null) {\n                    // This is the first hook in the list.\n                    currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;\n                } else {\n                    // Append to the end of the list.\n                    workInProgressHook = workInProgressHook.next = newHook;\n                }\n            }\n            return workInProgressHook;\n        } // NOTE: defining two versions of this function to avoid size impact when this feature is disabled.\n        // Previously this function was inlined, the additional `memoCache` property makes it not inlined.\n        var createFunctionComponentUpdateQueue;\n        {\n            createFunctionComponentUpdateQueue = function() {\n                return {\n                    lastEffect: null,\n                    events: null,\n                    stores: null,\n                    memoCache: null\n                };\n            };\n        }\n        function useThenable(thenable) {\n            // Track the position of the thenable within this fiber.\n            var index = thenableIndexCounter;\n            thenableIndexCounter += 1;\n            if (thenableState === null) {\n                thenableState = createThenableState();\n            }\n            var result = trackUsedThenable(thenableState, thenable, index);\n            if (currentlyRenderingFiber$1.alternate === null && (workInProgressHook === null ? currentlyRenderingFiber$1.memoizedState === null : workInProgressHook.next === null)) {\n                // Initial render, and either this is the first time the component is\n                // called, or there were no Hooks called after this use() the previous\n                // time (perhaps because it threw). Subsequent Hook calls should use the\n                // mount dispatcher.\n                {\n                    ReactSharedInternals.H = HooksDispatcherOnMountInDEV;\n                }\n            }\n            return result;\n        }\n        function use(usable) {\n            if (usable !== null && typeof usable === 'object') {\n                // $FlowFixMe[method-unbinding]\n                if (typeof usable.then === 'function') {\n                    // This is a thenable.\n                    var thenable = usable;\n                    return useThenable(thenable);\n                } else if (usable.$$typeof === REACT_CONTEXT_TYPE) {\n                    var context = usable;\n                    return readContext(context);\n                }\n            } // eslint-disable-next-line react-internal/safe-string-coercion\n            throw new Error('An unsupported type was passed to use(): ' + String(usable));\n        }\n        function useMemoCache(size) {\n            var memoCache = null; // Fast-path, load memo cache from wip fiber if already prepared\n            var updateQueue = currentlyRenderingFiber$1.updateQueue;\n            if (updateQueue !== null) {\n                memoCache = updateQueue.memoCache;\n            } // Otherwise clone from the current fiber\n            if (memoCache == null) {\n                var current = currentlyRenderingFiber$1.alternate;\n                if (current !== null) {\n                    var currentUpdateQueue = current.updateQueue;\n                    if (currentUpdateQueue !== null) {\n                        var currentMemoCache = currentUpdateQueue.memoCache;\n                        if (currentMemoCache != null) {\n                            memoCache = {\n                                // When enableNoCloningMemoCache is enabled, instead of treating the\n                                // cache as copy-on-write, like we do with fibers, we share the same\n                                // cache instance across all render attempts, even if the component\n                                // is interrupted before it commits.\n                                //\n                                // If an update is interrupted, either because it suspended or\n                                // because of another update, we can reuse the memoized computations\n                                // from the previous attempt. We can do this because the React\n                                // Compiler performs atomic writes to the memo cache, i.e. it will\n                                // not record the inputs to a memoization without also recording its\n                                // output.\n                                //\n                                // This gives us a form of \"resuming\" within components and hooks.\n                                //\n                                // This only works when updating a component that already mounted.\n                                // It has no impact during initial render, because the memo cache is\n                                // stored on the fiber, and since we have not implemented resuming\n                                // for fibers, it's always a fresh memo cache, anyway.\n                                //\n                                // However, this alone is pretty useful — it happens whenever you\n                                // update the UI with fresh data after a mutation/action, which is\n                                // extremely common in a Suspense-driven (e.g. RSC or Relay) app.\n                                data: currentMemoCache.data.map(function(array) {\n                                    return array.slice();\n                                }),\n                                index: 0\n                            };\n                        }\n                    }\n                }\n            } // Finally fall back to allocating a fresh instance of the cache\n            if (memoCache == null) {\n                memoCache = {\n                    data: [],\n                    index: 0\n                };\n            }\n            if (updateQueue === null) {\n                updateQueue = createFunctionComponentUpdateQueue();\n                currentlyRenderingFiber$1.updateQueue = updateQueue;\n            }\n            updateQueue.memoCache = memoCache;\n            var data = memoCache.data[memoCache.index];\n            if (data === undefined) {\n                data = memoCache.data[memoCache.index] = new Array(size);\n                for(var i = 0; i < size; i++){\n                    data[i] = REACT_MEMO_CACHE_SENTINEL;\n                }\n            } else if (data.length !== size) {\n                // TODO: consider warning or throwing here\n                {\n                    error('Expected a constant size argument for each invocation of useMemoCache. ' + 'The previous cache was allocated with size %s but size %s was requested.', data.length, size);\n                }\n            }\n            memoCache.index++;\n            return data;\n        }\n        function basicStateReducer(state, action) {\n            // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types\n            return typeof action === 'function' ? action(state) : action;\n        }\n        function mountReducer(reducer, initialArg, init) {\n            var hook = mountWorkInProgressHook();\n            var initialState;\n            if (init !== undefined) {\n                initialState = init(initialArg);\n                if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                    setIsStrictModeForDevtools(true);\n                    init(initialArg);\n                    setIsStrictModeForDevtools(false);\n                }\n            } else {\n                initialState = initialArg;\n            }\n            hook.memoizedState = hook.baseState = initialState;\n            var queue = {\n                pending: null,\n                lanes: NoLanes,\n                dispatch: null,\n                lastRenderedReducer: reducer,\n                lastRenderedState: initialState\n            };\n            hook.queue = queue;\n            var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);\n            return [\n                hook.memoizedState,\n                dispatch\n            ];\n        }\n        function updateReducer(reducer, initialArg, init) {\n            var hook = updateWorkInProgressHook();\n            return updateReducerImpl(hook, currentHook, reducer);\n        }\n        function updateReducerImpl(hook, current, reducer) {\n            var queue = hook.queue;\n            if (queue === null) {\n                throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');\n            }\n            queue.lastRenderedReducer = reducer; // The last rebase update that is NOT part of the base state.\n            var baseQueue = hook.baseQueue; // The last pending update that hasn't been processed yet.\n            var pendingQueue = queue.pending;\n            if (pendingQueue !== null) {\n                // We have new updates that haven't been processed yet.\n                // We'll add them to the base queue.\n                if (baseQueue !== null) {\n                    // Merge the pending queue and the base queue.\n                    var baseFirst = baseQueue.next;\n                    var pendingFirst = pendingQueue.next;\n                    baseQueue.next = pendingFirst;\n                    pendingQueue.next = baseFirst;\n                }\n                {\n                    if (current.baseQueue !== baseQueue) {\n                        // Internal invariant that should never happen, but feasibly could in\n                        // the future if we implement resuming, or some form of that.\n                        error('Internal error: Expected work-in-progress queue to be a clone. ' + 'This is a bug in React.');\n                    }\n                }\n                current.baseQueue = baseQueue = pendingQueue;\n                queue.pending = null;\n            }\n            var baseState = hook.baseState;\n            if (baseQueue === null) {\n                // If there are no pending updates, then the memoized state should be the\n                // same as the base state. Currently these only diverge in the case of\n                // useOptimistic, because useOptimistic accepts a new baseState on\n                // every render.\n                hook.memoizedState = baseState; // We don't need to call markWorkInProgressReceivedUpdate because\n            // baseState is derived from other reactive values.\n            } else {\n                // We have a queue to process.\n                var first = baseQueue.next;\n                var newState = baseState;\n                var newBaseState = null;\n                var newBaseQueueFirst = null;\n                var newBaseQueueLast = null;\n                var update = first;\n                var didReadFromEntangledAsyncAction = false;\n                do {\n                    // An extra OffscreenLane bit is added to updates that were made to\n                    // a hidden tree, so that we can distinguish them from updates that were\n                    // already there when the tree was hidden.\n                    var updateLane = removeLanes(update.lane, OffscreenLane);\n                    var isHiddenUpdate = updateLane !== update.lane; // Check if this update was made while the tree was hidden. If so, then\n                    // it's not a \"base\" update and we should disregard the extra base lanes\n                    // that were added to renderLanes when we entered the Offscreen tree.\n                    var shouldSkipUpdate = isHiddenUpdate ? !isSubsetOfLanes(getWorkInProgressRootRenderLanes(), updateLane) : !isSubsetOfLanes(renderLanes, updateLane);\n                    if (shouldSkipUpdate) {\n                        // Priority is insufficient. Skip this update. If this is the first\n                        // skipped update, the previous update/state is the new base\n                        // update/state.\n                        var clone = {\n                            lane: updateLane,\n                            revertLane: update.revertLane,\n                            action: update.action,\n                            hasEagerState: update.hasEagerState,\n                            eagerState: update.eagerState,\n                            next: null\n                        };\n                        if (newBaseQueueLast === null) {\n                            newBaseQueueFirst = newBaseQueueLast = clone;\n                            newBaseState = newState;\n                        } else {\n                            newBaseQueueLast = newBaseQueueLast.next = clone;\n                        } // Update the remaining priority in the queue.\n                        // TODO: Don't need to accumulate this. Instead, we can remove\n                        // renderLanes from the original lanes.\n                        currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);\n                        markSkippedUpdateLanes(updateLane);\n                    } else {\n                        // This update does have sufficient priority.\n                        // Check if this is an optimistic update.\n                        var revertLane = update.revertLane;\n                        if (revertLane === NoLane) {\n                            // This is not an optimistic update, and we're going to apply it now.\n                            // But, if there were earlier updates that were skipped, we need to\n                            // leave this update in the queue so it can be rebased later.\n                            if (newBaseQueueLast !== null) {\n                                var _clone = {\n                                    // This update is going to be committed so we never want uncommit\n                                    // it. Using NoLane works because 0 is a subset of all bitmasks, so\n                                    // this will never be skipped by the check above.\n                                    lane: NoLane,\n                                    revertLane: NoLane,\n                                    action: update.action,\n                                    hasEagerState: update.hasEagerState,\n                                    eagerState: update.eagerState,\n                                    next: null\n                                };\n                                newBaseQueueLast = newBaseQueueLast.next = _clone;\n                            } // Check if this update is part of a pending async action. If so,\n                            // we'll need to suspend until the action has finished, so that it's\n                            // batched together with future updates in the same action.\n                            if (updateLane === peekEntangledActionLane()) {\n                                didReadFromEntangledAsyncAction = true;\n                            }\n                        } else {\n                            // This is an optimistic update. If the \"revert\" priority is\n                            // sufficient, don't apply the update. Otherwise, apply the update,\n                            // but leave it in the queue so it can be either reverted or\n                            // rebased in a subsequent render.\n                            if (isSubsetOfLanes(renderLanes, revertLane)) {\n                                // The transition that this optimistic update is associated with\n                                // has finished. Pretend the update doesn't exist by skipping\n                                // over it.\n                                update = update.next; // Check if this update is part of a pending async action. If so,\n                                // we'll need to suspend until the action has finished, so that it's\n                                // batched together with future updates in the same action.\n                                if (revertLane === peekEntangledActionLane()) {\n                                    didReadFromEntangledAsyncAction = true;\n                                }\n                                continue;\n                            } else {\n                                var _clone2 = {\n                                    // Once we commit an optimistic update, we shouldn't uncommit it\n                                    // until the transition it is associated with has finished\n                                    // (represented by revertLane). Using NoLane here works because 0\n                                    // is a subset of all bitmasks, so this will never be skipped by\n                                    // the check above.\n                                    lane: NoLane,\n                                    // Reuse the same revertLane so we know when the transition\n                                    // has finished.\n                                    revertLane: update.revertLane,\n                                    action: update.action,\n                                    hasEagerState: update.hasEagerState,\n                                    eagerState: update.eagerState,\n                                    next: null\n                                };\n                                if (newBaseQueueLast === null) {\n                                    newBaseQueueFirst = newBaseQueueLast = _clone2;\n                                    newBaseState = newState;\n                                } else {\n                                    newBaseQueueLast = newBaseQueueLast.next = _clone2;\n                                } // Update the remaining priority in the queue.\n                                // TODO: Don't need to accumulate this. Instead, we can remove\n                                // renderLanes from the original lanes.\n                                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, revertLane);\n                                markSkippedUpdateLanes(revertLane);\n                            }\n                        } // Process this update.\n                        var action = update.action;\n                        if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                            reducer(newState, action);\n                        }\n                        if (update.hasEagerState) {\n                            // If this update is a state update (not a reducer) and was processed eagerly,\n                            // we can use the eagerly computed state\n                            newState = update.eagerState;\n                        } else {\n                            newState = reducer(newState, action);\n                        }\n                    }\n                    update = update.next;\n                }while (update !== null && update !== first);\n                if (newBaseQueueLast === null) {\n                    newBaseState = newState;\n                } else {\n                    newBaseQueueLast.next = newBaseQueueFirst;\n                } // Mark that the fiber performed work, but only if the new state is\n                // different from the current state.\n                if (!objectIs(newState, hook.memoizedState)) {\n                    markWorkInProgressReceivedUpdate(); // Check if this update is part of a pending async action. If so, we'll\n                    // need to suspend until the action has finished, so that it's batched\n                    // together with future updates in the same action.\n                    // TODO: Once we support hooks inside useMemo (or an equivalent\n                    // memoization boundary like Forget), hoist this logic so that it only\n                    // suspends if the memo boundary produces a new value.\n                    if (didReadFromEntangledAsyncAction) {\n                        var entangledActionThenable = peekEntangledActionThenable();\n                        if (entangledActionThenable !== null) {\n                            // TODO: Instead of the throwing the thenable directly, throw a\n                            // special object like `use` does so we can detect if it's captured\n                            // by userspace.\n                            throw entangledActionThenable;\n                        }\n                    }\n                }\n                hook.memoizedState = newState;\n                hook.baseState = newBaseState;\n                hook.baseQueue = newBaseQueueLast;\n                queue.lastRenderedState = newState;\n            }\n            if (baseQueue === null) {\n                // `queue.lanes` is used for entangling transitions. We can set it back to\n                // zero once the queue is empty.\n                queue.lanes = NoLanes;\n            }\n            var dispatch = queue.dispatch;\n            return [\n                hook.memoizedState,\n                dispatch\n            ];\n        }\n        function rerenderReducer(reducer, initialArg, init) {\n            var hook = updateWorkInProgressHook();\n            var queue = hook.queue;\n            if (queue === null) {\n                throw new Error('Should have a queue. This is likely a bug in React. Please file an issue.');\n            }\n            queue.lastRenderedReducer = reducer; // This is a re-render. Apply the new render phase updates to the previous\n            // work-in-progress hook.\n            var dispatch = queue.dispatch;\n            var lastRenderPhaseUpdate = queue.pending;\n            var newState = hook.memoizedState;\n            if (lastRenderPhaseUpdate !== null) {\n                // The queue doesn't persist past this render pass.\n                queue.pending = null;\n                var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;\n                var update = firstRenderPhaseUpdate;\n                do {\n                    // Process this render phase update. We don't have to check the\n                    // priority because it will always be the same as the current\n                    // render's.\n                    var action = update.action;\n                    newState = reducer(newState, action);\n                    update = update.next;\n                }while (update !== firstRenderPhaseUpdate); // Mark that the fiber performed work, but only if the new state is\n                // different from the current state.\n                if (!objectIs(newState, hook.memoizedState)) {\n                    markWorkInProgressReceivedUpdate();\n                }\n                hook.memoizedState = newState; // Don't persist the state accumulated from the render phase updates to\n                // the base state unless the queue is empty.\n                // TODO: Not sure if this is the desired semantics, but it's what we\n                // do for gDSFP. I can't remember why.\n                if (hook.baseQueue === null) {\n                    hook.baseState = newState;\n                }\n                queue.lastRenderedState = newState;\n            }\n            return [\n                newState,\n                dispatch\n            ];\n        }\n        function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n            var fiber = currentlyRenderingFiber$1;\n            var hook = mountWorkInProgressHook();\n            var nextSnapshot;\n            var isHydrating = getIsHydrating();\n            if (isHydrating) {\n                if (getServerSnapshot === undefined) {\n                    throw new Error('Missing getServerSnapshot, which is required for ' + 'server-rendered content. Will revert to client rendering.');\n                }\n                nextSnapshot = getServerSnapshot();\n                {\n                    if (!didWarnUncachedGetSnapshot) {\n                        if (nextSnapshot !== getServerSnapshot()) {\n                            error('The result of getServerSnapshot should be cached to avoid an infinite loop');\n                            didWarnUncachedGetSnapshot = true;\n                        }\n                    }\n                }\n            } else {\n                nextSnapshot = getSnapshot();\n                {\n                    if (!didWarnUncachedGetSnapshot) {\n                        var cachedSnapshot = getSnapshot();\n                        if (!objectIs(nextSnapshot, cachedSnapshot)) {\n                            error('The result of getSnapshot should be cached to avoid an infinite loop');\n                            didWarnUncachedGetSnapshot = true;\n                        }\n                    }\n                }\n                // Right before committing, we will walk the tree and check if any of the\n                // stores were mutated.\n                //\n                // We won't do this if we're hydrating server-rendered content, because if\n                // the content is stale, it's already visible anyway. Instead we'll patch\n                // it up in a passive effect.\n                var root = getWorkInProgressRoot();\n                if (root === null) {\n                    throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');\n                }\n                var rootRenderLanes = getWorkInProgressRootRenderLanes();\n                if (!includesBlockingLane(root, rootRenderLanes)) {\n                    pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n                }\n            } // Read the current snapshot from the store on every render. This breaks the\n            // normal rules of React, and only works because store updates are\n            // always synchronous.\n            hook.memoizedState = nextSnapshot;\n            var inst = {\n                value: nextSnapshot,\n                getSnapshot: getSnapshot\n            };\n            hook.queue = inst; // Schedule an effect to subscribe to the store.\n            mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [\n                subscribe\n            ]); // Schedule an effect to update the mutable instance fields. We will update\n            // this whenever subscribe, getSnapshot, or value changes. Because there's no\n            // clean-up function, and we track the deps correctly, we can call pushEffect\n            // directly, without storing any additional state. For the same reason, we\n            // don't need to set a static flag, either.\n            fiber.flags |= Passive$1;\n            pushEffect(HasEffect | Passive, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), createEffectInstance(), null);\n            return nextSnapshot;\n        }\n        function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n            var fiber = currentlyRenderingFiber$1;\n            var hook = updateWorkInProgressHook(); // Read the current snapshot from the store on every render. This breaks the\n            // normal rules of React, and only works because store updates are\n            // always synchronous.\n            var nextSnapshot;\n            var isHydrating = getIsHydrating();\n            if (isHydrating) {\n                // Needed for strict mode double render\n                if (getServerSnapshot === undefined) {\n                    throw new Error('Missing getServerSnapshot, which is required for ' + 'server-rendered content. Will revert to client rendering.');\n                }\n                nextSnapshot = getServerSnapshot();\n            } else {\n                nextSnapshot = getSnapshot();\n                {\n                    if (!didWarnUncachedGetSnapshot) {\n                        var cachedSnapshot = getSnapshot();\n                        if (!objectIs(nextSnapshot, cachedSnapshot)) {\n                            error('The result of getSnapshot should be cached to avoid an infinite loop');\n                            didWarnUncachedGetSnapshot = true;\n                        }\n                    }\n                }\n            }\n            var prevSnapshot = (currentHook || hook).memoizedState;\n            var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);\n            if (snapshotChanged) {\n                hook.memoizedState = nextSnapshot;\n                markWorkInProgressReceivedUpdate();\n            }\n            var inst = hook.queue;\n            updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [\n                subscribe\n            ]); // Whenever getSnapshot or subscribe changes, we need to check in the\n            // commit phase if there was an interleaved mutation. In concurrent mode\n            // this can happen all the time, but even in synchronous mode, an earlier\n            // effect may have mutated the store.\n            if (inst.getSnapshot !== getSnapshot || snapshotChanged || // Check if the subscribe function changed. We can save some memory by\n            // checking whether we scheduled a subscription effect above.\n            workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {\n                fiber.flags |= Passive$1;\n                pushEffect(HasEffect | Passive, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), createEffectInstance(), null); // Unless we're rendering a blocking lane, schedule a consistency check.\n                // Right before committing, we will walk the tree and check if any of the\n                // stores were mutated.\n                var root = getWorkInProgressRoot();\n                if (root === null) {\n                    throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');\n                }\n                if (!isHydrating && !includesBlockingLane(root, renderLanes)) {\n                    pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);\n                }\n            }\n            return nextSnapshot;\n        }\n        function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\n            fiber.flags |= StoreConsistency;\n            var check = {\n                getSnapshot: getSnapshot,\n                value: renderedSnapshot\n            };\n            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;\n            if (componentUpdateQueue === null) {\n                componentUpdateQueue = createFunctionComponentUpdateQueue();\n                currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;\n                componentUpdateQueue.stores = [\n                    check\n                ];\n            } else {\n                var stores = componentUpdateQueue.stores;\n                if (stores === null) {\n                    componentUpdateQueue.stores = [\n                        check\n                    ];\n                } else {\n                    stores.push(check);\n                }\n            }\n        }\n        function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\n            // These are updated in the passive phase\n            inst.value = nextSnapshot;\n            inst.getSnapshot = getSnapshot; // Something may have been mutated in between render and commit. This could\n            // have been in an event that fired before the passive effects, or it could\n            // have been in a layout effect. In that case, we would have used the old\n            // snapsho and getSnapshot values to bail out. We need to check one more time.\n            if (checkIfSnapshotChanged(inst)) {\n                // Force a re-render.\n                forceStoreRerender(fiber);\n            }\n        }\n        function subscribeToStore(fiber, inst, subscribe) {\n            var handleStoreChange = function() {\n                // The store changed. Check if the snapshot changed since the last time we\n                // read from the store.\n                if (checkIfSnapshotChanged(inst)) {\n                    // Force a re-render.\n                    forceStoreRerender(fiber);\n                }\n            }; // Subscribe to the store and return a clean-up function.\n            return subscribe(handleStoreChange);\n        }\n        function checkIfSnapshotChanged(inst) {\n            var latestGetSnapshot = inst.getSnapshot;\n            var prevValue = inst.value;\n            try {\n                var nextValue = latestGetSnapshot();\n                return !objectIs(prevValue, nextValue);\n            } catch (error) {\n                return true;\n            }\n        }\n        function forceStoreRerender(fiber) {\n            var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n            if (root !== null) {\n                scheduleUpdateOnFiber(root, fiber, SyncLane);\n            }\n        }\n        function mountStateImpl(initialState) {\n            var hook = mountWorkInProgressHook();\n            if (typeof initialState === 'function') {\n                var initialStateInitializer = initialState; // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types\n                initialState = initialStateInitializer();\n                if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                    setIsStrictModeForDevtools(true); // $FlowFixMe[incompatible-use]: Flow doesn't like mixed types\n                    initialStateInitializer();\n                    setIsStrictModeForDevtools(false);\n                }\n            }\n            hook.memoizedState = hook.baseState = initialState;\n            var queue = {\n                pending: null,\n                lanes: NoLanes,\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: initialState\n            };\n            hook.queue = queue;\n            return hook;\n        }\n        function mountState(initialState) {\n            var hook = mountStateImpl(initialState);\n            var queue = hook.queue;\n            var dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);\n            queue.dispatch = dispatch;\n            return [\n                hook.memoizedState,\n                dispatch\n            ];\n        }\n        function updateState(initialState) {\n            return updateReducer(basicStateReducer);\n        }\n        function rerenderState(initialState) {\n            return rerenderReducer(basicStateReducer);\n        }\n        function mountOptimistic(passthrough, reducer) {\n            var hook = mountWorkInProgressHook();\n            hook.memoizedState = hook.baseState = passthrough;\n            var queue = {\n                pending: null,\n                lanes: NoLanes,\n                dispatch: null,\n                // Optimistic state does not use the eager update optimization.\n                lastRenderedReducer: null,\n                lastRenderedState: null\n            };\n            hook.queue = queue; // This is different than the normal setState function.\n            var dispatch = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, true, queue);\n            queue.dispatch = dispatch;\n            return [\n                passthrough,\n                dispatch\n            ];\n        }\n        function updateOptimistic(passthrough, reducer) {\n            var hook = updateWorkInProgressHook();\n            return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n        }\n        function updateOptimisticImpl(hook, current, passthrough, reducer) {\n            // Optimistic updates are always rebased on top of the latest value passed in\n            // as an argument. It's called a passthrough because if there are no pending\n            // updates, it will be returned as-is.\n            //\n            // Reset the base state to the passthrough. Future updates will be applied\n            // on top of this.\n            hook.baseState = passthrough; // If a reducer is not provided, default to the same one used by useState.\n            var resolvedReducer = typeof reducer === 'function' ? reducer : basicStateReducer;\n            return updateReducerImpl(hook, currentHook, resolvedReducer);\n        }\n        function rerenderOptimistic(passthrough, reducer) {\n            // Unlike useState, useOptimistic doesn't support render phase updates.\n            // Also unlike useState, we need to replay all pending updates again in case\n            // the passthrough value changed.\n            //\n            // So instead of a forked re-render implementation that knows how to handle\n            // render phase udpates, we can use the same implementation as during a\n            // regular mount or update.\n            var hook = updateWorkInProgressHook();\n            if (currentHook !== null) {\n                // This is an update. Process the update queue.\n                return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n            } // This is a mount. No updates to process.\n            // Reset the base state to the passthrough. Future updates will be applied\n            // on top of this.\n            hook.baseState = passthrough;\n            var dispatch = hook.queue.dispatch;\n            return [\n                passthrough,\n                dispatch\n            ];\n        } // useActionState actions run sequentially, because each action receives the\n        // previous state as an argument. We store pending actions on a queue.\n        function dispatchActionState(fiber, actionQueue, setPendingState, setState, payload) {\n            if (isRenderPhaseUpdate(fiber)) {\n                throw new Error('Cannot update form state while rendering.');\n            }\n            var last = actionQueue.pending;\n            if (last === null) {\n                // There are no pending actions; this is the first one. We can run\n                // it immediately.\n                var newLast = {\n                    payload: payload,\n                    next: null // circular\n                };\n                newLast.next = actionQueue.pending = newLast;\n                runActionStateAction(actionQueue, setPendingState, setState, payload);\n            } else {\n                // There's already an action running. Add to the queue.\n                var first = last.next;\n                var _newLast = {\n                    payload: payload,\n                    next: first\n                };\n                actionQueue.pending = last.next = _newLast;\n            }\n        }\n        function runActionStateAction(actionQueue, setPendingState, setState, payload) {\n            var action = actionQueue.action;\n            var prevState = actionQueue.state; // This is a fork of startTransition\n            var prevTransition = ReactSharedInternals.T;\n            var currentTransition = {};\n            ReactSharedInternals.T = currentTransition;\n            {\n                ReactSharedInternals.T._updatedFibers = new Set();\n            }\n            // This will be reverted automatically when all actions are finished.\n            setPendingState(true);\n            try {\n                var returnValue = action(prevState, payload);\n                var onStartTransitionFinish = ReactSharedInternals.S;\n                if (onStartTransitionFinish !== null) {\n                    onStartTransitionFinish(currentTransition, returnValue);\n                }\n                if (returnValue !== null && typeof returnValue === 'object' && // $FlowFixMe[method-unbinding]\n                typeof returnValue.then === 'function') {\n                    var thenable = returnValue; // Attach a listener to read the return state of the action. As soon as\n                    // this resolves, we can run the next action in the sequence.\n                    thenable.then(function(nextState) {\n                        actionQueue.state = nextState;\n                        finishRunningActionStateAction(actionQueue, setPendingState, setState);\n                    }, function() {\n                        return finishRunningActionStateAction(actionQueue, setPendingState, setState);\n                    });\n                    setState(thenable);\n                } else {\n                    setState(returnValue);\n                    var nextState = returnValue;\n                    actionQueue.state = nextState;\n                    finishRunningActionStateAction(actionQueue, setPendingState, setState);\n                }\n            } catch (error) {\n                // This is a trick to get the `useActionState` hook to rethrow the error.\n                // When it unwraps the thenable with the `use` algorithm, the error\n                // will be thrown.\n                var rejectedThenable = {\n                    then: function() {},\n                    status: 'rejected',\n                    reason: error // $FlowFixMe: Not sure why this doesn't work\n                };\n                setState(rejectedThenable);\n                finishRunningActionStateAction(actionQueue, setPendingState, setState);\n            } finally{\n                ReactSharedInternals.T = prevTransition;\n                {\n                    if (prevTransition === null && currentTransition._updatedFibers) {\n                        var updatedFibersCount = currentTransition._updatedFibers.size;\n                        currentTransition._updatedFibers.clear();\n                        if (updatedFibersCount > 10) {\n                            warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');\n                        }\n                    }\n                }\n            }\n        }\n        function finishRunningActionStateAction(actionQueue, setPendingState, setState) {\n            // The action finished running. Pop it from the queue and run the next pending\n            // action, if there are any.\n            var last = actionQueue.pending;\n            if (last !== null) {\n                var first = last.next;\n                if (first === last) {\n                    // This was the last action in the queue.\n                    actionQueue.pending = null;\n                } else {\n                    // Remove the first node from the circular queue.\n                    var next = first.next;\n                    last.next = next; // Run the next action.\n                    runActionStateAction(actionQueue, setPendingState, setState, next.payload);\n                }\n            }\n        }\n        function actionStateReducer(oldState, newState) {\n            return newState;\n        }\n        function mountActionState(action, initialStateProp, permalink) {\n            var initialState = initialStateProp;\n            if (getIsHydrating()) {\n                var root = getWorkInProgressRoot();\n                var ssrFormState = root.formState; // If a formState option was passed to the root, there are form state\n                // markers that we need to hydrate. These indicate whether the form state\n                // matches this hook instance.\n                if (ssrFormState !== null) {\n                    var isMatching = tryToClaimNextHydratableFormMarkerInstance(currentlyRenderingFiber$1);\n                    if (isMatching) {\n                        initialState = ssrFormState[0];\n                    }\n                }\n            } // State hook. The state is stored in a thenable which is then unwrapped by\n            // the `use` algorithm during render.\n            var stateHook = mountWorkInProgressHook();\n            stateHook.memoizedState = stateHook.baseState = initialState; // TODO: Typing this \"correctly\" results in recursion limit errors\n            // const stateQueue: UpdateQueue<S | Awaited<S>, S | Awaited<S>> = {\n            var stateQueue = {\n                pending: null,\n                lanes: NoLanes,\n                dispatch: null,\n                lastRenderedReducer: actionStateReducer,\n                lastRenderedState: initialState\n            };\n            stateHook.queue = stateQueue;\n            var setState = dispatchSetState.bind(null, currentlyRenderingFiber$1, stateQueue);\n            stateQueue.dispatch = setState; // Pending state. This is used to store the pending state of the action.\n            // Tracked optimistically, like a transition pending state.\n            var pendingStateHook = mountStateImpl(false);\n            var setPendingState = dispatchOptimisticSetState.bind(null, currentlyRenderingFiber$1, false, pendingStateHook.queue); // Action queue hook. This is used to queue pending actions. The queue is\n            // shared between all instances of the hook. Similar to a regular state queue,\n            // but different because the actions are run sequentially, and they run in\n            // an event instead of during render.\n            var actionQueueHook = mountWorkInProgressHook();\n            var actionQueue = {\n                state: initialState,\n                dispatch: null,\n                // circular\n                action: action,\n                pending: null\n            };\n            actionQueueHook.queue = actionQueue;\n            var dispatch = dispatchActionState.bind(null, currentlyRenderingFiber$1, actionQueue, setPendingState, setState);\n            actionQueue.dispatch = dispatch; // Stash the action function on the memoized state of the hook. We'll use this\n            // to detect when the action function changes so we can update it in\n            // an effect.\n            actionQueueHook.memoizedState = action;\n            return [\n                initialState,\n                dispatch,\n                false\n            ];\n        }\n        function updateActionState(action, initialState, permalink) {\n            var stateHook = updateWorkInProgressHook();\n            var currentStateHook = currentHook;\n            return updateActionStateImpl(stateHook, currentStateHook, action);\n        }\n        function updateActionStateImpl(stateHook, currentStateHook, action, initialState, permalink) {\n            var _updateReducerImpl = updateReducerImpl(stateHook, currentStateHook, actionStateReducer), actionResult = _updateReducerImpl[0];\n            var _updateState = updateState(), isPending = _updateState[0]; // This will suspend until the action finishes.\n            var state = typeof actionResult === 'object' && actionResult !== null && // $FlowFixMe[method-unbinding]\n            typeof actionResult.then === 'function' ? useThenable(actionResult) : actionResult;\n            var actionQueueHook = updateWorkInProgressHook();\n            var actionQueue = actionQueueHook.queue;\n            var dispatch = actionQueue.dispatch; // Check if a new action was passed. If so, update it in an effect.\n            var prevAction = actionQueueHook.memoizedState;\n            if (action !== prevAction) {\n                currentlyRenderingFiber$1.flags |= Passive$1;\n                pushEffect(HasEffect | Passive, actionStateActionEffect.bind(null, actionQueue, action), createEffectInstance(), null);\n            }\n            return [\n                state,\n                dispatch,\n                isPending\n            ];\n        }\n        function actionStateActionEffect(actionQueue, action) {\n            actionQueue.action = action;\n        }\n        function rerenderActionState(action, initialState, permalink) {\n            // Unlike useState, useActionState doesn't support render phase updates.\n            // Also unlike useState, we need to replay all pending updates again in case\n            // the passthrough value changed.\n            //\n            // So instead of a forked re-render implementation that knows how to handle\n            // render phase udpates, we can use the same implementation as during a\n            // regular mount or update.\n            var stateHook = updateWorkInProgressHook();\n            var currentStateHook = currentHook;\n            if (currentStateHook !== null) {\n                // This is an update. Process the update queue.\n                return updateActionStateImpl(stateHook, currentStateHook, action);\n            }\n            updateWorkInProgressHook(); // State\n            // This is a mount. No updates to process.\n            var state = stateHook.memoizedState;\n            var actionQueueHook = updateWorkInProgressHook();\n            var actionQueue = actionQueueHook.queue;\n            var dispatch = actionQueue.dispatch; // This may have changed during the rerender.\n            actionQueueHook.memoizedState = action; // For mount, pending is always false.\n            return [\n                state,\n                dispatch,\n                false\n            ];\n        }\n        function pushEffect(tag, create, inst, deps) {\n            var effect = {\n                tag: tag,\n                create: create,\n                inst: inst,\n                deps: deps,\n                // Circular\n                next: null\n            };\n            var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;\n            if (componentUpdateQueue === null) {\n                componentUpdateQueue = createFunctionComponentUpdateQueue();\n                currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;\n                componentUpdateQueue.lastEffect = effect.next = effect;\n            } else {\n                var lastEffect = componentUpdateQueue.lastEffect;\n                if (lastEffect === null) {\n                    componentUpdateQueue.lastEffect = effect.next = effect;\n                } else {\n                    var firstEffect = lastEffect.next;\n                    lastEffect.next = effect;\n                    effect.next = firstEffect;\n                    componentUpdateQueue.lastEffect = effect;\n                }\n            }\n            return effect;\n        }\n        function createEffectInstance() {\n            return {\n                destroy: undefined\n            };\n        }\n        function mountRef(initialValue) {\n            var hook = mountWorkInProgressHook();\n            var ref = {\n                current: initialValue\n            };\n            hook.memoizedState = ref;\n            return ref;\n        }\n        function updateRef(initialValue) {\n            var hook = updateWorkInProgressHook();\n            return hook.memoizedState;\n        }\n        function mountEffectImpl(fiberFlags, hookFlags, create, deps) {\n            var hook = mountWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            currentlyRenderingFiber$1.flags |= fiberFlags;\n            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, createEffectInstance(), nextDeps);\n        }\n        function updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n            var hook = updateWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            var effect = hook.memoizedState;\n            var inst = effect.inst; // currentHook is null on initial mount when rerendering after a render phase\n            // state update or for strict mode.\n            if (currentHook !== null) {\n                if (nextDeps !== null) {\n                    var prevEffect = currentHook.memoizedState;\n                    var prevDeps = prevEffect.deps;\n                    if (areHookInputsEqual(nextDeps, prevDeps)) {\n                        hook.memoizedState = pushEffect(hookFlags, create, inst, nextDeps);\n                        return;\n                    }\n                }\n            }\n            currentlyRenderingFiber$1.flags |= fiberFlags;\n            hook.memoizedState = pushEffect(HasEffect | hookFlags, create, inst, nextDeps);\n        }\n        function mountEffect(create, deps) {\n            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode && (currentlyRenderingFiber$1.mode & NoStrictPassiveEffectsMode) === NoMode) {\n                mountEffectImpl(MountPassiveDev | Passive$1 | PassiveStatic, Passive, create, deps);\n            } else {\n                mountEffectImpl(Passive$1 | PassiveStatic, Passive, create, deps);\n            }\n        }\n        function updateEffect(create, deps) {\n            updateEffectImpl(Passive$1, Passive, create, deps);\n        }\n        function mountInsertionEffect(create, deps) {\n            mountEffectImpl(Update, Insertion, create, deps);\n        }\n        function updateInsertionEffect(create, deps) {\n            return updateEffectImpl(Update, Insertion, create, deps);\n        }\n        function mountLayoutEffect(create, deps) {\n            var fiberFlags = Update | LayoutStatic;\n            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n                fiberFlags |= MountLayoutDev;\n            }\n            return mountEffectImpl(fiberFlags, Layout, create, deps);\n        }\n        function updateLayoutEffect(create, deps) {\n            return updateEffectImpl(Update, Layout, create, deps);\n        }\n        function imperativeHandleEffect(create, ref) {\n            if (typeof ref === 'function') {\n                var refCallback = ref;\n                var inst = create();\n                var refCleanup = refCallback(inst);\n                return function() {\n                    if (typeof refCleanup === 'function') {\n                        // $FlowFixMe[incompatible-use] we need to assume no parameters\n                        refCleanup();\n                    } else {\n                        refCallback(null);\n                    }\n                };\n            } else if (ref !== null && ref !== undefined) {\n                var refObject = ref;\n                {\n                    if (!refObject.hasOwnProperty('current')) {\n                        error('Expected useImperativeHandle() first argument to either be a ' + 'ref callback or React.createRef() object. Instead received: %s.', 'an object with keys {' + Object.keys(refObject).join(', ') + '}');\n                    }\n                }\n                var _inst = create();\n                refObject.current = _inst;\n                return function() {\n                    refObject.current = null;\n                };\n            }\n        }\n        function mountImperativeHandle(ref, create, deps) {\n            {\n                if (typeof create !== 'function') {\n                    error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');\n                }\n            }\n            var effectDeps = deps !== null && deps !== undefined ? deps.concat([\n                ref\n            ]) : null;\n            var fiberFlags = Update | LayoutStatic;\n            if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {\n                fiberFlags |= MountLayoutDev;\n            }\n            mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n        }\n        function updateImperativeHandle(ref, create, deps) {\n            {\n                if (typeof create !== 'function') {\n                    error('Expected useImperativeHandle() second argument to be a function ' + 'that creates a handle. Instead received: %s.', create !== null ? typeof create : 'null');\n                }\n            }\n            var effectDeps = deps !== null && deps !== undefined ? deps.concat([\n                ref\n            ]) : null;\n            updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);\n        }\n        function mountDebugValue(value, formatterFn) {\n        // The react-debug-hooks package injects its own implementation\n        // so that e.g. DevTools can display custom hook values.\n        }\n        var updateDebugValue = mountDebugValue;\n        function mountCallback(callback, deps) {\n            var hook = mountWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            hook.memoizedState = [\n                callback,\n                nextDeps\n            ];\n            return callback;\n        }\n        function updateCallback(callback, deps) {\n            var hook = updateWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            var prevState = hook.memoizedState;\n            if (nextDeps !== null) {\n                var prevDeps = prevState[1];\n                if (areHookInputsEqual(nextDeps, prevDeps)) {\n                    return prevState[0];\n                }\n            }\n            hook.memoizedState = [\n                callback,\n                nextDeps\n            ];\n            return callback;\n        }\n        function mountMemo(nextCreate, deps) {\n            var hook = mountWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            var nextValue = nextCreate();\n            if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                setIsStrictModeForDevtools(true);\n                nextCreate();\n                setIsStrictModeForDevtools(false);\n            }\n            hook.memoizedState = [\n                nextValue,\n                nextDeps\n            ];\n            return nextValue;\n        }\n        function updateMemo(nextCreate, deps) {\n            var hook = updateWorkInProgressHook();\n            var nextDeps = deps === undefined ? null : deps;\n            var prevState = hook.memoizedState; // Assume these are defined. If they're not, areHookInputsEqual will warn.\n            if (nextDeps !== null) {\n                var prevDeps = prevState[1];\n                if (areHookInputsEqual(nextDeps, prevDeps)) {\n                    return prevState[0];\n                }\n            }\n            var nextValue = nextCreate();\n            if (shouldDoubleInvokeUserFnsInHooksDEV) {\n                setIsStrictModeForDevtools(true);\n                nextCreate();\n                setIsStrictModeForDevtools(false);\n            }\n            hook.memoizedState = [\n                nextValue,\n                nextDeps\n            ];\n            return nextValue;\n        }\n        function mountDeferredValue(value, initialValue) {\n            var hook = mountWorkInProgressHook();\n            return mountDeferredValueImpl(hook, value, initialValue);\n        }\n        function updateDeferredValue(value, initialValue) {\n            var hook = updateWorkInProgressHook();\n            var resolvedCurrentHook = currentHook;\n            var prevValue = resolvedCurrentHook.memoizedState;\n            return updateDeferredValueImpl(hook, prevValue, value, initialValue);\n        }\n        function rerenderDeferredValue(value, initialValue) {\n            var hook = updateWorkInProgressHook();\n            if (currentHook === null) {\n                // This is a rerender during a mount.\n                return mountDeferredValueImpl(hook, value, initialValue);\n            } else {\n                // This is a rerender during an update.\n                var prevValue = currentHook.memoizedState;\n                return updateDeferredValueImpl(hook, prevValue, value, initialValue);\n            }\n        }\n        function mountDeferredValueImpl(hook, value, initialValue) {\n            if (// current render is not synchronous.\n            initialValue !== undefined && // However, to avoid waterfalls, we do not defer if this render\n            // was itself spawned by an earlier useDeferredValue. Check if DeferredLane\n            // is part of the render lanes.\n            !includesSomeLane(renderLanes, DeferredLane)) {\n                // Render with the initial value\n                hook.memoizedState = initialValue; // Schedule a deferred render to switch to the final value.\n                var deferredLane = requestDeferredLane();\n                currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);\n                markSkippedUpdateLanes(deferredLane);\n                return initialValue;\n            } else {\n                hook.memoizedState = value;\n                return value;\n            }\n        }\n        function updateDeferredValueImpl(hook, prevValue, value, initialValue) {\n            if (objectIs(value, prevValue)) {\n                // The incoming value is referentially identical to the currently rendered\n                // value, so we can bail out quickly.\n                return value;\n            } else {\n                // Received a new value that's different from the current value.\n                // Check if we're inside a hidden tree\n                if (isCurrentTreeHidden()) {\n                    // Revealing a prerendered tree is considered the same as mounting new\n                    // one, so we reuse the \"mount\" path in this case.\n                    var resultValue = mountDeferredValueImpl(hook, value, initialValue); // Unlike during an actual mount, we need to mark this as an update if\n                    // the value changed.\n                    if (!objectIs(resultValue, prevValue)) {\n                        markWorkInProgressReceivedUpdate();\n                    }\n                    return resultValue;\n                }\n                var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);\n                if (shouldDeferValue) {\n                    // This is an urgent update. Since the value has changed, keep using the\n                    // previous value and spawn a deferred render to update it later.\n                    // Schedule a deferred render\n                    var deferredLane = requestDeferredLane();\n                    currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);\n                    markSkippedUpdateLanes(deferredLane); // Reuse the previous value. We do not need to mark this as an update,\n                    // because we did not render a new value.\n                    return prevValue;\n                } else {\n                    // This is not an urgent update, so we can use the latest value regardless\n                    // of what it is. No need to defer it.\n                    // Mark this as an update to prevent the fiber from bailing out.\n                    markWorkInProgressReceivedUpdate();\n                    hook.memoizedState = value;\n                    return value;\n                }\n            }\n        }\n        function startTransition(fiber, queue, pendingState, finishedState, callback, options) {\n            var previousPriority = getCurrentUpdatePriority();\n            setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));\n            var prevTransition = ReactSharedInternals.T;\n            var currentTransition = {};\n            {\n                // We don't really need to use an optimistic update here, because we\n                // schedule a second \"revert\" update below (which we use to suspend the\n                // transition until the async action scope has finished). But we'll use an\n                // optimistic update anyway to make it less likely the behavior accidentally\n                // diverges; for example, both an optimistic update and this one should\n                // share the same lane.\n                ReactSharedInternals.T = currentTransition;\n                dispatchOptimisticSetState(fiber, false, queue, pendingState);\n            }\n            {\n                currentTransition._updatedFibers = new Set();\n            }\n            try {\n                if (enableAsyncActions) {\n                    var returnValue = callback();\n                    var onStartTransitionFinish = ReactSharedInternals.S;\n                    if (onStartTransitionFinish !== null) {\n                        onStartTransitionFinish(currentTransition, returnValue);\n                    } // Check if we're inside an async action scope. If so, we'll entangle\n                    // this new action with the existing scope.\n                    //\n                    // If we're not already inside an async action scope, and this action is\n                    // async, then we'll create a new async scope.\n                    //\n                    // In the async case, the resulting render will suspend until the async\n                    // action scope has finished.\n                    if (returnValue !== null && typeof returnValue === 'object' && typeof returnValue.then === 'function') {\n                        var thenable = returnValue; // Create a thenable that resolves to `finishedState` once the async\n                        // action has completed.\n                        var thenableForFinishedState = chainThenableValue(thenable, finishedState);\n                        dispatchSetState(fiber, queue, thenableForFinishedState);\n                    } else {\n                        dispatchSetState(fiber, queue, finishedState);\n                    }\n                }\n            } catch (error) {\n                {\n                    // This is a trick to get the `useTransition` hook to rethrow the error.\n                    // When it unwraps the thenable with the `use` algorithm, the error\n                    // will be thrown.\n                    var rejectedThenable = {\n                        then: function() {},\n                        status: 'rejected',\n                        reason: error\n                    };\n                    dispatchSetState(fiber, queue, rejectedThenable);\n                }\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactSharedInternals.T = prevTransition;\n                {\n                    if (prevTransition === null && currentTransition._updatedFibers) {\n                        var updatedFibersCount = currentTransition._updatedFibers.size;\n                        currentTransition._updatedFibers.clear();\n                        if (updatedFibersCount > 10) {\n                            warn('Detected a large number of updates inside startTransition. ' + 'If this is due to a subscription please re-write it to use React provided hooks. ' + 'Otherwise concurrent mode guarantees are off the table.');\n                        }\n                    }\n                }\n            }\n        }\n        var noop = function() {};\n        function startHostTransition(formFiber, pendingState, action, formData) {\n            if (formFiber.tag !== HostComponent) {\n                throw new Error('Expected the form instance to be a HostComponent. This ' + 'is a bug in React.');\n            }\n            var stateHook = ensureFormComponentIsStateful(formFiber);\n            var queue = stateHook.queue;\n            startTransition(formFiber, queue, pendingState, NotPendingTransition, // the action, if one is provided. Consider refactoring these two\n            // concerns to avoid the extra lambda.\n            action === null ? // set the pending form status.\n            noop : function() {\n                // Automatically reset the form when the action completes.\n                requestFormReset(formFiber);\n                return action(formData);\n            });\n        }\n        function ensureFormComponentIsStateful(formFiber) {\n            var existingStateHook = formFiber.memoizedState;\n            if (existingStateHook !== null) {\n                // This fiber was already upgraded to be stateful.\n                return existingStateHook;\n            } // Upgrade this host component fiber to be stateful. We're going to pretend\n            // it was stateful all along so we can reuse most of the implementation\n            // for function components and useTransition.\n            //\n            // Create the state hook used by TransitionAwareHostComponent. This is\n            // essentially an inlined version of mountState.\n            var newQueue = {\n                pending: null,\n                lanes: NoLanes,\n                // We're going to cheat and intentionally not create a bound dispatch\n                // method, because we can call it directly in startTransition.\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: NotPendingTransition\n            };\n            var stateHook = {\n                memoizedState: NotPendingTransition,\n                baseState: NotPendingTransition,\n                baseQueue: null,\n                queue: newQueue,\n                next: null\n            }; // We use another state hook to track whether the form needs to be reset.\n            // The state is an empty object. To trigger a reset, we update the state\n            // to a new object. Then during rendering, we detect that the state has\n            // changed and schedule a commit effect.\n            var initialResetState = {};\n            var newResetStateQueue = {\n                pending: null,\n                lanes: NoLanes,\n                // We're going to cheat and intentionally not create a bound dispatch\n                // method, because we can call it directly in startTransition.\n                dispatch: null,\n                lastRenderedReducer: basicStateReducer,\n                lastRenderedState: initialResetState\n            };\n            var resetStateHook = {\n                memoizedState: initialResetState,\n                baseState: initialResetState,\n                baseQueue: null,\n                queue: newResetStateQueue,\n                next: null\n            };\n            stateHook.next = resetStateHook; // Add the hook list to both fiber alternates. The idea is that the fiber\n            // had this hook all along.\n            formFiber.memoizedState = stateHook;\n            var alternate = formFiber.alternate;\n            if (alternate !== null) {\n                alternate.memoizedState = stateHook;\n            }\n            return stateHook;\n        }\n        function requestFormReset(formFiber) {\n            var transition = requestCurrentTransition();\n            {\n                if (transition === null) {\n                    // An optimistic update occurred, but startTransition is not on the stack.\n                    // The form reset will be scheduled at default (sync) priority, which\n                    // is probably not what the user intended. Most likely because the\n                    // requestFormReset call happened after an `await`.\n                    // TODO: Theoretically, requestFormReset is still useful even for\n                    // non-transition updates because it allows you to update defaultValue\n                    // synchronously and then wait to reset until after the update commits.\n                    // I've chosen to warn anyway because it's more likely the `await` mistake\n                    // described above. But arguably we shouldn't.\n                    error('requestFormReset was called outside a transition or action. To ' + 'fix, move to an action, or wrap with startTransition.');\n                }\n            }\n            var stateHook = ensureFormComponentIsStateful(formFiber);\n            var newResetState = {};\n            var resetStateHook = stateHook.next;\n            var resetStateQueue = resetStateHook.queue;\n            dispatchSetState(formFiber, resetStateQueue, newResetState);\n        }\n        function mountTransition() {\n            var stateHook = mountStateImpl(false); // The `start` method never changes.\n            var start = startTransition.bind(null, currentlyRenderingFiber$1, stateHook.queue, true, false);\n            var hook = mountWorkInProgressHook();\n            hook.memoizedState = start;\n            return [\n                false,\n                start\n            ];\n        }\n        function updateTransition() {\n            var _updateState2 = updateState(), booleanOrThenable = _updateState2[0];\n            var hook = updateWorkInProgressHook();\n            var start = hook.memoizedState;\n            var isPending = typeof booleanOrThenable === 'boolean' ? booleanOrThenable : useThenable(booleanOrThenable);\n            return [\n                isPending,\n                start\n            ];\n        }\n        function rerenderTransition() {\n            var _rerenderState = rerenderState(), booleanOrThenable = _rerenderState[0];\n            var hook = updateWorkInProgressHook();\n            var start = hook.memoizedState;\n            var isPending = typeof booleanOrThenable === 'boolean' ? booleanOrThenable : useThenable(booleanOrThenable);\n            return [\n                isPending,\n                start\n            ];\n        }\n        function useHostTransitionStatus() {\n            var status = readContext(HostTransitionContext);\n            return status !== null ? status : NotPendingTransition;\n        }\n        function mountId() {\n            var hook = mountWorkInProgressHook();\n            var root = getWorkInProgressRoot(); // TODO: In Fizz, id generation is specific to each server config. Maybe we\n            // should do this in Fiber, too? Deferring this decision for now because\n            // there's no other place to store the prefix except for an internal field on\n            // the public createRoot object, which the fiber tree does not currently have\n            // a reference to.\n            var identifierPrefix = root.identifierPrefix;\n            var id;\n            if (getIsHydrating()) {\n                var treeId = getTreeId(); // Use a captial R prefix for server-generated ids.\n                id = ':' + identifierPrefix + 'R' + treeId; // Unless this is the first id at this level, append a number at the end\n                // that represents the position of this useId hook among all the useId\n                // hooks for this fiber.\n                var localId = localIdCounter++;\n                if (localId > 0) {\n                    id += 'H' + localId.toString(32);\n                }\n                id += ':';\n            } else {\n                // Use a lowercase r prefix for client-generated ids.\n                var globalClientId = globalClientIdCounter++;\n                id = ':' + identifierPrefix + 'r' + globalClientId.toString(32) + ':';\n            }\n            hook.memoizedState = id;\n            return id;\n        }\n        function updateId() {\n            var hook = updateWorkInProgressHook();\n            var id = hook.memoizedState;\n            return id;\n        }\n        function mountRefresh() {\n            var hook = mountWorkInProgressHook();\n            var refresh = hook.memoizedState = refreshCache.bind(null, currentlyRenderingFiber$1);\n            return refresh;\n        }\n        function updateRefresh() {\n            var hook = updateWorkInProgressHook();\n            return hook.memoizedState;\n        }\n        function refreshCache(fiber, seedKey, seedValue) {\n            // TODO: Consider warning if the refresh is at discrete priority, or if we\n            // otherwise suspect that it wasn't batched properly.\n            var provider = fiber.return;\n            while(provider !== null){\n                switch(provider.tag){\n                    case CacheComponent:\n                    case HostRoot:\n                        {\n                            // Schedule an update on the cache boundary to trigger a refresh.\n                            var lane = requestUpdateLane(provider);\n                            var refreshUpdate = createUpdate(lane);\n                            var root = enqueueUpdate(provider, refreshUpdate, lane);\n                            if (root !== null) {\n                                scheduleUpdateOnFiber(root, provider, lane);\n                                entangleTransitions(root, provider, lane);\n                            } // TODO: If a refresh never commits, the new cache created here must be\n                            // released. A simple case is start refreshing a cache boundary, but then\n                            // unmount that boundary before the refresh completes.\n                            var seededCache = createCache();\n                            if (seedKey !== null && seedKey !== undefined && root !== null) {\n                                {\n                                    {\n                                        error('The seed argument is not enabled outside experimental channels.');\n                                    }\n                                }\n                            }\n                            var payload = {\n                                cache: seededCache\n                            };\n                            refreshUpdate.payload = payload;\n                            return;\n                        }\n                }\n                provider = provider.return;\n            } // TODO: Warn if unmounted?\n        }\n        function dispatchReducerAction(fiber, queue, action) {\n            {\n                if (typeof arguments[3] === 'function') {\n                    error(\"State updates from the useState() and useReducer() Hooks don't support the \" + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');\n                }\n            }\n            var lane = requestUpdateLane(fiber);\n            var update = {\n                lane: lane,\n                revertLane: NoLane,\n                action: action,\n                hasEagerState: false,\n                eagerState: null,\n                next: null\n            };\n            if (isRenderPhaseUpdate(fiber)) {\n                enqueueRenderPhaseUpdate(queue, update);\n            } else {\n                var root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, lane);\n                    entangleTransitionUpdate(root, queue, lane);\n                }\n            }\n            markUpdateInDevTools(fiber, lane);\n        }\n        function dispatchSetState(fiber, queue, action) {\n            {\n                if (typeof arguments[3] === 'function') {\n                    error(\"State updates from the useState() and useReducer() Hooks don't support the \" + 'second callback argument. To execute a side effect after ' + 'rendering, declare it in the component body with useEffect().');\n                }\n            }\n            var lane = requestUpdateLane(fiber);\n            var update = {\n                lane: lane,\n                revertLane: NoLane,\n                action: action,\n                hasEagerState: false,\n                eagerState: null,\n                next: null\n            };\n            if (isRenderPhaseUpdate(fiber)) {\n                enqueueRenderPhaseUpdate(queue, update);\n            } else {\n                var alternate = fiber.alternate;\n                if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {\n                    // The queue is currently empty, which means we can eagerly compute the\n                    // next state before entering the render phase. If the new state is the\n                    // same as the current state, we may be able to bail out entirely.\n                    var lastRenderedReducer = queue.lastRenderedReducer;\n                    if (lastRenderedReducer !== null) {\n                        var prevDispatcher = null;\n                        {\n                            prevDispatcher = ReactSharedInternals.H;\n                            ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                        }\n                        try {\n                            var currentState = queue.lastRenderedState;\n                            var eagerState = lastRenderedReducer(currentState, action); // Stash the eagerly computed state, and the reducer used to compute\n                            // it, on the update object. If the reducer hasn't changed by the\n                            // time we enter the render phase, then the eager state can be used\n                            // without calling the reducer again.\n                            update.hasEagerState = true;\n                            update.eagerState = eagerState;\n                            if (objectIs(eagerState, currentState)) {\n                                // Fast path. We can bail out without scheduling React to re-render.\n                                // It's still possible that we'll need to rebase this update later,\n                                // if the component re-renders for a different reason and by that\n                                // time the reducer has changed.\n                                // TODO: Do we still need to entangle transitions in this case?\n                                enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update);\n                                return;\n                            }\n                        } catch (error) {} finally{\n                            {\n                                ReactSharedInternals.H = prevDispatcher;\n                            }\n                        }\n                    }\n                }\n                var root = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, lane);\n                    entangleTransitionUpdate(root, queue, lane);\n                }\n            }\n            markUpdateInDevTools(fiber, lane);\n        }\n        function dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {\n            var transition = requestCurrentTransition();\n            {\n                if (transition === null) {\n                    // An optimistic update occurred, but startTransition is not on the stack.\n                    // There are two likely scenarios.\n                    // One possibility is that the optimistic update is triggered by a regular\n                    // event handler (e.g. `onSubmit`) instead of an action. This is a mistake\n                    // and we will warn.\n                    // The other possibility is the optimistic update is inside an async\n                    // action, but after an `await`. In this case, we can make it \"just work\"\n                    // by associating the optimistic update with the pending async action.\n                    // Technically it's possible that the optimistic update is unrelated to\n                    // the pending action, but we don't have a way of knowing this for sure\n                    // because browsers currently do not provide a way to track async scope.\n                    // (The AsyncContext proposal, if it lands, will solve this in the\n                    // future.) However, this is no different than the problem of unrelated\n                    // transitions being grouped together — it's not wrong per se, but it's\n                    // not ideal.\n                    // Once AsyncContext starts landing in browsers, we will provide better\n                    // warnings in development for these cases.\n                    if (peekEntangledActionLane() !== NoLane) ;\n                    else {\n                        // There's no pending async action. The most likely cause is that we're\n                        // inside a regular event handler (e.g. onSubmit) instead of an action.\n                        error('An optimistic state update occurred outside a transition or ' + 'action. To fix, move the update to an action, or wrap ' + 'with startTransition.');\n                    }\n                }\n            }\n            var update = {\n                // An optimistic update commits synchronously.\n                lane: SyncLane,\n                // After committing, the optimistic update is \"reverted\" using the same\n                // lane as the transition it's associated with.\n                revertLane: requestTransitionLane(),\n                action: action,\n                hasEagerState: false,\n                eagerState: null,\n                next: null\n            };\n            if (isRenderPhaseUpdate(fiber)) {\n                // When calling startTransition during render, this warns instead of\n                // throwing because throwing would be a breaking change. setOptimisticState\n                // is a new API so it's OK to throw.\n                if (throwIfDuringRender) {\n                    throw new Error('Cannot update optimistic state while rendering.');\n                } else {\n                    // startTransition was called during render. We don't need to do anything\n                    // besides warn here because the render phase update would be overidden by\n                    // the second update, anyway. We can remove this branch and make it throw\n                    // in a future release.\n                    {\n                        error('Cannot call startTransition while rendering.');\n                    }\n                }\n            } else {\n                var root = enqueueConcurrentHookUpdate(fiber, queue, update, SyncLane);\n                if (root !== null) {\n                    // NOTE: The optimistic update implementation assumes that the transition\n                    // will never be attempted before the optimistic update. This currently\n                    // holds because the optimistic update is always synchronous. If we ever\n                    // change that, we'll need to account for this.\n                    scheduleUpdateOnFiber(root, fiber, SyncLane); // Optimistic updates are always synchronous, so we don't need to call\n                // entangleTransitionUpdate here.\n                }\n            }\n            markUpdateInDevTools(fiber, SyncLane);\n        }\n        function isRenderPhaseUpdate(fiber) {\n            var alternate = fiber.alternate;\n            return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;\n        }\n        function enqueueRenderPhaseUpdate(queue, update) {\n            // This is a render phase update. Stash it in a lazily-created map of\n            // queue -> linked list of updates. After this render pass, we'll restart\n            // and apply the stashed updates on top of the work-in-progress hook.\n            didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;\n            var pending = queue.pending;\n            if (pending === null) {\n                // This is the first update. Create a circular list.\n                update.next = update;\n            } else {\n                update.next = pending.next;\n                pending.next = update;\n            }\n            queue.pending = update;\n        } // TODO: Move to ReactFiberConcurrentUpdates?\n        function entangleTransitionUpdate(root, queue, lane) {\n            if (isTransitionLane(lane)) {\n                var queueLanes = queue.lanes; // If any entangled lanes are no longer pending on the root, then they\n                // must have finished. We can remove them from the shared queue, which\n                // represents a superset of the actually pending lanes. In some cases we\n                // may entangle more than we need to, but that's OK. In fact it's worse if\n                // we *don't* entangle when we should.\n                queueLanes = intersectLanes(queueLanes, root.pendingLanes); // Entangle the new transition lane with the other transition lanes.\n                var newQueueLanes = mergeLanes(queueLanes, lane);\n                queue.lanes = newQueueLanes; // Even if queue.lanes already include lane, we don't know for certain if\n                // the lane finished since the last time we entangled it. So we need to\n                // entangle it again, just to be sure.\n                markRootEntangled(root, newQueueLanes);\n            }\n        }\n        function markUpdateInDevTools(fiber, lane, action) {\n            {\n                markStateUpdateScheduled(fiber, lane);\n            }\n        }\n        var ContextOnlyDispatcher = {\n            readContext: readContext,\n            use: use,\n            useCallback: throwInvalidHookError,\n            useContext: throwInvalidHookError,\n            useEffect: throwInvalidHookError,\n            useImperativeHandle: throwInvalidHookError,\n            useLayoutEffect: throwInvalidHookError,\n            useInsertionEffect: throwInvalidHookError,\n            useMemo: throwInvalidHookError,\n            useReducer: throwInvalidHookError,\n            useRef: throwInvalidHookError,\n            useState: throwInvalidHookError,\n            useDebugValue: throwInvalidHookError,\n            useDeferredValue: throwInvalidHookError,\n            useTransition: throwInvalidHookError,\n            useSyncExternalStore: throwInvalidHookError,\n            useId: throwInvalidHookError\n        };\n        {\n            ContextOnlyDispatcher.useCacheRefresh = throwInvalidHookError;\n        }\n        {\n            ContextOnlyDispatcher.useMemoCache = throwInvalidHookError;\n        }\n        {\n            ContextOnlyDispatcher.useHostTransitionStatus = throwInvalidHookError;\n            ContextOnlyDispatcher.useFormState = throwInvalidHookError;\n            ContextOnlyDispatcher.useActionState = throwInvalidHookError;\n        }\n        {\n            ContextOnlyDispatcher.useOptimistic = throwInvalidHookError;\n        }\n        var HooksDispatcherOnMountInDEV = null;\n        var HooksDispatcherOnMountWithHookTypesInDEV = null;\n        var HooksDispatcherOnUpdateInDEV = null;\n        var HooksDispatcherOnRerenderInDEV = null;\n        var InvalidNestedHooksDispatcherOnMountInDEV = null;\n        var InvalidNestedHooksDispatcherOnUpdateInDEV = null;\n        var InvalidNestedHooksDispatcherOnRerenderInDEV = null;\n        {\n            var warnInvalidContextAccess = function() {\n                error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\n            };\n            var warnInvalidHookAccess = function() {\n                error('Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. ' + 'You can only call Hooks at the top level of your React function. ' + 'For more information, see ' + 'https://react.dev/link/rules-of-hooks');\n            };\n            HooksDispatcherOnMountInDEV = {\n                readContext: function(context) {\n                    return readContext(context);\n                },\n                use: use,\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = 'useCallback';\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = 'useContext';\n                    mountHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = 'useEffect';\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = 'useImperativeHandle';\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = 'useInsertionEffect';\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = 'useLayoutEffect';\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    return mountLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = 'useMemo';\n                    mountHookTypesDev();\n                    checkDepsAreArrayDev(deps);\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountMemo(create, deps);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = 'useReducer';\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = 'useRef';\n                    mountHookTypesDev();\n                    return mountRef(initialValue);\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = 'useState';\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountState(initialState);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = 'useDebugValue';\n                    mountHookTypesDev();\n                    return mountDebugValue();\n                },\n                useDeferredValue: function(value, initialValue) {\n                    currentHookNameInDev = 'useDeferredValue';\n                    mountHookTypesDev();\n                    return mountDeferredValue(value, initialValue);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = 'useTransition';\n                    mountHookTypesDev();\n                    return mountTransition();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = 'useSyncExternalStore';\n                    mountHookTypesDev();\n                    return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = 'useId';\n                    mountHookTypesDev();\n                    return mountId();\n                }\n            };\n            {\n                HooksDispatcherOnMountInDEV.useCacheRefresh = function useCacheRefresh() {\n                    currentHookNameInDev = 'useCacheRefresh';\n                    mountHookTypesDev();\n                    return mountRefresh();\n                };\n            }\n            {\n                HooksDispatcherOnMountInDEV.useMemoCache = useMemoCache;\n            }\n            {\n                HooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;\n                HooksDispatcherOnMountInDEV.useFormState = function useFormState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useFormState';\n                    mountHookTypesDev();\n                    return mountActionState(action, initialState);\n                };\n                HooksDispatcherOnMountInDEV.useActionState = function useActionState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useActionState';\n                    mountHookTypesDev();\n                    return mountActionState(action, initialState);\n                };\n            }\n            {\n                HooksDispatcherOnMountInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {\n                    currentHookNameInDev = 'useOptimistic';\n                    mountHookTypesDev();\n                    return mountOptimistic(passthrough);\n                };\n            }\n            HooksDispatcherOnMountWithHookTypesInDEV = {\n                readContext: function(context) {\n                    return readContext(context);\n                },\n                use: use,\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = 'useCallback';\n                    updateHookTypesDev();\n                    return mountCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = 'useContext';\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = 'useEffect';\n                    updateHookTypesDev();\n                    return mountEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = 'useImperativeHandle';\n                    updateHookTypesDev();\n                    return mountImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = 'useInsertionEffect';\n                    updateHookTypesDev();\n                    return mountInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = 'useLayoutEffect';\n                    updateHookTypesDev();\n                    return mountLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = 'useMemo';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountMemo(create, deps);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = 'useReducer';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = 'useRef';\n                    updateHookTypesDev();\n                    return mountRef(initialValue);\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = 'useState';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountState(initialState);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = 'useDebugValue';\n                    updateHookTypesDev();\n                    return mountDebugValue();\n                },\n                useDeferredValue: function(value, initialValue) {\n                    currentHookNameInDev = 'useDeferredValue';\n                    updateHookTypesDev();\n                    return mountDeferredValue(value, initialValue);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = 'useTransition';\n                    updateHookTypesDev();\n                    return mountTransition();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = 'useSyncExternalStore';\n                    updateHookTypesDev();\n                    return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = 'useId';\n                    updateHookTypesDev();\n                    return mountId();\n                }\n            };\n            {\n                HooksDispatcherOnMountWithHookTypesInDEV.useCacheRefresh = function useCacheRefresh() {\n                    currentHookNameInDev = 'useCacheRefresh';\n                    updateHookTypesDev();\n                    return mountRefresh();\n                };\n            }\n            {\n                HooksDispatcherOnMountWithHookTypesInDEV.useMemoCache = useMemoCache;\n            }\n            {\n                HooksDispatcherOnMountWithHookTypesInDEV.useHostTransitionStatus = useHostTransitionStatus;\n                HooksDispatcherOnMountWithHookTypesInDEV.useFormState = function useFormState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useFormState';\n                    updateHookTypesDev();\n                    warnOnUseFormStateInDev();\n                    return mountActionState(action, initialState);\n                };\n                HooksDispatcherOnMountWithHookTypesInDEV.useActionState = function useActionState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useActionState';\n                    updateHookTypesDev();\n                    return mountActionState(action, initialState);\n                };\n            }\n            {\n                HooksDispatcherOnMountWithHookTypesInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {\n                    currentHookNameInDev = 'useOptimistic';\n                    updateHookTypesDev();\n                    return mountOptimistic(passthrough);\n                };\n            }\n            HooksDispatcherOnUpdateInDEV = {\n                readContext: function(context) {\n                    return readContext(context);\n                },\n                use: use,\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = 'useCallback';\n                    updateHookTypesDev();\n                    return updateCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = 'useContext';\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = 'useEffect';\n                    updateHookTypesDev();\n                    return updateEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = 'useImperativeHandle';\n                    updateHookTypesDev();\n                    return updateImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = 'useInsertionEffect';\n                    updateHookTypesDev();\n                    return updateInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = 'useLayoutEffect';\n                    updateHookTypesDev();\n                    return updateLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = 'useMemo';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateMemo(create, deps);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = 'useReducer';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = 'useRef';\n                    updateHookTypesDev();\n                    return updateRef();\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = 'useState';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateState(initialState);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = 'useDebugValue';\n                    updateHookTypesDev();\n                    return updateDebugValue();\n                },\n                useDeferredValue: function(value, initialValue) {\n                    currentHookNameInDev = 'useDeferredValue';\n                    updateHookTypesDev();\n                    return updateDeferredValue(value, initialValue);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = 'useTransition';\n                    updateHookTypesDev();\n                    return updateTransition();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = 'useSyncExternalStore';\n                    updateHookTypesDev();\n                    return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = 'useId';\n                    updateHookTypesDev();\n                    return updateId();\n                }\n            };\n            {\n                HooksDispatcherOnUpdateInDEV.useCacheRefresh = function useCacheRefresh() {\n                    currentHookNameInDev = 'useCacheRefresh';\n                    updateHookTypesDev();\n                    return updateRefresh();\n                };\n            }\n            {\n                HooksDispatcherOnUpdateInDEV.useMemoCache = useMemoCache;\n            }\n            {\n                HooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;\n                HooksDispatcherOnUpdateInDEV.useFormState = function useFormState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useFormState';\n                    updateHookTypesDev();\n                    warnOnUseFormStateInDev();\n                    return updateActionState(action);\n                };\n                HooksDispatcherOnUpdateInDEV.useActionState = function useActionState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useActionState';\n                    updateHookTypesDev();\n                    return updateActionState(action);\n                };\n            }\n            {\n                HooksDispatcherOnUpdateInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {\n                    currentHookNameInDev = 'useOptimistic';\n                    updateHookTypesDev();\n                    return updateOptimistic(passthrough, reducer);\n                };\n            }\n            HooksDispatcherOnRerenderInDEV = {\n                readContext: function(context) {\n                    return readContext(context);\n                },\n                use: use,\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = 'useCallback';\n                    updateHookTypesDev();\n                    return updateCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = 'useContext';\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = 'useEffect';\n                    updateHookTypesDev();\n                    return updateEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = 'useImperativeHandle';\n                    updateHookTypesDev();\n                    return updateImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = 'useInsertionEffect';\n                    updateHookTypesDev();\n                    return updateInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = 'useLayoutEffect';\n                    updateHookTypesDev();\n                    return updateLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = 'useMemo';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n                    try {\n                        return updateMemo(create, deps);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = 'useReducer';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n                    try {\n                        return rerenderReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = 'useRef';\n                    updateHookTypesDev();\n                    return updateRef();\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = 'useState';\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnRerenderInDEV;\n                    try {\n                        return rerenderState(initialState);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = 'useDebugValue';\n                    updateHookTypesDev();\n                    return updateDebugValue();\n                },\n                useDeferredValue: function(value, initialValue) {\n                    currentHookNameInDev = 'useDeferredValue';\n                    updateHookTypesDev();\n                    return rerenderDeferredValue(value, initialValue);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = 'useTransition';\n                    updateHookTypesDev();\n                    return rerenderTransition();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = 'useSyncExternalStore';\n                    updateHookTypesDev();\n                    return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = 'useId';\n                    updateHookTypesDev();\n                    return updateId();\n                }\n            };\n            {\n                HooksDispatcherOnRerenderInDEV.useCacheRefresh = function useCacheRefresh() {\n                    currentHookNameInDev = 'useCacheRefresh';\n                    updateHookTypesDev();\n                    return updateRefresh();\n                };\n            }\n            {\n                HooksDispatcherOnRerenderInDEV.useMemoCache = useMemoCache;\n            }\n            {\n                HooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;\n                HooksDispatcherOnRerenderInDEV.useFormState = function useFormState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useFormState';\n                    updateHookTypesDev();\n                    warnOnUseFormStateInDev();\n                    return rerenderActionState(action);\n                };\n                HooksDispatcherOnRerenderInDEV.useActionState = function useActionState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useActionState';\n                    updateHookTypesDev();\n                    return rerenderActionState(action);\n                };\n            }\n            {\n                HooksDispatcherOnRerenderInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {\n                    currentHookNameInDev = 'useOptimistic';\n                    updateHookTypesDev();\n                    return rerenderOptimistic(passthrough, reducer);\n                };\n            }\n            InvalidNestedHooksDispatcherOnMountInDEV = {\n                readContext: function(context) {\n                    warnInvalidContextAccess();\n                    return readContext(context);\n                },\n                use: function(usable) {\n                    warnInvalidHookAccess();\n                    return use(usable);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = 'useCallback';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = 'useContext';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = 'useEffect';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = 'useImperativeHandle';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = 'useInsertionEffect';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = 'useLayoutEffect';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = 'useMemo';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountMemo(create, deps);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = 'useReducer';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = 'useRef';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountRef(initialValue);\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = 'useState';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnMountInDEV;\n                    try {\n                        return mountState(initialState);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = 'useDebugValue';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountDebugValue();\n                },\n                useDeferredValue: function(value, initialValue) {\n                    currentHookNameInDev = 'useDeferredValue';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountDeferredValue(value, initialValue);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = 'useTransition';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountTransition();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = 'useSyncExternalStore';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = 'useId';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountId();\n                }\n            };\n            {\n                InvalidNestedHooksDispatcherOnMountInDEV.useCacheRefresh = function useCacheRefresh() {\n                    currentHookNameInDev = 'useCacheRefresh';\n                    mountHookTypesDev();\n                    return mountRefresh();\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnMountInDEV.useMemoCache = function(size) {\n                    warnInvalidHookAccess();\n                    return useMemoCache(size);\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnMountInDEV.useHostTransitionStatus = useHostTransitionStatus;\n                InvalidNestedHooksDispatcherOnMountInDEV.useFormState = function useFormState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useFormState';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountActionState(action, initialState);\n                };\n                InvalidNestedHooksDispatcherOnMountInDEV.useActionState = function useActionState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useActionState';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountActionState(action, initialState);\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnMountInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {\n                    currentHookNameInDev = 'useOptimistic';\n                    warnInvalidHookAccess();\n                    mountHookTypesDev();\n                    return mountOptimistic(passthrough);\n                };\n            }\n            InvalidNestedHooksDispatcherOnUpdateInDEV = {\n                readContext: function(context) {\n                    warnInvalidContextAccess();\n                    return readContext(context);\n                },\n                use: function(usable) {\n                    warnInvalidHookAccess();\n                    return use(usable);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = 'useCallback';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = 'useContext';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = 'useEffect';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = 'useImperativeHandle';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = 'useInsertionEffect';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = 'useLayoutEffect';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = 'useMemo';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateMemo(create, deps);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = 'useReducer';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = 'useRef';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateRef();\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = 'useState';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateState(initialState);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = 'useDebugValue';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateDebugValue();\n                },\n                useDeferredValue: function(value, initialValue) {\n                    currentHookNameInDev = 'useDeferredValue';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateDeferredValue(value, initialValue);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = 'useTransition';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateTransition();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = 'useSyncExternalStore';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = 'useId';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateId();\n                }\n            };\n            {\n                InvalidNestedHooksDispatcherOnUpdateInDEV.useCacheRefresh = function useCacheRefresh() {\n                    currentHookNameInDev = 'useCacheRefresh';\n                    updateHookTypesDev();\n                    return updateRefresh();\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnUpdateInDEV.useMemoCache = function(size) {\n                    warnInvalidHookAccess();\n                    return useMemoCache(size);\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnUpdateInDEV.useHostTransitionStatus = useHostTransitionStatus;\n                InvalidNestedHooksDispatcherOnUpdateInDEV.useFormState = function useFormState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useFormState';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateActionState(action);\n                };\n                InvalidNestedHooksDispatcherOnUpdateInDEV.useActionState = function useActionState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useActionState';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateActionState(action);\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnUpdateInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {\n                    currentHookNameInDev = 'useOptimistic';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateOptimistic(passthrough, reducer);\n                };\n            }\n            InvalidNestedHooksDispatcherOnRerenderInDEV = {\n                readContext: function(context) {\n                    warnInvalidContextAccess();\n                    return readContext(context);\n                },\n                use: function(usable) {\n                    warnInvalidHookAccess();\n                    return use(usable);\n                },\n                useCallback: function(callback, deps) {\n                    currentHookNameInDev = 'useCallback';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateCallback(callback, deps);\n                },\n                useContext: function(context) {\n                    currentHookNameInDev = 'useContext';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return readContext(context);\n                },\n                useEffect: function(create, deps) {\n                    currentHookNameInDev = 'useEffect';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateEffect(create, deps);\n                },\n                useImperativeHandle: function(ref, create, deps) {\n                    currentHookNameInDev = 'useImperativeHandle';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateImperativeHandle(ref, create, deps);\n                },\n                useInsertionEffect: function(create, deps) {\n                    currentHookNameInDev = 'useInsertionEffect';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateInsertionEffect(create, deps);\n                },\n                useLayoutEffect: function(create, deps) {\n                    currentHookNameInDev = 'useLayoutEffect';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateLayoutEffect(create, deps);\n                },\n                useMemo: function(create, deps) {\n                    currentHookNameInDev = 'useMemo';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return updateMemo(create, deps);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useReducer: function(reducer, initialArg, init) {\n                    currentHookNameInDev = 'useReducer';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return rerenderReducer(reducer, initialArg, init);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useRef: function(initialValue) {\n                    currentHookNameInDev = 'useRef';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateRef();\n                },\n                useState: function(initialState) {\n                    currentHookNameInDev = 'useState';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    var prevDispatcher = ReactSharedInternals.H;\n                    ReactSharedInternals.H = InvalidNestedHooksDispatcherOnUpdateInDEV;\n                    try {\n                        return rerenderState(initialState);\n                    } finally{\n                        ReactSharedInternals.H = prevDispatcher;\n                    }\n                },\n                useDebugValue: function(value, formatterFn) {\n                    currentHookNameInDev = 'useDebugValue';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateDebugValue();\n                },\n                useDeferredValue: function(value, initialValue) {\n                    currentHookNameInDev = 'useDeferredValue';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return rerenderDeferredValue(value, initialValue);\n                },\n                useTransition: function() {\n                    currentHookNameInDev = 'useTransition';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return rerenderTransition();\n                },\n                useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {\n                    currentHookNameInDev = 'useSyncExternalStore';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);\n                },\n                useId: function() {\n                    currentHookNameInDev = 'useId';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return updateId();\n                }\n            };\n            {\n                InvalidNestedHooksDispatcherOnRerenderInDEV.useCacheRefresh = function useCacheRefresh() {\n                    currentHookNameInDev = 'useCacheRefresh';\n                    updateHookTypesDev();\n                    return updateRefresh();\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnRerenderInDEV.useMemoCache = function(size) {\n                    warnInvalidHookAccess();\n                    return useMemoCache(size);\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnRerenderInDEV.useHostTransitionStatus = useHostTransitionStatus;\n                InvalidNestedHooksDispatcherOnRerenderInDEV.useFormState = function useFormState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useFormState';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return rerenderActionState(action);\n                };\n                InvalidNestedHooksDispatcherOnRerenderInDEV.useActionState = function useActionState(action, initialState, permalink) {\n                    currentHookNameInDev = 'useActionState';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return rerenderActionState(action);\n                };\n            }\n            {\n                InvalidNestedHooksDispatcherOnRerenderInDEV.useOptimistic = function useOptimistic(passthrough, reducer) {\n                    currentHookNameInDev = 'useOptimistic';\n                    warnInvalidHookAccess();\n                    updateHookTypesDev();\n                    return rerenderOptimistic(passthrough, reducer);\n                };\n            }\n        }\n        var now = Scheduler.unstable_now;\n        var commitTime = 0;\n        var layoutEffectStartTime = -1;\n        var profilerStartTime = -1;\n        var passiveEffectStartTime = -1;\n        /**\n * Tracks whether the current update was a nested/cascading update (scheduled from a layout effect).\n *\n * The overall sequence is:\n *   1. render\n *   2. commit (and call `onRender`, `onCommit`)\n *   3. check for nested updates\n *   4. flush passive effects (and call `onPostCommit`)\n *\n * Nested updates are identified in step 3 above,\n * but step 4 still applies to the work that was just committed.\n * We use two flags to track nested updates then:\n * one tracks whether the upcoming update is a nested update,\n * and the other tracks whether the current update was a nested update.\n * The first value gets synced to the second at the start of the render phase.\n */ var currentUpdateIsNested = false;\n        var nestedUpdateScheduled = false;\n        function isCurrentUpdateNested() {\n            return currentUpdateIsNested;\n        }\n        function markNestedUpdateScheduled() {\n            {\n                nestedUpdateScheduled = true;\n            }\n        }\n        function resetNestedUpdateFlag() {\n            {\n                currentUpdateIsNested = false;\n                nestedUpdateScheduled = false;\n            }\n        }\n        function syncNestedUpdateFlag() {\n            {\n                currentUpdateIsNested = nestedUpdateScheduled;\n                nestedUpdateScheduled = false;\n            }\n        }\n        function getCommitTime() {\n            return commitTime;\n        }\n        function recordCommitTime() {\n            commitTime = now();\n        }\n        function startProfilerTimer(fiber) {\n            profilerStartTime = now();\n            if (fiber.actualStartTime < 0) {\n                fiber.actualStartTime = now();\n            }\n        }\n        function stopProfilerTimerIfRunning(fiber) {\n            profilerStartTime = -1;\n        }\n        function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {\n            if (profilerStartTime >= 0) {\n                var elapsedTime = now() - profilerStartTime;\n                fiber.actualDuration += elapsedTime;\n                if (overrideBaseTime) {\n                    fiber.selfBaseDuration = elapsedTime;\n                }\n                profilerStartTime = -1;\n            }\n        }\n        function recordLayoutEffectDuration(fiber) {\n            if (layoutEffectStartTime >= 0) {\n                var elapsedTime = now() - layoutEffectStartTime;\n                layoutEffectStartTime = -1; // Store duration on the next nearest Profiler ancestor\n                // Or the root (for the DevTools Profiler to read)\n                var parentFiber = fiber.return;\n                while(parentFiber !== null){\n                    switch(parentFiber.tag){\n                        case HostRoot:\n                            var root = parentFiber.stateNode;\n                            root.effectDuration += elapsedTime;\n                            return;\n                        case Profiler:\n                            var parentStateNode = parentFiber.stateNode;\n                            parentStateNode.effectDuration += elapsedTime;\n                            return;\n                    }\n                    parentFiber = parentFiber.return;\n                }\n            }\n        }\n        function recordPassiveEffectDuration(fiber) {\n            if (passiveEffectStartTime >= 0) {\n                var elapsedTime = now() - passiveEffectStartTime;\n                passiveEffectStartTime = -1; // Store duration on the next nearest Profiler ancestor\n                // Or the root (for the DevTools Profiler to read)\n                var parentFiber = fiber.return;\n                while(parentFiber !== null){\n                    switch(parentFiber.tag){\n                        case HostRoot:\n                            var root = parentFiber.stateNode;\n                            if (root !== null) {\n                                root.passiveEffectDuration += elapsedTime;\n                            }\n                            return;\n                        case Profiler:\n                            var parentStateNode = parentFiber.stateNode;\n                            if (parentStateNode !== null) {\n                                // Detached fibers have their state node cleared out.\n                                // In this case, the return pointer is also cleared out,\n                                // so we won't be able to report the time spent in this Profiler's subtree.\n                                parentStateNode.passiveEffectDuration += elapsedTime;\n                            }\n                            return;\n                    }\n                    parentFiber = parentFiber.return;\n                }\n            }\n        }\n        function startLayoutEffectTimer() {\n            layoutEffectStartTime = now();\n        }\n        function startPassiveEffectTimer() {\n            passiveEffectStartTime = now();\n        }\n        function transferActualDuration(fiber) {\n            // Transfer time spent rendering these children so we don't lose it\n            // after we rerender. This is used as a helper in special cases\n            // where we should count the work of multiple passes.\n            var child = fiber.child;\n            while(child){\n                // $FlowFixMe[unsafe-addition] addition with possible null/undefined value\n                fiber.actualDuration += child.actualDuration;\n                child = child.sibling;\n            }\n        }\n        var fakeInternalInstance = {};\n        var didWarnAboutStateAssignmentForComponent;\n        var didWarnAboutUninitializedState;\n        var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;\n        var didWarnAboutLegacyLifecyclesAndDerivedState;\n        var didWarnAboutUndefinedDerivedState;\n        var didWarnAboutDirectlyAssigningPropsToState;\n        var didWarnAboutInvalidateContextType;\n        var didWarnOnInvalidCallback;\n        {\n            didWarnAboutStateAssignmentForComponent = new Set();\n            didWarnAboutUninitializedState = new Set();\n            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set();\n            didWarnAboutLegacyLifecyclesAndDerivedState = new Set();\n            didWarnAboutDirectlyAssigningPropsToState = new Set();\n            didWarnAboutUndefinedDerivedState = new Set();\n            didWarnAboutInvalidateContextType = new Set();\n            didWarnOnInvalidCallback = new Set(); // This is so gross but it's at least non-critical and can be removed if\n            // it causes problems. This is meant to give a nicer error message for\n            // ReactDOM15.unstable_renderSubtreeIntoContainer(reactDOM16Component,\n            // ...)) which otherwise throws a \"_processChildContext is not a function\"\n            // exception.\n            Object.defineProperty(fakeInternalInstance, '_processChildContext', {\n                enumerable: false,\n                value: function() {\n                    throw new Error('_processChildContext is not available in React 16+. This likely ' + 'means you have multiple copies of React and are attempting to nest ' + 'a React 15 tree inside a React 16 tree using ' + \"unstable_renderSubtreeIntoContainer, which isn't supported. Try \" + 'to make sure you have only one copy of React (and ideally, switch ' + 'to ReactDOM.createPortal).');\n                }\n            });\n            Object.freeze(fakeInternalInstance);\n        }\n        function warnOnInvalidCallback(callback) {\n            {\n                if (callback === null || typeof callback === 'function') {\n                    return;\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var key = String(callback);\n                if (!didWarnOnInvalidCallback.has(key)) {\n                    didWarnOnInvalidCallback.add(key);\n                    error('Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n                }\n            }\n        }\n        function warnOnUndefinedDerivedState(type, partialState) {\n            {\n                if (partialState === undefined) {\n                    var componentName = getComponentNameFromType(type) || 'Component';\n                    if (!didWarnAboutUndefinedDerivedState.has(componentName)) {\n                        didWarnAboutUndefinedDerivedState.add(componentName);\n                        error('%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. ' + 'You have returned undefined.', componentName);\n                    }\n                }\n            }\n        }\n        function applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, nextProps) {\n            var prevState = workInProgress.memoizedState;\n            var partialState = getDerivedStateFromProps(nextProps, prevState);\n            {\n                if (workInProgress.mode & StrictLegacyMode) {\n                    setIsStrictModeForDevtools(true);\n                    try {\n                        // Invoke the function an extra time to help detect side-effects.\n                        partialState = getDerivedStateFromProps(nextProps, prevState);\n                    } finally{\n                        setIsStrictModeForDevtools(false);\n                    }\n                }\n                warnOnUndefinedDerivedState(ctor, partialState);\n            }\n            var memoizedState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);\n            workInProgress.memoizedState = memoizedState; // Once the update queue is empty, persist the derived state onto the\n            // base state.\n            if (workInProgress.lanes === NoLanes) {\n                // Queue is always non-null for classes\n                var updateQueue = workInProgress.updateQueue;\n                updateQueue.baseState = memoizedState;\n            }\n        }\n        var classComponentUpdater = {\n            isMounted: isMounted,\n            // $FlowFixMe[missing-local-annot]\n            enqueueSetState: function(inst, payload, callback) {\n                var fiber = get(inst);\n                var lane = requestUpdateLane(fiber);\n                var update = createUpdate(lane);\n                update.payload = payload;\n                if (callback !== undefined && callback !== null) {\n                    {\n                        warnOnInvalidCallback(callback);\n                    }\n                    update.callback = callback;\n                }\n                var root = enqueueUpdate(fiber, update, lane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, lane);\n                    entangleTransitions(root, fiber, lane);\n                }\n                {\n                    markStateUpdateScheduled(fiber, lane);\n                }\n            },\n            enqueueReplaceState: function(inst, payload, callback) {\n                var fiber = get(inst);\n                var lane = requestUpdateLane(fiber);\n                var update = createUpdate(lane);\n                update.tag = ReplaceState;\n                update.payload = payload;\n                if (callback !== undefined && callback !== null) {\n                    {\n                        warnOnInvalidCallback(callback);\n                    }\n                    update.callback = callback;\n                }\n                var root = enqueueUpdate(fiber, update, lane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, lane);\n                    entangleTransitions(root, fiber, lane);\n                }\n                {\n                    markStateUpdateScheduled(fiber, lane);\n                }\n            },\n            // $FlowFixMe[missing-local-annot]\n            enqueueForceUpdate: function(inst, callback) {\n                var fiber = get(inst);\n                var lane = requestUpdateLane(fiber);\n                var update = createUpdate(lane);\n                update.tag = ForceUpdate;\n                if (callback !== undefined && callback !== null) {\n                    {\n                        warnOnInvalidCallback(callback);\n                    }\n                    update.callback = callback;\n                }\n                var root = enqueueUpdate(fiber, update, lane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, lane);\n                    entangleTransitions(root, fiber, lane);\n                }\n                {\n                    markForceUpdateScheduled(fiber, lane);\n                }\n            }\n        };\n        function checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) {\n            var instance = workInProgress.stateNode;\n            if (typeof instance.shouldComponentUpdate === 'function') {\n                var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n                {\n                    if (workInProgress.mode & StrictLegacyMode) {\n                        setIsStrictModeForDevtools(true);\n                        try {\n                            // Invoke the function an extra time to help detect side-effects.\n                            shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);\n                        } finally{\n                            setIsStrictModeForDevtools(false);\n                        }\n                    }\n                    if (shouldUpdate === undefined) {\n                        error('%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', getComponentNameFromType(ctor) || 'Component');\n                    }\n                }\n                return shouldUpdate;\n            }\n            if (ctor.prototype && ctor.prototype.isPureReactComponent) {\n                return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);\n            }\n            return true;\n        }\n        function checkClassInstance(workInProgress, ctor, newProps) {\n            var instance = workInProgress.stateNode;\n            {\n                var name = getComponentNameFromType(ctor) || 'Component';\n                var renderPresent = instance.render;\n                if (!renderPresent) {\n                    if (ctor.prototype && typeof ctor.prototype.render === 'function') {\n                        error('No `render` method found on the %s ' + 'instance: did you accidentally return an object from the constructor?', name);\n                    } else {\n                        error('No `render` method found on the %s ' + 'instance: you may have forgotten to define `render`.', name);\n                    }\n                }\n                if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {\n                    error('getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', name);\n                }\n                if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {\n                    error('getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', name);\n                }\n                if (instance.propTypes) {\n                    error('propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', name);\n                }\n                if (instance.contextType) {\n                    error('contextType was defined as an instance property on %s. Use a static ' + 'property to define contextType instead.', name);\n                }\n                {\n                    if (ctor.childContextTypes) {\n                        error('%s uses the legacy childContextTypes API which was removed in React 19. ' + 'Use React.createContext() instead.', name);\n                    }\n                    if (ctor.contextTypes) {\n                        error('%s uses the legacy contextTypes API which was removed in React 19. ' + 'Use React.createContext() with static contextType instead.', name);\n                    }\n                }\n                if (typeof instance.componentShouldUpdate === 'function') {\n                    error('%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', name);\n                }\n                if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== 'undefined') {\n                    error('%s has a method called shouldComponentUpdate(). ' + 'shouldComponentUpdate should not be used when extending React.PureComponent. ' + 'Please extend React.Component if shouldComponentUpdate is used.', getComponentNameFromType(ctor) || 'A pure component');\n                }\n                if (typeof instance.componentDidUnmount === 'function') {\n                    error('%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', name);\n                }\n                if (typeof instance.componentDidReceiveProps === 'function') {\n                    error('%s has a method called ' + 'componentDidReceiveProps(). But there is no such lifecycle method. ' + 'If you meant to update the state in response to changing props, ' + 'use componentWillReceiveProps(). If you meant to fetch data or ' + 'run side-effects or mutations after React has updated the UI, use componentDidUpdate().', name);\n                }\n                if (typeof instance.componentWillRecieveProps === 'function') {\n                    error('%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', name);\n                }\n                if (typeof instance.UNSAFE_componentWillRecieveProps === 'function') {\n                    error('%s has a method called ' + 'UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?', name);\n                }\n                var hasMutatedProps = instance.props !== newProps;\n                if (instance.props !== undefined && hasMutatedProps) {\n                    error('When calling super() in `%s`, make sure to pass ' + \"up the same props that your component's constructor was passed.\", name);\n                }\n                if (instance.defaultProps) {\n                    error('Setting defaultProps as an instance property on %s is not supported and will be ignored.' + ' Instead, define defaultProps as a static property on %s.', name, name);\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === 'function' && typeof instance.componentDidUpdate !== 'function' && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {\n                    didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);\n                    error('%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). ' + 'This component defines getSnapshotBeforeUpdate() only.', getComponentNameFromType(ctor));\n                }\n                if (typeof instance.getDerivedStateFromProps === 'function') {\n                    error('%s: getDerivedStateFromProps() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);\n                }\n                if (typeof instance.getDerivedStateFromError === 'function') {\n                    error('%s: getDerivedStateFromError() is defined as an instance method ' + 'and will be ignored. Instead, declare it as a static method.', name);\n                }\n                if (typeof ctor.getSnapshotBeforeUpdate === 'function') {\n                    error('%s: getSnapshotBeforeUpdate() is defined as a static method ' + 'and will be ignored. Instead, declare it as an instance method.', name);\n                }\n                var state = instance.state;\n                if (state && (typeof state !== 'object' || isArray(state))) {\n                    error('%s.state: must be set to an object or null', name);\n                }\n                if (typeof instance.getChildContext === 'function' && typeof ctor.childContextTypes !== 'object') {\n                    error('%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', name);\n                }\n            }\n        }\n        function constructClassInstance(workInProgress, ctor, props) {\n            var context = emptyContextObject;\n            var contextType = ctor.contextType;\n            {\n                if ('contextType' in ctor) {\n                    var isValid = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE;\n                    if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {\n                        didWarnAboutInvalidateContextType.add(ctor);\n                        var addendum = '';\n                        if (contextType === undefined) {\n                            addendum = ' However, it is set to undefined. ' + 'This can be caused by a typo or by mixing up named and default imports. ' + 'This can also happen due to a circular dependency, so ' + 'try moving the createContext() call to a separate file.';\n                        } else if (typeof contextType !== 'object') {\n                            addendum = ' However, it is set to a ' + typeof contextType + '.';\n                        } else if (contextType.$$typeof === REACT_CONSUMER_TYPE) {\n                            addendum = ' Did you accidentally pass the Context.Consumer instead?';\n                        } else {\n                            addendum = ' However, it is set to an object with keys {' + Object.keys(contextType).join(', ') + '}.';\n                        }\n                        error('%s defines an invalid contextType. ' + 'contextType should point to the Context object returned by React.createContext().%s', getComponentNameFromType(ctor) || 'Component', addendum);\n                    }\n                }\n            }\n            if (typeof contextType === 'object' && contextType !== null) {\n                context = readContext(contextType);\n            }\n            var instance = new ctor(props, context); // Instantiate twice to help detect side-effects.\n            {\n                if (workInProgress.mode & StrictLegacyMode) {\n                    setIsStrictModeForDevtools(true);\n                    try {\n                        instance = new ctor(props, context); // eslint-disable-line no-new\n                    } finally{\n                        setIsStrictModeForDevtools(false);\n                    }\n                }\n            }\n            var state = workInProgress.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;\n            instance.updater = classComponentUpdater;\n            workInProgress.stateNode = instance; // The instance needs access to the fiber so that it can schedule updates\n            set(instance, workInProgress);\n            {\n                instance._reactInternalInstance = fakeInternalInstance;\n            }\n            {\n                if (typeof ctor.getDerivedStateFromProps === 'function' && state === null) {\n                    var componentName = getComponentNameFromType(ctor) || 'Component';\n                    if (!didWarnAboutUninitializedState.has(componentName)) {\n                        didWarnAboutUninitializedState.add(componentName);\n                        error('`%s` uses `getDerivedStateFromProps` but its initial state is ' + '%s. This is not recommended. Instead, define the initial state by ' + 'assigning an object to `this.state` in the constructor of `%s`. ' + 'This ensures that `getDerivedStateFromProps` arguments have a consistent shape.', componentName, instance.state === null ? 'null' : 'undefined', componentName);\n                    }\n                } // If new component APIs are defined, \"unsafe\" lifecycles won't be called.\n                // Warn about these lifecycles if they are present.\n                // Don't warn about react-lifecycles-compat polyfilled methods though.\n                if (typeof ctor.getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function') {\n                    var foundWillMountName = null;\n                    var foundWillReceivePropsName = null;\n                    var foundWillUpdateName = null;\n                    if (typeof instance.componentWillMount === 'function' && instance.componentWillMount.__suppressDeprecationWarning !== true) {\n                        foundWillMountName = 'componentWillMount';\n                    } else if (typeof instance.UNSAFE_componentWillMount === 'function') {\n                        foundWillMountName = 'UNSAFE_componentWillMount';\n                    }\n                    if (typeof instance.componentWillReceiveProps === 'function' && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {\n                        foundWillReceivePropsName = 'componentWillReceiveProps';\n                    } else if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n                        foundWillReceivePropsName = 'UNSAFE_componentWillReceiveProps';\n                    }\n                    if (typeof instance.componentWillUpdate === 'function' && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {\n                        foundWillUpdateName = 'componentWillUpdate';\n                    } else if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n                        foundWillUpdateName = 'UNSAFE_componentWillUpdate';\n                    }\n                    if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {\n                        var _componentName = getComponentNameFromType(ctor) || 'Component';\n                        var newApiName = typeof ctor.getDerivedStateFromProps === 'function' ? 'getDerivedStateFromProps()' : 'getSnapshotBeforeUpdate()';\n                        if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {\n                            didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);\n                            error('Unsafe legacy lifecycles will not be called for components using new component APIs.\\n\\n' + '%s uses %s but also contains the following legacy lifecycles:%s%s%s\\n\\n' + 'The above lifecycles should be removed. Learn more about this warning here:\\n' + 'https://react.dev/link/unsafe-component-lifecycles', _componentName, newApiName, foundWillMountName !== null ? \"\\n  \" + foundWillMountName : '', foundWillReceivePropsName !== null ? \"\\n  \" + foundWillReceivePropsName : '', foundWillUpdateName !== null ? \"\\n  \" + foundWillUpdateName : '');\n                        }\n                    }\n                }\n            }\n            return instance;\n        }\n        function callComponentWillMount(workInProgress, instance) {\n            var oldState = instance.state;\n            if (typeof instance.componentWillMount === 'function') {\n                instance.componentWillMount();\n            }\n            if (typeof instance.UNSAFE_componentWillMount === 'function') {\n                instance.UNSAFE_componentWillMount();\n            }\n            if (oldState !== instance.state) {\n                {\n                    error('%s.componentWillMount(): Assigning directly to this.state is ' + \"deprecated (except inside a component's \" + 'constructor). Use setState instead.', getComponentNameFromFiber(workInProgress) || 'Component');\n                }\n                classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n            }\n        }\n        function callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext) {\n            var oldState = instance.state;\n            if (typeof instance.componentWillReceiveProps === 'function') {\n                instance.componentWillReceiveProps(newProps, nextContext);\n            }\n            if (typeof instance.UNSAFE_componentWillReceiveProps === 'function') {\n                instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n            }\n            if (instance.state !== oldState) {\n                {\n                    var componentName = getComponentNameFromFiber(workInProgress) || 'Component';\n                    if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {\n                        didWarnAboutStateAssignmentForComponent.add(componentName);\n                        error('%s.componentWillReceiveProps(): Assigning directly to ' + \"this.state is deprecated (except inside a component's \" + 'constructor). Use setState instead.', componentName);\n                    }\n                }\n                classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n            }\n        } // Invokes the mount life-cycles on a previously never rendered instance.\n        function mountClassInstance(workInProgress, ctor, newProps, renderLanes) {\n            {\n                checkClassInstance(workInProgress, ctor, newProps);\n            }\n            var instance = workInProgress.stateNode;\n            instance.props = newProps;\n            instance.state = workInProgress.memoizedState;\n            instance.refs = {};\n            initializeUpdateQueue(workInProgress);\n            var contextType = ctor.contextType;\n            if (typeof contextType === 'object' && contextType !== null) {\n                instance.context = readContext(contextType);\n            } else {\n                instance.context = emptyContextObject;\n            }\n            {\n                if (instance.state === newProps) {\n                    var componentName = getComponentNameFromType(ctor) || 'Component';\n                    if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {\n                        didWarnAboutDirectlyAssigningPropsToState.add(componentName);\n                        error('%s: It is not recommended to assign props directly to state ' + \"because updates to props won't be reflected in state. \" + 'In most cases, it is better to use props directly.', componentName);\n                    }\n                }\n                if (workInProgress.mode & StrictLegacyMode) {\n                    ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, instance);\n                }\n                ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress, instance);\n            }\n            instance.state = workInProgress.memoizedState;\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n            if (typeof getDerivedStateFromProps === 'function') {\n                applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n                instance.state = workInProgress.memoizedState;\n            } // In order to support react-lifecycles-compat polyfilled components,\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\n            if (typeof ctor.getDerivedStateFromProps !== 'function' && typeof instance.getSnapshotBeforeUpdate !== 'function' && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n                callComponentWillMount(workInProgress, instance); // If we had additional state updates during this life-cycle, let's\n                // process them now.\n                processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n                suspendIfUpdateReadFromEntangledAsyncAction();\n                instance.state = workInProgress.memoizedState;\n            }\n            if (typeof instance.componentDidMount === 'function') {\n                workInProgress.flags |= Update | LayoutStatic;\n            }\n            if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                workInProgress.flags |= MountLayoutDev;\n            }\n        }\n        function resumeMountClassInstance(workInProgress, ctor, newProps, renderLanes) {\n            var instance = workInProgress.stateNode;\n            var unresolvedOldProps = workInProgress.memoizedProps;\n            var oldProps = resolveClassComponentProps(ctor, unresolvedOldProps);\n            instance.props = oldProps;\n            var oldContext = instance.context;\n            var contextType = ctor.contextType;\n            var nextContext = emptyContextObject;\n            if (typeof contextType === 'object' && contextType !== null) {\n                nextContext = readContext(contextType);\n            }\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n            var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // When comparing whether props changed, we should compare using the\n            // unresolved props object that is stored on the fiber, rather than the\n            // one that gets assigned to the instance, because that object may have been\n            // cloned to resolve default props and/or remove `ref`.\n            var unresolvedNewProps = workInProgress.pendingProps;\n            var didReceiveNewProps = unresolvedNewProps !== unresolvedOldProps; // Note: During these life-cycles, instance.props/instance.state are what\n            // ever the previously attempted to render - not the \"current\". However,\n            // during componentDidUpdate we pass the \"current\" props.\n            // In order to support react-lifecycles-compat polyfilled components,\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\n            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n                if (didReceiveNewProps || oldContext !== nextContext) {\n                    callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n                }\n            }\n            resetHasForceUpdateBeforeProcessing();\n            var oldState = workInProgress.memoizedState;\n            var newState = instance.state = oldState;\n            processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n            suspendIfUpdateReadFromEntangledAsyncAction();\n            newState = workInProgress.memoizedState;\n            if (!didReceiveNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {\n                // If an update was already in progress, we should schedule an Update\n                // effect even though we're bailing out, so that cWU/cDU are called.\n                if (typeof instance.componentDidMount === 'function') {\n                    workInProgress.flags |= Update | LayoutStatic;\n                }\n                if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                    workInProgress.flags |= MountLayoutDev;\n                }\n                return false;\n            }\n            if (typeof getDerivedStateFromProps === 'function') {\n                applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n                newState = workInProgress.memoizedState;\n            }\n            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext);\n            if (shouldUpdate) {\n                // In order to support react-lifecycles-compat polyfilled components,\n                // Unsafe lifecycles should not be invoked for components using the new APIs.\n                if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === 'function' || typeof instance.componentWillMount === 'function')) {\n                    if (typeof instance.componentWillMount === 'function') {\n                        instance.componentWillMount();\n                    }\n                    if (typeof instance.UNSAFE_componentWillMount === 'function') {\n                        instance.UNSAFE_componentWillMount();\n                    }\n                }\n                if (typeof instance.componentDidMount === 'function') {\n                    workInProgress.flags |= Update | LayoutStatic;\n                }\n                if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                    workInProgress.flags |= MountLayoutDev;\n                }\n            } else {\n                // If an update was already in progress, we should schedule an Update\n                // effect even though we're bailing out, so that cWU/cDU are called.\n                if (typeof instance.componentDidMount === 'function') {\n                    workInProgress.flags |= Update | LayoutStatic;\n                }\n                if ((workInProgress.mode & StrictEffectsMode) !== NoMode) {\n                    workInProgress.flags |= MountLayoutDev;\n                } // If shouldComponentUpdate returned false, we should still update the\n                // memoized state to indicate that this work can be reused.\n                workInProgress.memoizedProps = newProps;\n                workInProgress.memoizedState = newState;\n            } // Update the existing instance's state, props, and context pointers even\n            // if shouldComponentUpdate returns false.\n            instance.props = newProps;\n            instance.state = newState;\n            instance.context = nextContext;\n            return shouldUpdate;\n        } // Invokes the update life-cycles and returns false if it shouldn't rerender.\n        function updateClassInstance(current, workInProgress, ctor, newProps, renderLanes) {\n            var instance = workInProgress.stateNode;\n            cloneUpdateQueue(current, workInProgress);\n            var unresolvedOldProps = workInProgress.memoizedProps;\n            var oldProps = resolveClassComponentProps(ctor, unresolvedOldProps);\n            instance.props = oldProps;\n            var unresolvedNewProps = workInProgress.pendingProps;\n            var oldContext = instance.context;\n            var contextType = ctor.contextType;\n            var nextContext = emptyContextObject;\n            if (typeof contextType === 'object' && contextType !== null) {\n                nextContext = readContext(contextType);\n            }\n            var getDerivedStateFromProps = ctor.getDerivedStateFromProps;\n            var hasNewLifecycles = typeof getDerivedStateFromProps === 'function' || typeof instance.getSnapshotBeforeUpdate === 'function'; // Note: During these life-cycles, instance.props/instance.state are what\n            // ever the previously attempted to render - not the \"current\". However,\n            // during componentDidUpdate we pass the \"current\" props.\n            // In order to support react-lifecycles-compat polyfilled components,\n            // Unsafe lifecycles should not be invoked for components using the new APIs.\n            if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === 'function' || typeof instance.componentWillReceiveProps === 'function')) {\n                if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {\n                    callComponentWillReceiveProps(workInProgress, instance, newProps, nextContext);\n                }\n            }\n            resetHasForceUpdateBeforeProcessing();\n            var oldState = workInProgress.memoizedState;\n            var newState = instance.state = oldState;\n            processUpdateQueue(workInProgress, newProps, instance, renderLanes);\n            suspendIfUpdateReadFromEntangledAsyncAction();\n            newState = workInProgress.memoizedState;\n            if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation) {\n                // If an update was already in progress, we should schedule an Update\n                // effect even though we're bailing out, so that cWU/cDU are called.\n                if (typeof instance.componentDidUpdate === 'function') {\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n                        workInProgress.flags |= Update;\n                    }\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n                        workInProgress.flags |= Snapshot;\n                    }\n                }\n                return false;\n            }\n            if (typeof getDerivedStateFromProps === 'function') {\n                applyDerivedStateFromProps(workInProgress, ctor, getDerivedStateFromProps, newProps);\n                newState = workInProgress.memoizedState;\n            }\n            var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress, ctor, oldProps, newProps, oldState, newState, nextContext) || // TODO: In some cases, we'll end up checking if context has changed twice,\n            // both before and after `shouldComponentUpdate` has been called. Not ideal,\n            // but I'm loath to refactor this function. This only happens for memoized\n            // components so it's not that common.\n            enableLazyContextPropagation;\n            if (shouldUpdate) {\n                // In order to support react-lifecycles-compat polyfilled components,\n                // Unsafe lifecycles should not be invoked for components using the new APIs.\n                if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === 'function' || typeof instance.componentWillUpdate === 'function')) {\n                    if (typeof instance.componentWillUpdate === 'function') {\n                        instance.componentWillUpdate(newProps, newState, nextContext);\n                    }\n                    if (typeof instance.UNSAFE_componentWillUpdate === 'function') {\n                        instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);\n                    }\n                }\n                if (typeof instance.componentDidUpdate === 'function') {\n                    workInProgress.flags |= Update;\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n                    workInProgress.flags |= Snapshot;\n                }\n            } else {\n                // If an update was already in progress, we should schedule an Update\n                // effect even though we're bailing out, so that cWU/cDU are called.\n                if (typeof instance.componentDidUpdate === 'function') {\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n                        workInProgress.flags |= Update;\n                    }\n                }\n                if (typeof instance.getSnapshotBeforeUpdate === 'function') {\n                    if (unresolvedOldProps !== current.memoizedProps || oldState !== current.memoizedState) {\n                        workInProgress.flags |= Snapshot;\n                    }\n                } // If shouldComponentUpdate returned false, we should still update the\n                // memoized props/state to indicate that this work can be reused.\n                workInProgress.memoizedProps = newProps;\n                workInProgress.memoizedState = newState;\n            } // Update the existing instance's state, props, and context pointers even\n            // if shouldComponentUpdate returns false.\n            instance.props = newProps;\n            instance.state = newState;\n            instance.context = nextContext;\n            return shouldUpdate;\n        }\n        function resolveClassComponentProps(Component, baseProps, // would have already been resolved by the JSX runtime.\n        // TODO: We're going to remove default prop resolution from the JSX runtime\n        // and keep it only for class components. As part of that change, we should\n        // remove this extra check.\n        alreadyResolvedDefaultProps) {\n            var newProps = baseProps;\n            {\n                // Remove ref from the props object, if it exists.\n                if ('ref' in baseProps) {\n                    newProps = {};\n                    for(var propName in baseProps){\n                        if (propName !== 'ref') {\n                            newProps[propName] = baseProps[propName];\n                        }\n                    }\n                }\n            }\n            var defaultProps = Component.defaultProps;\n            if (defaultProps && // default props here in the reconciler, rather than in the JSX runtime.\n            disableDefaultPropsExceptForClasses) {\n                // We may have already copied the props object above to remove ref. If so,\n                // we can modify that. Otherwise, copy the props object with Object.assign.\n                if (newProps === baseProps) {\n                    newProps = assign({}, newProps);\n                } // Taken from old JSX runtime, where this used to live.\n                for(var _propName in defaultProps){\n                    if (newProps[_propName] === undefined) {\n                        newProps[_propName] = defaultProps[_propName];\n                    }\n                }\n            }\n            return newProps;\n        }\n        var reportGlobalError = typeof reportError === 'function' ? // emulating an uncaught JavaScript error.\n        reportError : function(error) {\n            if (false) { var shouldLog, event, message; } else if (typeof process === 'object' && // $FlowFixMe[method-unbinding]\n            typeof process.emit === 'function') {\n                // Node Polyfill\n                process.emit('uncaughtException', error);\n                return;\n            } // eslint-disable-next-line react-internal/no-production-logging\n            console['error'](error);\n        };\n        var componentName = null;\n        var errorBoundaryName = null;\n        function defaultOnUncaughtError(error, errorInfo) {\n            // Overriding this can silence these warnings e.g. for tests.\n            // See https://github.com/facebook/react/pull/13384\n            // For uncaught root errors we report them as uncaught to the browser's\n            // onerror callback. This won't have component stacks and the error addendum.\n            // So we add those into a separate console.warn.\n            reportGlobalError(error);\n            {\n                var componentNameMessage = componentName ? \"An error occurred in the <\" + componentName + \"> component.\" : 'An error occurred in one of your React components.';\n                var errorBoundaryMessage = 'Consider adding an error boundary to your tree to customize error handling behavior.\\n' + 'Visit https://react.dev/link/error-boundaries to learn more about error boundaries.';\n                {\n                    // The current Fiber is disconnected at this point which means that console printing\n                    // cannot add a component stack since it terminates at the deletion node. This is not\n                    // a problem for owner stacks which are not disconnected but for the parent component\n                    // stacks we need to use the snapshot we've previously extracted.\n                    var componentStack = errorInfo.componentStack != null ? errorInfo.componentStack : ''; // Don't transform to our wrapper\n                    console['warn']('%s\\n\\n%s\\n%s', componentNameMessage, errorBoundaryMessage, componentStack);\n                }\n            }\n        }\n        function defaultOnCaughtError(error$1, errorInfo) {\n            // Overriding this can silence these warnings e.g. for tests.\n            // See https://github.com/facebook/react/pull/13384\n            // Caught by error boundary\n            {\n                var componentNameMessage = componentName ? \"The above error occurred in the <\" + componentName + \"> component.\" : 'The above error occurred in one of your React components.'; // In development, we provide our own message which includes the component stack\n                // in addition to the error.\n                var recreateMessage = \"React will try to recreate this component tree from scratch \" + (\"using the error boundary you provided, \" + (errorBoundaryName || 'Anonymous') + \".\");\n                {\n                    // The current Fiber is disconnected at this point which means that console printing\n                    // cannot add a component stack since it terminates at the deletion node. This is not\n                    // a problem for owner stacks which are not disconnected but for the parent component\n                    // stacks we need to use the snapshot we've previously extracted.\n                    var componentStack = errorInfo.componentStack != null ? errorInfo.componentStack : ''; // Don't transform to our wrapper\n                    console['error']('%o\\n\\n%s\\n\\n%s\\n%s', error$1, componentNameMessage, recreateMessage, componentStack);\n                }\n            }\n        }\n        function defaultOnRecoverableError(error, errorInfo) {\n            reportGlobalError(error);\n        }\n        function logUncaughtError(root, errorInfo) {\n            try {\n                if (true) {\n                    componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;\n                    errorBoundaryName = null;\n                }\n                var error = errorInfo.value;\n                if ( true && ReactSharedInternals.actQueue !== null) {\n                    // For uncaught errors inside act, we track them on the act and then\n                    // rethrow them into the test.\n                    ReactSharedInternals.thrownErrors.push(error);\n                    return;\n                }\n                var onUncaughtError = root.onUncaughtError;\n                onUncaughtError(error, {\n                    componentStack: errorInfo.stack\n                });\n            } catch (e) {\n                // This method must not throw, or React internal state will get messed up.\n                // If console.error is overridden, or logCapturedError() shows a dialog that throws,\n                // we want to report this error outside of the normal stack as a last resort.\n                // https://github.com/facebook/react/issues/13188\n                setTimeout(function() {\n                    throw e;\n                });\n            }\n        }\n        function logCaughtError(root, boundary, errorInfo) {\n            try {\n                if (true) {\n                    componentName = errorInfo.source ? getComponentNameFromFiber(errorInfo.source) : null;\n                    errorBoundaryName = getComponentNameFromFiber(boundary);\n                }\n                var error = errorInfo.value;\n                var onCaughtError = root.onCaughtError;\n                onCaughtError(error, {\n                    componentStack: errorInfo.stack,\n                    errorBoundary: boundary.tag === ClassComponent ? boundary.stateNode // This should always be the case as long as we only have class boundaries\n                     : null\n                });\n            } catch (e) {\n                // This method must not throw, or React internal state will get messed up.\n                // If console.error is overridden, or logCapturedError() shows a dialog that throws,\n                // we want to report this error outside of the normal stack as a last resort.\n                // https://github.com/facebook/react/issues/13188\n                setTimeout(function() {\n                    throw e;\n                });\n            }\n        }\n        function createRootErrorUpdate(root, errorInfo, lane) {\n            var update = createUpdate(lane); // Unmount the root by rendering null.\n            update.tag = CaptureUpdate; // Caution: React DevTools currently depends on this property\n            // being called \"element\".\n            update.payload = {\n                element: null\n            };\n            update.callback = function() {\n                var prevFiber = getCurrentFiber(); // should just be the root\n                setCurrentDebugFiberInDEV(errorInfo.source);\n                logUncaughtError(root, errorInfo);\n                setCurrentDebugFiberInDEV(prevFiber);\n            };\n            return update;\n        }\n        function createClassErrorUpdate(lane) {\n            var update = createUpdate(lane);\n            update.tag = CaptureUpdate;\n            return update;\n        }\n        function initializeClassErrorUpdate(update, root, fiber, errorInfo) {\n            var getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n            if (typeof getDerivedStateFromError === 'function') {\n                var error$1 = errorInfo.value;\n                update.payload = function() {\n                    return getDerivedStateFromError(error$1);\n                };\n                update.callback = function() {\n                    {\n                        markFailedErrorBoundaryForHotReloading(fiber);\n                    }\n                    var prevFiber = getCurrentFiber(); // should be the error boundary\n                    setCurrentDebugFiberInDEV(errorInfo.source);\n                    logCaughtError(root, fiber, errorInfo);\n                    setCurrentDebugFiberInDEV(prevFiber);\n                };\n            }\n            var inst = fiber.stateNode;\n            if (inst !== null && typeof inst.componentDidCatch === 'function') {\n                // $FlowFixMe[missing-this-annot]\n                update.callback = function callback() {\n                    {\n                        markFailedErrorBoundaryForHotReloading(fiber);\n                    }\n                    var prevFiber = getCurrentFiber(); // should be the error boundary\n                    setCurrentDebugFiberInDEV(errorInfo.source);\n                    logCaughtError(root, fiber, errorInfo);\n                    setCurrentDebugFiberInDEV(prevFiber);\n                    if (typeof getDerivedStateFromError !== 'function') {\n                        // To preserve the preexisting retry behavior of error boundaries,\n                        // we keep track of which ones already failed during this batch.\n                        // This gets reset before we yield back to the browser.\n                        // TODO: Warn in strict mode if getDerivedStateFromError is\n                        // not defined.\n                        markLegacyErrorBoundaryAsFailed(this);\n                    }\n                    var error$1 = errorInfo.value;\n                    var stack = errorInfo.stack;\n                    this.componentDidCatch(error$1, {\n                        componentStack: stack !== null ? stack : ''\n                    });\n                    {\n                        if (typeof getDerivedStateFromError !== 'function') {\n                            // If componentDidCatch is the only error boundary method defined,\n                            // then it needs to call setState to recover from errors.\n                            // If no state update is scheduled then the boundary will swallow the error.\n                            if (!includesSomeLane(fiber.lanes, SyncLane)) {\n                                error('%s: Error boundaries should implement getDerivedStateFromError(). ' + 'In that method, return a state update to display an error message or fallback UI.', getComponentNameFromFiber(fiber) || 'Unknown');\n                            }\n                        }\n                    }\n                };\n            }\n        }\n        function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes) {\n            // with the normal suspend path.\n            //\n            // After this we'll use a set of heuristics to determine whether this\n            // render pass will run to completion or restart or \"suspend\" the commit.\n            // The actual logic for this is spread out in different places.\n            //\n            // This first principle is that if we're going to suspend when we complete\n            // a root, then we should also restart if we get an update or ping that\n            // might unsuspend it, and vice versa. The only reason to suspend is\n            // because you think you might want to restart before committing. However,\n            // it doesn't make sense to restart only while in the period we're suspended.\n            //\n            // Restarting too aggressively is also not good because it starves out any\n            // intermediate loading state. So we use heuristics to determine when.\n            // Suspense Heuristics\n            //\n            // If nothing threw a Promise or all the same fallbacks are already showing,\n            // then don't suspend/restart.\n            //\n            // If this is an initial render of a new tree of Suspense boundaries and\n            // those trigger a fallback, then don't suspend/restart. We want to ensure\n            // that we can show the initial loading state as quickly as possible.\n            //\n            // If we hit a \"Delayed\" case, such as when we'd switch from content back into\n            // a fallback, then we should always suspend/restart. Transitions apply\n            // to this case. If none is defined, JND is used instead.\n            //\n            // If we're already showing a fallback and it gets \"retried\", allowing us to show\n            // another level, but there's still an inner boundary that would show a fallback,\n            // then we suspend/restart for 500ms since the last time we showed a fallback\n            // anywhere in the tree. This effectively throttles progressive loading into a\n            // consistent train of commits. This also gives us an opportunity to restart to\n            // get to the completed state slightly earlier.\n            //\n            // If there's ambiguity due to batching it's resolved in preference of:\n            // 1) \"delayed\", 2) \"initial render\", 3) \"retry\".\n            //\n            // We want to ensure that a \"busy\" state doesn't get force committed. We want to\n            // ensure that new initial loading states can commit as soon as possible.\n            suspenseBoundary.flags |= ShouldCapture; // TODO: I think we can remove this, since we now use `DidCapture` in\n            // the begin phase to prevent an early bailout.\n            suspenseBoundary.lanes = rootRenderLanes;\n            return suspenseBoundary;\n        }\n        function throwException(root, returnFiber, sourceFiber, value, rootRenderLanes) {\n            // The source fiber did not complete.\n            sourceFiber.flags |= Incomplete;\n            {\n                if (isDevToolsPresent) {\n                    // If we have pending work still, restore the original updaters\n                    restorePendingUpdaters(root, rootRenderLanes);\n                }\n            }\n            if (value !== null && typeof value === 'object') {\n                if (typeof value.then === 'function') {\n                    // This is a wakeable. The component suspended.\n                    var wakeable = value;\n                    {\n                        if (getIsHydrating() && disableLegacyMode) {\n                            markDidThrowWhileHydratingDEV();\n                        }\n                    }\n                    var suspenseBoundary = getSuspenseHandler();\n                    if (suspenseBoundary !== null) {\n                        switch(suspenseBoundary.tag){\n                            case SuspenseComponent:\n                                {\n                                    // If this suspense boundary is not already showing a fallback, mark\n                                    // the in-progress render as suspended. We try to perform this logic\n                                    // as soon as soon as possible during the render phase, so the work\n                                    // loop can know things like whether it's OK to switch to other tasks,\n                                    // or whether it can wait for data to resolve before continuing.\n                                    // TODO: Most of these checks are already performed when entering a\n                                    // Suspense boundary. We should track the information on the stack so\n                                    // we don't have to recompute it on demand. This would also allow us\n                                    // to unify with `use` which needs to perform this logic even sooner,\n                                    // before `throwException` is called.\n                                    {\n                                        if (getShellBoundary() === null) {\n                                            // Suspended in the \"shell\" of the app. This is an undesirable\n                                            // loading state. We should avoid committing this tree.\n                                            renderDidSuspendDelayIfPossible();\n                                        } else {\n                                            // If we suspended deeper than the shell, we don't need to delay\n                                            // the commmit. However, we still call renderDidSuspend if this is\n                                            // a new boundary, to tell the work loop that a new fallback has\n                                            // appeared during this render.\n                                            // TODO: Theoretically we should be able to delete this branch.\n                                            // It's currently used for two things: 1) to throttle the\n                                            // appearance of successive loading states, and 2) in\n                                            // SuspenseList, to determine whether the children include any\n                                            // pending fallbacks. For 1, we should apply throttling to all\n                                            // retries, not just ones that render an additional fallback. For\n                                            // 2, we should check subtreeFlags instead. Then we can delete\n                                            // this branch.\n                                            var current = suspenseBoundary.alternate;\n                                            if (current === null) {\n                                                renderDidSuspend();\n                                            }\n                                        }\n                                    }\n                                    suspenseBoundary.flags &= ~ForceClientRender;\n                                    markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes); // Retry listener\n                                    //\n                                    // If the fallback does commit, we need to attach a different type of\n                                    // listener. This one schedules an update on the Suspense boundary to\n                                    // turn the fallback state off.\n                                    //\n                                    // Stash the wakeable on the boundary fiber so we can access it in the\n                                    // commit phase.\n                                    //\n                                    // When the wakeable resolves, we'll attempt to render the boundary\n                                    // again (\"retry\").\n                                    // Check if this is a Suspensey resource. We do not attach retry\n                                    // listeners to these, because we don't actually need them for\n                                    // rendering. Only for committing. Instead, if a fallback commits\n                                    // and the only thing that suspended was a Suspensey resource, we\n                                    // retry immediately.\n                                    // TODO: Refactor throwException so that we don't have to do this type\n                                    // check. The caller already knows what the cause was.\n                                    var isSuspenseyResource = wakeable === noopSuspenseyCommitThenable;\n                                    if (isSuspenseyResource) {\n                                        suspenseBoundary.flags |= ScheduleRetry;\n                                    } else {\n                                        var retryQueue = suspenseBoundary.updateQueue;\n                                        if (retryQueue === null) {\n                                            suspenseBoundary.updateQueue = new Set([\n                                                wakeable\n                                            ]);\n                                        } else {\n                                            retryQueue.add(wakeable);\n                                        } // We only attach ping listeners in concurrent mode. Legacy\n                                        // Suspense always commits fallbacks synchronously, so there are\n                                        // no pings.\n                                        {\n                                            attachPingListener(root, wakeable, rootRenderLanes);\n                                        }\n                                    }\n                                    return false;\n                                }\n                            case OffscreenComponent:\n                                {\n                                    {\n                                        suspenseBoundary.flags |= ShouldCapture;\n                                        var _isSuspenseyResource = wakeable === noopSuspenseyCommitThenable;\n                                        if (_isSuspenseyResource) {\n                                            suspenseBoundary.flags |= ScheduleRetry;\n                                        } else {\n                                            var offscreenQueue = suspenseBoundary.updateQueue;\n                                            if (offscreenQueue === null) {\n                                                var newOffscreenQueue = {\n                                                    transitions: null,\n                                                    markerInstances: null,\n                                                    retryQueue: new Set([\n                                                        wakeable\n                                                    ])\n                                                };\n                                                suspenseBoundary.updateQueue = newOffscreenQueue;\n                                            } else {\n                                                var _retryQueue = offscreenQueue.retryQueue;\n                                                if (_retryQueue === null) {\n                                                    offscreenQueue.retryQueue = new Set([\n                                                        wakeable\n                                                    ]);\n                                                } else {\n                                                    _retryQueue.add(wakeable);\n                                                }\n                                            }\n                                            attachPingListener(root, wakeable, rootRenderLanes);\n                                        }\n                                        return false;\n                                    }\n                                }\n                        }\n                        throw new Error(\"Unexpected Suspense handler tag (\" + suspenseBoundary.tag + \"). This \" + 'is a bug in React.');\n                    } else {\n                        // No boundary was found. Unless this is a sync update, this is OK.\n                        // We can suspend and wait for more data to arrive.\n                        {\n                            // In a concurrent root, suspending without a Suspense boundary is\n                            // allowed. It will suspend indefinitely without committing.\n                            //\n                            // TODO: Should we have different behavior for discrete updates? What\n                            // about flushSync? Maybe it should put the tree into an inert state,\n                            // and potentially log a warning. Revisit this for a future release.\n                            attachPingListener(root, wakeable, rootRenderLanes);\n                            renderDidSuspendDelayIfPossible();\n                            return false;\n                        }\n                    }\n                }\n            } // This is a regular error, not a Suspense wakeable.\n            if (getIsHydrating() && disableLegacyMode) {\n                markDidThrowWhileHydratingDEV();\n                var _suspenseBoundary = getSuspenseHandler(); // If the error was thrown during hydration, we may be able to recover by\n                // discarding the dehydrated content and switching to a client render.\n                // Instead of surfacing the error, find the nearest Suspense boundary\n                // and render it again without hydration.\n                if (_suspenseBoundary !== null) {\n                    if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags$1) {\n                        // Set a flag to indicate that we should try rendering the normal\n                        // children again, not the fallback.\n                        _suspenseBoundary.flags |= ForceClientRender;\n                    }\n                    markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root, rootRenderLanes); // Even though the user may not be affected by this error, we should\n                    // still log it so it can be fixed.\n                    if (value !== HydrationMismatchException) {\n                        var _wrapperError = new Error('There was an error while hydrating but React was able to recover by ' + 'instead client rendering from the nearest Suspense boundary.', {\n                            cause: value\n                        });\n                        queueHydrationError(createCapturedValueAtFiber(_wrapperError, sourceFiber));\n                    }\n                    return false;\n                } else {\n                    if (value !== HydrationMismatchException) {\n                        var _wrapperError2 = new Error('There was an error while hydrating but React was able to recover by ' + 'instead client rendering the entire root.', {\n                            cause: value\n                        });\n                        queueHydrationError(createCapturedValueAtFiber(_wrapperError2, sourceFiber));\n                    }\n                    var _workInProgress = root.current.alternate; // Schedule an update at the root to log the error but this shouldn't\n                    // actually happen because we should recover.\n                    _workInProgress.flags |= ShouldCapture;\n                    var lane = pickArbitraryLane(rootRenderLanes);\n                    _workInProgress.lanes = mergeLanes(_workInProgress.lanes, lane);\n                    var rootErrorInfo = createCapturedValueAtFiber(value, sourceFiber);\n                    var update = createRootErrorUpdate(_workInProgress.stateNode, rootErrorInfo, lane);\n                    enqueueCapturedUpdate(_workInProgress, update);\n                    renderDidError();\n                    return false;\n                }\n            }\n            var wrapperError = new Error('There was an error during concurrent rendering but React was able to recover by ' + 'instead synchronously rendering the entire root.', {\n                cause: value\n            });\n            queueConcurrentError(createCapturedValueAtFiber(wrapperError, sourceFiber));\n            renderDidError(); // We didn't find a boundary that could handle this type of exception. Start\n            // over and traverse parent path again, this time treating the exception\n            // as an error.\n            if (returnFiber === null) {\n                // There's no return fiber, which means the root errored. This should never\n                // happen. Return `true` to trigger a fatal error (panic).\n                return true;\n            }\n            var errorInfo = createCapturedValueAtFiber(value, sourceFiber);\n            var workInProgress = returnFiber;\n            do {\n                switch(workInProgress.tag){\n                    case HostRoot:\n                        {\n                            workInProgress.flags |= ShouldCapture;\n                            var _lane = pickArbitraryLane(rootRenderLanes);\n                            workInProgress.lanes = mergeLanes(workInProgress.lanes, _lane);\n                            var _update = createRootErrorUpdate(workInProgress.stateNode, errorInfo, _lane);\n                            enqueueCapturedUpdate(workInProgress, _update);\n                            return false;\n                        }\n                    case ClassComponent:\n                        // Capture and retry\n                        var ctor = workInProgress.type;\n                        var instance = workInProgress.stateNode;\n                        if ((workInProgress.flags & DidCapture) === NoFlags$1 && (typeof ctor.getDerivedStateFromError === 'function' || instance !== null && typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance))) {\n                            workInProgress.flags |= ShouldCapture;\n                            var _lane2 = pickArbitraryLane(rootRenderLanes);\n                            workInProgress.lanes = mergeLanes(workInProgress.lanes, _lane2); // Schedule the error boundary to re-render using updated state\n                            var _update2 = createClassErrorUpdate(_lane2);\n                            initializeClassErrorUpdate(_update2, root, workInProgress, errorInfo);\n                            enqueueCapturedUpdate(workInProgress, _update2);\n                            return false;\n                        }\n                        break;\n                } // $FlowFixMe[incompatible-type] we bail out when we get a null\n                workInProgress = workInProgress.return;\n            }while (workInProgress !== null);\n            return false;\n        }\n        // into a dehydrated boundary.\n        var SelectiveHydrationException = new Error(\"This is not a real error. It's an implementation detail of React's \" + \"selective hydration feature. If this leaks into userspace, it's a bug in \" + 'React. Please file an issue.');\n        var didReceiveUpdate = false;\n        var didWarnAboutBadClass;\n        var didWarnAboutContextTypeOnFunctionComponent;\n        var didWarnAboutGetDerivedStateOnFunctionComponent;\n        var didWarnAboutReassigningProps;\n        var didWarnAboutRevealOrder;\n        var didWarnAboutTailOptions;\n        {\n            didWarnAboutBadClass = {};\n            didWarnAboutContextTypeOnFunctionComponent = {};\n            didWarnAboutGetDerivedStateOnFunctionComponent = {};\n            didWarnAboutReassigningProps = false;\n            didWarnAboutRevealOrder = {};\n            didWarnAboutTailOptions = {};\n        }\n        function reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\n            if (current === null) {\n                // If this is a fresh new component that hasn't been rendered yet, we\n                // won't update its child set by applying minimal side-effects. Instead,\n                // we will add them all to the child before it gets rendered. That means\n                // we can optimize this reconciliation pass by not tracking side-effects.\n                workInProgress.child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n            } else {\n                // If the current child is the same as the work in progress, it means that\n                // we haven't yet started any work on these children. Therefore, we use\n                // the clone algorithm to create a copy of all the current children.\n                // If we had any progressed work already, that is invalid at this point so\n                // let's throw it out.\n                workInProgress.child = reconcileChildFibers(workInProgress, current.child, nextChildren, renderLanes);\n            }\n        }\n        function forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes) {\n            // This function is fork of reconcileChildren. It's used in cases where we\n            // want to reconcile without matching against the existing set. This has the\n            // effect of all current children being unmounted; even if the type and key\n            // are the same, the old child is unmounted and a new child is created.\n            //\n            // To do this, we're going to go through the reconcile algorithm twice. In\n            // the first pass, we schedule a deletion for all the current children by\n            // passing null.\n            workInProgress.child = reconcileChildFibers(workInProgress, current.child, null, renderLanes); // In the second pass, we mount the new children. The trick here is that we\n            // pass null in place of where we usually pass the current child set. This has\n            // the effect of remounting all children regardless of whether their\n            // identities match.\n            workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n        }\n        function updateForwardRef(current, workInProgress, Component, nextProps, renderLanes) {\n            // TODO: current can be non-null here even if the component\n            // hasn't yet mounted. This happens after the first render suspends.\n            // We'll need to figure out if this is fine or can cause issues.\n            var render = Component.render;\n            var ref = workInProgress.ref;\n            var propsWithoutRef;\n            if ('ref' in nextProps) {\n                // `ref` is just a prop now, but `forwardRef` expects it to not appear in\n                // the props object. This used to happen in the JSX runtime, but now we do\n                // it here.\n                propsWithoutRef = {};\n                for(var key in nextProps){\n                    // Since `ref` should only appear in props via the JSX transform, we can\n                    // assume that this is a plain object. So we don't need a\n                    // hasOwnProperty check.\n                    if (key !== 'ref') {\n                        propsWithoutRef[key] = nextProps[key];\n                    }\n                }\n            } else {\n                propsWithoutRef = nextProps;\n            } // The rest is a fork of updateFunctionComponent\n            var nextChildren;\n            var hasId;\n            prepareToReadContext(workInProgress, renderLanes);\n            {\n                markComponentRenderStarted(workInProgress);\n            }\n            {\n                setIsRendering(true);\n                nextChildren = renderWithHooks(current, workInProgress, render, propsWithoutRef, ref, renderLanes);\n                hasId = checkDidRenderIdHook();\n                setIsRendering(false);\n            }\n            {\n                markComponentRenderStopped();\n            }\n            if (current !== null && !didReceiveUpdate) {\n                bailoutHooks(current, workInProgress, renderLanes);\n                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n            }\n            if (getIsHydrating() && hasId) {\n                pushMaterializedTreeId(workInProgress);\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n            if (current === null) {\n                var type = Component.type;\n                if (isSimpleFunctionComponent(type) && Component.compare === null && disableDefaultPropsExceptForClasses) {\n                    var resolvedType = type;\n                    {\n                        resolvedType = resolveFunctionForHotReloading(type);\n                    }\n                    // and with only the default shallow comparison, we upgrade it\n                    // to a SimpleMemoComponent to allow fast path updates.\n                    workInProgress.tag = SimpleMemoComponent;\n                    workInProgress.type = resolvedType;\n                    {\n                        validateFunctionComponentInDev(workInProgress, type);\n                    }\n                    return updateSimpleMemoComponent(current, workInProgress, resolvedType, nextProps, renderLanes);\n                }\n                var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress, workInProgress.mode, renderLanes);\n                child.ref = workInProgress.ref;\n                child.return = workInProgress;\n                workInProgress.child = child;\n                return child;\n            }\n            var currentChild = current.child; // This is always exactly one child\n            var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);\n            if (!hasScheduledUpdateOrContext) {\n                // This will be the props with resolved defaultProps,\n                // unlike current.memoizedProps which will be the unresolved ones.\n                var prevProps = currentChild.memoizedProps; // Default to shallow comparison\n                var compare = Component.compare;\n                compare = compare !== null ? compare : shallowEqual;\n                if (compare(prevProps, nextProps) && current.ref === workInProgress.ref) {\n                    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                }\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            var newChild = createWorkInProgress(currentChild, nextProps);\n            newChild.ref = workInProgress.ref;\n            newChild.return = workInProgress;\n            workInProgress.child = newChild;\n            return newChild;\n        }\n        function updateSimpleMemoComponent(current, workInProgress, Component, nextProps, renderLanes) {\n            // TODO: current can be non-null here even if the component\n            // hasn't yet mounted. This happens when the inner render suspends.\n            // We'll need to figure out if this is fine or can cause issues.\n            if (current !== null) {\n                var prevProps = current.memoizedProps;\n                if (shallowEqual(prevProps, nextProps) && current.ref === workInProgress.ref && workInProgress.type === current.type) {\n                    didReceiveUpdate = false; // The props are shallowly equal. Reuse the previous props object, like we\n                    // would during a normal fiber bailout.\n                    //\n                    // We don't have strong guarantees that the props object is referentially\n                    // equal during updates where we can't bail out anyway — like if the props\n                    // are shallowly equal, but there's a local state or context update in the\n                    // same batch.\n                    //\n                    // However, as a principle, we should aim to make the behavior consistent\n                    // across different ways of memoizing a component. For example, React.memo\n                    // has a different internal Fiber layout if you pass a normal function\n                    // component (SimpleMemoComponent) versus if you pass a different type\n                    // like forwardRef (MemoComponent). But this is an implementation detail.\n                    // Wrapping a component in forwardRef (or React.lazy, etc) shouldn't\n                    // affect whether the props object is reused during a bailout.\n                    workInProgress.pendingProps = nextProps = prevProps;\n                    if (!checkScheduledUpdateOrContext(current, renderLanes)) {\n                        // The pending lanes were cleared at the beginning of beginWork. We're\n                        // about to bail out, but there might be other lanes that weren't\n                        // included in the current render. Usually, the priority level of the\n                        // remaining updates is accumulated during the evaluation of the\n                        // component (i.e. when processing the update queue). But since since\n                        // we're bailing out early *without* evaluating the component, we need\n                        // to account for it here, too. Reset to the value of the current fiber.\n                        // NOTE: This only applies to SimpleMemoComponent, not MemoComponent,\n                        // because a MemoComponent fiber does not have hooks or an update queue;\n                        // rather, it wraps around an inner component, which may or may not\n                        // contains hooks.\n                        // TODO: Move the reset at in beginWork out of the common path so that\n                        // this is no longer necessary.\n                        workInProgress.lanes = current.lanes;\n                        return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                    } else if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags$1) {\n                        // This is a special case that only exists for legacy mode.\n                        // See https://github.com/facebook/react/pull/19216.\n                        didReceiveUpdate = true;\n                    }\n                }\n            }\n            return updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes);\n        }\n        function updateOffscreenComponent(current, workInProgress, renderLanes) {\n            var nextProps = workInProgress.pendingProps;\n            var nextChildren = nextProps.children;\n            var nextIsDetached = (workInProgress.stateNode._pendingVisibility & OffscreenDetached) !== 0;\n            var prevState = current !== null ? current.memoizedState : null;\n            markRef(current, workInProgress);\n            if (nextProps.mode === 'hidden' || enableLegacyHidden || nextIsDetached) {\n                // Rendering a hidden tree.\n                var didSuspend = (workInProgress.flags & DidCapture) !== NoFlags$1;\n                if (didSuspend) {\n                    // Something suspended inside a hidden tree\n                    // Include the base lanes from the last render\n                    var nextBaseLanes = prevState !== null ? mergeLanes(prevState.baseLanes, renderLanes) : renderLanes;\n                    if (current !== null) {\n                        // Reset to the current children\n                        var currentChild = workInProgress.child = current.child; // The current render suspended, but there may be other lanes with\n                        // pending work. We can't read `childLanes` from the current Offscreen\n                        // fiber because we reset it when it was deferred; however, we can read\n                        // the pending lanes from the child fibers.\n                        var currentChildLanes = NoLanes;\n                        while(currentChild !== null){\n                            currentChildLanes = mergeLanes(mergeLanes(currentChildLanes, currentChild.lanes), currentChild.childLanes);\n                            currentChild = currentChild.sibling;\n                        }\n                        var lanesWeJustAttempted = nextBaseLanes;\n                        var remainingChildLanes = removeLanes(currentChildLanes, lanesWeJustAttempted);\n                        workInProgress.childLanes = remainingChildLanes;\n                    } else {\n                        workInProgress.childLanes = NoLanes;\n                        workInProgress.child = null;\n                    }\n                    return deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes);\n                }\n                if (!includesSomeLane(renderLanes, OffscreenLane)) {\n                    // We're hidden, and we're not rendering at Offscreen. We will bail out\n                    // and resume this tree later.\n                    // Schedule this fiber to re-render at Offscreen priority\n                    workInProgress.lanes = workInProgress.childLanes = laneToLanes(OffscreenLane); // Include the base lanes from the last render\n                    var _nextBaseLanes = prevState !== null ? mergeLanes(prevState.baseLanes, renderLanes) : renderLanes;\n                    return deferHiddenOffscreenComponent(current, workInProgress, _nextBaseLanes);\n                } else {\n                    // This is the second render. The surrounding visible content has already\n                    // committed. Now we resume rendering the hidden tree.\n                    // Rendering at offscreen, so we can clear the base lanes.\n                    var _nextState = {\n                        baseLanes: NoLanes,\n                        cachePool: null\n                    };\n                    workInProgress.memoizedState = _nextState;\n                    if (current !== null) {\n                        // If the render that spawned this one accessed the cache pool, resume\n                        // using the same cache. Unless the parent changed, since that means\n                        // there was a refresh.\n                        var prevCachePool = prevState !== null ? prevState.cachePool : null; // TODO: Consider if and how Offscreen pre-rendering should\n                        // be attributed to the transition that spawned it\n                        pushTransition(workInProgress, prevCachePool);\n                    } // Push the lanes that were skipped when we bailed out.\n                    if (prevState !== null) {\n                        pushHiddenContext(workInProgress, prevState);\n                    } else {\n                        reuseHiddenContextOnStack(workInProgress);\n                    }\n                    pushOffscreenSuspenseHandler(workInProgress);\n                }\n            } else {\n                // Rendering a visible tree.\n                if (prevState !== null) {\n                    // We're going from hidden -> visible.\n                    var _prevCachePool = null;\n                    {\n                        // If the render that spawned this one accessed the cache pool, resume\n                        // using the same cache. Unless the parent changed, since that means\n                        // there was a refresh.\n                        _prevCachePool = prevState.cachePool;\n                    }\n                    pushTransition(workInProgress, _prevCachePool); // Push the lanes that were skipped when we bailed out.\n                    pushHiddenContext(workInProgress, prevState);\n                    reuseSuspenseHandlerOnStack(workInProgress); // Since we're not hidden anymore, reset the state\n                    workInProgress.memoizedState = null;\n                } else {\n                    // We weren't previously hidden, and we still aren't, so there's nothing\n                    // special to do. Need to push to the stack regardless, though, to avoid\n                    // a push/pop misalignment.\n                    {\n                        // If the render that spawned this one accessed the cache pool, resume\n                        // using the same cache. Unless the parent changed, since that means\n                        // there was a refresh.\n                        if (current !== null) {\n                            pushTransition(workInProgress, null);\n                        }\n                    }\n                    // to avoid a push/pop misalignment.\n                    reuseHiddenContextOnStack(workInProgress);\n                    reuseSuspenseHandlerOnStack(workInProgress);\n                }\n            }\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function deferHiddenOffscreenComponent(current, workInProgress, nextBaseLanes, renderLanes) {\n            var nextState = {\n                baseLanes: nextBaseLanes,\n                // Save the cache pool so we can resume later.\n                cachePool: getOffscreenDeferredCache()\n            };\n            workInProgress.memoizedState = nextState;\n            {\n                // push the cache pool even though we're going to bail out\n                // because otherwise there'd be a context mismatch\n                if (current !== null) {\n                    pushTransition(workInProgress, null);\n                }\n            }\n            // to avoid a push/pop misalignment.\n            reuseHiddenContextOnStack(workInProgress);\n            pushOffscreenSuspenseHandler(workInProgress);\n            return null;\n        } // Note: These happen to have identical begin phases, for now. We shouldn't hold\n        function updateCacheComponent(current, workInProgress, renderLanes) {\n            prepareToReadContext(workInProgress, renderLanes);\n            var parentCache = readContext(CacheContext);\n            if (current === null) {\n                // Initial mount. Request a fresh cache from the pool.\n                var freshCache = requestCacheFromPool(renderLanes);\n                var initialState = {\n                    parent: parentCache,\n                    cache: freshCache\n                };\n                workInProgress.memoizedState = initialState;\n                initializeUpdateQueue(workInProgress);\n                pushCacheProvider(workInProgress, freshCache);\n            } else {\n                // Check for updates\n                if (includesSomeLane(current.lanes, renderLanes)) {\n                    cloneUpdateQueue(current, workInProgress);\n                    processUpdateQueue(workInProgress, null, null, renderLanes);\n                    suspendIfUpdateReadFromEntangledAsyncAction();\n                }\n                var prevState = current.memoizedState;\n                var nextState = workInProgress.memoizedState; // Compare the new parent cache to the previous to see detect there was\n                // a refresh.\n                if (prevState.parent !== parentCache) {\n                    // Refresh in parent. Update the parent.\n                    var derivedState = {\n                        parent: parentCache,\n                        cache: parentCache\n                    }; // Copied from getDerivedStateFromProps implementation. Once the update\n                    // queue is empty, persist the derived state onto the base state.\n                    workInProgress.memoizedState = derivedState;\n                    if (workInProgress.lanes === NoLanes) {\n                        var updateQueue = workInProgress.updateQueue;\n                        workInProgress.memoizedState = updateQueue.baseState = derivedState;\n                    }\n                    pushCacheProvider(workInProgress, parentCache); // No need to propagate a context change because the refreshed parent\n                // already did.\n                } else {\n                    // The parent didn't refresh. Now check if this cache did.\n                    var nextCache = nextState.cache;\n                    pushCacheProvider(workInProgress, nextCache);\n                    if (nextCache !== prevState.cache) {\n                        // This cache refreshed. Propagate a context change.\n                        propagateContextChange(workInProgress, CacheContext, renderLanes);\n                    }\n                }\n            }\n            var nextChildren = workInProgress.pendingProps.children;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        } // This should only be called if the name changes\n        function updateFragment(current, workInProgress, renderLanes) {\n            var nextChildren = workInProgress.pendingProps;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateMode(current, workInProgress, renderLanes) {\n            var nextChildren = workInProgress.pendingProps.children;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateProfiler(current, workInProgress, renderLanes) {\n            {\n                workInProgress.flags |= Update;\n                {\n                    // Reset effect durations for the next eventual effect phase.\n                    // These are reset during render to allow the DevTools commit hook a chance to read them,\n                    var stateNode = workInProgress.stateNode;\n                    stateNode.effectDuration = 0;\n                    stateNode.passiveEffectDuration = 0;\n                }\n            }\n            var nextProps = workInProgress.pendingProps;\n            var nextChildren = nextProps.children;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function markRef(current, workInProgress) {\n            // TODO: Check props.ref instead of fiber.ref when enableRefAsProp is on.\n            var ref = workInProgress.ref;\n            if (ref === null) {\n                if (current !== null && current.ref !== null) {\n                    // Schedule a Ref effect\n                    workInProgress.flags |= Ref | RefStatic;\n                }\n            } else {\n                if (typeof ref !== 'function' && typeof ref !== 'object') {\n                    throw new Error('Expected ref to be a function, an object returned by React.createRef(), or undefined/null.');\n                }\n                if (current === null || current.ref !== ref) {\n                    workInProgress.flags |= Ref | RefStatic;\n                }\n            }\n        }\n        function updateFunctionComponent(current, workInProgress, Component, nextProps, renderLanes) {\n            {\n                if (Component.prototype && typeof Component.prototype.render === 'function') {\n                    var componentName = getComponentNameFromType(Component) || 'Unknown';\n                    if (!didWarnAboutBadClass[componentName]) {\n                        error(\"The <%s /> component appears to have a render method, but doesn't extend React.Component. \" + 'This is likely to cause errors. Change %s to extend React.Component instead.', componentName, componentName);\n                        didWarnAboutBadClass[componentName] = true;\n                    }\n                }\n                if (workInProgress.mode & StrictLegacyMode) {\n                    ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress, null);\n                }\n                if (current === null) {\n                    // Some validations were previously done in mountIndeterminateComponent however and are now run\n                    // in updateFuntionComponent but only on mount\n                    validateFunctionComponentInDev(workInProgress, workInProgress.type);\n                    if (Component.contextTypes) {\n                        error('%s uses the legacy contextTypes API which was removed in React 19. ' + 'Use React.createContext() with React.useContext() instead.', getComponentNameFromType(Component) || 'Unknown');\n                    }\n                }\n            }\n            var context;\n            var nextChildren;\n            var hasId;\n            prepareToReadContext(workInProgress, renderLanes);\n            {\n                markComponentRenderStarted(workInProgress);\n            }\n            {\n                setIsRendering(true);\n                nextChildren = renderWithHooks(current, workInProgress, Component, nextProps, context, renderLanes);\n                hasId = checkDidRenderIdHook();\n                setIsRendering(false);\n            }\n            {\n                markComponentRenderStopped();\n            }\n            if (current !== null && !didReceiveUpdate) {\n                bailoutHooks(current, workInProgress, renderLanes);\n                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n            }\n            if (getIsHydrating() && hasId) {\n                pushMaterializedTreeId(workInProgress);\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function replayFunctionComponent(current, workInProgress, nextProps, Component, secondArg, renderLanes) {\n            // This function is used to replay a component that previously suspended,\n            // after its data resolves. It's a simplified version of\n            // updateFunctionComponent that reuses the hooks from the previous attempt.\n            prepareToReadContext(workInProgress, renderLanes);\n            {\n                markComponentRenderStarted(workInProgress);\n            }\n            var nextChildren = replaySuspendedComponentWithHooks(current, workInProgress, Component, nextProps, secondArg);\n            var hasId = checkDidRenderIdHook();\n            {\n                markComponentRenderStopped();\n            }\n            if (current !== null && !didReceiveUpdate) {\n                bailoutHooks(current, workInProgress, renderLanes);\n                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n            }\n            if (getIsHydrating() && hasId) {\n                pushMaterializedTreeId(workInProgress);\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateClassComponent(current, workInProgress, Component, nextProps, renderLanes) {\n            {\n                // This is used by DevTools to force a boundary to error.\n                switch(shouldError(workInProgress)){\n                    case false:\n                        {\n                            var _instance = workInProgress.stateNode;\n                            var ctor = workInProgress.type; // TODO This way of resetting the error boundary state is a hack.\n                            // Is there a better way to do this?\n                            var tempInstance = new ctor(workInProgress.memoizedProps, _instance.context);\n                            var state = tempInstance.state;\n                            _instance.updater.enqueueSetState(_instance, state, null);\n                            break;\n                        }\n                    case true:\n                        {\n                            workInProgress.flags |= DidCapture;\n                            workInProgress.flags |= ShouldCapture; // eslint-disable-next-line react-internal/prod-error-codes\n                            var error$1 = new Error('Simulated error coming from DevTools');\n                            var lane = pickArbitraryLane(renderLanes);\n                            workInProgress.lanes = mergeLanes(workInProgress.lanes, lane); // Schedule the error boundary to re-render using updated state\n                            var root = getWorkInProgressRoot();\n                            if (root === null) {\n                                throw new Error('Expected a work-in-progress root. This is a bug in React. Please file an issue.');\n                            }\n                            var update = createClassErrorUpdate(lane);\n                            initializeClassErrorUpdate(update, root, workInProgress, createCapturedValueAtFiber(error$1, workInProgress));\n                            enqueueCapturedUpdate(workInProgress, update);\n                            break;\n                        }\n                }\n            }\n            // During mounting we don't know the child context yet as the instance doesn't exist.\n            // We will invalidate the child context in finishClassComponent() right after rendering.\n            var hasContext;\n            if (isContextProvider()) {\n                hasContext = true;\n            } else {\n                hasContext = false;\n            }\n            prepareToReadContext(workInProgress, renderLanes);\n            var instance = workInProgress.stateNode;\n            var shouldUpdate;\n            if (instance === null) {\n                constructClassInstance(workInProgress, Component, nextProps);\n                mountClassInstance(workInProgress, Component, nextProps, renderLanes);\n                shouldUpdate = true;\n            } else if (current === null) {\n                // In a resume, we'll already have an instance we can reuse.\n                shouldUpdate = resumeMountClassInstance(workInProgress, Component, nextProps, renderLanes);\n            } else {\n                shouldUpdate = updateClassInstance(current, workInProgress, Component, nextProps, renderLanes);\n            }\n            var nextUnitOfWork = finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes);\n            {\n                var inst = workInProgress.stateNode;\n                if (shouldUpdate && inst.props !== nextProps) {\n                    if (!didWarnAboutReassigningProps) {\n                        error('It looks like %s is reassigning its own `this.props` while rendering. ' + 'This is not supported and can lead to confusing bugs.', getComponentNameFromFiber(workInProgress) || 'a component');\n                    }\n                    didWarnAboutReassigningProps = true;\n                }\n            }\n            return nextUnitOfWork;\n        }\n        function finishClassComponent(current, workInProgress, Component, shouldUpdate, hasContext, renderLanes) {\n            // Refs should update even if shouldComponentUpdate returns false\n            markRef(current, workInProgress);\n            var didCaptureError = (workInProgress.flags & DidCapture) !== NoFlags$1;\n            if (!shouldUpdate && !didCaptureError) {\n                return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n            }\n            var instance = workInProgress.stateNode; // Rerender\n            {\n                setCurrentFiber(workInProgress);\n            }\n            var nextChildren;\n            if (didCaptureError && typeof Component.getDerivedStateFromError !== 'function') {\n                // If we captured an error, but getDerivedStateFromError is not defined,\n                // unmount all the children. componentDidCatch will schedule an update to\n                // re-render a fallback. This is temporary until we migrate everyone to\n                // the new API.\n                // TODO: Warn in a future release.\n                nextChildren = null;\n                {\n                    stopProfilerTimerIfRunning();\n                }\n            } else {\n                {\n                    markComponentRenderStarted(workInProgress);\n                }\n                {\n                    setIsRendering(true);\n                    nextChildren = instance.render();\n                    if (workInProgress.mode & StrictLegacyMode) {\n                        setIsStrictModeForDevtools(true);\n                        try {\n                            instance.render();\n                        } finally{\n                            setIsStrictModeForDevtools(false);\n                        }\n                    }\n                    setIsRendering(false);\n                }\n                {\n                    markComponentRenderStopped();\n                }\n            } // React DevTools reads this flag.\n            workInProgress.flags |= PerformedWork;\n            if (current !== null && didCaptureError) {\n                // If we're recovering from an error, reconcile without reusing any of\n                // the existing children. Conceptually, the normal children and the children\n                // that are shown on error are two different sets, so we shouldn't reuse\n                // normal children even if their identities match.\n                forceUnmountCurrentAndReconcile(current, workInProgress, nextChildren, renderLanes);\n            } else {\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            } // Memoize state using the values we just used to render.\n            // TODO: Restructure so we never read values from the instance.\n            workInProgress.memoizedState = instance.state; // The context might have changed so we need to recalculate it.\n            return workInProgress.child;\n        }\n        function pushHostRootContext(workInProgress) {\n            var root = workInProgress.stateNode;\n            pushHostContainer(workInProgress, root.containerInfo);\n        }\n        function updateHostRoot(current, workInProgress, renderLanes) {\n            pushHostRootContext(workInProgress);\n            if (current === null) {\n                throw new Error('Should have a current fiber. This is a bug in React.');\n            }\n            var nextProps = workInProgress.pendingProps;\n            var prevState = workInProgress.memoizedState;\n            var prevChildren = prevState.element;\n            cloneUpdateQueue(current, workInProgress);\n            processUpdateQueue(workInProgress, nextProps, null, renderLanes);\n            var nextState = workInProgress.memoizedState;\n            {\n                var nextCache = nextState.cache;\n                pushCacheProvider(workInProgress, nextCache);\n                if (nextCache !== prevState.cache) {\n                    // The root cache refreshed.\n                    propagateContextChange(workInProgress, CacheContext, renderLanes);\n                }\n            }\n            // it needs to happen after the `pushCacheProvider` call above to avoid a\n            // context stack mismatch. A bit unfortunate.\n            suspendIfUpdateReadFromEntangledAsyncAction(); // Caution: React DevTools currently depends on this property\n            // being called \"element\".\n            var nextChildren = nextState.element;\n            if (supportsHydration && prevState.isDehydrated) {\n                // This is a hydration root whose shell has not yet hydrated. We should\n                // attempt to hydrate.\n                // Flip isDehydrated to false to indicate that when this render\n                // finishes, the root will no longer be dehydrated.\n                var overrideState = {\n                    element: nextChildren,\n                    isDehydrated: false,\n                    cache: nextState.cache\n                };\n                var updateQueue = workInProgress.updateQueue; // `baseState` can always be the last state because the root doesn't\n                // have reducer functions so it doesn't need rebasing.\n                updateQueue.baseState = overrideState;\n                workInProgress.memoizedState = overrideState;\n                if (workInProgress.flags & ForceClientRender) {\n                    // Something errored during a previous attempt to hydrate the shell, so we\n                    // forced a client render. We should have a recoverable error already scheduled.\n                    return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes);\n                } else if (nextChildren !== prevChildren) {\n                    var recoverableError = createCapturedValueAtFiber(new Error('This root received an early update, before anything was able ' + 'hydrate. Switched the entire root to client rendering.'), workInProgress);\n                    queueHydrationError(recoverableError);\n                    return mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes);\n                } else {\n                    // The outermost shell has not hydrated yet. Start hydrating.\n                    enterHydrationState(workInProgress);\n                    var child = mountChildFibers(workInProgress, null, nextChildren, renderLanes);\n                    workInProgress.child = child;\n                    var node = child;\n                    while(node){\n                        // Mark each child as hydrating. This is a fast path to know whether this\n                        // tree is part of a hydrating tree. This is used to determine if a child\n                        // node has fully mounted yet, and for scheduling event replaying.\n                        // Conceptually this is similar to Placement in that a new subtree is\n                        // inserted into the React tree here. It just happens to not need DOM\n                        // mutations because it already exists.\n                        node.flags = node.flags & ~Placement | Hydrating;\n                        node = node.sibling;\n                    }\n                }\n            } else {\n                // Root is not dehydrated. Either this is a client-only root, or it\n                // already hydrated.\n                resetHydrationState();\n                if (nextChildren === prevChildren) {\n                    return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                }\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            }\n            return workInProgress.child;\n        }\n        function mountHostRootWithoutHydrating(current, workInProgress, nextChildren, renderLanes) {\n            // Revert to client rendering.\n            resetHydrationState();\n            workInProgress.flags |= ForceClientRender;\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateHostComponent$1(current, workInProgress, renderLanes) {\n            if (current === null) {\n                tryToClaimNextHydratableInstance(workInProgress);\n            }\n            pushHostContext(workInProgress);\n            var type = workInProgress.type;\n            var nextProps = workInProgress.pendingProps;\n            var prevProps = current !== null ? current.memoizedProps : null;\n            var nextChildren = nextProps.children;\n            var isDirectTextChild = shouldSetTextContent(type, nextProps);\n            if (isDirectTextChild) {\n                // We special case a direct text child of a host node. This is a common\n                // case. We won't handle it as a reified child. We will instead handle\n                // this in the host environment that also has access to this prop. That\n                // avoids allocating another HostText fiber and traversing it.\n                nextChildren = null;\n            } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {\n                // If we're switching from a direct text child to a normal child, or to\n                // empty, we need to schedule the text content to be reset.\n                workInProgress.flags |= ContentReset;\n            }\n            {\n                var memoizedState = workInProgress.memoizedState;\n                if (memoizedState !== null) {\n                    // This fiber has been upgraded to a stateful component. The only way\n                    // happens currently is for form actions. We use hooks to track the\n                    // pending and error state of the form.\n                    //\n                    // Once a fiber is upgraded to be stateful, it remains stateful for the\n                    // rest of its lifetime.\n                    var newState = renderTransitionAwareHostComponentWithHooks(current, workInProgress, renderLanes); // If the transition state changed, propagate the change to all the\n                    // descendents. We use Context as an implementation detail for this.\n                    //\n                    // This is intentionally set here instead of pushHostContext because\n                    // pushHostContext gets called before we process the state hook, to avoid\n                    // a state mismatch in the event that something suspends.\n                    //\n                    // NOTE: This assumes that there cannot be nested transition providers,\n                    // because the only renderer that implements this feature is React DOM,\n                    // and forms cannot be nested. If we did support nested providers, then\n                    // we would need to push a context value even for host fibers that\n                    // haven't been upgraded yet.\n                    if (isPrimaryRenderer) {\n                        HostTransitionContext._currentValue = newState;\n                    } else {\n                        HostTransitionContext._currentValue2 = newState;\n                    }\n                    {\n                        if (didReceiveUpdate) {\n                            if (current !== null) {\n                                var oldStateHook = current.memoizedState;\n                                var oldState = oldStateHook.memoizedState; // This uses regular equality instead of Object.is because we assume\n                                // that host transition state doesn't include NaN as a valid type.\n                                if (oldState !== newState) {\n                                    propagateContextChange(workInProgress, HostTransitionContext, renderLanes);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            markRef(current, workInProgress);\n            reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateHostHoistable(current, workInProgress, renderLanes) {\n            markRef(current, workInProgress);\n            var currentProps = current === null ? null : current.memoizedProps;\n            var resource = workInProgress.memoizedState = getResource(workInProgress.type, currentProps, workInProgress.pendingProps);\n            if (current === null) {\n                if (!getIsHydrating() && resource === null) {\n                    // This is not a Resource Hoistable and we aren't hydrating so we construct the instance.\n                    workInProgress.stateNode = createHoistableInstance(workInProgress.type, workInProgress.pendingProps, getRootHostContainer(), workInProgress);\n                }\n            } // Resources never have reconciler managed children. It is possible for\n            // the host implementation of getResource to consider children in the\n            // resource construction but they will otherwise be discarded. In practice\n            // this precludes all but the simplest children and Host specific warnings\n            // should be implemented to warn when children are passsed when otherwise not\n            // expected\n            return null;\n        }\n        function updateHostSingleton(current, workInProgress, renderLanes) {\n            pushHostContext(workInProgress);\n            if (current === null) {\n                claimHydratableSingleton(workInProgress);\n            }\n            var nextChildren = workInProgress.pendingProps.children;\n            if (current === null && !getIsHydrating()) {\n                // Similar to Portals we append Singleton children in the commit phase. So we\n                // Track insertions even on mount.\n                // TODO: Consider unifying this with how the root works.\n                workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n            } else {\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            }\n            markRef(current, workInProgress);\n            return workInProgress.child;\n        }\n        function updateHostText$1(current, workInProgress) {\n            if (current === null) {\n                tryToClaimNextHydratableTextInstance(workInProgress);\n            } // Nothing to do here. This is terminal. We'll do the completion step\n            // immediately after.\n            return null;\n        }\n        function mountLazyComponent(_current, workInProgress, elementType, renderLanes) {\n            var props = workInProgress.pendingProps;\n            var lazyComponent = elementType;\n            var payload = lazyComponent._payload;\n            var init = lazyComponent._init;\n            var Component = init(payload); // Store the unwrapped component in the type.\n            workInProgress.type = Component;\n            if (typeof Component === 'function') {\n                if (isFunctionClassComponent(Component)) {\n                    var resolvedProps = resolveClassComponentProps(Component, props);\n                    workInProgress.tag = ClassComponent;\n                    {\n                        workInProgress.type = Component = resolveClassForHotReloading(Component);\n                    }\n                    return updateClassComponent(null, workInProgress, Component, resolvedProps, renderLanes);\n                } else {\n                    var _resolvedProps = props;\n                    workInProgress.tag = FunctionComponent;\n                    {\n                        validateFunctionComponentInDev(workInProgress, Component);\n                        workInProgress.type = Component = resolveFunctionForHotReloading(Component);\n                    }\n                    return updateFunctionComponent(null, workInProgress, Component, _resolvedProps, renderLanes);\n                }\n            } else if (Component !== undefined && Component !== null) {\n                var $$typeof = Component.$$typeof;\n                if ($$typeof === REACT_FORWARD_REF_TYPE) {\n                    var _resolvedProps2 = props;\n                    workInProgress.tag = ForwardRef;\n                    {\n                        workInProgress.type = Component = resolveForwardRefForHotReloading(Component);\n                    }\n                    return updateForwardRef(null, workInProgress, Component, _resolvedProps2, renderLanes);\n                } else if ($$typeof === REACT_MEMO_TYPE) {\n                    var _resolvedProps3 = props;\n                    workInProgress.tag = MemoComponent;\n                    return updateMemoComponent(null, workInProgress, Component, _resolvedProps3, renderLanes);\n                }\n            }\n            var hint = '';\n            {\n                if (Component !== null && typeof Component === 'object' && Component.$$typeof === REACT_LAZY_TYPE) {\n                    hint = ' Did you wrap a component in React.lazy() more than once?';\n                }\n            }\n            // because the fact that it's a separate type of work is an\n            // implementation detail.\n            throw new Error(\"Element type is invalid. Received a promise that resolves to: \" + Component + \". \" + (\"Lazy element type must resolve to a class or function.\" + hint));\n        }\n        function validateFunctionComponentInDev(workInProgress, Component) {\n            {\n                if (Component) {\n                    if (Component.childContextTypes) {\n                        error('childContextTypes cannot be defined on a function component.\\n' + '  %s.childContextTypes = ...', Component.displayName || Component.name || 'Component');\n                    }\n                }\n                if (typeof Component.getDerivedStateFromProps === 'function') {\n                    var _componentName2 = getComponentNameFromType(Component) || 'Unknown';\n                    if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2]) {\n                        error('%s: Function components do not support getDerivedStateFromProps.', _componentName2);\n                        didWarnAboutGetDerivedStateOnFunctionComponent[_componentName2] = true;\n                    }\n                }\n                if (typeof Component.contextType === 'object' && Component.contextType !== null) {\n                    var _componentName3 = getComponentNameFromType(Component) || 'Unknown';\n                    if (!didWarnAboutContextTypeOnFunctionComponent[_componentName3]) {\n                        error('%s: Function components do not support contextType.', _componentName3);\n                        didWarnAboutContextTypeOnFunctionComponent[_componentName3] = true;\n                    }\n                }\n            }\n        }\n        var SUSPENDED_MARKER = {\n            dehydrated: null,\n            treeContext: null,\n            retryLane: NoLane\n        };\n        function mountSuspenseOffscreenState(renderLanes) {\n            return {\n                baseLanes: renderLanes,\n                cachePool: getSuspendedCache()\n            };\n        }\n        function updateSuspenseOffscreenState(prevOffscreenState, renderLanes) {\n            var cachePool = null;\n            {\n                var prevCachePool = prevOffscreenState.cachePool;\n                if (prevCachePool !== null) {\n                    var parentCache = isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2;\n                    if (prevCachePool.parent !== parentCache) {\n                        // Detected a refresh in the parent. This overrides any previously\n                        // suspended cache.\n                        cachePool = {\n                            parent: parentCache,\n                            pool: parentCache\n                        };\n                    } else {\n                        // We can reuse the cache from last time. The only thing that would have\n                        // overridden it is a parent refresh, which we checked for above.\n                        cachePool = prevCachePool;\n                    }\n                } else {\n                    // If there's no previous cache pool, grab the current one.\n                    cachePool = getSuspendedCache();\n                }\n            }\n            return {\n                baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes),\n                cachePool: cachePool\n            };\n        } // TODO: Probably should inline this back\n        function shouldRemainOnFallback(current, workInProgress, renderLanes) {\n            // If we're already showing a fallback, there are cases where we need to\n            // remain on that fallback regardless of whether the content has resolved.\n            // For example, SuspenseList coordinates when nested content appears.\n            // TODO: For compatibility with offscreen prerendering, this should also check\n            // whether the current fiber (if it exists) was visible in the previous tree.\n            if (current !== null) {\n                var suspenseState = current.memoizedState;\n                if (suspenseState === null) {\n                    // Currently showing content. Don't hide it, even if ForceSuspenseFallback\n                    // is true. More precise name might be \"ForceRemainSuspenseFallback\".\n                    // Note: This is a factoring smell. Can't remain on a fallback if there's\n                    // no fallback to remain on.\n                    return false;\n                }\n            } // Not currently showing content. Consult the Suspense context.\n            var suspenseContext = suspenseStackCursor.current;\n            return hasSuspenseListContext(suspenseContext, ForceSuspenseFallback);\n        }\n        function getRemainingWorkInPrimaryTree(current, primaryTreeDidDefer, renderLanes) {\n            var remainingLanes = current !== null ? removeLanes(current.childLanes, renderLanes) : NoLanes;\n            if (primaryTreeDidDefer) {\n                // A useDeferredValue hook spawned a deferred task inside the primary tree.\n                // Ensure that we retry this component at the deferred priority.\n                // TODO: We could make this a per-subtree value instead of a global one.\n                // Would need to track it on the context stack somehow, similar to what\n                // we'd have to do for resumable contexts.\n                remainingLanes = mergeLanes(remainingLanes, peekDeferredLane());\n            }\n            return remainingLanes;\n        }\n        function updateSuspenseComponent(current, workInProgress, renderLanes) {\n            var nextProps = workInProgress.pendingProps; // This is used by DevTools to force a boundary to suspend.\n            {\n                if (shouldSuspend(workInProgress)) {\n                    workInProgress.flags |= DidCapture;\n                }\n            }\n            var showFallback = false;\n            var didSuspend = (workInProgress.flags & DidCapture) !== NoFlags$1;\n            if (didSuspend || shouldRemainOnFallback(current)) {\n                // Something in this boundary's subtree already suspended. Switch to\n                // rendering the fallback children.\n                showFallback = true;\n                workInProgress.flags &= ~DidCapture;\n            } // Check if the primary children spawned a deferred task (useDeferredValue)\n            // during the first pass.\n            var didPrimaryChildrenDefer = (workInProgress.flags & DidDefer) !== NoFlags$1;\n            workInProgress.flags &= ~DidDefer; // OK, the next part is confusing. We're about to reconcile the Suspense\n            // boundary's children. This involves some custom reconciliation logic. Two\n            // main reasons this is so complicated.\n            //\n            // First, Legacy Mode has different semantics for backwards compatibility. The\n            // primary tree will commit in an inconsistent state, so when we do the\n            // second pass to render the fallback, we do some exceedingly, uh, clever\n            // hacks to make that not totally break. Like transferring effects and\n            // deletions from hidden tree. In Concurrent Mode, it's much simpler,\n            // because we bailout on the primary tree completely and leave it in its old\n            // state, no effects. Same as what we do for Offscreen (except that\n            // Offscreen doesn't have the first render pass).\n            //\n            // Second is hydration. During hydration, the Suspense fiber has a slightly\n            // different layout, where the child points to a dehydrated fragment, which\n            // contains the DOM rendered by the server.\n            //\n            // Third, even if you set all that aside, Suspense is like error boundaries in\n            // that we first we try to render one tree, and if that fails, we render again\n            // and switch to a different tree. Like a try/catch block. So we have to track\n            // which branch we're currently rendering. Ideally we would model this using\n            // a stack.\n            if (current === null) {\n                // Initial mount\n                // Special path for hydration\n                // If we're currently hydrating, try to hydrate this boundary.\n                if (getIsHydrating()) {\n                    // We must push the suspense handler context *before* attempting to\n                    // hydrate, to avoid a mismatch in case it errors.\n                    if (showFallback) {\n                        pushPrimaryTreeSuspenseHandler(workInProgress);\n                    } else {\n                        pushFallbackTreeSuspenseHandler(workInProgress);\n                    }\n                    tryToClaimNextHydratableSuspenseInstance(workInProgress); // This could've been a dehydrated suspense component.\n                    var suspenseState = workInProgress.memoizedState;\n                    if (suspenseState !== null) {\n                        var dehydrated = suspenseState.dehydrated;\n                        if (dehydrated !== null) {\n                            return mountDehydratedSuspenseComponent(workInProgress, dehydrated);\n                        }\n                    } // If hydration didn't succeed, fall through to the normal Suspense path.\n                    // To avoid a stack mismatch we need to pop the Suspense handler that we\n                    // pushed above. This will become less awkward when move the hydration\n                    // logic to its own fiber.\n                    popSuspenseHandler(workInProgress);\n                }\n                var nextPrimaryChildren = nextProps.children;\n                var nextFallbackChildren = nextProps.fallback;\n                if (showFallback) {\n                    pushFallbackTreeSuspenseHandler(workInProgress);\n                    var fallbackFragment = mountSuspenseFallbackChildren(workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n                    var primaryChildFragment = workInProgress.child;\n                    primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes);\n                    primaryChildFragment.childLanes = getRemainingWorkInPrimaryTree(current, didPrimaryChildrenDefer, renderLanes);\n                    workInProgress.memoizedState = SUSPENDED_MARKER;\n                    return fallbackFragment;\n                } else {\n                    pushPrimaryTreeSuspenseHandler(workInProgress);\n                    return mountSuspensePrimaryChildren(workInProgress, nextPrimaryChildren);\n                }\n            } else {\n                // This is an update.\n                // Special path for hydration\n                var prevState = current.memoizedState;\n                if (prevState !== null) {\n                    var _dehydrated = prevState.dehydrated;\n                    if (_dehydrated !== null) {\n                        return updateDehydratedSuspenseComponent(current, workInProgress, didSuspend, didPrimaryChildrenDefer, nextProps, _dehydrated, prevState, renderLanes);\n                    }\n                }\n                if (showFallback) {\n                    pushFallbackTreeSuspenseHandler(workInProgress);\n                    var _nextFallbackChildren = nextProps.fallback;\n                    var _nextPrimaryChildren = nextProps.children;\n                    var fallbackChildFragment = updateSuspenseFallbackChildren(current, workInProgress, _nextPrimaryChildren, _nextFallbackChildren, renderLanes);\n                    var _primaryChildFragment2 = workInProgress.child;\n                    var prevOffscreenState = current.child.memoizedState;\n                    _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes);\n                    _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current, didPrimaryChildrenDefer, renderLanes);\n                    workInProgress.memoizedState = SUSPENDED_MARKER;\n                    return fallbackChildFragment;\n                } else {\n                    pushPrimaryTreeSuspenseHandler(workInProgress);\n                    var _nextPrimaryChildren2 = nextProps.children;\n                    var _primaryChildFragment3 = updateSuspensePrimaryChildren(current, workInProgress, _nextPrimaryChildren2);\n                    workInProgress.memoizedState = null;\n                    return _primaryChildFragment3;\n                }\n            }\n        }\n        function mountSuspensePrimaryChildren(workInProgress, primaryChildren, renderLanes) {\n            var mode = workInProgress.mode;\n            var primaryChildProps = {\n                mode: 'visible',\n                children: primaryChildren\n            };\n            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);\n            primaryChildFragment.return = workInProgress;\n            workInProgress.child = primaryChildFragment;\n            return primaryChildFragment;\n        }\n        function mountSuspenseFallbackChildren(workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n            var mode = workInProgress.mode;\n            var primaryChildProps = {\n                mode: 'hidden',\n                children: primaryChildren\n            };\n            var primaryChildFragment;\n            var fallbackChildFragment;\n            {\n                primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);\n                fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null);\n            }\n            primaryChildFragment.return = workInProgress;\n            fallbackChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = fallbackChildFragment;\n            workInProgress.child = primaryChildFragment;\n            return fallbackChildFragment;\n        }\n        function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes) {\n            // The props argument to `createFiberFromOffscreen` is `any` typed, so we use\n            // this wrapper function to constrain it.\n            return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);\n        }\n        function updateWorkInProgressOffscreenFiber(current, offscreenProps) {\n            // The props argument to `createWorkInProgress` is `any` typed, so we use this\n            // wrapper function to constrain it.\n            return createWorkInProgress(current, offscreenProps);\n        }\n        function updateSuspensePrimaryChildren(current, workInProgress, primaryChildren, renderLanes) {\n            var currentPrimaryChildFragment = current.child;\n            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n            var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {\n                mode: 'visible',\n                children: primaryChildren\n            });\n            primaryChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = null;\n            if (currentFallbackChildFragment !== null) {\n                // Delete the fallback child fragment\n                var deletions = workInProgress.deletions;\n                if (deletions === null) {\n                    workInProgress.deletions = [\n                        currentFallbackChildFragment\n                    ];\n                    workInProgress.flags |= ChildDeletion;\n                } else {\n                    deletions.push(currentFallbackChildFragment);\n                }\n            }\n            workInProgress.child = primaryChildFragment;\n            return primaryChildFragment;\n        }\n        function updateSuspenseFallbackChildren(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n            var mode = workInProgress.mode;\n            var currentPrimaryChildFragment = current.child;\n            var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;\n            var primaryChildProps = {\n                mode: 'hidden',\n                children: primaryChildren\n            };\n            var primaryChildFragment;\n            {\n                primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps); // Since we're reusing a current tree, we need to reuse the flags, too.\n                // (We don't do this in legacy mode, because in legacy mode we don't re-use\n                // the current tree; see previous branch.)\n                primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;\n            }\n            var fallbackChildFragment;\n            if (currentFallbackChildFragment !== null) {\n                fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);\n            } else {\n                fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes, null); // Needs a placement effect because the parent (the Suspense boundary) already\n                // mounted but this is a new fiber.\n                fallbackChildFragment.flags |= Placement;\n            }\n            fallbackChildFragment.return = workInProgress;\n            primaryChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = fallbackChildFragment;\n            workInProgress.child = primaryChildFragment;\n            return fallbackChildFragment;\n        }\n        function retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes) {\n            // Falling back to client rendering. Because this has performance\n            // implications, it's considered a recoverable error, even though the user\n            // likely won't observe anything wrong with the UI.\n            // This will add the old fiber to the deletion list\n            reconcileChildFibers(workInProgress, current.child, null, renderLanes); // We're now not suspended nor dehydrated.\n            var nextProps = workInProgress.pendingProps;\n            var primaryChildren = nextProps.children;\n            var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren); // Needs a placement effect because the parent (the Suspense boundary) already\n            // mounted but this is a new fiber.\n            primaryChildFragment.flags |= Placement;\n            workInProgress.memoizedState = null;\n            return primaryChildFragment;\n        }\n        function mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, primaryChildren, fallbackChildren, renderLanes) {\n            var fiberMode = workInProgress.mode;\n            var primaryChildProps = {\n                mode: 'visible',\n                children: primaryChildren\n            };\n            var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);\n            var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes, null); // Needs a placement effect because the parent (the Suspense\n            // boundary) already mounted but this is a new fiber.\n            fallbackChildFragment.flags |= Placement;\n            primaryChildFragment.return = workInProgress;\n            fallbackChildFragment.return = workInProgress;\n            primaryChildFragment.sibling = fallbackChildFragment;\n            workInProgress.child = primaryChildFragment;\n            {\n                // We will have dropped the effect list which contains the\n                // deletion. We need to reconcile to delete the current child.\n                reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n            }\n            return fallbackChildFragment;\n        }\n        function mountDehydratedSuspenseComponent(workInProgress, suspenseInstance, renderLanes) {\n            // During the first pass, we'll bail out and not drill into the children.\n            // Instead, we'll leave the content in place and try to hydrate it later.\n            if (isSuspenseInstanceFallback(suspenseInstance)) {\n                // This is a client-only boundary. Since we won't get any content from the server\n                // for this, we need to schedule that at a higher priority based on when it would\n                // have timed out. In theory we could render it in this pass but it would have the\n                // wrong priority associated with it and will prevent hydration of parent path.\n                // Instead, we'll leave work left on it to render it in a separate commit.\n                // TODO This time should be the time at which the server rendered response that is\n                // a parent to this boundary was displayed. However, since we currently don't have\n                // a protocol to transfer that time, we'll just estimate it by using the current\n                // time. This will mean that Suspense timeouts are slightly shifted to later than\n                // they should be.\n                // Schedule a normal pri update to render this content.\n                workInProgress.lanes = laneToLanes(DefaultHydrationLane);\n            } else {\n                // We'll continue hydrating the rest at offscreen priority since we'll already\n                // be showing the right content coming from the server, it is no rush.\n                workInProgress.lanes = laneToLanes(OffscreenLane);\n            }\n            return null;\n        }\n        function updateDehydratedSuspenseComponent(current, workInProgress, didSuspend, didPrimaryChildrenDefer, nextProps, suspenseInstance, suspenseState, renderLanes) {\n            if (!didSuspend) {\n                // This is the first render pass. Attempt to hydrate.\n                pushPrimaryTreeSuspenseHandler(workInProgress); // We should never be hydrating at this point because it is the first pass,\n                // but after we've already committed once.\n                warnIfHydrating();\n                if (isSuspenseInstanceFallback(suspenseInstance)) {\n                    // This boundary is in a permanent fallback state. In this case, we'll never\n                    // get an update and we'll never be able to hydrate the final content. Let's just try the\n                    // client side render instead.\n                    var digest;\n                    var message;\n                    var stack = null;\n                    var componentStack = null;\n                    {\n                        var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);\n                        digest = _getSuspenseInstanceF.digest;\n                        message = _getSuspenseInstanceF.message;\n                        stack = _getSuspenseInstanceF.stack;\n                        componentStack = _getSuspenseInstanceF.componentStack;\n                    }\n                    {\n                        var error;\n                        if (message) {\n                            // eslint-disable-next-line react-internal/prod-error-codes\n                            error = new Error(message);\n                        } else {\n                            error = new Error('The server could not finish this Suspense boundary, likely ' + 'due to an error during server rendering. ' + 'Switched to client rendering.');\n                        } // Replace the stack with the server stack\n                        error.stack = stack || '';\n                        error.digest = digest;\n                        var capturedValue = createCapturedValueFromError(error, componentStack === undefined ? null : componentStack);\n                        queueHydrationError(capturedValue);\n                    }\n                    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n                }\n                // any context has changed, we need to treat is as if the input might have changed.\n                var hasContextChanged = includesSomeLane(renderLanes, current.childLanes);\n                if (didReceiveUpdate || hasContextChanged) {\n                    // This boundary has changed since the first render. This means that we are now unable to\n                    // hydrate it. We might still be able to hydrate it using a higher priority lane.\n                    var root = getWorkInProgressRoot();\n                    if (root !== null) {\n                        var attemptHydrationAtLane = getBumpedLaneForHydration(root, renderLanes);\n                        if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {\n                            // Intentionally mutating since this render will get interrupted. This\n                            // is one of the very rare times where we mutate the current tree\n                            // during the render phase.\n                            suspenseState.retryLane = attemptHydrationAtLane;\n                            enqueueConcurrentRenderForLane(current, attemptHydrationAtLane);\n                            scheduleUpdateOnFiber(root, current, attemptHydrationAtLane); // Throw a special object that signals to the work loop that it should\n                            // interrupt the current render.\n                            //\n                            // Because we're inside a React-only execution stack, we don't\n                            // strictly need to throw here — we could instead modify some internal\n                            // work loop state. But using an exception means we don't need to\n                            // check for this case on every iteration of the work loop. So doing\n                            // it this way moves the check out of the fast path.\n                            throw SelectiveHydrationException;\n                        }\n                    } // If we did not selectively hydrate, we'll continue rendering without\n                    // hydrating. Mark this tree as suspended to prevent it from committing\n                    // outside a transition.\n                    //\n                    // This path should only happen if the hydration lane already suspended.\n                    // Currently, it also happens during sync updates because there is no\n                    // hydration lane for sync updates.\n                    // TODO: We should ideally have a sync hydration lane that we can apply to do\n                    // a pass where we hydrate this subtree in place using the previous Context and then\n                    // reapply the update afterwards.\n                    if (isSuspenseInstancePending(suspenseInstance)) ;\n                    else {\n                        renderDidSuspendDelayIfPossible();\n                    }\n                    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n                } else if (isSuspenseInstancePending(suspenseInstance)) {\n                    // This component is still pending more data from the server, so we can't hydrate its\n                    // content. We treat it as if this component suspended itself. It might seem as if\n                    // we could just try to render it client-side instead. However, this will perform a\n                    // lot of unnecessary work and is unlikely to complete since it often will suspend\n                    // on missing data anyway. Additionally, the server might be able to render more\n                    // than we can on the client yet. In that case we'd end up with more fallback states\n                    // on the client than if we just leave it alone. If the server times out or errors\n                    // these should update this boundary to the permanent Fallback state instead.\n                    // Mark it as having captured (i.e. suspended).\n                    workInProgress.flags |= DidCapture; // Leave the child in place. I.e. the dehydrated fragment.\n                    workInProgress.child = current.child; // Register a callback to retry this boundary once the server has sent the result.\n                    var retry = retryDehydratedSuspenseBoundary.bind(null, current);\n                    registerSuspenseInstanceRetry(suspenseInstance, retry);\n                    return null;\n                } else {\n                    // This is the first attempt.\n                    reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress, suspenseInstance, suspenseState.treeContext);\n                    var primaryChildren = nextProps.children;\n                    var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress, primaryChildren); // Mark the children as hydrating. This is a fast path to know whether this\n                    // tree is part of a hydrating tree. This is used to determine if a child\n                    // node has fully mounted yet, and for scheduling event replaying.\n                    // Conceptually this is similar to Placement in that a new subtree is\n                    // inserted into the React tree here. It just happens to not need DOM\n                    // mutations because it already exists.\n                    primaryChildFragment.flags |= Hydrating;\n                    return primaryChildFragment;\n                }\n            } else {\n                // This is the second render pass. We already attempted to hydrated, but\n                // something either suspended or errored.\n                if (workInProgress.flags & ForceClientRender) {\n                    // Something errored during hydration. Try again without hydrating.\n                    // The error should've already been logged in throwException.\n                    pushPrimaryTreeSuspenseHandler(workInProgress);\n                    workInProgress.flags &= ~ForceClientRender;\n                    return retrySuspenseComponentWithoutHydrating(current, workInProgress, renderLanes);\n                } else if (workInProgress.memoizedState !== null) {\n                    // Something suspended and we should still be in dehydrated mode.\n                    // Leave the existing child in place.\n                    // Push to avoid a mismatch\n                    pushFallbackTreeSuspenseHandler(workInProgress);\n                    workInProgress.child = current.child; // The dehydrated completion pass expects this flag to be there\n                    // but the normal suspense pass doesn't.\n                    workInProgress.flags |= DidCapture;\n                    return null;\n                } else {\n                    // Suspended but we should no longer be in dehydrated mode.\n                    // Therefore we now have to render the fallback.\n                    pushFallbackTreeSuspenseHandler(workInProgress);\n                    var nextPrimaryChildren = nextProps.children;\n                    var nextFallbackChildren = nextProps.fallback;\n                    var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current, workInProgress, nextPrimaryChildren, nextFallbackChildren, renderLanes);\n                    var _primaryChildFragment4 = workInProgress.child;\n                    _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes);\n                    _primaryChildFragment4.childLanes = getRemainingWorkInPrimaryTree(current, didPrimaryChildrenDefer, renderLanes);\n                    workInProgress.memoizedState = SUSPENDED_MARKER;\n                    return fallbackChildFragment;\n                }\n            }\n        }\n        function scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {\n            fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\n            var alternate = fiber.alternate;\n            if (alternate !== null) {\n                alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\n            }\n            scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);\n        }\n        function propagateSuspenseContextChange(workInProgress, firstChild, renderLanes) {\n            // Mark any Suspense boundaries with fallbacks as having work to do.\n            // If they were previously forced into fallbacks, they may now be able\n            // to unblock.\n            var node = firstChild;\n            while(node !== null){\n                if (node.tag === SuspenseComponent) {\n                    var state = node.memoizedState;\n                    if (state !== null) {\n                        scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\n                    }\n                } else if (node.tag === SuspenseListComponent) {\n                    // If the tail is hidden there might not be an Suspense boundaries\n                    // to schedule work on. In this case we have to schedule it on the\n                    // list itself.\n                    // We don't have to traverse to the children of the list since\n                    // the list will propagate the change when it rerenders.\n                    scheduleSuspenseWorkOnFiber(node, renderLanes, workInProgress);\n                } else if (node.child !== null) {\n                    node.child.return = node;\n                    node = node.child;\n                    continue;\n                }\n                if (node === workInProgress) {\n                    return;\n                } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                while(node.sibling === null){\n                    // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    if (node.return === null || node.return === workInProgress) {\n                        return;\n                    }\n                    node = node.return;\n                } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                node.sibling.return = node.return;\n                node = node.sibling;\n            }\n        }\n        function findLastContentRow(firstChild) {\n            // This is going to find the last row among these children that is already\n            // showing content on the screen, as opposed to being in fallback state or\n            // new. If a row has multiple Suspense boundaries, any of them being in the\n            // fallback state, counts as the whole row being in a fallback state.\n            // Note that the \"rows\" will be workInProgress, but any nested children\n            // will still be current since we haven't rendered them yet. The mounted\n            // order may not be the same as the new order. We use the new order.\n            var row = firstChild;\n            var lastContentRow = null;\n            while(row !== null){\n                var currentRow = row.alternate; // New rows can't be content rows.\n                if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n                    lastContentRow = row;\n                }\n                row = row.sibling;\n            }\n            return lastContentRow;\n        }\n        function validateRevealOrder(revealOrder) {\n            {\n                if (revealOrder !== undefined && revealOrder !== 'forwards' && revealOrder !== 'backwards' && revealOrder !== 'together' && !didWarnAboutRevealOrder[revealOrder]) {\n                    didWarnAboutRevealOrder[revealOrder] = true;\n                    if (typeof revealOrder === 'string') {\n                        switch(revealOrder.toLowerCase()){\n                            case 'together':\n                            case 'forwards':\n                            case 'backwards':\n                                {\n                                    error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'Use lowercase \"%s\" instead.', revealOrder, revealOrder.toLowerCase());\n                                    break;\n                                }\n                            case 'forward':\n                            case 'backward':\n                                {\n                                    error('\"%s\" is not a valid value for revealOrder on <SuspenseList />. ' + 'React uses the -s suffix in the spelling. Use \"%ss\" instead.', revealOrder, revealOrder.toLowerCase());\n                                    break;\n                                }\n                            default:\n                                error('\"%s\" is not a supported revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n                                break;\n                        }\n                    } else {\n                        error('%s is not a supported value for revealOrder on <SuspenseList />. ' + 'Did you mean \"together\", \"forwards\" or \"backwards\"?', revealOrder);\n                    }\n                }\n            }\n        }\n        function validateTailOptions(tailMode, revealOrder) {\n            {\n                if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {\n                    if (tailMode !== 'collapsed' && tailMode !== 'hidden') {\n                        didWarnAboutTailOptions[tailMode] = true;\n                        error('\"%s\" is not a supported value for tail on <SuspenseList />. ' + 'Did you mean \"collapsed\" or \"hidden\"?', tailMode);\n                    } else if (revealOrder !== 'forwards' && revealOrder !== 'backwards') {\n                        didWarnAboutTailOptions[tailMode] = true;\n                        error('<SuspenseList tail=\"%s\" /> is only valid if revealOrder is ' + '\"forwards\" or \"backwards\". ' + 'Did you mean to specify revealOrder=\"forwards\"?', tailMode);\n                    }\n                }\n            }\n        }\n        function validateSuspenseListNestedChild(childSlot, index) {\n            {\n                var isAnArray = isArray(childSlot);\n                var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === 'function';\n                if (isAnArray || isIterable) {\n                    var type = isAnArray ? 'array' : 'iterable';\n                    error('A nested %s was passed to row #%s in <SuspenseList />. Wrap it in ' + 'an additional SuspenseList to configure its revealOrder: ' + '<SuspenseList revealOrder=...> ... ' + '<SuspenseList revealOrder=...>{%s}</SuspenseList> ... ' + '</SuspenseList>', type, index, type);\n                    return false;\n                }\n            }\n            return true;\n        }\n        function validateSuspenseListChildren(children, revealOrder) {\n            {\n                if ((revealOrder === 'forwards' || revealOrder === 'backwards') && children !== undefined && children !== null && children !== false) {\n                    if (isArray(children)) {\n                        for(var i = 0; i < children.length; i++){\n                            if (!validateSuspenseListNestedChild(children[i], i)) {\n                                return;\n                            }\n                        }\n                    } else {\n                        var iteratorFn = getIteratorFn(children);\n                        if (typeof iteratorFn === 'function') {\n                            var childrenIterator = iteratorFn.call(children);\n                            if (childrenIterator) {\n                                var step = childrenIterator.next();\n                                var _i = 0;\n                                for(; !step.done; step = childrenIterator.next()){\n                                    if (!validateSuspenseListNestedChild(step.value, _i)) {\n                                        return;\n                                    }\n                                    _i++;\n                                }\n                            }\n                        } else {\n                            error('A single row was passed to a <SuspenseList revealOrder=\"%s\" />. ' + 'This is not useful since it needs multiple rows. ' + 'Did you mean to pass multiple children or an array?', revealOrder);\n                        }\n                    }\n                }\n            }\n        }\n        function initSuspenseListRenderState(workInProgress, isBackwards, tail, lastContentRow, tailMode) {\n            var renderState = workInProgress.memoizedState;\n            if (renderState === null) {\n                workInProgress.memoizedState = {\n                    isBackwards: isBackwards,\n                    rendering: null,\n                    renderingStartTime: 0,\n                    last: lastContentRow,\n                    tail: tail,\n                    tailMode: tailMode\n                };\n            } else {\n                // We can reuse the existing object from previous renders.\n                renderState.isBackwards = isBackwards;\n                renderState.rendering = null;\n                renderState.renderingStartTime = 0;\n                renderState.last = lastContentRow;\n                renderState.tail = tail;\n                renderState.tailMode = tailMode;\n            }\n        } // This can end up rendering this component multiple passes.\n        // The first pass splits the children fibers into two sets. A head and tail.\n        // We first render the head. If anything is in fallback state, we do another\n        // pass through beginWork to rerender all children (including the tail) with\n        // the force suspend context. If the first render didn't have anything in\n        // in fallback state. Then we render each row in the tail one-by-one.\n        // That happens in the completeWork phase without going back to beginWork.\n        function updateSuspenseListComponent(current, workInProgress, renderLanes) {\n            var nextProps = workInProgress.pendingProps;\n            var revealOrder = nextProps.revealOrder;\n            var tailMode = nextProps.tail;\n            var newChildren = nextProps.children;\n            validateRevealOrder(revealOrder);\n            validateTailOptions(tailMode, revealOrder);\n            validateSuspenseListChildren(newChildren, revealOrder);\n            reconcileChildren(current, workInProgress, newChildren, renderLanes);\n            var suspenseContext = suspenseStackCursor.current;\n            var shouldForceFallback = hasSuspenseListContext(suspenseContext, ForceSuspenseFallback);\n            if (shouldForceFallback) {\n                suspenseContext = setShallowSuspenseListContext(suspenseContext, ForceSuspenseFallback);\n                workInProgress.flags |= DidCapture;\n            } else {\n                var didSuspendBefore = current !== null && (current.flags & DidCapture) !== NoFlags$1;\n                if (didSuspendBefore) {\n                    // If we previously forced a fallback, we need to schedule work\n                    // on any nested boundaries to let them know to try to render\n                    // again. This is the same as context updating.\n                    propagateSuspenseContextChange(workInProgress, workInProgress.child, renderLanes);\n                }\n                suspenseContext = setDefaultShallowSuspenseListContext(suspenseContext);\n            }\n            pushSuspenseListContext(workInProgress, suspenseContext);\n            {\n                switch(revealOrder){\n                    case 'forwards':\n                        {\n                            var lastContentRow = findLastContentRow(workInProgress.child);\n                            var tail;\n                            if (lastContentRow === null) {\n                                // The whole list is part of the tail.\n                                // TODO: We could fast path by just rendering the tail now.\n                                tail = workInProgress.child;\n                                workInProgress.child = null;\n                            } else {\n                                // Disconnect the tail rows after the content row.\n                                // We're going to render them separately later.\n                                tail = lastContentRow.sibling;\n                                lastContentRow.sibling = null;\n                            }\n                            initSuspenseListRenderState(workInProgress, false, tail, lastContentRow, tailMode);\n                            break;\n                        }\n                    case 'backwards':\n                        {\n                            // We're going to find the first row that has existing content.\n                            // At the same time we're going to reverse the list of everything\n                            // we pass in the meantime. That's going to be our tail in reverse\n                            // order.\n                            var _tail = null;\n                            var row = workInProgress.child;\n                            workInProgress.child = null;\n                            while(row !== null){\n                                var currentRow = row.alternate; // New rows can't be content rows.\n                                if (currentRow !== null && findFirstSuspended(currentRow) === null) {\n                                    // This is the beginning of the main content.\n                                    workInProgress.child = row;\n                                    break;\n                                }\n                                var nextRow = row.sibling;\n                                row.sibling = _tail;\n                                _tail = row;\n                                row = nextRow;\n                            } // TODO: If workInProgress.child is null, we can continue on the tail immediately.\n                            initSuspenseListRenderState(workInProgress, true, _tail, null, tailMode);\n                            break;\n                        }\n                    case 'together':\n                        {\n                            initSuspenseListRenderState(workInProgress, false, null, null, undefined);\n                            break;\n                        }\n                    default:\n                        {\n                            // The default reveal order is the same as not having\n                            // a boundary.\n                            workInProgress.memoizedState = null;\n                        }\n                }\n            }\n            return workInProgress.child;\n        }\n        function updatePortalComponent(current, workInProgress, renderLanes) {\n            pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n            var nextChildren = workInProgress.pendingProps;\n            if (current === null) {\n                // Portals are special because we don't append the children during mount\n                // but at commit. Therefore we need to track insertions which the normal\n                // flow doesn't do during mount. This doesn't happen at the root because\n                // the root always starts with a \"current\" with a null child.\n                // TODO: Consider unifying this with how the root works.\n                workInProgress.child = reconcileChildFibers(workInProgress, null, nextChildren, renderLanes);\n            } else {\n                reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n            }\n            return workInProgress.child;\n        }\n        var hasWarnedAboutUsingNoValuePropOnContextProvider = false;\n        function updateContextProvider(current, workInProgress, renderLanes) {\n            var context;\n            {\n                context = workInProgress.type;\n            }\n            var newProps = workInProgress.pendingProps;\n            var oldProps = workInProgress.memoizedProps;\n            var newValue = newProps.value;\n            {\n                if (!('value' in newProps)) {\n                    if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {\n                        hasWarnedAboutUsingNoValuePropOnContextProvider = true;\n                        error('The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?');\n                    }\n                }\n            }\n            pushProvider(workInProgress, context, newValue);\n            {\n                if (oldProps !== null) {\n                    var oldValue = oldProps.value;\n                    if (objectIs(oldValue, newValue)) {\n                        // No change. Bailout early if children are the same.\n                        if (oldProps.children === newProps.children && !hasContextChanged()) {\n                            return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                        }\n                    } else {\n                        // The context value changed. Search for matching consumers and schedule\n                        // them to update.\n                        propagateContextChange(workInProgress, context, renderLanes);\n                    }\n                }\n            }\n            var newChildren = newProps.children;\n            reconcileChildren(current, workInProgress, newChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function updateContextConsumer(current, workInProgress, renderLanes) {\n            var context;\n            {\n                var consumerType = workInProgress.type;\n                context = consumerType._context;\n            }\n            var newProps = workInProgress.pendingProps;\n            var render = newProps.children;\n            {\n                if (typeof render !== 'function') {\n                    error('A context consumer was rendered with multiple children, or a child ' + \"that isn't a function. A context consumer expects a single child \" + 'that is a function. If you did pass a function, make sure there ' + 'is no trailing or leading whitespace around it.');\n                }\n            }\n            prepareToReadContext(workInProgress, renderLanes);\n            var newValue = readContext(context);\n            {\n                markComponentRenderStarted(workInProgress);\n            }\n            var newChildren;\n            {\n                setIsRendering(true);\n                newChildren = render(newValue);\n                setIsRendering(false);\n            }\n            {\n                markComponentRenderStopped();\n            }\n            workInProgress.flags |= PerformedWork;\n            reconcileChildren(current, workInProgress, newChildren, renderLanes);\n            return workInProgress.child;\n        }\n        function markWorkInProgressReceivedUpdate() {\n            didReceiveUpdate = true;\n        }\n        function bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {\n            if (current !== null) {\n                // Reuse previous dependencies\n                workInProgress.dependencies = current.dependencies;\n            }\n            {\n                // Don't update \"base\" render times for bailouts.\n                stopProfilerTimerIfRunning();\n            }\n            markSkippedUpdateLanes(workInProgress.lanes); // Check if the children have any pending work.\n            if (!includesSomeLane(renderLanes, workInProgress.childLanes)) {\n                // The children don't have any work either. We can skip them.\n                // TODO: Once we add back resuming, we should check if the children are\n                // a work-in-progress set. If so, we need to transfer their effects.\n                {\n                    return null;\n                }\n            } // This fiber doesn't have work, but its subtree does. Clone the child\n            // fibers and continue.\n            cloneChildFibers(current, workInProgress);\n            return workInProgress.child;\n        }\n        function remountFiber(current, oldWorkInProgress, newWorkInProgress) {\n            {\n                var returnFiber = oldWorkInProgress.return;\n                if (returnFiber === null) {\n                    // eslint-disable-next-line react-internal/prod-error-codes\n                    throw new Error('Cannot swap the root fiber.');\n                } // Disconnect from the old current.\n                // It will get deleted.\n                current.alternate = null;\n                oldWorkInProgress.alternate = null; // Connect to the new tree.\n                newWorkInProgress.index = oldWorkInProgress.index;\n                newWorkInProgress.sibling = oldWorkInProgress.sibling;\n                newWorkInProgress.return = oldWorkInProgress.return;\n                newWorkInProgress.ref = oldWorkInProgress.ref;\n                {\n                    newWorkInProgress._debugInfo = oldWorkInProgress._debugInfo;\n                }\n                if (oldWorkInProgress === returnFiber.child) {\n                    returnFiber.child = newWorkInProgress;\n                } else {\n                    var prevSibling = returnFiber.child;\n                    if (prevSibling === null) {\n                        // eslint-disable-next-line react-internal/prod-error-codes\n                        throw new Error('Expected parent to have a child.');\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    while(prevSibling.sibling !== oldWorkInProgress){\n                        // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        prevSibling = prevSibling.sibling;\n                        if (prevSibling === null) {\n                            // eslint-disable-next-line react-internal/prod-error-codes\n                            throw new Error('Expected to find the previous sibling.');\n                        }\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    prevSibling.sibling = newWorkInProgress;\n                } // Delete the old fiber and place the new one.\n                // Since the old fiber is disconnected, we have to schedule it manually.\n                var deletions = returnFiber.deletions;\n                if (deletions === null) {\n                    returnFiber.deletions = [\n                        current\n                    ];\n                    returnFiber.flags |= ChildDeletion;\n                } else {\n                    deletions.push(current);\n                }\n                newWorkInProgress.flags |= Placement; // Restart work from the new fiber.\n                return newWorkInProgress;\n            }\n        }\n        function checkScheduledUpdateOrContext(current, renderLanes) {\n            // Before performing an early bailout, we must check if there are pending\n            // updates or context.\n            var updateLanes = current.lanes;\n            if (includesSomeLane(updateLanes, renderLanes)) {\n                return true;\n            } // No pending update, but because context is propagated lazily, we need\n            return false;\n        }\n        function attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes) {\n            // This fiber does not have any pending work. Bailout without entering\n            // the begin phase. There's still some bookkeeping we that needs to be done\n            // in this optimized path, mostly pushing stuff onto the stack.\n            switch(workInProgress.tag){\n                case HostRoot:\n                    pushHostRootContext(workInProgress);\n                    {\n                        var cache = current.memoizedState.cache;\n                        pushCacheProvider(workInProgress, cache);\n                    }\n                    resetHydrationState();\n                    break;\n                case HostSingleton:\n                case HostComponent:\n                    pushHostContext(workInProgress);\n                    break;\n                case ClassComponent:\n                    {\n                        break;\n                    }\n                case HostPortal:\n                    pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n                    break;\n                case ContextProvider:\n                    {\n                        var newValue = workInProgress.memoizedProps.value;\n                        var context;\n                        {\n                            context = workInProgress.type;\n                        }\n                        pushProvider(workInProgress, context, newValue);\n                        break;\n                    }\n                case Profiler:\n                    {\n                        // Profiler should only call onRender when one of its descendants actually rendered.\n                        var hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n                        if (hasChildWork) {\n                            workInProgress.flags |= Update;\n                        }\n                        {\n                            // Reset effect durations for the next eventual effect phase.\n                            // These are reset during render to allow the DevTools commit hook a chance to read them,\n                            var stateNode = workInProgress.stateNode;\n                            stateNode.effectDuration = 0;\n                            stateNode.passiveEffectDuration = 0;\n                        }\n                    }\n                    break;\n                case SuspenseComponent:\n                    {\n                        var state = workInProgress.memoizedState;\n                        if (state !== null) {\n                            if (state.dehydrated !== null) {\n                                // We're not going to render the children, so this is just to maintain\n                                // push/pop symmetry\n                                pushPrimaryTreeSuspenseHandler(workInProgress); // We know that this component will suspend again because if it has\n                                // been unsuspended it has committed as a resolved Suspense component.\n                                // If it needs to be retried, it should have work scheduled on it.\n                                workInProgress.flags |= DidCapture; // We should never render the children of a dehydrated boundary until we\n                                // upgrade it. We return null instead of bailoutOnAlreadyFinishedWork.\n                                return null;\n                            } // If this boundary is currently timed out, we need to decide\n                            // whether to retry the primary children, or to skip over it and\n                            // go straight to the fallback. Check the priority of the primary\n                            // child fragment.\n                            var primaryChildFragment = workInProgress.child;\n                            var primaryChildLanes = primaryChildFragment.childLanes;\n                            if (includesSomeLane(renderLanes, primaryChildLanes)) {\n                                // The primary children have pending work. Use the normal path\n                                // to attempt to render the primary children again.\n                                return updateSuspenseComponent(current, workInProgress, renderLanes);\n                            } else {\n                                // The primary child fragment does not have pending work marked\n                                // on it\n                                pushPrimaryTreeSuspenseHandler(workInProgress); // The primary children do not have pending work with sufficient\n                                // priority. Bailout.\n                                var child = bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n                                if (child !== null) {\n                                    // The fallback children have pending work. Skip over the\n                                    // primary children and work on the fallback.\n                                    return child.sibling;\n                                } else {\n                                    // Note: We can return `null` here because we already checked\n                                    // whether there were nested context consumers, via the call to\n                                    // `bailoutOnAlreadyFinishedWork` above.\n                                    return null;\n                                }\n                            }\n                        } else {\n                            pushPrimaryTreeSuspenseHandler(workInProgress);\n                        }\n                        break;\n                    }\n                case SuspenseListComponent:\n                    {\n                        var didSuspendBefore = (current.flags & DidCapture) !== NoFlags$1;\n                        var _hasChildWork = includesSomeLane(renderLanes, workInProgress.childLanes);\n                        if (didSuspendBefore) {\n                            if (_hasChildWork) {\n                                // If something was in fallback state last time, and we have all the\n                                // same children then we're still in progressive loading state.\n                                // Something might get unblocked by state updates or retries in the\n                                // tree which will affect the tail. So we need to use the normal\n                                // path to compute the correct tail.\n                                return updateSuspenseListComponent(current, workInProgress, renderLanes);\n                            } // If none of the children had any work, that means that none of\n                            // them got retried so they'll still be blocked in the same way\n                            // as before. We can fast bail out.\n                            workInProgress.flags |= DidCapture;\n                        } // If nothing suspended before and we're rendering the same children,\n                        // then the tail doesn't matter. Anything new that suspends will work\n                        // in the \"together\" mode, so we can continue from the state we had.\n                        var renderState = workInProgress.memoizedState;\n                        if (renderState !== null) {\n                            // Reset to the \"together\" mode in case we've started a different\n                            // update in the past but didn't complete it.\n                            renderState.rendering = null;\n                            renderState.tail = null;\n                            renderState.lastEffect = null;\n                        }\n                        pushSuspenseListContext(workInProgress, suspenseStackCursor.current);\n                        if (_hasChildWork) {\n                            break;\n                        } else {\n                            // If none of the children had any work, that means that none of\n                            // them got retried so they'll still be blocked in the same way\n                            // as before. We can fast bail out.\n                            return null;\n                        }\n                    }\n                case OffscreenComponent:\n                case LegacyHiddenComponent:\n                    {\n                        // Need to check if the tree still needs to be deferred. This is\n                        // almost identical to the logic used in the normal update path,\n                        // so we'll just enter that. The only difference is we'll bail out\n                        // at the next level instead of this one, because the child props\n                        // have not changed. Which is fine.\n                        // TODO: Probably should refactor `beginWork` to split the bailout\n                        // path from the normal path. I'm tempted to do a labeled break here\n                        // but I won't :)\n                        workInProgress.lanes = NoLanes;\n                        return updateOffscreenComponent(current, workInProgress, renderLanes);\n                    }\n                case CacheComponent:\n                    {\n                        {\n                            var _cache = current.memoizedState.cache;\n                            pushCacheProvider(workInProgress, _cache);\n                        }\n                        break;\n                    }\n            }\n            return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n        }\n        function beginWork(current, workInProgress, renderLanes) {\n            {\n                if (workInProgress._debugNeedsRemount && current !== null) {\n                    // This will restart the begin phase with a new fiber.\n                    return remountFiber(current, workInProgress, createFiberFromTypeAndProps(workInProgress.type, workInProgress.key, workInProgress.pendingProps, workInProgress._debugOwner || null, workInProgress.mode, workInProgress.lanes));\n                }\n            }\n            if (current !== null) {\n                var oldProps = current.memoizedProps;\n                var newProps = workInProgress.pendingProps;\n                if (oldProps !== newProps || hasContextChanged() || workInProgress.type !== current.type) {\n                    // If props or context changed, mark the fiber as having performed work.\n                    // This may be unset if the props are determined to be equal later (memo).\n                    didReceiveUpdate = true;\n                } else {\n                    // Neither props nor legacy context changes. Check if there's a pending\n                    // update or context change.\n                    var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current, renderLanes);\n                    if (!hasScheduledUpdateOrContext && // If this is the second pass of an error or suspense boundary, there\n                    // may not be work scheduled on `current`, so we check for this flag.\n                    (workInProgress.flags & DidCapture) === NoFlags$1) {\n                        // No pending updates or context. Bail out now.\n                        didReceiveUpdate = false;\n                        return attemptEarlyBailoutIfNoScheduledUpdate(current, workInProgress, renderLanes);\n                    }\n                    if ((current.flags & ForceUpdateForLegacySuspense) !== NoFlags$1) {\n                        // This is a special case that only exists for legacy mode.\n                        // See https://github.com/facebook/react/pull/19216.\n                        didReceiveUpdate = true;\n                    } else {\n                        // An update was scheduled on this fiber, but there are no new props\n                        // nor legacy context. Set this to false. If an update queue or context\n                        // consumer produces a changed value, it will set this to true. Otherwise,\n                        // the component will assume the children have not changed and bail out.\n                        didReceiveUpdate = false;\n                    }\n                }\n            } else {\n                didReceiveUpdate = false;\n                if (getIsHydrating() && isForkedChild(workInProgress)) {\n                    // Check if this child belongs to a list of muliple children in\n                    // its parent.\n                    //\n                    // In a true multi-threaded implementation, we would render children on\n                    // parallel threads. This would represent the beginning of a new render\n                    // thread for this subtree.\n                    //\n                    // We only use this for id generation during hydration, which is why the\n                    // logic is located in this special branch.\n                    var slotIndex = workInProgress.index;\n                    var numberOfForks = getForksAtLevel();\n                    pushTreeId(workInProgress, numberOfForks, slotIndex);\n                }\n            } // Before entering the begin phase, clear pending update priority.\n            // TODO: This assumes that we're about to evaluate the component and process\n            // the update queue. However, there's an exception: SimpleMemoComponent\n            // sometimes bails out later in the begin phase. This indicates that we should\n            // move this assignment out of the common path and into each branch.\n            workInProgress.lanes = NoLanes;\n            switch(workInProgress.tag){\n                case LazyComponent:\n                    {\n                        var elementType = workInProgress.elementType;\n                        return mountLazyComponent(current, workInProgress, elementType, renderLanes);\n                    }\n                case FunctionComponent:\n                    {\n                        var Component = workInProgress.type;\n                        var unresolvedProps = workInProgress.pendingProps;\n                        var resolvedProps = unresolvedProps;\n                        return updateFunctionComponent(current, workInProgress, Component, resolvedProps, renderLanes);\n                    }\n                case ClassComponent:\n                    {\n                        var _Component = workInProgress.type;\n                        var _unresolvedProps = workInProgress.pendingProps;\n                        var _resolvedProps4 = resolveClassComponentProps(_Component, _unresolvedProps);\n                        return updateClassComponent(current, workInProgress, _Component, _resolvedProps4, renderLanes);\n                    }\n                case HostRoot:\n                    return updateHostRoot(current, workInProgress, renderLanes);\n                case HostHoistable:\n                    if (supportsResources) {\n                        return updateHostHoistable(current, workInProgress);\n                    }\n                // Fall through\n                case HostSingleton:\n                    if (supportsSingletons) {\n                        return updateHostSingleton(current, workInProgress, renderLanes);\n                    }\n                // Fall through\n                case HostComponent:\n                    return updateHostComponent$1(current, workInProgress, renderLanes);\n                case HostText:\n                    return updateHostText$1(current, workInProgress);\n                case SuspenseComponent:\n                    return updateSuspenseComponent(current, workInProgress, renderLanes);\n                case HostPortal:\n                    return updatePortalComponent(current, workInProgress, renderLanes);\n                case ForwardRef:\n                    {\n                        var type = workInProgress.type;\n                        var _unresolvedProps2 = workInProgress.pendingProps;\n                        var _resolvedProps5 = _unresolvedProps2;\n                        return updateForwardRef(current, workInProgress, type, _resolvedProps5, renderLanes);\n                    }\n                case Fragment:\n                    return updateFragment(current, workInProgress, renderLanes);\n                case Mode:\n                    return updateMode(current, workInProgress, renderLanes);\n                case Profiler:\n                    return updateProfiler(current, workInProgress, renderLanes);\n                case ContextProvider:\n                    return updateContextProvider(current, workInProgress, renderLanes);\n                case ContextConsumer:\n                    return updateContextConsumer(current, workInProgress, renderLanes);\n                case MemoComponent:\n                    {\n                        var _type = workInProgress.type;\n                        var _unresolvedProps3 = workInProgress.pendingProps; // Resolve outer props first, then resolve inner props.\n                        var _resolvedProps6 = _unresolvedProps3;\n                        _resolvedProps6 = _resolvedProps6;\n                        return updateMemoComponent(current, workInProgress, _type, _resolvedProps6, renderLanes);\n                    }\n                case SimpleMemoComponent:\n                    {\n                        return updateSimpleMemoComponent(current, workInProgress, workInProgress.type, workInProgress.pendingProps, renderLanes);\n                    }\n                case IncompleteClassComponent:\n                    {\n                        {\n                            break;\n                        }\n                    }\n                case IncompleteFunctionComponent:\n                    {\n                        {\n                            break;\n                        }\n                    }\n                case SuspenseListComponent:\n                    {\n                        return updateSuspenseListComponent(current, workInProgress, renderLanes);\n                    }\n                case ScopeComponent:\n                    {\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        return updateOffscreenComponent(current, workInProgress, renderLanes);\n                    }\n                case LegacyHiddenComponent:\n                    {\n                        break;\n                    }\n                case CacheComponent:\n                    {\n                        {\n                            return updateCacheComponent(current, workInProgress, renderLanes);\n                        }\n                    }\n            }\n            throw new Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in \" + 'React. Please file an issue.');\n        }\n        var valueCursor = createCursor(null);\n        var rendererCursorDEV;\n        {\n            rendererCursorDEV = createCursor(null);\n        }\n        var renderer2CursorDEV;\n        {\n            renderer2CursorDEV = createCursor(null);\n        }\n        var rendererSigil;\n        {\n            // Use this to detect multiple renderers using the same context\n            rendererSigil = {};\n        }\n        var currentlyRenderingFiber = null;\n        var lastContextDependency = null;\n        var lastFullyObservedContext = null;\n        var isDisallowedContextReadInDEV = false;\n        function resetContextDependencies() {\n            // This is called right before React yields execution, to ensure `readContext`\n            // cannot be called outside the render phase.\n            currentlyRenderingFiber = null;\n            lastContextDependency = null;\n            lastFullyObservedContext = null;\n            {\n                isDisallowedContextReadInDEV = false;\n            }\n        }\n        function enterDisallowedContextReadInDEV() {\n            {\n                isDisallowedContextReadInDEV = true;\n            }\n        }\n        function exitDisallowedContextReadInDEV() {\n            {\n                isDisallowedContextReadInDEV = false;\n            }\n        }\n        function pushProvider(providerFiber, context, nextValue) {\n            if (isPrimaryRenderer) {\n                push(valueCursor, context._currentValue, providerFiber);\n                context._currentValue = nextValue;\n                {\n                    push(rendererCursorDEV, context._currentRenderer, providerFiber);\n                    if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {\n                        error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');\n                    }\n                    context._currentRenderer = rendererSigil;\n                }\n            } else {\n                push(valueCursor, context._currentValue2, providerFiber);\n                context._currentValue2 = nextValue;\n                {\n                    push(renderer2CursorDEV, context._currentRenderer2, providerFiber);\n                    if (context._currentRenderer2 !== undefined && context._currentRenderer2 !== null && context._currentRenderer2 !== rendererSigil) {\n                        error('Detected multiple renderers concurrently rendering the ' + 'same context provider. This is currently unsupported.');\n                    }\n                    context._currentRenderer2 = rendererSigil;\n                }\n            }\n        }\n        function popProvider(context, providerFiber) {\n            var currentValue = valueCursor.current;\n            if (isPrimaryRenderer) {\n                context._currentValue = currentValue;\n                {\n                    var currentRenderer = rendererCursorDEV.current;\n                    pop(rendererCursorDEV, providerFiber);\n                    context._currentRenderer = currentRenderer;\n                }\n            } else {\n                context._currentValue2 = currentValue;\n                {\n                    var currentRenderer2 = renderer2CursorDEV.current;\n                    pop(renderer2CursorDEV, providerFiber);\n                    context._currentRenderer2 = currentRenderer2;\n                }\n            }\n            pop(valueCursor, providerFiber);\n        }\n        function scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {\n            // Update the child lanes of all the ancestors, including the alternates.\n            var node = parent;\n            while(node !== null){\n                var alternate = node.alternate;\n                if (!isSubsetOfLanes(node.childLanes, renderLanes)) {\n                    node.childLanes = mergeLanes(node.childLanes, renderLanes);\n                    if (alternate !== null) {\n                        alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);\n                    }\n                } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes)) {\n                    alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes);\n                } else ;\n                if (node === propagationRoot) {\n                    break;\n                }\n                node = node.return;\n            }\n            {\n                if (node !== propagationRoot) {\n                    error('Expected to find the propagation root when scheduling context work. ' + 'This error is likely caused by a bug in React. Please file an issue.');\n                }\n            }\n        }\n        function propagateContextChange(workInProgress, context, renderLanes) {\n            {\n                propagateContextChange_eager(workInProgress, context, renderLanes);\n            }\n        }\n        function propagateContextChange_eager(workInProgress, context, renderLanes) {\n            var fiber = workInProgress.child;\n            if (fiber !== null) {\n                // Set the return pointer of the child to the work-in-progress fiber.\n                fiber.return = workInProgress;\n            }\n            while(fiber !== null){\n                var nextFiber = void 0; // Visit this fiber.\n                var list = fiber.dependencies;\n                if (list !== null) {\n                    nextFiber = fiber.child;\n                    var dependency = list.firstContext;\n                    while(dependency !== null){\n                        // Check if the context matches.\n                        if (dependency.context === context) {\n                            // Match! Schedule an update on this fiber.\n                            if (fiber.tag === ClassComponent) {\n                                // Schedule a force update on the work-in-progress.\n                                var lane = pickArbitraryLane(renderLanes);\n                                var update = createUpdate(lane);\n                                update.tag = ForceUpdate; // TODO: Because we don't have a work-in-progress, this will add the\n                                // update to the current fiber, too, which means it will persist even if\n                                // this render is thrown away. Since it's a race condition, not sure it's\n                                // worth fixing.\n                                // Inlined `enqueueUpdate` to remove interleaved update check\n                                var updateQueue = fiber.updateQueue;\n                                if (updateQueue === null) ;\n                                else {\n                                    var sharedQueue = updateQueue.shared;\n                                    var pending = sharedQueue.pending;\n                                    if (pending === null) {\n                                        // This is the first update. Create a circular list.\n                                        update.next = update;\n                                    } else {\n                                        update.next = pending.next;\n                                        pending.next = update;\n                                    }\n                                    sharedQueue.pending = update;\n                                }\n                            }\n                            fiber.lanes = mergeLanes(fiber.lanes, renderLanes);\n                            var alternate = fiber.alternate;\n                            if (alternate !== null) {\n                                alternate.lanes = mergeLanes(alternate.lanes, renderLanes);\n                            }\n                            scheduleContextWorkOnParentPath(fiber.return, renderLanes, workInProgress); // Mark the updated lanes on the list, too.\n                            list.lanes = mergeLanes(list.lanes, renderLanes); // Since we already found a match, we can stop traversing the\n                            break;\n                        }\n                        dependency = dependency.next;\n                    }\n                } else if (fiber.tag === ContextProvider) {\n                    // Don't scan deeper if this is a matching provider\n                    nextFiber = fiber.type === workInProgress.type ? null : fiber.child;\n                } else if (fiber.tag === DehydratedFragment) {\n                    // If a dehydrated suspense boundary is in this subtree, we don't know\n                    // if it will have any context consumers in it. The best we can do is\n                    // mark it as having updates.\n                    var parentSuspense = fiber.return;\n                    if (parentSuspense === null) {\n                        throw new Error('We just came from a parent so we must have had a parent. This is a bug in React.');\n                    }\n                    parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes);\n                    var _alternate = parentSuspense.alternate;\n                    if (_alternate !== null) {\n                        _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes);\n                    } // This is intentionally passing this fiber as the parent\n                    // because we want to schedule this fiber as having work\n                    // on its children. We'll use the childLanes on\n                    // this fiber to indicate that a context has changed.\n                    scheduleContextWorkOnParentPath(parentSuspense, renderLanes, workInProgress);\n                    nextFiber = fiber.sibling;\n                } else {\n                    // Traverse down.\n                    nextFiber = fiber.child;\n                }\n                if (nextFiber !== null) {\n                    // Set the return pointer of the child to the work-in-progress fiber.\n                    nextFiber.return = fiber;\n                } else {\n                    // No child. Traverse to next sibling.\n                    nextFiber = fiber;\n                    while(nextFiber !== null){\n                        if (nextFiber === workInProgress) {\n                            // We're back to the root of this subtree. Exit.\n                            nextFiber = null;\n                            break;\n                        }\n                        var sibling = nextFiber.sibling;\n                        if (sibling !== null) {\n                            // Set the return pointer of the sibling to the work-in-progress fiber.\n                            sibling.return = nextFiber.return;\n                            nextFiber = sibling;\n                            break;\n                        } // No more siblings. Traverse up.\n                        nextFiber = nextFiber.return;\n                    }\n                }\n                fiber = nextFiber;\n            }\n        }\n        function prepareToReadContext(workInProgress, renderLanes) {\n            currentlyRenderingFiber = workInProgress;\n            lastContextDependency = null;\n            lastFullyObservedContext = null;\n            var dependencies = workInProgress.dependencies;\n            if (dependencies !== null) {\n                {\n                    var firstContext = dependencies.firstContext;\n                    if (firstContext !== null) {\n                        if (includesSomeLane(dependencies.lanes, renderLanes)) {\n                            // Context list has a pending update. Mark that this fiber performed work.\n                            markWorkInProgressReceivedUpdate();\n                        } // Reset the work-in-progress list\n                        dependencies.firstContext = null;\n                    }\n                }\n            }\n        }\n        function readContext(context) {\n            {\n                // This warning would fire if you read context inside a Hook like useMemo.\n                // Unlike the class check below, it's not enforced in production for perf.\n                if (isDisallowedContextReadInDEV) {\n                    error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\n                }\n            }\n            return readContextForConsumer(currentlyRenderingFiber, context);\n        }\n        function readContextDuringReconciliation(consumer, context, renderLanes) {\n            if (currentlyRenderingFiber === null) {\n                prepareToReadContext(consumer, renderLanes);\n            }\n            return readContextForConsumer(consumer, context);\n        }\n        function readContextForConsumer(consumer, context) {\n            var value = isPrimaryRenderer ? context._currentValue : context._currentValue2;\n            if (lastFullyObservedContext === context) ;\n            else {\n                var contextItem = {\n                    context: context,\n                    memoizedValue: value,\n                    next: null\n                };\n                if (lastContextDependency === null) {\n                    if (consumer === null) {\n                        throw new Error('Context can only be read while React is rendering. ' + 'In classes, you can read it in the render method or getDerivedStateFromProps. ' + 'In function components, you can read it directly in the function body, but not ' + 'inside Hooks like useReducer() or useMemo().');\n                    } // This is the first dependency for this component. Create a new list.\n                    lastContextDependency = contextItem;\n                    consumer.dependencies = {\n                        lanes: NoLanes,\n                        firstContext: contextItem\n                    };\n                } else {\n                    // Append a new context item.\n                    lastContextDependency = lastContextDependency.next = contextItem;\n                }\n            }\n            return value;\n        }\n        // replace it with a lightweight shim that only has the features we use.\n        var AbortControllerLocal = typeof AbortController !== 'undefined' ? AbortController : // $FlowFixMe[prop-missing]\n        function AbortControllerShim() {\n            var listeners = [];\n            var signal = this.signal = {\n                aborted: false,\n                addEventListener: function(type, listener) {\n                    listeners.push(listener);\n                }\n            };\n            this.abort = function() {\n                signal.aborted = true;\n                listeners.forEach(function(listener) {\n                    return listener();\n                });\n            };\n        }; // Intentionally not named imports because Rollup would\n        // use dynamic dispatch for CommonJS interop named imports.\n        var scheduleCallback$1 = Scheduler.unstable_scheduleCallback, NormalPriority = Scheduler.unstable_NormalPriority;\n        var CacheContext = {\n            $$typeof: REACT_CONTEXT_TYPE,\n            // We don't use Consumer/Provider for Cache components. So we'll cheat.\n            Consumer: null,\n            Provider: null,\n            // We'll initialize these at the root.\n            _currentValue: null,\n            _currentValue2: null,\n            _threadCount: 0\n        };\n        {\n            CacheContext._currentRenderer = null;\n            CacheContext._currentRenderer2 = null;\n        }\n        // for retaining the cache once it is in use (retainCache), and releasing the cache\n        // once it is no longer needed (releaseCache).\n        function createCache() {\n            var cache = {\n                controller: new AbortControllerLocal(),\n                data: new Map(),\n                refCount: 0\n            };\n            return cache;\n        }\n        function retainCache(cache) {\n            {\n                if (cache.controller.signal.aborted) {\n                    warn('A cache instance was retained after it was already freed. ' + 'This likely indicates a bug in React.');\n                }\n            }\n            cache.refCount++;\n        } // Cleanup a cache instance, potentially freeing it if there are no more references\n        function releaseCache(cache) {\n            cache.refCount--;\n            {\n                if (cache.refCount < 0) {\n                    warn('A cache instance was released after it was already freed. ' + 'This likely indicates a bug in React.');\n                }\n            }\n            if (cache.refCount === 0) {\n                scheduleCallback$1(NormalPriority, function() {\n                    cache.controller.abort();\n                });\n            }\n        }\n        function pushCacheProvider(workInProgress, cache) {\n            pushProvider(workInProgress, CacheContext, cache);\n        }\n        function popCacheProvider(workInProgress, cache) {\n            popProvider(CacheContext, workInProgress);\n        }\n        // the shared internals object. This is used by the isomorphic implementation of\n        // startTransition to compose all the startTransitions together.\n        //\n        //   function startTransition(fn) {\n        //     return startTransitionDOM(() => {\n        //       return startTransitionART(() => {\n        //         return startTransitionThreeFiber(() => {\n        //           // and so on...\n        //           return fn();\n        //         });\n        //       });\n        //     });\n        //   }\n        //\n        // Currently we only compose together the code that runs at the end of each\n        // startTransition, because for now that's sufficient — the part that sets\n        // isTransition=true on the stack uses a separate shared internal field. But\n        // really we should delete the shared field and track isTransition per\n        // reconciler. Leaving this for a future PR.\n        var prevOnStartTransitionFinish = ReactSharedInternals.S;\n        ReactSharedInternals.S = function onStartTransitionFinishForReconciler(transition, returnValue) {\n            if (typeof returnValue === 'object' && returnValue !== null && typeof returnValue.then === 'function') {\n                // This is an async action\n                var thenable = returnValue;\n                entangleAsyncAction(transition, thenable);\n            }\n            if (prevOnStartTransitionFinish !== null) {\n                prevOnStartTransitionFinish(transition, returnValue);\n            }\n        };\n        function requestCurrentTransition() {\n            return ReactSharedInternals.T;\n        } // When retrying a Suspense/Offscreen boundary, we restore the cache that was\n        // used during the previous render by placing it here, on the stack.\n        var resumedCache = createCursor(null); // During the render/synchronous commit phase, we don't actually process the\n        function peekCacheFromPool() {\n            // If we're rendering inside a Suspense boundary that is currently hidden,\n            // we should use the same cache that we used during the previous render, if\n            // one exists.\n            var cacheResumedFromPreviousRender = resumedCache.current;\n            if (cacheResumedFromPreviousRender !== null) {\n                return cacheResumedFromPreviousRender;\n            } // Otherwise, check the root's cache pool.\n            var root = getWorkInProgressRoot();\n            var cacheFromRootCachePool = root.pooledCache;\n            return cacheFromRootCachePool;\n        }\n        function requestCacheFromPool(renderLanes) {\n            // Similar to previous function, except if there's not already a cache in the\n            // pool, we allocate a new one.\n            var cacheFromPool = peekCacheFromPool();\n            if (cacheFromPool !== null) {\n                return cacheFromPool;\n            } // Create a fresh cache and add it to the root cache pool. A cache can have\n            // multiple owners:\n            // - A cache pool that lives on the FiberRoot. This is where all fresh caches\n            //   are originally created (TODO: except during refreshes, until we implement\n            //   this correctly). The root takes ownership immediately when the cache is\n            //   created. Conceptually, root.pooledCache is an Option<Arc<Cache>> (owned),\n            //   and the return value of this function is a &Arc<Cache> (borrowed).\n            // - One of several fiber types: host root, cache boundary, suspense\n            //   component. These retain and release in the commit phase.\n            var root = getWorkInProgressRoot();\n            var freshCache = createCache();\n            root.pooledCache = freshCache;\n            retainCache(freshCache);\n            if (freshCache !== null) {\n                root.pooledCacheLanes |= renderLanes;\n            }\n            return freshCache;\n        }\n        function pushTransition(offscreenWorkInProgress, prevCachePool, newTransitions) {\n            {\n                if (prevCachePool === null) {\n                    push(resumedCache, resumedCache.current, offscreenWorkInProgress);\n                } else {\n                    push(resumedCache, prevCachePool.pool, offscreenWorkInProgress);\n                }\n            }\n        }\n        function popTransition(workInProgress, current) {\n            if (current !== null) {\n                {\n                    pop(resumedCache, workInProgress);\n                }\n            }\n        }\n        function getSuspendedCache() {\n            // cache that would have been used to render fresh data during this render,\n            // if there was any, so that we can resume rendering with the same cache when\n            // we receive more data.\n            var cacheFromPool = peekCacheFromPool();\n            if (cacheFromPool === null) {\n                return null;\n            }\n            return {\n                // We must also save the parent, so that when we resume we can detect\n                // a refresh.\n                parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,\n                pool: cacheFromPool\n            };\n        }\n        function getOffscreenDeferredCache() {\n            var cacheFromPool = peekCacheFromPool();\n            if (cacheFromPool === null) {\n                return null;\n            }\n            return {\n                // We must also store the parent, so that when we resume we can detect\n                // a refresh.\n                parent: isPrimaryRenderer ? CacheContext._currentValue : CacheContext._currentValue2,\n                pool: cacheFromPool\n            };\n        }\n        /**\n * Tag the fiber with an update effect. This turns a Placement into\n * a PlacementAndUpdate.\n */ function markUpdate(workInProgress) {\n            workInProgress.flags |= Update;\n        }\n        /**\n * In persistent mode, return whether this update needs to clone the subtree.\n */ function doesRequireClone(current, completedWork) {\n            var didBailout = current !== null && current.child === completedWork.child;\n            if (didBailout) {\n                return false;\n            }\n            if ((completedWork.flags & ChildDeletion) !== NoFlags$1) {\n                return true;\n            } // TODO: If we move the `doesRequireClone` call after `bubbleProperties`\n            // then we only have to check the `completedWork.subtreeFlags`.\n            var child = completedWork.child;\n            while(child !== null){\n                if ((child.flags & MutationMask) !== NoFlags$1 || (child.subtreeFlags & MutationMask) !== NoFlags$1) {\n                    return true;\n                }\n                child = child.sibling;\n            }\n            return false;\n        }\n        function appendAllChildren(parent, workInProgress, needsVisibilityToggle, isHidden) {\n            if (supportsMutation) {\n                // We only have the top Fiber that was created but we need recurse down its\n                // children to find all the terminal nodes.\n                var node = workInProgress.child;\n                while(node !== null){\n                    if (node.tag === HostComponent || node.tag === HostText) {\n                        appendInitialChild(parent, node.stateNode);\n                    } else if (node.tag === HostPortal || (supportsSingletons ? node.tag === HostSingleton : false)) ;\n                    else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                    if (node === workInProgress) {\n                        return;\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    while(node.sibling === null){\n                        // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        if (node.return === null || node.return === workInProgress) {\n                            return;\n                        }\n                        node = node.return;\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            } else if (supportsPersistence) {\n                // We only have the top Fiber that was created but we need recurse down its\n                // children to find all the terminal nodes.\n                var _node = workInProgress.child;\n                while(_node !== null){\n                    if (_node.tag === HostComponent) {\n                        var instance = _node.stateNode;\n                        if (needsVisibilityToggle && isHidden) {\n                            // This child is inside a timed out tree. Hide it.\n                            var props = _node.memoizedProps;\n                            var type = _node.type;\n                            instance = cloneHiddenInstance(instance, type, props);\n                        }\n                        appendInitialChild(parent, instance);\n                    } else if (_node.tag === HostText) {\n                        var _instance = _node.stateNode;\n                        if (needsVisibilityToggle && isHidden) {\n                            // This child is inside a timed out tree. Hide it.\n                            var text = _node.memoizedProps;\n                            _instance = cloneHiddenTextInstance(_instance, text);\n                        }\n                        appendInitialChild(parent, _instance);\n                    } else if (_node.tag === HostPortal) ;\n                    else if (_node.tag === OffscreenComponent && _node.memoizedState !== null) {\n                        // The children in this boundary are hidden. Toggle their visibility\n                        // before appending.\n                        var child = _node.child;\n                        if (child !== null) {\n                            child.return = _node;\n                        }\n                        appendAllChildren(parent, _node, /* needsVisibilityToggle */ true, /* isHidden */ true);\n                    } else if (_node.child !== null) {\n                        _node.child.return = _node;\n                        _node = _node.child;\n                        continue;\n                    }\n                    if (_node === workInProgress) {\n                        return;\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    while(_node.sibling === null){\n                        // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        if (_node.return === null || _node.return === workInProgress) {\n                            return;\n                        }\n                        _node = _node.return;\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    _node.sibling.return = _node.return;\n                    _node = _node.sibling;\n                }\n            }\n        } // An unfortunate fork of appendAllChildren because we have two different parent types.\n        function appendAllChildrenToContainer(containerChildSet, workInProgress, needsVisibilityToggle, isHidden) {\n            if (supportsPersistence) {\n                // We only have the top Fiber that was created but we need recurse down its\n                // children to find all the terminal nodes.\n                var node = workInProgress.child;\n                while(node !== null){\n                    if (node.tag === HostComponent) {\n                        var instance = node.stateNode;\n                        if (needsVisibilityToggle && isHidden) {\n                            // This child is inside a timed out tree. Hide it.\n                            var props = node.memoizedProps;\n                            var type = node.type;\n                            instance = cloneHiddenInstance(instance, type, props);\n                        }\n                        appendChildToContainerChildSet(containerChildSet, instance);\n                    } else if (node.tag === HostText) {\n                        var _instance2 = node.stateNode;\n                        if (needsVisibilityToggle && isHidden) {\n                            // This child is inside a timed out tree. Hide it.\n                            var text = node.memoizedProps;\n                            _instance2 = cloneHiddenTextInstance(_instance2, text);\n                        }\n                        appendChildToContainerChildSet(containerChildSet, _instance2);\n                    } else if (node.tag === HostPortal) ;\n                    else if (node.tag === OffscreenComponent && node.memoizedState !== null) {\n                        // The children in this boundary are hidden. Toggle their visibility\n                        // before appending.\n                        var child = node.child;\n                        if (child !== null) {\n                            child.return = node;\n                        } // If Offscreen is not in manual mode, detached tree is hidden from user space.\n                        var _needsVisibilityToggle = !isOffscreenManual(node);\n                        appendAllChildrenToContainer(containerChildSet, node, /* needsVisibilityToggle */ _needsVisibilityToggle, /* isHidden */ true);\n                    } else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                    node = node;\n                    if (node === workInProgress) {\n                        return;\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    while(node.sibling === null){\n                        // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        if (node.return === null || node.return === workInProgress) {\n                            return;\n                        }\n                        node = node.return;\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            }\n        }\n        function updateHostContainer(current, workInProgress) {\n            if (supportsPersistence) {\n                if (doesRequireClone(current, workInProgress)) {\n                    var portalOrRoot = workInProgress.stateNode;\n                    var container = portalOrRoot.containerInfo;\n                    var newChildSet = createContainerChildSet(); // If children might have changed, we have to add them all to the set.\n                    appendAllChildrenToContainer(newChildSet, workInProgress, /* needsVisibilityToggle */ false, /* isHidden */ false);\n                    portalOrRoot.pendingChildren = newChildSet; // Schedule an update on the container to swap out the container.\n                    markUpdate(workInProgress);\n                    finalizeContainerChildren(container, newChildSet);\n                }\n            }\n        }\n        function updateHostComponent(current, workInProgress, type, newProps, renderLanes) {\n            if (supportsMutation) {\n                // If we have an alternate, that means this is an update and we need to\n                // schedule a side-effect to do the updates.\n                var oldProps = current.memoizedProps;\n                if (oldProps === newProps) {\n                    // In mutation mode, this is sufficient for a bailout because\n                    // we won't touch this node even if children changed.\n                    return;\n                }\n                markUpdate(workInProgress);\n            } else if (supportsPersistence) {\n                var currentInstance = current.stateNode;\n                var _oldProps = current.memoizedProps; // If there are no effects associated with this node, then none of our children had any updates.\n                // This guarantees that we can reuse all of them.\n                var requiresClone = doesRequireClone(current, workInProgress);\n                if (!requiresClone && _oldProps === newProps) {\n                    // No changes, just reuse the existing instance.\n                    // Note that this might release a previous clone.\n                    workInProgress.stateNode = currentInstance;\n                    return;\n                }\n                var currentHostContext = getHostContext();\n                var newChildSet = null;\n                if (requiresClone && passChildrenWhenCloningPersistedNodes) {\n                    newChildSet = createContainerChildSet(); // If children might have changed, we have to add them all to the set.\n                    appendAllChildrenToContainer(newChildSet, workInProgress, /* needsVisibilityToggle */ false, /* isHidden */ false);\n                }\n                var newInstance = cloneInstance(currentInstance, type, _oldProps, newProps, !requiresClone, newChildSet);\n                if (newInstance === currentInstance) {\n                    // No changes, just reuse the existing instance.\n                    // Note that this might release a previous clone.\n                    workInProgress.stateNode = currentInstance;\n                    return;\n                } // Certain renderers require commit-time effects for initial mount.\n                // (eg DOM renderer supports auto-focus for certain elements).\n                // Make sure such renderers get scheduled for later work.\n                if (finalizeInitialChildren(newInstance, type, newProps, currentHostContext)) {\n                    markUpdate(workInProgress);\n                }\n                workInProgress.stateNode = newInstance;\n                if (!requiresClone) {\n                    // If there are no other effects in this tree, we need to flag this node as having one.\n                    // Even though we're not going to use it for anything.\n                    // Otherwise parents won't know that there are new children to propagate upwards.\n                    markUpdate(workInProgress);\n                } else {\n                    // If children might have changed, we have to add them all to the set.\n                    appendAllChildren(newInstance, workInProgress, /* needsVisibilityToggle */ false, /* isHidden */ false);\n                }\n            }\n        } // This function must be called at the very end of the complete phase, because\n        // it might throw to suspend, and if the resource immediately loads, the work\n        // loop will resume rendering as if the work-in-progress completed. So it must\n        // fully complete.\n        // TODO: This should ideally move to begin phase, but currently the instance is\n        // not created until the complete phase. For our existing use cases, host nodes\n        // that suspend don't have children, so it doesn't matter. But that might not\n        // always be true in the future.\n        function preloadInstanceAndSuspendIfNeeded(workInProgress, type, props, renderLanes) {\n            if (!maySuspendCommit(type, props)) {\n                // If this flag was set previously, we can remove it. The flag\n                // represents whether this particular set of props might ever need to\n                // suspend. The safest thing to do is for maySuspendCommit to always\n                // return true, but if the renderer is reasonably confident that the\n                // underlying resource won't be evicted, it can return false as a\n                // performance optimization.\n                workInProgress.flags &= ~MaySuspendCommit;\n                return;\n            } // Mark this fiber with a flag. This gets set on all host instances\n            // that might possibly suspend, even if they don't need to suspend\n            // currently. We use this when revealing a prerendered tree, because\n            // even though the tree has \"mounted\", its resources might not have\n            // loaded yet.\n            workInProgress.flags |= MaySuspendCommit; // preload the instance if necessary. Even if this is an urgent render there\n            // could be benefits to preloading early.\n            // @TODO we should probably do the preload in begin work\n            var isReady = preloadInstance(type, props);\n            if (!isReady) {\n                if (shouldRemainOnPreviousScreen()) {\n                    workInProgress.flags |= ShouldSuspendCommit;\n                } else {\n                    suspendCommit();\n                }\n            }\n        }\n        function preloadResourceAndSuspendIfNeeded(workInProgress, resource, type, props, renderLanes) {\n            // This is a fork of preloadInstanceAndSuspendIfNeeded, but for resources.\n            if (!mayResourceSuspendCommit(resource)) {\n                workInProgress.flags &= ~MaySuspendCommit;\n                return;\n            }\n            workInProgress.flags |= MaySuspendCommit;\n            var isReady = preloadResource(resource);\n            if (!isReady) {\n                if (shouldRemainOnPreviousScreen()) {\n                    workInProgress.flags |= ShouldSuspendCommit;\n                } else {\n                    suspendCommit();\n                }\n            }\n        }\n        function scheduleRetryEffect(workInProgress, retryQueue) {\n            var wakeables = retryQueue;\n            if (wakeables !== null) {\n                // Schedule an effect to attach a retry listener to the promise.\n                // TODO: Move to passive phase\n                workInProgress.flags |= Update;\n            } else {\n                // This boundary suspended, but no wakeables were added to the retry\n                // queue. Check if the renderer suspended commit. If so, this means\n                // that once the fallback is committed, we can immediately retry\n                // rendering again, because rendering wasn't actually blocked. Only\n                // the commit phase.\n                // TODO: Consider a model where we always schedule an immediate retry, even\n                // for normal Suspense. That way the retry can partially render up to the\n                // first thing that suspends.\n                if (workInProgress.flags & ScheduleRetry) {\n                    var retryLane = // I also suspect that we need some further consolidation of offscreen\n                    // and retry lanes.\n                    workInProgress.tag !== OffscreenComponent ? claimNextRetryLane() : OffscreenLane;\n                    workInProgress.lanes = mergeLanes(workInProgress.lanes, retryLane);\n                }\n            }\n        }\n        function updateHostText(current, workInProgress, oldText, newText) {\n            if (supportsMutation) {\n                // If the text differs, mark it as an update. All the work in done in commitWork.\n                if (oldText !== newText) {\n                    markUpdate(workInProgress);\n                }\n            } else if (supportsPersistence) {\n                if (oldText !== newText) {\n                    // If the text content differs, we'll create a new text instance for it.\n                    var rootContainerInstance = getRootHostContainer();\n                    var currentHostContext = getHostContext();\n                    workInProgress.stateNode = createTextInstance(newText, rootContainerInstance, currentHostContext, workInProgress); // We'll have to mark it as having an effect, even though we won't use the effect for anything.\n                    // This lets the parents know that at least one of their children has changed.\n                    markUpdate(workInProgress);\n                } else {\n                    workInProgress.stateNode = current.stateNode;\n                }\n            }\n        }\n        function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n            if (getIsHydrating()) {\n                // If we're hydrating, we should consume as many items as we can\n                // so we don't leave any behind.\n                return;\n            }\n            switch(renderState.tailMode){\n                case 'hidden':\n                    {\n                        // Any insertions at the end of the tail list after this point\n                        // should be invisible. If there are already mounted boundaries\n                        // anything before them are not considered for collapsing.\n                        // Therefore we need to go through the whole tail to find if\n                        // there are any.\n                        var tailNode = renderState.tail;\n                        var lastTailNode = null;\n                        while(tailNode !== null){\n                            if (tailNode.alternate !== null) {\n                                lastTailNode = tailNode;\n                            }\n                            tailNode = tailNode.sibling;\n                        } // Next we're simply going to delete all insertions after the\n                        // last rendered item.\n                        if (lastTailNode === null) {\n                            // All remaining items in the tail are insertions.\n                            renderState.tail = null;\n                        } else {\n                            // Detach the insertion after the last node that was already\n                            // inserted.\n                            lastTailNode.sibling = null;\n                        }\n                        break;\n                    }\n                case 'collapsed':\n                    {\n                        // Any insertions at the end of the tail list after this point\n                        // should be invisible. If there are already mounted boundaries\n                        // anything before them are not considered for collapsing.\n                        // Therefore we need to go through the whole tail to find if\n                        // there are any.\n                        var _tailNode = renderState.tail;\n                        var _lastTailNode = null;\n                        while(_tailNode !== null){\n                            if (_tailNode.alternate !== null) {\n                                _lastTailNode = _tailNode;\n                            }\n                            _tailNode = _tailNode.sibling;\n                        } // Next we're simply going to delete all insertions after the\n                        // last rendered item.\n                        if (_lastTailNode === null) {\n                            // All remaining items in the tail are insertions.\n                            if (!hasRenderedATailFallback && renderState.tail !== null) {\n                                // We suspended during the head. We want to show at least one\n                                // row at the tail. So we'll keep on and cut off the rest.\n                                renderState.tail.sibling = null;\n                            } else {\n                                renderState.tail = null;\n                            }\n                        } else {\n                            // Detach the insertion after the last node that was already\n                            // inserted.\n                            _lastTailNode.sibling = null;\n                        }\n                        break;\n                    }\n            }\n        }\n        function bubbleProperties(completedWork) {\n            var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;\n            var newChildLanes = NoLanes;\n            var subtreeFlags = NoFlags$1;\n            if (!didBailout) {\n                // Bubble up the earliest expiration time.\n                if ((completedWork.mode & ProfileMode) !== NoMode) {\n                    // In profiling mode, resetChildExpirationTime is also used to reset\n                    // profiler durations.\n                    var actualDuration = completedWork.actualDuration;\n                    var treeBaseDuration = completedWork.selfBaseDuration;\n                    var child = completedWork.child;\n                    while(child !== null){\n                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));\n                        subtreeFlags |= child.subtreeFlags;\n                        subtreeFlags |= child.flags; // When a fiber is cloned, its actualDuration is reset to 0. This value will\n                        // only be updated if work is done on the fiber (i.e. it doesn't bailout).\n                        // When work is done, it should bubble to the parent's actualDuration. If\n                        // the fiber has not been cloned though, (meaning no work was done), then\n                        // this value will reflect the amount of time spent working on a previous\n                        // render. In that case it should not bubble. We determine whether it was\n                        // cloned by comparing the child pointer.\n                        // $FlowFixMe[unsafe-addition] addition with possible null/undefined value\n                        actualDuration += child.actualDuration; // $FlowFixMe[unsafe-addition] addition with possible null/undefined value\n                        treeBaseDuration += child.treeBaseDuration;\n                        child = child.sibling;\n                    }\n                    completedWork.actualDuration = actualDuration;\n                    completedWork.treeBaseDuration = treeBaseDuration;\n                } else {\n                    var _child = completedWork.child;\n                    while(_child !== null){\n                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));\n                        subtreeFlags |= _child.subtreeFlags;\n                        subtreeFlags |= _child.flags; // Update the return pointer so the tree is consistent. This is a code\n                        // smell because it assumes the commit phase is never concurrent with\n                        // the render phase. Will address during refactor to alternate model.\n                        _child.return = completedWork;\n                        _child = _child.sibling;\n                    }\n                }\n                completedWork.subtreeFlags |= subtreeFlags;\n            } else {\n                // Bubble up the earliest expiration time.\n                if ((completedWork.mode & ProfileMode) !== NoMode) {\n                    // In profiling mode, resetChildExpirationTime is also used to reset\n                    // profiler durations.\n                    var _treeBaseDuration = completedWork.selfBaseDuration;\n                    var _child2 = completedWork.child;\n                    while(_child2 !== null){\n                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes)); // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n                        // so we should bubble those up even during a bailout. All the other\n                        // flags have a lifetime only of a single render + commit, so we should\n                        // ignore them.\n                        subtreeFlags |= _child2.subtreeFlags & StaticMask;\n                        subtreeFlags |= _child2.flags & StaticMask; // $FlowFixMe[unsafe-addition] addition with possible null/undefined value\n                        _treeBaseDuration += _child2.treeBaseDuration;\n                        _child2 = _child2.sibling;\n                    }\n                    completedWork.treeBaseDuration = _treeBaseDuration;\n                } else {\n                    var _child3 = completedWork.child;\n                    while(_child3 !== null){\n                        newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes)); // \"Static\" flags share the lifetime of the fiber/hook they belong to,\n                        // so we should bubble those up even during a bailout. All the other\n                        // flags have a lifetime only of a single render + commit, so we should\n                        // ignore them.\n                        subtreeFlags |= _child3.subtreeFlags & StaticMask;\n                        subtreeFlags |= _child3.flags & StaticMask; // Update the return pointer so the tree is consistent. This is a code\n                        // smell because it assumes the commit phase is never concurrent with\n                        // the render phase. Will address during refactor to alternate model.\n                        _child3.return = completedWork;\n                        _child3 = _child3.sibling;\n                    }\n                }\n                completedWork.subtreeFlags |= subtreeFlags;\n            }\n            completedWork.childLanes = newChildLanes;\n            return didBailout;\n        }\n        function completeDehydratedSuspenseBoundary(current, workInProgress, nextState) {\n            var wasHydrated = popHydrationState(workInProgress);\n            if (nextState !== null && nextState.dehydrated !== null) {\n                // We might be inside a hydration state the first time we're picking up this\n                // Suspense boundary, and also after we've reentered it for further hydration.\n                if (current === null) {\n                    if (!wasHydrated) {\n                        throw new Error('A dehydrated suspense component was completed without a hydrated node. ' + 'This is probably a bug in React.');\n                    }\n                    prepareToHydrateHostSuspenseInstance(workInProgress);\n                    bubbleProperties(workInProgress);\n                    {\n                        if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                            var isTimedOutSuspense = nextState !== null;\n                            if (isTimedOutSuspense) {\n                                // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                                var primaryChildFragment = workInProgress.child;\n                                if (primaryChildFragment !== null) {\n                                    // $FlowFixMe[unsafe-arithmetic] Flow doesn't support type casting in combination with the -= operator\n                                    workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n                                }\n                            }\n                        }\n                    }\n                    return false;\n                } else {\n                    emitPendingHydrationWarnings(); // We might have reentered this boundary to hydrate it. If so, we need to reset the hydration\n                    // state since we're now exiting out of it. popHydrationState doesn't do that for us.\n                    resetHydrationState();\n                    if ((workInProgress.flags & DidCapture) === NoFlags$1) {\n                        // This boundary did not suspend so it's now hydrated and unsuspended.\n                        workInProgress.memoizedState = null;\n                    } // If nothing suspended, we need to schedule an effect to mark this boundary\n                    // as having hydrated so events know that they're free to be invoked.\n                    // It's also a signal to replay events and the suspense callback.\n                    // If something suspended, schedule an effect to attach retry listeners.\n                    // So we might as well always mark this.\n                    workInProgress.flags |= Update;\n                    bubbleProperties(workInProgress);\n                    {\n                        if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                            var _isTimedOutSuspense = nextState !== null;\n                            if (_isTimedOutSuspense) {\n                                // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                                var _primaryChildFragment = workInProgress.child;\n                                if (_primaryChildFragment !== null) {\n                                    // $FlowFixMe[unsafe-arithmetic] Flow doesn't support type casting in combination with the -= operator\n                                    workInProgress.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;\n                                }\n                            }\n                        }\n                    }\n                    return false;\n                }\n            } else {\n                // Successfully completed this tree. If this was a forced client render,\n                // there may have been recoverable errors during first hydration\n                // attempt. If so, add them to a queue so we can log them in the\n                // commit phase.\n                upgradeHydrationErrorsToRecoverable(); // Fall through to normal Suspense path\n                return true;\n            }\n        }\n        function completeWork(current, workInProgress, renderLanes) {\n            var newProps = workInProgress.pendingProps; // Note: This intentionally doesn't check if we're hydrating because comparing\n            // to the current tree provider fiber is just as fast and less error-prone.\n            // Ideally we would have a special version of the work loop only\n            // for hydration.\n            popTreeContext(workInProgress);\n            switch(workInProgress.tag){\n                case IncompleteFunctionComponent:\n                    {\n                        {\n                            break;\n                        }\n                    }\n                case LazyComponent:\n                case SimpleMemoComponent:\n                case FunctionComponent:\n                case ForwardRef:\n                case Fragment:\n                case Mode:\n                case Profiler:\n                case ContextConsumer:\n                case MemoComponent:\n                    bubbleProperties(workInProgress);\n                    return null;\n                case ClassComponent:\n                    {\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case HostRoot:\n                    {\n                        var fiberRoot = workInProgress.stateNode;\n                        {\n                            var previousCache = null;\n                            if (current !== null) {\n                                previousCache = current.memoizedState.cache;\n                            }\n                            var cache = workInProgress.memoizedState.cache;\n                            if (cache !== previousCache) {\n                                // Run passive effects to retain/release the cache.\n                                workInProgress.flags |= Passive$1;\n                            }\n                            popCacheProvider(workInProgress);\n                        }\n                        popHostContainer(workInProgress);\n                        if (fiberRoot.pendingContext) {\n                            fiberRoot.context = fiberRoot.pendingContext;\n                            fiberRoot.pendingContext = null;\n                        }\n                        if (current === null || current.child === null) {\n                            // If we hydrated, pop so that we can delete any remaining children\n                            // that weren't hydrated.\n                            var wasHydrated = popHydrationState(workInProgress);\n                            if (wasHydrated) {\n                                emitPendingHydrationWarnings(); // If we hydrated, then we'll need to schedule an update for\n                                // the commit side-effects on the root.\n                                markUpdate(workInProgress);\n                            } else {\n                                if (current !== null) {\n                                    var prevState = current.memoizedState;\n                                    if (!prevState.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)\n                                    (workInProgress.flags & ForceClientRender) !== NoFlags$1) {\n                                        // Schedule an effect to clear this container at the start of the\n                                        // next commit. This handles the case of React rendering into a\n                                        // container with previous children. It's also safe to do for\n                                        // updates too, because current.child would only be null if the\n                                        // previous render was null (so the container would already\n                                        // be empty).\n                                        workInProgress.flags |= Snapshot; // If this was a forced client render, there may have been\n                                        // recoverable errors during first hydration attempt. If so, add\n                                        // them to a queue so we can log them in the commit phase.\n                                        upgradeHydrationErrorsToRecoverable();\n                                    }\n                                }\n                            }\n                        }\n                        updateHostContainer(current, workInProgress);\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case HostHoistable:\n                    {\n                        if (supportsResources) {\n                            // The branching here is more complicated than you might expect because\n                            // a HostHoistable sometimes corresponds to a Resource and sometimes\n                            // corresponds to an Instance. It can also switch during an update.\n                            var type = workInProgress.type;\n                            var nextResource = workInProgress.memoizedState;\n                            if (current === null) {\n                                // We are mounting and must Update this Hoistable in this commit\n                                // @TODO refactor this block to create the instance here in complete\n                                // phase if we are not hydrating.\n                                markUpdate(workInProgress);\n                                if (nextResource !== null) {\n                                    // This is a Hoistable Resource\n                                    // This must come at the very end of the complete phase.\n                                    bubbleProperties(workInProgress);\n                                    preloadResourceAndSuspendIfNeeded(workInProgress, nextResource);\n                                    return null;\n                                } else {\n                                    // This is a Hoistable Instance\n                                    // This must come at the very end of the complete phase.\n                                    bubbleProperties(workInProgress);\n                                    preloadInstanceAndSuspendIfNeeded(workInProgress, type, newProps);\n                                    return null;\n                                }\n                            } else {\n                                // We are updating.\n                                var currentResource = current.memoizedState;\n                                if (nextResource !== currentResource) {\n                                    // We are transitioning to, from, or between Hoistable Resources\n                                    // and require an update\n                                    markUpdate(workInProgress);\n                                }\n                                if (nextResource !== null) {\n                                    // This is a Hoistable Resource\n                                    // This must come at the very end of the complete phase.\n                                    bubbleProperties(workInProgress);\n                                    if (nextResource === currentResource) {\n                                        workInProgress.flags &= ~MaySuspendCommit;\n                                    } else {\n                                        preloadResourceAndSuspendIfNeeded(workInProgress, nextResource);\n                                    }\n                                    return null;\n                                } else {\n                                    // This is a Hoistable Instance\n                                    // We may have props to update on the Hoistable instance.\n                                    if (supportsMutation) {\n                                        var oldProps = current.memoizedProps;\n                                        if (oldProps !== newProps) {\n                                            markUpdate(workInProgress);\n                                        }\n                                    } else {\n                                        // We use the updateHostComponent path becuase it produces\n                                        // the update queue we need for Hoistables.\n                                        updateHostComponent(current, workInProgress, type, newProps);\n                                    } // This must come at the very end of the complete phase.\n                                    bubbleProperties(workInProgress);\n                                    preloadInstanceAndSuspendIfNeeded(workInProgress, type, newProps);\n                                    return null;\n                                }\n                            }\n                        } // Fall through\n                    }\n                case HostSingleton:\n                    {\n                        if (supportsSingletons) {\n                            popHostContext(workInProgress);\n                            var rootContainerInstance = getRootHostContainer();\n                            var _type = workInProgress.type;\n                            if (current !== null && workInProgress.stateNode != null) {\n                                if (supportsMutation) {\n                                    var _oldProps2 = current.memoizedProps;\n                                    if (_oldProps2 !== newProps) {\n                                        markUpdate(workInProgress);\n                                    }\n                                } else {\n                                    updateHostComponent(current, workInProgress, _type, newProps);\n                                }\n                            } else {\n                                if (!newProps) {\n                                    if (workInProgress.stateNode === null) {\n                                        throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n                                    } // This can happen when we abort work.\n                                    bubbleProperties(workInProgress);\n                                    return null;\n                                }\n                                var currentHostContext = getHostContext();\n                                var _wasHydrated = popHydrationState(workInProgress);\n                                var instance;\n                                if (_wasHydrated) {\n                                    // We ignore the boolean indicating there is an updateQueue because\n                                    // it is used only to set text children and HostSingletons do not\n                                    // use them.\n                                    prepareToHydrateHostInstance(workInProgress, currentHostContext);\n                                    instance = workInProgress.stateNode;\n                                } else {\n                                    instance = resolveSingletonInstance(_type, newProps, rootContainerInstance, currentHostContext, true);\n                                    workInProgress.stateNode = instance;\n                                    markUpdate(workInProgress);\n                                }\n                            }\n                            bubbleProperties(workInProgress);\n                            return null;\n                        } // Fall through\n                    }\n                case HostComponent:\n                    {\n                        popHostContext(workInProgress);\n                        var _type2 = workInProgress.type;\n                        if (current !== null && workInProgress.stateNode != null) {\n                            updateHostComponent(current, workInProgress, _type2, newProps);\n                        } else {\n                            if (!newProps) {\n                                if (workInProgress.stateNode === null) {\n                                    throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n                                } // This can happen when we abort work.\n                                bubbleProperties(workInProgress);\n                                return null;\n                            }\n                            var _currentHostContext = getHostContext(); // TODO: Move createInstance to beginWork and keep it on a context\n                            // \"stack\" as the parent. Then append children as we go in beginWork\n                            // or completeWork depending on whether we want to add them top->down or\n                            // bottom->up. Top->down is faster in IE11.\n                            var _wasHydrated2 = popHydrationState(workInProgress);\n                            if (_wasHydrated2) {\n                                // TODO: Move this and createInstance step into the beginPhase\n                                // to consolidate.\n                                prepareToHydrateHostInstance(workInProgress, _currentHostContext);\n                            } else {\n                                var _rootContainerInstance = getRootHostContainer();\n                                var _instance3 = createInstance(_type2, newProps, _rootContainerInstance, _currentHostContext, workInProgress); // TODO: For persistent renderers, we should pass children as part\n                                // of the initial instance creation\n                                appendAllChildren(_instance3, workInProgress, false, false);\n                                workInProgress.stateNode = _instance3; // Certain renderers require commit-time effects for initial mount.\n                                // (eg DOM renderer supports auto-focus for certain elements).\n                                // Make sure such renderers get scheduled for later work.\n                                if (finalizeInitialChildren(_instance3, _type2, newProps, _currentHostContext)) {\n                                    markUpdate(workInProgress);\n                                }\n                            }\n                        }\n                        bubbleProperties(workInProgress); // This must come at the very end of the complete phase, because it might\n                        // throw to suspend, and if the resource immediately loads, the work loop\n                        // will resume rendering as if the work-in-progress completed. So it must\n                        // fully complete.\n                        preloadInstanceAndSuspendIfNeeded(workInProgress, workInProgress.type, workInProgress.pendingProps);\n                        return null;\n                    }\n                case HostText:\n                    {\n                        var newText = newProps;\n                        if (current && workInProgress.stateNode != null) {\n                            var oldText = current.memoizedProps; // If we have an alternate, that means this is an update and we need\n                            // to schedule a side-effect to do the updates.\n                            updateHostText(current, workInProgress, oldText, newText);\n                        } else {\n                            if (typeof newText !== 'string') {\n                                if (workInProgress.stateNode === null) {\n                                    throw new Error('We must have new props for new mounts. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n                                } // This can happen when we abort work.\n                            }\n                            var _rootContainerInstance2 = getRootHostContainer();\n                            var _currentHostContext2 = getHostContext();\n                            var _wasHydrated3 = popHydrationState(workInProgress);\n                            if (_wasHydrated3) {\n                                prepareToHydrateHostTextInstance(workInProgress);\n                            } else {\n                                workInProgress.stateNode = createTextInstance(newText, _rootContainerInstance2, _currentHostContext2, workInProgress);\n                            }\n                        }\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case SuspenseComponent:\n                    {\n                        var nextState = workInProgress.memoizedState; // Special path for dehydrated boundaries. We may eventually move this\n                        // to its own fiber type so that we can add other kinds of hydration\n                        // boundaries that aren't associated with a Suspense tree. In anticipation\n                        // of such a refactor, all the hydration logic is contained in\n                        // this branch.\n                        if (current === null || current.memoizedState !== null && current.memoizedState.dehydrated !== null) {\n                            var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current, workInProgress, nextState);\n                            if (!fallthroughToNormalSuspensePath) {\n                                if (workInProgress.flags & ForceClientRender) {\n                                    popSuspenseHandler(workInProgress); // Special case. There were remaining unhydrated nodes. We treat\n                                    // this as a mismatch. Revert to client rendering.\n                                    return workInProgress;\n                                } else {\n                                    popSuspenseHandler(workInProgress); // Did not finish hydrating, either because this is the initial\n                                    // render or because something suspended.\n                                    return null;\n                                }\n                            } // Continue with the normal Suspense path.\n                        }\n                        popSuspenseHandler(workInProgress);\n                        if ((workInProgress.flags & DidCapture) !== NoFlags$1) {\n                            // Something suspended. Re-render with the fallback children.\n                            workInProgress.lanes = renderLanes; // Do not reset the effect list.\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                transferActualDuration(workInProgress);\n                            } // Don't bubble properties in this case.\n                            return workInProgress;\n                        }\n                        var nextDidTimeout = nextState !== null;\n                        var prevDidTimeout = current !== null && current.memoizedState !== null;\n                        if (nextDidTimeout) {\n                            var offscreenFiber = workInProgress.child;\n                            var _previousCache = null;\n                            if (offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null && offscreenFiber.alternate.memoizedState.cachePool !== null) {\n                                _previousCache = offscreenFiber.alternate.memoizedState.cachePool.pool;\n                            }\n                            var _cache = null;\n                            if (offscreenFiber.memoizedState !== null && offscreenFiber.memoizedState.cachePool !== null) {\n                                _cache = offscreenFiber.memoizedState.cachePool.pool;\n                            }\n                            if (_cache !== _previousCache) {\n                                // Run passive effects to retain/release the cache.\n                                offscreenFiber.flags |= Passive$1;\n                            }\n                        } // If the suspended state of the boundary changes, we need to schedule\n                        // a passive effect, which is when we process the transitions\n                        if (nextDidTimeout !== prevDidTimeout) {\n                            // an effect to toggle the subtree's visibility. When we switch from\n                            // fallback -> primary, the inner Offscreen fiber schedules this effect\n                            // as part of its normal complete phase. But when we switch from\n                            // primary -> fallback, the inner Offscreen fiber does not have a complete\n                            // phase. So we need to schedule its effect here.\n                            //\n                            // We also use this flag to connect/disconnect the effects, but the same\n                            // logic applies: when re-connecting, the Offscreen fiber's complete\n                            // phase will handle scheduling the effect. It's only when the fallback\n                            // is active that we have to do anything special.\n                            if (nextDidTimeout) {\n                                var _offscreenFiber2 = workInProgress.child;\n                                _offscreenFiber2.flags |= Visibility;\n                            }\n                        }\n                        var retryQueue = workInProgress.updateQueue;\n                        scheduleRetryEffect(workInProgress, retryQueue);\n                        bubbleProperties(workInProgress);\n                        {\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                if (nextDidTimeout) {\n                                    // Don't count time spent in a timed out Suspense subtree as part of the base duration.\n                                    var primaryChildFragment = workInProgress.child;\n                                    if (primaryChildFragment !== null) {\n                                        // $FlowFixMe[unsafe-arithmetic] Flow doesn't support type casting in combination with the -= operator\n                                        workInProgress.treeBaseDuration -= primaryChildFragment.treeBaseDuration;\n                                    }\n                                }\n                            }\n                        }\n                        return null;\n                    }\n                case HostPortal:\n                    popHostContainer(workInProgress);\n                    updateHostContainer(current, workInProgress);\n                    if (current === null) {\n                        preparePortalMount(workInProgress.stateNode.containerInfo);\n                    }\n                    bubbleProperties(workInProgress);\n                    return null;\n                case ContextProvider:\n                    // Pop provider fiber\n                    var context;\n                    {\n                        context = workInProgress.type;\n                    }\n                    popProvider(context, workInProgress);\n                    bubbleProperties(workInProgress);\n                    return null;\n                case IncompleteClassComponent:\n                    {\n                        {\n                            break;\n                        }\n                    }\n                case SuspenseListComponent:\n                    {\n                        popSuspenseListContext(workInProgress);\n                        var renderState = workInProgress.memoizedState;\n                        if (renderState === null) {\n                            // We're running in the default, \"independent\" mode.\n                            // We don't do anything in this mode.\n                            bubbleProperties(workInProgress);\n                            return null;\n                        }\n                        var didSuspendAlready = (workInProgress.flags & DidCapture) !== NoFlags$1;\n                        var renderedTail = renderState.rendering;\n                        if (renderedTail === null) {\n                            // We just rendered the head.\n                            if (!didSuspendAlready) {\n                                // This is the first pass. We need to figure out if anything is still\n                                // suspended in the rendered set.\n                                // If new content unsuspended, but there's still some content that\n                                // didn't. Then we need to do a second pass that forces everything\n                                // to keep showing their fallbacks.\n                                // We might be suspended if something in this render pass suspended, or\n                                // something in the previous committed pass suspended. Otherwise,\n                                // there's no chance so we can skip the expensive call to\n                                // findFirstSuspended.\n                                var cannotBeSuspended = renderHasNotSuspendedYet() && (current === null || (current.flags & DidCapture) === NoFlags$1);\n                                if (!cannotBeSuspended) {\n                                    var row = workInProgress.child;\n                                    while(row !== null){\n                                        var suspended = findFirstSuspended(row);\n                                        if (suspended !== null) {\n                                            didSuspendAlready = true;\n                                            workInProgress.flags |= DidCapture;\n                                            cutOffTailIfNeeded(renderState, false); // If this is a newly suspended tree, it might not get committed as\n                                            // part of the second pass. In that case nothing will subscribe to\n                                            // its thenables. Instead, we'll transfer its thenables to the\n                                            // SuspenseList so that it can retry if they resolve.\n                                            // There might be multiple of these in the list but since we're\n                                            // going to wait for all of them anyway, it doesn't really matter\n                                            // which ones gets to ping. In theory we could get clever and keep\n                                            // track of how many dependencies remain but it gets tricky because\n                                            // in the meantime, we can add/remove/change items and dependencies.\n                                            // We might bail out of the loop before finding any but that\n                                            // doesn't matter since that means that the other boundaries that\n                                            // we did find already has their listeners attached.\n                                            var _retryQueue = suspended.updateQueue;\n                                            workInProgress.updateQueue = _retryQueue;\n                                            scheduleRetryEffect(workInProgress, _retryQueue); // Rerender the whole list, but this time, we'll force fallbacks\n                                            // to stay in place.\n                                            // Reset the effect flags before doing the second pass since that's now invalid.\n                                            // Reset the child fibers to their original state.\n                                            workInProgress.subtreeFlags = NoFlags$1;\n                                            resetChildFibers(workInProgress, renderLanes); // Set up the Suspense List Context to force suspense and\n                                            // immediately rerender the children.\n                                            pushSuspenseListContext(workInProgress, setShallowSuspenseListContext(suspenseStackCursor.current, ForceSuspenseFallback)); // Don't bubble properties in this case.\n                                            return workInProgress.child;\n                                        }\n                                        row = row.sibling;\n                                    }\n                                }\n                                if (renderState.tail !== null && now$1() > getRenderTargetTime()) {\n                                    // We have already passed our CPU deadline but we still have rows\n                                    // left in the tail. We'll just give up further attempts to render\n                                    // the main content and only render fallbacks.\n                                    workInProgress.flags |= DidCapture;\n                                    didSuspendAlready = true;\n                                    cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\n                                    // to get it started back up to attempt the next item. While in terms\n                                    // of priority this work has the same priority as this current render,\n                                    // it's not part of the same transition once the transition has\n                                    // committed. If it's sync, we still want to yield so that it can be\n                                    // painted. Conceptually, this is really the same as pinging.\n                                    // We can use any RetryLane even if it's the one currently rendering\n                                    // since we're leaving it behind on this node.\n                                    workInProgress.lanes = SomeRetryLane;\n                                }\n                            } else {\n                                cutOffTailIfNeeded(renderState, false);\n                            } // Next we're going to render the tail.\n                        } else {\n                            // Append the rendered row to the child list.\n                            if (!didSuspendAlready) {\n                                var _suspended = findFirstSuspended(renderedTail);\n                                if (_suspended !== null) {\n                                    workInProgress.flags |= DidCapture;\n                                    didSuspendAlready = true; // Ensure we transfer the update queue to the parent so that it doesn't\n                                    // get lost if this row ends up dropped during a second pass.\n                                    var _retryQueue2 = _suspended.updateQueue;\n                                    workInProgress.updateQueue = _retryQueue2;\n                                    scheduleRetryEffect(workInProgress, _retryQueue2);\n                                    cutOffTailIfNeeded(renderState, true); // This might have been modified.\n                                    if (renderState.tail === null && renderState.tailMode === 'hidden' && !renderedTail.alternate && !getIsHydrating() // We don't cut it if we're hydrating.\n                                    ) {\n                                        // We're done.\n                                        bubbleProperties(workInProgress);\n                                        return null;\n                                    }\n                                } else if (// time we have to render. So rendering one more row would likely\n                                // exceed it.\n                                now$1() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes !== OffscreenLane) {\n                                    // We have now passed our CPU deadline and we'll just give up further\n                                    // attempts to render the main content and only render fallbacks.\n                                    // The assumption is that this is usually faster.\n                                    workInProgress.flags |= DidCapture;\n                                    didSuspendAlready = true;\n                                    cutOffTailIfNeeded(renderState, false); // Since nothing actually suspended, there will nothing to ping this\n                                    // to get it started back up to attempt the next item. While in terms\n                                    // of priority this work has the same priority as this current render,\n                                    // it's not part of the same transition once the transition has\n                                    // committed. If it's sync, we still want to yield so that it can be\n                                    // painted. Conceptually, this is really the same as pinging.\n                                    // We can use any RetryLane even if it's the one currently rendering\n                                    // since we're leaving it behind on this node.\n                                    workInProgress.lanes = SomeRetryLane;\n                                }\n                            }\n                            if (renderState.isBackwards) {\n                                // The effect list of the backwards tail will have been added\n                                // to the end. This breaks the guarantee that life-cycles fire in\n                                // sibling order but that isn't a strong guarantee promised by React.\n                                // Especially since these might also just pop in during future commits.\n                                // Append to the beginning of the list.\n                                renderedTail.sibling = workInProgress.child;\n                                workInProgress.child = renderedTail;\n                            } else {\n                                var previousSibling = renderState.last;\n                                if (previousSibling !== null) {\n                                    previousSibling.sibling = renderedTail;\n                                } else {\n                                    workInProgress.child = renderedTail;\n                                }\n                                renderState.last = renderedTail;\n                            }\n                        }\n                        if (renderState.tail !== null) {\n                            // We still have tail rows to render.\n                            // Pop a row.\n                            var next = renderState.tail;\n                            renderState.rendering = next;\n                            renderState.tail = next.sibling;\n                            renderState.renderingStartTime = now$1();\n                            next.sibling = null; // Restore the context.\n                            // TODO: We can probably just avoid popping it instead and only\n                            // setting it the first time we go from not suspended to suspended.\n                            var suspenseContext = suspenseStackCursor.current;\n                            if (didSuspendAlready) {\n                                suspenseContext = setShallowSuspenseListContext(suspenseContext, ForceSuspenseFallback);\n                            } else {\n                                suspenseContext = setDefaultShallowSuspenseListContext(suspenseContext);\n                            }\n                            pushSuspenseListContext(workInProgress, suspenseContext); // Do a pass over the next row.\n                            // Don't bubble properties in this case.\n                            return next;\n                        }\n                        bubbleProperties(workInProgress);\n                        return null;\n                    }\n                case ScopeComponent:\n                    {\n                        break;\n                    }\n                case OffscreenComponent:\n                case LegacyHiddenComponent:\n                    {\n                        popSuspenseHandler(workInProgress);\n                        popHiddenContext(workInProgress);\n                        var _nextState = workInProgress.memoizedState;\n                        var nextIsHidden = _nextState !== null; // Schedule a Visibility effect if the visibility has changed\n                        {\n                            if (current !== null) {\n                                var _prevState = current.memoizedState;\n                                var prevIsHidden = _prevState !== null;\n                                if (prevIsHidden !== nextIsHidden) {\n                                    workInProgress.flags |= Visibility;\n                                }\n                            } else {\n                                // On initial mount, we only need a Visibility effect if the tree\n                                // is hidden.\n                                if (nextIsHidden) {\n                                    workInProgress.flags |= Visibility;\n                                }\n                            }\n                        }\n                        if (!nextIsHidden || !disableLegacyMode) {\n                            bubbleProperties(workInProgress);\n                        } else {\n                            // Don't bubble properties for hidden children unless we're rendering\n                            // at offscreen priority.\n                            if (includesSomeLane(renderLanes, OffscreenLane) && // Also don't bubble if the tree suspended\n                            (workInProgress.flags & DidCapture) === NoLanes) {\n                                bubbleProperties(workInProgress); // Check if there was an insertion or update in the hidden subtree.\n                                // If so, we need to hide those nodes in the commit phase, so\n                                // schedule a visibility effect.\n                                if (workInProgress.subtreeFlags & (Placement | Update)) {\n                                    workInProgress.flags |= Visibility;\n                                }\n                            }\n                        }\n                        var offscreenQueue = workInProgress.updateQueue;\n                        if (offscreenQueue !== null) {\n                            var _retryQueue3 = offscreenQueue.retryQueue;\n                            scheduleRetryEffect(workInProgress, _retryQueue3);\n                        }\n                        {\n                            var _previousCache2 = null;\n                            if (current !== null && current.memoizedState !== null && current.memoizedState.cachePool !== null) {\n                                _previousCache2 = current.memoizedState.cachePool.pool;\n                            }\n                            var _cache2 = null;\n                            if (workInProgress.memoizedState !== null && workInProgress.memoizedState.cachePool !== null) {\n                                _cache2 = workInProgress.memoizedState.cachePool.pool;\n                            }\n                            if (_cache2 !== _previousCache2) {\n                                // Run passive effects to retain/release the cache.\n                                workInProgress.flags |= Passive$1;\n                            }\n                        }\n                        popTransition(workInProgress, current);\n                        return null;\n                    }\n                case CacheComponent:\n                    {\n                        {\n                            var _previousCache3 = null;\n                            if (current !== null) {\n                                _previousCache3 = current.memoizedState.cache;\n                            }\n                            var _cache3 = workInProgress.memoizedState.cache;\n                            if (_cache3 !== _previousCache3) {\n                                // Run passive effects to retain/release the cache.\n                                workInProgress.flags |= Passive$1;\n                            }\n                            popCacheProvider(workInProgress);\n                            bubbleProperties(workInProgress);\n                        }\n                        return null;\n                    }\n                case TracingMarkerComponent:\n                    {\n                        return null;\n                    }\n            }\n            throw new Error(\"Unknown unit of work tag (\" + workInProgress.tag + \"). This error is likely caused by a bug in \" + 'React. Please file an issue.');\n        }\n        function unwindWork(current, workInProgress, renderLanes) {\n            // Note: This intentionally doesn't check if we're hydrating because comparing\n            // to the current tree provider fiber is just as fast and less error-prone.\n            // Ideally we would have a special version of the work loop only\n            // for hydration.\n            popTreeContext(workInProgress);\n            switch(workInProgress.tag){\n                case ClassComponent:\n                    {\n                        var flags = workInProgress.flags;\n                        if (flags & ShouldCapture) {\n                            workInProgress.flags = flags & ~ShouldCapture | DidCapture;\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                transferActualDuration(workInProgress);\n                            }\n                            return workInProgress;\n                        }\n                        return null;\n                    }\n                case HostRoot:\n                    {\n                        {\n                            popCacheProvider(workInProgress);\n                        }\n                        popHostContainer(workInProgress);\n                        var _flags = workInProgress.flags;\n                        if ((_flags & ShouldCapture) !== NoFlags$1 && (_flags & DidCapture) === NoFlags$1) {\n                            // There was an error during render that wasn't captured by a suspense\n                            // boundary. Do a second pass on the root to unmount the children.\n                            workInProgress.flags = _flags & ~ShouldCapture | DidCapture;\n                            return workInProgress;\n                        } // We unwound to the root without completing it. Exit.\n                        return null;\n                    }\n                case HostHoistable:\n                case HostSingleton:\n                case HostComponent:\n                    {\n                        // TODO: popHydrationState\n                        popHostContext(workInProgress);\n                        return null;\n                    }\n                case SuspenseComponent:\n                    {\n                        popSuspenseHandler(workInProgress);\n                        var suspenseState = workInProgress.memoizedState;\n                        if (suspenseState !== null && suspenseState.dehydrated !== null) {\n                            if (workInProgress.alternate === null) {\n                                throw new Error('Threw in newly mounted dehydrated component. This is likely a bug in ' + 'React. Please file an issue.');\n                            }\n                            resetHydrationState();\n                        }\n                        var _flags2 = workInProgress.flags;\n                        if (_flags2 & ShouldCapture) {\n                            workInProgress.flags = _flags2 & ~ShouldCapture | DidCapture; // Captured a suspense effect. Re-render the boundary.\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                transferActualDuration(workInProgress);\n                            }\n                            return workInProgress;\n                        }\n                        return null;\n                    }\n                case SuspenseListComponent:\n                    {\n                        popSuspenseListContext(workInProgress); // SuspenseList doesn't actually catch anything. It should've been\n                        // caught by a nested boundary. If not, it should bubble through.\n                        return null;\n                    }\n                case HostPortal:\n                    popHostContainer(workInProgress);\n                    return null;\n                case ContextProvider:\n                    var context;\n                    {\n                        context = workInProgress.type;\n                    }\n                    popProvider(context, workInProgress);\n                    return null;\n                case OffscreenComponent:\n                case LegacyHiddenComponent:\n                    {\n                        popSuspenseHandler(workInProgress);\n                        popHiddenContext(workInProgress);\n                        popTransition(workInProgress, current);\n                        var _flags3 = workInProgress.flags;\n                        if (_flags3 & ShouldCapture) {\n                            workInProgress.flags = _flags3 & ~ShouldCapture | DidCapture; // Captured a suspense effect. Re-render the boundary.\n                            if ((workInProgress.mode & ProfileMode) !== NoMode) {\n                                transferActualDuration(workInProgress);\n                            }\n                            return workInProgress;\n                        }\n                        return null;\n                    }\n                case CacheComponent:\n                    {\n                        popCacheProvider(workInProgress);\n                    }\n                    return null;\n                case TracingMarkerComponent:\n                    return null;\n                default:\n                    return null;\n            }\n        }\n        function unwindInterruptedWork(current, interruptedWork, renderLanes) {\n            // Note: This intentionally doesn't check if we're hydrating because comparing\n            // to the current tree provider fiber is just as fast and less error-prone.\n            // Ideally we would have a special version of the work loop only\n            // for hydration.\n            popTreeContext(interruptedWork);\n            switch(interruptedWork.tag){\n                case ClassComponent:\n                    {\n                        break;\n                    }\n                case HostRoot:\n                    {\n                        {\n                            popCacheProvider(interruptedWork);\n                        }\n                        popHostContainer(interruptedWork);\n                        break;\n                    }\n                case HostHoistable:\n                case HostSingleton:\n                case HostComponent:\n                    {\n                        popHostContext(interruptedWork);\n                        break;\n                    }\n                case HostPortal:\n                    popHostContainer(interruptedWork);\n                    break;\n                case SuspenseComponent:\n                    popSuspenseHandler(interruptedWork);\n                    break;\n                case SuspenseListComponent:\n                    popSuspenseListContext(interruptedWork);\n                    break;\n                case ContextProvider:\n                    var context;\n                    {\n                        context = interruptedWork.type;\n                    }\n                    popProvider(context, interruptedWork);\n                    break;\n                case OffscreenComponent:\n                case LegacyHiddenComponent:\n                    popSuspenseHandler(interruptedWork);\n                    popHiddenContext(interruptedWork);\n                    popTransition(interruptedWork, current);\n                    break;\n                case CacheComponent:\n                    {\n                        popCacheProvider(interruptedWork);\n                    }\n                    break;\n            }\n        }\n        var didWarnAboutUndefinedSnapshotBeforeUpdate = null;\n        {\n            didWarnAboutUndefinedSnapshotBeforeUpdate = new Set();\n        }\n        // Allows us to avoid traversing the return path to find the nearest Offscreen ancestor.\n        var offscreenSubtreeIsHidden = false;\n        var offscreenSubtreeWasHidden = false; // Used to track if a form needs to be reset at the end of the mutation phase.\n        var needsFormReset = false;\n        var PossiblyWeakSet = typeof WeakSet === 'function' ? WeakSet : Set;\n        var nextEffect = null; // Used for Profiling builds to track updaters.\n        var inProgressLanes = null;\n        var inProgressRoot = null;\n        function shouldProfile(current) {\n            return (current.mode & ProfileMode) !== NoMode && (getExecutionContext() & CommitContext) !== NoContext;\n        }\n        function callComponentWillUnmountWithTimer(current, instance) {\n            instance.props = resolveClassComponentProps(current.type, current.memoizedProps);\n            instance.state = current.memoizedState;\n            if (shouldProfile(current)) {\n                try {\n                    startLayoutEffectTimer();\n                    instance.componentWillUnmount();\n                } finally{\n                    recordLayoutEffectDuration(current);\n                }\n            } else {\n                instance.componentWillUnmount();\n            }\n        } // Capture errors so they don't interrupt unmounting.\n        function safelyCallComponentWillUnmount(current, nearestMountedAncestor, instance) {\n            try {\n                callComponentWillUnmountWithTimer(current, instance);\n            } catch (error) {\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        } // Capture errors so they don't interrupt mounting.\n        function safelyAttachRef(current, nearestMountedAncestor) {\n            try {\n                commitAttachRef(current);\n            } catch (error) {\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n        function safelyDetachRef(current, nearestMountedAncestor) {\n            var ref = current.ref;\n            var refCleanup = current.refCleanup;\n            if (ref !== null) {\n                if (typeof refCleanup === 'function') {\n                    try {\n                        if (shouldProfile(current)) {\n                            try {\n                                startLayoutEffectTimer();\n                                refCleanup();\n                            } finally{\n                                recordLayoutEffectDuration(current);\n                            }\n                        } else {\n                            refCleanup();\n                        }\n                    } catch (error) {\n                        captureCommitPhaseError(current, nearestMountedAncestor, error);\n                    } finally{\n                        // `refCleanup` has been called. Nullify all references to it to prevent double invocation.\n                        current.refCleanup = null;\n                        var finishedWork = current.alternate;\n                        if (finishedWork != null) {\n                            finishedWork.refCleanup = null;\n                        }\n                    }\n                } else if (typeof ref === 'function') {\n                    try {\n                        if (shouldProfile(current)) {\n                            try {\n                                startLayoutEffectTimer();\n                                ref(null);\n                            } finally{\n                                recordLayoutEffectDuration(current);\n                            }\n                        } else {\n                            ref(null);\n                        }\n                    } catch (error) {\n                        captureCommitPhaseError(current, nearestMountedAncestor, error);\n                    }\n                } else {\n                    // $FlowFixMe[incompatible-use] unable to narrow type to RefObject\n                    ref.current = null;\n                }\n            }\n        }\n        function safelyCallDestroy(current, nearestMountedAncestor, destroy) {\n            try {\n                destroy();\n            } catch (error) {\n                captureCommitPhaseError(current, nearestMountedAncestor, error);\n            }\n        }\n        var shouldFireAfterActiveInstanceBlur = false;\n        function commitBeforeMutationEffects(root, firstChild) {\n            prepareForCommit(root.containerInfo);\n            nextEffect = firstChild;\n            commitBeforeMutationEffects_begin(); // We no longer need to track the active instance fiber\n            var shouldFire = shouldFireAfterActiveInstanceBlur;\n            shouldFireAfterActiveInstanceBlur = false;\n            return shouldFire;\n        }\n        function commitBeforeMutationEffects_begin() {\n            while(nextEffect !== null){\n                var fiber = nextEffect; // This phase is only used for beforeActiveInstanceBlur.\n                var child = fiber.child;\n                if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags$1 && child !== null) {\n                    child.return = fiber;\n                    nextEffect = child;\n                } else {\n                    commitBeforeMutationEffects_complete();\n                }\n            }\n        }\n        function commitBeforeMutationEffects_complete() {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                setCurrentDebugFiberInDEV(fiber);\n                try {\n                    commitBeforeMutationEffectsOnFiber(fiber);\n                } catch (error) {\n                    captureCommitPhaseError(fiber, fiber.return, error);\n                }\n                resetCurrentDebugFiberInDEV();\n                var sibling = fiber.sibling;\n                if (sibling !== null) {\n                    sibling.return = fiber.return;\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = fiber.return;\n            }\n        }\n        function commitBeforeMutationEffectsOnFiber(finishedWork) {\n            var current = finishedWork.alternate;\n            var flags = finishedWork.flags;\n            if ((flags & Snapshot) !== NoFlags$1) {\n                setCurrentDebugFiberInDEV(finishedWork);\n            }\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                    {\n                        break;\n                    }\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        break;\n                    }\n                case ClassComponent:\n                    {\n                        if ((flags & Snapshot) !== NoFlags$1) {\n                            if (current !== null) {\n                                var prevProps = current.memoizedProps;\n                                var prevState = current.memoizedState;\n                                var instance = finishedWork.stateNode; // We could update instance props and state here,\n                                // but instead we rely on them being set during last render.\n                                // TODO: revisit this when we implement resuming.\n                                {\n                                    if (!finishedWork.type.defaultProps && !('ref' in finishedWork.memoizedProps) && !didWarnAboutReassigningProps) {\n                                        if (instance.props !== finishedWork.memoizedProps) {\n                                            error('Expected %s props to match memoized props before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                                        }\n                                        if (instance.state !== finishedWork.memoizedState) {\n                                            error('Expected %s state to match memoized state before ' + 'getSnapshotBeforeUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                                        }\n                                    }\n                                }\n                                var snapshot = instance.getSnapshotBeforeUpdate(resolveClassComponentProps(finishedWork.type, prevProps), prevState);\n                                {\n                                    var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;\n                                    if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {\n                                        didWarnSet.add(finishedWork.type);\n                                        error('%s.getSnapshotBeforeUpdate(): A snapshot value (or null) ' + 'must be returned. You have returned undefined.', getComponentNameFromFiber(finishedWork));\n                                    }\n                                }\n                                instance.__reactInternalSnapshotBeforeUpdate = snapshot;\n                            }\n                        }\n                        break;\n                    }\n                case HostRoot:\n                    {\n                        if ((flags & Snapshot) !== NoFlags$1) {\n                            if (supportsMutation) {\n                                var root = finishedWork.stateNode;\n                                clearContainer(root.containerInfo);\n                            }\n                        }\n                        break;\n                    }\n                case HostComponent:\n                case HostHoistable:\n                case HostSingleton:\n                case HostText:\n                case HostPortal:\n                case IncompleteClassComponent:\n                    break;\n                default:\n                    {\n                        if ((flags & Snapshot) !== NoFlags$1) {\n                            throw new Error('This unit of work tag should not have side-effects. This error is ' + 'likely caused by a bug in React. Please file an issue.');\n                        }\n                    }\n            }\n            if ((flags & Snapshot) !== NoFlags$1) {\n                resetCurrentDebugFiberInDEV();\n            }\n        }\n        function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {\n            var updateQueue = finishedWork.updateQueue;\n            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n            if (lastEffect !== null) {\n                var firstEffect = lastEffect.next;\n                var effect = firstEffect;\n                do {\n                    if ((effect.tag & flags) === flags) {\n                        // Unmount\n                        var inst = effect.inst;\n                        var destroy = inst.destroy;\n                        if (destroy !== undefined) {\n                            inst.destroy = undefined;\n                            {\n                                if ((flags & Passive) !== NoFlags) {\n                                    markComponentPassiveEffectUnmountStarted(finishedWork);\n                                } else if ((flags & Layout) !== NoFlags) {\n                                    markComponentLayoutEffectUnmountStarted(finishedWork);\n                                }\n                            }\n                            {\n                                if ((flags & Insertion) !== NoFlags) {\n                                    setIsRunningInsertionEffect(true);\n                                }\n                            }\n                            safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);\n                            {\n                                if ((flags & Insertion) !== NoFlags) {\n                                    setIsRunningInsertionEffect(false);\n                                }\n                            }\n                            {\n                                if ((flags & Passive) !== NoFlags) {\n                                    markComponentPassiveEffectUnmountStopped();\n                                } else if ((flags & Layout) !== NoFlags) {\n                                    markComponentLayoutEffectUnmountStopped();\n                                }\n                            }\n                        }\n                    }\n                    effect = effect.next;\n                }while (effect !== firstEffect);\n            }\n        }\n        function commitHookEffectListMount(flags, finishedWork) {\n            var updateQueue = finishedWork.updateQueue;\n            var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;\n            if (lastEffect !== null) {\n                var firstEffect = lastEffect.next;\n                var effect = firstEffect;\n                do {\n                    if ((effect.tag & flags) === flags) {\n                        {\n                            if ((flags & Passive) !== NoFlags) {\n                                markComponentPassiveEffectMountStarted(finishedWork);\n                            } else if ((flags & Layout) !== NoFlags) {\n                                markComponentLayoutEffectMountStarted(finishedWork);\n                            }\n                        }\n                        var create = effect.create;\n                        {\n                            if ((flags & Insertion) !== NoFlags) {\n                                setIsRunningInsertionEffect(true);\n                            }\n                        }\n                        var inst = effect.inst;\n                        var destroy = create();\n                        inst.destroy = destroy;\n                        {\n                            if ((flags & Insertion) !== NoFlags) {\n                                setIsRunningInsertionEffect(false);\n                            }\n                        }\n                        {\n                            if ((flags & Passive) !== NoFlags) {\n                                markComponentPassiveEffectMountStopped();\n                            } else if ((flags & Layout) !== NoFlags) {\n                                markComponentLayoutEffectMountStopped();\n                            }\n                        }\n                        {\n                            if (destroy !== undefined && typeof destroy !== 'function') {\n                                var hookName = void 0;\n                                if ((effect.tag & Layout) !== NoFlags$1) {\n                                    hookName = 'useLayoutEffect';\n                                } else if ((effect.tag & Insertion) !== NoFlags$1) {\n                                    hookName = 'useInsertionEffect';\n                                } else {\n                                    hookName = 'useEffect';\n                                }\n                                var addendum = void 0;\n                                if (destroy === null) {\n                                    addendum = ' You returned null. If your effect does not require clean ' + 'up, return undefined (or nothing).';\n                                } else if (typeof destroy.then === 'function') {\n                                    addendum = '\\n\\nIt looks like you wrote ' + hookName + '(async () => ...) or returned a Promise. ' + 'Instead, write the async function inside your effect ' + 'and call it immediately:\\n\\n' + hookName + '(() => {\\n' + '  async function fetchData() {\\n' + '    // You can await here\\n' + '    const response = await MyAPI.getData(someId);\\n' + '    // ...\\n' + '  }\\n' + '  fetchData();\\n' + \"}, [someId]); // Or [] if effect doesn't need props or state\\n\\n\" + 'Learn more about data fetching with Hooks: https://react.dev/link/hooks-data-fetching';\n                                } else {\n                                    addendum = ' You returned: ' + destroy;\n                                }\n                                error('%s must not return anything besides a function, ' + 'which is used for clean-up.%s', hookName, addendum);\n                            }\n                        }\n                    }\n                    effect = effect.next;\n                }while (effect !== firstEffect);\n            }\n        }\n        function commitPassiveEffectDurations(finishedRoot, finishedWork) {\n            if (getExecutionContext() & CommitContext) {\n                // Only Profilers with work in their subtree will have an Update effect scheduled.\n                if ((finishedWork.flags & Update) !== NoFlags$1) {\n                    switch(finishedWork.tag){\n                        case Profiler:\n                            {\n                                var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;\n                                var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit; // This value will still reflect the previous commit phase.\n                                // It does not get reset until the start of the next commit phase.\n                                var commitTime = getCommitTime();\n                                var phase = finishedWork.alternate === null ? 'mount' : 'update';\n                                {\n                                    if (isCurrentUpdateNested()) {\n                                        phase = 'nested-update';\n                                    }\n                                }\n                                if (typeof onPostCommit === 'function') {\n                                    onPostCommit(id, phase, passiveEffectDuration, commitTime);\n                                } // Bubble times to the next nearest ancestor Profiler.\n                                // After we process that Profiler, we'll bubble further up.\n                                var parentFiber = finishedWork.return;\n                                outer: while(parentFiber !== null){\n                                    switch(parentFiber.tag){\n                                        case HostRoot:\n                                            var root = parentFiber.stateNode;\n                                            root.passiveEffectDuration += passiveEffectDuration;\n                                            break outer;\n                                        case Profiler:\n                                            var parentStateNode = parentFiber.stateNode;\n                                            parentStateNode.passiveEffectDuration += passiveEffectDuration;\n                                            break outer;\n                                    }\n                                    parentFiber = parentFiber.return;\n                                }\n                                break;\n                            }\n                    }\n                }\n            }\n        }\n        function commitHookLayoutEffects(finishedWork, hookFlags) {\n            // At this point layout effects have already been destroyed (during mutation phase).\n            // This is done to prevent sibling component effects from interfering with each other,\n            // e.g. a destroy function in one component should never override a ref set\n            // by a create function in another component during the same commit.\n            if (shouldProfile(finishedWork)) {\n                try {\n                    startLayoutEffectTimer();\n                    commitHookEffectListMount(hookFlags, finishedWork);\n                } catch (error) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n                recordLayoutEffectDuration(finishedWork);\n            } else {\n                try {\n                    commitHookEffectListMount(hookFlags, finishedWork);\n                } catch (error) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n            }\n        }\n        function commitClassLayoutLifecycles(finishedWork, current) {\n            var instance = finishedWork.stateNode;\n            if (current === null) {\n                // We could update instance props and state here,\n                // but instead we rely on them being set during last render.\n                // TODO: revisit this when we implement resuming.\n                {\n                    if (!finishedWork.type.defaultProps && !('ref' in finishedWork.memoizedProps) && !didWarnAboutReassigningProps) {\n                        if (instance.props !== finishedWork.memoizedProps) {\n                            error('Expected %s props to match memoized props before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                        }\n                        if (instance.state !== finishedWork.memoizedState) {\n                            error('Expected %s state to match memoized state before ' + 'componentDidMount. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                        }\n                    }\n                }\n                if (shouldProfile(finishedWork)) {\n                    try {\n                        startLayoutEffectTimer();\n                        instance.componentDidMount();\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                    recordLayoutEffectDuration(finishedWork);\n                } else {\n                    try {\n                        instance.componentDidMount();\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n            } else {\n                var prevProps = resolveClassComponentProps(finishedWork.type, current.memoizedProps);\n                var prevState = current.memoizedState; // We could update instance props and state here,\n                // but instead we rely on them being set during last render.\n                // TODO: revisit this when we implement resuming.\n                {\n                    if (!finishedWork.type.defaultProps && !('ref' in finishedWork.memoizedProps) && !didWarnAboutReassigningProps) {\n                        if (instance.props !== finishedWork.memoizedProps) {\n                            error('Expected %s props to match memoized props before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                        }\n                        if (instance.state !== finishedWork.memoizedState) {\n                            error('Expected %s state to match memoized state before ' + 'componentDidUpdate. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                        }\n                    }\n                }\n                if (shouldProfile(finishedWork)) {\n                    try {\n                        startLayoutEffectTimer();\n                        instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                    recordLayoutEffectDuration(finishedWork);\n                } else {\n                    try {\n                        instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);\n                    } catch (error) {\n                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                    }\n                }\n            }\n        }\n        function commitClassCallbacks(finishedWork) {\n            // TODO: I think this is now always non-null by the time it reaches the\n            // commit phase. Consider removing the type check.\n            var updateQueue = finishedWork.updateQueue;\n            if (updateQueue !== null) {\n                var instance = finishedWork.stateNode;\n                {\n                    if (!finishedWork.type.defaultProps && !('ref' in finishedWork.memoizedProps) && !didWarnAboutReassigningProps) {\n                        if (instance.props !== finishedWork.memoizedProps) {\n                            error('Expected %s props to match memoized props before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.props`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                        }\n                        if (instance.state !== finishedWork.memoizedState) {\n                            error('Expected %s state to match memoized state before ' + 'processing the update queue. ' + 'This might either be because of a bug in React, or because ' + 'a component reassigns its own `this.state`. ' + 'Please file an issue.', getComponentNameFromFiber(finishedWork) || 'instance');\n                        }\n                    }\n                }\n                // but instead we rely on them being set during last render.\n                // TODO: revisit this when we implement resuming.\n                try {\n                    commitCallbacks(updateQueue, instance);\n                } catch (error) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n            }\n        }\n        function commitHostComponentMount(finishedWork) {\n            var type = finishedWork.type;\n            var props = finishedWork.memoizedProps;\n            var instance = finishedWork.stateNode;\n            try {\n                commitMount(instance, type, props, finishedWork);\n            } catch (error) {\n                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n            }\n        }\n        function commitProfilerUpdate(finishedWork, current) {\n            if (getExecutionContext() & CommitContext) {\n                try {\n                    var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;\n                    var effectDuration = finishedWork.stateNode.effectDuration;\n                    var commitTime = getCommitTime();\n                    var phase = current === null ? 'mount' : 'update';\n                    if (enableProfilerNestedUpdatePhase) {\n                        if (isCurrentUpdateNested()) {\n                            phase = 'nested-update';\n                        }\n                    }\n                    if (typeof onRender === 'function') {\n                        onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime);\n                    }\n                    if (enableProfilerCommitHooks) {\n                        if (typeof onCommit === 'function') {\n                            onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime);\n                        } // Schedule a passive effect for this Profiler to call onPostCommit hooks.\n                        // This effect should be scheduled even if there is no onPostCommit callback for this Profiler,\n                        // because the effect is also where times bubble to parent Profilers.\n                        enqueuePendingPassiveProfilerEffect(finishedWork); // Propagate layout effect durations to the next nearest Profiler ancestor.\n                        // Do not reset these values until the next render so DevTools has a chance to read them first.\n                        var parentFiber = finishedWork.return;\n                        outer: while(parentFiber !== null){\n                            switch(parentFiber.tag){\n                                case HostRoot:\n                                    var root = parentFiber.stateNode;\n                                    root.effectDuration += effectDuration;\n                                    break outer;\n                                case Profiler:\n                                    var parentStateNode = parentFiber.stateNode;\n                                    parentStateNode.effectDuration += effectDuration;\n                                    break outer;\n                            }\n                            parentFiber = parentFiber.return;\n                        }\n                    }\n                } catch (error) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n            }\n        }\n        function commitLayoutEffectOnFiber(finishedRoot, current, finishedWork, committedLanes) {\n            // When updating this function, also update reappearLayoutEffects, which does\n            // most of the same things when an offscreen tree goes from hidden -> visible.\n            var flags = finishedWork.flags;\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                        if (flags & Update) {\n                            commitHookLayoutEffects(finishedWork, Layout | HasEffect);\n                        }\n                        break;\n                    }\n                case ClassComponent:\n                    {\n                        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                        if (flags & Update) {\n                            commitClassLayoutLifecycles(finishedWork, current);\n                        }\n                        if (flags & Callback) {\n                            commitClassCallbacks(finishedWork);\n                        }\n                        if (flags & Ref) {\n                            safelyAttachRef(finishedWork, finishedWork.return);\n                        }\n                        break;\n                    }\n                case HostRoot:\n                    {\n                        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                        if (flags & Callback) {\n                            // TODO: I think this is now always non-null by the time it reaches the\n                            // commit phase. Consider removing the type check.\n                            var updateQueue = finishedWork.updateQueue;\n                            if (updateQueue !== null) {\n                                var instance = null;\n                                if (finishedWork.child !== null) {\n                                    switch(finishedWork.child.tag){\n                                        case HostSingleton:\n                                        case HostComponent:\n                                            instance = getPublicInstance(finishedWork.child.stateNode);\n                                            break;\n                                        case ClassComponent:\n                                            instance = finishedWork.child.stateNode;\n                                            break;\n                                    }\n                                }\n                                try {\n                                    commitCallbacks(updateQueue, instance);\n                                } catch (error) {\n                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                }\n                            }\n                        }\n                        break;\n                    }\n                case HostHoistable:\n                    {\n                        if (supportsResources) {\n                            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                            if (flags & Ref) {\n                                safelyAttachRef(finishedWork, finishedWork.return);\n                            }\n                            break;\n                        } // Fall through\n                    }\n                case HostSingleton:\n                case HostComponent:\n                    {\n                        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork); // Renderers may schedule work to be done after host components are mounted\n                        // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n                        // These effects should only be committed when components are first mounted,\n                        // aka when there is no current/alternate.\n                        if (current === null && flags & Update) {\n                            commitHostComponentMount(finishedWork);\n                        }\n                        if (flags & Ref) {\n                            safelyAttachRef(finishedWork, finishedWork.return);\n                        }\n                        break;\n                    }\n                case Profiler:\n                    {\n                        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork); // TODO: Should this fire inside an offscreen tree? Or should it wait to\n                        // fire when the tree becomes visible again.\n                        if (flags & Update) {\n                            commitProfilerUpdate(finishedWork, current);\n                        }\n                        break;\n                    }\n                case SuspenseComponent:\n                    {\n                        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                        if (flags & Update) {\n                            commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n                        }\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        var isModernRoot = disableLegacyMode;\n                        if (isModernRoot) {\n                            var isHidden = finishedWork.memoizedState !== null;\n                            var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;\n                            if (newOffscreenSubtreeIsHidden) ;\n                            else {\n                                // The Offscreen tree is visible.\n                                var wasHidden = current !== null && current.memoizedState !== null;\n                                var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;\n                                var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;\n                                var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                                offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;\n                                offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;\n                                if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {\n                                    // This is the root of a reappearing boundary. As we continue\n                                    // traversing the layout effects, we must also re-mount layout\n                                    // effects that were unmounted when the Offscreen subtree was\n                                    // hidden. So this is a superset of the normal commitLayoutEffects.\n                                    var includeWorkInProgressEffects = (finishedWork.subtreeFlags & LayoutMask) !== NoFlags$1;\n                                    recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                                } else {\n                                    recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                                }\n                                offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n                                offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                            }\n                        } else {\n                            recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                        }\n                        if (flags & Ref) {\n                            var props = finishedWork.memoizedProps;\n                            if (props.mode === 'manual') {\n                                safelyAttachRef(finishedWork, finishedWork.return);\n                            } else {\n                                safelyDetachRef(finishedWork, finishedWork.return);\n                            }\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n                        break;\n                    }\n            }\n        }\n        function hideOrUnhideAllChildren(finishedWork, isHidden) {\n            // Only hide or unhide the top-most host nodes.\n            var hostSubtreeRoot = null;\n            if (supportsMutation) {\n                // We only have the top Fiber that was inserted but we need to recurse down its\n                // children to find all the terminal nodes.\n                var node = finishedWork;\n                while(true){\n                    if (node.tag === HostComponent || (supportsResources ? node.tag === HostHoistable : false) || (supportsSingletons ? node.tag === HostSingleton : false)) {\n                        if (hostSubtreeRoot === null) {\n                            hostSubtreeRoot = node;\n                            try {\n                                var instance = node.stateNode;\n                                if (isHidden) {\n                                    hideInstance(instance);\n                                } else {\n                                    unhideInstance(node.stateNode, node.memoizedProps);\n                                }\n                            } catch (error) {\n                                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                            }\n                        }\n                    } else if (node.tag === HostText) {\n                        if (hostSubtreeRoot === null) {\n                            try {\n                                var _instance = node.stateNode;\n                                if (isHidden) {\n                                    hideTextInstance(_instance);\n                                } else {\n                                    unhideTextInstance(_instance, node.memoizedProps);\n                                }\n                            } catch (error) {\n                                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                            }\n                        }\n                    } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork) ;\n                    else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                    if (node === finishedWork) {\n                        return;\n                    }\n                    while(node.sibling === null){\n                        if (node.return === null || node.return === finishedWork) {\n                            return;\n                        }\n                        if (hostSubtreeRoot === node) {\n                            hostSubtreeRoot = null;\n                        }\n                        node = node.return;\n                    }\n                    if (hostSubtreeRoot === node) {\n                        hostSubtreeRoot = null;\n                    }\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            }\n        }\n        function commitAttachRef(finishedWork) {\n            var ref = finishedWork.ref;\n            if (ref !== null) {\n                var instance = finishedWork.stateNode;\n                var instanceToUse;\n                switch(finishedWork.tag){\n                    case HostHoistable:\n                    case HostSingleton:\n                    case HostComponent:\n                        instanceToUse = getPublicInstance(instance);\n                        break;\n                    default:\n                        instanceToUse = instance;\n                } // Moved outside to ensure DCE works with this flag\n                if (typeof ref === 'function') {\n                    if (shouldProfile(finishedWork)) {\n                        try {\n                            startLayoutEffectTimer();\n                            finishedWork.refCleanup = ref(instanceToUse);\n                        } finally{\n                            recordLayoutEffectDuration(finishedWork);\n                        }\n                    } else {\n                        finishedWork.refCleanup = ref(instanceToUse);\n                    }\n                } else {\n                    {\n                        // TODO: We should move these warnings to happen during the render\n                        // phase (markRef).\n                        if (typeof ref === 'string') {\n                            error('String refs are no longer supported.');\n                        } else if (!ref.hasOwnProperty('current')) {\n                            error('Unexpected ref object provided for %s. ' + 'Use either a ref-setter function or React.createRef().', getComponentNameFromFiber(finishedWork));\n                        }\n                    }\n                    ref.current = instanceToUse;\n                }\n            }\n        }\n        function detachFiberMutation(fiber) {\n            // Cut off the return pointer to disconnect it from the tree.\n            // This enables us to detect and warn against state updates on an unmounted component.\n            // It also prevents events from bubbling from within disconnected components.\n            //\n            // Ideally, we should also clear the child pointer of the parent alternate to let this\n            // get GC:ed but we don't know which for sure which parent is the current\n            // one so we'll settle for GC:ing the subtree of this child.\n            // This child itself will be GC:ed when the parent updates the next time.\n            //\n            // Note that we can't clear child or sibling pointers yet.\n            // They're needed for passive effects and for findDOMNode.\n            // We defer those fields, and all other cleanup, to the passive phase (see detachFiberAfterEffects).\n            //\n            // Don't reset the alternate yet, either. We need that so we can detach the\n            // alternate's fields in the passive phase. Clearing the return pointer is\n            // sufficient for findDOMNode semantics.\n            var alternate = fiber.alternate;\n            if (alternate !== null) {\n                alternate.return = null;\n            }\n            fiber.return = null;\n        }\n        function detachFiberAfterEffects(fiber) {\n            var alternate = fiber.alternate;\n            if (alternate !== null) {\n                fiber.alternate = null;\n                detachFiberAfterEffects(alternate);\n            } // Clear cyclical Fiber fields. This level alone is designed to roughly\n            // approximate the planned Fiber refactor. In that world, `setState` will be\n            // bound to a special \"instance\" object instead of a Fiber. The Instance\n            // object will not have any of these fields. It will only be connected to\n            // the fiber tree via a single link at the root. So if this level alone is\n            // sufficient to fix memory issues, that bodes well for our plans.\n            fiber.child = null;\n            fiber.deletions = null;\n            fiber.sibling = null; // The `stateNode` is cyclical because on host nodes it points to the host\n            // tree, which has its own pointers to children, parents, and siblings.\n            // The other host nodes also point back to fibers, so we should detach that\n            // one, too.\n            if (fiber.tag === HostComponent) {\n                var hostInstance = fiber.stateNode;\n                if (hostInstance !== null) {\n                    detachDeletedInstance(hostInstance);\n                }\n            }\n            fiber.stateNode = null;\n            {\n                fiber._debugOwner = null;\n            }\n            // disconnected the fiber from the tree. So even if something leaks this\n            // particular fiber, it won't leak anything else.\n            fiber.return = null;\n            fiber.dependencies = null;\n            fiber.memoizedProps = null;\n            fiber.memoizedState = null;\n            fiber.pendingProps = null;\n            fiber.stateNode = null; // TODO: Move to `commitPassiveUnmountInsideDeletedTreeOnFiber` instead.\n            fiber.updateQueue = null;\n        }\n        function emptyPortalContainer(current) {\n            if (!supportsPersistence) {\n                return;\n            }\n            var portal = current.stateNode;\n            var containerInfo = portal.containerInfo;\n            var emptyChildSet = createContainerChildSet();\n            replaceContainerChildren(containerInfo, emptyChildSet);\n        }\n        function getHostParentFiber(fiber) {\n            var parent = fiber.return;\n            while(parent !== null){\n                if (isHostParent(parent)) {\n                    return parent;\n                }\n                parent = parent.return;\n            }\n            throw new Error('Expected to find a host parent. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n        }\n        function isHostParent(fiber) {\n            return fiber.tag === HostComponent || fiber.tag === HostRoot || (supportsResources ? fiber.tag === HostHoistable : false) || (supportsSingletons ? fiber.tag === HostSingleton : false) || fiber.tag === HostPortal;\n        }\n        function getHostSibling(fiber) {\n            // We're going to search forward into the tree until we find a sibling host\n            // node. Unfortunately, if multiple insertions are done in a row we have to\n            // search past them. This leads to exponential search for the next sibling.\n            // TODO: Find a more efficient way to do this.\n            var node = fiber;\n            siblings: while(true){\n                // If we didn't find anything, let's try the next sibling.\n                while(node.sibling === null){\n                    if (node.return === null || isHostParent(node.return)) {\n                        // If we pop out of the root or hit the parent the fiber we are the\n                        // last sibling.\n                        return null;\n                    } // $FlowFixMe[incompatible-type] found when upgrading Flow\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n                while(node.tag !== HostComponent && node.tag !== HostText && (!supportsSingletons ? true : node.tag !== HostSingleton) && node.tag !== DehydratedFragment){\n                    // If it is not host node and, we might have a host node inside it.\n                    // Try to search down until we find one.\n                    if (node.flags & Placement) {\n                        continue siblings;\n                    } // If we don't have a child, try the siblings instead.\n                    // We also skip portals because they are not part of this host tree.\n                    if (node.child === null || node.tag === HostPortal) {\n                        continue siblings;\n                    } else {\n                        node.child.return = node;\n                        node = node.child;\n                    }\n                } // Check if this host node is stable or about to be placed.\n                if (!(node.flags & Placement)) {\n                    // Found it!\n                    return node.stateNode;\n                }\n            }\n        }\n        function commitPlacement(finishedWork) {\n            if (!supportsMutation) {\n                return;\n            }\n            if (supportsSingletons) {\n                if (finishedWork.tag === HostSingleton) {\n                    // Singletons are already in the Host and don't need to be placed\n                    // Since they operate somewhat like Portals though their children will\n                    // have Placement and will get placed inside them\n                    return;\n                }\n            } // Recursively insert all host nodes into the parent.\n            var parentFiber = getHostParentFiber(finishedWork);\n            switch(parentFiber.tag){\n                case HostSingleton:\n                    {\n                        if (supportsSingletons) {\n                            var parent = parentFiber.stateNode;\n                            var before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its\n                            // children to find all the terminal nodes.\n                            insertOrAppendPlacementNode(finishedWork, before, parent);\n                            break;\n                        } // Fall through\n                    }\n                case HostComponent:\n                    {\n                        var _parent = parentFiber.stateNode;\n                        if (parentFiber.flags & ContentReset) {\n                            // Reset the text content of the parent before doing any insertions\n                            resetTextContent(_parent); // Clear ContentReset from the effect tag\n                            parentFiber.flags &= ~ContentReset;\n                        }\n                        var _before = getHostSibling(finishedWork); // We only have the top Fiber that was inserted but we need to recurse down its\n                        // children to find all the terminal nodes.\n                        insertOrAppendPlacementNode(finishedWork, _before, _parent);\n                        break;\n                    }\n                case HostRoot:\n                case HostPortal:\n                    {\n                        var _parent2 = parentFiber.stateNode.containerInfo;\n                        var _before2 = getHostSibling(finishedWork);\n                        insertOrAppendPlacementNodeIntoContainer(finishedWork, _before2, _parent2);\n                        break;\n                    }\n                default:\n                    throw new Error('Invalid host parent fiber. This error is likely caused by a bug ' + 'in React. Please file an issue.');\n            }\n        }\n        function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n            var tag = node.tag;\n            var isHost = tag === HostComponent || tag === HostText;\n            if (isHost) {\n                var stateNode = node.stateNode;\n                if (before) {\n                    insertInContainerBefore(parent, stateNode, before);\n                } else {\n                    appendChildToContainer(parent, stateNode);\n                }\n            } else if (tag === HostPortal || (supportsSingletons ? tag === HostSingleton : false)) ;\n            else {\n                var child = node.child;\n                if (child !== null) {\n                    insertOrAppendPlacementNodeIntoContainer(child, before, parent);\n                    var sibling = child.sibling;\n                    while(sibling !== null){\n                        insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);\n                        sibling = sibling.sibling;\n                    }\n                }\n            }\n        }\n        function insertOrAppendPlacementNode(node, before, parent) {\n            var tag = node.tag;\n            var isHost = tag === HostComponent || tag === HostText;\n            if (isHost) {\n                var stateNode = node.stateNode;\n                if (before) {\n                    insertBefore(parent, stateNode, before);\n                } else {\n                    appendChild(parent, stateNode);\n                }\n            } else if (tag === HostPortal || (supportsSingletons ? tag === HostSingleton : false)) ;\n            else {\n                var child = node.child;\n                if (child !== null) {\n                    insertOrAppendPlacementNode(child, before, parent);\n                    var sibling = child.sibling;\n                    while(sibling !== null){\n                        insertOrAppendPlacementNode(sibling, before, parent);\n                        sibling = sibling.sibling;\n                    }\n                }\n            }\n        } // These are tracked on the stack as we recursively traverse a\n        // deleted subtree.\n        // TODO: Update these during the whole mutation phase, not just during\n        // a deletion.\n        var hostParent = null;\n        var hostParentIsContainer = false;\n        function commitDeletionEffects(root, returnFiber, deletedFiber) {\n            if (supportsMutation) {\n                // We only have the top Fiber that was deleted but we need to recurse down its\n                // children to find all the terminal nodes.\n                // Recursively delete all host nodes from the parent, detach refs, clean\n                // up mounted layout effects, and call componentWillUnmount.\n                // We only need to remove the topmost host child in each branch. But then we\n                // still need to keep traversing to unmount effects, refs, and cWU. TODO: We\n                // could split this into two separate traversals functions, where the second\n                // one doesn't include any removeChild logic. This is maybe the same\n                // function as \"disappearLayoutEffects\" (or whatever that turns into after\n                // the layout phase is refactored to use recursion).\n                // Before starting, find the nearest host parent on the stack so we know\n                // which instance/container to remove the children from.\n                // TODO: Instead of searching up the fiber return path on every deletion, we\n                // can track the nearest host component on the JS stack as we traverse the\n                // tree during the commit phase. This would make insertions faster, too.\n                var parent = returnFiber;\n                findParent: while(parent !== null){\n                    switch(parent.tag){\n                        case HostSingleton:\n                        case HostComponent:\n                            {\n                                hostParent = parent.stateNode;\n                                hostParentIsContainer = false;\n                                break findParent;\n                            }\n                        case HostRoot:\n                            {\n                                hostParent = parent.stateNode.containerInfo;\n                                hostParentIsContainer = true;\n                                break findParent;\n                            }\n                        case HostPortal:\n                            {\n                                hostParent = parent.stateNode.containerInfo;\n                                hostParentIsContainer = true;\n                                break findParent;\n                            }\n                    }\n                    parent = parent.return;\n                }\n                if (hostParent === null) {\n                    throw new Error('Expected to find a host parent. This error is likely caused by ' + 'a bug in React. Please file an issue.');\n                }\n                commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n                hostParent = null;\n                hostParentIsContainer = false;\n            } else {\n                // Detach refs and call componentWillUnmount() on the whole subtree.\n                commitDeletionEffectsOnFiber(root, returnFiber, deletedFiber);\n            }\n            detachFiberMutation(deletedFiber);\n        }\n        function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {\n            // TODO: Use a static flag to skip trees that don't have unmount effects\n            var child = parent.child;\n            while(child !== null){\n                commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);\n                child = child.sibling;\n            }\n        }\n        function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {\n            onCommitUnmount(deletedFiber); // The cases in this outer switch modify the stack before they traverse\n            // into their subtree. There are simpler cases in the inner switch\n            // that don't modify the stack.\n            switch(deletedFiber.tag){\n                case HostHoistable:\n                    {\n                        if (supportsResources) {\n                            if (!offscreenSubtreeWasHidden) {\n                                safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                            }\n                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                            if (deletedFiber.memoizedState) {\n                                releaseResource(deletedFiber.memoizedState);\n                            } else if (deletedFiber.stateNode) {\n                                unmountHoistable(deletedFiber.stateNode);\n                            }\n                            return;\n                        } // Fall through\n                    }\n                case HostSingleton:\n                    {\n                        if (supportsSingletons) {\n                            if (!offscreenSubtreeWasHidden) {\n                                safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                            }\n                            var prevHostParent = hostParent;\n                            var prevHostParentIsContainer = hostParentIsContainer;\n                            hostParent = deletedFiber.stateNode;\n                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber); // Normally this is called in passive unmount effect phase however with\n                            // HostSingleton we warn if you acquire one that is already associated to\n                            // a different fiber. To increase our chances of avoiding this, specifically\n                            // if you keyed a HostSingleton so there will be a delete followed by a Placement\n                            // we treat detach eagerly here\n                            releaseSingletonInstance(deletedFiber.stateNode);\n                            hostParent = prevHostParent;\n                            hostParentIsContainer = prevHostParentIsContainer;\n                            return;\n                        } // Fall through\n                    }\n                case HostComponent:\n                    {\n                        if (!offscreenSubtreeWasHidden) {\n                            safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                        } // Intentional fallthrough to next branch\n                    }\n                case HostText:\n                    {\n                        // We only need to remove the nearest host child. Set the host parent\n                        // to `null` on the stack to indicate that nested children don't\n                        // need to be removed.\n                        if (supportsMutation) {\n                            var _prevHostParent = hostParent;\n                            var _prevHostParentIsContainer = hostParentIsContainer;\n                            hostParent = null;\n                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                            hostParent = _prevHostParent;\n                            hostParentIsContainer = _prevHostParentIsContainer;\n                            if (hostParent !== null) {\n                                // Now that all the child effects have unmounted, we can remove the\n                                // node from the tree.\n                                if (hostParentIsContainer) {\n                                    removeChildFromContainer(hostParent, deletedFiber.stateNode);\n                                } else {\n                                    removeChild(hostParent, deletedFiber.stateNode);\n                                }\n                            }\n                        } else {\n                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                        }\n                        return;\n                    }\n                case DehydratedFragment:\n                    {\n                        // Delete the dehydrated suspense boundary and all of its content.\n                        if (supportsMutation) {\n                            if (hostParent !== null) {\n                                if (hostParentIsContainer) {\n                                    clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);\n                                } else {\n                                    clearSuspenseBoundary(hostParent, deletedFiber.stateNode);\n                                }\n                            }\n                        }\n                        return;\n                    }\n                case HostPortal:\n                    {\n                        if (supportsMutation) {\n                            // When we go into a portal, it becomes the parent to remove from.\n                            var _prevHostParent2 = hostParent;\n                            var _prevHostParentIsContainer2 = hostParentIsContainer;\n                            hostParent = deletedFiber.stateNode.containerInfo;\n                            hostParentIsContainer = true;\n                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                            hostParent = _prevHostParent2;\n                            hostParentIsContainer = _prevHostParentIsContainer2;\n                        } else {\n                            emptyPortalContainer(deletedFiber);\n                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                        }\n                        return;\n                    }\n                case FunctionComponent:\n                case ForwardRef:\n                case MemoComponent:\n                case SimpleMemoComponent:\n                    {\n                        if (!offscreenSubtreeWasHidden) {\n                            var updateQueue = deletedFiber.updateQueue;\n                            if (updateQueue !== null) {\n                                var lastEffect = updateQueue.lastEffect;\n                                if (lastEffect !== null) {\n                                    var firstEffect = lastEffect.next;\n                                    var effect = firstEffect;\n                                    do {\n                                        var tag = effect.tag;\n                                        var inst = effect.inst;\n                                        var destroy = inst.destroy;\n                                        if (destroy !== undefined) {\n                                            if ((tag & Insertion) !== NoFlags) {\n                                                inst.destroy = undefined;\n                                                safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                                            } else if ((tag & Layout) !== NoFlags) {\n                                                {\n                                                    markComponentLayoutEffectUnmountStarted(deletedFiber);\n                                                }\n                                                if (shouldProfile(deletedFiber)) {\n                                                    startLayoutEffectTimer();\n                                                    inst.destroy = undefined;\n                                                    safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                                                    recordLayoutEffectDuration(deletedFiber);\n                                                } else {\n                                                    inst.destroy = undefined;\n                                                    safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);\n                                                }\n                                                {\n                                                    markComponentLayoutEffectUnmountStopped();\n                                                }\n                                            }\n                                        }\n                                        effect = effect.next;\n                                    }while (effect !== firstEffect);\n                                }\n                            }\n                        }\n                        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                        return;\n                    }\n                case ClassComponent:\n                    {\n                        if (!offscreenSubtreeWasHidden) {\n                            safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                            var instance = deletedFiber.stateNode;\n                            if (typeof instance.componentWillUnmount === 'function') {\n                                safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);\n                            }\n                        }\n                        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                        return;\n                    }\n                case ScopeComponent:\n                    {\n                        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                        return;\n                    }\n                case OffscreenComponent:\n                    {\n                        safelyDetachRef(deletedFiber, nearestMountedAncestor);\n                        {\n                            // If this offscreen component is hidden, we already unmounted it. Before\n                            // deleting the children, track that it's already unmounted so that we\n                            // don't attempt to unmount the effects again.\n                            // TODO: If the tree is hidden, in most cases we should be able to skip\n                            // over the nested children entirely. An exception is we haven't yet found\n                            // the topmost host node to delete, which we already track on the stack.\n                            // But the other case is portals, which need to be detached no matter how\n                            // deeply they are nested. We should use a subtree flag to track whether a\n                            // subtree includes a nested portal.\n                            var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;\n                            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);\n                        return;\n                    }\n            }\n        }\n        function commitSuspenseCallback(finishedWork) {}\n        function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n            if (!supportsHydration) {\n                return;\n            }\n            var newState = finishedWork.memoizedState;\n            if (newState === null) {\n                var current = finishedWork.alternate;\n                if (current !== null) {\n                    var prevState = current.memoizedState;\n                    if (prevState !== null) {\n                        var suspenseInstance = prevState.dehydrated;\n                        if (suspenseInstance !== null) {\n                            try {\n                                commitHydratedSuspenseInstance(suspenseInstance);\n                                var hydrationCallbacks, onHydrated;\n                                if (enableSuspenseCallback) ;\n                            } catch (error) {\n                                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        function getRetryCache(finishedWork) {\n            // TODO: Unify the interface for the retry cache so we don't have to switch\n            // on the tag like this.\n            switch(finishedWork.tag){\n                case SuspenseComponent:\n                case SuspenseListComponent:\n                    {\n                        var retryCache = finishedWork.stateNode;\n                        if (retryCache === null) {\n                            retryCache = finishedWork.stateNode = new PossiblyWeakSet();\n                        }\n                        return retryCache;\n                    }\n                case OffscreenComponent:\n                    {\n                        var instance = finishedWork.stateNode;\n                        var _retryCache = instance._retryCache;\n                        if (_retryCache === null) {\n                            _retryCache = instance._retryCache = new PossiblyWeakSet();\n                        }\n                        return _retryCache;\n                    }\n                default:\n                    {\n                        throw new Error(\"Unexpected Suspense handler tag (\" + finishedWork.tag + \"). This is a \" + 'bug in React.');\n                    }\n            }\n        }\n        function detachOffscreenInstance(instance) {\n            var fiber = instance._current;\n            if (fiber === null) {\n                throw new Error('Calling Offscreen.detach before instance handle has been set.');\n            }\n            if ((instance._pendingVisibility & OffscreenDetached) !== NoFlags$1) {\n                // The instance is already detached, this is a noop.\n                return;\n            } // TODO: There is an opportunity to optimise this by not entering commit phase\n            // and unmounting effects directly.\n            var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n            if (root !== null) {\n                instance._pendingVisibility |= OffscreenDetached;\n                scheduleUpdateOnFiber(root, fiber, SyncLane);\n            }\n        }\n        function attachOffscreenInstance(instance) {\n            var fiber = instance._current;\n            if (fiber === null) {\n                throw new Error('Calling Offscreen.detach before instance handle has been set.');\n            }\n            if ((instance._pendingVisibility & OffscreenDetached) === NoFlags$1) {\n                // The instance is already attached, this is a noop.\n                return;\n            }\n            var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n            if (root !== null) {\n                instance._pendingVisibility &= ~OffscreenDetached;\n                scheduleUpdateOnFiber(root, fiber, SyncLane);\n            }\n        }\n        function attachSuspenseRetryListeners(finishedWork, wakeables) {\n            // If this boundary just timed out, then it will have a set of wakeables.\n            // For each wakeable, attach a listener so that when it resolves, React\n            // attempts to re-render the boundary in the primary (pre-timeout) state.\n            var retryCache = getRetryCache(finishedWork);\n            wakeables.forEach(function(wakeable) {\n                // Memoize using the boundary fiber to prevent redundant listeners.\n                var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n                if (!retryCache.has(wakeable)) {\n                    retryCache.add(wakeable);\n                    {\n                        if (isDevToolsPresent) {\n                            if (inProgressLanes !== null && inProgressRoot !== null) {\n                                // If we have pending work still, associate the original updaters with it.\n                                restorePendingUpdaters(inProgressRoot, inProgressLanes);\n                            } else {\n                                throw Error('Expected finished root and lanes to be set. This is a bug in React.');\n                            }\n                        }\n                    }\n                    wakeable.then(retry, retry);\n                }\n            });\n        } // This function detects when a Suspense boundary goes from visible to hidden.\n        function commitMutationEffects(root, finishedWork, committedLanes) {\n            inProgressLanes = committedLanes;\n            inProgressRoot = root;\n            setCurrentDebugFiberInDEV(finishedWork);\n            commitMutationEffectsOnFiber(finishedWork, root);\n            resetCurrentDebugFiberInDEV();\n            inProgressLanes = null;\n            inProgressRoot = null;\n        }\n        function recursivelyTraverseMutationEffects(root, parentFiber, lanes) {\n            // Deletions effects can be scheduled on any fiber type. They need to happen\n            // before the children effects hae fired.\n            var deletions = parentFiber.deletions;\n            if (deletions !== null) {\n                for(var i = 0; i < deletions.length; i++){\n                    var childToDelete = deletions[i];\n                    try {\n                        commitDeletionEffects(root, parentFiber, childToDelete);\n                    } catch (error) {\n                        captureCommitPhaseError(childToDelete, parentFiber, error);\n                    }\n                }\n            }\n            var prevDebugFiber = getCurrentFiber();\n            if (parentFiber.subtreeFlags & MutationMask) {\n                var child = parentFiber.child;\n                while(child !== null){\n                    setCurrentDebugFiberInDEV(child);\n                    commitMutationEffectsOnFiber(child, root);\n                    child = child.sibling;\n                }\n            }\n            setCurrentDebugFiberInDEV(prevDebugFiber);\n        }\n        var currentHoistableRoot = null;\n        function commitMutationEffectsOnFiber(finishedWork, root, lanes) {\n            var current = finishedWork.alternate;\n            var flags = finishedWork.flags; // The effect flag should be checked *after* we refine the type of fiber,\n            // because the fiber tag is more specific. An exception is any flag related\n            // to reconciliation, because those can be set on all fiber types.\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case MemoComponent:\n                case SimpleMemoComponent:\n                    {\n                        recursivelyTraverseMutationEffects(root, finishedWork);\n                        commitReconciliationEffects(finishedWork);\n                        if (flags & Update) {\n                            try {\n                                commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);\n                                commitHookEffectListMount(Insertion | HasEffect, finishedWork);\n                            } catch (error) {\n                                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                            } // Layout effects are destroyed during the mutation phase so that all\n                            // destroy functions for all fibers are called before any create functions.\n                            // This prevents sibling component effects from interfering with each other,\n                            // e.g. a destroy function in one component should never override a ref set\n                            // by a create function in another component during the same commit.\n                            if (shouldProfile(finishedWork)) {\n                                try {\n                                    startLayoutEffectTimer();\n                                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n                                } catch (error) {\n                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                }\n                                recordLayoutEffectDuration(finishedWork);\n                            } else {\n                                try {\n                                    commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);\n                                } catch (error) {\n                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                }\n                            }\n                        }\n                        return;\n                    }\n                case ClassComponent:\n                    {\n                        recursivelyTraverseMutationEffects(root, finishedWork);\n                        commitReconciliationEffects(finishedWork);\n                        if (flags & Ref) {\n                            if (current !== null) {\n                                safelyDetachRef(current, current.return);\n                            }\n                        }\n                        if (flags & Callback && offscreenSubtreeIsHidden) {\n                            var updateQueue = finishedWork.updateQueue;\n                            if (updateQueue !== null) {\n                                deferHiddenCallbacks(updateQueue);\n                            }\n                        }\n                        return;\n                    }\n                case HostHoistable:\n                    {\n                        if (supportsResources) {\n                            // We cast because we always set the root at the React root and so it cannot be\n                            // null while we are processing mutation effects\n                            var hoistableRoot = currentHoistableRoot;\n                            recursivelyTraverseMutationEffects(root, finishedWork);\n                            commitReconciliationEffects(finishedWork);\n                            if (flags & Ref) {\n                                if (current !== null) {\n                                    safelyDetachRef(current, current.return);\n                                }\n                            }\n                            if (flags & Update) {\n                                var currentResource = current !== null ? current.memoizedState : null;\n                                var newResource = finishedWork.memoizedState;\n                                if (current === null) {\n                                    // We are mounting a new HostHoistable Fiber. We fork the mount\n                                    // behavior based on whether this instance is a Hoistable Instance\n                                    // or a Hoistable Resource\n                                    if (newResource === null) {\n                                        if (finishedWork.stateNode === null) {\n                                            finishedWork.stateNode = hydrateHoistable(hoistableRoot, finishedWork.type, finishedWork.memoizedProps, finishedWork);\n                                        } else {\n                                            mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode);\n                                        }\n                                    } else {\n                                        finishedWork.stateNode = acquireResource(hoistableRoot, newResource, finishedWork.memoizedProps);\n                                    }\n                                } else if (currentResource !== newResource) {\n                                    // We are moving to or from Hoistable Resource, or between different Hoistable Resources\n                                    if (currentResource === null) {\n                                        if (current.stateNode !== null) {\n                                            unmountHoistable(current.stateNode);\n                                        }\n                                    } else {\n                                        releaseResource(currentResource);\n                                    }\n                                    if (newResource === null) {\n                                        mountHoistable(hoistableRoot, finishedWork.type, finishedWork.stateNode);\n                                    } else {\n                                        acquireResource(hoistableRoot, newResource, finishedWork.memoizedProps);\n                                    }\n                                } else if (newResource === null && finishedWork.stateNode !== null) {\n                                    try {\n                                        commitUpdate(finishedWork.stateNode, finishedWork.type, current.memoizedProps, finishedWork.memoizedProps, finishedWork);\n                                    } catch (error) {\n                                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                    }\n                                }\n                            }\n                            return;\n                        } // Fall through\n                    }\n                case HostSingleton:\n                    {\n                        if (supportsSingletons) {\n                            if (flags & Update) {\n                                var previousWork = finishedWork.alternate;\n                                if (previousWork === null) {\n                                    var singleton = finishedWork.stateNode;\n                                    var props = finishedWork.memoizedProps; // This was a new mount, we need to clear and set initial properties\n                                    clearSingleton(singleton);\n                                    acquireSingletonInstance(finishedWork.type, props, singleton, finishedWork);\n                                }\n                            }\n                        } // Fall through\n                    }\n                case HostComponent:\n                    {\n                        recursivelyTraverseMutationEffects(root, finishedWork);\n                        commitReconciliationEffects(finishedWork);\n                        if (flags & Ref) {\n                            if (current !== null) {\n                                safelyDetachRef(current, current.return);\n                            }\n                        }\n                        if (supportsMutation) {\n                            // TODO: ContentReset gets cleared by the children during the commit\n                            // phase. This is a refactor hazard because it means we must read\n                            // flags the flags after `commitReconciliationEffects` has already run;\n                            // the order matters. We should refactor so that ContentReset does not\n                            // rely on mutating the flag during commit. Like by setting a flag\n                            // during the render phase instead.\n                            if (finishedWork.flags & ContentReset) {\n                                var instance = finishedWork.stateNode;\n                                try {\n                                    resetTextContent(instance);\n                                } catch (error) {\n                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                }\n                            }\n                            if (flags & Update) {\n                                var _instance2 = finishedWork.stateNode;\n                                if (_instance2 != null) {\n                                    // Commit the work prepared earlier.\n                                    var newProps = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n                                    // as the newProps. The updatePayload will contain the real change in\n                                    // this case.\n                                    var oldProps = current !== null ? current.memoizedProps : newProps;\n                                    var type = finishedWork.type;\n                                    try {\n                                        commitUpdate(_instance2, type, oldProps, newProps, finishedWork);\n                                    } catch (error) {\n                                        captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                    }\n                                }\n                            }\n                            if (flags & FormReset) {\n                                needsFormReset = true;\n                                {\n                                    if (finishedWork.type !== 'form') {\n                                        // Paranoid coding. In case we accidentally start using the\n                                        // FormReset bit for something else.\n                                        error('Unexpected host component type. Expected a form. This is a ' + 'bug in React.');\n                                    }\n                                }\n                            }\n                        }\n                        return;\n                    }\n                case HostText:\n                    {\n                        recursivelyTraverseMutationEffects(root, finishedWork);\n                        commitReconciliationEffects(finishedWork);\n                        if (flags & Update) {\n                            if (supportsMutation) {\n                                if (finishedWork.stateNode === null) {\n                                    throw new Error('This should have a text node initialized. This error is likely ' + 'caused by a bug in React. Please file an issue.');\n                                }\n                                var textInstance = finishedWork.stateNode;\n                                var newText = finishedWork.memoizedProps; // For hydration we reuse the update path but we treat the oldProps\n                                // as the newProps. The updatePayload will contain the real change in\n                                // this case.\n                                var oldText = current !== null ? current.memoizedProps : newText;\n                                try {\n                                    commitTextUpdate(textInstance, oldText, newText);\n                                } catch (error) {\n                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                }\n                            }\n                        }\n                        return;\n                    }\n                case HostRoot:\n                    {\n                        if (supportsResources) {\n                            prepareToCommitHoistables();\n                            var previousHoistableRoot = currentHoistableRoot;\n                            currentHoistableRoot = getHoistableRoot(root.containerInfo);\n                            recursivelyTraverseMutationEffects(root, finishedWork);\n                            currentHoistableRoot = previousHoistableRoot;\n                            commitReconciliationEffects(finishedWork);\n                        } else {\n                            recursivelyTraverseMutationEffects(root, finishedWork);\n                            commitReconciliationEffects(finishedWork);\n                        }\n                        if (flags & Update) {\n                            if (supportsMutation && supportsHydration) {\n                                if (current !== null) {\n                                    var prevRootState = current.memoizedState;\n                                    if (prevRootState.isDehydrated) {\n                                        try {\n                                            commitHydratedContainer(root.containerInfo);\n                                        } catch (error) {\n                                            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                        }\n                                    }\n                                }\n                            }\n                            if (supportsPersistence) {\n                                var containerInfo = root.containerInfo;\n                                var pendingChildren = root.pendingChildren;\n                                try {\n                                    replaceContainerChildren(containerInfo, pendingChildren);\n                                } catch (error) {\n                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                }\n                            }\n                        }\n                        if (needsFormReset) {\n                            // A form component requested to be reset during this commit. We do this\n                            // after all mutations in the rest of the tree so that `defaultValue`\n                            // will already be updated. This way you can update `defaultValue` using\n                            // data sent by the server as a result of the form submission.\n                            //\n                            // Theoretically we could check finishedWork.subtreeFlags & FormReset,\n                            // but the FormReset bit is overloaded with other flags used by other\n                            // fiber types. So this extra variable lets us skip traversing the tree\n                            // except when a form was actually submitted.\n                            needsFormReset = false;\n                            recursivelyResetForms(finishedWork);\n                        }\n                        return;\n                    }\n                case HostPortal:\n                    {\n                        if (supportsResources) {\n                            var _previousHoistableRoot = currentHoistableRoot;\n                            currentHoistableRoot = getHoistableRoot(finishedWork.stateNode.containerInfo);\n                            recursivelyTraverseMutationEffects(root, finishedWork);\n                            commitReconciliationEffects(finishedWork);\n                            currentHoistableRoot = _previousHoistableRoot;\n                        } else {\n                            recursivelyTraverseMutationEffects(root, finishedWork);\n                            commitReconciliationEffects(finishedWork);\n                        }\n                        if (flags & Update) {\n                            if (supportsPersistence) {\n                                var portal = finishedWork.stateNode;\n                                var _containerInfo = portal.containerInfo;\n                                var _pendingChildren = portal.pendingChildren;\n                                try {\n                                    replaceContainerChildren(_containerInfo, _pendingChildren);\n                                } catch (error) {\n                                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                                }\n                            }\n                        }\n                        return;\n                    }\n                case SuspenseComponent:\n                    {\n                        recursivelyTraverseMutationEffects(root, finishedWork);\n                        commitReconciliationEffects(finishedWork); // TODO: We should mark a flag on the Suspense fiber itself, rather than\n                        // relying on the Offscreen fiber having a flag also being marked. The\n                        // reason is that this offscreen fiber might not be part of the work-in-\n                        // progress tree! It could have been reused from a previous render. This\n                        // doesn't lead to incorrect behavior because we don't rely on the flag\n                        // check alone; we also compare the states explicitly below. But for\n                        // modeling purposes, we _should_ be able to rely on the flag check alone.\n                        // So this is a bit fragile.\n                        //\n                        // Also, all this logic could/should move to the passive phase so it\n                        // doesn't block paint.\n                        var offscreenFiber = finishedWork.child;\n                        if (offscreenFiber.flags & Visibility) {\n                            // Throttle the appearance and disappearance of Suspense fallbacks.\n                            var isShowingFallback = finishedWork.memoizedState !== null;\n                            var wasShowingFallback = current !== null && current.memoizedState !== null;\n                            {\n                                if (isShowingFallback !== wasShowingFallback) {\n                                    // A fallback is either appearing or disappearing.\n                                    markCommitTimeOfFallback();\n                                }\n                            }\n                        }\n                        if (flags & Update) {\n                            try {\n                                commitSuspenseCallback(finishedWork);\n                            } catch (error) {\n                                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                            }\n                            var retryQueue = finishedWork.updateQueue;\n                            if (retryQueue !== null) {\n                                finishedWork.updateQueue = null;\n                                attachSuspenseRetryListeners(finishedWork, retryQueue);\n                            }\n                        }\n                        return;\n                    }\n                case OffscreenComponent:\n                    {\n                        if (flags & Ref) {\n                            if (current !== null) {\n                                safelyDetachRef(current, current.return);\n                            }\n                        }\n                        var newState = finishedWork.memoizedState;\n                        var isHidden = newState !== null;\n                        var wasHidden = current !== null && current.memoizedState !== null;\n                        {\n                            // Before committing the children, track on the stack whether this\n                            // offscreen subtree was already hidden, so that we don't unmount the\n                            // effects again.\n                            var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;\n                            var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n                            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || isHidden;\n                            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;\n                            recursivelyTraverseMutationEffects(root, finishedWork);\n                            offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n                            offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n                        }\n                        commitReconciliationEffects(finishedWork);\n                        var offscreenInstance = finishedWork.stateNode; // TODO: Add explicit effect flag to set _current.\n                        offscreenInstance._current = finishedWork; // Offscreen stores pending changes to visibility in `_pendingVisibility`. This is\n                        // to support batching of `attach` and `detach` calls.\n                        offscreenInstance._visibility &= ~OffscreenDetached;\n                        offscreenInstance._visibility |= offscreenInstance._pendingVisibility & OffscreenDetached;\n                        if (flags & Visibility) {\n                            // Track the current state on the Offscreen instance so we can\n                            // read it during an event\n                            if (isHidden) {\n                                offscreenInstance._visibility &= ~OffscreenVisible;\n                            } else {\n                                offscreenInstance._visibility |= OffscreenVisible;\n                            }\n                            if (isHidden) {\n                                var isUpdate = current !== null;\n                                var wasHiddenByAncestorOffscreen = offscreenSubtreeIsHidden || offscreenSubtreeWasHidden; // Only trigger disapper layout effects if:\n                                //   - This is an update, not first mount.\n                                //   - This Offscreen was not hidden before.\n                                //   - Ancestor Offscreen was not hidden in previous commit.\n                                if (isUpdate && !wasHidden && !wasHiddenByAncestorOffscreen) {\n                                    {\n                                        // Disappear the layout effects of all the children\n                                        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                                    }\n                                }\n                            } // Offscreen with manual mode manages visibility manually.\n                            if (supportsMutation && !isOffscreenManual(finishedWork)) {\n                                // TODO: This needs to run whenever there's an insertion or update\n                                // inside a hidden Offscreen tree.\n                                hideOrUnhideAllChildren(finishedWork, isHidden);\n                            }\n                        } // TODO: Move to passive phase\n                        if (flags & Update) {\n                            var offscreenQueue = finishedWork.updateQueue;\n                            if (offscreenQueue !== null) {\n                                var _retryQueue = offscreenQueue.retryQueue;\n                                if (_retryQueue !== null) {\n                                    offscreenQueue.retryQueue = null;\n                                    attachSuspenseRetryListeners(finishedWork, _retryQueue);\n                                }\n                            }\n                        }\n                        return;\n                    }\n                case SuspenseListComponent:\n                    {\n                        recursivelyTraverseMutationEffects(root, finishedWork);\n                        commitReconciliationEffects(finishedWork);\n                        if (flags & Update) {\n                            var _retryQueue2 = finishedWork.updateQueue;\n                            if (_retryQueue2 !== null) {\n                                finishedWork.updateQueue = null;\n                                attachSuspenseRetryListeners(finishedWork, _retryQueue2);\n                            }\n                        }\n                        return;\n                    }\n                case ScopeComponent:\n                    {\n                        return;\n                    }\n                default:\n                    {\n                        recursivelyTraverseMutationEffects(root, finishedWork);\n                        commitReconciliationEffects(finishedWork);\n                        return;\n                    }\n            }\n        }\n        function commitReconciliationEffects(finishedWork) {\n            // Placement effects (insertions, reorders) can be scheduled on any fiber\n            // type. They needs to happen after the children effects have fired, but\n            // before the effects on this fiber have fired.\n            var flags = finishedWork.flags;\n            if (flags & Placement) {\n                try {\n                    commitPlacement(finishedWork);\n                } catch (error) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                } // Clear the \"placement\" from effect tag so that we know that this is\n                // inserted, before any life-cycles like componentDidMount gets called.\n                // TODO: findDOMNode doesn't rely on this any more but isMounted does\n                // and isMounted is deprecated anyway so we should be able to kill this.\n                finishedWork.flags &= ~Placement;\n            }\n            if (flags & Hydrating) {\n                finishedWork.flags &= ~Hydrating;\n            }\n        }\n        function recursivelyResetForms(parentFiber) {\n            if (parentFiber.subtreeFlags & FormReset) {\n                var child = parentFiber.child;\n                while(child !== null){\n                    resetFormOnFiber(child);\n                    child = child.sibling;\n                }\n            }\n        }\n        function resetFormOnFiber(fiber) {\n            recursivelyResetForms(fiber);\n            if (fiber.tag === HostComponent && fiber.flags & FormReset) {\n                var formInstance = fiber.stateNode;\n                resetFormInstance(formInstance);\n            }\n        }\n        function commitLayoutEffects(finishedWork, root, committedLanes) {\n            inProgressLanes = committedLanes;\n            inProgressRoot = root;\n            setCurrentDebugFiberInDEV(finishedWork);\n            var current = finishedWork.alternate;\n            commitLayoutEffectOnFiber(root, current, finishedWork);\n            resetCurrentDebugFiberInDEV();\n            inProgressLanes = null;\n            inProgressRoot = null;\n        }\n        function recursivelyTraverseLayoutEffects(root, parentFiber, lanes) {\n            var prevDebugFiber = getCurrentFiber();\n            if (parentFiber.subtreeFlags & LayoutMask) {\n                var child = parentFiber.child;\n                while(child !== null){\n                    setCurrentDebugFiberInDEV(child);\n                    var current = child.alternate;\n                    commitLayoutEffectOnFiber(root, current, child);\n                    child = child.sibling;\n                }\n            }\n            setCurrentDebugFiberInDEV(prevDebugFiber);\n        }\n        function disappearLayoutEffects(finishedWork) {\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case MemoComponent:\n                case SimpleMemoComponent:\n                    {\n                        // TODO (Offscreen) Check: flags & LayoutStatic\n                        if (shouldProfile(finishedWork)) {\n                            try {\n                                startLayoutEffectTimer();\n                                commitHookEffectListUnmount(Layout, finishedWork, finishedWork.return);\n                            } finally{\n                                recordLayoutEffectDuration(finishedWork);\n                            }\n                        } else {\n                            commitHookEffectListUnmount(Layout, finishedWork, finishedWork.return);\n                        }\n                        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                        break;\n                    }\n                case ClassComponent:\n                    {\n                        // TODO (Offscreen) Check: flags & RefStatic\n                        safelyDetachRef(finishedWork, finishedWork.return);\n                        var instance = finishedWork.stateNode;\n                        if (typeof instance.componentWillUnmount === 'function') {\n                            safelyCallComponentWillUnmount(finishedWork, finishedWork.return, instance);\n                        }\n                        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                        break;\n                    }\n                case HostHoistable:\n                case HostSingleton:\n                case HostComponent:\n                    {\n                        // TODO (Offscreen) Check: flags & RefStatic\n                        safelyDetachRef(finishedWork, finishedWork.return);\n                        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        // TODO (Offscreen) Check: flags & RefStatic\n                        safelyDetachRef(finishedWork, finishedWork.return);\n                        var isHidden = finishedWork.memoizedState !== null;\n                        if (isHidden) ;\n                        else {\n                            recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n                        break;\n                    }\n            }\n        }\n        function recursivelyTraverseDisappearLayoutEffects(parentFiber) {\n            // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\n            var child = parentFiber.child;\n            while(child !== null){\n                disappearLayoutEffects(child);\n                child = child.sibling;\n            }\n        }\n        function reappearLayoutEffects(finishedRoot, current, finishedWork, // from a previously committed tree. We cannot check non-static flags if the\n        // node was reused.\n        includeWorkInProgressEffects) {\n            // Turn on layout effects in a tree that previously disappeared.\n            var flags = finishedWork.flags;\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects); // TODO: Check flags & LayoutStatic\n                        commitHookLayoutEffects(finishedWork, Layout);\n                        break;\n                    }\n                case ClassComponent:\n                    {\n                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects); // TODO: Check for LayoutStatic flag\n                        var instance = finishedWork.stateNode;\n                        if (typeof instance.componentDidMount === 'function') {\n                            try {\n                                instance.componentDidMount();\n                            } catch (error) {\n                                captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                            }\n                        } // Commit any callbacks that would have fired while the component\n                        // was hidden.\n                        var updateQueue = finishedWork.updateQueue;\n                        if (updateQueue !== null) {\n                            commitHiddenCallbacks(updateQueue, instance);\n                        } // If this is newly finished work, check for setState callbacks\n                        if (includeWorkInProgressEffects && flags & Callback) {\n                            commitClassCallbacks(finishedWork);\n                        } // TODO: Check flags & RefStatic\n                        safelyAttachRef(finishedWork, finishedWork.return);\n                        break;\n                    }\n                // Unlike commitLayoutEffectsOnFiber, we don't need to handle HostRoot\n                // because this function only visits nodes that are inside an\n                // Offscreen fiber.\n                // case HostRoot: {\n                //  ...\n                // }\n                case HostHoistable:\n                case HostSingleton:\n                case HostComponent:\n                    {\n                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects); // Renderers may schedule work to be done after host components are mounted\n                        // (eg DOM renderer may schedule auto-focus for inputs and form controls).\n                        // These effects should only be committed when components are first mounted,\n                        // aka when there is no current/alternate.\n                        if (includeWorkInProgressEffects && current === null && flags & Update) {\n                            commitHostComponentMount(finishedWork);\n                        } // TODO: Check flags & Ref\n                        safelyAttachRef(finishedWork, finishedWork.return);\n                        break;\n                    }\n                case Profiler:\n                    {\n                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects); // TODO: Figure out how Profiler updates should work with Offscreen\n                        if (includeWorkInProgressEffects && flags & Update) {\n                            commitProfilerUpdate(finishedWork, current);\n                        }\n                        break;\n                    }\n                case SuspenseComponent:\n                    {\n                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects); // TODO: Figure out how Suspense hydration callbacks should work\n                        // with Offscreen.\n                        if (includeWorkInProgressEffects && flags & Update) {\n                            commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n                        }\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        var offscreenState = finishedWork.memoizedState;\n                        var isHidden = offscreenState !== null;\n                        if (isHidden) ;\n                        else {\n                            recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                        } // TODO: Check flags & Ref\n                        safelyAttachRef(finishedWork, finishedWork.return);\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyTraverseReappearLayoutEffects(finishedRoot, finishedWork, includeWorkInProgressEffects);\n                        break;\n                    }\n            }\n        }\n        function recursivelyTraverseReappearLayoutEffects(finishedRoot, parentFiber, includeWorkInProgressEffects) {\n            // This function visits both newly finished work and nodes that were re-used\n            // from a previously committed tree. We cannot check non-static flags if the\n            // node was reused.\n            var childShouldIncludeWorkInProgressEffects = includeWorkInProgressEffects && (parentFiber.subtreeFlags & LayoutMask) !== NoFlags$1; // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\n            var prevDebugFiber = getCurrentFiber();\n            var child = parentFiber.child;\n            while(child !== null){\n                var current = child.alternate;\n                reappearLayoutEffects(finishedRoot, current, child, childShouldIncludeWorkInProgressEffects);\n                child = child.sibling;\n            }\n            setCurrentDebugFiberInDEV(prevDebugFiber);\n        }\n        function commitHookPassiveMountEffects(finishedWork, hookFlags) {\n            if (shouldProfile(finishedWork)) {\n                startPassiveEffectTimer();\n                try {\n                    commitHookEffectListMount(hookFlags, finishedWork);\n                } catch (error) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n                recordPassiveEffectDuration(finishedWork);\n            } else {\n                try {\n                    commitHookEffectListMount(hookFlags, finishedWork);\n                } catch (error) {\n                    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n                }\n            }\n        }\n        function commitOffscreenPassiveMountEffects(current, finishedWork, instance) {\n            {\n                var previousCache = null;\n                if (current !== null && current.memoizedState !== null && current.memoizedState.cachePool !== null) {\n                    previousCache = current.memoizedState.cachePool.pool;\n                }\n                var nextCache = null;\n                if (finishedWork.memoizedState !== null && finishedWork.memoizedState.cachePool !== null) {\n                    nextCache = finishedWork.memoizedState.cachePool.pool;\n                } // Retain/release the cache used for pending (suspended) nodes.\n                // Note that this is only reached in the non-suspended/visible case:\n                // when the content is suspended/hidden, the retain/release occurs\n                // via the parent Suspense component (see case above).\n                if (nextCache !== previousCache) {\n                    if (nextCache != null) {\n                        retainCache(nextCache);\n                    }\n                    if (previousCache != null) {\n                        releaseCache(previousCache);\n                    }\n                }\n            }\n        }\n        function commitCachePassiveMountEffect(current, finishedWork) {\n            {\n                var previousCache = null;\n                if (finishedWork.alternate !== null) {\n                    previousCache = finishedWork.alternate.memoizedState.cache;\n                }\n                var nextCache = finishedWork.memoizedState.cache; // Retain/release the cache. In theory the cache component\n                // could be \"borrowing\" a cache instance owned by some parent,\n                // in which case we could avoid retaining/releasing. But it\n                // is non-trivial to determine when that is the case, so we\n                // always retain/release.\n                if (nextCache !== previousCache) {\n                    retainCache(nextCache);\n                    if (previousCache != null) {\n                        releaseCache(previousCache);\n                    }\n                }\n            }\n        }\n        function commitPassiveMountEffects(root, finishedWork, committedLanes, committedTransitions) {\n            setCurrentDebugFiberInDEV(finishedWork);\n            commitPassiveMountOnFiber(root, finishedWork, committedLanes, committedTransitions);\n            resetCurrentDebugFiberInDEV();\n        }\n        function recursivelyTraversePassiveMountEffects(root, parentFiber, committedLanes, committedTransitions) {\n            var prevDebugFiber = getCurrentFiber();\n            if (parentFiber.subtreeFlags & PassiveMask) {\n                var child = parentFiber.child;\n                while(child !== null){\n                    setCurrentDebugFiberInDEV(child);\n                    commitPassiveMountOnFiber(root, child, committedLanes, committedTransitions);\n                    child = child.sibling;\n                }\n            }\n            setCurrentDebugFiberInDEV(prevDebugFiber);\n        }\n        function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {\n            // When updating this function, also update reconnectPassiveEffects, which does\n            // most of the same things when an offscreen tree goes from hidden -> visible,\n            // or when toggling effects inside a hidden tree.\n            var flags = finishedWork.flags;\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                        if (flags & Passive$1) {\n                            commitHookPassiveMountEffects(finishedWork, Passive | HasEffect);\n                        }\n                        break;\n                    }\n                case HostRoot:\n                    {\n                        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                        if (flags & Passive$1) {\n                            {\n                                var previousCache = null;\n                                if (finishedWork.alternate !== null) {\n                                    previousCache = finishedWork.alternate.memoizedState.cache;\n                                }\n                                var nextCache = finishedWork.memoizedState.cache; // Retain/release the root cache.\n                                // Note that on initial mount, previousCache and nextCache will be the same\n                                // and this retain won't occur. To counter this, we instead retain the HostRoot's\n                                // initial cache when creating the root itself (see createFiberRoot() in\n                                // ReactFiberRoot.js). Subsequent updates that change the cache are reflected\n                                // here, such that previous/next caches are retained correctly.\n                                if (nextCache !== previousCache) {\n                                    retainCache(nextCache);\n                                    if (previousCache != null) {\n                                        releaseCache(previousCache);\n                                    }\n                                }\n                            }\n                        }\n                        break;\n                    }\n                case LegacyHiddenComponent:\n                    {\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        // TODO: Pass `current` as argument to this function\n                        var _instance3 = finishedWork.stateNode;\n                        var nextState = finishedWork.memoizedState;\n                        var isHidden = nextState !== null;\n                        if (isHidden) {\n                            if (_instance3._visibility & OffscreenPassiveEffectsConnected) {\n                                // The effects are currently connected. Update them.\n                                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                            } else {\n                                {\n                                    // The effects are currently disconnected. Since the tree is hidden,\n                                    // don't connect them. This also applies to the initial render.\n                                    {\n                                        // \"Atomic\" effects are ones that need to fire on every commit,\n                                        // even during pre-rendering. An example is updating the reference\n                                        // count on cache instances.\n                                        recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n                                    }\n                                }\n                            }\n                        } else {\n                            // Tree is visible\n                            if (_instance3._visibility & OffscreenPassiveEffectsConnected) {\n                                // The effects are currently connected. Update them.\n                                recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                            } else {\n                                // The effects are currently disconnected. Reconnect them, while also\n                                // firing effects inside newly mounted trees. This also applies to\n                                // the initial render.\n                                _instance3._visibility |= OffscreenPassiveEffectsConnected;\n                                var includeWorkInProgressEffects = (finishedWork.subtreeFlags & PassiveMask) !== NoFlags$1;\n                                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                            }\n                        }\n                        if (flags & Passive$1) {\n                            var _current = finishedWork.alternate;\n                            commitOffscreenPassiveMountEffects(_current, finishedWork);\n                        }\n                        break;\n                    }\n                case CacheComponent:\n                    {\n                        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                        if (flags & Passive$1) {\n                            // TODO: Pass `current` as argument to this function\n                            var _current2 = finishedWork.alternate;\n                            commitCachePassiveMountEffect(_current2, finishedWork);\n                        }\n                        break;\n                    }\n                case TracingMarkerComponent:\n                default:\n                    {\n                        recursivelyTraversePassiveMountEffects(finishedRoot, finishedWork, committedLanes, committedTransitions);\n                        break;\n                    }\n            }\n        }\n        function recursivelyTraverseReconnectPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions, includeWorkInProgressEffects) {\n            // This function visits both newly finished work and nodes that were re-used\n            // from a previously committed tree. We cannot check non-static flags if the\n            // node was reused.\n            var childShouldIncludeWorkInProgressEffects = includeWorkInProgressEffects && (parentFiber.subtreeFlags & PassiveMask) !== NoFlags$1; // TODO (Offscreen) Check: flags & (RefStatic | LayoutStatic)\n            var prevDebugFiber = getCurrentFiber();\n            var child = parentFiber.child;\n            while(child !== null){\n                reconnectPassiveEffects(finishedRoot, child, committedLanes, committedTransitions, childShouldIncludeWorkInProgressEffects);\n                child = child.sibling;\n            }\n            setCurrentDebugFiberInDEV(prevDebugFiber);\n        }\n        function reconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, // from a previously committed tree. We cannot check non-static flags if the\n        // node was reused.\n        includeWorkInProgressEffects) {\n            var flags = finishedWork.flags;\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects); // TODO: Check for PassiveStatic flag\n                        commitHookPassiveMountEffects(finishedWork, Passive);\n                        break;\n                    }\n                // Unlike commitPassiveMountOnFiber, we don't need to handle HostRoot\n                // because this function only visits nodes that are inside an\n                // Offscreen fiber.\n                // case HostRoot: {\n                //  ...\n                // }\n                case LegacyHiddenComponent:\n                    {\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        var _instance4 = finishedWork.stateNode;\n                        var nextState = finishedWork.memoizedState;\n                        var isHidden = nextState !== null;\n                        if (isHidden) {\n                            if (_instance4._visibility & OffscreenPassiveEffectsConnected) {\n                                // The effects are currently connected. Update them.\n                                recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                            } else {\n                                {\n                                    // The effects are currently disconnected. Since the tree is hidden,\n                                    // don't connect them. This also applies to the initial render.\n                                    {\n                                        // \"Atomic\" effects are ones that need to fire on every commit,\n                                        // even during pre-rendering. An example is updating the reference\n                                        // count on cache instances.\n                                        recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n                                    }\n                                }\n                            }\n                        } else {\n                            // Tree is visible\n                            // Since we're already inside a reconnecting tree, it doesn't matter\n                            // whether the effects are currently connected. In either case, we'll\n                            // continue traversing the tree and firing all the effects.\n                            //\n                            // We do need to set the \"connected\" flag on the instance, though.\n                            _instance4._visibility |= OffscreenPassiveEffectsConnected;\n                            recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                        }\n                        if (includeWorkInProgressEffects && flags & Passive$1) {\n                            // TODO: Pass `current` as argument to this function\n                            var _current3 = finishedWork.alternate;\n                            commitOffscreenPassiveMountEffects(_current3, finishedWork);\n                        }\n                        break;\n                    }\n                case CacheComponent:\n                    {\n                        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                        if (includeWorkInProgressEffects && flags & Passive$1) {\n                            // TODO: Pass `current` as argument to this function\n                            var _current4 = finishedWork.alternate;\n                            commitCachePassiveMountEffect(_current4, finishedWork);\n                        }\n                        break;\n                    }\n                case TracingMarkerComponent:\n                default:\n                    {\n                        recursivelyTraverseReconnectPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions, includeWorkInProgressEffects);\n                        break;\n                    }\n            }\n        }\n        function recursivelyTraverseAtomicPassiveEffects(finishedRoot, parentFiber, committedLanes, committedTransitions) {\n            // \"Atomic\" effects are ones that need to fire on every commit, even during\n            // pre-rendering. We call this function when traversing a hidden tree whose\n            // regular effects are currently disconnected.\n            var prevDebugFiber = getCurrentFiber(); // TODO: Add special flag for atomic effects\n            if (parentFiber.subtreeFlags & PassiveMask) {\n                var child = parentFiber.child;\n                while(child !== null){\n                    setCurrentDebugFiberInDEV(child);\n                    commitAtomicPassiveEffects(finishedRoot, child);\n                    child = child.sibling;\n                }\n            }\n            setCurrentDebugFiberInDEV(prevDebugFiber);\n        }\n        function commitAtomicPassiveEffects(finishedRoot, finishedWork, committedLanes, committedTransitions) {\n            // \"Atomic\" effects are ones that need to fire on every commit, even during\n            // pre-rendering. We call this function when traversing a hidden tree whose\n            // regular effects are currently disconnected.\n            var flags = finishedWork.flags;\n            switch(finishedWork.tag){\n                case OffscreenComponent:\n                    {\n                        recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n                        if (flags & Passive$1) {\n                            // TODO: Pass `current` as argument to this function\n                            var current = finishedWork.alternate;\n                            commitOffscreenPassiveMountEffects(current, finishedWork);\n                        }\n                        break;\n                    }\n                case CacheComponent:\n                    {\n                        recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n                        if (flags & Passive$1) {\n                            // TODO: Pass `current` as argument to this function\n                            var _current5 = finishedWork.alternate;\n                            commitCachePassiveMountEffect(_current5, finishedWork);\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n                        break;\n                    }\n            }\n        }\n        function commitPassiveUnmountEffects(finishedWork) {\n            setCurrentDebugFiberInDEV(finishedWork);\n            commitPassiveUnmountOnFiber(finishedWork);\n            resetCurrentDebugFiberInDEV();\n        } // If we're inside a brand new tree, or a tree that was already visible, then we\n        // should only suspend host components that have a ShouldSuspendCommit flag.\n        // Components without it haven't changed since the last commit, so we can skip\n        // over those.\n        //\n        // When we enter a tree that is being revealed (going from hidden -> visible),\n        // we need to suspend _any_ component that _may_ suspend. Even if they're\n        // already in the \"current\" tree. Because their visibility has changed, the\n        // browser may not have prerendered them yet. So we check the MaySuspendCommit\n        // flag instead.\n        var suspenseyCommitFlag = ShouldSuspendCommit;\n        function accumulateSuspenseyCommit(finishedWork) {\n            accumulateSuspenseyCommitOnFiber(finishedWork);\n        }\n        function recursivelyAccumulateSuspenseyCommit(parentFiber) {\n            if (parentFiber.subtreeFlags & suspenseyCommitFlag) {\n                var child = parentFiber.child;\n                while(child !== null){\n                    accumulateSuspenseyCommitOnFiber(child);\n                    child = child.sibling;\n                }\n            }\n        }\n        function accumulateSuspenseyCommitOnFiber(fiber) {\n            switch(fiber.tag){\n                case HostHoistable:\n                    {\n                        recursivelyAccumulateSuspenseyCommit(fiber);\n                        if (fiber.flags & suspenseyCommitFlag) {\n                            if (fiber.memoizedState !== null) {\n                                suspendResource(currentHoistableRoot, fiber.memoizedState, fiber.memoizedProps);\n                            } else {\n                                var type = fiber.type;\n                                var props = fiber.memoizedProps;\n                                suspendInstance(type, props);\n                            }\n                        }\n                        break;\n                    }\n                case HostComponent:\n                    {\n                        recursivelyAccumulateSuspenseyCommit(fiber);\n                        if (fiber.flags & suspenseyCommitFlag) {\n                            var _type = fiber.type;\n                            var _props = fiber.memoizedProps;\n                            suspendInstance(_type, _props);\n                        }\n                        break;\n                    }\n                case HostRoot:\n                case HostPortal:\n                    {\n                        if (supportsResources) {\n                            var previousHoistableRoot = currentHoistableRoot;\n                            var container = fiber.stateNode.containerInfo;\n                            currentHoistableRoot = getHoistableRoot(container);\n                            recursivelyAccumulateSuspenseyCommit(fiber);\n                            currentHoistableRoot = previousHoistableRoot;\n                        } else {\n                            recursivelyAccumulateSuspenseyCommit(fiber);\n                        }\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        var isHidden = fiber.memoizedState !== null;\n                        if (isHidden) ;\n                        else {\n                            var current = fiber.alternate;\n                            var wasHidden = current !== null && current.memoizedState !== null;\n                            if (wasHidden) {\n                                // This tree is being revealed. Visit all newly visible suspensey\n                                // instances, even if they're in the current tree.\n                                var prevFlags = suspenseyCommitFlag;\n                                suspenseyCommitFlag = MaySuspendCommit;\n                                recursivelyAccumulateSuspenseyCommit(fiber);\n                                suspenseyCommitFlag = prevFlags;\n                            } else {\n                                recursivelyAccumulateSuspenseyCommit(fiber);\n                            }\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyAccumulateSuspenseyCommit(fiber);\n                    }\n            }\n        }\n        function detachAlternateSiblings(parentFiber) {\n            // A fiber was deleted from this parent fiber, but it's still part of the\n            // previous (alternate) parent fiber's list of children. Because children\n            // are a linked list, an earlier sibling that's still alive will be\n            // connected to the deleted fiber via its `alternate`:\n            //\n            //   live fiber --alternate--> previous live fiber --sibling--> deleted\n            //   fiber\n            //\n            // We can't disconnect `alternate` on nodes that haven't been deleted yet,\n            // but we can disconnect the `sibling` and `child` pointers.\n            var previousFiber = parentFiber.alternate;\n            if (previousFiber !== null) {\n                var detachedChild = previousFiber.child;\n                if (detachedChild !== null) {\n                    previousFiber.child = null;\n                    do {\n                        // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        var detachedSibling = detachedChild.sibling; // $FlowFixMe[incompatible-use] found when upgrading Flow\n                        detachedChild.sibling = null;\n                        detachedChild = detachedSibling;\n                    }while (detachedChild !== null);\n                }\n            }\n        }\n        function commitHookPassiveUnmountEffects(finishedWork, nearestMountedAncestor, hookFlags) {\n            if (shouldProfile(finishedWork)) {\n                startPassiveEffectTimer();\n                commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);\n                recordPassiveEffectDuration(finishedWork);\n            } else {\n                commitHookEffectListUnmount(hookFlags, finishedWork, nearestMountedAncestor);\n            }\n        }\n        function recursivelyTraversePassiveUnmountEffects(parentFiber) {\n            // Deletions effects can be scheduled on any fiber type. They need to happen\n            // before the children effects have fired.\n            var deletions = parentFiber.deletions;\n            if ((parentFiber.flags & ChildDeletion) !== NoFlags$1) {\n                if (deletions !== null) {\n                    for(var i = 0; i < deletions.length; i++){\n                        var childToDelete = deletions[i]; // TODO: Convert this to use recursion\n                        nextEffect = childToDelete;\n                        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);\n                    }\n                }\n                detachAlternateSiblings(parentFiber);\n            }\n            var prevDebugFiber = getCurrentFiber(); // TODO: Split PassiveMask into separate masks for mount and unmount?\n            if (parentFiber.subtreeFlags & PassiveMask) {\n                var child = parentFiber.child;\n                while(child !== null){\n                    setCurrentDebugFiberInDEV(child);\n                    commitPassiveUnmountOnFiber(child);\n                    child = child.sibling;\n                }\n            }\n            setCurrentDebugFiberInDEV(prevDebugFiber);\n        }\n        function commitPassiveUnmountOnFiber(finishedWork) {\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        recursivelyTraversePassiveUnmountEffects(finishedWork);\n                        if (finishedWork.flags & Passive$1) {\n                            commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive | HasEffect);\n                        }\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        var instance = finishedWork.stateNode;\n                        var nextState = finishedWork.memoizedState;\n                        var isHidden = nextState !== null;\n                        if (isHidden && instance._visibility & OffscreenPassiveEffectsConnected && // the future we may change this to unmount after a delay.\n                        (finishedWork.return === null || finishedWork.return.tag !== SuspenseComponent)) {\n                            // The effects are currently connected. Disconnect them.\n                            // TODO: Add option or heuristic to delay before disconnecting the\n                            // effects. Then if the tree reappears before the delay has elapsed, we\n                            // can skip toggling the effects entirely.\n                            instance._visibility &= ~OffscreenPassiveEffectsConnected;\n                            recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n                        } else {\n                            recursivelyTraversePassiveUnmountEffects(finishedWork);\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyTraversePassiveUnmountEffects(finishedWork);\n                        break;\n                    }\n            }\n        }\n        function recursivelyTraverseDisconnectPassiveEffects(parentFiber) {\n            // Deletions effects can be scheduled on any fiber type. They need to happen\n            // before the children effects have fired.\n            var deletions = parentFiber.deletions;\n            if ((parentFiber.flags & ChildDeletion) !== NoFlags$1) {\n                if (deletions !== null) {\n                    for(var i = 0; i < deletions.length; i++){\n                        var childToDelete = deletions[i]; // TODO: Convert this to use recursion\n                        nextEffect = childToDelete;\n                        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(childToDelete, parentFiber);\n                    }\n                }\n                detachAlternateSiblings(parentFiber);\n            }\n            var prevDebugFiber = getCurrentFiber(); // TODO: Check PassiveStatic flag\n            var child = parentFiber.child;\n            while(child !== null){\n                setCurrentDebugFiberInDEV(child);\n                disconnectPassiveEffect(child);\n                child = child.sibling;\n            }\n            setCurrentDebugFiberInDEV(prevDebugFiber);\n        }\n        function disconnectPassiveEffect(finishedWork) {\n            switch(finishedWork.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        // TODO: Check PassiveStatic flag\n                        commitHookPassiveUnmountEffects(finishedWork, finishedWork.return, Passive); // When disconnecting passive effects, we fire the effects in the same\n                        // order as during a deletiong: parent before child\n                        recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n                        break;\n                    }\n                case OffscreenComponent:\n                    {\n                        var instance = finishedWork.stateNode;\n                        if (instance._visibility & OffscreenPassiveEffectsConnected) {\n                            instance._visibility &= ~OffscreenPassiveEffectsConnected;\n                            recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n                        }\n                        break;\n                    }\n                default:\n                    {\n                        recursivelyTraverseDisconnectPassiveEffects(finishedWork);\n                        break;\n                    }\n            }\n        }\n        function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {\n            while(nextEffect !== null){\n                var fiber = nextEffect; // Deletion effects fire in parent -> child order\n                // TODO: Check if fiber has a PassiveStatic flag\n                setCurrentDebugFiberInDEV(fiber);\n                commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);\n                resetCurrentDebugFiberInDEV();\n                var child = fiber.child; // TODO: Only traverse subtree if it has a PassiveStatic flag.\n                if (child !== null) {\n                    child.return = fiber;\n                    nextEffect = child;\n                } else {\n                    commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);\n                }\n            }\n        }\n        function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {\n            while(nextEffect !== null){\n                var fiber = nextEffect;\n                var sibling = fiber.sibling;\n                var returnFiber = fiber.return; // Recursively traverse the entire deleted tree and clean up fiber fields.\n                // This is more aggressive than ideal, and the long term goal is to only\n                // have to detach the deleted tree at the root.\n                detachFiberAfterEffects(fiber);\n                if (fiber === deletedSubtreeRoot) {\n                    nextEffect = null;\n                    return;\n                }\n                if (sibling !== null) {\n                    sibling.return = returnFiber;\n                    nextEffect = sibling;\n                    return;\n                }\n                nextEffect = returnFiber;\n            }\n        }\n        function commitPassiveUnmountInsideDeletedTreeOnFiber(current, nearestMountedAncestor) {\n            switch(current.tag){\n                case FunctionComponent:\n                case ForwardRef:\n                case SimpleMemoComponent:\n                    {\n                        commitHookPassiveUnmountEffects(current, nearestMountedAncestor, Passive);\n                        break;\n                    }\n                // TODO: run passive unmount effects when unmounting a root.\n                // Because passive unmount effects are not currently run,\n                // the cache instance owned by the root will never be freed.\n                // When effects are run, the cache should be freed here:\n                // case HostRoot: {\n                //   if (enableCache) {\n                //     const cache = current.memoizedState.cache;\n                //     releaseCache(cache);\n                //   }\n                //   break;\n                // }\n                case LegacyHiddenComponent:\n                case OffscreenComponent:\n                    {\n                        {\n                            if (current.memoizedState !== null && current.memoizedState.cachePool !== null) {\n                                var cache = current.memoizedState.cachePool.pool; // Retain/release the cache used for pending (suspended) nodes.\n                                // Note that this is only reached in the non-suspended/visible case:\n                                // when the content is suspended/hidden, the retain/release occurs\n                                // via the parent Suspense component (see case above).\n                                if (cache != null) {\n                                    retainCache(cache);\n                                }\n                            }\n                        }\n                        break;\n                    }\n                case SuspenseComponent:\n                    {\n                        break;\n                    }\n                case CacheComponent:\n                    {\n                        {\n                            var _cache = current.memoizedState.cache;\n                            releaseCache(_cache);\n                        }\n                        break;\n                    }\n            }\n        }\n        function getCacheForType(resourceType) {\n            var cache = readContext(CacheContext);\n            var cacheForType = cache.data.get(resourceType);\n            if (cacheForType === undefined) {\n                cacheForType = resourceType();\n                cache.data.set(resourceType, cacheForType);\n            }\n            return cacheForType;\n        }\n        var DefaultAsyncDispatcher = {\n            getCacheForType: getCacheForType\n        };\n        {\n            DefaultAsyncDispatcher.getOwner = function() {\n                return current;\n            };\n        }\n        var COMPONENT_TYPE = 0;\n        var HAS_PSEUDO_CLASS_TYPE = 1;\n        var ROLE_TYPE = 2;\n        var TEST_NAME_TYPE = 3;\n        var TEXT_TYPE = 4;\n        if (typeof Symbol === 'function' && Symbol.for) {\n            var symbolFor = Symbol.for;\n            COMPONENT_TYPE = symbolFor('selector.component');\n            HAS_PSEUDO_CLASS_TYPE = symbolFor('selector.has_pseudo_class');\n            ROLE_TYPE = symbolFor('selector.role');\n            TEST_NAME_TYPE = symbolFor('selector.test_id');\n            TEXT_TYPE = symbolFor('selector.text');\n        }\n        function createComponentSelector(component) {\n            return {\n                $$typeof: COMPONENT_TYPE,\n                value: component\n            };\n        }\n        function createHasPseudoClassSelector(selectors) {\n            return {\n                $$typeof: HAS_PSEUDO_CLASS_TYPE,\n                value: selectors\n            };\n        }\n        function createRoleSelector(role) {\n            return {\n                $$typeof: ROLE_TYPE,\n                value: role\n            };\n        }\n        function createTextSelector(text) {\n            return {\n                $$typeof: TEXT_TYPE,\n                value: text\n            };\n        }\n        function createTestNameSelector(id) {\n            return {\n                $$typeof: TEST_NAME_TYPE,\n                value: id\n            };\n        }\n        function findFiberRootForHostRoot(hostRoot) {\n            var maybeFiber = getInstanceFromNode(hostRoot);\n            if (maybeFiber != null) {\n                if (typeof maybeFiber.memoizedProps['data-testname'] !== 'string') {\n                    throw new Error('Invalid host root specified. Should be either a React container or a node with a testname attribute.');\n                }\n                return maybeFiber;\n            } else {\n                var fiberRoot = findFiberRoot(hostRoot);\n                if (fiberRoot === null) {\n                    throw new Error('Could not find React container within specified host subtree.');\n                } // The Flow type for FiberRoot is a little funky.\n                // createFiberRoot() cheats this by treating the root as :any and adding stateNode lazily.\n                return fiberRoot.stateNode.current;\n            }\n        }\n        function matchSelector(fiber, selector) {\n            var tag = fiber.tag;\n            switch(selector.$$typeof){\n                case COMPONENT_TYPE:\n                    if (fiber.type === selector.value) {\n                        return true;\n                    }\n                    break;\n                case HAS_PSEUDO_CLASS_TYPE:\n                    return hasMatchingPaths(fiber, selector.value);\n                case ROLE_TYPE:\n                    if (tag === HostComponent || tag === HostHoistable || tag === HostSingleton) {\n                        var node = fiber.stateNode;\n                        if (matchAccessibilityRole(node, selector.value)) {\n                            return true;\n                        }\n                    }\n                    break;\n                case TEXT_TYPE:\n                    if (tag === HostComponent || tag === HostText || tag === HostHoistable || tag === HostSingleton) {\n                        var textContent = getTextContent(fiber);\n                        if (textContent !== null && textContent.indexOf(selector.value) >= 0) {\n                            return true;\n                        }\n                    }\n                    break;\n                case TEST_NAME_TYPE:\n                    if (tag === HostComponent || tag === HostHoistable || tag === HostSingleton) {\n                        var dataTestID = fiber.memoizedProps['data-testname'];\n                        if (typeof dataTestID === 'string' && dataTestID.toLowerCase() === selector.value.toLowerCase()) {\n                            return true;\n                        }\n                    }\n                    break;\n                default:\n                    throw new Error('Invalid selector type specified.');\n            }\n            return false;\n        }\n        function selectorToString(selector) {\n            switch(selector.$$typeof){\n                case COMPONENT_TYPE:\n                    var displayName = getComponentNameFromType(selector.value) || 'Unknown';\n                    return \"<\" + displayName + \">\";\n                case HAS_PSEUDO_CLASS_TYPE:\n                    return \":has(\" + (selectorToString(selector) || '') + \")\";\n                case ROLE_TYPE:\n                    return \"[role=\\\"\" + selector.value + \"\\\"]\";\n                case TEXT_TYPE:\n                    return \"\\\"\" + selector.value + \"\\\"\";\n                case TEST_NAME_TYPE:\n                    return \"[data-testname=\\\"\" + selector.value + \"\\\"]\";\n                default:\n                    throw new Error('Invalid selector type specified.');\n            }\n        }\n        function findPaths(root, selectors) {\n            var matchingFibers = [];\n            var stack = [\n                root,\n                0\n            ];\n            var index = 0;\n            while(index < stack.length){\n                var fiber = stack[index++];\n                var tag = fiber.tag;\n                var selectorIndex = stack[index++];\n                var selector = selectors[selectorIndex];\n                if ((tag === HostComponent || tag === HostHoistable || tag === HostSingleton) && isHiddenSubtree(fiber)) {\n                    continue;\n                } else {\n                    while(selector != null && matchSelector(fiber, selector)){\n                        selectorIndex++;\n                        selector = selectors[selectorIndex];\n                    }\n                }\n                if (selectorIndex === selectors.length) {\n                    matchingFibers.push(fiber);\n                } else {\n                    var child = fiber.child;\n                    while(child !== null){\n                        stack.push(child, selectorIndex);\n                        child = child.sibling;\n                    }\n                }\n            }\n            return matchingFibers;\n        } // Same as findPaths but with eager bailout on first match\n        function hasMatchingPaths(root, selectors) {\n            var stack = [\n                root,\n                0\n            ];\n            var index = 0;\n            while(index < stack.length){\n                var fiber = stack[index++];\n                var tag = fiber.tag;\n                var selectorIndex = stack[index++];\n                var selector = selectors[selectorIndex];\n                if ((tag === HostComponent || tag === HostHoistable || tag === HostSingleton) && isHiddenSubtree(fiber)) {\n                    continue;\n                } else {\n                    while(selector != null && matchSelector(fiber, selector)){\n                        selectorIndex++;\n                        selector = selectors[selectorIndex];\n                    }\n                }\n                if (selectorIndex === selectors.length) {\n                    return true;\n                } else {\n                    var child = fiber.child;\n                    while(child !== null){\n                        stack.push(child, selectorIndex);\n                        child = child.sibling;\n                    }\n                }\n            }\n            return false;\n        }\n        function findAllNodes(hostRoot, selectors) {\n            if (!supportsTestSelectors) {\n                throw new Error('Test selector API is not supported by this renderer.');\n            }\n            var root = findFiberRootForHostRoot(hostRoot);\n            var matchingFibers = findPaths(root, selectors);\n            var instanceRoots = [];\n            var stack = Array.from(matchingFibers);\n            var index = 0;\n            while(index < stack.length){\n                var node = stack[index++];\n                var tag = node.tag;\n                if (tag === HostComponent || tag === HostHoistable || tag === HostSingleton) {\n                    if (isHiddenSubtree(node)) {\n                        continue;\n                    }\n                    instanceRoots.push(node.stateNode);\n                } else {\n                    var child = node.child;\n                    while(child !== null){\n                        stack.push(child);\n                        child = child.sibling;\n                    }\n                }\n            }\n            return instanceRoots;\n        }\n        function getFindAllNodesFailureDescription(hostRoot, selectors) {\n            if (!supportsTestSelectors) {\n                throw new Error('Test selector API is not supported by this renderer.');\n            }\n            var root = findFiberRootForHostRoot(hostRoot);\n            var maxSelectorIndex = 0;\n            var matchedNames = []; // The logic of this loop should be kept in sync with findPaths()\n            var stack = [\n                root,\n                0\n            ];\n            var index = 0;\n            while(index < stack.length){\n                var fiber = stack[index++];\n                var tag = fiber.tag;\n                var selectorIndex = stack[index++];\n                var selector = selectors[selectorIndex];\n                if ((tag === HostComponent || tag === HostHoistable || tag === HostSingleton) && isHiddenSubtree(fiber)) {\n                    continue;\n                } else if (matchSelector(fiber, selector)) {\n                    matchedNames.push(selectorToString(selector));\n                    selectorIndex++;\n                    if (selectorIndex > maxSelectorIndex) {\n                        maxSelectorIndex = selectorIndex;\n                    }\n                }\n                if (selectorIndex < selectors.length) {\n                    var child = fiber.child;\n                    while(child !== null){\n                        stack.push(child, selectorIndex);\n                        child = child.sibling;\n                    }\n                }\n            }\n            if (maxSelectorIndex < selectors.length) {\n                var unmatchedNames = [];\n                for(var i = maxSelectorIndex; i < selectors.length; i++){\n                    unmatchedNames.push(selectorToString(selectors[i]));\n                }\n                return 'findAllNodes was able to match part of the selector:\\n' + (\"  \" + matchedNames.join(' > ') + \"\\n\\n\") + 'No matching component was found for:\\n' + (\"  \" + unmatchedNames.join(' > '));\n            }\n            return null;\n        }\n        function findBoundingRects(hostRoot, selectors) {\n            if (!supportsTestSelectors) {\n                throw new Error('Test selector API is not supported by this renderer.');\n            }\n            var instanceRoots = findAllNodes(hostRoot, selectors);\n            var boundingRects = [];\n            for(var i = 0; i < instanceRoots.length; i++){\n                boundingRects.push(getBoundingRect(instanceRoots[i]));\n            }\n            for(var _i = boundingRects.length - 1; _i > 0; _i--){\n                var targetRect = boundingRects[_i];\n                var targetLeft = targetRect.x;\n                var targetRight = targetLeft + targetRect.width;\n                var targetTop = targetRect.y;\n                var targetBottom = targetTop + targetRect.height;\n                for(var j = _i - 1; j >= 0; j--){\n                    if (_i !== j) {\n                        var otherRect = boundingRects[j];\n                        var otherLeft = otherRect.x;\n                        var otherRight = otherLeft + otherRect.width;\n                        var otherTop = otherRect.y;\n                        var otherBottom = otherTop + otherRect.height; // Merging all rects to the minimums set would be complicated,\n                        // but we can handle the most common cases:\n                        // 1. completely overlapping rects\n                        // 2. adjacent rects that are the same width or height (e.g. items in a list)\n                        //\n                        // Even given the above constraints,\n                        // we still won't end up with the fewest possible rects without doing multiple passes,\n                        // but it's good enough for this purpose.\n                        if (targetLeft >= otherLeft && targetTop >= otherTop && targetRight <= otherRight && targetBottom <= otherBottom) {\n                            // Complete overlapping rects; remove the inner one.\n                            boundingRects.splice(_i, 1);\n                            break;\n                        } else if (targetLeft === otherLeft && targetRect.width === otherRect.width && !(otherBottom < targetTop) && !(otherTop > targetBottom)) {\n                            // Adjacent vertical rects; merge them.\n                            if (otherTop > targetTop) {\n                                otherRect.height += otherTop - targetTop;\n                                otherRect.y = targetTop;\n                            }\n                            if (otherBottom < targetBottom) {\n                                otherRect.height = targetBottom - otherTop;\n                            }\n                            boundingRects.splice(_i, 1);\n                            break;\n                        } else if (targetTop === otherTop && targetRect.height === otherRect.height && !(otherRight < targetLeft) && !(otherLeft > targetRight)) {\n                            // Adjacent horizontal rects; merge them.\n                            if (otherLeft > targetLeft) {\n                                otherRect.width += otherLeft - targetLeft;\n                                otherRect.x = targetLeft;\n                            }\n                            if (otherRight < targetRight) {\n                                otherRect.width = targetRight - otherLeft;\n                            }\n                            boundingRects.splice(_i, 1);\n                            break;\n                        }\n                    }\n                }\n            }\n            return boundingRects;\n        }\n        function focusWithin(hostRoot, selectors) {\n            if (!supportsTestSelectors) {\n                throw new Error('Test selector API is not supported by this renderer.');\n            }\n            var root = findFiberRootForHostRoot(hostRoot);\n            var matchingFibers = findPaths(root, selectors);\n            var stack = Array.from(matchingFibers);\n            var index = 0;\n            while(index < stack.length){\n                var fiber = stack[index++];\n                var tag = fiber.tag;\n                if (isHiddenSubtree(fiber)) {\n                    continue;\n                }\n                if (tag === HostComponent || tag === HostHoistable || tag === HostSingleton) {\n                    var node = fiber.stateNode;\n                    if (setFocusIfFocusable(node)) {\n                        return true;\n                    }\n                }\n                var child = fiber.child;\n                while(child !== null){\n                    stack.push(child);\n                    child = child.sibling;\n                }\n            }\n            return false;\n        }\n        var commitHooks = [];\n        function onCommitRoot() {\n            if (supportsTestSelectors) {\n                commitHooks.forEach(function(commitHook) {\n                    return commitHook();\n                });\n            }\n        }\n        function observeVisibleRects(hostRoot, selectors, callback, options) {\n            if (!supportsTestSelectors) {\n                throw new Error('Test selector API is not supported by this renderer.');\n            }\n            var instanceRoots = findAllNodes(hostRoot, selectors);\n            var _setupIntersectionObs = setupIntersectionObserver(instanceRoots, callback, options), disconnect = _setupIntersectionObs.disconnect, observe = _setupIntersectionObs.observe, unobserve = _setupIntersectionObs.unobserve; // When React mutates the host environment, we may need to change what we're listening to.\n            var commitHook = function() {\n                var nextInstanceRoots = findAllNodes(hostRoot, selectors);\n                instanceRoots.forEach(function(target) {\n                    if (nextInstanceRoots.indexOf(target) < 0) {\n                        unobserve(target);\n                    }\n                });\n                nextInstanceRoots.forEach(function(target) {\n                    if (instanceRoots.indexOf(target) < 0) {\n                        observe(target);\n                    }\n                });\n            };\n            commitHooks.push(commitHook);\n            return {\n                disconnect: function() {\n                    // Stop listening for React mutations:\n                    var index = commitHooks.indexOf(commitHook);\n                    if (index >= 0) {\n                        commitHooks.splice(index, 1);\n                    } // Disconnect the host observer:\n                    disconnect();\n                }\n            };\n        }\n        function isConcurrentActEnvironment() {\n            {\n                var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== 'undefined' ? IS_REACT_ACT_ENVIRONMENT : undefined;\n                if (!isReactActEnvironmentGlobal && ReactSharedInternals.actQueue !== null) {\n                    // TODO: Include link to relevant documentation page.\n                    error('The current testing environment is not configured to support ' + 'act(...)');\n                }\n                return isReactActEnvironmentGlobal;\n            }\n        }\n        var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n        var NoContext = /*             */ 0;\n        var BatchedContext = /*               */ 1;\n        var RenderContext = /*         */ 2;\n        var CommitContext = /*         */ 4;\n        var RootInProgress = 0;\n        var RootFatalErrored = 1;\n        var RootErrored = 2;\n        var RootSuspended = 3;\n        var RootSuspendedWithDelay = 4;\n        var RootCompleted = 5;\n        var RootDidNotComplete = 6; // Describes where we are in the React execution stack\n        var executionContext = NoContext; // The root we're working on\n        var workInProgressRoot = null; // The fiber we're working on\n        var workInProgress = null; // The lanes we're rendering\n        var workInProgressRootRenderLanes = NoLanes;\n        var NotSuspended = 0;\n        var SuspendedOnError = 1;\n        var SuspendedOnData = 2;\n        var SuspendedOnImmediate = 3;\n        var SuspendedOnInstance = 4;\n        var SuspendedOnInstanceAndReadyToContinue = 5;\n        var SuspendedOnDeprecatedThrowPromise = 6;\n        var SuspendedAndReadyToContinue = 7;\n        var SuspendedOnHydration = 8; // When this is true, the work-in-progress fiber just suspended (or errored) and\n        // we've yet to unwind the stack. In some cases, we may yield to the main thread\n        // after this happens. If the fiber is pinged before we resume, we can retry\n        // immediately instead of unwinding the stack.\n        var workInProgressSuspendedReason = NotSuspended;\n        var workInProgressThrownValue = null; // Whether a ping listener was attached during this render. This is slightly\n        // different that whether something suspended, because we don't add multiple\n        // listeners to a promise we've already seen (per root and lane).\n        var workInProgressRootDidAttachPingListener = false; // A contextual version of workInProgressRootRenderLanes. It is a superset of\n        // the lanes that we started working on at the root. When we enter a subtree\n        // that is currently hidden, we add the lanes that would have committed if\n        // the hidden tree hadn't been deferred. This is modified by the\n        // HiddenContext module.\n        //\n        // Most things in the work loop should deal with workInProgressRootRenderLanes.\n        // Most things in begin/complete phases should deal with entangledRenderLanes.\n        var entangledRenderLanes = NoLanes; // Whether to root completed, errored, suspended, etc.\n        var workInProgressRootExitStatus = RootInProgress; // The work left over by components that were visited during this render. Only\n        // includes unprocessed updates, not work in bailed out children.\n        var workInProgressRootSkippedLanes = NoLanes; // Lanes that were updated (in an interleaved event) during this render.\n        var workInProgressRootInterleavedUpdatedLanes = NoLanes; // Lanes that were updated during the render phase (*not* an interleaved event).\n        var workInProgressRootPingedLanes = NoLanes; // If this lane scheduled deferred work, this is the lane of the deferred task.\n        var workInProgressDeferredLane = NoLane; // Errors that are thrown during the render phase.\n        var workInProgressRootConcurrentErrors = null; // These are errors that we recovered from without surfacing them to the UI.\n        // We will log them once the tree commits.\n        var workInProgressRootRecoverableErrors = null; // Tracks when an update occurs during the render phase.\n        var workInProgressRootDidIncludeRecursiveRenderUpdate = false; // Thacks when an update occurs during the commit phase. It's a separate\n        // variable from the one for renders because the commit phase may run\n        // concurrently to a render phase.\n        var didIncludeCommitPhaseUpdate = false; // The most recent time we either committed a fallback, or when a fallback was\n        // filled in with the resolved UI. This lets us throttle the appearance of new\n        // content as it streams in, to minimize jank.\n        // TODO: Think of a better name for this variable?\n        var globalMostRecentFallbackTime = 0;\n        var FALLBACK_THROTTLE_MS = 300; // The absolute time for when we should start giving up on rendering\n        // more and prefer CPU suspense heuristics instead.\n        var workInProgressRootRenderTargetTime = Infinity; // How long a render is supposed to take before we start following CPU\n        // suspense heuristics and opt out of rendering more content.\n        var RENDER_TIMEOUT_MS = 500;\n        var workInProgressTransitions = null;\n        function resetRenderTimer() {\n            workInProgressRootRenderTargetTime = now$1() + RENDER_TIMEOUT_MS;\n        }\n        function getRenderTargetTime() {\n            return workInProgressRootRenderTargetTime;\n        }\n        var legacyErrorBoundariesThatAlreadyFailed = null;\n        var rootDoesHavePassiveEffects = false;\n        var rootWithPendingPassiveEffects = null;\n        var pendingPassiveEffectsLanes = NoLanes;\n        var pendingPassiveProfilerEffects = [];\n        var pendingPassiveEffectsRemainingLanes = NoLanes;\n        var pendingPassiveTransitions = null; // Use these to prevent an infinite loop of nested updates\n        var NESTED_UPDATE_LIMIT = 50;\n        var nestedUpdateCount = 0;\n        var rootWithNestedUpdates = null;\n        var isFlushingPassiveEffects = false;\n        var didScheduleUpdateDuringPassiveEffects = false;\n        var NESTED_PASSIVE_UPDATE_LIMIT = 50;\n        var nestedPassiveUpdateCount = 0;\n        var rootWithPassiveNestedUpdates = null;\n        var isRunningInsertionEffect = false;\n        function getWorkInProgressRoot() {\n            return workInProgressRoot;\n        }\n        function getWorkInProgressRootRenderLanes() {\n            return workInProgressRootRenderLanes;\n        }\n        function isWorkLoopSuspendedOnData() {\n            return workInProgressSuspendedReason === SuspendedOnData;\n        }\n        function requestUpdateLane(fiber) {\n            if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {\n                // This is a render phase update. These are not officially supported. The\n                // old behavior is to give this the same \"thread\" (lanes) as\n                // whatever is currently rendering. So if you call `setState` on a component\n                // that happens later in the same render, it will flush. Ideally, we want to\n                // remove the special case and treat them as if they came from an\n                // interleaved event. Regardless, this pattern is not officially supported.\n                // This behavior is only a fallback. The flag only exists until we can roll\n                // out the setState warning, since existing code might accidentally rely on\n                // the current behavior.\n                return pickArbitraryLane(workInProgressRootRenderLanes);\n            }\n            var transition = requestCurrentTransition();\n            if (transition !== null) {\n                {\n                    if (!transition._updatedFibers) {\n                        transition._updatedFibers = new Set();\n                    }\n                    transition._updatedFibers.add(fiber);\n                }\n                var actionScopeLane = peekEntangledActionLane();\n                return actionScopeLane !== NoLane ? actionScopeLane : // is the first update in that scope. Either way, we need to get a\n                // fresh transition lane.\n                requestTransitionLane();\n            }\n            return eventPriorityToLane(resolveUpdatePriority());\n        }\n        function requestRetryLane(fiber) {\n            return claimNextRetryLane();\n        }\n        function requestDeferredLane() {\n            if (workInProgressDeferredLane === NoLane) {\n                // If there are multiple useDeferredValue hooks in the same render, the\n                // tasks that they spawn should all be batched together, so they should all\n                // receive the same lane.\n                // Check the priority of the current render to decide the priority of the\n                // deferred task.\n                // OffscreenLane is used for prerendering, but we also use OffscreenLane\n                // for incremental hydration. It's given the lowest priority because the\n                // initial HTML is the same as the final UI. But useDeferredValue during\n                // hydration is an exception — we need to upgrade the UI to the final\n                // value. So if we're currently hydrating, we treat it like a transition.\n                var isPrerendering = includesSomeLane(workInProgressRootRenderLanes, OffscreenLane) && !getIsHydrating();\n                if (isPrerendering) {\n                    // There's only one OffscreenLane, so if it contains deferred work, we\n                    // should just reschedule using the same lane.\n                    workInProgressDeferredLane = OffscreenLane;\n                } else {\n                    // Everything else is spawned as a transition.\n                    workInProgressDeferredLane = claimNextTransitionLane();\n                }\n            } // Mark the parent Suspense boundary so it knows to spawn the deferred lane.\n            var suspenseHandler = getSuspenseHandler();\n            if (suspenseHandler !== null) {\n                // TODO: As an optimization, we shouldn't entangle the lanes at the root; we\n                // can entangle them using the baseLanes of the Suspense boundary instead.\n                // We only need to do something special if there's no Suspense boundary.\n                suspenseHandler.flags |= DidDefer;\n            }\n            return workInProgressDeferredLane;\n        }\n        function peekDeferredLane() {\n            return workInProgressDeferredLane;\n        }\n        function scheduleUpdateOnFiber(root, fiber, lane) {\n            {\n                if (isRunningInsertionEffect) {\n                    error('useInsertionEffect must not schedule updates.');\n                }\n            }\n            {\n                if (isFlushingPassiveEffects) {\n                    didScheduleUpdateDuringPassiveEffects = true;\n                }\n            }\n            // finish loading.\n            if (root === workInProgressRoot && workInProgressSuspendedReason === SuspendedOnData || // Suspended commit phase\n            root.cancelPendingCommit !== null) {\n                // The incoming update might unblock the current render. Interrupt the\n                // current attempt and restart from the top.\n                prepareFreshStack(root, NoLanes);\n                markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane);\n            } // Mark that the root has a pending update.\n            markRootUpdated(root, lane);\n            if ((executionContext & RenderContext) !== NoLanes && root === workInProgressRoot) {\n                // This update was dispatched during the render phase. This is a mistake\n                // if the update originates from user space (with the exception of local\n                // hook updates, which are handled differently and don't reach this\n                // function), but there are some internal React features that use this as\n                // an implementation detail, like selective hydration.\n                warnAboutRenderPhaseUpdatesInDEV(fiber); // Track lanes that were updated during the render phase\n            } else {\n                // This is a normal update, scheduled from outside the render phase. For\n                // example, during an input event.\n                {\n                    if (isDevToolsPresent) {\n                        addFiberToLanesMap(root, fiber, lane);\n                    }\n                }\n                warnIfUpdatesNotWrappedWithActDEV(fiber);\n                if (root === workInProgressRoot) {\n                    // Received an update to a tree that's in the middle of rendering. Mark\n                    // that there was an interleaved update work on this root.\n                    if ((executionContext & RenderContext) === NoContext) {\n                        workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);\n                    }\n                    if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n                        // The root already suspended with a delay, which means this render\n                        // definitely won't finish. Since we have a new update, let's mark it as\n                        // suspended now, right before marking the incoming update. This has the\n                        // effect of interrupting the current render and switching to the update.\n                        // TODO: Make sure this doesn't override pings that happen while we've\n                        // already started rendering.\n                        markRootSuspended(root, workInProgressRootRenderLanes, workInProgressDeferredLane);\n                    }\n                }\n                ensureRootIsScheduled(root);\n                if (lane === SyncLane && executionContext === NoContext && !disableLegacyMode && (fiber.mode & ConcurrentMode) === NoMode) {\n                    if (ReactSharedInternals.isBatchingLegacy) ;\n                    else {\n                        // Flush the synchronous work now, unless we're already working or inside\n                        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n                        // scheduleCallbackForFiber to preserve the ability to schedule a callback\n                        // without immediately flushing it. We only do this for user-initiated\n                        // updates, to preserve historical behavior of legacy mode.\n                        resetRenderTimer();\n                    }\n                }\n            }\n        }\n        function scheduleInitialHydrationOnRoot(root, lane) {\n            // This is a special fork of scheduleUpdateOnFiber that is only used to\n            // schedule the initial hydration of a root that has just been created. Most\n            // of the stuff in scheduleUpdateOnFiber can be skipped.\n            //\n            // The main reason for this separate path, though, is to distinguish the\n            // initial children from subsequent updates. In fully client-rendered roots\n            // (createRoot instead of hydrateRoot), all top-level renders are modeled as\n            // updates, but hydration roots are special because the initial render must\n            // match what was rendered on the server.\n            var current = root.current;\n            current.lanes = lane;\n            markRootUpdated(root, lane);\n            ensureRootIsScheduled(root);\n        }\n        function isUnsafeClassRenderPhaseUpdate(fiber) {\n            // Check if this is a render phase update. Only called by class components,\n            // which special (deprecated) behavior for UNSAFE_componentWillReceive props.\n            return (executionContext & RenderContext) !== NoContext;\n        } // This is the entry point for every concurrent task, i.e. anything that\n        // goes through Scheduler.\n        function performConcurrentWorkOnRoot(root, didTimeout) {\n            {\n                resetNestedUpdateFlag();\n            }\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                throw new Error('Should not already be working.');\n            } // Flush any pending passive effects before deciding which lanes to work on,\n            // in case they schedule additional work.\n            var originalCallbackNode = root.callbackNode;\n            var didFlushPassiveEffects = flushPassiveEffects();\n            if (didFlushPassiveEffects) {\n                // Something in the passive effect phase may have canceled the current task.\n                // Check if the task node for this root was changed.\n                if (root.callbackNode !== originalCallbackNode) {\n                    // The current task was canceled. Exit. We don't need to call\n                    // `ensureRootIsScheduled` because the check above implies either that\n                    // there's a new task, or that there's no remaining work on this root.\n                    return null;\n                }\n            } // Determine the next lanes to work on, using the fields stored\n            // on the root.\n            // TODO: This was already computed in the caller. Pass it as an argument.\n            var lanes = getNextLanes(root, root === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);\n            if (lanes === NoLanes) {\n                // Defensive coding. This is never expected to happen.\n                return null;\n            } // We disable time-slicing in some cases: if the work has been CPU-bound\n            // for too long (\"expired\" work, to prevent starvation), or we're in\n            // sync-updates-by-default mode.\n            // TODO: We only check `didTimeout` defensively, to account for a Scheduler\n            // bug we're still investigating. Once the bug in Scheduler is fixed,\n            // we can remove this, since we track expiration ourselves.\n            var shouldTimeSlice = !includesBlockingLane(root, lanes) && !includesExpiredLane(root, lanes) && !didTimeout;\n            var exitStatus = shouldTimeSlice ? renderRootConcurrent(root, lanes) : renderRootSync(root, lanes);\n            if (exitStatus !== RootInProgress) {\n                var renderWasConcurrent = shouldTimeSlice;\n                do {\n                    if (exitStatus === RootDidNotComplete) {\n                        // The render unwound without completing the tree. This happens in special\n                        // cases where need to exit the current render without producing a\n                        // consistent tree or committing.\n                        markRootSuspended(root, lanes, NoLane);\n                    } else {\n                        // The render completed.\n                        // Check if this render may have yielded to a concurrent event, and if so,\n                        // confirm that any newly rendered stores are consistent.\n                        // TODO: It's possible that even a concurrent render may never have yielded\n                        // to the main thread, if it was fast enough, or if it expired. We could\n                        // skip the consistency check in that case, too.\n                        var finishedWork = root.current.alternate;\n                        if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {\n                            // A store was mutated in an interleaved event. Render again,\n                            // synchronously, to block further mutations.\n                            exitStatus = renderRootSync(root, lanes); // We assume the tree is now consistent because we didn't yield to any\n                            // concurrent events.\n                            renderWasConcurrent = false; // Need to check the exit status again.\n                            continue;\n                        } // Check if something threw\n                        if (exitStatus === RootErrored) {\n                            var lanesThatJustErrored = lanes;\n                            var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root, lanesThatJustErrored);\n                            if (errorRetryLanes !== NoLanes) {\n                                lanes = errorRetryLanes;\n                                exitStatus = recoverFromConcurrentError(root, lanesThatJustErrored, errorRetryLanes);\n                                renderWasConcurrent = false; // Need to check the exit status again.\n                                if (exitStatus !== RootErrored) {\n                                    continue;\n                                }\n                            }\n                        }\n                        if (exitStatus === RootFatalErrored) {\n                            prepareFreshStack(root, NoLanes);\n                            markRootSuspended(root, lanes, NoLane);\n                            break;\n                        } // We now have a consistent tree. The next step is either to commit it,\n                        // or, if something suspended, wait to commit it after a timeout.\n                        root.finishedWork = finishedWork;\n                        root.finishedLanes = lanes;\n                        finishConcurrentRender(root, exitStatus, finishedWork, lanes);\n                    }\n                    break;\n                }while (true);\n            }\n            ensureRootIsScheduled(root);\n            return getContinuationForRoot(root, originalCallbackNode);\n        }\n        function recoverFromConcurrentError(root, originallyAttemptedLanes, errorRetryLanes) {\n            // If an error occurred during hydration, discard server response and fall\n            // back to client side render.\n            // Before rendering again, save the errors from the previous attempt.\n            var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;\n            var wasRootDehydrated = supportsHydration && isRootDehydrated(root);\n            if (wasRootDehydrated) {\n                // The shell failed to hydrate. Set a flag to force a client rendering\n                // during the next attempt. To do this, we call prepareFreshStack now\n                // to create the root work-in-progress fiber. This is a bit weird in terms\n                // of factoring, because it relies on renderRootSync not calling\n                // prepareFreshStack again in the call below, which happens because the\n                // root and lanes haven't changed.\n                //\n                // TODO: I think what we should do is set ForceClientRender inside\n                // throwException, like we do for nested Suspense boundaries. The reason\n                // it's here instead is so we can switch to the synchronous work loop, too.\n                // Something to consider for a future refactor.\n                var rootWorkInProgress = prepareFreshStack(root, errorRetryLanes);\n                rootWorkInProgress.flags |= ForceClientRender;\n            }\n            var exitStatus = renderRootSync(root, errorRetryLanes);\n            if (exitStatus !== RootErrored) {\n                // Successfully finished rendering on retry\n                if (workInProgressRootDidAttachPingListener && !wasRootDehydrated) {\n                    // During the synchronous render, we attached additional ping listeners.\n                    // This is highly suggestive of an uncached promise (though it's not the\n                    // only reason this would happen). If it was an uncached promise, then\n                    // it may have masked a downstream error from ocurring without actually\n                    // fixing it. Example:\n                    //\n                    //    use(Promise.resolve('uncached'))\n                    //    throw new Error('Oops!')\n                    //\n                    // When this happens, there's a conflict between blocking potential\n                    // concurrent data races and unwrapping uncached promise values. We\n                    // have to choose one or the other. Because the data race recovery is\n                    // a last ditch effort, we'll disable it.\n                    root.errorRecoveryDisabledLanes = mergeLanes(root.errorRecoveryDisabledLanes, originallyAttemptedLanes); // Mark the current render as suspended and force it to restart. Once\n                    // these lanes finish successfully, we'll re-enable the error recovery\n                    // mechanism for subsequent updates.\n                    workInProgressRootInterleavedUpdatedLanes |= originallyAttemptedLanes;\n                    return RootSuspendedWithDelay;\n                } // The errors from the failed first attempt have been recovered. Add\n                // them to the collection of recoverable errors. We'll log them in the\n                // commit phase.\n                var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;\n                workInProgressRootRecoverableErrors = errorsFromFirstAttempt; // The errors from the second attempt should be queued after the errors\n                // from the first attempt, to preserve the causal sequence.\n                if (errorsFromSecondAttempt !== null) {\n                    queueRecoverableErrors(errorsFromSecondAttempt);\n                }\n            }\n            return exitStatus;\n        }\n        function queueRecoverableErrors(errors) {\n            if (workInProgressRootRecoverableErrors === null) {\n                workInProgressRootRecoverableErrors = errors;\n            } else {\n                // $FlowFixMe[method-unbinding]\n                workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);\n            }\n        }\n        function finishConcurrentRender(root, exitStatus, finishedWork, lanes) {\n            // TODO: The fact that most of these branches are identical suggests that some\n            // of the exit statuses are not best modeled as exit statuses and should be\n            // tracked orthogonally.\n            switch(exitStatus){\n                case RootInProgress:\n                case RootFatalErrored:\n                    {\n                        throw new Error('Root did not complete. This is a bug in React.');\n                    }\n                case RootSuspendedWithDelay:\n                    {\n                        if (includesOnlyTransitions(lanes)) {\n                            // This is a transition, so we should exit without committing a\n                            // placeholder and without scheduling a timeout. Delay indefinitely\n                            // until we receive more data.\n                            markRootSuspended(root, lanes, workInProgressDeferredLane);\n                            return;\n                        } // Commit the placeholder.\n                        break;\n                    }\n                case RootErrored:\n                    {\n                        // This render errored. Ignore any recoverable errors because we weren't actually\n                        // able to recover. Instead, whatever the final errors were is the ones we log.\n                        // This ensures that we only log the actual client side error if it's just a plain\n                        // error thrown from a component on the server and the client.\n                        workInProgressRootRecoverableErrors = null;\n                        break;\n                    }\n                case RootSuspended:\n                case RootCompleted:\n                    {\n                        break;\n                    }\n                default:\n                    {\n                        throw new Error('Unknown root exit status.');\n                    }\n            }\n            if (shouldForceFlushFallbacksInDEV()) {\n                // We're inside an `act` scope. Commit immediately.\n                commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, workInProgressDeferredLane);\n            } else {\n                if (includesOnlyRetries(lanes) && alwaysThrottleRetries) {\n                    // This render only included retries, no updates. Throttle committing\n                    // retries so that we don't show too many loading states too quickly.\n                    var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now$1(); // Don't bother with a very short suspense time.\n                    if (msUntilTimeout > 10) {\n                        markRootSuspended(root, lanes, workInProgressDeferredLane);\n                        var nextLanes = getNextLanes(root, NoLanes);\n                        if (nextLanes !== NoLanes) {\n                            // There's additional work we can do on this root. We might as well\n                            // attempt to work on that while we're suspended.\n                            return;\n                        } // The render is suspended, it hasn't timed out, and there's no\n                        // lower priority work to do. Instead of committing the fallback\n                        // immediately, wait for more data to arrive.\n                        // TODO: Combine retry throttling with Suspensey commits. Right now they\n                        // run one after the other.\n                        root.timeoutHandle = scheduleTimeout(commitRootWhenReady.bind(null, root, finishedWork, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane), msUntilTimeout);\n                        return;\n                    }\n                }\n                commitRootWhenReady(root, finishedWork, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, lanes, workInProgressDeferredLane);\n            }\n        }\n        function commitRootWhenReady(root, finishedWork, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, lanes, spawnedLane) {\n            // TODO: Combine retry throttling with Suspensey commits. Right now they run\n            // one after the other.\n            var BothVisibilityAndMaySuspendCommit = Visibility | MaySuspendCommit;\n            var subtreeFlags = finishedWork.subtreeFlags;\n            if (subtreeFlags & ShouldSuspendCommit || (subtreeFlags & BothVisibilityAndMaySuspendCommit) === BothVisibilityAndMaySuspendCommit) {\n                // Before committing, ask the renderer whether the host tree is ready.\n                // If it's not, we'll wait until it notifies us.\n                startSuspendingCommit(); // This will walk the completed fiber tree and attach listeners to all\n                // the suspensey resources. The renderer is responsible for accumulating\n                // all the load events. This all happens in a single synchronous\n                // transaction, so it track state in its own module scope.\n                accumulateSuspenseyCommit(finishedWork); // At the end, ask the renderer if it's ready to commit, or if we should\n                // suspend. If it's not ready, it will return a callback to subscribe to\n                // a ready event.\n                var schedulePendingCommit = waitForCommitToBeReady();\n                if (schedulePendingCommit !== null) {\n                    // NOTE: waitForCommitToBeReady returns a subscribe function so that we\n                    // only allocate a function if the commit isn't ready yet. The other\n                    // pattern would be to always pass a callback to waitForCommitToBeReady.\n                    // Not yet ready to commit. Delay the commit until the renderer notifies\n                    // us that it's ready. This will be canceled if we start work on the\n                    // root again.\n                    root.cancelPendingCommit = schedulePendingCommit(commitRoot.bind(null, root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate));\n                    markRootSuspended(root, lanes, spawnedLane);\n                    return;\n                }\n            } // Otherwise, commit immediately.\n            commitRoot(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane);\n        }\n        function isRenderConsistentWithExternalStores(finishedWork) {\n            // Search the rendered tree for external store reads, and check whether the\n            // stores were mutated in a concurrent event. Intentionally using an iterative\n            // loop instead of recursion so we can exit early.\n            var node = finishedWork;\n            while(true){\n                if (node.flags & StoreConsistency) {\n                    var updateQueue = node.updateQueue;\n                    if (updateQueue !== null) {\n                        var checks = updateQueue.stores;\n                        if (checks !== null) {\n                            for(var i = 0; i < checks.length; i++){\n                                var check = checks[i];\n                                var getSnapshot = check.getSnapshot;\n                                var renderedValue = check.value;\n                                try {\n                                    if (!objectIs(getSnapshot(), renderedValue)) {\n                                        // Found an inconsistent store.\n                                        return false;\n                                    }\n                                } catch (error) {\n                                    // If `getSnapshot` throws, return `false`. This will schedule\n                                    // a re-render, and the error will be rethrown during render.\n                                    return false;\n                                }\n                            }\n                        }\n                    }\n                }\n                var child = node.child;\n                if (node.subtreeFlags & StoreConsistency && child !== null) {\n                    child.return = node;\n                    node = child;\n                    continue;\n                }\n                if (node === finishedWork) {\n                    return true;\n                }\n                while(node.sibling === null){\n                    if (node.return === null || node.return === finishedWork) {\n                        return true;\n                    }\n                    node = node.return;\n                }\n                node.sibling.return = node.return;\n                node = node.sibling;\n            } // Flow doesn't know this is unreachable, but eslint does\n            // eslint-disable-next-line no-unreachable\n            return true;\n        } // The extra indirections around markRootUpdated and markRootSuspended is\n        // needed to avoid a circular dependency between this module and\n        // ReactFiberLane. There's probably a better way to split up these modules and\n        // avoid this problem. Perhaps all the root-marking functions should move into\n        // the work loop.\n        function markRootUpdated(root, updatedLanes) {\n            markRootUpdated$1(root, updatedLanes);\n            {\n                // Check for recursive updates\n                if (executionContext & RenderContext) {\n                    workInProgressRootDidIncludeRecursiveRenderUpdate = true;\n                } else if (executionContext & CommitContext) {\n                    didIncludeCommitPhaseUpdate = true;\n                }\n                throwIfInfiniteUpdateLoopDetected();\n            }\n        }\n        function markRootPinged(root, pingedLanes) {\n            markRootPinged$1(root, pingedLanes);\n            {\n                // Check for recursive pings. Pings are conceptually different from updates in\n                // other contexts but we call it an \"update\" in this context because\n                // repeatedly pinging a suspended render can cause a recursive render loop.\n                // The relevant property is that it can result in a new render attempt\n                // being scheduled.\n                if (executionContext & RenderContext) {\n                    workInProgressRootDidIncludeRecursiveRenderUpdate = true;\n                } else if (executionContext & CommitContext) {\n                    didIncludeCommitPhaseUpdate = true;\n                }\n                throwIfInfiniteUpdateLoopDetected();\n            }\n        }\n        function markRootSuspended(root, suspendedLanes, spawnedLane) {\n            // When suspending, we should always exclude lanes that were pinged or (more\n            // rarely, since we try to avoid it) updated during the render phase.\n            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);\n            suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);\n            markRootSuspended$1(root, suspendedLanes, spawnedLane);\n        } // This is the entry point for synchronous tasks that don't go\n        // through Scheduler\n        function performSyncWorkOnRoot(root, lanes) {\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                throw new Error('Should not already be working.');\n            }\n            var didFlushPassiveEffects = flushPassiveEffects();\n            if (didFlushPassiveEffects) {\n                // If passive effects were flushed, exit to the outer work loop in the root\n                // scheduler, so we can recompute the priority.\n                // TODO: We don't actually need this `ensureRootIsScheduled` call because\n                // this path is only reachable if the root is already part of the schedule.\n                // I'm including it only for consistency with the other exit points from\n                // this function. Can address in a subsequent refactor.\n                ensureRootIsScheduled(root);\n                return null;\n            }\n            {\n                syncNestedUpdateFlag();\n            }\n            var exitStatus = renderRootSync(root, lanes);\n            if (exitStatus === RootErrored) {\n                // If something threw an error, try rendering one more time. We'll render\n                // synchronously to block concurrent data mutations, and we'll includes\n                // all pending updates are included. If it still fails after the second\n                // attempt, we'll give up and commit the resulting tree.\n                var originallyAttemptedLanes = lanes;\n                var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root, originallyAttemptedLanes);\n                if (errorRetryLanes !== NoLanes) {\n                    lanes = errorRetryLanes;\n                    exitStatus = recoverFromConcurrentError(root, originallyAttemptedLanes, errorRetryLanes);\n                }\n            }\n            if (exitStatus === RootFatalErrored) {\n                prepareFreshStack(root, NoLanes);\n                markRootSuspended(root, lanes, NoLane);\n                ensureRootIsScheduled(root);\n                return null;\n            }\n            if (exitStatus === RootDidNotComplete) {\n                // The render unwound without completing the tree. This happens in special\n                // cases where need to exit the current render without producing a\n                // consistent tree or committing.\n                markRootSuspended(root, lanes, workInProgressDeferredLane);\n                ensureRootIsScheduled(root);\n                return null;\n            } // We now have a consistent tree. Because this is a sync render, we\n            // will commit it even if something suspended.\n            var finishedWork = root.current.alternate;\n            root.finishedWork = finishedWork;\n            root.finishedLanes = lanes;\n            commitRoot(root, workInProgressRootRecoverableErrors, workInProgressTransitions, workInProgressRootDidIncludeRecursiveRenderUpdate, workInProgressDeferredLane); // Before exiting, make sure there's a callback scheduled for the next\n            // pending level.\n            ensureRootIsScheduled(root);\n            return null;\n        }\n        function flushRoot(root, lanes) {\n            if (lanes !== NoLanes) {\n                upgradePendingLanesToSync(root, lanes);\n                ensureRootIsScheduled(root);\n                if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n                    resetRenderTimer(); // TODO: For historical reasons this flushes all sync work across all\n                    // roots. It shouldn't really matter either way, but we could change this\n                    // to only flush the given root.\n                    flushSyncWorkOnAllRoots();\n                }\n            }\n        }\n        function getExecutionContext() {\n            return executionContext;\n        }\n        function deferredUpdates(fn) {\n            var prevTransition = ReactSharedInternals.T;\n            var previousPriority = getCurrentUpdatePriority();\n            try {\n                setCurrentUpdatePriority(DefaultEventPriority);\n                ReactSharedInternals.T = null;\n                return fn();\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactSharedInternals.T = prevTransition;\n            }\n        }\n        function batchedUpdates(fn, a) {\n            {\n                // batchedUpdates is a no-op now, but there's still some internal react-dom\n                // code calling it, that we can't remove until we remove legacy mode.\n                return fn(a);\n            }\n        }\n        function discreteUpdates(fn, a, b, c, d) {\n            var prevTransition = ReactSharedInternals.T;\n            var previousPriority = getCurrentUpdatePriority();\n            try {\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                ReactSharedInternals.T = null;\n                return fn(a, b, c, d);\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactSharedInternals.T = prevTransition;\n                if (executionContext === NoContext) {\n                    resetRenderTimer();\n                }\n            }\n        } // Overload the definition to the two valid signatures.\n        // Warning, this opts-out of checking the function body.\n        // eslint-disable-next-line no-unused-vars\n        // eslint-disable-next-line no-redeclare\n        // eslint-disable-next-line no-redeclare\n        function flushSyncFromReconciler(fn) {\n            // In legacy mode, we flush pending passive effects at the beginning of the\n            // next event, not at the end of the previous one.\n            if (rootWithPendingPassiveEffects !== null && !disableLegacyMode && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {\n                flushPassiveEffects();\n            }\n            var prevExecutionContext = executionContext;\n            executionContext |= BatchedContext;\n            var prevTransition = ReactSharedInternals.T;\n            var previousPriority = getCurrentUpdatePriority();\n            try {\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                ReactSharedInternals.T = null;\n                if (fn) {\n                    return fn();\n                } else {\n                    return undefined;\n                }\n            } finally{\n                setCurrentUpdatePriority(previousPriority);\n                ReactSharedInternals.T = prevTransition;\n                executionContext = prevExecutionContext; // Flush the immediate callbacks that were scheduled during this batch.\n                // Note that this will happen even if batchedUpdates is higher up\n                // the stack.\n                if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n                    flushSyncWorkOnAllRoots();\n                }\n            }\n        } // If called outside of a render or commit will flush all sync work on all roots\n        // Returns whether the the call was during a render or not\n        function flushSyncWork() {\n            if ((executionContext & (RenderContext | CommitContext)) === NoContext) {\n                flushSyncWorkOnAllRoots();\n                return false;\n            }\n            return true;\n        }\n        function isAlreadyRendering() {\n            // Used by the renderer to print a warning if certain APIs are called from\n            // the wrong context.\n            return (executionContext & (RenderContext | CommitContext)) !== NoContext;\n        }\n        // hidden subtree. The stack logic is managed there because that's the only\n        // place that ever modifies it. Which module it lives in doesn't matter for\n        // performance because this function will get inlined regardless\n        function setEntangledRenderLanes(newEntangledRenderLanes) {\n            entangledRenderLanes = newEntangledRenderLanes;\n        }\n        function getEntangledRenderLanes() {\n            return entangledRenderLanes;\n        }\n        function resetWorkInProgressStack() {\n            if (workInProgress === null) return;\n            var interruptedWork;\n            if (workInProgressSuspendedReason === NotSuspended) {\n                // Normal case. Work-in-progress hasn't started yet. Unwind all\n                // its parents.\n                interruptedWork = workInProgress.return;\n            } else {\n                // Work-in-progress is in suspended state. Reset the work loop and unwind\n                // both the suspended fiber and all its parents.\n                resetSuspendedWorkLoopOnUnwind(workInProgress);\n                interruptedWork = workInProgress;\n            }\n            while(interruptedWork !== null){\n                var current = interruptedWork.alternate;\n                unwindInterruptedWork(current, interruptedWork);\n                interruptedWork = interruptedWork.return;\n            }\n            workInProgress = null;\n        }\n        function prepareFreshStack(root, lanes) {\n            root.finishedWork = null;\n            root.finishedLanes = NoLanes;\n            var timeoutHandle = root.timeoutHandle;\n            if (timeoutHandle !== noTimeout) {\n                // The root previous suspended and scheduled a timeout to commit a fallback\n                // state. Now that we have additional work, cancel the timeout.\n                root.timeoutHandle = noTimeout; // $FlowFixMe[incompatible-call] Complains noTimeout is not a TimeoutID, despite the check above\n                cancelTimeout(timeoutHandle);\n            }\n            var cancelPendingCommit = root.cancelPendingCommit;\n            if (cancelPendingCommit !== null) {\n                root.cancelPendingCommit = null;\n                cancelPendingCommit();\n            }\n            resetWorkInProgressStack();\n            workInProgressRoot = root;\n            var rootWorkInProgress = createWorkInProgress(root.current, null);\n            workInProgress = rootWorkInProgress;\n            workInProgressRootRenderLanes = lanes;\n            workInProgressSuspendedReason = NotSuspended;\n            workInProgressThrownValue = null;\n            workInProgressRootDidAttachPingListener = false;\n            workInProgressRootExitStatus = RootInProgress;\n            workInProgressRootSkippedLanes = NoLanes;\n            workInProgressRootInterleavedUpdatedLanes = NoLanes;\n            workInProgressRootPingedLanes = NoLanes;\n            workInProgressDeferredLane = NoLane;\n            workInProgressRootConcurrentErrors = null;\n            workInProgressRootRecoverableErrors = null;\n            workInProgressRootDidIncludeRecursiveRenderUpdate = false; // Get the lanes that are entangled with whatever we're about to render. We\n            // track these separately so we can distinguish the priority of the render\n            // task from the priority of the lanes it is entangled with. For example, a\n            // transition may not be allowed to finish unless it includes the Sync lane,\n            // which is currently suspended. We should be able to render the Transition\n            // and Sync lane in the same batch, but at Transition priority, because the\n            // Sync lane already suspended.\n            entangledRenderLanes = getEntangledLanes(root, lanes);\n            finishQueueingConcurrentUpdates();\n            {\n                ReactStrictModeWarnings.discardPendingWarnings();\n            }\n            return rootWorkInProgress;\n        }\n        function resetSuspendedWorkLoopOnUnwind(fiber) {\n            // Reset module-level state that was set during the render phase.\n            resetContextDependencies();\n            resetHooksOnUnwind(fiber);\n            resetChildReconcilerOnUnwind();\n        }\n        function handleThrow(root, thrownValue) {\n            // A component threw an exception. Usually this is because it suspended, but\n            // it also includes regular program errors.\n            //\n            // We're either going to unwind the stack to show a Suspense or error\n            // boundary, or we're going to replay the component again. Like after a\n            // promise resolves.\n            //\n            // Until we decide whether we're going to unwind or replay, we should preserve\n            // the current state of the work loop without resetting anything.\n            //\n            // If we do decide to unwind the stack, module-level variables will be reset\n            // in resetSuspendedWorkLoopOnUnwind.\n            // These should be reset immediately because they're only supposed to be set\n            // when React is executing user code.\n            resetHooksAfterThrow();\n            {\n                resetCurrentFiber();\n            }\n            if (thrownValue === SuspenseException) {\n                // This is a special type of exception used for Suspense. For historical\n                // reasons, the rest of the Suspense implementation expects the thrown value\n                // to be a thenable, because before `use` existed that was the (unstable)\n                // API for suspending. This implementation detail can change later, once we\n                // deprecate the old API in favor of `use`.\n                thrownValue = getSuspendedThenable();\n                workInProgressSuspendedReason = shouldRemainOnPreviousScreen() && // Check if there are other pending updates that might possibly unblock this\n                // component from suspending. This mirrors the check in\n                // renderDidSuspendDelayIfPossible. We should attempt to unify them somehow.\n                // TODO: Consider unwinding immediately, using the\n                // SuspendedOnHydration mechanism.\n                !includesNonIdleWork(workInProgressRootSkippedLanes) && !includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes) ? SuspendedOnData : // immediately resolved (i.e. in a microtask). Otherwise, trigger the\n                // nearest Suspense fallback.\n                SuspendedOnImmediate;\n            } else if (thrownValue === SuspenseyCommitException) {\n                thrownValue = getSuspendedThenable();\n                workInProgressSuspendedReason = SuspendedOnInstance;\n            } else if (thrownValue === SelectiveHydrationException) {\n                // An update flowed into a dehydrated boundary. Before we can apply the\n                // update, we need to finish hydrating. Interrupt the work-in-progress\n                // render so we can restart at the hydration lane.\n                //\n                // The ideal implementation would be able to switch contexts without\n                // unwinding the current stack.\n                //\n                // We could name this something more general but as of now it's the only\n                // case where we think this should happen.\n                workInProgressSuspendedReason = SuspendedOnHydration;\n            } else {\n                // This is a regular error.\n                var isWakeable = thrownValue !== null && typeof thrownValue === 'object' && typeof thrownValue.then === 'function';\n                workInProgressSuspendedReason = isWakeable ? // This has slightly different behavior than suspending with `use`.\n                SuspendedOnDeprecatedThrowPromise : // suspended, we must clear the thenable state to unblock the work loop.\n                SuspendedOnError;\n            }\n            workInProgressThrownValue = thrownValue;\n            var erroredWork = workInProgress;\n            if (erroredWork === null) {\n                // This is a fatal error\n                workInProgressRootExitStatus = RootFatalErrored;\n                logUncaughtError(root, createCapturedValueAtFiber(thrownValue, root.current));\n                return;\n            }\n            if (erroredWork.mode & ProfileMode) {\n                // Record the time spent rendering before an error was thrown. This\n                // avoids inaccurate Profiler durations in the case of a\n                // suspended render.\n                stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);\n            }\n            {\n                markComponentRenderStopped();\n                switch(workInProgressSuspendedReason){\n                    case SuspendedOnError:\n                        {\n                            markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);\n                            break;\n                        }\n                    case SuspendedOnData:\n                    case SuspendedOnImmediate:\n                    case SuspendedOnDeprecatedThrowPromise:\n                    case SuspendedAndReadyToContinue:\n                        {\n                            var wakeable = thrownValue;\n                            markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);\n                            break;\n                        }\n                }\n            }\n        }\n        function shouldRemainOnPreviousScreen() {\n            // This is asking whether it's better to suspend the transition and remain\n            // on the previous screen, versus showing a fallback as soon as possible. It\n            // takes into account both the priority of render and also whether showing a\n            // fallback would produce a desirable user experience.\n            var handler = getSuspenseHandler();\n            if (handler === null) {\n                // There's no Suspense boundary that can provide a fallback. We have no\n                // choice but to remain on the previous screen.\n                // NOTE: We do this even for sync updates, for lack of any better option. In\n                // the future, we may change how we handle this, like by putting the whole\n                // root into a \"detached\" mode.\n                return true;\n            } // TODO: Once `use` has fully replaced the `throw promise` pattern, we should\n            // be able to remove the equivalent check in finishConcurrentRender, and rely\n            // just on this one.\n            if (includesOnlyTransitions(workInProgressRootRenderLanes)) {\n                if (getShellBoundary() === null) {\n                    // We're rendering inside the \"shell\" of the app. Activating the nearest\n                    // fallback would cause visible content to disappear. It's better to\n                    // suspend the transition and remain on the previous screen.\n                    return true;\n                } else {\n                    // We're rendering content that wasn't part of the previous screen.\n                    // Rather than block the transition, it's better to show a fallback as\n                    // soon as possible. The appearance of any nested fallbacks will be\n                    // throttled to avoid jank.\n                    return false;\n                }\n            }\n            if (includesOnlyRetries(workInProgressRootRenderLanes) || // In this context, an OffscreenLane counts as a Retry\n            // TODO: It's become increasingly clear that Retries and Offscreen are\n            // deeply connected. They probably can be unified further.\n            includesSomeLane(workInProgressRootRenderLanes, OffscreenLane)) {\n                // During a retry, we can suspend rendering if the nearest Suspense boundary\n                // is the boundary of the \"shell\", because we're guaranteed not to block\n                // any new content from appearing.\n                //\n                // The reason we must check if this is a retry is because it guarantees\n                // that suspending the work loop won't block an actual update, because\n                // retries don't \"update\" anything; they fill in fallbacks that were left\n                // behind by a previous transition.\n                return handler === getShellBoundary();\n            } // For all other Lanes besides Transitions and Retries, we should not wait\n            // for the data to load.\n            return false;\n        }\n        function pushDispatcher(container) {\n            var prevDispatcher = ReactSharedInternals.H;\n            ReactSharedInternals.H = ContextOnlyDispatcher;\n            if (prevDispatcher === null) {\n                // The React isomorphic package does not include a default dispatcher.\n                // Instead the first renderer will lazily attach one, in order to give\n                // nicer error messages.\n                return ContextOnlyDispatcher;\n            } else {\n                return prevDispatcher;\n            }\n        }\n        function popDispatcher(prevDispatcher) {\n            ReactSharedInternals.H = prevDispatcher;\n        }\n        function pushAsyncDispatcher() {\n            {\n                var prevAsyncDispatcher = ReactSharedInternals.A;\n                ReactSharedInternals.A = DefaultAsyncDispatcher;\n                return prevAsyncDispatcher;\n            }\n        }\n        function popAsyncDispatcher(prevAsyncDispatcher) {\n            {\n                ReactSharedInternals.A = prevAsyncDispatcher;\n            }\n        }\n        function markCommitTimeOfFallback() {\n            globalMostRecentFallbackTime = now$1();\n        }\n        function markSkippedUpdateLanes(lane) {\n            workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);\n        }\n        function renderDidSuspend() {\n            if (workInProgressRootExitStatus === RootInProgress) {\n                workInProgressRootExitStatus = RootSuspended;\n            }\n        }\n        function renderDidSuspendDelayIfPossible() {\n            workInProgressRootExitStatus = RootSuspendedWithDelay; // Check if there are updates that we skipped tree that might have unblocked\n            // this render.\n            if ((includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes)) && workInProgressRoot !== null) {\n                // Mark the current render as suspended so that we switch to working on\n                // the updates that were skipped. Usually we only suspend at the end of\n                // the render phase.\n                // TODO: We should probably always mark the root as suspended immediately\n                // (inside this function), since by suspending at the end of the render\n                // phase introduces a potential mistake where we suspend lanes that were\n                // pinged or updated while we were rendering.\n                // TODO: Consider unwinding immediately, using the\n                // SuspendedOnHydration mechanism.\n                markRootSuspended(workInProgressRoot, workInProgressRootRenderLanes, workInProgressDeferredLane);\n            }\n        }\n        function renderDidError() {\n            if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {\n                workInProgressRootExitStatus = RootErrored;\n            }\n        }\n        function queueConcurrentError(error) {\n            if (workInProgressRootConcurrentErrors === null) {\n                workInProgressRootConcurrentErrors = [\n                    error\n                ];\n            } else {\n                workInProgressRootConcurrentErrors.push(error);\n            }\n        } // Called during render to determine if anything has suspended.\n        // Returns false if we're not sure.\n        function renderHasNotSuspendedYet() {\n            // If something errored or completed, we can't really be sure,\n            // so those are false.\n            return workInProgressRootExitStatus === RootInProgress;\n        } // TODO: Over time, this function and renderRootConcurrent have become more\n        // and more similar. Not sure it makes sense to maintain forked paths. Consider\n        // unifying them again.\n        function renderRootSync(root, lanes) {\n            var prevExecutionContext = executionContext;\n            executionContext |= RenderContext;\n            var prevDispatcher = pushDispatcher();\n            var prevAsyncDispatcher = pushAsyncDispatcher(); // If the root or lanes have changed, throw out the existing stack\n            // and prepare a fresh one. Otherwise we'll continue where we left off.\n            if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n                {\n                    if (isDevToolsPresent) {\n                        var memoizedUpdaters = root.memoizedUpdaters;\n                        if (memoizedUpdaters.size > 0) {\n                            restorePendingUpdaters(root, workInProgressRootRenderLanes);\n                            memoizedUpdaters.clear();\n                        } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n                        // If we bailout on this work, we'll move them back (like above).\n                        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n                        // That way we can keep the current update and future updates separate.\n                        movePendingFibersToMemoized(root, lanes);\n                    }\n                }\n                workInProgressTransitions = getTransitionsForLanes();\n                prepareFreshStack(root, lanes);\n            }\n            {\n                markRenderStarted(lanes);\n            }\n            var didSuspendInShell = false;\n            outer: do {\n                try {\n                    if (workInProgressSuspendedReason !== NotSuspended && workInProgress !== null) {\n                        // The work loop is suspended. During a synchronous render, we don't\n                        // yield to the main thread. Immediately unwind the stack. This will\n                        // trigger either a fallback or an error boundary.\n                        // TODO: For discrete and \"default\" updates (anything that's not\n                        // flushSync), we want to wait for the microtasks the flush before\n                        // unwinding. Will probably implement this using renderRootConcurrent,\n                        // or merge renderRootSync and renderRootConcurrent into the same\n                        // function and fork the behavior some other way.\n                        var unitOfWork = workInProgress;\n                        var thrownValue = workInProgressThrownValue;\n                        switch(workInProgressSuspendedReason){\n                            case SuspendedOnHydration:\n                                {\n                                    // Selective hydration. An update flowed into a dehydrated tree.\n                                    // Interrupt the current render so the work loop can switch to the\n                                    // hydration lane.\n                                    resetWorkInProgressStack();\n                                    workInProgressRootExitStatus = RootDidNotComplete;\n                                    break outer;\n                                }\n                            case SuspendedOnImmediate:\n                            case SuspendedOnData:\n                                {\n                                    if (!didSuspendInShell && getSuspenseHandler() === null) {\n                                        didSuspendInShell = true;\n                                    } // Intentional fallthrough\n                                }\n                            default:\n                                {\n                                    // Unwind then continue with the normal work loop.\n                                    workInProgressSuspendedReason = NotSuspended;\n                                    workInProgressThrownValue = null;\n                                    throwAndUnwindWorkLoop(root, unitOfWork, thrownValue);\n                                    break;\n                                }\n                        }\n                    }\n                    workLoopSync();\n                    break;\n                } catch (thrownValue) {\n                    handleThrow(root, thrownValue);\n                }\n            }while (true); // Check if something suspended in the shell. We use this to detect an\n            // infinite ping loop caused by an uncached promise.\n            //\n            // Only increment this counter once per synchronous render attempt across the\n            // whole tree. Even if there are many sibling components that suspend, this\n            // counter only gets incremented once.\n            if (didSuspendInShell) {\n                root.shellSuspendCounter++;\n            }\n            resetContextDependencies();\n            executionContext = prevExecutionContext;\n            popDispatcher(prevDispatcher);\n            popAsyncDispatcher(prevAsyncDispatcher);\n            if (workInProgress !== null) {\n                // This is a sync render, so we should have finished the whole tree.\n                throw new Error('Cannot commit an incomplete root. This error is likely caused by a ' + 'bug in React. Please file an issue.');\n            }\n            {\n                markRenderStopped();\n            }\n            workInProgressRoot = null;\n            workInProgressRootRenderLanes = NoLanes; // It's safe to process the queue now that the render phase is complete.\n            finishQueueingConcurrentUpdates();\n            return workInProgressRootExitStatus;\n        } // The work loop is an extremely hot path. Tell Closure not to inline it.\n        /** @noinline */ function workLoopSync() {\n            // Perform work without checking if we need to yield between fiber.\n            while(workInProgress !== null){\n                performUnitOfWork(workInProgress);\n            }\n        }\n        function renderRootConcurrent(root, lanes) {\n            var prevExecutionContext = executionContext;\n            executionContext |= RenderContext;\n            var prevDispatcher = pushDispatcher();\n            var prevAsyncDispatcher = pushAsyncDispatcher(); // If the root or lanes have changed, throw out the existing stack\n            // and prepare a fresh one. Otherwise we'll continue where we left off.\n            if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) {\n                {\n                    if (isDevToolsPresent) {\n                        var memoizedUpdaters = root.memoizedUpdaters;\n                        if (memoizedUpdaters.size > 0) {\n                            restorePendingUpdaters(root, workInProgressRootRenderLanes);\n                            memoizedUpdaters.clear();\n                        } // At this point, move Fibers that scheduled the upcoming work from the Map to the Set.\n                        // If we bailout on this work, we'll move them back (like above).\n                        // It's important to move them now in case the work spawns more work at the same priority with different updaters.\n                        // That way we can keep the current update and future updates separate.\n                        movePendingFibersToMemoized(root, lanes);\n                    }\n                }\n                workInProgressTransitions = getTransitionsForLanes();\n                resetRenderTimer();\n                prepareFreshStack(root, lanes);\n            }\n            {\n                markRenderStarted(lanes);\n            }\n            outer: do {\n                try {\n                    if (workInProgressSuspendedReason !== NotSuspended && workInProgress !== null) {\n                        // The work loop is suspended. We need to either unwind the stack or\n                        // replay the suspended component.\n                        var unitOfWork = workInProgress;\n                        var thrownValue = workInProgressThrownValue;\n                        resumeOrUnwind: switch(workInProgressSuspendedReason){\n                            case SuspendedOnError:\n                                {\n                                    // Unwind then continue with the normal work loop.\n                                    workInProgressSuspendedReason = NotSuspended;\n                                    workInProgressThrownValue = null;\n                                    throwAndUnwindWorkLoop(root, unitOfWork, thrownValue);\n                                    break;\n                                }\n                            case SuspendedOnData:\n                                {\n                                    var thenable = thrownValue;\n                                    if (isThenableResolved(thenable)) {\n                                        // The data resolved. Try rendering the component again.\n                                        workInProgressSuspendedReason = NotSuspended;\n                                        workInProgressThrownValue = null;\n                                        replaySuspendedUnitOfWork(unitOfWork);\n                                        break;\n                                    } // The work loop is suspended on data. We should wait for it to\n                                    // resolve before continuing to render.\n                                    // TODO: Handle the case where the promise resolves synchronously.\n                                    // Usually this is handled when we instrument the promise to add a\n                                    // `status` field, but if the promise already has a status, we won't\n                                    // have added a listener until right here.\n                                    var onResolution = function() {\n                                        // Check if the root is still suspended on this promise.\n                                        if (workInProgressSuspendedReason === SuspendedOnData && workInProgressRoot === root) {\n                                            // Mark the root as ready to continue rendering.\n                                            workInProgressSuspendedReason = SuspendedAndReadyToContinue;\n                                        } // Ensure the root is scheduled. We should do this even if we're\n                                        // currently working on a different root, so that we resume\n                                        // rendering later.\n                                        ensureRootIsScheduled(root);\n                                    };\n                                    thenable.then(onResolution, onResolution);\n                                    break outer;\n                                }\n                            case SuspendedOnImmediate:\n                                {\n                                    // If this fiber just suspended, it's possible the data is already\n                                    // cached. Yield to the main thread to give it a chance to ping. If\n                                    // it does, we can retry immediately without unwinding the stack.\n                                    workInProgressSuspendedReason = SuspendedAndReadyToContinue;\n                                    break outer;\n                                }\n                            case SuspendedOnInstance:\n                                {\n                                    workInProgressSuspendedReason = SuspendedOnInstanceAndReadyToContinue;\n                                    break outer;\n                                }\n                            case SuspendedAndReadyToContinue:\n                                {\n                                    var _thenable = thrownValue;\n                                    if (isThenableResolved(_thenable)) {\n                                        // The data resolved. Try rendering the component again.\n                                        workInProgressSuspendedReason = NotSuspended;\n                                        workInProgressThrownValue = null;\n                                        replaySuspendedUnitOfWork(unitOfWork);\n                                    } else {\n                                        // Otherwise, unwind then continue with the normal work loop.\n                                        workInProgressSuspendedReason = NotSuspended;\n                                        workInProgressThrownValue = null;\n                                        throwAndUnwindWorkLoop(root, unitOfWork, thrownValue);\n                                    }\n                                    break;\n                                }\n                            case SuspendedOnInstanceAndReadyToContinue:\n                                {\n                                    var resource = null;\n                                    switch(workInProgress.tag){\n                                        case HostHoistable:\n                                            {\n                                                resource = workInProgress.memoizedState;\n                                            }\n                                        // intentional fallthrough\n                                        case HostComponent:\n                                        case HostSingleton:\n                                            {\n                                                // Before unwinding the stack, check one more time if the\n                                                // instance is ready. It may have loaded when React yielded to\n                                                // the main thread.\n                                                // Assigning this to a constant so Flow knows the binding won't\n                                                // be mutated by `preloadInstance`.\n                                                var hostFiber = workInProgress;\n                                                var type = hostFiber.type;\n                                                var props = hostFiber.pendingProps;\n                                                var isReady = resource ? preloadResource(resource) : preloadInstance(type, props);\n                                                if (isReady) {\n                                                    // The data resolved. Resume the work loop as if nothing\n                                                    // suspended. Unlike when a user component suspends, we don't\n                                                    // have to replay anything because the host fiber\n                                                    // already completed.\n                                                    workInProgressSuspendedReason = NotSuspended;\n                                                    workInProgressThrownValue = null;\n                                                    var sibling = hostFiber.sibling;\n                                                    if (sibling !== null) {\n                                                        workInProgress = sibling;\n                                                    } else {\n                                                        var returnFiber = hostFiber.return;\n                                                        if (returnFiber !== null) {\n                                                            workInProgress = returnFiber;\n                                                            completeUnitOfWork(returnFiber);\n                                                        } else {\n                                                            workInProgress = null;\n                                                        }\n                                                    }\n                                                    break resumeOrUnwind;\n                                                }\n                                                break;\n                                            }\n                                        default:\n                                            {\n                                                // This will fail gracefully but it's not correct, so log a\n                                                // warning in dev.\n                                                if (true) {\n                                                    error('Unexpected type of fiber triggered a suspensey commit. ' + 'This is a bug in React.');\n                                                }\n                                                break;\n                                            }\n                                    } // Otherwise, unwind then continue with the normal work loop.\n                                    workInProgressSuspendedReason = NotSuspended;\n                                    workInProgressThrownValue = null;\n                                    throwAndUnwindWorkLoop(root, unitOfWork, thrownValue);\n                                    break;\n                                }\n                            case SuspendedOnDeprecatedThrowPromise:\n                                {\n                                    // Suspended by an old implementation that uses the `throw promise`\n                                    // pattern. The newer replaying behavior can cause subtle issues\n                                    // like infinite ping loops. So we maintain the old behavior and\n                                    // always unwind.\n                                    workInProgressSuspendedReason = NotSuspended;\n                                    workInProgressThrownValue = null;\n                                    throwAndUnwindWorkLoop(root, unitOfWork, thrownValue);\n                                    break;\n                                }\n                            case SuspendedOnHydration:\n                                {\n                                    // Selective hydration. An update flowed into a dehydrated tree.\n                                    // Interrupt the current render so the work loop can switch to the\n                                    // hydration lane.\n                                    resetWorkInProgressStack();\n                                    workInProgressRootExitStatus = RootDidNotComplete;\n                                    break outer;\n                                }\n                            default:\n                                {\n                                    throw new Error('Unexpected SuspendedReason. This is a bug in React.');\n                                }\n                        }\n                    }\n                    if ( true && ReactSharedInternals.actQueue !== null) {\n                        // `act` special case: If we're inside an `act` scope, don't consult\n                        // `shouldYield`. Always keep working until the render is complete.\n                        // This is not just an optimization: in a unit test environment, we\n                        // can't trust the result of `shouldYield`, because the host I/O is\n                        // likely mocked.\n                        workLoopSync();\n                    } else {\n                        workLoopConcurrent();\n                    }\n                    break;\n                } catch (thrownValue) {\n                    handleThrow(root, thrownValue);\n                }\n            }while (true);\n            resetContextDependencies();\n            popDispatcher(prevDispatcher);\n            popAsyncDispatcher(prevAsyncDispatcher);\n            executionContext = prevExecutionContext;\n            if (workInProgress !== null) {\n                // Still work remaining.\n                {\n                    markRenderYielded();\n                }\n                return RootInProgress;\n            } else {\n                // Completed the tree.\n                {\n                    markRenderStopped();\n                }\n                workInProgressRoot = null;\n                workInProgressRootRenderLanes = NoLanes; // It's safe to process the queue now that the render phase is complete.\n                finishQueueingConcurrentUpdates(); // Return the final exit status.\n                return workInProgressRootExitStatus;\n            }\n        }\n        /** @noinline */ function workLoopConcurrent() {\n            // Perform work until Scheduler asks us to yield\n            while(workInProgress !== null && !shouldYield()){\n                // $FlowFixMe[incompatible-call] found when upgrading Flow\n                performUnitOfWork(workInProgress);\n            }\n        }\n        function performUnitOfWork(unitOfWork) {\n            // The current, flushed, state of this fiber is the alternate. Ideally\n            // nothing should rely on this, but relying on it here means that we don't\n            // need an additional field on the work in progress.\n            var current = unitOfWork.alternate;\n            setCurrentDebugFiberInDEV(unitOfWork);\n            var next;\n            if ((unitOfWork.mode & ProfileMode) !== NoMode) {\n                startProfilerTimer(unitOfWork);\n                next = beginWork(current, unitOfWork, entangledRenderLanes);\n                stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n            } else {\n                next = beginWork(current, unitOfWork, entangledRenderLanes);\n            }\n            {\n                resetCurrentFiber();\n            }\n            unitOfWork.memoizedProps = unitOfWork.pendingProps;\n            if (next === null) {\n                // If this doesn't spawn new work, complete the current work.\n                completeUnitOfWork(unitOfWork);\n            } else {\n                workInProgress = next;\n            }\n        }\n        function replaySuspendedUnitOfWork(unitOfWork) {\n            // This is a fork of performUnitOfWork specifcally for replaying a fiber that\n            // just suspended.\n            //\n            var current = unitOfWork.alternate;\n            setCurrentDebugFiberInDEV(unitOfWork);\n            var next;\n            var isProfilingMode = (unitOfWork.mode & ProfileMode) !== NoMode;\n            if (isProfilingMode) {\n                startProfilerTimer(unitOfWork);\n            }\n            switch(unitOfWork.tag){\n                case SimpleMemoComponent:\n                case FunctionComponent:\n                    {\n                        // Resolve `defaultProps`. This logic is copied from `beginWork`.\n                        // TODO: Consider moving this switch statement into that module. Also,\n                        // could maybe use this as an opportunity to say `use` doesn't work with\n                        // `defaultProps` :)\n                        var Component = unitOfWork.type;\n                        var unresolvedProps = unitOfWork.pendingProps;\n                        var resolvedProps = unresolvedProps;\n                        var context;\n                        next = replayFunctionComponent(current, unitOfWork, resolvedProps, Component, context, workInProgressRootRenderLanes);\n                        break;\n                    }\n                case ForwardRef:\n                    {\n                        // Resolve `defaultProps`. This logic is copied from `beginWork`.\n                        // TODO: Consider moving this switch statement into that module. Also,\n                        // could maybe use this as an opportunity to say `use` doesn't work with\n                        // `defaultProps` :)\n                        var _Component = unitOfWork.type.render;\n                        var _unresolvedProps = unitOfWork.pendingProps;\n                        var _resolvedProps = _unresolvedProps;\n                        next = replayFunctionComponent(current, unitOfWork, _resolvedProps, _Component, unitOfWork.ref, workInProgressRootRenderLanes);\n                        break;\n                    }\n                case HostComponent:\n                    {\n                        // Some host components are stateful (that's how we implement form\n                        // actions) but we don't bother to reuse the memoized state because it's\n                        // not worth the extra code. The main reason to reuse the previous hooks\n                        // is to reuse uncached promises, but we happen to know that the only\n                        // promises that a host component might suspend on are definitely cached\n                        // because they are controlled by us. So don't bother.\n                        resetHooksOnUnwind(unitOfWork); // Fallthrough to the next branch.\n                    }\n                default:\n                    {\n                        // Other types besides function components are reset completely before\n                        // being replayed. Currently this only happens when a Usable type is\n                        // reconciled — the reconciler will suspend.\n                        //\n                        // We reset the fiber back to its original state; however, this isn't\n                        // a full \"unwind\" because we're going to reuse the promises that were\n                        // reconciled previously. So it's intentional that we don't call\n                        // resetSuspendedWorkLoopOnUnwind here.\n                        unwindInterruptedWork(current, unitOfWork);\n                        unitOfWork = workInProgress = resetWorkInProgress(unitOfWork, entangledRenderLanes);\n                        next = beginWork(current, unitOfWork, entangledRenderLanes);\n                        break;\n                    }\n            }\n            if (isProfilingMode) {\n                stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n            } // The begin phase finished successfully without suspending. Return to the\n            // normal work loop.\n            {\n                resetCurrentFiber();\n            }\n            unitOfWork.memoizedProps = unitOfWork.pendingProps;\n            if (next === null) {\n                // If this doesn't spawn new work, complete the current work.\n                completeUnitOfWork(unitOfWork);\n            } else {\n                workInProgress = next;\n            }\n        }\n        function throwAndUnwindWorkLoop(root, unitOfWork, thrownValue) {\n            // This is a fork of performUnitOfWork specifcally for unwinding a fiber\n            // that threw an exception.\n            //\n            // Return to the normal work loop. This will unwind the stack, and potentially\n            // result in showing a fallback.\n            resetSuspendedWorkLoopOnUnwind(unitOfWork);\n            var returnFiber = unitOfWork.return;\n            try {\n                // Find and mark the nearest Suspense or error boundary that can handle\n                // this \"exception\".\n                var didFatal = throwException(root, returnFiber, unitOfWork, thrownValue, workInProgressRootRenderLanes);\n                if (didFatal) {\n                    panicOnRootError(root, thrownValue);\n                    return;\n                }\n            } catch (error) {\n                // We had trouble processing the error. An example of this happening is\n                // when accessing the `componentDidCatch` property of an error boundary\n                // throws an error. A weird edge case. There's a regression test for this.\n                // To prevent an infinite loop, bubble the error up to the next parent.\n                if (returnFiber !== null) {\n                    workInProgress = returnFiber;\n                    throw error;\n                } else {\n                    panicOnRootError(root, thrownValue);\n                    return;\n                }\n            }\n            if (unitOfWork.flags & Incomplete) {\n                // Unwind the stack until we reach the nearest boundary.\n                unwindUnitOfWork(unitOfWork);\n            } else {\n                // Although the fiber suspended, we're intentionally going to commit it in\n                // an inconsistent state. We can do this safely in cases where we know the\n                // inconsistent tree will be hidden.\n                //\n                // This currently only applies to Legacy Suspense implementation, but we may\n                // port a version of this to concurrent roots, too, when performing a\n                // synchronous render. Because that will allow us to mutate the tree as we\n                // go instead of buffering mutations until the end. Though it's unclear if\n                // this particular path is how that would be implemented.\n                completeUnitOfWork(unitOfWork);\n            }\n        }\n        function panicOnRootError(root, error) {\n            // There's no ancestor that can handle this exception. This should never\n            // happen because the root is supposed to capture all errors that weren't\n            // caught by an error boundary. This is a fatal error, or panic condition,\n            // because we've run out of ways to recover.\n            workInProgressRootExitStatus = RootFatalErrored;\n            logUncaughtError(root, createCapturedValueAtFiber(error, root.current)); // Set `workInProgress` to null. This represents advancing to the next\n            // sibling, or the parent if there are no siblings. But since the root\n            // has no siblings nor a parent, we set it to null. Usually this is\n            // handled by `completeUnitOfWork` or `unwindWork`, but since we're\n            // intentionally not calling those, we need set it here.\n            // TODO: Consider calling `unwindWork` to pop the contexts.\n            workInProgress = null;\n        }\n        function completeUnitOfWork(unitOfWork) {\n            // Attempt to complete the current unit of work, then move to the next\n            // sibling. If there are no more siblings, return to the parent fiber.\n            var completedWork = unitOfWork;\n            do {\n                {\n                    if ((completedWork.flags & Incomplete) !== NoFlags$1) {\n                        // NOTE: If we re-enable sibling prerendering in some cases, this branch\n                        // is where we would switch to the unwinding path.\n                        error('Internal React error: Expected this fiber to be complete, but ' + \"it isn't. It should have been unwound. This is a bug in React.\");\n                    }\n                }\n                // nothing should rely on this, but relying on it here means that we don't\n                // need an additional field on the work in progress.\n                var current = completedWork.alternate;\n                var returnFiber = completedWork.return;\n                setCurrentDebugFiberInDEV(completedWork);\n                var next = void 0;\n                if ((completedWork.mode & ProfileMode) === NoMode) {\n                    next = completeWork(current, completedWork, entangledRenderLanes);\n                } else {\n                    startProfilerTimer(completedWork);\n                    next = completeWork(current, completedWork, entangledRenderLanes); // Update render duration assuming we didn't error.\n                    stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\n                }\n                resetCurrentDebugFiberInDEV();\n                if (next !== null) {\n                    // Completing this fiber spawned new work. Work on that next.\n                    workInProgress = next;\n                    return;\n                }\n                var siblingFiber = completedWork.sibling;\n                if (siblingFiber !== null) {\n                    // If there is more work to do in this returnFiber, do that next.\n                    workInProgress = siblingFiber;\n                    return;\n                } // Otherwise, return to the parent\n                // $FlowFixMe[incompatible-type] we bail out when we get a null\n                completedWork = returnFiber; // Update the next thing we're working on in case something throws.\n                workInProgress = completedWork;\n            }while (completedWork !== null); // We've reached the root.\n            if (workInProgressRootExitStatus === RootInProgress) {\n                workInProgressRootExitStatus = RootCompleted;\n            }\n        }\n        function unwindUnitOfWork(unitOfWork) {\n            var incompleteWork = unitOfWork;\n            do {\n                // The current, flushed, state of this fiber is the alternate. Ideally\n                // nothing should rely on this, but relying on it here means that we don't\n                // need an additional field on the work in progress.\n                var current = incompleteWork.alternate; // This fiber did not complete because something threw. Pop values off\n                // the stack without entering the complete phase. If this is a boundary,\n                // capture values if possible.\n                var next = unwindWork(current, incompleteWork); // Because this fiber did not complete, don't reset its lanes.\n                if (next !== null) {\n                    // Found a boundary that can handle this exception. Re-renter the\n                    // begin phase. This branch will return us to the normal work loop.\n                    //\n                    // Since we're restarting, remove anything that is not a host effect\n                    // from the effect tag.\n                    next.flags &= HostEffectMask;\n                    workInProgress = next;\n                    return;\n                } // Keep unwinding until we reach either a boundary or the root.\n                if ((incompleteWork.mode & ProfileMode) !== NoMode) {\n                    // Record the render duration for the fiber that errored.\n                    stopProfilerTimerIfRunningAndRecordDelta(incompleteWork, false); // Include the time spent working on failed children before continuing.\n                    var actualDuration = incompleteWork.actualDuration;\n                    var child = incompleteWork.child;\n                    while(child !== null){\n                        // $FlowFixMe[unsafe-addition] addition with possible null/undefined value\n                        actualDuration += child.actualDuration;\n                        child = child.sibling;\n                    }\n                    incompleteWork.actualDuration = actualDuration;\n                } // TODO: Once we stop prerendering siblings, instead of resetting the parent\n                // of the node being unwound, we should be able to reset node itself as we\n                // unwind the stack. Saves an additional null check.\n                var returnFiber = incompleteWork.return;\n                if (returnFiber !== null) {\n                    // Mark the parent fiber as incomplete and clear its subtree flags.\n                    // TODO: Once we stop prerendering siblings, we may be able to get rid of\n                    // the Incomplete flag because unwinding to the nearest boundary will\n                    // happen synchronously.\n                    returnFiber.flags |= Incomplete;\n                    returnFiber.subtreeFlags = NoFlags$1;\n                    returnFiber.deletions = null;\n                } // NOTE: If we re-enable sibling prerendering in some cases, here we\n                // would switch to the normal completion path: check if a sibling\n                // exists, and if so, begin work on it.\n                // Otherwise, return to the parent\n                // $FlowFixMe[incompatible-type] we bail out when we get a null\n                incompleteWork = returnFiber; // Update the next thing we're working on in case something throws.\n                workInProgress = incompleteWork;\n            }while (incompleteWork !== null); // We've unwound all the way to the root.\n            workInProgressRootExitStatus = RootDidNotComplete;\n            workInProgress = null;\n        }\n        function commitRoot(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, spawnedLane) {\n            // TODO: This no longer makes any sense. We already wrap the mutation and\n            // layout phases. Should be able to remove.\n            var prevTransition = ReactSharedInternals.T;\n            var previousUpdateLanePriority = getCurrentUpdatePriority();\n            try {\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                ReactSharedInternals.T = null;\n                commitRootImpl(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, previousUpdateLanePriority, spawnedLane);\n            } finally{\n                ReactSharedInternals.T = prevTransition;\n                setCurrentUpdatePriority(previousUpdateLanePriority);\n            }\n            return null;\n        }\n        function commitRootImpl(root, recoverableErrors, transitions, didIncludeRenderPhaseUpdate, renderPriorityLevel, spawnedLane) {\n            do {\n                // `flushPassiveEffects` will call `flushSyncUpdateQueue` at the end, which\n                // means `flushPassiveEffects` will sometimes result in additional\n                // passive effects. So we need to keep flushing in a loop until there are\n                // no more pending effects.\n                // TODO: Might be better if `flushPassiveEffects` did not automatically\n                // flush synchronous work at the end, to avoid factoring hazards like this.\n                flushPassiveEffects();\n            }while (rootWithPendingPassiveEffects !== null);\n            flushRenderPhaseStrictModeWarningsInDEV();\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                throw new Error('Should not already be working.');\n            }\n            var finishedWork = root.finishedWork;\n            var lanes = root.finishedLanes;\n            {\n                markCommitStarted(lanes);\n            }\n            if (finishedWork === null) {\n                {\n                    markCommitStopped();\n                }\n                return null;\n            } else {\n                {\n                    if (lanes === NoLanes) {\n                        error('root.finishedLanes should not be empty during a commit. This is a ' + 'bug in React.');\n                    }\n                }\n            }\n            root.finishedWork = null;\n            root.finishedLanes = NoLanes;\n            if (finishedWork === root.current) {\n                throw new Error('Cannot commit the same tree as before. This error is likely caused by ' + 'a bug in React. Please file an issue.');\n            } // commitRoot never returns a continuation; it always finishes synchronously.\n            // So we can clear these now to allow a new callback to be scheduled.\n            root.callbackNode = null;\n            root.callbackPriority = NoLane;\n            root.cancelPendingCommit = null; // Check which lanes no longer have any work scheduled on them, and mark\n            // those as finished.\n            var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes); // Make sure to account for lanes that were updated by a concurrent event\n            // during the render phase; don't mark them as finished.\n            var concurrentlyUpdatedLanes = getConcurrentlyUpdatedLanes();\n            remainingLanes = mergeLanes(remainingLanes, concurrentlyUpdatedLanes);\n            markRootFinished(root, remainingLanes, spawnedLane); // Reset this before firing side effects so we can detect recursive updates.\n            didIncludeCommitPhaseUpdate = false;\n            if (root === workInProgressRoot) {\n                // We can reset these now that they are finished.\n                workInProgressRoot = null;\n                workInProgress = null;\n                workInProgressRootRenderLanes = NoLanes;\n            } // If there are pending passive effects, schedule a callback to process them.\n            // Do this as early as possible, so it is queued before anything else that\n            // might get scheduled in the commit phase. (See #16714.)\n            // TODO: Delete all other places that schedule the passive effect callback\n            // They're redundant.\n            if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags$1 || (finishedWork.flags & PassiveMask) !== NoFlags$1) {\n                if (!rootDoesHavePassiveEffects) {\n                    rootDoesHavePassiveEffects = true;\n                    pendingPassiveEffectsRemainingLanes = remainingLanes; // workInProgressTransitions might be overwritten, so we want\n                    // to store it in pendingPassiveTransitions until they get processed\n                    // We need to pass this through as an argument to commitRoot\n                    // because workInProgressTransitions might have changed between\n                    // the previous render and commit if we throttle the commit\n                    // with setTimeout\n                    pendingPassiveTransitions = transitions;\n                    scheduleCallback(NormalPriority$1, function() {\n                        flushPassiveEffects(); // This render triggered passive effects: release the root cache pool\n                        // *after* passive effects fire to avoid freeing a cache pool that may\n                        // be referenced by a node in the tree (HostRoot, Cache boundary etc)\n                        return null;\n                    });\n                }\n            } // Check if there are any effects in the whole tree.\n            // TODO: This is left over from the effect list implementation, where we had\n            // to check for the existence of `firstEffect` to satisfy Flow. I think the\n            // only other reason this optimization exists is because it affects profiling.\n            // Reconsider whether this is necessary.\n            var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags$1;\n            var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags$1;\n            if (subtreeHasEffects || rootHasEffect) {\n                var prevTransition = ReactSharedInternals.T;\n                ReactSharedInternals.T = null;\n                var previousPriority = getCurrentUpdatePriority();\n                setCurrentUpdatePriority(DiscreteEventPriority);\n                var prevExecutionContext = executionContext;\n                executionContext |= CommitContext; // The commit phase is broken into several sub-phases. We do a separate pass\n                // of the effect list for each phase: all mutation effects come before all\n                // layout effects, and so on.\n                // The first phase a \"before mutation\" phase. We use this phase to read the\n                // state of the host tree right before we mutate it. This is where\n                // getSnapshotBeforeUpdate is called.\n                commitBeforeMutationEffects(root, finishedWork);\n                {\n                    // Mark the current commit time to be shared by all Profilers in this\n                    // batch. This enables them to be grouped later.\n                    recordCommitTime();\n                }\n                commitMutationEffects(root, finishedWork, lanes);\n                resetAfterCommit(root.containerInfo); // The work-in-progress tree is now the current tree. This must come after\n                // the mutation phase, so that the previous tree is still current during\n                // componentWillUnmount, but before the layout phase, so that the finished\n                // work is current during componentDidMount/Update.\n                root.current = finishedWork; // The next phase is the layout phase, where we call effects that read\n                {\n                    markLayoutEffectsStarted(lanes);\n                }\n                commitLayoutEffects(finishedWork, root, lanes);\n                {\n                    markLayoutEffectsStopped();\n                }\n                // opportunity to paint.\n                requestPaint();\n                executionContext = prevExecutionContext; // Reset the priority to the previous non-sync value.\n                setCurrentUpdatePriority(previousPriority);\n                ReactSharedInternals.T = prevTransition;\n            } else {\n                // No effects.\n                root.current = finishedWork; // Measure these anyway so the flamegraph explicitly shows that there were\n                // no effects.\n                // TODO: Maybe there's a better way to report this.\n                {\n                    recordCommitTime();\n                }\n            }\n            var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;\n            if (rootDoesHavePassiveEffects) {\n                // This commit has passive effects. Stash a reference to them. But don't\n                // schedule a callback until after flushing layout work.\n                rootDoesHavePassiveEffects = false;\n                rootWithPendingPassiveEffects = root;\n                pendingPassiveEffectsLanes = lanes;\n            } else {\n                // There were no passive effects, so we can immediately release the cache\n                // pool for this render.\n                releaseRootPooledCache(root, remainingLanes);\n                {\n                    nestedPassiveUpdateCount = 0;\n                    rootWithPassiveNestedUpdates = null;\n                }\n            } // Read this again, since an effect might have updated it\n            remainingLanes = root.pendingLanes; // Check if there's remaining work on this root\n            // TODO: This is part of the `componentDidCatch` implementation. Its purpose\n            // is to detect whether something might have called setState inside\n            // `componentDidCatch`. The mechanism is known to be flawed because `setState`\n            // inside `componentDidCatch` is itself flawed — that's why we recommend\n            // `getDerivedStateFromError` instead. However, it could be improved by\n            // checking if remainingLanes includes Sync work, instead of whether there's\n            // any work remaining at all (which would also include stuff like Suspense\n            // retries or transitions). It's been like this for a while, though, so fixing\n            // it probably isn't that urgent.\n            if (remainingLanes === NoLanes) {\n                // If there's no remaining work, we can clear the set of already failed\n                // error boundaries.\n                legacyErrorBoundariesThatAlreadyFailed = null;\n            }\n            {\n                if (!rootDidHavePassiveEffects) {\n                    commitDoubleInvokeEffectsInDEV(root);\n                }\n            }\n            onCommitRoot$1(finishedWork.stateNode, renderPriorityLevel);\n            {\n                if (isDevToolsPresent) {\n                    root.memoizedUpdaters.clear();\n                }\n            }\n            {\n                onCommitRoot();\n            }\n            // additional work on this root is scheduled.\n            ensureRootIsScheduled(root);\n            if (recoverableErrors !== null) {\n                // There were errors during this render, but recovered from them without\n                // needing to surface it to the UI. We log them here.\n                var onRecoverableError = root.onRecoverableError;\n                for(var i = 0; i < recoverableErrors.length; i++){\n                    var recoverableError = recoverableErrors[i];\n                    var errorInfo = makeErrorInfo(recoverableError.stack);\n                    setCurrentDebugFiberInDEV(recoverableError.source);\n                    onRecoverableError(recoverableError.value, errorInfo);\n                    resetCurrentDebugFiberInDEV();\n                }\n            } // If the passive effects are the result of a discrete render, flush them\n            // synchronously at the end of the current task so that the result is\n            // immediately observable. Otherwise, we assume that they are not\n            // order-dependent and do not need to be observed by external systems, so we\n            // can wait until after paint.\n            // TODO: We can optimize this by not scheduling the callback earlier. Since we\n            // currently schedule the callback in multiple places, will wait until those\n            // are consolidated.\n            if (includesSyncLane(pendingPassiveEffectsLanes) && disableLegacyMode) {\n                flushPassiveEffects();\n            } // Read this again, since a passive effect might have updated it\n            remainingLanes = root.pendingLanes; // Check if this render scheduled a cascading synchronous update. This is a\n            // heurstic to detect infinite update loops. We are intentionally excluding\n            // hydration lanes in this check, because render triggered by selective\n            // hydration is conceptually not an update.\n            if (// the render phase or the commit phase. We track these explicitly because\n            // we can't infer from the remaining lanes alone.\n            didIncludeRenderPhaseUpdate || didIncludeCommitPhaseUpdate || // Was the finished render the result of an update (not hydration)?\n            includesSomeLane(lanes, UpdateLanes) && // Did it schedule a sync update?\n            includesSomeLane(remainingLanes, SyncUpdateLanes)) {\n                {\n                    markNestedUpdateScheduled();\n                }\n                // finishing. If there are too many, it indicates an infinite update loop.\n                if (root === rootWithNestedUpdates) {\n                    nestedUpdateCount++;\n                } else {\n                    nestedUpdateCount = 0;\n                    rootWithNestedUpdates = root;\n                }\n            } else {\n                nestedUpdateCount = 0;\n            } // If layout work was scheduled, flush it now.\n            flushSyncWorkOnAllRoots();\n            {\n                markCommitStopped();\n            }\n            return null;\n        }\n        function makeErrorInfo(componentStack) {\n            var errorInfo = {\n                componentStack: componentStack\n            };\n            {\n                Object.defineProperty(errorInfo, 'digest', {\n                    get: function() {\n                        error('You are accessing \"digest\" from the errorInfo object passed to onRecoverableError.' + ' This property is no longer provided as part of errorInfo but can be accessed as a property' + ' of the Error instance itself.');\n                    }\n                });\n            }\n            return errorInfo;\n        }\n        function releaseRootPooledCache(root, remainingLanes) {\n            {\n                var pooledCacheLanes = root.pooledCacheLanes &= remainingLanes;\n                if (pooledCacheLanes === NoLanes) {\n                    // None of the remaining work relies on the cache pool. Clear it so\n                    // subsequent requests get a new cache\n                    var pooledCache = root.pooledCache;\n                    if (pooledCache != null) {\n                        root.pooledCache = null;\n                        releaseCache(pooledCache);\n                    }\n                }\n            }\n        }\n        function flushPassiveEffects() {\n            // Returns whether passive effects were flushed.\n            // TODO: Combine this check with the one in flushPassiveEFfectsImpl. We should\n            // probably just combine the two functions. I believe they were only separate\n            // in the first place because we used to wrap it with\n            // `Scheduler.runWithPriority`, which accepts a function. But now we track the\n            // priority within React itself, so we can mutate the variable directly.\n            if (rootWithPendingPassiveEffects !== null) {\n                // Cache the root since rootWithPendingPassiveEffects is cleared in\n                // flushPassiveEffectsImpl\n                var root = rootWithPendingPassiveEffects; // Cache and clear the remaining lanes flag; it must be reset since this\n                // method can be called from various places, not always from commitRoot\n                // where the remaining lanes are known\n                var remainingLanes = pendingPassiveEffectsRemainingLanes;\n                pendingPassiveEffectsRemainingLanes = NoLanes;\n                var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);\n                var priority = lowerEventPriority(DefaultEventPriority, renderPriority);\n                var prevTransition = ReactSharedInternals.T;\n                var previousPriority = getCurrentUpdatePriority();\n                try {\n                    setCurrentUpdatePriority(priority);\n                    ReactSharedInternals.T = null;\n                    return flushPassiveEffectsImpl();\n                } finally{\n                    setCurrentUpdatePriority(previousPriority);\n                    ReactSharedInternals.T = prevTransition; // Once passive effects have run for the tree - giving components a\n                    // chance to retain cache instances they use - release the pooled\n                    // cache at the root (if there is one)\n                    releaseRootPooledCache(root, remainingLanes);\n                }\n            }\n            return false;\n        }\n        function enqueuePendingPassiveProfilerEffect(fiber) {\n            {\n                pendingPassiveProfilerEffects.push(fiber);\n                if (!rootDoesHavePassiveEffects) {\n                    rootDoesHavePassiveEffects = true;\n                    scheduleCallback(NormalPriority$1, function() {\n                        flushPassiveEffects();\n                        return null;\n                    });\n                }\n            }\n        }\n        function flushPassiveEffectsImpl() {\n            if (rootWithPendingPassiveEffects === null) {\n                return false;\n            } // Cache and clear the transitions flag\n            var transitions = pendingPassiveTransitions;\n            pendingPassiveTransitions = null;\n            var root = rootWithPendingPassiveEffects;\n            var lanes = pendingPassiveEffectsLanes;\n            rootWithPendingPassiveEffects = null; // TODO: This is sometimes out of sync with rootWithPendingPassiveEffects.\n            // Figure out why and fix it. It's not causing any known issues (probably\n            // because it's only used for profiling), but it's a refactor hazard.\n            pendingPassiveEffectsLanes = NoLanes;\n            if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {\n                throw new Error('Cannot flush passive effects while already rendering.');\n            }\n            {\n                isFlushingPassiveEffects = true;\n                didScheduleUpdateDuringPassiveEffects = false;\n            }\n            {\n                markPassiveEffectsStarted(lanes);\n            }\n            var prevExecutionContext = executionContext;\n            executionContext |= CommitContext;\n            commitPassiveUnmountEffects(root.current);\n            commitPassiveMountEffects(root, root.current, lanes, transitions); // TODO: Move to commitPassiveMountEffects\n            {\n                var profilerEffects = pendingPassiveProfilerEffects;\n                pendingPassiveProfilerEffects = [];\n                for(var i = 0; i < profilerEffects.length; i++){\n                    var fiber = profilerEffects[i];\n                    commitPassiveEffectDurations(root, fiber);\n                }\n            }\n            {\n                markPassiveEffectsStopped();\n            }\n            {\n                commitDoubleInvokeEffectsInDEV(root);\n            }\n            executionContext = prevExecutionContext;\n            flushSyncWorkOnAllRoots();\n            {\n                // If additional passive effects were scheduled, increment a counter. If this\n                // exceeds the limit, we'll fire a warning.\n                if (didScheduleUpdateDuringPassiveEffects) {\n                    if (root === rootWithPassiveNestedUpdates) {\n                        nestedPassiveUpdateCount++;\n                    } else {\n                        nestedPassiveUpdateCount = 0;\n                        rootWithPassiveNestedUpdates = root;\n                    }\n                } else {\n                    nestedPassiveUpdateCount = 0;\n                }\n                isFlushingPassiveEffects = false;\n                didScheduleUpdateDuringPassiveEffects = false;\n            }\n            onPostCommitRoot(root);\n            {\n                var stateNode = root.current.stateNode;\n                stateNode.effectDuration = 0;\n                stateNode.passiveEffectDuration = 0;\n            }\n            return true;\n        }\n        function isAlreadyFailedLegacyErrorBoundary(instance) {\n            return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);\n        }\n        function markLegacyErrorBoundaryAsFailed(instance) {\n            if (legacyErrorBoundariesThatAlreadyFailed === null) {\n                legacyErrorBoundariesThatAlreadyFailed = new Set([\n                    instance\n                ]);\n            } else {\n                legacyErrorBoundariesThatAlreadyFailed.add(instance);\n            }\n        }\n        function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {\n            var errorInfo = createCapturedValueAtFiber(error, sourceFiber);\n            var update = createRootErrorUpdate(rootFiber.stateNode, errorInfo, SyncLane);\n            var root = enqueueUpdate(rootFiber, update, SyncLane);\n            if (root !== null) {\n                markRootUpdated(root, SyncLane);\n                ensureRootIsScheduled(root);\n            }\n        }\n        function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {\n            {\n                setIsRunningInsertionEffect(false);\n            }\n            if (sourceFiber.tag === HostRoot) {\n                // Error was thrown at the root. There is no parent, so the root\n                // itself should capture it.\n                captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);\n                return;\n            }\n            var fiber = nearestMountedAncestor;\n            while(fiber !== null){\n                if (fiber.tag === HostRoot) {\n                    captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);\n                    return;\n                } else if (fiber.tag === ClassComponent) {\n                    var ctor = fiber.type;\n                    var instance = fiber.stateNode;\n                    if (typeof ctor.getDerivedStateFromError === 'function' || typeof instance.componentDidCatch === 'function' && !isAlreadyFailedLegacyErrorBoundary(instance)) {\n                        var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);\n                        var update = createClassErrorUpdate(SyncLane);\n                        var root = enqueueUpdate(fiber, update, SyncLane);\n                        if (root !== null) {\n                            initializeClassErrorUpdate(update, root, fiber, errorInfo);\n                            markRootUpdated(root, SyncLane);\n                            ensureRootIsScheduled(root);\n                        }\n                        return;\n                    }\n                }\n                fiber = fiber.return;\n            }\n            {\n                error('Internal React error: Attempted to capture a commit phase error ' + 'inside a detached tree. This indicates a bug in React. Potential ' + 'causes include deleting the same fiber more than once, committing an ' + 'already-finished tree, or an inconsistent return pointer.\\n\\n' + 'Error message:\\n\\n%s', error$1);\n            }\n        }\n        function attachPingListener(root, wakeable, lanes) {\n            // Attach a ping listener\n            //\n            // The data might resolve before we have a chance to commit the fallback. Or,\n            // in the case of a refresh, we'll never commit a fallback. So we need to\n            // attach a listener now. When it resolves (\"pings\"), we can decide whether to\n            // try rendering the tree again.\n            //\n            // Only attach a listener if one does not already exist for the lanes\n            // we're currently rendering (which acts like a \"thread ID\" here).\n            //\n            // We only need to do this in concurrent mode. Legacy Suspense always\n            // commits fallbacks synchronously, so there are no pings.\n            var pingCache = root.pingCache;\n            var threadIDs;\n            if (pingCache === null) {\n                pingCache = root.pingCache = new PossiblyWeakMap();\n                threadIDs = new Set();\n                pingCache.set(wakeable, threadIDs);\n            } else {\n                threadIDs = pingCache.get(wakeable);\n                if (threadIDs === undefined) {\n                    threadIDs = new Set();\n                    pingCache.set(wakeable, threadIDs);\n                }\n            }\n            if (!threadIDs.has(lanes)) {\n                workInProgressRootDidAttachPingListener = true; // Memoize using the thread ID to prevent redundant listeners.\n                threadIDs.add(lanes);\n                var ping = pingSuspendedRoot.bind(null, root, wakeable, lanes);\n                {\n                    if (isDevToolsPresent) {\n                        // If we have pending work still, restore the original updaters\n                        restorePendingUpdaters(root, lanes);\n                    }\n                }\n                wakeable.then(ping, ping);\n            }\n        }\n        function pingSuspendedRoot(root, wakeable, pingedLanes) {\n            var pingCache = root.pingCache;\n            if (pingCache !== null) {\n                // The wakeable resolved, so we no longer need to memoize, because it will\n                // never be thrown again.\n                pingCache.delete(wakeable);\n            }\n            markRootPinged(root, pingedLanes);\n            warnIfSuspenseResolutionNotWrappedWithActDEV();\n            if (workInProgressRoot === root && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {\n                // Received a ping at the same priority level at which we're currently\n                // rendering. We might want to restart this render. This should mirror\n                // the logic of whether or not a root suspends once it completes.\n                // TODO: If we're rendering sync either due to Sync, Batched or expired,\n                // we should probably never restart.\n                // If we're suspended with delay, or if it's a retry, we'll always suspend\n                // so we can always restart.\n                if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now$1() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {\n                    // Force a restart from the root by unwinding the stack. Unless this is\n                    // being called from the render phase, because that would cause a crash.\n                    if ((executionContext & RenderContext) === NoContext) {\n                        prepareFreshStack(root, NoLanes);\n                    }\n                } else {\n                    // Even though we can't restart right now, we might get an\n                    // opportunity later. So we mark this render as having a ping.\n                    workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);\n                }\n            }\n            ensureRootIsScheduled(root);\n        }\n        function retryTimedOutBoundary(boundaryFiber, retryLane) {\n            // The boundary fiber (a Suspense component or SuspenseList component)\n            // previously was rendered in its fallback state. One of the promises that\n            // suspended it has resolved, which means at least part of the tree was\n            // likely unblocked. Try rendering again, at a new lanes.\n            if (retryLane === NoLane) {\n                // TODO: Assign this to `suspenseState.retryLane`? to avoid\n                // unnecessary entanglement?\n                retryLane = requestRetryLane();\n            } // TODO: Special case idle priority?\n            var root = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);\n            if (root !== null) {\n                markRootUpdated(root, retryLane);\n                ensureRootIsScheduled(root);\n            }\n        }\n        function retryDehydratedSuspenseBoundary(boundaryFiber) {\n            var suspenseState = boundaryFiber.memoizedState;\n            var retryLane = NoLane;\n            if (suspenseState !== null) {\n                retryLane = suspenseState.retryLane;\n            }\n            retryTimedOutBoundary(boundaryFiber, retryLane);\n        }\n        function resolveRetryWakeable(boundaryFiber, wakeable) {\n            var retryLane = NoLane; // Default\n            var retryCache;\n            switch(boundaryFiber.tag){\n                case SuspenseComponent:\n                    retryCache = boundaryFiber.stateNode;\n                    var suspenseState = boundaryFiber.memoizedState;\n                    if (suspenseState !== null) {\n                        retryLane = suspenseState.retryLane;\n                    }\n                    break;\n                case SuspenseListComponent:\n                    retryCache = boundaryFiber.stateNode;\n                    break;\n                case OffscreenComponent:\n                    {\n                        var instance = boundaryFiber.stateNode;\n                        retryCache = instance._retryCache;\n                        break;\n                    }\n                default:\n                    throw new Error('Pinged unknown suspense boundary type. ' + 'This is probably a bug in React.');\n            }\n            if (retryCache !== null) {\n                // The wakeable resolved, so we no longer need to memoize, because it will\n                // never be thrown again.\n                retryCache.delete(wakeable);\n            }\n            retryTimedOutBoundary(boundaryFiber, retryLane);\n        }\n        function throwIfInfiniteUpdateLoopDetected() {\n            if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {\n                nestedUpdateCount = 0;\n                nestedPassiveUpdateCount = 0;\n                rootWithNestedUpdates = null;\n                rootWithPassiveNestedUpdates = null;\n                {\n                    if (executionContext & RenderContext && workInProgressRoot !== null) {\n                        // We're in the render phase. Disable the concurrent error recovery\n                        // mechanism to ensure that the error we're about to throw gets handled.\n                        // We need it to trigger the nearest error boundary so that the infinite\n                        // update loop is broken.\n                        workInProgressRoot.errorRecoveryDisabledLanes = mergeLanes(workInProgressRoot.errorRecoveryDisabledLanes, workInProgressRootRenderLanes);\n                    }\n                }\n                throw new Error('Maximum update depth exceeded. This can happen when a component ' + 'repeatedly calls setState inside componentWillUpdate or ' + 'componentDidUpdate. React limits the number of nested updates to ' + 'prevent infinite loops.');\n            }\n            {\n                if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {\n                    nestedPassiveUpdateCount = 0;\n                    rootWithPassiveNestedUpdates = null;\n                    error('Maximum update depth exceeded. This can happen when a component ' + \"calls setState inside useEffect, but useEffect either doesn't \" + 'have a dependency array, or one of the dependencies changes on ' + 'every render.');\n                }\n            }\n        }\n        function flushRenderPhaseStrictModeWarningsInDEV() {\n            {\n                ReactStrictModeWarnings.flushLegacyContextWarning();\n                ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();\n            }\n        }\n        function recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, parentFiber, isInStrictMode) {\n            if ((parentFiber.subtreeFlags & (PlacementDEV | Visibility)) === NoFlags$1) {\n                // Parent's descendants have already had effects double invoked.\n                // Early exit to avoid unnecessary tree traversal.\n                return;\n            }\n            var child = parentFiber.child;\n            while(child !== null){\n                doubleInvokeEffectsInDEVIfNecessary(root, child, isInStrictMode);\n                child = child.sibling;\n            }\n        } // Unconditionally disconnects and connects passive and layout effects.\n        function doubleInvokeEffectsOnFiber(root, fiber) {\n            var shouldDoubleInvokePassiveEffects = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n            setIsStrictModeForDevtools(true);\n            disappearLayoutEffects(fiber);\n            if (shouldDoubleInvokePassiveEffects) {\n                disconnectPassiveEffect(fiber);\n            }\n            reappearLayoutEffects(root, fiber.alternate, fiber, false);\n            if (shouldDoubleInvokePassiveEffects) {\n                reconnectPassiveEffects(root, fiber, NoLanes, null, false);\n            }\n            setIsStrictModeForDevtools(false);\n        }\n        function doubleInvokeEffectsInDEVIfNecessary(root, fiber, parentIsInStrictMode) {\n            var isStrictModeFiber = fiber.type === REACT_STRICT_MODE_TYPE;\n            var isInStrictMode = parentIsInStrictMode || isStrictModeFiber; // First case: the fiber **is not** of type OffscreenComponent. No\n            // special rules apply to double invoking effects.\n            if (fiber.tag !== OffscreenComponent) {\n                if (fiber.flags & PlacementDEV) {\n                    setCurrentDebugFiberInDEV(fiber);\n                    if (isInStrictMode) {\n                        doubleInvokeEffectsOnFiber(root, fiber, (fiber.mode & NoStrictPassiveEffectsMode) === NoMode);\n                    }\n                    resetCurrentDebugFiberInDEV();\n                } else {\n                    recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, fiber, isInStrictMode);\n                }\n                return;\n            } // Second case: the fiber **is** of type OffscreenComponent.\n            // This branch contains cases specific to Offscreen.\n            if (fiber.memoizedState === null) {\n                // Only consider Offscreen that is visible.\n                // TODO (Offscreen) Handle manual mode.\n                setCurrentDebugFiberInDEV(fiber);\n                if (isInStrictMode && fiber.flags & Visibility) {\n                    // Double invoke effects on Offscreen's subtree only\n                    // if it is visible and its visibility has changed.\n                    doubleInvokeEffectsOnFiber(root, fiber);\n                } else if (fiber.subtreeFlags & PlacementDEV) {\n                    // Something in the subtree could have been suspended.\n                    // We need to continue traversal and find newly inserted fibers.\n                    recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, fiber, isInStrictMode);\n                }\n                resetCurrentDebugFiberInDEV();\n            }\n        }\n        function commitDoubleInvokeEffectsInDEV(root, hasPassiveEffects) {\n            {\n                {\n                    var doubleInvokeEffects = true;\n                    if (!(root.current.mode & (StrictLegacyMode | StrictEffectsMode))) {\n                        doubleInvokeEffects = false;\n                    }\n                    recursivelyTraverseAndDoubleInvokeEffectsInDEV(root, root.current, doubleInvokeEffects);\n                }\n            }\n        }\n        var didWarnStateUpdateForNotYetMountedComponent = null;\n        function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {\n            {\n                if ((executionContext & RenderContext) !== NoContext) {\n                    // We let the other warning about render phase updates deal with this one.\n                    return;\n                }\n                var tag = fiber.tag;\n                if (tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {\n                    // Only warn for user-defined components, not internal ones like Suspense.\n                    return;\n                } // We show the whole stack but dedupe on the top component's name because\n                // the problematic code almost always lies inside that component.\n                var componentName = getComponentNameFromFiber(fiber) || 'ReactComponent';\n                if (didWarnStateUpdateForNotYetMountedComponent !== null) {\n                    if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {\n                        return;\n                    } // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    didWarnStateUpdateForNotYetMountedComponent.add(componentName);\n                } else {\n                    didWarnStateUpdateForNotYetMountedComponent = new Set([\n                        componentName\n                    ]);\n                }\n                var previousFiber = current;\n                try {\n                    setCurrentDebugFiberInDEV(fiber);\n                    error(\"Can't perform a React state update on a component that hasn't mounted yet. \" + 'This indicates that you have a side-effect in your render function that ' + 'asynchronously later calls tries to update the component. Move this work to ' + 'useEffect instead.');\n                } finally{\n                    if (previousFiber) {\n                        setCurrentDebugFiberInDEV(fiber);\n                    } else {\n                        resetCurrentDebugFiberInDEV();\n                    }\n                }\n            }\n        }\n        var didWarnAboutUpdateInRender = false;\n        var didWarnAboutUpdateInRenderForAnotherComponent;\n        {\n            didWarnAboutUpdateInRenderForAnotherComponent = new Set();\n        }\n        function warnAboutRenderPhaseUpdatesInDEV(fiber) {\n            {\n                if (isRendering) {\n                    switch(fiber.tag){\n                        case FunctionComponent:\n                        case ForwardRef:\n                        case SimpleMemoComponent:\n                            {\n                                var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || 'Unknown'; // Dedupe by the rendering component because it's the one that needs to be fixed.\n                                var dedupeKey = renderingComponentName;\n                                if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {\n                                    didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);\n                                    var setStateComponentName = getComponentNameFromFiber(fiber) || 'Unknown';\n                                    error('Cannot update a component (`%s`) while rendering a ' + 'different component (`%s`). To locate the bad setState() call inside `%s`, ' + 'follow the stack trace as described in https://react.dev/link/setstate-in-render', setStateComponentName, renderingComponentName, renderingComponentName);\n                                }\n                                break;\n                            }\n                        case ClassComponent:\n                            {\n                                if (!didWarnAboutUpdateInRender) {\n                                    error('Cannot update during an existing state transition (such as ' + 'within `render`). Render methods should be a pure ' + 'function of props and state.');\n                                    didWarnAboutUpdateInRender = true;\n                                }\n                                break;\n                            }\n                    }\n                }\n            }\n        }\n        function restorePendingUpdaters(root, lanes) {\n            {\n                if (isDevToolsPresent) {\n                    var memoizedUpdaters = root.memoizedUpdaters;\n                    memoizedUpdaters.forEach(function(schedulingFiber) {\n                        addFiberToLanesMap(root, schedulingFiber, lanes);\n                    }); // This function intentionally does not clear memoized updaters.\n                // Those may still be relevant to the current commit\n                // and a future one (e.g. Suspense).\n                }\n            }\n        }\n        var fakeActCallbackNode = {}; // $FlowFixMe[missing-local-annot]\n        function scheduleCallback(priorityLevel, callback) {\n            {\n                // If we're currently inside an `act` scope, bypass Scheduler and push to\n                // the `act` queue instead.\n                var actQueue = ReactSharedInternals.actQueue;\n                if (actQueue !== null) {\n                    actQueue.push(callback);\n                    return fakeActCallbackNode;\n                } else {\n                    return scheduleCallback$3(priorityLevel, callback);\n                }\n            }\n        }\n        function shouldForceFlushFallbacksInDEV() {\n            // Never force flush in production. This function should get stripped out.\n            return ReactSharedInternals.actQueue !== null;\n        }\n        function warnIfUpdatesNotWrappedWithActDEV(fiber) {\n            {\n                {\n                    if (!isConcurrentActEnvironment()) {\n                        // Not in an act environment. No need to warn.\n                        return;\n                    }\n                }\n                if (ReactSharedInternals.actQueue === null) {\n                    var previousFiber = current;\n                    try {\n                        setCurrentDebugFiberInDEV(fiber);\n                        error('An update to %s inside a test was not wrapped in act(...).\\n\\n' + 'When testing, code that causes React state updates should be ' + 'wrapped into act(...):\\n\\n' + 'act(() => {\\n' + '  /* fire events that update state */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://react.dev/link/wrap-tests-with-act', getComponentNameFromFiber(fiber));\n                    } finally{\n                        if (previousFiber) {\n                            setCurrentDebugFiberInDEV(fiber);\n                        } else {\n                            resetCurrentDebugFiberInDEV();\n                        }\n                    }\n                }\n            }\n        }\n        function warnIfSuspenseResolutionNotWrappedWithActDEV(root) {\n            {\n                if (isConcurrentActEnvironment() && ReactSharedInternals.actQueue === null) {\n                    error('A suspended resource finished loading inside a test, but the event ' + 'was not wrapped in act(...).\\n\\n' + 'When testing, code that resolves suspended data should be wrapped ' + 'into act(...):\\n\\n' + 'act(() => {\\n' + '  /* finish loading suspended data */\\n' + '});\\n' + '/* assert on the output */\\n\\n' + \"This ensures that you're testing the behavior the user would see \" + 'in the browser.' + ' Learn more at https://react.dev/link/wrap-tests-with-act');\n                }\n            }\n        }\n        function setIsRunningInsertionEffect(isRunning) {\n            {\n                isRunningInsertionEffect = isRunning;\n            }\n        }\n        /* eslint-disable react-internal/prod-error-codes */ // Used by React Refresh runtime through DevTools Global Hook.\n        var resolveFamily = null;\n        var failedBoundaries = null;\n        var setRefreshHandler = function(handler) {\n            {\n                resolveFamily = handler;\n            }\n        };\n        function resolveFunctionForHotReloading(type) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return type;\n                }\n                var family = resolveFamily(type);\n                if (family === undefined) {\n                    return type;\n                } // Use the latest known implementation.\n                return family.current;\n            }\n        }\n        function resolveClassForHotReloading(type) {\n            // No implementation differences.\n            return resolveFunctionForHotReloading(type);\n        }\n        function resolveForwardRefForHotReloading(type) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return type;\n                }\n                var family = resolveFamily(type);\n                if (family === undefined) {\n                    // Check if we're dealing with a real forwardRef. Don't want to crash early.\n                    if (type !== null && type !== undefined && typeof type.render === 'function') {\n                        // ForwardRef is special because its resolved .type is an object,\n                        // but it's possible that we only have its inner render function in the map.\n                        // If that inner render function is different, we'll build a new forwardRef type.\n                        var currentRender = resolveFunctionForHotReloading(type.render);\n                        if (type.render !== currentRender) {\n                            var syntheticType = {\n                                $$typeof: REACT_FORWARD_REF_TYPE,\n                                render: currentRender\n                            };\n                            if (type.displayName !== undefined) {\n                                syntheticType.displayName = type.displayName;\n                            }\n                            return syntheticType;\n                        }\n                    }\n                    return type;\n                } // Use the latest known implementation.\n                return family.current;\n            }\n        }\n        function isCompatibleFamilyForHotReloading(fiber, element) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return false;\n                }\n                var prevType = fiber.elementType;\n                var nextType = element.type; // If we got here, we know types aren't === equal.\n                var needsCompareFamilies = false;\n                var $$typeofNextType = typeof nextType === 'object' && nextType !== null ? nextType.$$typeof : null;\n                switch(fiber.tag){\n                    case ClassComponent:\n                        {\n                            if (typeof nextType === 'function') {\n                                needsCompareFamilies = true;\n                            }\n                            break;\n                        }\n                    case FunctionComponent:\n                        {\n                            if (typeof nextType === 'function') {\n                                needsCompareFamilies = true;\n                            } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                                // We don't know the inner type yet.\n                                // We're going to assume that the lazy inner type is stable,\n                                // and so it is sufficient to avoid reconciling it away.\n                                // We're not going to unwrap or actually use the new lazy type.\n                                needsCompareFamilies = true;\n                            }\n                            break;\n                        }\n                    case ForwardRef:\n                        {\n                            if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {\n                                needsCompareFamilies = true;\n                            } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                                needsCompareFamilies = true;\n                            }\n                            break;\n                        }\n                    case MemoComponent:\n                    case SimpleMemoComponent:\n                        {\n                            if ($$typeofNextType === REACT_MEMO_TYPE) {\n                                // TODO: if it was but can no longer be simple,\n                                // we shouldn't set this.\n                                needsCompareFamilies = true;\n                            } else if ($$typeofNextType === REACT_LAZY_TYPE) {\n                                needsCompareFamilies = true;\n                            }\n                            break;\n                        }\n                    default:\n                        return false;\n                } // Check if both types have a family and it's the same one.\n                if (needsCompareFamilies) {\n                    // Note: memo() and forwardRef() we'll compare outer rather than inner type.\n                    // This means both of them need to be registered to preserve state.\n                    // If we unwrapped and compared the inner types for wrappers instead,\n                    // then we would risk falsely saying two separate memo(Foo)\n                    // calls are equivalent because they wrap the same Foo function.\n                    var prevFamily = resolveFamily(prevType); // $FlowFixMe[not-a-function] found when upgrading Flow\n                    if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) {\n                        return true;\n                    }\n                }\n                return false;\n            }\n        }\n        function markFailedErrorBoundaryForHotReloading(fiber) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return;\n                }\n                if (typeof WeakSet !== 'function') {\n                    return;\n                }\n                if (failedBoundaries === null) {\n                    failedBoundaries = new WeakSet();\n                }\n                failedBoundaries.add(fiber);\n            }\n        }\n        var scheduleRefresh = function(root, update) {\n            {\n                if (resolveFamily === null) {\n                    // Hot reloading is disabled.\n                    return;\n                }\n                var staleFamilies = update.staleFamilies, updatedFamilies = update.updatedFamilies;\n                flushPassiveEffects();\n                scheduleFibersWithFamiliesRecursively(root.current, updatedFamilies, staleFamilies);\n                flushSyncWork();\n            }\n        };\n        var scheduleRoot = function(root, element) {\n            {\n                if (root.context !== emptyContextObject) {\n                    // Super edge case: root has a legacy _renderSubtree context\n                    // but we don't know the parentComponent so we can't pass it.\n                    // Just ignore. We'll delete this with _renderSubtree code path later.\n                    return;\n                }\n                updateContainerSync(element, root, null, null);\n                flushSyncWork();\n            }\n        };\n        function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {\n            {\n                var alternate = fiber.alternate, child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;\n                var candidateType = null;\n                switch(tag){\n                    case FunctionComponent:\n                    case SimpleMemoComponent:\n                    case ClassComponent:\n                        candidateType = type;\n                        break;\n                    case ForwardRef:\n                        candidateType = type.render;\n                        break;\n                }\n                if (resolveFamily === null) {\n                    throw new Error('Expected resolveFamily to be set during hot reload.');\n                }\n                var needsRender = false;\n                var needsRemount = false;\n                if (candidateType !== null) {\n                    var family = resolveFamily(candidateType);\n                    if (family !== undefined) {\n                        if (staleFamilies.has(family)) {\n                            needsRemount = true;\n                        } else if (updatedFamilies.has(family)) {\n                            if (tag === ClassComponent) {\n                                needsRemount = true;\n                            } else {\n                                needsRender = true;\n                            }\n                        }\n                    }\n                }\n                if (failedBoundaries !== null) {\n                    if (failedBoundaries.has(fiber) || // $FlowFixMe[incompatible-use] found when upgrading Flow\n                    alternate !== null && failedBoundaries.has(alternate)) {\n                        needsRemount = true;\n                    }\n                }\n                if (needsRemount) {\n                    fiber._debugNeedsRemount = true;\n                }\n                if (needsRemount || needsRender) {\n                    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                    if (root !== null) {\n                        scheduleUpdateOnFiber(root, fiber, SyncLane);\n                    }\n                }\n                if (child !== null && !needsRemount) {\n                    scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);\n                }\n                if (sibling !== null) {\n                    scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);\n                }\n            }\n        }\n        var findHostInstancesForRefresh = function(root, families) {\n            {\n                var hostInstances = new Set();\n                var types = new Set(families.map(function(family) {\n                    return family.current;\n                }));\n                findHostInstancesForMatchingFibersRecursively(root.current, types, hostInstances);\n                return hostInstances;\n            }\n        };\n        function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {\n            {\n                var child = fiber.child, sibling = fiber.sibling, tag = fiber.tag, type = fiber.type;\n                var candidateType = null;\n                switch(tag){\n                    case FunctionComponent:\n                    case SimpleMemoComponent:\n                    case ClassComponent:\n                        candidateType = type;\n                        break;\n                    case ForwardRef:\n                        candidateType = type.render;\n                        break;\n                }\n                var didMatch = false;\n                if (candidateType !== null) {\n                    if (types.has(candidateType)) {\n                        didMatch = true;\n                    }\n                }\n                if (didMatch) {\n                    // We have a match. This only drills down to the closest host components.\n                    // There's no need to search deeper because for the purpose of giving\n                    // visual feedback, \"flashing\" outermost parent rectangles is sufficient.\n                    findHostInstancesForFiberShallowly(fiber, hostInstances);\n                } else {\n                    // If there's no match, maybe there will be one further down in the child tree.\n                    if (child !== null) {\n                        findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);\n                    }\n                }\n                if (sibling !== null) {\n                    findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);\n                }\n            }\n        }\n        function findHostInstancesForFiberShallowly(fiber, hostInstances) {\n            {\n                var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);\n                if (foundHostInstances) {\n                    return;\n                } // If we didn't find any host children, fallback to closest host parent.\n                var node = fiber;\n                while(true){\n                    switch(node.tag){\n                        case HostSingleton:\n                        case HostComponent:\n                            hostInstances.add(node.stateNode);\n                            return;\n                        case HostPortal:\n                            hostInstances.add(node.stateNode.containerInfo);\n                            return;\n                        case HostRoot:\n                            hostInstances.add(node.stateNode.containerInfo);\n                            return;\n                    }\n                    if (node.return === null) {\n                        throw new Error('Expected to reach root first.');\n                    }\n                    node = node.return;\n                }\n            }\n        }\n        function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {\n            {\n                var node = fiber;\n                var foundHostInstances = false;\n                while(true){\n                    if (node.tag === HostComponent || node.tag === HostHoistable || (supportsSingletons ? node.tag === HostSingleton : false)) {\n                        // We got a match.\n                        foundHostInstances = true;\n                        hostInstances.add(node.stateNode); // There may still be more, so keep searching.\n                    } else if (node.child !== null) {\n                        node.child.return = node;\n                        node = node.child;\n                        continue;\n                    }\n                    if (node === fiber) {\n                        return foundHostInstances;\n                    }\n                    while(node.sibling === null){\n                        if (node.return === null || node.return === fiber) {\n                            return foundHostInstances;\n                        }\n                        node = node.return;\n                    }\n                    node.sibling.return = node.return;\n                    node = node.sibling;\n                }\n            }\n            return false;\n        }\n        var hasBadMapPolyfill;\n        {\n            hasBadMapPolyfill = false;\n            try {\n                var nonExtensibleObject = Object.preventExtensions({});\n                /* eslint-disable no-new */ new Map([\n                    [\n                        nonExtensibleObject,\n                        null\n                    ]\n                ]);\n                new Set([\n                    nonExtensibleObject\n                ]);\n            /* eslint-enable no-new */ } catch (e) {\n                // TODO: Consider warning about bad polyfills\n                hasBadMapPolyfill = true;\n            }\n        }\n        function FiberNode(tag, pendingProps, key, mode) {\n            // Instance\n            this.tag = tag;\n            this.key = key;\n            this.elementType = null;\n            this.type = null;\n            this.stateNode = null; // Fiber\n            this.return = null;\n            this.child = null;\n            this.sibling = null;\n            this.index = 0;\n            this.ref = null;\n            this.refCleanup = null;\n            this.pendingProps = pendingProps;\n            this.memoizedProps = null;\n            this.updateQueue = null;\n            this.memoizedState = null;\n            this.dependencies = null;\n            this.mode = mode; // Effects\n            this.flags = NoFlags$1;\n            this.subtreeFlags = NoFlags$1;\n            this.deletions = null;\n            this.lanes = NoLanes;\n            this.childLanes = NoLanes;\n            this.alternate = null;\n            {\n                // Note: The following is done to avoid a v8 performance cliff.\n                //\n                // Initializing the fields below to smis and later updating them with\n                // double values will cause Fibers to end up having separate shapes.\n                // This behavior/bug has something to do with Object.preventExtension().\n                // Fortunately this only impacts DEV builds.\n                // Unfortunately it makes React unusably slow for some applications.\n                // To work around this, initialize the fields below with doubles.\n                //\n                // Learn more about this here:\n                // https://github.com/facebook/react/issues/14365\n                // https://bugs.chromium.org/p/v8/issues/detail?id=8538\n                this.actualDuration = Number.NaN;\n                this.actualStartTime = Number.NaN;\n                this.selfBaseDuration = Number.NaN;\n                this.treeBaseDuration = Number.NaN; // It's okay to replace the initial doubles with smis after initialization.\n                // This won't trigger the performance cliff mentioned above,\n                // and it simplifies other profiler code (including DevTools).\n                this.actualDuration = 0;\n                this.actualStartTime = -1;\n                this.selfBaseDuration = 0;\n                this.treeBaseDuration = 0;\n            }\n            {\n                // This isn't directly used but is handy for debugging internals:\n                this._debugInfo = null;\n                this._debugOwner = null;\n                this._debugNeedsRemount = false;\n                this._debugHookTypes = null;\n                if (!hasBadMapPolyfill && typeof Object.preventExtensions === 'function') {\n                    Object.preventExtensions(this);\n                }\n            }\n        } // This is a constructor function, rather than a POJO constructor, still\n        // please ensure we do the following:\n        // 1) Nobody should add any instance methods on this. Instance methods can be\n        //    more difficult to predict when they get optimized and they are almost\n        //    never inlined properly in static compilers.\n        // 2) Nobody should rely on `instanceof Fiber` for type testing. We should\n        //    always know when it is a fiber.\n        // 3) We might want to experiment with using numeric keys since they are easier\n        //    to optimize in a non-JIT environment.\n        // 4) We can easily go from a constructor to a createFiber object literal if that\n        //    is faster.\n        // 5) It should be easy to port this to a C struct and keep a C implementation\n        //    compatible.\n        function createFiber(tag, pendingProps, key, mode) {\n            // $FlowFixMe[invalid-constructor]: the shapes are exact here but Flow doesn't like constructors\n            return new FiberNode(tag, pendingProps, key, mode);\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function isSimpleFunctionComponent(type) {\n            return typeof type === 'function' && !shouldConstruct(type) && type.defaultProps === undefined;\n        }\n        function isFunctionClassComponent(type) {\n            return shouldConstruct(type);\n        } // This is used to create an alternate fiber to do work on.\n        function createWorkInProgress(current, pendingProps) {\n            var workInProgress = current.alternate;\n            if (workInProgress === null) {\n                // We use a double buffering pooling technique because we know that we'll\n                // only ever need at most two versions of a tree. We pool the \"other\" unused\n                // node that we're free to reuse. This is lazily created to avoid allocating\n                // extra objects for things that are never updated. It also allow us to\n                // reclaim the extra memory if needed.\n                workInProgress = createFiber(current.tag, pendingProps, current.key, current.mode);\n                workInProgress.elementType = current.elementType;\n                workInProgress.type = current.type;\n                workInProgress.stateNode = current.stateNode;\n                {\n                    // DEV-only fields\n                    workInProgress._debugOwner = current._debugOwner;\n                    workInProgress._debugHookTypes = current._debugHookTypes;\n                }\n                workInProgress.alternate = current;\n                current.alternate = workInProgress;\n            } else {\n                workInProgress.pendingProps = pendingProps; // Needed because Blocks store data on type.\n                workInProgress.type = current.type; // We already have an alternate.\n                // Reset the effect tag.\n                workInProgress.flags = NoFlags$1; // The effects are no longer valid.\n                workInProgress.subtreeFlags = NoFlags$1;\n                workInProgress.deletions = null;\n                {\n                    // We intentionally reset, rather than copy, actualDuration & actualStartTime.\n                    // This prevents time from endlessly accumulating in new commits.\n                    // This has the downside of resetting values for different priority renders,\n                    // But works for yielding (the common case) and should support resuming.\n                    workInProgress.actualDuration = 0;\n                    workInProgress.actualStartTime = -1;\n                }\n            } // Reset all effects except static ones.\n            // Static effects are not specific to a render.\n            workInProgress.flags = current.flags & StaticMask;\n            workInProgress.childLanes = current.childLanes;\n            workInProgress.lanes = current.lanes;\n            workInProgress.child = current.child;\n            workInProgress.memoizedProps = current.memoizedProps;\n            workInProgress.memoizedState = current.memoizedState;\n            workInProgress.updateQueue = current.updateQueue; // Clone the dependencies object. This is mutated during the render phase, so\n            // it cannot be shared with the current fiber.\n            var currentDependencies = current.dependencies;\n            workInProgress.dependencies = currentDependencies === null ? null : {\n                lanes: currentDependencies.lanes,\n                firstContext: currentDependencies.firstContext\n            }; // These will be overridden during the parent's reconciliation\n            workInProgress.sibling = current.sibling;\n            workInProgress.index = current.index;\n            workInProgress.ref = current.ref;\n            workInProgress.refCleanup = current.refCleanup;\n            {\n                workInProgress.selfBaseDuration = current.selfBaseDuration;\n                workInProgress.treeBaseDuration = current.treeBaseDuration;\n            }\n            {\n                workInProgress._debugInfo = current._debugInfo;\n                workInProgress._debugNeedsRemount = current._debugNeedsRemount;\n                switch(workInProgress.tag){\n                    case FunctionComponent:\n                    case SimpleMemoComponent:\n                        workInProgress.type = resolveFunctionForHotReloading(current.type);\n                        break;\n                    case ClassComponent:\n                        workInProgress.type = resolveClassForHotReloading(current.type);\n                        break;\n                    case ForwardRef:\n                        workInProgress.type = resolveForwardRefForHotReloading(current.type);\n                        break;\n                }\n            }\n            return workInProgress;\n        } // Used to reuse a Fiber for a second pass.\n        function resetWorkInProgress(workInProgress, renderLanes) {\n            // This resets the Fiber to what createFiber or createWorkInProgress would\n            // have set the values to before during the first pass. Ideally this wouldn't\n            // be necessary but unfortunately many code paths reads from the workInProgress\n            // when they should be reading from current and writing to workInProgress.\n            // We assume pendingProps, index, key, ref, return are still untouched to\n            // avoid doing another reconciliation.\n            // Reset the effect flags but keep any Placement tags, since that's something\n            // that child fiber is setting, not the reconciliation.\n            workInProgress.flags &= StaticMask | Placement; // The effects are no longer valid.\n            var current = workInProgress.alternate;\n            if (current === null) {\n                // Reset to createFiber's initial values.\n                workInProgress.childLanes = NoLanes;\n                workInProgress.lanes = renderLanes;\n                workInProgress.child = null;\n                workInProgress.subtreeFlags = NoFlags$1;\n                workInProgress.memoizedProps = null;\n                workInProgress.memoizedState = null;\n                workInProgress.updateQueue = null;\n                workInProgress.dependencies = null;\n                workInProgress.stateNode = null;\n                {\n                    // Note: We don't reset the actualTime counts. It's useful to accumulate\n                    // actual time across multiple render passes.\n                    workInProgress.selfBaseDuration = 0;\n                    workInProgress.treeBaseDuration = 0;\n                }\n            } else {\n                // Reset to the cloned values that createWorkInProgress would've.\n                workInProgress.childLanes = current.childLanes;\n                workInProgress.lanes = current.lanes;\n                workInProgress.child = current.child;\n                workInProgress.subtreeFlags = NoFlags$1;\n                workInProgress.deletions = null;\n                workInProgress.memoizedProps = current.memoizedProps;\n                workInProgress.memoizedState = current.memoizedState;\n                workInProgress.updateQueue = current.updateQueue; // Needed because Blocks store data on type.\n                workInProgress.type = current.type; // Clone the dependencies object. This is mutated during the render phase, so\n                // it cannot be shared with the current fiber.\n                var currentDependencies = current.dependencies;\n                workInProgress.dependencies = currentDependencies === null ? null : {\n                    lanes: currentDependencies.lanes,\n                    firstContext: currentDependencies.firstContext\n                };\n                {\n                    // Note: We don't reset the actualTime counts. It's useful to accumulate\n                    // actual time across multiple render passes.\n                    workInProgress.selfBaseDuration = current.selfBaseDuration;\n                    workInProgress.treeBaseDuration = current.treeBaseDuration;\n                }\n            }\n            return workInProgress;\n        }\n        function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {\n            var mode;\n            {\n                mode = ConcurrentMode;\n                if (isStrictMode === true) {\n                    mode |= StrictLegacyMode | StrictEffectsMode;\n                }\n            }\n            if (isDevToolsPresent) {\n                // Always collect profile timings when DevTools are present.\n                // This enables DevTools to start capturing timing at any point–\n                // Without some nodes in the tree having empty base times.\n                mode |= ProfileMode;\n            }\n            return createFiber(HostRoot, null, null, mode);\n        }\n        function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {\n            var fiberTag = FunctionComponent; // The resolved type is set if we know what the final type will be. I.e. it's not lazy.\n            var resolvedType = type;\n            if (typeof type === 'function') {\n                if (shouldConstruct(type)) {\n                    fiberTag = ClassComponent;\n                    {\n                        resolvedType = resolveClassForHotReloading(resolvedType);\n                    }\n                } else {\n                    {\n                        resolvedType = resolveFunctionForHotReloading(resolvedType);\n                    }\n                }\n            } else if (typeof type === 'string') {\n                if (supportsResources && supportsSingletons) {\n                    var hostContext = getHostContext();\n                    fiberTag = isHostHoistableType(type, pendingProps, hostContext) ? HostHoistable : isHostSingletonType(type) ? HostSingleton : HostComponent;\n                } else if (supportsResources) {\n                    var _hostContext = getHostContext();\n                    fiberTag = isHostHoistableType(type, pendingProps, _hostContext) ? HostHoistable : HostComponent;\n                } else if (supportsSingletons) {\n                    fiberTag = isHostSingletonType(type) ? HostSingleton : HostComponent;\n                } else {\n                    fiberTag = HostComponent;\n                }\n            } else {\n                getTag: switch(type){\n                    case REACT_FRAGMENT_TYPE:\n                        return createFiberFromFragment(pendingProps.children, mode, lanes, key);\n                    case REACT_STRICT_MODE_TYPE:\n                        fiberTag = Mode;\n                        mode |= StrictLegacyMode;\n                        {\n                            // Strict effects should never run on legacy roots\n                            mode |= StrictEffectsMode;\n                        }\n                        break;\n                    case REACT_PROFILER_TYPE:\n                        return createFiberFromProfiler(pendingProps, mode, lanes, key);\n                    case REACT_SUSPENSE_TYPE:\n                        return createFiberFromSuspense(pendingProps, mode, lanes, key);\n                    case REACT_SUSPENSE_LIST_TYPE:\n                        return createFiberFromSuspenseList(pendingProps, mode, lanes, key);\n                    case REACT_OFFSCREEN_TYPE:\n                        return createFiberFromOffscreen(pendingProps, mode, lanes, key);\n                    case REACT_LEGACY_HIDDEN_TYPE:\n                    // Fall through\n                    case REACT_SCOPE_TYPE:\n                    // Fall through\n                    case REACT_TRACING_MARKER_TYPE:\n                    // Fall through\n                    case REACT_DEBUG_TRACING_MODE_TYPE:\n                    // Fall through\n                    default:\n                        {\n                            if (typeof type === 'object' && type !== null) {\n                                switch(type.$$typeof){\n                                    case REACT_PROVIDER_TYPE:\n                                    // Fall through\n                                    case REACT_CONTEXT_TYPE:\n                                        {\n                                            fiberTag = ContextProvider;\n                                            break getTag;\n                                        }\n                                    case REACT_CONSUMER_TYPE:\n                                        {\n                                            fiberTag = ContextConsumer;\n                                            break getTag;\n                                        }\n                                    // Fall through\n                                    case REACT_FORWARD_REF_TYPE:\n                                        fiberTag = ForwardRef;\n                                        {\n                                            resolvedType = resolveForwardRefForHotReloading(resolvedType);\n                                        }\n                                        break getTag;\n                                    case REACT_MEMO_TYPE:\n                                        fiberTag = MemoComponent;\n                                        break getTag;\n                                    case REACT_LAZY_TYPE:\n                                        fiberTag = LazyComponent;\n                                        resolvedType = null;\n                                        break getTag;\n                                }\n                            }\n                            var info = '';\n                            var typeString;\n                            {\n                                if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n                                    info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n                                }\n                                if (type === null) {\n                                    typeString = 'null';\n                                } else if (isArray(type)) {\n                                    typeString = 'array';\n                                } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                                    typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n                                    info = ' Did you accidentally export a JSX literal instead of a component?';\n                                } else {\n                                    typeString = typeof type;\n                                }\n                                var ownerName = owner ? getComponentNameFromOwner(owner) : null;\n                                if (ownerName) {\n                                    info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n                                }\n                            }\n                            throw new Error('Element type is invalid: expected a string (for built-in ' + 'components) or a class/function (for composite components) ' + (\"but got: \" + typeString + \".\" + info));\n                        }\n                }\n            }\n            var fiber = createFiber(fiberTag, pendingProps, key, mode);\n            fiber.elementType = type;\n            fiber.type = resolvedType;\n            fiber.lanes = lanes;\n            {\n                fiber._debugOwner = owner;\n            }\n            return fiber;\n        }\n        function createFiberFromElement(element, mode, lanes) {\n            var owner = null;\n            {\n                owner = element._owner;\n            }\n            var type = element.type;\n            var key = element.key;\n            var pendingProps = element.props;\n            var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);\n            {\n                fiber._debugOwner = element._owner;\n            }\n            return fiber;\n        }\n        function createFiberFromFragment(elements, mode, lanes, key) {\n            var fiber = createFiber(Fragment, elements, key, mode);\n            fiber.lanes = lanes;\n            return fiber;\n        }\n        function createFiberFromProfiler(pendingProps, mode, lanes, key) {\n            {\n                if (typeof pendingProps.id !== 'string') {\n                    error('Profiler must specify an \"id\" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);\n                }\n            }\n            var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);\n            fiber.elementType = REACT_PROFILER_TYPE;\n            fiber.lanes = lanes;\n            {\n                fiber.stateNode = {\n                    effectDuration: 0,\n                    passiveEffectDuration: 0\n                };\n            }\n            return fiber;\n        }\n        function createFiberFromSuspense(pendingProps, mode, lanes, key) {\n            var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);\n            fiber.elementType = REACT_SUSPENSE_TYPE;\n            fiber.lanes = lanes;\n            return fiber;\n        }\n        function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {\n            var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);\n            fiber.elementType = REACT_SUSPENSE_LIST_TYPE;\n            fiber.lanes = lanes;\n            return fiber;\n        }\n        function createFiberFromOffscreen(pendingProps, mode, lanes, key) {\n            var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);\n            fiber.elementType = REACT_OFFSCREEN_TYPE;\n            fiber.lanes = lanes;\n            var primaryChildInstance = {\n                _visibility: OffscreenVisible,\n                _pendingVisibility: OffscreenVisible,\n                _pendingMarkers: null,\n                _retryCache: null,\n                _transitions: null,\n                _current: null,\n                detach: function() {\n                    return detachOffscreenInstance(primaryChildInstance);\n                },\n                attach: function() {\n                    return attachOffscreenInstance(primaryChildInstance);\n                }\n            };\n            fiber.stateNode = primaryChildInstance;\n            return fiber;\n        }\n        function createFiberFromText(content, mode, lanes) {\n            var fiber = createFiber(HostText, content, null, mode);\n            fiber.lanes = lanes;\n            return fiber;\n        }\n        function createFiberFromDehydratedFragment(dehydratedNode) {\n            var fiber = createFiber(DehydratedFragment, null, null, NoMode);\n            fiber.stateNode = dehydratedNode;\n            return fiber;\n        }\n        function createFiberFromPortal(portal, mode, lanes) {\n            var pendingProps = portal.children !== null ? portal.children : [];\n            var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);\n            fiber.lanes = lanes;\n            fiber.stateNode = {\n                containerInfo: portal.containerInfo,\n                pendingChildren: null,\n                // Used by persistent updates\n                implementation: portal.implementation\n            };\n            return fiber;\n        }\n        function FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState) {\n            this.tag = ConcurrentRoot;\n            this.containerInfo = containerInfo;\n            this.pendingChildren = null;\n            this.current = null;\n            this.pingCache = null;\n            this.finishedWork = null;\n            this.timeoutHandle = noTimeout;\n            this.cancelPendingCommit = null;\n            this.context = null;\n            this.pendingContext = null;\n            this.next = null;\n            this.callbackNode = null;\n            this.callbackPriority = NoLane;\n            this.expirationTimes = createLaneMap(NoTimestamp);\n            this.pendingLanes = NoLanes;\n            this.suspendedLanes = NoLanes;\n            this.pingedLanes = NoLanes;\n            this.expiredLanes = NoLanes;\n            this.finishedLanes = NoLanes;\n            this.errorRecoveryDisabledLanes = NoLanes;\n            this.shellSuspendCounter = 0;\n            this.entangledLanes = NoLanes;\n            this.entanglements = createLaneMap(NoLanes);\n            this.hiddenUpdates = createLaneMap(null);\n            this.identifierPrefix = identifierPrefix;\n            this.onUncaughtError = onUncaughtError;\n            this.onCaughtError = onCaughtError;\n            this.onRecoverableError = onRecoverableError;\n            {\n                this.pooledCache = null;\n                this.pooledCacheLanes = NoLanes;\n            }\n            this.formState = formState;\n            this.incompleteTransitions = new Map();\n            {\n                this.effectDuration = 0;\n                this.passiveEffectDuration = 0;\n            }\n            {\n                this.memoizedUpdaters = new Set();\n                var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];\n                for(var _i = 0; _i < TotalLanes; _i++){\n                    pendingUpdatersLaneMap.push(new Set());\n                }\n            }\n            {\n                {\n                    // TODO: This varies by each renderer.\n                    this._debugRootType = hydrate ? 'hydrateRoot()' : 'createRoot()';\n                }\n            }\n        }\n        function createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, // host config, but because they are passed in at runtime, we have to thread\n        // them through the root constructor. Perhaps we should put them all into a\n        // single type, like a DynamicHostConfig that is defined by the renderer.\n        identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {\n            // $FlowFixMe[invalid-constructor] Flow no longer supports calling new on functions\n            var root = new FiberRootNode(containerInfo, tag, hydrate, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, formState);\n            // stateNode is any.\n            var uninitializedFiber = createHostRootFiber(tag, isStrictMode);\n            root.current = uninitializedFiber;\n            uninitializedFiber.stateNode = root;\n            {\n                var initialCache = createCache();\n                retainCache(initialCache); // The pooledCache is a fresh cache instance that is used temporarily\n                // for newly mounted boundaries during a render. In general, the\n                // pooledCache is always cleared from the root at the end of a render:\n                // it is either released when render commits, or moved to an Offscreen\n                // component if rendering suspends. Because the lifetime of the pooled\n                // cache is distinct from the main memoizedState.cache, it must be\n                // retained separately.\n                root.pooledCache = initialCache;\n                retainCache(initialCache);\n                var initialState = {\n                    element: initialChildren,\n                    isDehydrated: hydrate,\n                    cache: initialCache\n                };\n                uninitializedFiber.memoizedState = initialState;\n            }\n            initializeUpdateQueue(uninitializedFiber);\n            return root;\n        }\n        var ReactVersion = '19.0.0-rc-935180c7e0-20240524';\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return '' + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before using it here.', typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        function createPortal(children, containerInfo, implementation) {\n            var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n            {\n                checkKeyStringCoercion(key);\n            }\n            return {\n                // This tag allow us to uniquely identify this as a React Portal\n                $$typeof: REACT_PORTAL_TYPE,\n                key: key == null ? null : '' + key,\n                children: children,\n                containerInfo: containerInfo,\n                implementation: implementation\n            };\n        }\n        // Might add PROFILE later.\n        var didWarnAboutNestedUpdates;\n        var didWarnAboutFindNodeInStrictMode;\n        {\n            didWarnAboutNestedUpdates = false;\n            didWarnAboutFindNodeInStrictMode = {};\n        }\n        function getContextForSubtree(parentComponent) {\n            if (!parentComponent) {\n                return emptyContextObject;\n            }\n            var fiber = get(parentComponent);\n            var parentContext = findCurrentUnmaskedContext();\n            if (fiber.tag === ClassComponent) {\n                var Component = fiber.type;\n                if (isContextProvider()) {\n                    return processChildContext(fiber, Component, parentContext);\n                }\n            }\n            return parentContext;\n        }\n        function findHostInstance(component) {\n            var fiber = get(component);\n            if (fiber === undefined) {\n                if (typeof component.render === 'function') {\n                    throw new Error('Unable to find node on an unmounted component.');\n                } else {\n                    var keys = Object.keys(component).join(',');\n                    throw new Error(\"Argument appears to not be a ReactComponent. Keys: \" + keys);\n                }\n            }\n            var hostFiber = findCurrentHostFiber(fiber);\n            if (hostFiber === null) {\n                return null;\n            }\n            return getPublicInstance(hostFiber.stateNode);\n        }\n        function findHostInstanceWithWarning(component, methodName) {\n            {\n                var fiber = get(component);\n                if (fiber === undefined) {\n                    if (typeof component.render === 'function') {\n                        throw new Error('Unable to find node on an unmounted component.');\n                    } else {\n                        var keys = Object.keys(component).join(',');\n                        throw new Error(\"Argument appears to not be a ReactComponent. Keys: \" + keys);\n                    }\n                }\n                var hostFiber = findCurrentHostFiber(fiber);\n                if (hostFiber === null) {\n                    return null;\n                }\n                if (hostFiber.mode & StrictLegacyMode) {\n                    var componentName = getComponentNameFromFiber(fiber) || 'Component';\n                    if (!didWarnAboutFindNodeInStrictMode[componentName]) {\n                        didWarnAboutFindNodeInStrictMode[componentName] = true;\n                        var previousFiber = current;\n                        try {\n                            setCurrentDebugFiberInDEV(hostFiber);\n                            if (fiber.mode & StrictLegacyMode) {\n                                error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which is inside StrictMode. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://react.dev/link/strict-mode-find-node', methodName, methodName, componentName);\n                            } else {\n                                error('%s is deprecated in StrictMode. ' + '%s was passed an instance of %s which renders StrictMode children. ' + 'Instead, add a ref directly to the element you want to reference. ' + 'Learn more about using refs safely here: ' + 'https://react.dev/link/strict-mode-find-node', methodName, methodName, componentName);\n                            }\n                        } finally{\n                            // Ideally this should reset to previous but this shouldn't be called in\n                            // render and there's another warning for that anyway.\n                            if (previousFiber) {\n                                setCurrentDebugFiberInDEV(previousFiber);\n                            } else {\n                                resetCurrentDebugFiberInDEV();\n                            }\n                        }\n                    }\n                }\n                return getPublicInstance(hostFiber.stateNode);\n            }\n        }\n        function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks) {\n            var hydrate = false;\n            var initialChildren = null;\n            return createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, null);\n        }\n        function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState) {\n            var hydrate = true;\n            var root = createFiberRoot(containerInfo, tag, hydrate, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onUncaughtError, onCaughtError, onRecoverableError, transitionCallbacks, formState); // TODO: Move this to FiberRoot constructor\n            root.context = getContextForSubtree(null); // Schedule the initial render. In a hydration root, this is different from\n            // a regular update because the initial render must match was was rendered\n            // on the server.\n            // NOTE: This update intentionally doesn't have a payload. We're only using\n            // the update to schedule work on the root fiber (and, for legacy roots, to\n            // enqueue the callback if one is provided).\n            var current = root.current;\n            var lane = requestUpdateLane(current);\n            var update = createUpdate(lane);\n            update.callback = callback !== undefined && callback !== null ? callback : null;\n            enqueueUpdate(current, update, lane);\n            scheduleInitialHydrationOnRoot(root, lane);\n            return root;\n        }\n        function updateContainer(element, container, parentComponent, callback) {\n            var current = container.current;\n            var lane = requestUpdateLane(current);\n            updateContainerImpl(current, lane, element, container, parentComponent, callback);\n            return lane;\n        }\n        function updateContainerSync(element, container, parentComponent, callback) {\n            if (container.tag === LegacyRoot) {\n                flushPassiveEffects();\n            }\n            var current = container.current;\n            updateContainerImpl(current, SyncLane, element, container, parentComponent, callback);\n            return SyncLane;\n        }\n        function updateContainerImpl(rootFiber, lane, element, container, parentComponent, callback) {\n            {\n                onScheduleRoot(container, element);\n            }\n            {\n                markRenderScheduled(lane);\n            }\n            var context = getContextForSubtree(parentComponent);\n            if (container.context === null) {\n                container.context = context;\n            } else {\n                container.pendingContext = context;\n            }\n            {\n                if (isRendering && current !== null && !didWarnAboutNestedUpdates) {\n                    didWarnAboutNestedUpdates = true;\n                    error('Render methods should be a pure function of props and state; ' + 'triggering nested component updates from render is not allowed. ' + 'If necessary, trigger nested updates in componentDidUpdate.\\n\\n' + 'Check the render method of %s.', getComponentNameFromFiber(current) || 'Unknown');\n                }\n            }\n            var update = createUpdate(lane); // Caution: React DevTools currently depends on this property\n            // being called \"element\".\n            update.payload = {\n                element: element\n            };\n            callback = callback === undefined ? null : callback;\n            if (callback !== null) {\n                {\n                    if (typeof callback !== 'function') {\n                        error('Expected the last optional `callback` argument to be a ' + 'function. Instead received: %s.', callback);\n                    }\n                }\n                update.callback = callback;\n            }\n            var root = enqueueUpdate(rootFiber, update, lane);\n            if (root !== null) {\n                scheduleUpdateOnFiber(root, rootFiber, lane);\n                entangleTransitions(root, rootFiber, lane);\n            }\n        }\n        function getPublicRootInstance(container) {\n            var containerFiber = container.current;\n            if (!containerFiber.child) {\n                return null;\n            }\n            switch(containerFiber.child.tag){\n                case HostSingleton:\n                case HostComponent:\n                    return getPublicInstance(containerFiber.child.stateNode);\n                default:\n                    return containerFiber.child.stateNode;\n            }\n        }\n        function attemptSynchronousHydration(fiber) {\n            switch(fiber.tag){\n                case HostRoot:\n                    {\n                        var root = fiber.stateNode;\n                        if (isRootDehydrated(root)) {\n                            // Flush the first scheduled \"update\".\n                            var lanes = getHighestPriorityPendingLanes(root);\n                            flushRoot(root, lanes);\n                        }\n                        break;\n                    }\n                case SuspenseComponent:\n                    {\n                        var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                        if (_root !== null) {\n                            scheduleUpdateOnFiber(_root, fiber, SyncLane);\n                        }\n                        flushSyncWork(); // If we're still blocked after this, we need to increase\n                        // the priority of any promises resolving within this\n                        // boundary so that they next attempt also has higher pri.\n                        var retryLane = SyncLane;\n                        markRetryLaneIfNotHydrated(fiber, retryLane);\n                        break;\n                    }\n            }\n        }\n        function markRetryLaneImpl(fiber, retryLane) {\n            var suspenseState = fiber.memoizedState;\n            if (suspenseState !== null && suspenseState.dehydrated !== null) {\n                suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);\n            }\n        } // Increases the priority of thenables when they resolve within this boundary.\n        function markRetryLaneIfNotHydrated(fiber, retryLane) {\n            markRetryLaneImpl(fiber, retryLane);\n            var alternate = fiber.alternate;\n            if (alternate) {\n                markRetryLaneImpl(alternate, retryLane);\n            }\n        }\n        function attemptContinuousHydration(fiber) {\n            if (fiber.tag !== SuspenseComponent) {\n                // We ignore HostRoots here because we can't increase\n                // their priority and they should not suspend on I/O,\n                // since you have to wrap anything that might suspend in\n                // Suspense.\n                return;\n            }\n            var lane = SelectiveHydrationLane;\n            var root = enqueueConcurrentRenderForLane(fiber, lane);\n            if (root !== null) {\n                scheduleUpdateOnFiber(root, fiber, lane);\n            }\n            markRetryLaneIfNotHydrated(fiber, lane);\n        }\n        function attemptHydrationAtCurrentPriority(fiber) {\n            if (fiber.tag !== SuspenseComponent) {\n                // We ignore HostRoots here because we can't increase\n                // their priority other than synchronously flush it.\n                return;\n            }\n            var lane = requestUpdateLane(fiber);\n            var root = enqueueConcurrentRenderForLane(fiber, lane);\n            if (root !== null) {\n                scheduleUpdateOnFiber(root, fiber, lane);\n            }\n            markRetryLaneIfNotHydrated(fiber, lane);\n        }\n        function findHostInstanceWithNoPortals(fiber) {\n            var hostFiber = findCurrentHostFiberWithNoPortals(fiber);\n            if (hostFiber === null) {\n                return null;\n            }\n            return getPublicInstance(hostFiber.stateNode);\n        }\n        var shouldErrorImpl = function(fiber) {\n            return null;\n        };\n        function shouldError(fiber) {\n            return shouldErrorImpl(fiber);\n        }\n        var shouldSuspendImpl = function(fiber) {\n            return false;\n        };\n        function shouldSuspend(fiber) {\n            return shouldSuspendImpl(fiber);\n        }\n        var overrideHookState = null;\n        var overrideHookStateDeletePath = null;\n        var overrideHookStateRenamePath = null;\n        var overrideProps = null;\n        var overridePropsDeletePath = null;\n        var overridePropsRenamePath = null;\n        var scheduleUpdate = null;\n        var setErrorHandler = null;\n        var setSuspenseHandler = null;\n        {\n            var copyWithDeleteImpl = function(obj, path, index) {\n                var key = path[index];\n                var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n                if (index + 1 === path.length) {\n                    if (isArray(updated)) {\n                        updated.splice(key, 1);\n                    } else {\n                        delete updated[key];\n                    }\n                    return updated;\n                } // $FlowFixMe[incompatible-use] number or string is fine here\n                updated[key] = copyWithDeleteImpl(obj[key], path, index + 1);\n                return updated;\n            };\n            var copyWithDelete = function(obj, path) {\n                return copyWithDeleteImpl(obj, path, 0);\n            };\n            var copyWithRenameImpl = function(obj, oldPath, newPath, index) {\n                var oldKey = oldPath[index];\n                var updated = isArray(obj) ? obj.slice() : assign({}, obj);\n                if (index + 1 === oldPath.length) {\n                    var newKey = newPath[index]; // $FlowFixMe[incompatible-use] number or string is fine here\n                    updated[newKey] = updated[oldKey];\n                    if (isArray(updated)) {\n                        updated.splice(oldKey, 1);\n                    } else {\n                        delete updated[oldKey];\n                    }\n                } else {\n                    // $FlowFixMe[incompatible-use] number or string is fine here\n                    updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index + 1);\n                }\n                return updated;\n            };\n            var copyWithRename = function(obj, oldPath, newPath) {\n                if (oldPath.length !== newPath.length) {\n                    warn('copyWithRename() expects paths of the same length');\n                    return;\n                } else {\n                    for(var i = 0; i < newPath.length - 1; i++){\n                        if (oldPath[i] !== newPath[i]) {\n                            warn('copyWithRename() expects paths to be the same except for the deepest key');\n                            return;\n                        }\n                    }\n                }\n                return copyWithRenameImpl(obj, oldPath, newPath, 0);\n            };\n            var copyWithSetImpl = function(obj, path, index, value) {\n                if (index >= path.length) {\n                    return value;\n                }\n                var key = path[index];\n                var updated = isArray(obj) ? obj.slice() : assign({}, obj); // $FlowFixMe[incompatible-use] number or string is fine here\n                updated[key] = copyWithSetImpl(obj[key], path, index + 1, value);\n                return updated;\n            };\n            var copyWithSet = function(obj, path, value) {\n                return copyWithSetImpl(obj, path, 0, value);\n            };\n            var findHook = function(fiber, id) {\n                // For now, the \"id\" of stateful hooks is just the stateful hook index.\n                // This may change in the future with e.g. nested hooks.\n                var currentHook = fiber.memoizedState;\n                while(currentHook !== null && id > 0){\n                    currentHook = currentHook.next;\n                    id--;\n                }\n                return currentHook;\n            }; // Support DevTools editable values for useState and useReducer.\n            overrideHookState = function(fiber, id, path, value) {\n                var hook = findHook(fiber, id);\n                if (hook !== null) {\n                    var newState = copyWithSet(hook.memoizedState, path, value);\n                    hook.memoizedState = newState;\n                    hook.baseState = newState; // We aren't actually adding an update to the queue,\n                    // because there is no update we can add for useReducer hooks that won't trigger an error.\n                    // (There's no appropriate action type for DevTools overrides.)\n                    // As a result though, React will see the scheduled update as a noop and bailout.\n                    // Shallow cloning props works as a workaround for now to bypass the bailout check.\n                    fiber.memoizedProps = assign({}, fiber.memoizedProps);\n                    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                    if (root !== null) {\n                        scheduleUpdateOnFiber(root, fiber, SyncLane);\n                    }\n                }\n            };\n            overrideHookStateDeletePath = function(fiber, id, path) {\n                var hook = findHook(fiber, id);\n                if (hook !== null) {\n                    var newState = copyWithDelete(hook.memoizedState, path);\n                    hook.memoizedState = newState;\n                    hook.baseState = newState; // We aren't actually adding an update to the queue,\n                    // because there is no update we can add for useReducer hooks that won't trigger an error.\n                    // (There's no appropriate action type for DevTools overrides.)\n                    // As a result though, React will see the scheduled update as a noop and bailout.\n                    // Shallow cloning props works as a workaround for now to bypass the bailout check.\n                    fiber.memoizedProps = assign({}, fiber.memoizedProps);\n                    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                    if (root !== null) {\n                        scheduleUpdateOnFiber(root, fiber, SyncLane);\n                    }\n                }\n            };\n            overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {\n                var hook = findHook(fiber, id);\n                if (hook !== null) {\n                    var newState = copyWithRename(hook.memoizedState, oldPath, newPath);\n                    hook.memoizedState = newState;\n                    hook.baseState = newState; // We aren't actually adding an update to the queue,\n                    // because there is no update we can add for useReducer hooks that won't trigger an error.\n                    // (There's no appropriate action type for DevTools overrides.)\n                    // As a result though, React will see the scheduled update as a noop and bailout.\n                    // Shallow cloning props works as a workaround for now to bypass the bailout check.\n                    fiber.memoizedProps = assign({}, fiber.memoizedProps);\n                    var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                    if (root !== null) {\n                        scheduleUpdateOnFiber(root, fiber, SyncLane);\n                    }\n                }\n            }; // Support DevTools props for function components, forwardRef, memo, host components, etc.\n            overrideProps = function(fiber, path, value) {\n                fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);\n                if (fiber.alternate) {\n                    fiber.alternate.pendingProps = fiber.pendingProps;\n                }\n                var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, SyncLane);\n                }\n            };\n            overridePropsDeletePath = function(fiber, path) {\n                fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);\n                if (fiber.alternate) {\n                    fiber.alternate.pendingProps = fiber.pendingProps;\n                }\n                var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, SyncLane);\n                }\n            };\n            overridePropsRenamePath = function(fiber, oldPath, newPath) {\n                fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);\n                if (fiber.alternate) {\n                    fiber.alternate.pendingProps = fiber.pendingProps;\n                }\n                var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, SyncLane);\n                }\n            };\n            scheduleUpdate = function(fiber) {\n                var root = enqueueConcurrentRenderForLane(fiber, SyncLane);\n                if (root !== null) {\n                    scheduleUpdateOnFiber(root, fiber, SyncLane);\n                }\n            };\n            setErrorHandler = function(newShouldErrorImpl) {\n                shouldErrorImpl = newShouldErrorImpl;\n            };\n            setSuspenseHandler = function(newShouldSuspendImpl) {\n                shouldSuspendImpl = newShouldSuspendImpl;\n            };\n        }\n        function findHostInstanceByFiber(fiber) {\n            var hostFiber = findCurrentHostFiber(fiber);\n            if (hostFiber === null) {\n                return null;\n            }\n            return hostFiber.stateNode;\n        }\n        function emptyFindFiberByHostInstance(instance) {\n            return null;\n        }\n        function getCurrentFiberForDevTools() {\n            return current;\n        }\n        function injectIntoDevTools(devToolsConfig) {\n            var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;\n            return injectInternals({\n                bundleType: devToolsConfig.bundleType,\n                version: devToolsConfig.version,\n                rendererPackageName: devToolsConfig.rendererPackageName,\n                rendererConfig: devToolsConfig.rendererConfig,\n                overrideHookState: overrideHookState,\n                overrideHookStateDeletePath: overrideHookStateDeletePath,\n                overrideHookStateRenamePath: overrideHookStateRenamePath,\n                overrideProps: overrideProps,\n                overridePropsDeletePath: overridePropsDeletePath,\n                overridePropsRenamePath: overridePropsRenamePath,\n                setErrorHandler: setErrorHandler,\n                setSuspenseHandler: setSuspenseHandler,\n                scheduleUpdate: scheduleUpdate,\n                currentDispatcherRef: ReactSharedInternals,\n                findHostInstanceByFiber: findHostInstanceByFiber,\n                findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,\n                // React Refresh\n                findHostInstancesForRefresh: findHostInstancesForRefresh,\n                scheduleRefresh: scheduleRefresh,\n                scheduleRoot: scheduleRoot,\n                setRefreshHandler: setRefreshHandler,\n                // Enables DevTools to append owner stacks to error messages in DEV mode.\n                getCurrentFiber: getCurrentFiberForDevTools,\n                // Enables DevTools to detect reconciler version rather than renderer version\n                // which may not match for third party renderers.\n                reconcilerVersion: ReactVersion\n            });\n        }\n        exports.attemptContinuousHydration = attemptContinuousHydration;\n        exports.attemptHydrationAtCurrentPriority = attemptHydrationAtCurrentPriority;\n        exports.attemptSynchronousHydration = attemptSynchronousHydration;\n        exports.batchedUpdates = batchedUpdates;\n        exports.createComponentSelector = createComponentSelector;\n        exports.createContainer = createContainer;\n        exports.createHasPseudoClassSelector = createHasPseudoClassSelector;\n        exports.createHydrationContainer = createHydrationContainer;\n        exports.createPortal = createPortal;\n        exports.createRoleSelector = createRoleSelector;\n        exports.createTestNameSelector = createTestNameSelector;\n        exports.createTextSelector = createTextSelector;\n        exports.defaultOnCaughtError = defaultOnCaughtError;\n        exports.defaultOnRecoverableError = defaultOnRecoverableError;\n        exports.defaultOnUncaughtError = defaultOnUncaughtError;\n        exports.deferredUpdates = deferredUpdates;\n        exports.discreteUpdates = discreteUpdates;\n        exports.findAllNodes = findAllNodes;\n        exports.findBoundingRects = findBoundingRects;\n        exports.findHostInstance = findHostInstance;\n        exports.findHostInstanceWithNoPortals = findHostInstanceWithNoPortals;\n        exports.findHostInstanceWithWarning = findHostInstanceWithWarning;\n        exports.flushPassiveEffects = flushPassiveEffects;\n        exports.flushSyncFromReconciler = flushSyncFromReconciler;\n        exports.flushSyncWork = flushSyncWork;\n        exports.focusWithin = focusWithin;\n        exports.getFindAllNodesFailureDescription = getFindAllNodesFailureDescription;\n        exports.getPublicRootInstance = getPublicRootInstance;\n        exports.injectIntoDevTools = injectIntoDevTools;\n        exports.isAlreadyRendering = isAlreadyRendering;\n        exports.observeVisibleRects = observeVisibleRects;\n        exports.shouldError = shouldError;\n        exports.shouldSuspend = shouldSuspend;\n        exports.startHostTransition = startHostTransition;\n        exports.updateContainer = updateContainer;\n        exports.updateContainerSync = updateContainerSync;\n        return exports;\n    };\n    module.exports[\"default\"] = module.exports;\n    Object.defineProperty(module.exports, \"__esModule\", ({\n        value: true\n    }));\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtcmVjb25jaWxlckAwLjMxLjAtcmMtOTM1MTgwYzdlMC0yMDI0MDUyNF9yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL3JlYWN0LXJlY29uY2lsZXIvY2pzL3JlYWN0LXJlY29uY2lsZXIuZGV2ZWxvcG1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0NBUUMsR0FFWTtBQUViLElBQUlBLElBQXFDLEVBQUU7SUFDekNDLE9BQU9DLE9BQU8sR0FBRyxTQUFTQyxjQUFjQyxTQUFTO1FBQy9DLElBQUlGLFVBQVUsQ0FBQztRQUNuQjtRQUVBLElBQUlHLFFBQVFDLG1CQUFPQSxDQUFDLDhKQUFPO1FBQzNCLElBQUlDLFlBQVlELG1CQUFPQSxDQUFDLHFIQUFXO1FBRW5DLElBQUlFLHVCQUF1QkgsTUFBTUksK0RBQStEO1FBRWhHLElBQUlDLGtCQUFrQjtRQUN0QixTQUFTQyxtQkFBbUJDLGtCQUFrQjtZQUM1QztnQkFDRUYsa0JBQWtCRTtZQUNwQjtRQUNGLEVBQUUsK0RBQStEO1FBQ2pFLCtDQUErQztRQUMvQyxFQUFFO1FBQ0YsOERBQThEO1FBQzlELHFDQUFxQztRQUVyQyxTQUFTQyxLQUFLQyxNQUFNO1lBQ2xCO2dCQUNFLElBQUksQ0FBQ0osaUJBQWlCO29CQUNwQixJQUFLLElBQUlLLE9BQU9DLFVBQVVDLE1BQU0sRUFBRUMsT0FBTyxJQUFJQyxNQUFNSixPQUFPLElBQUlBLE9BQU8sSUFBSSxJQUFJSyxPQUFPLEdBQUdBLE9BQU9MLE1BQU1LLE9BQVE7d0JBQzFHRixJQUFJLENBQUNFLE9BQU8sRUFBRSxHQUFHSixTQUFTLENBQUNJLEtBQUs7b0JBQ2xDO29CQUVBQyxhQUFhLFFBQVFQLFFBQVFJO2dCQUMvQjtZQUNGO1FBQ0Y7UUFDQSxTQUFTSSxNQUFNUixNQUFNO1lBQ25CO2dCQUNFLElBQUksQ0FBQ0osaUJBQWlCO29CQUNwQixJQUFLLElBQUlhLFFBQVFQLFVBQVVDLE1BQU0sRUFBRUMs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b0Q7UUFBRU8sT0FBTztJQUFLLENBQUMsRUFBQztBQUN0RSIsInNvdXJjZXMiOlsiL1VzZXJzL21obWQvRG9jdW1lbnRzL0dpdEh1Yi9BV00tZGF0YXRob24vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LXJlY29uY2lsZXJAMC4zMS4wLXJjLTkzNTE4MGM3ZTAtMjAyNDA1MjRfcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9yZWFjdC1yZWNvbmNpbGVyL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLmRldmVsb3BtZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2UgUmVhY3RcbiAqIHJlYWN0LXJlY29uY2lsZXIuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICQkJHJlY29uY2lsZXIoJCQkY29uZmlnKSB7XG4gICAgdmFyIGV4cG9ydHMgPSB7fTtcbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcbnZhciBTY2hlZHVsZXIgPSByZXF1aXJlKCdzY2hlZHVsZXInKTtcblxudmFyIFJlYWN0U2hhcmVkSW50ZXJuYWxzID0gUmVhY3QuX19DTElFTlRfSU5URVJOQUxTX0RPX05PVF9VU0VfT1JfV0FSTl9VU0VSU19USEVZX0NBTk5PVF9VUEdSQURFO1xuXG52YXIgc3VwcHJlc3NXYXJuaW5nID0gZmFsc2U7XG5mdW5jdGlvbiBzZXRTdXBwcmVzc1dhcm5pbmcobmV3U3VwcHJlc3NXYXJuaW5nKSB7XG4gIHtcbiAgICBzdXBwcmVzc1dhcm5pbmcgPSBuZXdTdXBwcmVzc1dhcm5pbmc7XG4gIH1cbn0gLy8gSW4gREVWLCBjYWxscyB0byBjb25zb2xlLndhcm4gYW5kIGNvbnNvbGUuZXJyb3IgZ2V0IHJlcGxhY2VkXG4vLyBieSBjYWxscyB0byB0aGVzZSBtZXRob2RzIGJ5IGEgQmFiZWwgcGx1Z2luLlxuLy9cbi8vIEluIFBST0QgKG9yIGluIHBhY2thZ2VzIHdpdGhvdXQgYWNjZXNzIHRvIFJlYWN0IGludGVybmFscyksXG4vLyB0aGV5IGFyZSBsZWZ0IGFzIHRoZXkgYXJlIGluc3RlYWQuXG5cbmZ1bmN0aW9uIHdhcm4oZm9ybWF0KSB7XG4gIHtcbiAgICBpZiAoIXN1cHByZXNzV2FybmluZykge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgcHJpbnRXYXJuaW5nKCd3YXJuJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGVycm9yKGZvcm1hdCkge1xuICB7XG4gICAgaWYgKCFzdXBwcmVzc1dhcm5pbmcpIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgaXNFcnJvckxvZ2dlciA9IGZvcm1hdCA9PT0gJyVzXFxuXFxuJXNcXG4nIHx8IGZvcm1hdCA9PT0gJyVvXFxuXFxuJXNcXG5cXG4lc1xcbic7XG5cbiAgICBpZiAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrKSB7XG4gICAgICB2YXIgc3RhY2sgPSBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2soKTtcblxuICAgICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChpc0Vycm9yTG9nZ2VyKSB7XG4gICAgICAvLyBEb24ndCBwcmVmaXggb3VyIGRlZmF1bHQgbG9nZ2luZyBmb3JtYXR0aW5nIGluIFJlYWN0RmliZXJFcnJvckxvZ2dnZXIuXG4gICAgICAvLyBEb24ndCB0b1N0cmluZyB0aGUgYXJndW1lbnRzLlxuICAgICAgYXJncy51bnNoaWZ0KGZvcm1hdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIHByZWZpeCBhbmQgc3RvcCB0b1N0cmluZ2luZyBpbiB0aGUgd3JhcHBlciBhbmRcbiAgICAgIC8vIGluc3RlYWQgZG8gaXQgYXQgZWFjaCBjYWxsc2l0ZSBhcyBuZWVkZWQuXG4gICAgICAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgICBhcmdzID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICAgIH0pO1xuICAgICAgYXJncy51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTtcbiAgICB9IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3MpO1xuICB9XG59XG5cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG52YXIgTGVnYWN5Um9vdCA9IDA7XG52YXIgQ29uY3VycmVudFJvb3QgPSAxO1xuXG4vKipcbiAqIGBSZWFjdEluc3RhbmNlTWFwYCBtYWludGFpbnMgYSBtYXBwaW5nIGZyb20gYSBwdWJsaWMgZmFjaW5nIHN0YXRlZnVsXG4gKiBpbnN0YW5jZSAoa2V5KSBhbmQgdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uICh2YWx1ZSkuIFRoaXMgYWxsb3dzIHB1YmxpY1xuICogbWV0aG9kcyB0byBhY2NlcHQgdGhlIHVzZXIgZmFjaW5nIGluc3RhbmNlIGFzIGFuIGFyZ3VtZW50IGFuZCBtYXAgdGhlbSBiYWNrXG4gKiB0byBpbnRlcm5hbCBtZXRob2RzLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIG1vZHVsZSBpcyBjdXJyZW50bHkgc2hhcmVkIGFuZCBhc3N1bWVkIHRvIGJlIHN0YXRlbGVzcy5cbiAqIElmIHRoaXMgYmVjb21lcyBhbiBhY3R1YWwgTWFwLCB0aGF0IHdpbGwgYnJlYWsuXG4gKi9cbmZ1bmN0aW9uIGdldChrZXkpIHtcbiAgcmV0dXJuIGtleS5fcmVhY3RJbnRlcm5hbHM7XG59XG5mdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSkge1xuICBrZXkuX3JlYWN0SW50ZXJuYWxzID0gdmFsdWU7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBLaWxsc3dpdGNoXG4vL1xuLy8gRmxhZ3MgdGhhdCBleGlzdCBzb2xlbHkgdG8gdHVybiBvZmYgYSBjaGFuZ2UgaW4gY2FzZSBpdCBjYXVzZXMgYSByZWdyZXNzaW9uXG4vLyB3aGVuIGl0IHJvbGxzIG91dCB0byBwcm9kLiBXZSBzaG91bGQgcmVtb3ZlIHRoZXNlIGFzIHNvb24gYXMgcG9zc2libGUuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIExhbmQgb3IgcmVtb3ZlIChtb2RlcmF0ZSBlZmZvcnQpXG4vL1xuLy8gRmxhZ3MgdGhhdCBjYW4gYmUgcHJvYmFibHkgZGVsZXRlZCBvciBsYW5kZWQsIGJ1dCBtaWdodCByZXF1aXJlIGV4dHJhIGVmZm9ydFxuLy8gbGlrZSBtaWdyYXRpbmcgaW50ZXJuYWwgY2FsbGVycyBvciBwZXJmb3JtYW5jZSB0ZXN0aW5nLlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFRPRE86IEZpbmlzaCByb2xsaW5nIG91dCBpbiB3d3dcblxudmFyIGZhdm9yU2FmZXR5T3Zlckh5ZHJhdGlvblBlcmYgPSB0cnVlO1xudmFyIGVuYWJsZUFzeW5jQWN0aW9ucyA9IHRydWU7IC8vIE5lZWQgdG8gcmVtb3ZlIGRpZFRpbWVvdXQgYXJndW1lbnQgZnJvbSBTY2hlZHVsZXIgYmVmb3JlIGxhbmRpbmdcblxudmFyIGRpc2FibGVEZWZhdWx0UHJvcHNFeGNlcHRGb3JDbGFzc2VzID0gdHJ1ZTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFNsYXRlZCBmb3IgcmVtb3ZhbCBpbiB0aGUgZnV0dXJlIChzaWduaWZpY2FudCBlZmZvcnQpXG4vL1xuLy8gVGhlc2UgYXJlIGV4cGVyaW1lbnRzIHRoYXQgZGlkbid0IHdvcmsgb3V0LCBhbmQgbmV2ZXIgc2hpcHBlZCwgYnV0IHdlIGNhbid0XG4vLyBkZWxldGUgZnJvbSB0aGUgY29kZWJhc2UgdW50aWwgd2UgbWlncmF0ZSBpbnRlcm5hbCBjYWxsZXJzLlxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEFkZCBhIGNhbGxiYWNrIHByb3BlcnR5IHRvIHN1c3BlbnNlIHRvIG5vdGlmeSB3aGljaCBwcm9taXNlcyBhcmUgY3VycmVudGx5XG4vLyBpbiB0aGUgdXBkYXRlIHF1ZXVlLiBUaGlzIGFsbG93cyByZXBvcnRpbmcgYW5kIHRyYWNpbmcgb2Ygd2hhdCBpcyBjYXVzaW5nXG4vLyB0aGUgdXNlciB0byBzZWUgYSBsb2FkaW5nIHN0YXRlLlxuLy9cbi8vIEFsc28gYWxsb3dzIGh5ZHJhdGlvbiBjYWxsYmFja3MgdG8gZmlyZSB3aGVuIGEgZGVoeWRyYXRlZCBib3VuZGFyeSBnZXRzXG4vLyBoeWRyYXRlZCBvciBkZWxldGVkLlxuLy9cbi8vIFRoaXMgd2lsbCBldmVudHVhbGx5IGJlIHJlcGxhY2VkIGJ5IHRoZSBUcmFuc2l0aW9uIFRyYWNpbmcgcHJvcG9zYWwuXG5cbnZhciBlbmFibGVTdXNwZW5zZUNhbGxiYWNrID0gZmFsc2U7IC8vIEV4cGVyaW1lbnRhbCBTY29wZSBzdXBwb3J0LlxudmFyIGVuYWJsZUFzeW5jSXRlcmFibGVDaGlsZHJlbiA9IGZhbHNlO1xuXG52YXIgZW5hYmxlTGF6eUNvbnRleHRQcm9wYWdhdGlvbiA9IGZhbHNlOyAvLyBGQi1vbmx5IHVzYWdlLiBUaGUgbmV3IEFQSSBoYXMgZGlmZmVyZW50IHNlbWFudGljcy5cblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbnZhciBhbHdheXNUaHJvdHRsZVJldHJpZXMgPSB0cnVlO1xudmFyIHBhc3NDaGlsZHJlbldoZW5DbG9uaW5nUGVyc2lzdGVkTm9kZXMgPSBmYWxzZTtcbnZhciBzeW5jTGFuZUV4cGlyYXRpb25NcyA9IDI1MDtcbnZhciB0cmFuc2l0aW9uTGFuZUV4cGlyYXRpb25NcyA9IDUwMDA7IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBUaGlzIGFsbG93cyB1cyB0byBsYW5kIGJyZWFraW5nIGNoYW5nZXMgdG8gcmVtb3ZlIGxlZ2FjeSBtb2RlIEFQSXMgaW4gZXhwZXJpbWVudGFsIGJ1aWxkc1xuLy8gYmVmb3JlIHJlbW92aW5nIHRoZW0gaW4gc3RhYmxlIGluIHRoZSBuZXh0IE1ham9yXG5cbnZhciBkaXNhYmxlTGVnYWN5TW9kZSA9IHRydWU7XG4vLyBEZWJ1Z2dpbmcgYW5kIERldlRvb2xzXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQWRkcyB1c2VyIHRpbWluZyBtYXJrcyBmb3IgZS5nLiBzdGF0ZSB1cGRhdGVzLCBzdXNwZW5zZSwgYW5kIHdvcmsgbG9vcCBzdHVmZixcbi8vIGZvciBhbiBleHBlcmltZW50YWwgdGltZWxpbmUgdG9vbC5cblxudmFyIGVuYWJsZVNjaGVkdWxpbmdQcm9maWxlciA9IHRydWU7IC8vIEhlbHBzIGlkZW50aWZ5IHNpZGUgZWZmZWN0cyBpbiByZW5kZXItcGhhc2UgbGlmZWN5Y2xlIGhvb2tzIGFuZCBzZXRTdGF0ZVxuXG52YXIgZW5hYmxlUHJvZmlsZXJUaW1lciA9IHRydWU7IC8vIFJlY29yZCBkdXJhdGlvbnMgZm9yIGNvbW1pdCBhbmQgcGFzc2l2ZSBlZmZlY3RzIHBoYXNlcy5cblxudmFyIGVuYWJsZVByb2ZpbGVyQ29tbWl0SG9va3MgPSB0cnVlOyAvLyBQaGFzZSBwYXJhbSBwYXNzZWQgdG8gb25SZW5kZXIgY2FsbGJhY2sgZGlmZmVyZW50aWF0ZXMgYmV0d2VlbiBhbiBcInVwZGF0ZVwiIGFuZCBhIFwiY2FzY2FkaW5nLXVwZGF0ZVwiLlxuXG52YXIgZW5hYmxlUHJvZmlsZXJOZXN0ZWRVcGRhdGVQaGFzZSA9IHRydWU7IC8vIEFkZHMgdmVyYm9zZSBjb25zb2xlIGxvZ2dpbmcgZm9yIGUuZy4gc3RhdGUgdXBkYXRlcywgc3VzcGVuc2UsIGFuZCB3b3JrIGxvb3BcblxudmFyIEZ1bmN0aW9uQ29tcG9uZW50ID0gMDtcbnZhciBDbGFzc0NvbXBvbmVudCA9IDE7XG52YXIgSG9zdFJvb3QgPSAzOyAvLyBSb290IG9mIGEgaG9zdCB0cmVlLiBDb3VsZCBiZSBuZXN0ZWQgaW5zaWRlIGFub3RoZXIgbm9kZS5cblxudmFyIEhvc3RQb3J0YWwgPSA0OyAvLyBBIHN1YnRyZWUuIENvdWxkIGJlIGFuIGVudHJ5IHBvaW50IHRvIGEgZGlmZmVyZW50IHJlbmRlcmVyLlxuXG52YXIgSG9zdENvbXBvbmVudCA9IDU7XG52YXIgSG9zdFRleHQgPSA2O1xudmFyIEZyYWdtZW50ID0gNztcbnZhciBNb2RlID0gODtcbnZhciBDb250ZXh0Q29uc3VtZXIgPSA5O1xudmFyIENvbnRleHRQcm92aWRlciA9IDEwO1xudmFyIEZvcndhcmRSZWYgPSAxMTtcbnZhciBQcm9maWxlciA9IDEyO1xudmFyIFN1c3BlbnNlQ29tcG9uZW50ID0gMTM7XG52YXIgTWVtb0NvbXBvbmVudCA9IDE0O1xudmFyIFNpbXBsZU1lbW9Db21wb25lbnQgPSAxNTtcbnZhciBMYXp5Q29tcG9uZW50ID0gMTY7XG52YXIgSW5jb21wbGV0ZUNsYXNzQ29tcG9uZW50ID0gMTc7XG52YXIgRGVoeWRyYXRlZEZyYWdtZW50ID0gMTg7XG52YXIgU3VzcGVuc2VMaXN0Q29tcG9uZW50ID0gMTk7XG52YXIgU2NvcGVDb21wb25lbnQgPSAyMTtcbnZhciBPZmZzY3JlZW5Db21wb25lbnQgPSAyMjtcbnZhciBMZWdhY3lIaWRkZW5Db21wb25lbnQgPSAyMztcbnZhciBDYWNoZUNvbXBvbmVudCA9IDI0O1xudmFyIFRyYWNpbmdNYXJrZXJDb21wb25lbnQgPSAyNTtcbnZhciBIb3N0SG9pc3RhYmxlID0gMjY7XG52YXIgSG9zdFNpbmdsZXRvbiA9IDI3O1xudmFyIEluY29tcGxldGVGdW5jdGlvbkNvbXBvbmVudCA9IDI4O1xuXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy5cblxudmFyIFJFQUNUX0xFR0FDWV9FTEVNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50Jyk7XG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QudHJhbnNpdGlvbmFsLmVsZW1lbnQnKSA7XG52YXIgUkVBQ1RfUE9SVEFMX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wb3J0YWwnKTtcbnZhciBSRUFDVF9GUkFHTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZnJhZ21lbnQnKTtcbnZhciBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3RyaWN0X21vZGUnKTtcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvZmlsZXInKTtcbnZhciBSRUFDVF9QUk9WSURFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucHJvdmlkZXInKTsgLy8gVE9ETzogRGVsZXRlIHdpdGggZW5hYmxlUmVuZGVyYWJsZUNvbnRleHRcblxudmFyIFJFQUNUX0NPTlNVTUVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jb25zdW1lcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9TQ09QRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc2NvcGUnKTtcbnZhciBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmRlYnVnX3RyYWNlX21vZGUnKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nKTtcbnZhciBSRUFDVF9UUkFDSU5HX01BUktFUl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QudHJhY2luZ19tYXJrZXInKTtcbnZhciBSRUFDVF9NRU1PX0NBQ0hFX1NFTlRJTkVMID0gU3ltYm9sLmZvcigncmVhY3QubWVtb19jYWNoZV9zZW50aW5lbCcpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZSQxKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUkMSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxudmFyIFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UpIHtcbiAgICAgIC8vIFRPRE86IENyZWF0ZSBhIGNvbnZlbnRpb24gZm9yIG5hbWluZyBjbGllbnQgcmVmZXJlbmNlcyB3aXRoIGRlYnVnIGluZm8uXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgbnVsbDtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdHlwZTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBSRUFDVF9QT1JUQUxfVFlQRTpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgUkVBQ1RfUFJPRklMRVJfVFlQRTpcbiAgICAgIHJldHVybiAnUHJvZmlsZXInO1xuXG4gICAgY2FzZSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFOlxuICAgICAgcmV0dXJuICdTdHJpY3RNb2RlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9QUk9WSURFUl9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcblxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lJDEoY29udGV4dCkgKyAnLlByb3ZpZGVyJztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX0NPTlNVTUVSX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY29uc3VtZXIgPSB0eXBlO1xuICAgICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZSQxKGNvbnN1bWVyLl9jb250ZXh0KSArICcuQ29uc3VtZXInO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lJDEodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIG91dGVyVHlwZS5kaXNwbGF5TmFtZSB8fCAoZnVuY3Rpb25OYW1lICE9PSAnJyA/IHdyYXBwZXJOYW1lICsgXCIoXCIgKyBmdW5jdGlvbk5hbWUgKyBcIilcIiA6IHdyYXBwZXJOYW1lKTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggc2hhcmVkL2dldENvbXBvbmVudE5hbWVGcm9tVHlwZVxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufVxuXG5mdW5jdGlvbiBnZXRDb21wb25lbnROYW1lRnJvbU93bmVyKG93bmVyKSB7XG4gIGlmICh0eXBlb2Ygb3duZXIudGFnID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKG93bmVyKTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb3duZXIubmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gb3duZXIubmFtZTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikge1xuICB2YXIgdGFnID0gZmliZXIudGFnLFxuICAgICAgdHlwZSA9IGZpYmVyLnR5cGU7XG5cbiAgc3dpdGNoICh0YWcpIHtcbiAgICBjYXNlIENhY2hlQ29tcG9uZW50OlxuICAgICAgcmV0dXJuICdDYWNoZSc7XG5cbiAgICBjYXNlIENvbnRleHRDb25zdW1lcjpcbiAgICAgIHtcbiAgICAgICAgdmFyIGNvbnN1bWVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnN1bWVyLl9jb250ZXh0KSArICcuQ29uc3VtZXInO1xuICAgICAgfVxuXG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXI6XG4gICAgICB7XG4gICAgICAgIHZhciBfY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShfY29udGV4dCkgKyAnLlByb3ZpZGVyJztcbiAgICAgIH1cblxuICAgIGNhc2UgRGVoeWRyYXRlZEZyYWdtZW50OlxuICAgICAgcmV0dXJuICdEZWh5ZHJhdGVkRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgcmV0dXJuIGdldFdyYXBwZWROYW1lKHR5cGUsIHR5cGUucmVuZGVyLCAnRm9yd2FyZFJlZicpO1xuXG4gICAgY2FzZSBGcmFnbWVudDpcbiAgICAgIHJldHVybiAnRnJhZ21lbnQnO1xuXG4gICAgY2FzZSBIb3N0SG9pc3RhYmxlOlxuICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAvLyBIb3N0IGNvbXBvbmVudCB0eXBlIGlzIHRoZSBkaXNwbGF5IG5hbWUgKGUuZy4gXCJkaXZcIiwgXCJWaWV3XCIpXG4gICAgICByZXR1cm4gdHlwZTtcblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHJldHVybiAnUG9ydGFsJztcblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICByZXR1cm4gJ1Jvb3QnO1xuXG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHJldHVybiAnVGV4dCc7XG5cbiAgICBjYXNlIExhenlDb21wb25lbnQ6XG4gICAgICAvLyBOYW1lIGNvbWVzIGZyb20gdGhlIHR5cGUgaW4gdGhpcyBjYXNlOyB3ZSBkb24ndCBoYXZlIGEgdGFnLlxuICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKTtcblxuICAgIGNhc2UgTW9kZTpcbiAgICAgIGlmICh0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFKSB7XG4gICAgICAgIC8vIERvbid0IGJlIGxlc3Mgc3BlY2lmaWMgdGhhbiBzaGFyZWQvZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlXG4gICAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnTW9kZSc7XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgIHJldHVybiAnT2Zmc2NyZWVuJztcblxuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgU2NvcGVDb21wb25lbnQ6XG4gICAgICByZXR1cm4gJ1Njb3BlJztcblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuXG4gICAgY2FzZSBUcmFjaW5nTWFya2VyQ29tcG9uZW50OlxuICAgICAgcmV0dXJuICdUcmFjaW5nTWFya2VyJztcbiAgICAvLyBUaGUgZGlzcGxheSBuYW1lIGZvciB0aGVzZSB0YWdzIGNvbWUgZnJvbSB0aGUgdXNlci1wcm92aWRlZCB0eXBlOlxuXG4gICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgY2FzZSBJbmNvbXBsZXRlRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgLy8gRmFsbHRocm91Z2hcblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBOb0ZsYWdzJDEgPVxuLyogICAgICAgICAgICAgICAgICAgICAgKi9cbjA7XG52YXIgUGVyZm9ybWVkV29yayA9XG4vKiAgICAgICAgICAgICAgICAqL1xuMTtcbnZhciBQbGFjZW1lbnQgPVxuLyogICAgICAgICAgICAgICAgICAgICovXG4yO1xudmFyIERpZENhcHR1cmUgPVxuLyogICAgICAgICAgICAgICAgICAgKi9cbjEyODtcbnZhciBIeWRyYXRpbmcgPVxuLyogICAgICAgICAgICAgICAgICAgICovXG40MDk2OyAvLyBZb3UgY2FuIGNoYW5nZSB0aGUgcmVzdCAoYW5kIGFkZCBtb3JlKS5cblxudmFyIFVwZGF0ZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjQ7XG4vKiBTa2lwcGVkIHZhbHVlOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDBiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDsgKi9cblxudmFyIENoaWxkRGVsZXRpb24gPVxuLyogICAgICAgICAgICAgICAgKi9cbjE2O1xudmFyIENvbnRlbnRSZXNldCA9XG4vKiAgICAgICAgICAgICAgICAgKi9cbjMyO1xudmFyIENhbGxiYWNrID1cbi8qICAgICAgICAgICAgICAgICAgICAgKi9cbjY0O1xuLyogVXNlZCBieSBEaWRDYXB0dXJlOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAwYjAwMDAwMDAwMDAwMDAwMDAwMDAwMTAwMDAwMDA7ICovXG5cbnZhciBGb3JjZUNsaWVudFJlbmRlciA9XG4vKiAgICAgICAgICAgICovXG4yNTY7XG52YXIgUmVmID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuNTEyO1xudmFyIFNuYXBzaG90ID1cbi8qICAgICAgICAgICAgICAgICAgICAgKi9cbjEwMjQ7XG52YXIgUGFzc2l2ZSQxID1cbi8qICAgICAgICAgICAgICAgICAgICAgICovXG4yMDQ4O1xuLyogVXNlZCBieSBIeWRyYXRpbmc6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwYjAwMDAwMDAwMDAwMDAwMDEwMDAwMDAwMDAwMDA7ICovXG5cbnZhciBWaXNpYmlsaXR5ID1cbi8qICAgICAgICAgICAgICAgICAgICovXG44MTkyO1xudmFyIFN0b3JlQ29uc2lzdGVuY3kgPVxuLyogICAgICAgICAgICAgKi9cbjE2Mzg0OyAvLyBJdCdzIE9LIHRvIHJldXNlIHRoZXNlIGJpdHMgYmVjYXVzZSB0aGVzZSBmbGFncyBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlIGZvclxuLy8gZGlmZmVyZW50IGZpYmVyIHR5cGVzLiBXZSBzaG91bGQgcmVhbGx5IGJlIGRvaW5nIHRoaXMgZm9yIGFzIG1hbnkgZmxhZ3MgYXNcbi8vIHBvc3NpYmxlLCBiZWNhdXNlIHdlJ3JlIGFib3V0IHRvIHJ1biBvdXQgb2YgYml0cy5cblxudmFyIFNjaGVkdWxlUmV0cnkgPSBTdG9yZUNvbnNpc3RlbmN5O1xudmFyIFNob3VsZFN1c3BlbmRDb21taXQgPSBWaXNpYmlsaXR5O1xudmFyIERpZERlZmVyID0gQ29udGVudFJlc2V0O1xudmFyIEZvcm1SZXNldCA9IFNuYXBzaG90O1xuXG52YXIgSG9zdEVmZmVjdE1hc2sgPVxuLyogICAgICAgICAgICAgICAqL1xuMzI3Njc7IC8vIFRoZXNlIGFyZSBub3QgcmVhbGx5IHNpZGUgZWZmZWN0cywgYnV0IHdlIHN0aWxsIHJldXNlIHRoaXMgZmllbGQuXG5cbnZhciBJbmNvbXBsZXRlID1cbi8qICAgICAgICAgICAgICAgICAgICovXG4zMjc2ODtcbnZhciBTaG91bGRDYXB0dXJlID1cbi8qICAgICAgICAgICAgICAgICovXG42NTUzNjtcbnZhciBGb3JjZVVwZGF0ZUZvckxlZ2FjeVN1c3BlbnNlID1cbi8qICovXG4xMzEwNzI7XG52YXIgRm9ya2VkID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTA0ODU3NjsgLy8gU3RhdGljIHRhZ3MgZGVzY3JpYmUgYXNwZWN0cyBvZiBhIGZpYmVyIHRoYXQgYXJlIG5vdCBzcGVjaWZpYyB0byBhIHJlbmRlcixcbi8vIGUuZy4gYSBmaWJlciB1c2VzIGEgcGFzc2l2ZSBlZmZlY3QgKGV2ZW4gaWYgdGhlcmUgYXJlIG5vIHVwZGF0ZXMgb24gdGhpcyBwYXJ0aWN1bGFyIHJlbmRlcikuXG4vLyBUaGlzIGVuYWJsZXMgdXMgdG8gZGVmZXIgbW9yZSB3b3JrIGluIHRoZSB1bm1vdW50IGNhc2UsXG4vLyBzaW5jZSB3ZSBjYW4gZGVmZXIgdHJhdmVyc2luZyB0aGUgdHJlZSBkdXJpbmcgbGF5b3V0IHRvIGxvb2sgZm9yIFBhc3NpdmUgZWZmZWN0cyxcbi8vIGFuZCBpbnN0ZWFkIHJlbHkgb24gdGhlIHN0YXRpYyBmbGFnIGFzIGEgc2lnbmFsIHRoYXQgdGhlcmUgbWF5IGJlIGNsZWFudXAgd29yay5cblxudmFyIFJlZlN0YXRpYyA9XG4vKiAgICAgICAgICAgICAgICAgICAgKi9cbjIwOTcxNTI7XG52YXIgTGF5b3V0U3RhdGljID1cbi8qICAgICAgICAgICAgICAgICAqL1xuNDE5NDMwNDtcbnZhciBQYXNzaXZlU3RhdGljID1cbi8qICAgICAgICAgICAgICAgICovXG44Mzg4NjA4O1xudmFyIE1heVN1c3BlbmRDb21taXQgPVxuLyogICAgICAgICAgICAgKi9cbjE2Nzc3MjE2OyAvLyBGbGFnIHVzZWQgdG8gaWRlbnRpZnkgbmV3bHkgaW5zZXJ0ZWQgZmliZXJzLiBJdCBpc24ndCByZXNldCBhZnRlciBjb21taXQgdW5saWtlIGBQbGFjZW1lbnRgLlxuXG52YXIgUGxhY2VtZW50REVWID1cbi8qICAgICAgICAgICAgICAgICAqL1xuMzM1NTQ0MzI7XG52YXIgTW91bnRMYXlvdXREZXYgPVxuLyogICAgICAgICAgICAgICAqL1xuNjcxMDg4NjQ7XG52YXIgTW91bnRQYXNzaXZlRGV2ID1cbi8qICAgICAgICAgICAgICAqL1xuMTM0MjE3NzI4OyAvLyBHcm91cHMgb2YgZmxhZ3MgdGhhdCBhcmUgdXNlZCBpbiB0aGUgY29tbWl0IHBoYXNlIHRvIHNraXAgb3ZlciB0cmVlcyB0aGF0XG4vLyBkb24ndCBjb250YWluIGVmZmVjdHMsIGJ5IGNoZWNraW5nIHN1YnRyZWVGbGFncy5cblxudmFyIEJlZm9yZU11dGF0aW9uTWFzayA9IC8vIFRPRE86IFJlbW92ZSBVcGRhdGUgZmxhZyBmcm9tIGJlZm9yZSBtdXRhdGlvbiBwaGFzZSBieSByZS1sYW5kaW5nIFZpc2liaWxpdHlcbi8vIGZsYWcgbG9naWMgKHNlZSAjMjAwNDMpXG5VcGRhdGUgfCBTbmFwc2hvdCB8ICgwKTtcbnZhciBNdXRhdGlvbk1hc2sgPSBQbGFjZW1lbnQgfCBVcGRhdGUgfCBDaGlsZERlbGV0aW9uIHwgQ29udGVudFJlc2V0IHwgUmVmIHwgSHlkcmF0aW5nIHwgVmlzaWJpbGl0eSB8IEZvcm1SZXNldDtcbnZhciBMYXlvdXRNYXNrID0gVXBkYXRlIHwgQ2FsbGJhY2sgfCBSZWYgfCBWaXNpYmlsaXR5OyAvLyBUT0RPOiBTcGxpdCBpbnRvIFBhc3NpdmVNb3VudE1hc2sgYW5kIFBhc3NpdmVVbm1vdW50TWFza1xuXG52YXIgUGFzc2l2ZU1hc2sgPSBQYXNzaXZlJDEgfCBWaXNpYmlsaXR5IHwgQ2hpbGREZWxldGlvbjsgLy8gVW5pb24gb2YgdGFncyB0aGF0IGRvbid0IGdldCByZXNldCBvbiBjbG9uZXMuXG4vLyBUaGlzIGFsbG93cyBjZXJ0YWluIGNvbmNlcHRzIHRvIHBlcnNpc3Qgd2l0aG91dCByZWNhbGN1bGF0aW5nIHRoZW0sXG4vLyBlLmcuIHdoZXRoZXIgYSBzdWJ0cmVlIGNvbnRhaW5zIHBhc3NpdmUgZWZmZWN0cyBvciBwb3J0YWxzLlxuXG52YXIgU3RhdGljTWFzayA9IExheW91dFN0YXRpYyB8IFBhc3NpdmVTdGF0aWMgfCBSZWZTdGF0aWMgfCBNYXlTdXNwZW5kQ29tbWl0O1xuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBpbmZvOiBwcm9wcyxcbiAgICAgICAgbG9nOiBwcm9wcyxcbiAgICAgICAgd2FybjogcHJvcHMsXG4gICAgICAgIGVycm9yOiBwcm9wcyxcbiAgICAgICAgZ3JvdXA6IHByb3BzLFxuICAgICAgICBncm91cENvbGxhcHNlZDogcHJvcHMsXG4gICAgICAgIGdyb3VwRW5kOiBwcm9wc1xuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGRpc2FibGVkRGVwdGgrKztcbiAgfVxufVxuZnVuY3Rpb24gcmVlbmFibGVMb2dzKCkge1xuICB7XG4gICAgZGlzYWJsZWREZXB0aC0tO1xuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZMb2dcbiAgICAgICAgfSksXG4gICAgICAgIGluZm86IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkluZm9cbiAgICAgICAgfSksXG4gICAgICAgIHdhcm46IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZFcnJvclxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXA6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cENvbGxhcHNlZDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cEVuZFxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgIH1cblxuICAgIGlmIChkaXNhYmxlZERlcHRoIDwgMCkge1xuICAgICAgZXJyb3IoJ2Rpc2FibGVkRGVwdGggZmVsbCBiZWxvdyB6ZXJvLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgcHJlZml4O1xuZnVuY3Rpb24gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG5mdW5jdGlvbiBkZXNjcmliZURlYnVnSW5mb0ZyYW1lKG5hbWUsIGVudikge1xuICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSArIChlbnYgPyAnICgnICsgZW52ICsgJyknIDogJycpKTtcbn1cbnZhciByZWVudHJ5ID0gZmFsc2U7XG52YXIgY29tcG9uZW50RnJhbWVDYWNoZTtcblxue1xuICB2YXIgUG9zc2libHlXZWFrTWFwJDEgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwJDEoKTtcbn1cbi8qKlxuICogTGV2ZXJhZ2VzIG5hdGl2ZSBicm93c2VyL1ZNIHN0YWNrIGZyYW1lcyB0byBnZXQgcHJvcGVyIGRldGFpbHMgKGUuZy5cbiAqIGZpbGVuYW1lLCBsaW5lICsgY29sIG51bWJlcikgZm9yIGEgc2luZ2xlIGNvbXBvbmVudCBpbiBhIGNvbXBvbmVudCBzdGFjay4gV2VcbiAqIGRvIHRoaXMgYnk6XG4gKiAgICgxKSB0aHJvd2luZyBhbmQgY2F0Y2hpbmcgYW4gZXJyb3IgaW4gdGhlIGZ1bmN0aW9uIC0gdGhpcyB3aWxsIGJlIG91clxuICogICAgICAgY29udHJvbCBlcnJvci5cbiAqICAgKDIpIGNhbGxpbmcgdGhlIGNvbXBvbmVudCB3aGljaCB3aWxsIGV2ZW50dWFsbHkgdGhyb3cgYW4gZXJyb3IgdGhhdCB3ZSdsbFxuICogICAgICAgY2F0Y2ggLSB0aGlzIHdpbGwgYmUgb3VyIHNhbXBsZSBlcnJvci5cbiAqICAgKDMpIGRpZmZpbmcgdGhlIGNvbnRyb2wgYW5kIHNhbXBsZSBlcnJvciBzdGFja3MgdG8gZmluZCB0aGUgc3RhY2sgZnJhbWVcbiAqICAgICAgIHdoaWNoIHJlcHJlc2VudHMgb3VyIGNvbXBvbmVudC5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCFmbiB8fCByZWVudHJ5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAge1xuICAgIHZhciBmcmFtZSA9IGNvbXBvbmVudEZyYW1lQ2FjaGUuZ2V0KGZuKTtcblxuICAgIGlmIChmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnJhbWU7XG4gICAgfVxuICB9XG5cbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIEl0IGRvZXMgYWNjZXB0IHVuZGVmaW5lZC5cblxuICBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSA9IHVuZGVmaW5lZDtcbiAgdmFyIHByZXZpb3VzRGlzcGF0Y2hlciA9IG51bGw7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBudWxsO1xuICAgIGRpc2FibGVMb2dzKCk7XG4gIH1cbiAgLyoqXG4gICAqIEZpbmRpbmcgYSBjb21tb24gc3RhY2sgZnJhbWUgYmV0d2VlbiBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGNhbiBiZVxuICAgKiB0cmlja3kgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcyBhbmQgbGV2ZWxzIG9mIHN0YWNrIHRyYWNlIHRydW5jYXRpb24gZnJvbVxuICAgKiBkaWZmZXJlbnQgSlMgVk1zLiBTbyBpbnN0ZWFkIHdlJ2xsIGF0dGVtcHQgdG8gY29udHJvbCB3aGF0IHRoYXQgY29tbW9uXG4gICAqIGZyYW1lIHNob3VsZCBiZSB0aHJvdWdoIHRoaXMgb2JqZWN0IG1ldGhvZDpcbiAgICogSGF2aW5nIGJvdGggdGhlIHNhbXBsZSBhbmQgY29udHJvbCBlcnJvcnMgYmUgaW4gdGhlIGZ1bmN0aW9uIHVuZGVyIHRoZVxuICAgKiBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIHByb3BlcnR5LCArIHNldHRpbmcgdGhlIGBuYW1lYCBhbmRcbiAgICogYGRpc3BsYXlOYW1lYCBwcm9wZXJ0aWVzIG9mIHRoZSBmdW5jdGlvbiBlbnN1cmVzIHRoYXQgYSBzdGFja1xuICAgKiBmcmFtZSBleGlzdHMgdGhhdCBoYXMgdGhlIG1ldGhvZCBuYW1lIGBEZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lUm9vdGAgaW5cbiAgICogaXQgZm9yIGJvdGggY29udHJvbCBhbmQgc2FtcGxlIHN0YWNrcy5cbiAgICovXG5cblxuICB2YXIgUnVuSW5Sb290RnJhbWUgPSB7XG4gICAgRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290OiBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29udHJvbDtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgICAgIGlmIChjb25zdHJ1Y3QpIHtcbiAgICAgICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cblxuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIC8vIFdlIHVzZSBhIHRocm93aW5nIHNldHRlciBpbnN0ZWFkIG9mIGZyb3plbiBvciBub24td3JpdGFibGUgcHJvcHNcbiAgICAgICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAgICAgLy8gV2UgY29uc3RydWN0IGEgZGlmZmVyZW50IGNvbnRyb2wgZm9yIHRoaXMgY2FzZSB0byBpbmNsdWRlIGFueSBleHRyYVxuICAgICAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KEZha2UsIFtdKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgICAgICBmbi5jYWxsKEZha2UucHJvdG90eXBlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgfSAvLyBUT0RPKGx1bmEpOiBUaGlzIHdpbGwgY3VycmVudGx5IG9ubHkgdGhyb3cgaWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudFxuICAgICAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgICAgIC8vIGluIHNpbXBsZSBjb21wb25lbnRzIHRvb1xuXG5cbiAgICAgICAgICB2YXIgbWF5YmVQcm9taXNlID0gZm4oKTsgLy8gSWYgdGhlIGZ1bmN0aW9uIGNvbXBvbmVudCByZXR1cm5zIGEgcHJvbWlzZSwgaXQncyBsaWtlbHkgYW4gYXN5bmNcbiAgICAgICAgICAvLyBjb21wb25lbnQsIHdoaWNoIHdlIGRvbid0IHlldCBzdXBwb3J0LiBBdHRhY2ggYSBub29wIGNhdGNoIGhhbmRsZXIgdG9cbiAgICAgICAgICAvLyBzaWxlbmNlIHRoZSBlcnJvci5cbiAgICAgICAgICAvLyBUT0RPOiBJbXBsZW1lbnQgY29tcG9uZW50IHN0YWNrcyBmb3IgYXN5bmMgY2xpZW50IGNvbXBvbmVudHM/XG5cbiAgICAgICAgICBpZiAobWF5YmVQcm9taXNlICYmIHR5cGVvZiBtYXliZVByb21pc2UuY2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG1heWJlUHJvbWlzZS5jYXRjaChmdW5jdGlvbiAoKSB7fSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChzYW1wbGUpIHtcbiAgICAgICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICAgICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuIFtzYW1wbGUuc3RhY2ssIGNvbnRyb2wuc3RhY2tdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBbbnVsbCwgbnVsbF07XG4gICAgfVxuICB9OyAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cblxuICBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QuZGlzcGxheU5hbWUgPSAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290JztcbiAgdmFyIG5hbWVQcm9wRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LCAnbmFtZScpOyAvLyBCZWZvcmUgRVM2LCB0aGUgYG5hbWVgIHByb3BlcnR5IHdhcyBub3QgY29uZmlndXJhYmxlLlxuXG4gIGlmIChuYW1lUHJvcERlc2NyaXB0b3IgJiYgbmFtZVByb3BEZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSkge1xuICAgIC8vIFY4IHV0aWxpemVzIGEgZnVuY3Rpb24ncyBgbmFtZWAgcHJvcGVydHkgd2hlbiBnZW5lcmF0aW5nIGEgc3RhY2sgdHJhY2UuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgLy8gQ29uZmlndXJhYmxlIHByb3BlcnRpZXMgY2FuIGJlIHVwZGF0ZWQgZXZlbiBpZiBpdHMgd3JpdGFibGUgZGVzY3JpcHRvclxuICAgIC8vIGlzIHNldCB0byBgZmFsc2VgLlxuICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxuICAgICduYW1lJywge1xuICAgICAgdmFsdWU6ICdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnXG4gICAgfSk7XG4gIH1cblxuICB0cnkge1xuICAgIHZhciBfUnVuSW5Sb290RnJhbWUkRGV0ZXIgPSBSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QoKSxcbiAgICAgICAgc2FtcGxlU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMF0sXG4gICAgICAgIGNvbnRyb2xTdGFjayA9IF9SdW5JblJvb3RGcmFtZSREZXRlclsxXTtcblxuICAgIGlmIChzYW1wbGVTdGFjayAmJiBjb250cm9sU3RhY2spIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZVN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBjb250cm9sTGluZXMgPSBjb250cm9sU3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSAwO1xuICAgICAgdmFyIGMgPSAwO1xuXG4gICAgICB3aGlsZSAocyA8IHNhbXBsZUxpbmVzLmxlbmd0aCAmJiAhc2FtcGxlTGluZXNbc10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIHMrKztcbiAgICAgIH1cblxuICAgICAgd2hpbGUgKGMgPCBjb250cm9sTGluZXMubGVuZ3RoICYmICFjb250cm9sTGluZXNbY10uaW5jbHVkZXMoJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCcpKSB7XG4gICAgICAgIGMrKztcbiAgICAgIH0gLy8gV2UgY291bGRuJ3QgZmluZCBvdXIgaW50ZW50aW9uYWxseSBpbmplY3RlZCBjb21tb24gcm9vdCBmcmFtZSwgYXR0ZW1wdFxuICAgICAgLy8gdG8gZmluZCBhbm90aGVyIGNvbW1vbiByb290IGZyYW1lIGJ5IHNlYXJjaCBmcm9tIHRoZSBib3R0b20gb2YgdGhlXG4gICAgICAvLyBjb250cm9sIHN0YWNrLi4uXG5cblxuICAgICAgaWYgKHMgPT09IHNhbXBsZUxpbmVzLmxlbmd0aCB8fCBjID09PSBjb250cm9sTGluZXMubGVuZ3RoKSB7XG4gICAgICAgIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgICBjID0gY29udHJvbExpbmVzLmxlbmd0aCAtIDE7XG5cbiAgICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAgIC8vIFR5cGljYWxseSB0aGlzIHdpbGwgYmUgdGhlIHJvb3QgbW9zdCBvbmUuIEhvd2V2ZXIsIHN0YWNrIGZyYW1lcyBtYXkgYmVcbiAgICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYW5kIHRoZXJlIGZvciBjdXQgb2ZmIGVhcmxpZXIuIFNvIHdlIHNob3VsZCBmaW5kIHRoZSByb290IG1vc3QgZnJhbWUgaW5cbiAgICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgICBjLS07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICg7IHMgPj0gMSAmJiBjID49IDA7IHMtLSwgYy0tKSB7XG4gICAgICAgIC8vIE5leHQgd2UgZmluZCB0aGUgZmlyc3Qgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgd2hpY2ggc2hvdWxkIGJlIHRoZVxuICAgICAgICAvLyBmcmFtZSB0aGF0IGNhbGxlZCBvdXIgc2FtcGxlIGZ1bmN0aW9uIGFuZCB0aGUgY29udHJvbC5cbiAgICAgICAgaWYgKHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBJbiBWOCwgdGhlIGZpcnN0IGxpbmUgaXMgZGVzY3JpYmluZyB0aGUgbWVzc2FnZSBidXQgb3RoZXIgVk1zIGRvbid0LlxuICAgICAgICAgIC8vIElmIHdlJ3JlIGFib3V0IHRvIHJldHVybiB0aGUgZmlyc3QgbGluZSwgYW5kIHRoZSBjb250cm9sIGlzIGFsc28gb24gdGhlIHNhbWVcbiAgICAgICAgICAvLyBsaW5lLCB0aGF0J3MgYSBwcmV0dHkgZ29vZCBpbmRpY2F0b3IgdGhhdCBvdXIgc2FtcGxlIHRocmV3IGF0IHNhbWUgbGluZSBhc1xuICAgICAgICAgIC8vIHRoZSBjb250cm9sLiBJLmUuIGJlZm9yZSB3ZSBlbnRlcmVkIHRoZSBzYW1wbGUgZnJhbWUuIFNvIHdlIGlnbm9yZSB0aGlzIHJlc3VsdC5cbiAgICAgICAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaWYgeW91IHBhc3NlZCBhIGNsYXNzIHRvIGZ1bmN0aW9uIGNvbXBvbmVudCwgb3Igbm9uLWZ1bmN0aW9uLlxuICAgICAgICAgIGlmIChzICE9PSAxIHx8IGMgIT09IDEpIHtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcy0tO1xuICAgICAgICAgICAgICBjLS07IC8vIFdlIG1heSBzdGlsbCBoYXZlIHNpbWlsYXIgaW50ZXJtZWRpYXRlIGZyYW1lcyBmcm9tIHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgICAgICAgLy8gVGhlIG5leHQgb25lIHRoYXQgaXNuJ3QgdGhlIHNhbWUgc2hvdWxkIGJlIG91ciBtYXRjaCB0aG91Z2guXG5cbiAgICAgICAgICAgICAgaWYgKGMgPCAwIHx8IHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAgICAgICAvLyBWOCBhZGRzIGEgXCJuZXdcIiBwcmVmaXggZm9yIG5hdGl2ZSBjbGFzc2VzLiBMZXQncyByZW1vdmUgaXQgdG8gbWFrZSBpdCBwcmV0dGllci5cbiAgICAgICAgICAgICAgICB2YXIgX2ZyYW1lID0gJ1xcbicgKyBzYW1wbGVMaW5lc1tzXS5yZXBsYWNlKCcgYXQgbmV3ICcsICcgYXQgJyk7IC8vIElmIG91ciBjb21wb25lbnQgZnJhbWUgaXMgbGFiZWxlZCBcIjxhbm9ueW1vdXM+XCJcbiAgICAgICAgICAgICAgICAvLyBidXQgd2UgaGF2ZSBhIHVzZXItcHJvdmlkZWQgXCJkaXNwbGF5TmFtZVwiXG4gICAgICAgICAgICAgICAgLy8gc3BsaWNlIGl0IGluIHRvIG1ha2UgdGhlIHN0YWNrIG1vcmUgcmVhZGFibGUuXG5cblxuICAgICAgICAgICAgICAgIGlmIChmbi5kaXNwbGF5TmFtZSAmJiBfZnJhbWUuaW5jbHVkZXMoJzxhbm9ueW1vdXM+JykpIHtcbiAgICAgICAgICAgICAgICAgIF9mcmFtZSA9IF9mcmFtZS5yZXBsYWNlKCc8YW5vbnltb3VzPicsIGZuLmRpc3BsYXlOYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlQ2xhc3NDb21wb25lbnRGcmFtZShjdG9yKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShjdG9yLCB0cnVlKTtcbiAgfVxufVxuZnVuY3Rpb24gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKGZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlRmliZXIoZmliZXIpIHtcbiAgc3dpdGNoIChmaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RIb2lzdGFibGU6XG4gICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShmaWJlci50eXBlKTtcblxuICAgIGNhc2UgTGF6eUNvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnTGF6eScpO1xuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgU3VzcGVuc2VMaXN0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcblxuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmaWJlci50eXBlKTtcblxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZS5yZW5kZXIpO1xuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHJldHVybiBkZXNjcmliZUNsYXNzQ29tcG9uZW50RnJhbWUoZmliZXIudHlwZSk7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZCh3b3JrSW5Qcm9ncmVzcykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gJyc7XG4gICAgdmFyIG5vZGUgPSB3b3JrSW5Qcm9ncmVzcztcblxuICAgIGRvIHtcbiAgICAgIGluZm8gKz0gZGVzY3JpYmVGaWJlcihub2RlKTtcblxuICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgLy8gQWRkIGFueSBTZXJ2ZXIgQ29tcG9uZW50IHN0YWNrIGZyYW1lcyBpbiByZXZlcnNlIG9yZGVyLlxuICAgICAgICB2YXIgZGVidWdJbmZvID0gbm9kZS5fZGVidWdJbmZvO1xuXG4gICAgICAgIGlmIChkZWJ1Z0luZm8pIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gZGVidWdJbmZvLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBkZWJ1Z0luZm9baV07XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZW50cnkubmFtZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgaW5mbyArPSBkZXNjcmliZURlYnVnSW5mb0ZyYW1lKGVudHJ5Lm5hbWUsIGVudHJ5LmVudik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIHdlIGJhaWwgb3V0IHdoZW4gd2UgZ2V0IGEgbnVsbFxuXG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9IHdoaWxlIChub2RlKTtcblxuICAgIHJldHVybiBpbmZvO1xuICB9IGNhdGNoICh4KSB7XG4gICAgcmV0dXJuICdcXG5FcnJvciBnZW5lcmF0aW5nIHN0YWNrOiAnICsgeC5tZXNzYWdlICsgJ1xcbicgKyB4LnN0YWNrO1xuICB9XG59XG5cbnZhciBjdXJyZW50ID0gbnVsbDtcbnZhciBpc1JlbmRlcmluZyA9IGZhbHNlO1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50RmliZXJTdGFja0luRGV2KCkge1xuICB7XG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9IC8vIFNhZmUgYmVjYXVzZSBpZiBjdXJyZW50IGZpYmVyIGV4aXN0cywgd2UgYXJlIHJlY29uY2lsaW5nLFxuICAgIC8vIGFuZCBpdCBpcyBndWFyYW50ZWVkIHRvIGJlIHRoZSB3b3JrLWluLXByb2dyZXNzIHZlcnNpb24uXG5cblxuICAgIHJldHVybiBnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2QoY3VycmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzZXRDdXJyZW50RGVidWdGaWJlckluREVWKCkge1xuICB7XG4gICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgfVxufVxuZnVuY3Rpb24gc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihmaWJlcikge1xuICB7XG4gICAgc2V0Q3VycmVudEZpYmVyKGZpYmVyKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVzZXRDdXJyZW50RmliZXIoKSB7XG4gIHtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5nZXRDdXJyZW50U3RhY2sgPSBudWxsO1xuICAgIGlzUmVuZGVyaW5nID0gZmFsc2U7XG4gIH1cblxuICBjdXJyZW50ID0gbnVsbDtcbn1cbmZ1bmN0aW9uIHNldEN1cnJlbnRGaWJlcihmaWJlcikge1xuICB7XG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZ2V0Q3VycmVudFN0YWNrID0gZmliZXIgPT09IG51bGwgPyBudWxsIDogZ2V0Q3VycmVudEZpYmVyU3RhY2tJbkRldjtcbiAgICBpc1JlbmRlcmluZyA9IGZhbHNlO1xuICB9XG5cbiAgY3VycmVudCA9IGZpYmVyO1xufVxuZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyKCkge1xuICB7XG4gICAgcmV0dXJuIGN1cnJlbnQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHNldElzUmVuZGVyaW5nKHJlbmRlcmluZykge1xuICB7XG4gICAgaXNSZW5kZXJpbmcgPSByZW5kZXJpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TmVhcmVzdE1vdW50ZWRGaWJlcihmaWJlcikge1xuICB2YXIgbm9kZSA9IGZpYmVyO1xuICB2YXIgbmVhcmVzdE1vdW50ZWQgPSBmaWJlcjtcblxuICBpZiAoIWZpYmVyLmFsdGVybmF0ZSkge1xuICAgIC8vIElmIHRoZXJlIGlzIG5vIGFsdGVybmF0ZSwgdGhpcyBtaWdodCBiZSBhIG5ldyB0cmVlIHRoYXQgaXNuJ3QgaW5zZXJ0ZWRcbiAgICAvLyB5ZXQuIElmIGl0IGlzLCB0aGVuIGl0IHdpbGwgaGF2ZSBhIHBlbmRpbmcgaW5zZXJ0aW9uIGVmZmVjdCBvbiBpdC5cbiAgICB2YXIgbmV4dE5vZGUgPSBub2RlO1xuXG4gICAgZG8ge1xuICAgICAgbm9kZSA9IG5leHROb2RlO1xuXG4gICAgICBpZiAoKG5vZGUuZmxhZ3MgJiAoUGxhY2VtZW50IHwgSHlkcmF0aW5nKSkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAvLyBUaGlzIGlzIGFuIGluc2VydGlvbiBvciBpbi1wcm9ncmVzcyBoeWRyYXRpb24uIFRoZSBuZWFyZXN0IHBvc3NpYmxlXG4gICAgICAgIC8vIG1vdW50ZWQgZmliZXIgaXMgdGhlIHBhcmVudCBidXQgd2UgbmVlZCB0byBjb250aW51ZSB0byBmaWd1cmUgb3V0XG4gICAgICAgIC8vIGlmIHRoYXQgb25lIGlzIHN0aWxsIG1vdW50ZWQuXG4gICAgICAgIG5lYXJlc3RNb3VudGVkID0gbm9kZS5yZXR1cm47XG4gICAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIHdlIGJhaWwgb3V0IHdoZW4gd2UgZ2V0IGEgbnVsbFxuXG5cbiAgICAgIG5leHROb2RlID0gbm9kZS5yZXR1cm47XG4gICAgfSB3aGlsZSAobmV4dE5vZGUpO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChub2RlLnJldHVybikge1xuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cbiAgfVxuXG4gIGlmIChub2RlLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAvLyBUT0RPOiBDaGVjayBpZiB0aGlzIHdhcyBhIG5lc3RlZCBIb3N0Um9vdCB3aGVuIHVzZWQgd2l0aFxuICAgIC8vIHJlbmRlckNvbnRhaW5lckludG9TdWJ0cmVlLlxuICAgIHJldHVybiBuZWFyZXN0TW91bnRlZDtcbiAgfSAvLyBJZiB3ZSBkaWRuJ3QgaGl0IHRoZSByb290LCB0aGF0IG1lYW5zIHRoYXQgd2UncmUgaW4gYW4gZGlzY29ubmVjdGVkIHRyZWVcbiAgLy8gdGhhdCBoYXMgYmVlbiB1bm1vdW50ZWQuXG5cblxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGlzTW91bnRlZChjb21wb25lbnQpIHtcbiAge1xuICAgIHZhciBvd25lciA9IGN1cnJlbnQ7XG5cbiAgICBpZiAob3duZXIgIT09IG51bGwgJiYgaXNSZW5kZXJpbmcgJiYgb3duZXIudGFnID09PSBDbGFzc0NvbXBvbmVudCkge1xuICAgICAgdmFyIG93bmVyRmliZXIgPSBvd25lcjtcbiAgICAgIHZhciBpbnN0YW5jZSA9IG93bmVyRmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICBpZiAoIWluc3RhbmNlLl93YXJuZWRBYm91dFJlZnNJblJlbmRlcikge1xuICAgICAgICBlcnJvcignJXMgaXMgYWNjZXNzaW5nIGlzTW91bnRlZCBpbnNpZGUgaXRzIHJlbmRlcigpIGZ1bmN0aW9uLiAnICsgJ3JlbmRlcigpIHNob3VsZCBiZSBhIHB1cmUgZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLiBJdCBzaG91bGQgJyArICduZXZlciBhY2Nlc3Mgc29tZXRoaW5nIHRoYXQgcmVxdWlyZXMgc3RhbGUgZGF0YSBmcm9tIHRoZSBwcmV2aW91cyAnICsgJ3JlbmRlciwgc3VjaCBhcyByZWZzLiBNb3ZlIHRoaXMgbG9naWMgdG8gY29tcG9uZW50RGlkTW91bnQgYW5kICcgKyAnY29tcG9uZW50RGlkVXBkYXRlIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihvd25lckZpYmVyKSB8fCAnQSBjb21wb25lbnQnKTtcbiAgICAgIH1cblxuICAgICAgaW5zdGFuY2UuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICB2YXIgZmliZXIgPSBnZXQoY29tcG9uZW50KTtcblxuICBpZiAoIWZpYmVyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpID09PSBmaWJlcjtcbn1cblxuZnVuY3Rpb24gYXNzZXJ0SXNNb3VudGVkKGZpYmVyKSB7XG4gIGlmIChnZXROZWFyZXN0TW91bnRlZEZpYmVyKGZpYmVyKSAhPT0gZmliZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aChmaWJlcikge1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gIGlmICghYWx0ZXJuYXRlKSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgbm8gYWx0ZXJuYXRlLCB0aGVuIHdlIG9ubHkgbmVlZCB0byBjaGVjayBpZiBpdCBpcyBtb3VudGVkLlxuICAgIHZhciBuZWFyZXN0TW91bnRlZCA9IGdldE5lYXJlc3RNb3VudGVkRmliZXIoZmliZXIpO1xuXG4gICAgaWYgKG5lYXJlc3RNb3VudGVkID09PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgICB9XG5cbiAgICBpZiAobmVhcmVzdE1vdW50ZWQgIT09IGZpYmVyKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmliZXI7XG4gIH0gLy8gSWYgd2UgaGF2ZSB0d28gcG9zc2libGUgYnJhbmNoZXMsIHdlJ2xsIHdhbGsgYmFja3dhcmRzIHVwIHRvIHRoZSByb290XG4gIC8vIHRvIHNlZSB3aGF0IHBhdGggdGhlIHJvb3QgcG9pbnRzIHRvLiBPbiB0aGUgd2F5IHdlIG1heSBoaXQgb25lIG9mIHRoZVxuICAvLyBzcGVjaWFsIGNhc2VzIGFuZCB3ZSdsbCBkZWFsIHdpdGggdGhlbS5cblxuXG4gIHZhciBhID0gZmliZXI7XG4gIHZhciBiID0gYWx0ZXJuYXRlO1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgdmFyIHBhcmVudEEgPSBhLnJldHVybjtcblxuICAgIGlmIChwYXJlbnRBID09PSBudWxsKSB7XG4gICAgICAvLyBXZSdyZSBhdCB0aGUgcm9vdC5cbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBwYXJlbnRCID0gcGFyZW50QS5hbHRlcm5hdGU7XG5cbiAgICBpZiAocGFyZW50QiA9PT0gbnVsbCkge1xuICAgICAgLy8gVGhlcmUgaXMgbm8gYWx0ZXJuYXRlLiBUaGlzIGlzIGFuIHVudXN1YWwgY2FzZS4gQ3VycmVudGx5LCBpdCBvbmx5XG4gICAgICAvLyBoYXBwZW5zIHdoZW4gYSBTdXNwZW5zZSBjb21wb25lbnQgaXMgaGlkZGVuLiBBbiBleHRyYSBmcmFnbWVudCBmaWJlclxuICAgICAgLy8gaXMgaW5zZXJ0ZWQgaW4gYmV0d2VlbiB0aGUgU3VzcGVuc2UgZmliZXIgYW5kIGl0cyBjaGlsZHJlbi4gU2tpcFxuICAgICAgLy8gb3ZlciB0aGlzIGV4dHJhIGZyYWdtZW50IGZpYmVyIGFuZCBwcm9jZWVkIHRvIHRoZSBuZXh0IHBhcmVudC5cbiAgICAgIHZhciBuZXh0UGFyZW50ID0gcGFyZW50QS5yZXR1cm47XG5cbiAgICAgIGlmIChuZXh0UGFyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIGEgPSBiID0gbmV4dFBhcmVudDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIElmIHRoZXJlJ3Mgbm8gcGFyZW50LCB3ZSdyZSBhdCB0aGUgcm9vdC5cblxuXG4gICAgICBicmVhaztcbiAgICB9IC8vIElmIGJvdGggY29waWVzIG9mIHRoZSBwYXJlbnQgZmliZXIgcG9pbnQgdG8gdGhlIHNhbWUgY2hpbGQsIHdlIGNhblxuICAgIC8vIGFzc3VtZSB0aGF0IHRoZSBjaGlsZCBpcyBjdXJyZW50LiBUaGlzIGhhcHBlbnMgd2hlbiB3ZSBiYWlsb3V0IG9uIGxvd1xuICAgIC8vIHByaW9yaXR5OiB0aGUgYmFpbGVkIG91dCBmaWJlcidzIGNoaWxkIHJldXNlcyB0aGUgY3VycmVudCBjaGlsZC5cblxuXG4gICAgaWYgKHBhcmVudEEuY2hpbGQgPT09IHBhcmVudEIuY2hpbGQpIHtcbiAgICAgIHZhciBjaGlsZCA9IHBhcmVudEEuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChjaGlsZCkge1xuICAgICAgICBpZiAoY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAvLyBXZSd2ZSBkZXRlcm1pbmVkIHRoYXQgQSBpcyB0aGUgY3VycmVudCBicmFuY2guXG4gICAgICAgICAgYXNzZXJ0SXNNb3VudGVkKHBhcmVudEEpO1xuICAgICAgICAgIHJldHVybiBmaWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjaGlsZCA9PT0gYikge1xuICAgICAgICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBCIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICAgICAgICBhc3NlcnRJc01vdW50ZWQocGFyZW50QSk7XG4gICAgICAgICAgcmV0dXJuIGFsdGVybmF0ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH0gLy8gV2Ugc2hvdWxkIG5ldmVyIGhhdmUgYW4gYWx0ZXJuYXRlIGZvciBhbnkgbW91bnRpbmcgbm9kZS4gU28gdGhlIG9ubHlcbiAgICAgIC8vIHdheSB0aGlzIGNvdWxkIHBvc3NpYmx5IGhhcHBlbiBpcyBpZiB0aGlzIHdhcyB1bm1vdW50ZWQsIGlmIGF0IGFsbC5cblxuXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgICB9XG5cbiAgICBpZiAoYS5yZXR1cm4gIT09IGIucmV0dXJuKSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXIgb2YgQSBhbmQgdGhlIHJldHVybiBwb2ludGVyIG9mIEIgcG9pbnQgdG8gZGlmZmVyZW50XG4gICAgICAvLyBmaWJlcnMuIFdlIGFzc3VtZSB0aGF0IHJldHVybiBwb2ludGVycyBuZXZlciBjcmlzcy1jcm9zcywgc28gQSBtdXN0XG4gICAgICAvLyBiZWxvbmcgdG8gdGhlIGNoaWxkIHNldCBvZiBBLnJldHVybiwgYW5kIEIgbXVzdCBiZWxvbmcgdG8gdGhlIGNoaWxkXG4gICAgICAvLyBzZXQgb2YgQi5yZXR1cm4uXG4gICAgICBhID0gcGFyZW50QTtcbiAgICAgIGIgPSBwYXJlbnRCO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgcmV0dXJuIHBvaW50ZXJzIHBvaW50IHRvIHRoZSBzYW1lIGZpYmVyLiBXZSdsbCBoYXZlIHRvIHVzZSB0aGVcbiAgICAgIC8vIGRlZmF1bHQsIHNsb3cgcGF0aDogc2NhbiB0aGUgY2hpbGQgc2V0cyBvZiBlYWNoIHBhcmVudCBhbHRlcm5hdGUgdG8gc2VlXG4gICAgICAvLyB3aGljaCBjaGlsZCBiZWxvbmdzIHRvIHdoaWNoIHNldC5cbiAgICAgIC8vXG4gICAgICAvLyBTZWFyY2ggcGFyZW50IEEncyBjaGlsZCBzZXRcbiAgICAgIHZhciBkaWRGaW5kQ2hpbGQgPSBmYWxzZTtcbiAgICAgIHZhciBfY2hpbGQgPSBwYXJlbnRBLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoX2NoaWxkKSB7XG4gICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICBkaWRGaW5kQ2hpbGQgPSB0cnVlO1xuICAgICAgICAgIGEgPSBwYXJlbnRBO1xuICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgYiA9IHBhcmVudEE7XG4gICAgICAgICAgYSA9IHBhcmVudEI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgIH1cblxuICAgICAgaWYgKCFkaWRGaW5kQ2hpbGQpIHtcbiAgICAgICAgLy8gU2VhcmNoIHBhcmVudCBCJ3MgY2hpbGQgc2V0XG4gICAgICAgIF9jaGlsZCA9IHBhcmVudEIuY2hpbGQ7XG5cbiAgICAgICAgd2hpbGUgKF9jaGlsZCkge1xuICAgICAgICAgIGlmIChfY2hpbGQgPT09IGEpIHtcbiAgICAgICAgICAgIGRpZEZpbmRDaGlsZCA9IHRydWU7XG4gICAgICAgICAgICBhID0gcGFyZW50QjtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRBO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF9jaGlsZCA9PT0gYikge1xuICAgICAgICAgICAgZGlkRmluZENoaWxkID0gdHJ1ZTtcbiAgICAgICAgICAgIGIgPSBwYXJlbnRCO1xuICAgICAgICAgICAgYSA9IHBhcmVudEE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfY2hpbGQgPSBfY2hpbGQuc2libGluZztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghZGlkRmluZENoaWxkKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDaGlsZCB3YXMgbm90IGZvdW5kIGluIGVpdGhlciBwYXJlbnQgc2V0LiBUaGlzIGluZGljYXRlcyBhIGJ1ZyAnICsgJ2luIFJlYWN0IHJlbGF0ZWQgdG8gdGhlIHJldHVybiBwb2ludGVyLiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhLmFsdGVybmF0ZSAhPT0gYikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmV0dXJuIGZpYmVycyBzaG91bGQgYWx3YXlzIGJlIGVhY2ggb3RoZXJzJyBhbHRlcm5hdGVzLiBcIiArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfSAvLyBJZiB0aGUgcm9vdCBpcyBub3QgYSBob3N0IGNvbnRhaW5lciwgd2UncmUgaW4gYSBkaXNjb25uZWN0ZWQgdHJlZS4gSS5lLlxuICAvLyB1bm1vdW50ZWQuXG5cblxuICBpZiAoYS50YWcgIT09IEhvc3RSb290KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBub2RlIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuJyk7XG4gIH1cblxuICBpZiAoYS5zdGF0ZU5vZGUuY3VycmVudCA9PT0gYSkge1xuICAgIC8vIFdlJ3ZlIGRldGVybWluZWQgdGhhdCBBIGlzIHRoZSBjdXJyZW50IGJyYW5jaC5cbiAgICByZXR1cm4gZmliZXI7XG4gIH0gLy8gT3RoZXJ3aXNlIEIgaGFzIHRvIGJlIGN1cnJlbnQgYnJhbmNoLlxuXG5cbiAgcmV0dXJuIGFsdGVybmF0ZTtcbn1cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyKHBhcmVudCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gIHJldHVybiBjdXJyZW50UGFyZW50ICE9PSBudWxsID8gZmluZEN1cnJlbnRIb3N0RmliZXJJbXBsKGN1cnJlbnRQYXJlbnQpIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXJJbXBsKG5vZGUpIHtcbiAgLy8gTmV4dCB3ZSdsbCBkcmlsbCBkb3duIHRoaXMgY29tcG9uZW50IHRvIGZpbmQgdGhlIGZpcnN0IEhvc3RDb21wb25lbnQvVGV4dC5cbiAgdmFyIHRhZyA9IG5vZGUudGFnO1xuXG4gIGlmICh0YWcgPT09IEhvc3RDb21wb25lbnQgfHwgdGFnID09PSBIb3N0SG9pc3RhYmxlIHx8IHRhZyA9PT0gSG9zdFNpbmdsZXRvbiB8fCB0YWcgPT09IEhvc3RUZXh0KSB7XG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgIHZhciBtYXRjaCA9IGZpbmRDdXJyZW50SG9zdEZpYmVySW1wbChjaGlsZCk7XG5cbiAgICBpZiAobWF0Y2ggIT09IG51bGwpIHtcbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9XG5cbiAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKHBhcmVudCkge1xuICB2YXIgY3VycmVudFBhcmVudCA9IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoKHBhcmVudCk7XG4gIHJldHVybiBjdXJyZW50UGFyZW50ICE9PSBudWxsID8gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzSW1wbChjdXJyZW50UGFyZW50KSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGZpbmRDdXJyZW50SG9zdEZpYmVyV2l0aE5vUG9ydGFsc0ltcGwobm9kZSkge1xuICAvLyBOZXh0IHdlJ2xsIGRyaWxsIGRvd24gdGhpcyBjb21wb25lbnQgdG8gZmluZCB0aGUgZmlyc3QgSG9zdENvbXBvbmVudC9UZXh0LlxuICB2YXIgdGFnID0gbm9kZS50YWc7XG5cbiAgaWYgKHRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCB0YWcgPT09IEhvc3RIb2lzdGFibGUgfHwgdGFnID09PSBIb3N0U2luZ2xldG9uIHx8IHRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIHZhciBjaGlsZCA9IG5vZGUuY2hpbGQ7XG5cbiAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgaWYgKGNoaWxkLnRhZyAhPT0gSG9zdFBvcnRhbCkge1xuICAgICAgdmFyIG1hdGNoID0gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzSW1wbChjaGlsZCk7XG5cbiAgICAgIGlmIChtYXRjaCAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxuLy8gVGhpcyBpcyBhIGhvc3QgY29uZmlnIHRoYXQncyB1c2VkIGZvciB0aGUgYHJlYWN0LXJlY29uY2lsZXJgIHBhY2thZ2Ugb24gbnBtLlxuLy8gSXQgaXMgb25seSB1c2VkIGJ5IHRoaXJkLXBhcnR5IHJlbmRlcmVycy5cbi8vXG4vLyBJdHMgQVBJIGxldHMgeW91IHBhc3MgdGhlIGhvc3QgY29uZmlnIGFzIGFuIGFyZ3VtZW50LlxuLy8gSG93ZXZlciwgaW5zaWRlIHRoZSBgcmVhY3QtcmVjb25jaWxlcmAgd2UgdHJlYXQgaG9zdCBjb25maWcgYXMgYSBtb2R1bGUuXG4vLyBUaGlzIGZpbGUgaXMgYSBzaGltIGJldHdlZW4gdHdvIHdvcmxkcy5cbi8vXG4vLyBJdCB3b3JrcyBiZWNhdXNlIHRoZSBgcmVhY3QtcmVjb25jaWxlcmAgYnVuZGxlIGlzIHdyYXBwZWQgaW4gc29tZXRoaW5nIGxpa2U6XG4vL1xuLy8gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoJCQkY29uZmlnKSB7XG4vLyAgIC8qIHJlY29uY2lsZXIgY29kZSAqL1xuLy8gfVxuLy9cbi8vIFNvIGAkJCRjb25maWdgIGxvb2tzIGxpa2UgYSBnbG9iYWwgdmFyaWFibGUsIGJ1dCBpdCdzXG4vLyByZWFsbHkgYW4gYXJndW1lbnQgdG8gYSB0b3AtbGV2ZWwgd3JhcHBpbmcgZnVuY3Rpb24uXG4vLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4vLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4vLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4vLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4vLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4vLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4vLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4vLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4vLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4vLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4vLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4vLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4vLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4vLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4vLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG4vLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG52YXIgZ2V0UHVibGljSW5zdGFuY2UgPSAkJCRjb25maWcuZ2V0UHVibGljSW5zdGFuY2U7XG52YXIgZ2V0Um9vdEhvc3RDb250ZXh0ID0gJCQkY29uZmlnLmdldFJvb3RIb3N0Q29udGV4dDtcbnZhciBnZXRDaGlsZEhvc3RDb250ZXh0ID0gJCQkY29uZmlnLmdldENoaWxkSG9zdENvbnRleHQ7XG52YXIgcHJlcGFyZUZvckNvbW1pdCA9ICQkJGNvbmZpZy5wcmVwYXJlRm9yQ29tbWl0O1xudmFyIHJlc2V0QWZ0ZXJDb21taXQgPSAkJCRjb25maWcucmVzZXRBZnRlckNvbW1pdDtcbnZhciBjcmVhdGVJbnN0YW5jZSA9ICQkJGNvbmZpZy5jcmVhdGVJbnN0YW5jZTtcbnZhciBhcHBlbmRJbml0aWFsQ2hpbGQgPSAkJCRjb25maWcuYXBwZW5kSW5pdGlhbENoaWxkO1xudmFyIGZpbmFsaXplSW5pdGlhbENoaWxkcmVuID0gJCQkY29uZmlnLmZpbmFsaXplSW5pdGlhbENoaWxkcmVuO1xudmFyIHNob3VsZFNldFRleHRDb250ZW50ID0gJCQkY29uZmlnLnNob3VsZFNldFRleHRDb250ZW50O1xudmFyIGNyZWF0ZVRleHRJbnN0YW5jZSA9ICQkJGNvbmZpZy5jcmVhdGVUZXh0SW5zdGFuY2U7XG52YXIgc2NoZWR1bGVUaW1lb3V0ID0gJCQkY29uZmlnLnNjaGVkdWxlVGltZW91dDtcbnZhciBjYW5jZWxUaW1lb3V0ID0gJCQkY29uZmlnLmNhbmNlbFRpbWVvdXQ7XG52YXIgbm9UaW1lb3V0ID0gJCQkY29uZmlnLm5vVGltZW91dDtcbnZhciBpc1ByaW1hcnlSZW5kZXJlciA9ICQkJGNvbmZpZy5pc1ByaW1hcnlSZW5kZXJlcjtcbiQkJGNvbmZpZy53YXJuc0lmTm90QWN0aW5nO1xudmFyIHN1cHBvcnRzTXV0YXRpb24gPSAkJCRjb25maWcuc3VwcG9ydHNNdXRhdGlvbjtcbnZhciBzdXBwb3J0c1BlcnNpc3RlbmNlID0gJCQkY29uZmlnLnN1cHBvcnRzUGVyc2lzdGVuY2U7XG52YXIgc3VwcG9ydHNIeWRyYXRpb24gPSAkJCRjb25maWcuc3VwcG9ydHNIeWRyYXRpb247XG52YXIgZ2V0SW5zdGFuY2VGcm9tTm9kZSA9ICQkJGNvbmZpZy5nZXRJbnN0YW5jZUZyb21Ob2RlO1xuJCQkY29uZmlnLmJlZm9yZUFjdGl2ZUluc3RhbmNlQmx1cjtcbiQkJGNvbmZpZy5hZnRlckFjdGl2ZUluc3RhbmNlQmx1cjtcbnZhciBwcmVwYXJlUG9ydGFsTW91bnQgPSAkJCRjb25maWcucHJlcGFyZVBvcnRhbE1vdW50O1xuJCQkY29uZmlnLnByZXBhcmVTY29wZVVwZGF0ZTtcbiQkJGNvbmZpZy5nZXRJbnN0YW5jZUZyb21TY29wZTtcbnZhciBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkgPSAkJCRjb25maWcuc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5O1xudmFyIGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSA9ICQkJGNvbmZpZy5nZXRDdXJyZW50VXBkYXRlUHJpb3JpdHk7XG52YXIgcmVzb2x2ZVVwZGF0ZVByaW9yaXR5ID0gJCQkY29uZmlnLnJlc29sdmVVcGRhdGVQcmlvcml0eTtcbnZhciBzaG91bGRBdHRlbXB0RWFnZXJUcmFuc2l0aW9uID0gJCQkY29uZmlnLnNob3VsZEF0dGVtcHRFYWdlclRyYW5zaXRpb247XG52YXIgZGV0YWNoRGVsZXRlZEluc3RhbmNlID0gJCQkY29uZmlnLmRldGFjaERlbGV0ZWRJbnN0YW5jZTtcbiQkJGNvbmZpZy5yZXF1ZXN0UG9zdFBhaW50Q2FsbGJhY2s7XG52YXIgbWF5U3VzcGVuZENvbW1pdCA9ICQkJGNvbmZpZy5tYXlTdXNwZW5kQ29tbWl0O1xudmFyIHByZWxvYWRJbnN0YW5jZSA9ICQkJGNvbmZpZy5wcmVsb2FkSW5zdGFuY2U7XG52YXIgc3RhcnRTdXNwZW5kaW5nQ29tbWl0ID0gJCQkY29uZmlnLnN0YXJ0U3VzcGVuZGluZ0NvbW1pdDtcbnZhciBzdXNwZW5kSW5zdGFuY2UgPSAkJCRjb25maWcuc3VzcGVuZEluc3RhbmNlO1xudmFyIHdhaXRGb3JDb21taXRUb0JlUmVhZHkgPSAkJCRjb25maWcud2FpdEZvckNvbW1pdFRvQmVSZWFkeTtcbnZhciBOb3RQZW5kaW5nVHJhbnNpdGlvbiA9ICQkJGNvbmZpZy5Ob3RQZW5kaW5nVHJhbnNpdGlvbjtcbnZhciByZXNldEZvcm1JbnN0YW5jZSA9ICQkJGNvbmZpZy5yZXNldEZvcm1JbnN0YW5jZTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gICAgICBNaWNyb3Rhc2tzXG4vLyAgICAgKG9wdGlvbmFsKVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgc3VwcG9ydHNNaWNyb3Rhc2tzID0gJCQkY29uZmlnLnN1cHBvcnRzTWljcm90YXNrcztcbnZhciBzY2hlZHVsZU1pY3JvdGFzayA9ICQkJGNvbmZpZy5zY2hlZHVsZU1pY3JvdGFzazsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gICAgICBUZXN0IHNlbGVjdG9yc1xuLy8gICAgIChvcHRpb25hbClcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIHN1cHBvcnRzVGVzdFNlbGVjdG9ycyA9ICQkJGNvbmZpZy5zdXBwb3J0c1Rlc3RTZWxlY3RvcnM7XG52YXIgZmluZEZpYmVyUm9vdCA9ICQkJGNvbmZpZy5maW5kRmliZXJSb290O1xudmFyIGdldEJvdW5kaW5nUmVjdCA9ICQkJGNvbmZpZy5nZXRCb3VuZGluZ1JlY3Q7XG52YXIgZ2V0VGV4dENvbnRlbnQgPSAkJCRjb25maWcuZ2V0VGV4dENvbnRlbnQ7XG52YXIgaXNIaWRkZW5TdWJ0cmVlID0gJCQkY29uZmlnLmlzSGlkZGVuU3VidHJlZTtcbnZhciBtYXRjaEFjY2Vzc2liaWxpdHlSb2xlID0gJCQkY29uZmlnLm1hdGNoQWNjZXNzaWJpbGl0eVJvbGU7XG52YXIgc2V0Rm9jdXNJZkZvY3VzYWJsZSA9ICQkJGNvbmZpZy5zZXRGb2N1c0lmRm9jdXNhYmxlO1xudmFyIHNldHVwSW50ZXJzZWN0aW9uT2JzZXJ2ZXIgPSAkJCRjb25maWcuc2V0dXBJbnRlcnNlY3Rpb25PYnNlcnZlcjsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gICAgICBNdXRhdGlvblxuLy8gICAgIChvcHRpb25hbClcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGFwcGVuZENoaWxkID0gJCQkY29uZmlnLmFwcGVuZENoaWxkO1xudmFyIGFwcGVuZENoaWxkVG9Db250YWluZXIgPSAkJCRjb25maWcuYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcjtcbnZhciBjb21taXRUZXh0VXBkYXRlID0gJCQkY29uZmlnLmNvbW1pdFRleHRVcGRhdGU7XG52YXIgY29tbWl0TW91bnQgPSAkJCRjb25maWcuY29tbWl0TW91bnQ7XG52YXIgY29tbWl0VXBkYXRlID0gJCQkY29uZmlnLmNvbW1pdFVwZGF0ZTtcbnZhciBpbnNlcnRCZWZvcmUgPSAkJCRjb25maWcuaW5zZXJ0QmVmb3JlO1xudmFyIGluc2VydEluQ29udGFpbmVyQmVmb3JlID0gJCQkY29uZmlnLmluc2VydEluQ29udGFpbmVyQmVmb3JlO1xudmFyIHJlbW92ZUNoaWxkID0gJCQkY29uZmlnLnJlbW92ZUNoaWxkO1xudmFyIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lciA9ICQkJGNvbmZpZy5yZW1vdmVDaGlsZEZyb21Db250YWluZXI7XG52YXIgcmVzZXRUZXh0Q29udGVudCA9ICQkJGNvbmZpZy5yZXNldFRleHRDb250ZW50O1xudmFyIGhpZGVJbnN0YW5jZSA9ICQkJGNvbmZpZy5oaWRlSW5zdGFuY2U7XG52YXIgaGlkZVRleHRJbnN0YW5jZSA9ICQkJGNvbmZpZy5oaWRlVGV4dEluc3RhbmNlO1xudmFyIHVuaGlkZUluc3RhbmNlID0gJCQkY29uZmlnLnVuaGlkZUluc3RhbmNlO1xudmFyIHVuaGlkZVRleHRJbnN0YW5jZSA9ICQkJGNvbmZpZy51bmhpZGVUZXh0SW5zdGFuY2U7XG52YXIgY2xlYXJDb250YWluZXIgPSAkJCRjb25maWcuY2xlYXJDb250YWluZXI7IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vICAgICBQZXJzaXN0ZW5jZVxuLy8gICAgIChvcHRpb25hbClcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGNsb25lSW5zdGFuY2UgPSAkJCRjb25maWcuY2xvbmVJbnN0YW5jZTtcbnZhciBjcmVhdGVDb250YWluZXJDaGlsZFNldCA9ICQkJGNvbmZpZy5jcmVhdGVDb250YWluZXJDaGlsZFNldDtcbnZhciBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQgPSAkJCRjb25maWcuYXBwZW5kQ2hpbGRUb0NvbnRhaW5lckNoaWxkU2V0O1xudmFyIGZpbmFsaXplQ29udGFpbmVyQ2hpbGRyZW4gPSAkJCRjb25maWcuZmluYWxpemVDb250YWluZXJDaGlsZHJlbjtcbnZhciByZXBsYWNlQ29udGFpbmVyQ2hpbGRyZW4gPSAkJCRjb25maWcucmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuO1xudmFyIGNsb25lSGlkZGVuSW5zdGFuY2UgPSAkJCRjb25maWcuY2xvbmVIaWRkZW5JbnN0YW5jZTtcbnZhciBjbG9uZUhpZGRlblRleHRJbnN0YW5jZSA9ICQkJGNvbmZpZy5jbG9uZUhpZGRlblRleHRJbnN0YW5jZTsgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gICAgIEh5ZHJhdGlvblxuLy8gICAgIChvcHRpb25hbClcbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cblxudmFyIGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcgPSAkJCRjb25maWcuaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZztcbnZhciBpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayA9ICQkJGNvbmZpZy5pc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjaztcbnZhciBnZXRTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2tFcnJvckRldGFpbHMgPSAkJCRjb25maWcuZ2V0U3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrRXJyb3JEZXRhaWxzO1xudmFyIHJlZ2lzdGVyU3VzcGVuc2VJbnN0YW5jZVJldHJ5ID0gJCQkY29uZmlnLnJlZ2lzdGVyU3VzcGVuc2VJbnN0YW5jZVJldHJ5O1xudmFyIGNhbkh5ZHJhdGVGb3JtU3RhdGVNYXJrZXIgPSAkJCRjb25maWcuY2FuSHlkcmF0ZUZvcm1TdGF0ZU1hcmtlcjtcbnZhciBpc0Zvcm1TdGF0ZU1hcmtlck1hdGNoaW5nID0gJCQkY29uZmlnLmlzRm9ybVN0YXRlTWFya2VyTWF0Y2hpbmc7XG52YXIgZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nID0gJCQkY29uZmlnLmdldE5leHRIeWRyYXRhYmxlU2libGluZztcbnZhciBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZCA9ICQkJGNvbmZpZy5nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZDtcbnZhciBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpbkNvbnRhaW5lciA9ICQkJGNvbmZpZy5nZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpbkNvbnRhaW5lcjtcbnZhciBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblN1c3BlbnNlSW5zdGFuY2UgPSAkJCRjb25maWcuZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5TdXNwZW5zZUluc3RhbmNlO1xudmFyIGNhbkh5ZHJhdGVJbnN0YW5jZSA9ICQkJGNvbmZpZy5jYW5IeWRyYXRlSW5zdGFuY2U7XG52YXIgY2FuSHlkcmF0ZVRleHRJbnN0YW5jZSA9ICQkJGNvbmZpZy5jYW5IeWRyYXRlVGV4dEluc3RhbmNlO1xudmFyIGNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlID0gJCQkY29uZmlnLmNhbkh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlO1xudmFyIGh5ZHJhdGVJbnN0YW5jZSA9ICQkJGNvbmZpZy5oeWRyYXRlSW5zdGFuY2U7XG52YXIgaHlkcmF0ZVRleHRJbnN0YW5jZSA9ICQkJGNvbmZpZy5oeWRyYXRlVGV4dEluc3RhbmNlO1xudmFyIGh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlID0gJCQkY29uZmlnLmh5ZHJhdGVTdXNwZW5zZUluc3RhbmNlO1xudmFyIGdldE5leHRIeWRyYXRhYmxlSW5zdGFuY2VBZnRlclN1c3BlbnNlSW5zdGFuY2UgPSAkJCRjb25maWcuZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZTtcbnZhciBjb21taXRIeWRyYXRlZENvbnRhaW5lciA9ICQkJGNvbmZpZy5jb21taXRIeWRyYXRlZENvbnRhaW5lcjtcbnZhciBjb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UgPSAkJCRjb25maWcuY29tbWl0SHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlO1xudmFyIGNsZWFyU3VzcGVuc2VCb3VuZGFyeSA9ICQkJGNvbmZpZy5jbGVhclN1c3BlbnNlQm91bmRhcnk7XG52YXIgY2xlYXJTdXNwZW5zZUJvdW5kYXJ5RnJvbUNvbnRhaW5lciA9ICQkJGNvbmZpZy5jbGVhclN1c3BlbnNlQm91bmRhcnlGcm9tQ29udGFpbmVyO1xudmFyIHNob3VsZERlbGV0ZVVuaHlkcmF0ZWRUYWlsSW5zdGFuY2VzID0gJCQkY29uZmlnLnNob3VsZERlbGV0ZVVuaHlkcmF0ZWRUYWlsSW5zdGFuY2VzO1xudmFyIGRpZmZIeWRyYXRlZFByb3BzRm9yRGV2V2FybmluZ3MgPSAkJCRjb25maWcuZGlmZkh5ZHJhdGVkUHJvcHNGb3JEZXZXYXJuaW5ncztcbnZhciBkaWZmSHlkcmF0ZWRUZXh0Rm9yRGV2V2FybmluZ3MgPSAkJCRjb25maWcuZGlmZkh5ZHJhdGVkVGV4dEZvckRldldhcm5pbmdzO1xudmFyIGRlc2NyaWJlSHlkcmF0YWJsZUluc3RhbmNlRm9yRGV2V2FybmluZ3MgPSAkJCRjb25maWcuZGVzY3JpYmVIeWRyYXRhYmxlSW5zdGFuY2VGb3JEZXZXYXJuaW5ncztcbnZhciB2YWxpZGF0ZUh5ZHJhdGFibGVJbnN0YW5jZSA9ICQkJGNvbmZpZy52YWxpZGF0ZUh5ZHJhdGFibGVJbnN0YW5jZTtcbnZhciB2YWxpZGF0ZUh5ZHJhdGFibGVUZXh0SW5zdGFuY2UgPSAkJCRjb25maWcudmFsaWRhdGVIeWRyYXRhYmxlVGV4dEluc3RhbmNlOyAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAgICAgUmVzb3VyY2VzXG4vLyAgICAgKG9wdGlvbmFsKVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG52YXIgc3VwcG9ydHNSZXNvdXJjZXMgPSAkJCRjb25maWcuc3VwcG9ydHNSZXNvdXJjZXM7XG52YXIgaXNIb3N0SG9pc3RhYmxlVHlwZSA9ICQkJGNvbmZpZy5pc0hvc3RIb2lzdGFibGVUeXBlO1xudmFyIGdldEhvaXN0YWJsZVJvb3QgPSAkJCRjb25maWcuZ2V0SG9pc3RhYmxlUm9vdDtcbnZhciBnZXRSZXNvdXJjZSA9ICQkJGNvbmZpZy5nZXRSZXNvdXJjZTtcbnZhciBhY3F1aXJlUmVzb3VyY2UgPSAkJCRjb25maWcuYWNxdWlyZVJlc291cmNlO1xudmFyIHJlbGVhc2VSZXNvdXJjZSA9ICQkJGNvbmZpZy5yZWxlYXNlUmVzb3VyY2U7XG52YXIgaHlkcmF0ZUhvaXN0YWJsZSA9ICQkJGNvbmZpZy5oeWRyYXRlSG9pc3RhYmxlO1xudmFyIG1vdW50SG9pc3RhYmxlID0gJCQkY29uZmlnLm1vdW50SG9pc3RhYmxlO1xudmFyIHVubW91bnRIb2lzdGFibGUgPSAkJCRjb25maWcudW5tb3VudEhvaXN0YWJsZTtcbnZhciBjcmVhdGVIb2lzdGFibGVJbnN0YW5jZSA9ICQkJGNvbmZpZy5jcmVhdGVIb2lzdGFibGVJbnN0YW5jZTtcbnZhciBwcmVwYXJlVG9Db21taXRIb2lzdGFibGVzID0gJCQkY29uZmlnLnByZXBhcmVUb0NvbW1pdEhvaXN0YWJsZXM7XG52YXIgbWF5UmVzb3VyY2VTdXNwZW5kQ29tbWl0ID0gJCQkY29uZmlnLm1heVJlc291cmNlU3VzcGVuZENvbW1pdDtcbnZhciBwcmVsb2FkUmVzb3VyY2UgPSAkJCRjb25maWcucHJlbG9hZFJlc291cmNlO1xudmFyIHN1c3BlbmRSZXNvdXJjZSA9ICQkJGNvbmZpZy5zdXNwZW5kUmVzb3VyY2U7IC8vIC0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vICAgICBTaW5nbGV0b25zXG4vLyAgICAgKG9wdGlvbmFsKVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgc3VwcG9ydHNTaW5nbGV0b25zID0gJCQkY29uZmlnLnN1cHBvcnRzU2luZ2xldG9ucztcbnZhciByZXNvbHZlU2luZ2xldG9uSW5zdGFuY2UgPSAkJCRjb25maWcucmVzb2x2ZVNpbmdsZXRvbkluc3RhbmNlO1xudmFyIGNsZWFyU2luZ2xldG9uID0gJCQkY29uZmlnLmNsZWFyU2luZ2xldG9uO1xudmFyIGFjcXVpcmVTaW5nbGV0b25JbnN0YW5jZSA9ICQkJGNvbmZpZy5hY3F1aXJlU2luZ2xldG9uSW5zdGFuY2U7XG52YXIgcmVsZWFzZVNpbmdsZXRvbkluc3RhbmNlID0gJCQkY29uZmlnLnJlbGVhc2VTaW5nbGV0b25JbnN0YW5jZTtcbnZhciBpc0hvc3RTaW5nbGV0b25UeXBlID0gJCQkY29uZmlnLmlzSG9zdFNpbmdsZXRvblR5cGU7XG5cbnZhciB2YWx1ZVN0YWNrID0gW107XG52YXIgZmliZXJTdGFjaztcblxue1xuICBmaWJlclN0YWNrID0gW107XG59XG5cbnZhciBpbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjcmVhdGVDdXJzb3IoZGVmYXVsdFZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgY3VycmVudDogZGVmYXVsdFZhbHVlXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBvcChjdXJzb3IsIGZpYmVyKSB7XG4gIGlmIChpbmRleCA8IDApIHtcbiAgICB7XG4gICAgICBlcnJvcignVW5leHBlY3RlZCBwb3AuJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAge1xuICAgIGlmIChmaWJlciAhPT0gZmliZXJTdGFja1tpbmRleF0pIHtcbiAgICAgIGVycm9yKCdVbmV4cGVjdGVkIEZpYmVyIHBvcHBlZC4nKTtcbiAgICB9XG4gIH1cblxuICBjdXJzb3IuY3VycmVudCA9IHZhbHVlU3RhY2tbaW5kZXhdO1xuICB2YWx1ZVN0YWNrW2luZGV4XSA9IG51bGw7XG5cbiAge1xuICAgIGZpYmVyU3RhY2tbaW5kZXhdID0gbnVsbDtcbiAgfVxuXG4gIGluZGV4LS07XG59XG5cbmZ1bmN0aW9uIHB1c2goY3Vyc29yLCB2YWx1ZSwgZmliZXIpIHtcbiAgaW5kZXgrKztcbiAgdmFsdWVTdGFja1tpbmRleF0gPSBjdXJzb3IuY3VycmVudDtcblxuICB7XG4gICAgZmliZXJTdGFja1tpbmRleF0gPSBmaWJlcjtcbiAgfVxuXG4gIGN1cnNvci5jdXJyZW50ID0gdmFsdWU7XG59XG5cbnZhciBlbXB0eUNvbnRleHRPYmplY3QgPSB7fTtcblxue1xuICBPYmplY3QuZnJlZXplKGVtcHR5Q29udGV4dE9iamVjdCk7XG59IC8vIEEgY3Vyc29yIHRvIHRoZSBjdXJyZW50IG1lcmdlZCBjb250ZXh0IG9iamVjdCBvbiB0aGUgc3RhY2suXG5cbmZ1bmN0aW9uIGhhc0NvbnRleHRDaGFuZ2VkKCkge1xuICB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGlzQ29udGV4dFByb3ZpZGVyKHR5cGUpIHtcbiAge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ2hpbGRDb250ZXh0KGZpYmVyLCB0eXBlLCBwYXJlbnRDb250ZXh0KSB7XG4gIHtcbiAgICByZXR1cm4gcGFyZW50Q29udGV4dDtcbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dChmaWJlcikge1xuICB7XG4gICAgcmV0dXJuIGVtcHR5Q29udGV4dE9iamVjdDtcbiAgfVxufVxuXG4vLyBXZSB1c2UgdGhlIGV4aXN0ZW5jZSBvZiB0aGUgc3RhdGUgb2JqZWN0IGFzIGFuIGluZGljYXRvciB0aGF0IHRoZSBjb21wb25lbnRcbi8vIGlzIGhpZGRlbi5cbnZhciBPZmZzY3JlZW5WaXNpYmxlID1cbi8qICAgICAgICAgICAgICAgICAgICAgKi9cbjE7XG52YXIgT2Zmc2NyZWVuRGV0YWNoZWQgPVxuLyogICAgICAgICAgICAgICAgICAgICovXG4yO1xudmFyIE9mZnNjcmVlblBhc3NpdmVFZmZlY3RzQ29ubmVjdGVkID1cbi8qICAgICAqL1xuNDtcbmZ1bmN0aW9uIGlzT2Zmc2NyZWVuTWFudWFsKG9mZnNjcmVlbkZpYmVyKSB7XG4gIHJldHVybiBvZmZzY3JlZW5GaWJlci5tZW1vaXplZFByb3BzICE9PSBudWxsICYmIG9mZnNjcmVlbkZpYmVyLm1lbW9pemVkUHJvcHMubW9kZSA9PT0gJ21hbnVhbCc7XG59XG5cbnZhciBOb01vZGUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjA7IC8vIFRPRE86IFJlbW92ZSBDb25jdXJyZW50TW9kZSBieSByZWFkaW5nIGZyb20gdGhlIHJvb3QgdGFnIGluc3RlYWRcblxudmFyIENvbmN1cnJlbnRNb2RlID1cbi8qICAgICAgICAgICAgICAgICAqL1xuMTtcbnZhciBQcm9maWxlTW9kZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgKi9cbjI7XG52YXIgU3RyaWN0TGVnYWN5TW9kZSA9XG4vKiAgICAgICAgICAgICAgICovXG44O1xudmFyIFN0cmljdEVmZmVjdHNNb2RlID1cbi8qICAgICAgICAgICAgICAqL1xuMTY7XG52YXIgTm9TdHJpY3RQYXNzaXZlRWZmZWN0c01vZGUgPVxuLyogICAgICovXG42NDtcblxuLy8gVE9ETzogVGhpcyBpcyBwcmV0dHkgd2VsbCBzdXBwb3J0ZWQgYnkgYnJvd3NlcnMuIE1heWJlIHdlIGNhbiBkcm9wIGl0LlxudmFyIGNsejMyID0gTWF0aC5jbHozMiA/IE1hdGguY2x6MzIgOiBjbHozMkZhbGxiYWNrOyAvLyBDb3VudCBsZWFkaW5nIHplcm9zLlxuLy8gQmFzZWQgb246XG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9NYXRoL2NsejMyXG5cbnZhciBsb2ckMSA9IE1hdGgubG9nO1xudmFyIExOMiA9IE1hdGguTE4yO1xuXG5mdW5jdGlvbiBjbHozMkZhbGxiYWNrKHgpIHtcbiAgdmFyIGFzVWludCA9IHggPj4+IDA7XG5cbiAgaWYgKGFzVWludCA9PT0gMCkge1xuICAgIHJldHVybiAzMjtcbiAgfVxuXG4gIHJldHVybiAzMSAtIChsb2ckMShhc1VpbnQpIC8gTE4yIHwgMCkgfCAwO1xufVxuXG4vLyBJZiB0aG9zZSB2YWx1ZXMgYXJlIGNoYW5nZWQgdGhhdCBwYWNrYWdlIHNob3VsZCBiZSByZWJ1aWx0IGFuZCByZWRlcGxveWVkLlxuXG52YXIgVG90YWxMYW5lcyA9IDMxO1xudmFyIE5vTGFuZXMgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMDtcbnZhciBOb0xhbmUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICovXG4wO1xudmFyIFN5bmNIeWRyYXRpb25MYW5lID1cbi8qICAgICAgICAgICAgICAgKi9cbjE7XG52YXIgU3luY0xhbmUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMjtcbnZhciBTeW5jTGFuZUluZGV4ID0gMTtcbnZhciBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lID1cbi8qICAgICovXG40O1xudmFyIElucHV0Q29udGludW91c0xhbmUgPVxuLyogICAgICAgICAgICAgKi9cbjg7XG52YXIgRGVmYXVsdEh5ZHJhdGlvbkxhbmUgPVxuLyogICAgICAgICAgICAqL1xuMTY7XG52YXIgRGVmYXVsdExhbmUgPVxuLyogICAgICAgICAgICAgICAgICAgICAqL1xuMzI7XG52YXIgU3luY1VwZGF0ZUxhbmVzID0gU3luY0xhbmUgfCBJbnB1dENvbnRpbnVvdXNMYW5lIHwgRGVmYXVsdExhbmUgO1xudmFyIFRyYW5zaXRpb25IeWRyYXRpb25MYW5lID1cbi8qICAgICAgICAgICAgICAgICovXG42NDtcbnZhciBUcmFuc2l0aW9uTGFuZXMgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG40MTk0MTc2O1xudmFyIFRyYW5zaXRpb25MYW5lMSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG4xMjg7XG52YXIgVHJhbnNpdGlvbkxhbmUyID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjI1NjtcbnZhciBUcmFuc2l0aW9uTGFuZTMgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuNTEyO1xudmFyIFRyYW5zaXRpb25MYW5lNCA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG4xMDI0O1xudmFyIFRyYW5zaXRpb25MYW5lNSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG4yMDQ4O1xudmFyIFRyYW5zaXRpb25MYW5lNiA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG40MDk2O1xudmFyIFRyYW5zaXRpb25MYW5lNyA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG44MTkyO1xudmFyIFRyYW5zaXRpb25MYW5lOCA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG4xNjM4NDtcbnZhciBUcmFuc2l0aW9uTGFuZTkgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAqL1xuMzI3Njg7XG52YXIgVHJhbnNpdGlvbkxhbmUxMCA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjY1NTM2O1xudmFyIFRyYW5zaXRpb25MYW5lMTEgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG4xMzEwNzI7XG52YXIgVHJhbnNpdGlvbkxhbmUxMiA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgKi9cbjI2MjE0NDtcbnZhciBUcmFuc2l0aW9uTGFuZTEzID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAqL1xuNTI0Mjg4O1xudmFyIFRyYW5zaXRpb25MYW5lMTQgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG4xMDQ4NTc2O1xudmFyIFRyYW5zaXRpb25MYW5lMTUgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICovXG4yMDk3MTUyO1xudmFyIFJldHJ5TGFuZXMgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbjYyOTE0NTYwO1xudmFyIFJldHJ5TGFuZTEgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG40MTk0MzA0O1xudmFyIFJldHJ5TGFuZTIgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG44Mzg4NjA4O1xudmFyIFJldHJ5TGFuZTMgPVxuLyogICAgICAgICAgICAgICAgICAgICAgICAgICAgICovXG4xNjc3NzIxNjtcbnZhciBSZXRyeUxhbmU0ID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuMzM1NTQ0MzI7XG52YXIgU29tZVJldHJ5TGFuZSA9IFJldHJ5TGFuZTE7XG52YXIgU2VsZWN0aXZlSHlkcmF0aW9uTGFuZSA9XG4vKiAgICAgICAgICAqL1xuNjcxMDg4NjQ7XG52YXIgTm9uSWRsZUxhbmVzID1cbi8qICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuMTM0MjE3NzI3O1xudmFyIElkbGVIeWRyYXRpb25MYW5lID1cbi8qICAgICAgICAgICAgICAgKi9cbjEzNDIxNzcyODtcbnZhciBJZGxlTGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgICAgICovXG4yNjg0MzU0NTY7XG52YXIgT2Zmc2NyZWVuTGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAqL1xuNTM2ODcwOTEyO1xudmFyIERlZmVycmVkTGFuZSA9XG4vKiAgICAgICAgICAgICAgICAgICAgKi9cbjEwNzM3NDE4MjQ7IC8vIEFueSBsYW5lIHRoYXQgbWlnaHQgc2NoZWR1bGUgYW4gdXBkYXRlLiBUaGlzIGlzIHVzZWQgdG8gZGV0ZWN0IGluZmluaXRlXG4vLyB1cGRhdGUgbG9vcHMsIHNvIGl0IGRvZXNuJ3QgaW5jbHVkZSBoeWRyYXRpb24gbGFuZXMgb3IgcmV0cmllcy5cblxudmFyIFVwZGF0ZUxhbmVzID0gU3luY0xhbmUgfCBJbnB1dENvbnRpbnVvdXNMYW5lIHwgRGVmYXVsdExhbmUgfCBUcmFuc2l0aW9uTGFuZXM7IC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCBmb3IgdGhlIGV4cGVyaW1lbnRhbCB0aW1lbGluZSAocmVhY3QtZGV2dG9vbHMtdGltZWxpbmUpXG4vLyBJdCBzaG91bGQgYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIExhbmVzIHZhbHVlcyBhYm92ZS5cblxuZnVuY3Rpb24gZ2V0TGFiZWxGb3JMYW5lKGxhbmUpIHtcbiAge1xuICAgIGlmIChsYW5lICYgU3luY0h5ZHJhdGlvbkxhbmUpIHtcbiAgICAgIHJldHVybiAnU3luY0h5ZHJhdGlvbkxhbmUnO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgU3luY0xhbmUpIHtcbiAgICAgIHJldHVybiAnU3luYyc7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lKSB7XG4gICAgICByZXR1cm4gJ0lucHV0Q29udGludW91c0h5ZHJhdGlvbic7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBJbnB1dENvbnRpbnVvdXNMYW5lKSB7XG4gICAgICByZXR1cm4gJ0lucHV0Q29udGludW91cyc7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBEZWZhdWx0SHlkcmF0aW9uTGFuZSkge1xuICAgICAgcmV0dXJuICdEZWZhdWx0SHlkcmF0aW9uJztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIERlZmF1bHRMYW5lKSB7XG4gICAgICByZXR1cm4gJ0RlZmF1bHQnO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgVHJhbnNpdGlvbkh5ZHJhdGlvbkxhbmUpIHtcbiAgICAgIHJldHVybiAnVHJhbnNpdGlvbkh5ZHJhdGlvbic7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBUcmFuc2l0aW9uTGFuZXMpIHtcbiAgICAgIHJldHVybiAnVHJhbnNpdGlvbic7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBSZXRyeUxhbmVzKSB7XG4gICAgICByZXR1cm4gJ1JldHJ5JztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmUpIHtcbiAgICAgIHJldHVybiAnU2VsZWN0aXZlSHlkcmF0aW9uJztcbiAgICB9XG5cbiAgICBpZiAobGFuZSAmIElkbGVIeWRyYXRpb25MYW5lKSB7XG4gICAgICByZXR1cm4gJ0lkbGVIeWRyYXRpb24nO1xuICAgIH1cblxuICAgIGlmIChsYW5lICYgSWRsZUxhbmUpIHtcbiAgICAgIHJldHVybiAnSWRsZSc7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBPZmZzY3JlZW5MYW5lKSB7XG4gICAgICByZXR1cm4gJ09mZnNjcmVlbic7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgJiBEZWZlcnJlZExhbmUpIHtcbiAgICAgIHJldHVybiAnRGVmZXJyZWQnO1xuICAgIH1cbiAgfVxufVxudmFyIE5vVGltZXN0YW1wID0gLTE7XG52YXIgbmV4dFRyYW5zaXRpb25MYW5lID0gVHJhbnNpdGlvbkxhbmUxO1xudmFyIG5leHRSZXRyeUxhbmUgPSBSZXRyeUxhbmUxO1xuXG5mdW5jdGlvbiBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhsYW5lcykge1xuICB7XG4gICAgdmFyIHBlbmRpbmdTeW5jTGFuZXMgPSBsYW5lcyAmIFN5bmNVcGRhdGVMYW5lcztcblxuICAgIGlmIChwZW5kaW5nU3luY0xhbmVzICE9PSAwKSB7XG4gICAgICByZXR1cm4gcGVuZGluZ1N5bmNMYW5lcztcbiAgICB9XG4gIH1cblxuICBzd2l0Y2ggKGdldEhpZ2hlc3RQcmlvcml0eUxhbmUobGFuZXMpKSB7XG4gICAgY2FzZSBTeW5jSHlkcmF0aW9uTGFuZTpcbiAgICAgIHJldHVybiBTeW5jSHlkcmF0aW9uTGFuZTtcblxuICAgIGNhc2UgU3luY0xhbmU6XG4gICAgICByZXR1cm4gU3luY0xhbmU7XG5cbiAgICBjYXNlIElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmU6XG4gICAgICByZXR1cm4gSW5wdXRDb250aW51b3VzSHlkcmF0aW9uTGFuZTtcblxuICAgIGNhc2UgSW5wdXRDb250aW51b3VzTGFuZTpcbiAgICAgIHJldHVybiBJbnB1dENvbnRpbnVvdXNMYW5lO1xuXG4gICAgY2FzZSBEZWZhdWx0SHlkcmF0aW9uTGFuZTpcbiAgICAgIHJldHVybiBEZWZhdWx0SHlkcmF0aW9uTGFuZTtcblxuICAgIGNhc2UgRGVmYXVsdExhbmU6XG4gICAgICByZXR1cm4gRGVmYXVsdExhbmU7XG5cbiAgICBjYXNlIFRyYW5zaXRpb25IeWRyYXRpb25MYW5lOlxuICAgICAgcmV0dXJuIFRyYW5zaXRpb25IeWRyYXRpb25MYW5lO1xuXG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTI6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTM6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTQ6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTU6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTY6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTc6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTg6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTk6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTEwOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMTpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTI6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTEzOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxNDpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTU6XG4gICAgICByZXR1cm4gbGFuZXMgJiBUcmFuc2l0aW9uTGFuZXM7XG5cbiAgICBjYXNlIFJldHJ5TGFuZTE6XG4gICAgY2FzZSBSZXRyeUxhbmUyOlxuICAgIGNhc2UgUmV0cnlMYW5lMzpcbiAgICBjYXNlIFJldHJ5TGFuZTQ6XG4gICAgICByZXR1cm4gbGFuZXMgJiBSZXRyeUxhbmVzO1xuXG4gICAgY2FzZSBTZWxlY3RpdmVIeWRyYXRpb25MYW5lOlxuICAgICAgcmV0dXJuIFNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmU7XG5cbiAgICBjYXNlIElkbGVIeWRyYXRpb25MYW5lOlxuICAgICAgcmV0dXJuIElkbGVIeWRyYXRpb25MYW5lO1xuXG4gICAgY2FzZSBJZGxlTGFuZTpcbiAgICAgIHJldHVybiBJZGxlTGFuZTtcblxuICAgIGNhc2UgT2Zmc2NyZWVuTGFuZTpcbiAgICAgIHJldHVybiBPZmZzY3JlZW5MYW5lO1xuXG4gICAgY2FzZSBEZWZlcnJlZExhbmU6XG4gICAgICAvLyBUaGlzIHNob3VsZG4ndCBiZSByZWFjaGFibGUgYmVjYXVzZSBkZWZlcnJlZCB3b3JrIGlzIGFsd2F5cyBlbnRhbmdsZWRcbiAgICAgIC8vIHdpdGggc29tZXRoaW5nIGVsc2UuXG4gICAgICByZXR1cm4gTm9MYW5lcztcblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIGVycm9yKCdTaG91bGQgaGF2ZSBmb3VuZCBtYXRjaGluZyBsYW5lcy4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH0gLy8gVGhpcyBzaG91bGRuJ3QgYmUgcmVhY2hhYmxlLCBidXQgYXMgYSBmYWxsYmFjaywgcmV0dXJuIHRoZSBlbnRpcmUgYml0bWFzay5cblxuXG4gICAgICByZXR1cm4gbGFuZXM7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0TmV4dExhbmVzKHJvb3QsIHdpcExhbmVzKSB7XG4gIC8vIEVhcmx5IGJhaWxvdXQgaWYgdGhlcmUncyBubyBwZW5kaW5nIHdvcmsgbGVmdC5cbiAgdmFyIHBlbmRpbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzO1xuXG4gIGlmIChwZW5kaW5nTGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICByZXR1cm4gTm9MYW5lcztcbiAgfVxuXG4gIHZhciBuZXh0TGFuZXMgPSBOb0xhbmVzO1xuICB2YXIgc3VzcGVuZGVkTGFuZXMgPSByb290LnN1c3BlbmRlZExhbmVzO1xuICB2YXIgcGluZ2VkTGFuZXMgPSByb290LnBpbmdlZExhbmVzOyAvLyBEbyBub3Qgd29yayBvbiBhbnkgaWRsZSB3b3JrIHVudGlsIGFsbCB0aGUgbm9uLWlkbGUgd29yayBoYXMgZmluaXNoZWQsXG4gIC8vIGV2ZW4gaWYgdGhlIHdvcmsgaXMgc3VzcGVuZGVkLlxuXG4gIHZhciBub25JZGxlUGVuZGluZ0xhbmVzID0gcGVuZGluZ0xhbmVzICYgTm9uSWRsZUxhbmVzO1xuXG4gIGlmIChub25JZGxlUGVuZGluZ0xhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgdmFyIG5vbklkbGVVbmJsb2NrZWRMYW5lcyA9IG5vbklkbGVQZW5kaW5nTGFuZXMgJiB+c3VzcGVuZGVkTGFuZXM7XG5cbiAgICBpZiAobm9uSWRsZVVuYmxvY2tlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICBuZXh0TGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhub25JZGxlVW5ibG9ja2VkTGFuZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgbm9uSWRsZVBpbmdlZExhbmVzID0gbm9uSWRsZVBlbmRpbmdMYW5lcyAmIHBpbmdlZExhbmVzO1xuXG4gICAgICBpZiAobm9uSWRsZVBpbmdlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICAgIG5leHRMYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmVzKG5vbklkbGVQaW5nZWRMYW5lcyk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRoZSBvbmx5IHJlbWFpbmluZyB3b3JrIGlzIElkbGUuXG4gICAgdmFyIHVuYmxvY2tlZExhbmVzID0gcGVuZGluZ0xhbmVzICYgfnN1c3BlbmRlZExhbmVzO1xuXG4gICAgaWYgKHVuYmxvY2tlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICBuZXh0TGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyh1bmJsb2NrZWRMYW5lcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwaW5nZWRMYW5lcyAhPT0gTm9MYW5lcykge1xuICAgICAgICBuZXh0TGFuZXMgPSBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhwaW5nZWRMYW5lcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKG5leHRMYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIC8vIFRoaXMgc2hvdWxkIG9ubHkgYmUgcmVhY2hhYmxlIGlmIHdlJ3JlIHN1c3BlbmRlZFxuICAgIC8vIFRPRE86IENvbnNpZGVyIHdhcm5pbmcgaW4gdGhpcyBwYXRoIGlmIGEgZmFsbGJhY2sgdGltZXIgaXMgbm90IHNjaGVkdWxlZC5cbiAgICByZXR1cm4gTm9MYW5lcztcbiAgfSAvLyBJZiB3ZSdyZSBhbHJlYWR5IGluIHRoZSBtaWRkbGUgb2YgYSByZW5kZXIsIHN3aXRjaGluZyBsYW5lcyB3aWxsIGludGVycnVwdFxuICAvLyBpdCBhbmQgd2UnbGwgbG9zZSBvdXIgcHJvZ3Jlc3MuIFdlIHNob3VsZCBvbmx5IGRvIHRoaXMgaWYgdGhlIG5ldyBsYW5lcyBhcmVcbiAgLy8gaGlnaGVyIHByaW9yaXR5LlxuXG5cbiAgaWYgKHdpcExhbmVzICE9PSBOb0xhbmVzICYmIHdpcExhbmVzICE9PSBuZXh0TGFuZXMgJiYgLy8gSWYgd2UgYWxyZWFkeSBzdXNwZW5kZWQgd2l0aCBhIGRlbGF5LCB0aGVuIGludGVycnVwdGluZyBpcyBmaW5lLiBEb24ndFxuICAvLyBib3RoZXIgd2FpdGluZyB1bnRpbCB0aGUgcm9vdCBpcyBjb21wbGV0ZS5cbiAgKHdpcExhbmVzICYgc3VzcGVuZGVkTGFuZXMpID09PSBOb0xhbmVzKSB7XG4gICAgdmFyIG5leHRMYW5lID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZShuZXh0TGFuZXMpO1xuICAgIHZhciB3aXBMYW5lID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZSh3aXBMYW5lcyk7XG5cbiAgICBpZiAoIC8vIFRlc3RzIHdoZXRoZXIgdGhlIG5leHQgbGFuZSBpcyBlcXVhbCBvciBsb3dlciBwcmlvcml0eSB0aGFuIHRoZSB3aXBcbiAgICAvLyBvbmUuIFRoaXMgd29ya3MgYmVjYXVzZSB0aGUgYml0cyBkZWNyZWFzZSBpbiBwcmlvcml0eSBhcyB5b3UgZ28gbGVmdC5cbiAgICBuZXh0TGFuZSA+PSB3aXBMYW5lIHx8IC8vIERlZmF1bHQgcHJpb3JpdHkgdXBkYXRlcyBzaG91bGQgbm90IGludGVycnVwdCB0cmFuc2l0aW9uIHVwZGF0ZXMuIFRoZVxuICAgIC8vIG9ubHkgZGlmZmVyZW5jZSBiZXR3ZWVuIGRlZmF1bHQgdXBkYXRlcyBhbmQgdHJhbnNpdGlvbiB1cGRhdGVzIGlzIHRoYXRcbiAgICAvLyBkZWZhdWx0IHVwZGF0ZXMgZG8gbm90IHN1cHBvcnQgcmVmcmVzaCB0cmFuc2l0aW9ucy5cbiAgICBuZXh0TGFuZSA9PT0gRGVmYXVsdExhbmUgJiYgKHdpcExhbmUgJiBUcmFuc2l0aW9uTGFuZXMpICE9PSBOb0xhbmVzKSB7XG4gICAgICAvLyBLZWVwIHdvcmtpbmcgb24gdGhlIGV4aXN0aW5nIGluLXByb2dyZXNzIHRyZWUuIERvIG5vdCBpbnRlcnJ1cHQuXG4gICAgICByZXR1cm4gd2lwTGFuZXM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5leHRMYW5lcztcbn1cbmZ1bmN0aW9uIGdldEVudGFuZ2xlZExhbmVzKHJvb3QsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBlbnRhbmdsZWRMYW5lcyA9IHJlbmRlckxhbmVzO1xuXG4gIGlmICgoZW50YW5nbGVkTGFuZXMgJiBJbnB1dENvbnRpbnVvdXNMYW5lKSAhPT0gTm9MYW5lcykge1xuICAgIC8vIFdoZW4gdXBkYXRlcyBhcmUgc3luYyBieSBkZWZhdWx0LCB3ZSBlbnRhbmdsZSBjb250aW51b3VzIHByaW9yaXR5IHVwZGF0ZXNcbiAgICAvLyBhbmQgZGVmYXVsdCB1cGRhdGVzLCBzbyB0aGV5IHJlbmRlciBpbiB0aGUgc2FtZSBiYXRjaC4gVGhlIG9ubHkgcmVhc29uXG4gICAgLy8gdGhleSB1c2Ugc2VwYXJhdGUgbGFuZXMgaXMgYmVjYXVzZSBjb250aW51b3VzIHVwZGF0ZXMgc2hvdWxkIGludGVycnVwdFxuICAgIC8vIHRyYW5zaXRpb25zLCBidXQgZGVmYXVsdCB1cGRhdGVzIHNob3VsZCBub3QuXG4gICAgZW50YW5nbGVkTGFuZXMgfD0gZW50YW5nbGVkTGFuZXMgJiBEZWZhdWx0TGFuZTtcbiAgfSAvLyBDaGVjayBmb3IgZW50YW5nbGVkIGxhbmVzIGFuZCBhZGQgdGhlbSB0byB0aGUgYmF0Y2guXG4gIC8vXG4gIC8vIEEgbGFuZSBpcyBzYWlkIHRvIGJlIGVudGFuZ2xlZCB3aXRoIGFub3RoZXIgd2hlbiBpdCdzIG5vdCBhbGxvd2VkIHRvIHJlbmRlclxuICAvLyBpbiBhIGJhdGNoIHRoYXQgZG9lcyBub3QgYWxzbyBpbmNsdWRlIHRoZSBvdGhlciBsYW5lLiBUeXBpY2FsbHkgd2UgZG8gdGhpc1xuICAvLyB3aGVuIG11bHRpcGxlIHVwZGF0ZXMgaGF2ZSB0aGUgc2FtZSBzb3VyY2UsIGFuZCB3ZSBvbmx5IHdhbnQgdG8gcmVzcG9uZCB0b1xuICAvLyB0aGUgbW9zdCByZWNlbnQgZXZlbnQgZnJvbSB0aGF0IHNvdXJjZS5cbiAgLy9cbiAgLy8gTm90ZSB0aGF0IHdlIGFwcGx5IGVudGFuZ2xlbWVudHMgKmFmdGVyKiBjaGVja2luZyBmb3IgcGFydGlhbCB3b3JrIGFib3ZlLlxuICAvLyBUaGlzIG1lYW5zIHRoYXQgaWYgYSBsYW5lIGlzIGVudGFuZ2xlZCBkdXJpbmcgYW4gaW50ZXJsZWF2ZWQgZXZlbnQgd2hpbGVcbiAgLy8gaXQncyBhbHJlYWR5IHJlbmRlcmluZywgd2Ugd29uJ3QgaW50ZXJydXB0IGl0LiBUaGlzIGlzIGludGVudGlvbmFsLCBzaW5jZVxuICAvLyBlbnRhbmdsZW1lbnQgaXMgdXN1YWxseSBcImJlc3QgZWZmb3J0XCI6IHdlJ2xsIHRyeSBvdXIgYmVzdCB0byByZW5kZXIgdGhlXG4gIC8vIGxhbmVzIGluIHRoZSBzYW1lIGJhdGNoLCBidXQgaXQncyBub3Qgd29ydGggdGhyb3dpbmcgb3V0IHBhcnRpYWxseVxuICAvLyBjb21wbGV0ZWQgd29yayBpbiBvcmRlciB0byBkbyBpdC5cbiAgLy8gVE9ETzogUmVjb25zaWRlciB0aGlzLiBUaGUgY291bnRlci1hcmd1bWVudCBpcyB0aGF0IHRoZSBwYXJ0aWFsIHdvcmtcbiAgLy8gcmVwcmVzZW50cyBhbiBpbnRlcm1lZGlhdGUgc3RhdGUsIHdoaWNoIHdlIGRvbid0IHdhbnQgdG8gc2hvdyB0byB0aGUgdXNlci5cbiAgLy8gQW5kIGJ5IHNwZW5kaW5nIGV4dHJhIHRpbWUgZmluaXNoaW5nIGl0LCB3ZSdyZSBpbmNyZWFzaW5nIHRoZSBhbW91bnQgb2ZcbiAgLy8gdGltZSBpdCB0YWtlcyB0byBzaG93IHRoZSBmaW5hbCBzdGF0ZSwgd2hpY2ggaXMgd2hhdCB0aGV5IGFyZSBhY3R1YWxseVxuICAvLyB3YWl0aW5nIGZvci5cbiAgLy9cbiAgLy8gRm9yIHRob3NlIGV4Y2VwdGlvbnMgd2hlcmUgZW50YW5nbGVtZW50IGlzIHNlbWFudGljYWxseSBpbXBvcnRhbnQsXG4gIC8vIHdlIHNob3VsZCBlbnN1cmUgdGhhdCB0aGVyZSBpcyBubyBwYXJ0aWFsIHdvcmsgYXQgdGhlXG4gIC8vIHRpbWUgd2UgYXBwbHkgdGhlIGVudGFuZ2xlbWVudC5cblxuXG4gIHZhciBhbGxFbnRhbmdsZWRMYW5lcyA9IHJvb3QuZW50YW5nbGVkTGFuZXM7XG5cbiAgaWYgKGFsbEVudGFuZ2xlZExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgdmFyIGVudGFuZ2xlbWVudHMgPSByb290LmVudGFuZ2xlbWVudHM7XG4gICAgdmFyIGxhbmVzID0gZW50YW5nbGVkTGFuZXMgJiBhbGxFbnRhbmdsZWRMYW5lcztcblxuICAgIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICAgIHZhciBpbmRleCA9IHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO1xuICAgICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuICAgICAgZW50YW5nbGVkTGFuZXMgfD0gZW50YW5nbGVtZW50c1tpbmRleF07XG4gICAgICBsYW5lcyAmPSB+bGFuZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZW50YW5nbGVkTGFuZXM7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVFeHBpcmF0aW9uVGltZShsYW5lLCBjdXJyZW50VGltZSkge1xuICBzd2l0Y2ggKGxhbmUpIHtcbiAgICBjYXNlIFN5bmNIeWRyYXRpb25MYW5lOlxuICAgIGNhc2UgU3luY0xhbmU6XG4gICAgY2FzZSBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lOlxuICAgIGNhc2UgSW5wdXRDb250aW51b3VzTGFuZTpcbiAgICAgIC8vIFVzZXIgaW50ZXJhY3Rpb25zIHNob3VsZCBleHBpcmUgc2xpZ2h0bHkgbW9yZSBxdWlja2x5LlxuICAgICAgLy9cbiAgICAgIC8vIE5PVEU6IFRoaXMgaXMgc2V0IHRvIHRoZSBjb3JyZXNwb25kaW5nIGNvbnN0YW50IGFzIGluIFNjaGVkdWxlci5qcy5cbiAgICAgIC8vIFdoZW4gd2UgbWFkZSBpdCBsYXJnZXIsIGEgcHJvZHVjdCBtZXRyaWMgaW4gd3d3IHJlZ3Jlc3NlZCwgc3VnZ2VzdGluZ1xuICAgICAgLy8gdGhlcmUncyBhIHVzZXIgaW50ZXJhY3Rpb24gdGhhdCdzIGJlaW5nIHN0YXJ2ZWQgYnkgYSBzZXJpZXMgb2ZcbiAgICAgIC8vIHN5bmNocm9ub3VzIHVwZGF0ZXMuIElmIHRoYXQgdGhlb3J5IGlzIGNvcnJlY3QsIHRoZSBwcm9wZXIgc29sdXRpb24gaXNcbiAgICAgIC8vIHRvIGZpeCB0aGUgc3RhcnZhdGlvbi4gSG93ZXZlciwgdGhpcyBzY2VuYXJpbyBzdXBwb3J0cyB0aGUgaWRlYSB0aGF0XG4gICAgICAvLyBleHBpcmF0aW9uIHRpbWVzIGFyZSBhbiBpbXBvcnRhbnQgc2FmZWd1YXJkIHdoZW4gc3RhcnZhdGlvblxuICAgICAgLy8gZG9lcyBoYXBwZW4uXG4gICAgICByZXR1cm4gY3VycmVudFRpbWUgKyBzeW5jTGFuZUV4cGlyYXRpb25NcztcblxuICAgIGNhc2UgRGVmYXVsdEh5ZHJhdGlvbkxhbmU6XG4gICAgY2FzZSBEZWZhdWx0TGFuZTpcbiAgICBjYXNlIFRyYW5zaXRpb25IeWRyYXRpb25MYW5lOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUyOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUzOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU0OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU1OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU2OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU3OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU4OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU5OlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMDpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTE6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTEyOlxuICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUxMzpcbiAgICBjYXNlIFRyYW5zaXRpb25MYW5lMTQ6XG4gICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE1OlxuICAgICAgcmV0dXJuIGN1cnJlbnRUaW1lICsgdHJhbnNpdGlvbkxhbmVFeHBpcmF0aW9uTXM7XG5cbiAgICBjYXNlIFJldHJ5TGFuZTE6XG4gICAgY2FzZSBSZXRyeUxhbmUyOlxuICAgIGNhc2UgUmV0cnlMYW5lMzpcbiAgICBjYXNlIFJldHJ5TGFuZTQ6XG4gICAgICAvLyBUT0RPOiBSZXRyaWVzIHNob3VsZCBiZSBhbGxvd2VkIHRvIGV4cGlyZSBpZiB0aGV5IGFyZSBDUFUgYm91bmQgZm9yXG4gICAgICAvLyB0b28gbG9uZywgYnV0IHdoZW4gSSBtYWRlIHRoaXMgY2hhbmdlIGl0IGNhdXNlZCBhIHNwaWtlIGluIGJyb3dzZXJcbiAgICAgIC8vIGNyYXNoZXMuIFRoZXJlIG11c3QgYmUgc29tZSBvdGhlciB1bmRlcmx5aW5nIGJ1Zzsgbm90IHN1cGVyIHVyZ2VudCBidXRcbiAgICAgIC8vIGlkZWFsbHkgc2hvdWxkIGZpZ3VyZSBvdXQgd2h5IGFuZCBmaXggaXQuIFVuZm9ydHVuYXRlbHkgd2UgZG9uJ3QgaGF2ZVxuICAgICAgLy8gYSByZXBybyBmb3IgdGhlIGNyYXNoZXMsIG9ubHkgZGV0ZWN0ZWQgdmlhIHByb2R1Y3Rpb24gbWV0cmljcy5cbiAgICAgIHJldHVybiBOb1RpbWVzdGFtcDtcblxuICAgIGNhc2UgU2VsZWN0aXZlSHlkcmF0aW9uTGFuZTpcbiAgICBjYXNlIElkbGVIeWRyYXRpb25MYW5lOlxuICAgIGNhc2UgSWRsZUxhbmU6XG4gICAgY2FzZSBPZmZzY3JlZW5MYW5lOlxuICAgIGNhc2UgRGVmZXJyZWRMYW5lOlxuICAgICAgLy8gQW55dGhpbmcgaWRsZSBwcmlvcml0eSBvciBsb3dlciBzaG91bGQgbmV2ZXIgZXhwaXJlLlxuICAgICAgcmV0dXJuIE5vVGltZXN0YW1wO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgZXJyb3IoJ1Nob3VsZCBoYXZlIGZvdW5kIG1hdGNoaW5nIGxhbmVzLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gTm9UaW1lc3RhbXA7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXJ2ZWRMYW5lc0FzRXhwaXJlZChyb290LCBjdXJyZW50VGltZSkge1xuICAvLyBUT0RPOiBUaGlzIGdldHMgY2FsbGVkIGV2ZXJ5IHRpbWUgd2UgeWllbGQuIFdlIGNhbiBvcHRpbWl6ZSBieSBzdG9yaW5nXG4gIC8vIHRoZSBlYXJsaWVzdCBleHBpcmF0aW9uIHRpbWUgb24gdGhlIHJvb3QuIFRoZW4gdXNlIHRoYXQgdG8gcXVpY2tseSBiYWlsIG91dFxuICAvLyBvZiB0aGlzIGZ1bmN0aW9uLlxuICB2YXIgcGVuZGluZ0xhbmVzID0gcm9vdC5wZW5kaW5nTGFuZXM7XG4gIHZhciBzdXNwZW5kZWRMYW5lcyA9IHJvb3Quc3VzcGVuZGVkTGFuZXM7XG4gIHZhciBwaW5nZWRMYW5lcyA9IHJvb3QucGluZ2VkTGFuZXM7XG4gIHZhciBleHBpcmF0aW9uVGltZXMgPSByb290LmV4cGlyYXRpb25UaW1lczsgLy8gSXRlcmF0ZSB0aHJvdWdoIHRoZSBwZW5kaW5nIGxhbmVzIGFuZCBjaGVjayBpZiB3ZSd2ZSByZWFjaGVkIHRoZWlyXG4gIC8vIGV4cGlyYXRpb24gdGltZS4gSWYgc28sIHdlJ2xsIGFzc3VtZSB0aGUgdXBkYXRlIGlzIGJlaW5nIHN0YXJ2ZWQgYW5kIG1hcmtcbiAgLy8gaXQgYXMgZXhwaXJlZCB0byBmb3JjZSBpdCB0byBmaW5pc2guXG4gIC8vIFRPRE86IFdlIHNob3VsZCBiZSBhYmxlIHRvIHJlcGxhY2UgdGhpcyB3aXRoIHVwZ3JhZGVQZW5kaW5nTGFuZXNUb1N5bmNcbiAgLy9cbiAgLy8gV2UgZXhjbHVkZSByZXRyeSBsYW5lcyBiZWNhdXNlIHRob3NlIG11c3QgYWx3YXlzIGJlIHRpbWUgc2xpY2VkLCBpbiBvcmRlclxuICAvLyB0byB1bndyYXAgdW5jYWNoZWQgcHJvbWlzZXMuXG4gIC8vIFRPRE86IFdyaXRlIGEgdGVzdCBmb3IgdGhpc1xuXG4gIHZhciBsYW5lcyA9IHBlbmRpbmdMYW5lcyAmIH5SZXRyeUxhbmVzO1xuXG4gIHdoaWxlIChsYW5lcyA+IDApIHtcbiAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgdmFyIGV4cGlyYXRpb25UaW1lID0gZXhwaXJhdGlvblRpbWVzW2luZGV4XTtcblxuICAgIGlmIChleHBpcmF0aW9uVGltZSA9PT0gTm9UaW1lc3RhbXApIHtcbiAgICAgIC8vIEZvdW5kIGEgcGVuZGluZyBsYW5lIHdpdGggbm8gZXhwaXJhdGlvbiB0aW1lLiBJZiBpdCdzIG5vdCBzdXNwZW5kZWQsIG9yXG4gICAgICAvLyBpZiBpdCdzIHBpbmdlZCwgYXNzdW1lIGl0J3MgQ1BVLWJvdW5kLiBDb21wdXRlIGEgbmV3IGV4cGlyYXRpb24gdGltZVxuICAgICAgLy8gdXNpbmcgdGhlIGN1cnJlbnQgdGltZS5cbiAgICAgIGlmICgobGFuZSAmIHN1c3BlbmRlZExhbmVzKSA9PT0gTm9MYW5lcyB8fCAobGFuZSAmIHBpbmdlZExhbmVzKSAhPT0gTm9MYW5lcykge1xuICAgICAgICAvLyBBc3N1bWVzIHRpbWVzdGFtcHMgYXJlIG1vbm90b25pY2FsbHkgaW5jcmVhc2luZy5cbiAgICAgICAgZXhwaXJhdGlvblRpbWVzW2luZGV4XSA9IGNvbXB1dGVFeHBpcmF0aW9uVGltZShsYW5lLCBjdXJyZW50VGltZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChleHBpcmF0aW9uVGltZSA8PSBjdXJyZW50VGltZSkge1xuICAgICAgLy8gVGhpcyBsYW5lIGV4cGlyZWRcbiAgICAgIHJvb3QuZXhwaXJlZExhbmVzIHw9IGxhbmU7XG4gICAgfVxuXG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cbn0gLy8gVGhpcyByZXR1cm5zIHRoZSBoaWdoZXN0IHByaW9yaXR5IHBlbmRpbmcgbGFuZXMgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHRoZXlcbi8vIGFyZSBzdXNwZW5kZWQuXG5cbmZ1bmN0aW9uIGdldEhpZ2hlc3RQcmlvcml0eVBlbmRpbmdMYW5lcyhyb290KSB7XG4gIHJldHVybiBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lcyhyb290LnBlbmRpbmdMYW5lcyk7XG59XG5mdW5jdGlvbiBnZXRMYW5lc1RvUmV0cnlTeW5jaHJvbm91c2x5T25FcnJvcihyb290LCBvcmlnaW5hbGx5QXR0ZW1wdGVkTGFuZXMpIHtcbiAgaWYgKHJvb3QuZXJyb3JSZWNvdmVyeURpc2FibGVkTGFuZXMgJiBvcmlnaW5hbGx5QXR0ZW1wdGVkTGFuZXMpIHtcbiAgICAvLyBUaGUgZXJyb3IgcmVjb3ZlcnkgbWVjaGFuaXNtIGlzIGRpc2FibGVkIHVudGlsIHRoZXNlIGxhbmVzIGFyZSBjbGVhcmVkLlxuICAgIHJldHVybiBOb0xhbmVzO1xuICB9XG5cbiAgdmFyIGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW4gPSByb290LnBlbmRpbmdMYW5lcyAmIH5PZmZzY3JlZW5MYW5lO1xuXG4gIGlmIChldmVyeXRoaW5nQnV0T2Zmc2NyZWVuICE9PSBOb0xhbmVzKSB7XG4gICAgcmV0dXJuIGV2ZXJ5dGhpbmdCdXRPZmZzY3JlZW47XG4gIH1cblxuICBpZiAoZXZlcnl0aGluZ0J1dE9mZnNjcmVlbiAmIE9mZnNjcmVlbkxhbmUpIHtcbiAgICByZXR1cm4gT2Zmc2NyZWVuTGFuZTtcbiAgfVxuXG4gIHJldHVybiBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNTeW5jTGFuZShsYW5lcykge1xuICByZXR1cm4gKGxhbmVzICYgKFN5bmNMYW5lIHwgU3luY0h5ZHJhdGlvbkxhbmUpKSAhPT0gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGluY2x1ZGVzTm9uSWRsZVdvcmsobGFuZXMpIHtcbiAgcmV0dXJuIChsYW5lcyAmIE5vbklkbGVMYW5lcykgIT09IE5vTGFuZXM7XG59XG5mdW5jdGlvbiBpbmNsdWRlc09ubHlSZXRyaWVzKGxhbmVzKSB7XG4gIHJldHVybiAobGFuZXMgJiBSZXRyeUxhbmVzKSA9PT0gbGFuZXM7XG59XG5mdW5jdGlvbiBpbmNsdWRlc09ubHlOb25VcmdlbnRMYW5lcyhsYW5lcykge1xuICAvLyBUT0RPOiBTaG91bGQgaHlkcmF0aW9uIGxhbmVzIGJlIGluY2x1ZGVkIGhlcmU/IFRoaXMgZnVuY3Rpb24gaXMgb25seVxuICAvLyB1c2VkIGluIGB1cGRhdGVEZWZlcnJlZFZhbHVlSW1wbGAuXG4gIHZhciBVcmdlbnRMYW5lcyA9IFN5bmNMYW5lIHwgSW5wdXRDb250aW51b3VzTGFuZSB8IERlZmF1bHRMYW5lO1xuICByZXR1cm4gKGxhbmVzICYgVXJnZW50TGFuZXMpID09PSBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNPbmx5VHJhbnNpdGlvbnMobGFuZXMpIHtcbiAgcmV0dXJuIChsYW5lcyAmIFRyYW5zaXRpb25MYW5lcykgPT09IGxhbmVzO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNCbG9ja2luZ0xhbmUocm9vdCwgbGFuZXMpIHtcblxuICB2YXIgU3luY0RlZmF1bHRMYW5lcyA9IElucHV0Q29udGludW91c0h5ZHJhdGlvbkxhbmUgfCBJbnB1dENvbnRpbnVvdXNMYW5lIHwgRGVmYXVsdEh5ZHJhdGlvbkxhbmUgfCBEZWZhdWx0TGFuZTtcbiAgcmV0dXJuIChsYW5lcyAmIFN5bmNEZWZhdWx0TGFuZXMpICE9PSBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaW5jbHVkZXNFeHBpcmVkTGFuZShyb290LCBsYW5lcykge1xuICAvLyBUaGlzIGlzIGEgc2VwYXJhdGUgY2hlY2sgZnJvbSBpbmNsdWRlc0Jsb2NraW5nTGFuZSBiZWNhdXNlIGEgbGFuZSBjYW5cbiAgLy8gZXhwaXJlIGFmdGVyIGEgcmVuZGVyIGhhcyBhbHJlYWR5IHN0YXJ0ZWQuXG4gIHJldHVybiAobGFuZXMgJiByb290LmV4cGlyZWRMYW5lcykgIT09IE5vTGFuZXM7XG59XG5mdW5jdGlvbiBpc1RyYW5zaXRpb25MYW5lKGxhbmUpIHtcbiAgcmV0dXJuIChsYW5lICYgVHJhbnNpdGlvbkxhbmVzKSAhPT0gTm9MYW5lcztcbn1cbmZ1bmN0aW9uIGNsYWltTmV4dFRyYW5zaXRpb25MYW5lKCkge1xuICAvLyBDeWNsZSB0aHJvdWdoIHRoZSBsYW5lcywgYXNzaWduaW5nIGVhY2ggbmV3IHRyYW5zaXRpb24gdG8gdGhlIG5leHQgbGFuZS5cbiAgLy8gSW4gbW9zdCBjYXNlcywgdGhpcyBtZWFucyBldmVyeSB0cmFuc2l0aW9uIGdldHMgaXRzIG93biBsYW5lLCB1bnRpbCB3ZVxuICAvLyBydW4gb3V0IG9mIGxhbmVzIGFuZCBjeWNsZSBiYWNrIHRvIHRoZSBiZWdpbm5pbmcuXG4gIHZhciBsYW5lID0gbmV4dFRyYW5zaXRpb25MYW5lO1xuICBuZXh0VHJhbnNpdGlvbkxhbmUgPDw9IDE7XG5cbiAgaWYgKChuZXh0VHJhbnNpdGlvbkxhbmUgJiBUcmFuc2l0aW9uTGFuZXMpID09PSBOb0xhbmVzKSB7XG4gICAgbmV4dFRyYW5zaXRpb25MYW5lID0gVHJhbnNpdGlvbkxhbmUxO1xuICB9XG5cbiAgcmV0dXJuIGxhbmU7XG59XG5mdW5jdGlvbiBjbGFpbU5leHRSZXRyeUxhbmUoKSB7XG4gIHZhciBsYW5lID0gbmV4dFJldHJ5TGFuZTtcbiAgbmV4dFJldHJ5TGFuZSA8PD0gMTtcblxuICBpZiAoKG5leHRSZXRyeUxhbmUgJiBSZXRyeUxhbmVzKSA9PT0gTm9MYW5lcykge1xuICAgIG5leHRSZXRyeUxhbmUgPSBSZXRyeUxhbmUxO1xuICB9XG5cbiAgcmV0dXJuIGxhbmU7XG59XG5mdW5jdGlvbiBnZXRIaWdoZXN0UHJpb3JpdHlMYW5lKGxhbmVzKSB7XG4gIHJldHVybiBsYW5lcyAmIC1sYW5lcztcbn1cbmZ1bmN0aW9uIHBpY2tBcmJpdHJhcnlMYW5lKGxhbmVzKSB7XG4gIC8vIFRoaXMgd3JhcHBlciBmdW5jdGlvbiBnZXRzIGlubGluZWQuIE9ubHkgZXhpc3RzIHNvIHRvIGNvbW11bmljYXRlIHRoYXQgaXRcbiAgLy8gZG9lc24ndCBtYXR0ZXIgd2hpY2ggYml0IGlzIHNlbGVjdGVkOyB5b3UgY2FuIHBpY2sgYW55IGJpdCB3aXRob3V0XG4gIC8vIGFmZmVjdGluZyB0aGUgYWxnb3JpdGhtcyB3aGVyZSBpdHMgdXNlZC4gSGVyZSBJJ20gdXNpbmdcbiAgLy8gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZSBiZWNhdXNlIGl0IHJlcXVpcmVzIHRoZSBmZXdlc3Qgb3BlcmF0aW9ucy5cbiAgcmV0dXJuIGdldEhpZ2hlc3RQcmlvcml0eUxhbmUobGFuZXMpO1xufVxuXG5mdW5jdGlvbiBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKSB7XG4gIHJldHVybiAzMSAtIGNsejMyKGxhbmVzKTtcbn1cblxuZnVuY3Rpb24gbGFuZVRvSW5kZXgobGFuZSkge1xuICByZXR1cm4gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lKTtcbn1cblxuZnVuY3Rpb24gaW5jbHVkZXNTb21lTGFuZShhLCBiKSB7XG4gIHJldHVybiAoYSAmIGIpICE9PSBOb0xhbmVzO1xufVxuZnVuY3Rpb24gaXNTdWJzZXRPZkxhbmVzKHNldCwgc3Vic2V0KSB7XG4gIHJldHVybiAoc2V0ICYgc3Vic2V0KSA9PT0gc3Vic2V0O1xufVxuZnVuY3Rpb24gbWVyZ2VMYW5lcyhhLCBiKSB7XG4gIHJldHVybiBhIHwgYjtcbn1cbmZ1bmN0aW9uIHJlbW92ZUxhbmVzKHNldCwgc3Vic2V0KSB7XG4gIHJldHVybiBzZXQgJiB+c3Vic2V0O1xufVxuZnVuY3Rpb24gaW50ZXJzZWN0TGFuZXMoYSwgYikge1xuICByZXR1cm4gYSAmIGI7XG59IC8vIFNlZW1zIHJlZHVuZGFudCwgYnV0IGl0IGNoYW5nZXMgdGhlIHR5cGUgZnJvbSBhIHNpbmdsZSBsYW5lICh1c2VkIGZvclxuLy8gdXBkYXRlcykgdG8gYSBncm91cCBvZiBsYW5lcyAodXNlZCBmb3IgZmx1c2hpbmcgd29yaykuXG5cbmZ1bmN0aW9uIGxhbmVUb0xhbmVzKGxhbmUpIHtcbiAgcmV0dXJuIGxhbmU7XG59XG5mdW5jdGlvbiBoaWdoZXJQcmlvcml0eUxhbmUoYSwgYikge1xuICAvLyBUaGlzIHdvcmtzIGJlY2F1c2UgdGhlIGJpdCByYW5nZXMgZGVjcmVhc2UgaW4gcHJpb3JpdHkgYXMgeW91IGdvIGxlZnQuXG4gIHJldHVybiBhICE9PSBOb0xhbmUgJiYgYSA8IGIgPyBhIDogYjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUxhbmVNYXAoaW5pdGlhbCkge1xuICAvLyBJbnRlbnRpb25hbGx5IHB1c2hpbmcgb25lIGJ5IG9uZS5cbiAgLy8gaHR0cHM6Ly92OC5kZXYvYmxvZy9lbGVtZW50cy1raW5kcyNhdm9pZC1jcmVhdGluZy1ob2xlc1xuICB2YXIgbGFuZU1hcCA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgVG90YWxMYW5lczsgaSsrKSB7XG4gICAgbGFuZU1hcC5wdXNoKGluaXRpYWwpO1xuICB9XG5cbiAgcmV0dXJuIGxhbmVNYXA7XG59XG5mdW5jdGlvbiBtYXJrUm9vdFVwZGF0ZWQkMShyb290LCB1cGRhdGVMYW5lKSB7XG4gIHJvb3QucGVuZGluZ0xhbmVzIHw9IHVwZGF0ZUxhbmU7IC8vIElmIHRoZXJlIGFyZSBhbnkgc3VzcGVuZGVkIHRyYW5zaXRpb25zLCBpdCdzIHBvc3NpYmxlIHRoaXMgbmV3IHVwZGF0ZVxuICAvLyBjb3VsZCB1bmJsb2NrIHRoZW0uIENsZWFyIHRoZSBzdXNwZW5kZWQgbGFuZXMgc28gdGhhdCB3ZSBjYW4gdHJ5IHJlbmRlcmluZ1xuICAvLyB0aGVtIGFnYWluLlxuICAvL1xuICAvLyBUT0RPOiBXZSByZWFsbHkgb25seSBuZWVkIHRvIHVuc3VzcGVuZCBvbmx5IGxhbmVzIHRoYXQgYXJlIGluIHRoZVxuICAvLyBgc3VidHJlZUxhbmVzYCBvZiB0aGUgdXBkYXRlZCBmaWJlciwgb3IgdGhlIHVwZGF0ZSBsYW5lcyBvZiB0aGUgcmV0dXJuXG4gIC8vIHBhdGguIFRoaXMgd291bGQgZXhjbHVkZSBzdXNwZW5kZWQgdXBkYXRlcyBpbiBhbiB1bnJlbGF0ZWQgc2libGluZyB0cmVlLFxuICAvLyBzaW5jZSB0aGVyZSdzIG5vIHdheSBmb3IgdGhpcyB1cGRhdGUgdG8gdW5ibG9jayBpdC5cbiAgLy9cbiAgLy8gV2UgZG9uJ3QgZG8gdGhpcyBpZiB0aGUgaW5jb21pbmcgdXBkYXRlIGlzIGlkbGUsIGJlY2F1c2Ugd2UgbmV2ZXIgcHJvY2Vzc1xuICAvLyBpZGxlIHVwZGF0ZXMgdW50aWwgYWZ0ZXIgYWxsIHRoZSByZWd1bGFyIHVwZGF0ZXMgaGF2ZSBmaW5pc2hlZDsgdGhlcmUncyBub1xuICAvLyB3YXkgaXQgY291bGQgdW5ibG9jayBhIHRyYW5zaXRpb24uXG5cbiAgaWYgKHVwZGF0ZUxhbmUgIT09IElkbGVMYW5lKSB7XG4gICAgcm9vdC5zdXNwZW5kZWRMYW5lcyA9IE5vTGFuZXM7XG4gICAgcm9vdC5waW5nZWRMYW5lcyA9IE5vTGFuZXM7XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtSb290U3VzcGVuZGVkJDEocm9vdCwgc3VzcGVuZGVkTGFuZXMsIHNwYXduZWRMYW5lKSB7XG4gIHJvb3Quc3VzcGVuZGVkTGFuZXMgfD0gc3VzcGVuZGVkTGFuZXM7XG4gIHJvb3QucGluZ2VkTGFuZXMgJj0gfnN1c3BlbmRlZExhbmVzOyAvLyBUaGUgc3VzcGVuZGVkIGxhbmVzIGFyZSBubyBsb25nZXIgQ1BVLWJvdW5kLiBDbGVhciB0aGVpciBleHBpcmF0aW9uIHRpbWVzLlxuXG4gIHZhciBleHBpcmF0aW9uVGltZXMgPSByb290LmV4cGlyYXRpb25UaW1lcztcbiAgdmFyIGxhbmVzID0gc3VzcGVuZGVkTGFuZXM7XG5cbiAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgIHZhciBpbmRleCA9IHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO1xuICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICBleHBpcmF0aW9uVGltZXNbaW5kZXhdID0gTm9UaW1lc3RhbXA7XG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cblxuICBpZiAoc3Bhd25lZExhbmUgIT09IE5vTGFuZSkge1xuICAgIG1hcmtTcGF3bmVkRGVmZXJyZWRMYW5lKHJvb3QsIHNwYXduZWRMYW5lLCBzdXNwZW5kZWRMYW5lcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtSb290UGluZ2VkJDEocm9vdCwgcGluZ2VkTGFuZXMpIHtcbiAgcm9vdC5waW5nZWRMYW5lcyB8PSByb290LnN1c3BlbmRlZExhbmVzICYgcGluZ2VkTGFuZXM7XG59XG5mdW5jdGlvbiBtYXJrUm9vdEZpbmlzaGVkKHJvb3QsIHJlbWFpbmluZ0xhbmVzLCBzcGF3bmVkTGFuZSkge1xuICB2YXIgbm9Mb25nZXJQZW5kaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lcyAmIH5yZW1haW5pbmdMYW5lcztcbiAgcm9vdC5wZW5kaW5nTGFuZXMgPSByZW1haW5pbmdMYW5lczsgLy8gTGV0J3MgdHJ5IGV2ZXJ5dGhpbmcgYWdhaW5cblxuICByb290LnN1c3BlbmRlZExhbmVzID0gTm9MYW5lcztcbiAgcm9vdC5waW5nZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHJvb3QuZXhwaXJlZExhbmVzICY9IHJlbWFpbmluZ0xhbmVzO1xuICByb290LmVudGFuZ2xlZExhbmVzICY9IHJlbWFpbmluZ0xhbmVzO1xuICByb290LmVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzICY9IHJlbWFpbmluZ0xhbmVzO1xuICByb290LnNoZWxsU3VzcGVuZENvdW50ZXIgPSAwO1xuICB2YXIgZW50YW5nbGVtZW50cyA9IHJvb3QuZW50YW5nbGVtZW50cztcbiAgdmFyIGV4cGlyYXRpb25UaW1lcyA9IHJvb3QuZXhwaXJhdGlvblRpbWVzO1xuICB2YXIgaGlkZGVuVXBkYXRlcyA9IHJvb3QuaGlkZGVuVXBkYXRlczsgLy8gQ2xlYXIgdGhlIGxhbmVzIHRoYXQgbm8gbG9uZ2VyIGhhdmUgcGVuZGluZyB3b3JrXG5cbiAgdmFyIGxhbmVzID0gbm9Mb25nZXJQZW5kaW5nTGFuZXM7XG5cbiAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgIHZhciBpbmRleCA9IHBpY2tBcmJpdHJhcnlMYW5lSW5kZXgobGFuZXMpO1xuICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICBlbnRhbmdsZW1lbnRzW2luZGV4XSA9IE5vTGFuZXM7XG4gICAgZXhwaXJhdGlvblRpbWVzW2luZGV4XSA9IE5vVGltZXN0YW1wO1xuICAgIHZhciBoaWRkZW5VcGRhdGVzRm9yTGFuZSA9IGhpZGRlblVwZGF0ZXNbaW5kZXhdO1xuXG4gICAgaWYgKGhpZGRlblVwZGF0ZXNGb3JMYW5lICE9PSBudWxsKSB7XG4gICAgICBoaWRkZW5VcGRhdGVzW2luZGV4XSA9IG51bGw7IC8vIFwiSGlkZGVuXCIgdXBkYXRlcyBhcmUgdXBkYXRlcyB0aGF0IHdlcmUgbWFkZSB0byBhIGhpZGRlbiBjb21wb25lbnQuIFRoZXlcbiAgICAgIC8vIGhhdmUgc3BlY2lhbCBsb2dpYyBhc3NvY2lhdGVkIHdpdGggdGhlbSBiZWNhdXNlIHRoZXkgbWF5IGJlIGVudGFuZ2xlZFxuICAgICAgLy8gd2l0aCB1cGRhdGVzIHRoYXQgb2NjdXIgb3V0c2lkZSB0aGF0IHRyZWUuIEJ1dCBvbmNlIHRoZSBvdXRlciB0cmVlXG4gICAgICAvLyBjb21taXRzLCB0aGV5IGJlaGF2ZSBsaWtlIHJlZ3VsYXIgdXBkYXRlcy5cblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaWRkZW5VcGRhdGVzRm9yTGFuZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdXBkYXRlID0gaGlkZGVuVXBkYXRlc0ZvckxhbmVbaV07XG5cbiAgICAgICAgaWYgKHVwZGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHVwZGF0ZS5sYW5lICY9IH5PZmZzY3JlZW5MYW5lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cblxuICBpZiAoc3Bhd25lZExhbmUgIT09IE5vTGFuZSkge1xuICAgIG1hcmtTcGF3bmVkRGVmZXJyZWRMYW5lKHJvb3QsIHNwYXduZWRMYW5lLCAvLyBUaGlzIHJlbmRlciBmaW5pc2hlZCBzdWNjZXNzZnVsbHkgd2l0aG91dCBzdXNwZW5kaW5nLCBzbyB3ZSBkb24ndCBuZWVkXG4gICAgLy8gdG8gZW50YW5nbGUgdGhlIHNwYXduZWQgdGFzayB3aXRoIHRoZSBwYXJlbnQgdGFzay5cbiAgICBOb0xhbmVzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrU3Bhd25lZERlZmVycmVkTGFuZShyb290LCBzcGF3bmVkTGFuZSwgZW50YW5nbGVkTGFuZXMpIHtcbiAgLy8gVGhpcyByZW5kZXIgc3Bhd25lZCBhIGRlZmVycmVkIHRhc2suIE1hcmsgaXQgYXMgcGVuZGluZy5cbiAgcm9vdC5wZW5kaW5nTGFuZXMgfD0gc3Bhd25lZExhbmU7XG4gIHJvb3Quc3VzcGVuZGVkTGFuZXMgJj0gfnNwYXduZWRMYW5lOyAvLyBFbnRhbmdsZSB0aGUgc3Bhd25lZCBsYW5lIHdpdGggdGhlIERlZmVycmVkTGFuZSBiaXQgc28gdGhhdCB3ZSBrbm93IGl0XG4gIC8vIHdhcyB0aGUgcmVzdWx0IG9mIGFub3RoZXIgcmVuZGVyLiBUaGlzIGxldHMgdXMgYXZvaWQgYSB1c2VEZWZlcnJlZFZhbHVlXG4gIC8vIHdhdGVyZmFsbCDigJQgb25seSB0aGUgZmlyc3QgbGV2ZWwgd2lsbCBkZWZlci5cblxuICB2YXIgc3Bhd25lZExhbmVJbmRleCA9IGxhbmVUb0luZGV4KHNwYXduZWRMYW5lKTtcbiAgcm9vdC5lbnRhbmdsZWRMYW5lcyB8PSBzcGF3bmVkTGFuZTtcbiAgcm9vdC5lbnRhbmdsZW1lbnRzW3NwYXduZWRMYW5lSW5kZXhdIHw9IERlZmVycmVkTGFuZSB8IC8vIElmIHRoZSBwYXJlbnQgcmVuZGVyIHRhc2sgc3VzcGVuZGVkLCB3ZSBtdXN0IGFsc28gZW50YW5nbGUgdGhvc2UgbGFuZXNcbiAgLy8gd2l0aCB0aGUgc3Bhd25lZCB0YXNrLCBzbyB0aGF0IHRoZSBkZWZlcnJlZCB0YXNrIGluY2x1ZGVzIGFsbCB0aGUgc2FtZVxuICAvLyB1cGRhdGVzIHRoYXQgdGhlIHBhcmVudCB0YXNrIGRpZC4gV2UgY2FuIGV4Y2x1ZGUgYW55IGxhbmUgdGhhdCBpcyBub3RcbiAgLy8gdXNlZCBmb3IgdXBkYXRlcyAoZS5nLiBPZmZzY3JlZW4pLlxuICBlbnRhbmdsZWRMYW5lcyAmIFVwZGF0ZUxhbmVzO1xufVxuXG5mdW5jdGlvbiBtYXJrUm9vdEVudGFuZ2xlZChyb290LCBlbnRhbmdsZWRMYW5lcykge1xuICAvLyBJbiBhZGRpdGlvbiB0byBlbnRhbmdsaW5nIGVhY2ggb2YgdGhlIGdpdmVuIGxhbmVzIHdpdGggZWFjaCBvdGhlciwgd2UgYWxzb1xuICAvLyBoYXZlIHRvIGNvbnNpZGVyIF90cmFuc2l0aXZlXyBlbnRhbmdsZW1lbnRzLiBGb3IgZWFjaCBsYW5lIHRoYXQgaXMgYWxyZWFkeVxuICAvLyBlbnRhbmdsZWQgd2l0aCAqYW55KiBvZiB0aGUgZ2l2ZW4gbGFuZXMsIHRoYXQgbGFuZSBpcyBub3cgdHJhbnNpdGl2ZWx5XG4gIC8vIGVudGFuZ2xlZCB3aXRoICphbGwqIHRoZSBnaXZlbiBsYW5lcy5cbiAgLy9cbiAgLy8gVHJhbnNsYXRlZDogSWYgQyBpcyBlbnRhbmdsZWQgd2l0aCBBLCB0aGVuIGVudGFuZ2xpbmcgQSB3aXRoIEIgYWxzb1xuICAvLyBlbnRhbmdsZXMgQyB3aXRoIEIuXG4gIC8vXG4gIC8vIElmIHRoaXMgaXMgaGFyZCB0byBncmFzcCwgaXQgbWlnaHQgaGVscCB0byBpbnRlbnRpb25hbGx5IGJyZWFrIHRoaXNcbiAgLy8gZnVuY3Rpb24gYW5kIGxvb2sgYXQgdGhlIHRlc3RzIHRoYXQgZmFpbCBpbiBSZWFjdFRyYW5zaXRpb24tdGVzdC5qcy4gVHJ5XG4gIC8vIGNvbW1lbnRpbmcgb3V0IG9uZSBvZiB0aGUgY29uZGl0aW9ucyBiZWxvdy5cbiAgdmFyIHJvb3RFbnRhbmdsZWRMYW5lcyA9IHJvb3QuZW50YW5nbGVkTGFuZXMgfD0gZW50YW5nbGVkTGFuZXM7XG4gIHZhciBlbnRhbmdsZW1lbnRzID0gcm9vdC5lbnRhbmdsZW1lbnRzO1xuICB2YXIgbGFuZXMgPSByb290RW50YW5nbGVkTGFuZXM7XG5cbiAgd2hpbGUgKGxhbmVzKSB7XG4gICAgdmFyIGluZGV4ID0gcGlja0FyYml0cmFyeUxhbmVJbmRleChsYW5lcyk7XG4gICAgdmFyIGxhbmUgPSAxIDw8IGluZGV4O1xuXG4gICAgaWYgKCAvLyBJcyB0aGlzIG9uZSBvZiB0aGUgbmV3bHkgZW50YW5nbGVkIGxhbmVzP1xuICAgIGxhbmUgJiBlbnRhbmdsZWRMYW5lcyB8IC8vIElzIHRoaXMgbGFuZSB0cmFuc2l0aXZlbHkgZW50YW5nbGVkIHdpdGggdGhlIG5ld2x5IGVudGFuZ2xlZCBsYW5lcz9cbiAgICBlbnRhbmdsZW1lbnRzW2luZGV4XSAmIGVudGFuZ2xlZExhbmVzKSB7XG4gICAgICBlbnRhbmdsZW1lbnRzW2luZGV4XSB8PSBlbnRhbmdsZWRMYW5lcztcbiAgICB9XG5cbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxufVxuZnVuY3Rpb24gdXBncmFkZVBlbmRpbmdMYW5lVG9TeW5jKHJvb3QsIGxhbmUpIHtcbiAgLy8gU2luY2Ugd2UncmUgdXBncmFkaW5nIHRoZSBwcmlvcml0eSBvZiB0aGUgZ2l2ZW4gbGFuZSwgdGhlcmUgaXMgbm93IHBlbmRpbmdcbiAgLy8gc3luYyB3b3JrLlxuICByb290LnBlbmRpbmdMYW5lcyB8PSBTeW5jTGFuZTsgLy8gRW50YW5nbGUgdGhlIHN5bmMgbGFuZSB3aXRoIHRoZSBsYW5lIHdlJ3JlIHVwZ3JhZGluZy4gVGhpcyBtZWFucyBTeW5jTGFuZVxuICAvLyB3aWxsIG5vdCBiZSBhbGxvd2VkIHRvIGZpbmlzaCB3aXRob3V0IGFsc28gZmluaXNoaW5nIHRoZSBnaXZlbiBsYW5lLlxuXG4gIHJvb3QuZW50YW5nbGVkTGFuZXMgfD0gU3luY0xhbmU7XG4gIHJvb3QuZW50YW5nbGVtZW50c1tTeW5jTGFuZUluZGV4XSB8PSBsYW5lO1xufVxuZnVuY3Rpb24gdXBncmFkZVBlbmRpbmdMYW5lc1RvU3luYyhyb290LCBsYW5lc1RvVXBncmFkZSkge1xuICAvLyBTYW1lIGFzIHVwZ3JhZGVQZW5kaW5nTGFuZVRvU3luYyBidXQgYWNjZXB0cyBtdWx0aXBsZSBsYW5lcywgc28gaXQncyBhXG4gIC8vIGJpdCBzbG93ZXIuXG4gIHJvb3QucGVuZGluZ0xhbmVzIHw9IFN5bmNMYW5lO1xuICByb290LmVudGFuZ2xlZExhbmVzIHw9IFN5bmNMYW5lO1xuICB2YXIgbGFuZXMgPSBsYW5lc1RvVXBncmFkZTtcblxuICB3aGlsZSAobGFuZXMpIHtcbiAgICB2YXIgaW5kZXggPSBwaWNrQXJiaXRyYXJ5TGFuZUluZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgcm9vdC5lbnRhbmdsZW1lbnRzW1N5bmNMYW5lSW5kZXhdIHw9IGxhbmU7XG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtIaWRkZW5VcGRhdGUocm9vdCwgdXBkYXRlLCBsYW5lKSB7XG4gIHZhciBpbmRleCA9IGxhbmVUb0luZGV4KGxhbmUpO1xuICB2YXIgaGlkZGVuVXBkYXRlcyA9IHJvb3QuaGlkZGVuVXBkYXRlcztcbiAgdmFyIGhpZGRlblVwZGF0ZXNGb3JMYW5lID0gaGlkZGVuVXBkYXRlc1tpbmRleF07XG5cbiAgaWYgKGhpZGRlblVwZGF0ZXNGb3JMYW5lID09PSBudWxsKSB7XG4gICAgaGlkZGVuVXBkYXRlc1tpbmRleF0gPSBbdXBkYXRlXTtcbiAgfSBlbHNlIHtcbiAgICBoaWRkZW5VcGRhdGVzRm9yTGFuZS5wdXNoKHVwZGF0ZSk7XG4gIH1cblxuICB1cGRhdGUubGFuZSA9IGxhbmUgfCBPZmZzY3JlZW5MYW5lO1xufVxuZnVuY3Rpb24gZ2V0QnVtcGVkTGFuZUZvckh5ZHJhdGlvbihyb290LCByZW5kZXJMYW5lcykge1xuICB2YXIgcmVuZGVyTGFuZSA9IGdldEhpZ2hlc3RQcmlvcml0eUxhbmUocmVuZGVyTGFuZXMpO1xuICB2YXIgbGFuZTtcblxuICBpZiAoKHJlbmRlckxhbmUgJiBTeW5jVXBkYXRlTGFuZXMpICE9PSBOb0xhbmUpIHtcbiAgICBsYW5lID0gU3luY0h5ZHJhdGlvbkxhbmU7XG4gIH0gZWxzZSB7XG4gICAgc3dpdGNoIChyZW5kZXJMYW5lKSB7XG4gICAgICBjYXNlIFN5bmNMYW5lOlxuICAgICAgICBsYW5lID0gU3luY0h5ZHJhdGlvbkxhbmU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIElucHV0Q29udGludW91c0xhbmU6XG4gICAgICAgIGxhbmUgPSBJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBEZWZhdWx0TGFuZTpcbiAgICAgICAgbGFuZSA9IERlZmF1bHRIeWRyYXRpb25MYW5lO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE6XG4gICAgICBjYXNlIFRyYW5zaXRpb25MYW5lMjpcbiAgICAgIGNhc2UgVHJhbnNpdGlvbkxhbmUzOlxuICAgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTQ6XG4gICAgICBjYXNlIFRyYW5zaXRpb25MYW5lNTpcbiAgICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU2OlxuICAgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTc6XG4gICAgICBjYXNlIFRyYW5zaXRpb25MYW5lODpcbiAgICAgIGNhc2UgVHJhbnNpdGlvbkxhbmU5OlxuICAgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTEwOlxuICAgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTExOlxuICAgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTEyOlxuICAgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTEzOlxuICAgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE0OlxuICAgICAgY2FzZSBUcmFuc2l0aW9uTGFuZTE1OlxuICAgICAgY2FzZSBSZXRyeUxhbmUxOlxuICAgICAgY2FzZSBSZXRyeUxhbmUyOlxuICAgICAgY2FzZSBSZXRyeUxhbmUzOlxuICAgICAgY2FzZSBSZXRyeUxhbmU0OlxuICAgICAgICBsYW5lID0gVHJhbnNpdGlvbkh5ZHJhdGlvbkxhbmU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIElkbGVMYW5lOlxuICAgICAgICBsYW5lID0gSWRsZUh5ZHJhdGlvbkxhbmU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBFdmVyeXRoaW5nIGVsc2UgaXMgYWxyZWFkeSBlaXRoZXIgYSBoeWRyYXRpb24gbGFuZSwgb3Igc2hvdWxkbid0XG4gICAgICAgIC8vIGJlIHJldHJpZWQgYXQgYSBoeWRyYXRpb24gbGFuZS5cbiAgICAgICAgbGFuZSA9IE5vTGFuZTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9IC8vIENoZWNrIGlmIHRoZSBsYW5lIHdlIGNob3NlIGlzIHN1c3BlbmRlZC4gSWYgc28sIHRoYXQgaW5kaWNhdGVzIHRoYXQgd2VcbiAgLy8gYWxyZWFkeSBhdHRlbXB0ZWQgYW5kIGZhaWxlZCB0byBoeWRyYXRlIGF0IHRoYXQgbGV2ZWwuIEFsc28gY2hlY2sgaWYgd2UncmVcbiAgLy8gYWxyZWFkeSByZW5kZXJpbmcgdGhhdCBsYW5lLCB3aGljaCBpcyByYXJlIGJ1dCBjb3VsZCBoYXBwZW4uXG5cblxuICBpZiAoKGxhbmUgJiAocm9vdC5zdXNwZW5kZWRMYW5lcyB8IHJlbmRlckxhbmVzKSkgIT09IE5vTGFuZSkge1xuICAgIC8vIEdpdmUgdXAgdHJ5aW5nIHRvIGh5ZHJhdGUgYW5kIGZhbGwgYmFjayB0byBjbGllbnQgcmVuZGVyLlxuICAgIHJldHVybiBOb0xhbmU7XG4gIH1cblxuICByZXR1cm4gbGFuZTtcbn1cbmZ1bmN0aW9uIGFkZEZpYmVyVG9MYW5lc01hcChyb290LCBmaWJlciwgbGFuZXMpIHtcblxuICBpZiAoIWlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHBlbmRpbmdVcGRhdGVyc0xhbmVNYXAgPSByb290LnBlbmRpbmdVcGRhdGVyc0xhbmVNYXA7XG5cbiAgd2hpbGUgKGxhbmVzID4gMCkge1xuICAgIHZhciBpbmRleCA9IGxhbmVUb0luZGV4KGxhbmVzKTtcbiAgICB2YXIgbGFuZSA9IDEgPDwgaW5kZXg7XG4gICAgdmFyIHVwZGF0ZXJzID0gcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcFtpbmRleF07XG4gICAgdXBkYXRlcnMuYWRkKGZpYmVyKTtcbiAgICBsYW5lcyAmPSB+bGFuZTtcbiAgfVxufVxuZnVuY3Rpb24gbW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkKHJvb3QsIGxhbmVzKSB7XG5cbiAgaWYgKCFpc0RldlRvb2xzUHJlc2VudCkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBwZW5kaW5nVXBkYXRlcnNMYW5lTWFwID0gcm9vdC5wZW5kaW5nVXBkYXRlcnNMYW5lTWFwO1xuICB2YXIgbWVtb2l6ZWRVcGRhdGVycyA9IHJvb3QubWVtb2l6ZWRVcGRhdGVycztcblxuICB3aGlsZSAobGFuZXMgPiAwKSB7XG4gICAgdmFyIGluZGV4ID0gbGFuZVRvSW5kZXgobGFuZXMpO1xuICAgIHZhciBsYW5lID0gMSA8PCBpbmRleDtcbiAgICB2YXIgdXBkYXRlcnMgPSBwZW5kaW5nVXBkYXRlcnNMYW5lTWFwW2luZGV4XTtcblxuICAgIGlmICh1cGRhdGVycy5zaXplID4gMCkge1xuICAgICAgdXBkYXRlcnMuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICAgICAgICBpZiAoYWx0ZXJuYXRlID09PSBudWxsIHx8ICFtZW1vaXplZFVwZGF0ZXJzLmhhcyhhbHRlcm5hdGUpKSB7XG4gICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycy5hZGQoZmliZXIpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHVwZGF0ZXJzLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgbGFuZXMgJj0gfmxhbmU7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFRyYW5zaXRpb25zRm9yTGFuZXMocm9vdCwgbGFuZXMpIHtcbiAge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbnZhciBEaXNjcmV0ZUV2ZW50UHJpb3JpdHkgPSBTeW5jTGFuZTtcbnZhciBDb250aW51b3VzRXZlbnRQcmlvcml0eSA9IElucHV0Q29udGludW91c0xhbmU7XG52YXIgRGVmYXVsdEV2ZW50UHJpb3JpdHkgPSBEZWZhdWx0TGFuZTtcbnZhciBJZGxlRXZlbnRQcmlvcml0eSA9IElkbGVMYW5lO1xuZnVuY3Rpb24gaGlnaGVyRXZlbnRQcmlvcml0eShhLCBiKSB7XG4gIHJldHVybiBhICE9PSAwICYmIGEgPCBiID8gYSA6IGI7XG59XG5mdW5jdGlvbiBsb3dlckV2ZW50UHJpb3JpdHkoYSwgYikge1xuICByZXR1cm4gYSA9PT0gMCB8fCBhID4gYiA/IGEgOiBiO1xufVxuZnVuY3Rpb24gaXNIaWdoZXJFdmVudFByaW9yaXR5KGEsIGIpIHtcbiAgcmV0dXJuIGEgIT09IDAgJiYgYSA8IGI7XG59XG5mdW5jdGlvbiBldmVudFByaW9yaXR5VG9MYW5lKHVwZGF0ZVByaW9yaXR5KSB7XG4gIHJldHVybiB1cGRhdGVQcmlvcml0eTtcbn1cbmZ1bmN0aW9uIGxhbmVzVG9FdmVudFByaW9yaXR5KGxhbmVzKSB7XG4gIHZhciBsYW5lID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZShsYW5lcyk7XG5cbiAgaWYgKCFpc0hpZ2hlckV2ZW50UHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5LCBsYW5lKSkge1xuICAgIHJldHVybiBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk7XG4gIH1cblxuICBpZiAoIWlzSGlnaGVyRXZlbnRQcmlvcml0eShDb250aW51b3VzRXZlbnRQcmlvcml0eSwgbGFuZSkpIHtcbiAgICByZXR1cm4gQ29udGludW91c0V2ZW50UHJpb3JpdHk7XG4gIH1cblxuICBpZiAoaW5jbHVkZXNOb25JZGxlV29yayhsYW5lKSkge1xuICAgIHJldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTtcbiAgfVxuXG4gIHJldHVybiBJZGxlRXZlbnRQcmlvcml0eTtcbn1cblxuLy8gVGhpcyBtb2R1bGUgb25seSBleGlzdHMgYXMgYW4gRVNNIHdyYXBwZXIgYXJvdW5kIHRoZSBleHRlcm5hbCBDb21tb25KU1xudmFyIHNjaGVkdWxlQ2FsbGJhY2skMyA9IFNjaGVkdWxlci51bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrO1xudmFyIGNhbmNlbENhbGxiYWNrJDEgPSBTY2hlZHVsZXIudW5zdGFibGVfY2FuY2VsQ2FsbGJhY2s7XG52YXIgc2hvdWxkWWllbGQgPSBTY2hlZHVsZXIudW5zdGFibGVfc2hvdWxkWWllbGQ7XG52YXIgcmVxdWVzdFBhaW50ID0gU2NoZWR1bGVyLnVuc3RhYmxlX3JlcXVlc3RQYWludDtcbnZhciBub3ckMSA9IFNjaGVkdWxlci51bnN0YWJsZV9ub3c7XG52YXIgSW1tZWRpYXRlUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfSW1tZWRpYXRlUHJpb3JpdHk7XG52YXIgVXNlckJsb2NraW5nUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfVXNlckJsb2NraW5nUHJpb3JpdHk7XG52YXIgTm9ybWFsUHJpb3JpdHkkMSA9IFNjaGVkdWxlci51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eTtcbnZhciBJZGxlUHJpb3JpdHkgPSBTY2hlZHVsZXIudW5zdGFibGVfSWRsZVByaW9yaXR5OyAvLyB0aGlzIGRvZXNuJ3QgYWN0dWFsbHkgZXhpc3Qgb24gdGhlIHNjaGVkdWxlciwgYnV0IGl0ICpkb2VzKlxuLy8gb24gc2NoZWR1bGVyL3Vuc3RhYmxlX21vY2ssIHdoaWNoIHdlJ2xsIG5lZWQgZm9yIGludGVybmFsIHRlc3RpbmdcblxudmFyIGxvZyA9IFNjaGVkdWxlci5sb2c7XG52YXIgdW5zdGFibGVfc2V0RGlzYWJsZVlpZWxkVmFsdWUgPSBTY2hlZHVsZXIudW5zdGFibGVfc2V0RGlzYWJsZVlpZWxkVmFsdWU7XG5cbnZhciByZW5kZXJlcklEID0gbnVsbDtcbnZhciBpbmplY3RlZEhvb2sgPSBudWxsO1xudmFyIGluamVjdGVkUHJvZmlsaW5nSG9va3MgPSBudWxsO1xudmFyIGhhc0xvZ2dlZEVycm9yID0gZmFsc2U7XG52YXIgaXNEZXZUb29sc1ByZXNlbnQgPSB0eXBlb2YgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICE9PSAndW5kZWZpbmVkJztcbmZ1bmN0aW9uIGluamVjdEludGVybmFscyhpbnRlcm5hbHMpIHtcbiAgaWYgKHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgLy8gTm8gRGV2VG9vbHNcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgaG9vayA9IF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuICBpZiAoaG9vay5pc0Rpc2FibGVkKSB7XG4gICAgLy8gVGhpcyBpc24ndCBhIHJlYWwgcHJvcGVydHkgb24gdGhlIGhvb2ssIGJ1dCBpdCBjYW4gYmUgc2V0IHRvIG9wdCBvdXRcbiAgICAvLyBvZiBEZXZUb29scyBpbnRlZ3JhdGlvbiBhbmQgYXNzb2NpYXRlZCB3YXJuaW5ncyBhbmQgbG9ncy5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzM4NzdcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICghaG9vay5zdXBwb3J0c0ZpYmVyKSB7XG4gICAge1xuICAgICAgZXJyb3IoJ1RoZSBpbnN0YWxsZWQgdmVyc2lvbiBvZiBSZWFjdCBEZXZUb29scyBpcyB0b28gb2xkIGFuZCB3aWxsIG5vdCB3b3JrICcgKyAnd2l0aCB0aGUgY3VycmVudCB2ZXJzaW9uIG9mIFJlYWN0LiBQbGVhc2UgdXBkYXRlIFJlYWN0IERldlRvb2xzLiAnICsgJ2h0dHBzOi8vcmVhY3QuZGV2L2xpbmsvcmVhY3QtZGV2dG9vbHMnKTtcbiAgICB9IC8vIERldlRvb2xzIGV4aXN0cywgZXZlbiB0aG91Z2ggaXQgZG9lc24ndCBzdXBwb3J0IEZpYmVyLlxuXG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgaWYgKGVuYWJsZVNjaGVkdWxpbmdQcm9maWxlcikge1xuICAgICAgLy8gQ29uZGl0aW9uYWxseSBpbmplY3QgdGhlc2UgaG9va3Mgb25seSBpZiBUaW1lbGluZSBwcm9maWxlciBpcyBzdXBwb3J0ZWQgYnkgdGhpcyBidWlsZC5cbiAgICAgIC8vIFRoaXMgZ2l2ZXMgRGV2VG9vbHMgYSB3YXkgdG8gZmVhdHVyZSBkZXRlY3QgdGhhdCBpc24ndCB0aWVkIHRvIHZlcnNpb24gbnVtYmVyXG4gICAgICAvLyAoc2luY2UgcHJvZmlsaW5nIGFuZCB0aW1lbGluZSBhcmUgY29udHJvbGxlZCBieSBkaWZmZXJlbnQgZmVhdHVyZSBmbGFncykuXG4gICAgICBpbnRlcm5hbHMgPSBhc3NpZ24oe30sIGludGVybmFscywge1xuICAgICAgICBnZXRMYW5lTGFiZWxNYXA6IGdldExhbmVMYWJlbE1hcCxcbiAgICAgICAgaW5qZWN0UHJvZmlsaW5nSG9va3M6IGluamVjdFByb2ZpbGluZ0hvb2tzXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZW5kZXJlcklEID0gaG9vay5pbmplY3QoaW50ZXJuYWxzKTsgLy8gV2UgaGF2ZSBzdWNjZXNzZnVsbHkgaW5qZWN0ZWQsIHNvIG5vdyBpdCBpcyBzYWZlIHRvIHNldCB1cCBob29rcy5cblxuICAgIGluamVjdGVkSG9vayA9IGhvb2s7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vIENhdGNoIGFsbCBlcnJvcnMgYmVjYXVzZSBpdCBpcyB1bnNhZmUgdG8gdGhyb3cgZHVyaW5nIGluaXRpYWxpemF0aW9uLlxuICAgIHtcbiAgICAgIGVycm9yKCdSZWFjdCBpbnN0cnVtZW50YXRpb24gZW5jb3VudGVyZWQgYW4gZXJyb3I6ICVzLicsIGVycik7XG4gICAgfVxuICB9XG5cbiAgaWYgKGhvb2suY2hlY2tEQ0UpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSByZWFsIERldlRvb2xzLlxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgbGlrZWx5IGEgaG9vayBpbnN0YWxsZWQgYnkgRmFzdCBSZWZyZXNoIHJ1bnRpbWUuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5mdW5jdGlvbiBvblNjaGVkdWxlUm9vdChyb290LCBjaGlsZHJlbikge1xuICB7XG4gICAgaWYgKGluamVjdGVkSG9vayAmJiB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uU2NoZWR1bGVGaWJlclJvb3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGluamVjdGVkSG9vay5vblNjaGVkdWxlRmliZXJSb290KHJlbmRlcmVySUQsIHJvb3QsIGNoaWxkcmVuKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoIWhhc0xvZ2dlZEVycm9yKSB7XG4gICAgICAgICAgaGFzTG9nZ2VkRXJyb3IgPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJ1JlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLCBlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBvbkNvbW1pdFJvb3QkMShyb290LCBldmVudFByaW9yaXR5KSB7XG4gIGlmIChpbmplY3RlZEhvb2sgJiYgdHlwZW9mIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICB2YXIgZGlkRXJyb3IgPSAocm9vdC5jdXJyZW50LmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IERpZENhcHR1cmU7XG5cbiAgICAgIGlmIChlbmFibGVQcm9maWxlclRpbWVyKSB7XG4gICAgICAgIHZhciBzY2hlZHVsZXJQcmlvcml0eTtcblxuICAgICAgICBzd2l0Y2ggKGV2ZW50UHJpb3JpdHkpIHtcbiAgICAgICAgICBjYXNlIERpc2NyZXRlRXZlbnRQcmlvcml0eTpcbiAgICAgICAgICAgIHNjaGVkdWxlclByaW9yaXR5ID0gSW1tZWRpYXRlUHJpb3JpdHk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2UgQ29udGludW91c0V2ZW50UHJpb3JpdHk6XG4gICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSA9IFVzZXJCbG9ja2luZ1ByaW9yaXR5O1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIERlZmF1bHRFdmVudFByaW9yaXR5OlxuICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBOb3JtYWxQcmlvcml0eSQxO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIElkbGVFdmVudFByaW9yaXR5OlxuICAgICAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHkgPSBJZGxlUHJpb3JpdHk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBzY2hlZHVsZXJQcmlvcml0eSA9IE5vcm1hbFByaW9yaXR5JDE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyUm9vdChyZW5kZXJlcklELCByb290LCBzY2hlZHVsZXJQcmlvcml0eSwgZGlkRXJyb3IpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAge1xuICAgICAgICBpZiAoIWhhc0xvZ2dlZEVycm9yKSB7XG4gICAgICAgICAgaGFzTG9nZ2VkRXJyb3IgPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJ1JlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLCBlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBvblBvc3RDb21taXRSb290KHJvb3QpIHtcbiAgaWYgKGluamVjdGVkSG9vayAmJiB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uUG9zdENvbW1pdEZpYmVyUm9vdCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRyeSB7XG4gICAgICBpbmplY3RlZEhvb2sub25Qb3N0Q29tbWl0RmliZXJSb290KHJlbmRlcmVySUQsIHJvb3QpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAge1xuICAgICAgICBpZiAoIWhhc0xvZ2dlZEVycm9yKSB7XG4gICAgICAgICAgaGFzTG9nZ2VkRXJyb3IgPSB0cnVlO1xuXG4gICAgICAgICAgZXJyb3IoJ1JlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLCBlcnIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBvbkNvbW1pdFVubW91bnQoZmliZXIpIHtcbiAgaWYgKGluamVjdGVkSG9vayAmJiB0eXBlb2YgaW5qZWN0ZWRIb29rLm9uQ29tbWl0RmliZXJVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdHJ5IHtcbiAgICAgIGluamVjdGVkSG9vay5vbkNvbW1pdEZpYmVyVW5tb3VudChyZW5kZXJlcklELCBmaWJlcik7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB7XG4gICAgICAgIGlmICghaGFzTG9nZ2VkRXJyb3IpIHtcbiAgICAgICAgICBoYXNMb2dnZWRFcnJvciA9IHRydWU7XG5cbiAgICAgICAgICBlcnJvcignUmVhY3QgaW5zdHJ1bWVudGF0aW9uIGVuY291bnRlcmVkIGFuIGVycm9yOiAlcycsIGVycik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKG5ld0lzU3RyaWN0TW9kZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBsb2cgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFdlJ3JlIGluIGEgdGVzdCBiZWNhdXNlIFNjaGVkdWxlci5sb2cgb25seSBleGlzdHNcbiAgICAgIC8vIGluIFNjaGVkdWxlck1vY2suIFRvIHJlZHVjZSB0aGUgbm9pc2UgaW4gc3RyaWN0IG1vZGUgdGVzdHMsXG4gICAgICAvLyBzdXBwcmVzcyB3YXJuaW5ncyBhbmQgZGlzYWJsZSBzY2hlZHVsZXIgeWllbGRpbmcgZHVyaW5nIHRoZSBkb3VibGUgcmVuZGVyXG4gICAgICB1bnN0YWJsZV9zZXREaXNhYmxlWWllbGRWYWx1ZShuZXdJc1N0cmljdE1vZGUpO1xuICAgICAgc2V0U3VwcHJlc3NXYXJuaW5nKG5ld0lzU3RyaWN0TW9kZSk7XG4gICAgfVxuXG4gICAgaWYgKGluamVjdGVkSG9vayAmJiB0eXBlb2YgaW5qZWN0ZWRIb29rLnNldFN0cmljdE1vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGluamVjdGVkSG9vay5zZXRTdHJpY3RNb2RlKHJlbmRlcmVySUQsIG5ld0lzU3RyaWN0TW9kZSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAge1xuICAgICAgICAgIGlmICghaGFzTG9nZ2VkRXJyb3IpIHtcbiAgICAgICAgICAgIGhhc0xvZ2dlZEVycm9yID0gdHJ1ZTtcblxuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0IGluc3RydW1lbnRhdGlvbiBlbmNvdW50ZXJlZCBhbiBlcnJvcjogJXMnLCBlcnIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufSAvLyBQcm9maWxlciBBUEkgaG9va3NcblxuZnVuY3Rpb24gaW5qZWN0UHJvZmlsaW5nSG9va3MocHJvZmlsaW5nSG9va3MpIHtcbiAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcyA9IHByb2ZpbGluZ0hvb2tzO1xufVxuXG5mdW5jdGlvbiBnZXRMYW5lTGFiZWxNYXAoKSB7XG4gIHtcbiAgICB2YXIgbWFwID0gbmV3IE1hcCgpO1xuICAgIHZhciBsYW5lID0gMTtcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBUb3RhbExhbmVzOyBpbmRleCsrKSB7XG4gICAgICB2YXIgbGFiZWwgPSBnZXRMYWJlbEZvckxhbmUobGFuZSk7XG4gICAgICBtYXAuc2V0KGxhbmUsIGxhYmVsKTtcbiAgICAgIGxhbmUgKj0gMjtcbiAgICB9XG5cbiAgICByZXR1cm4gbWFwO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtDb21taXRTdGFydGVkKGxhbmVzKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tbWl0U3RhcnRlZChsYW5lcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tbWl0U3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21taXRTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21taXRTdG9wcGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50UmVuZGVyU3RhcnRlZChmaWJlcikge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQoZmliZXIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0YXJ0ZWQoZmliZXIpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkKGZpYmVyKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdG9wcGVkKCkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQoZmliZXIpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0VW5tb3VudFN0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RhcnRlZChmaWJlcik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkKCkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0YXJ0ZWQoZmliZXIpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0b3BwZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RvcHBlZCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0YXJ0ZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkKGZpYmVyKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RVbm1vdW50U3RvcHBlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0VW5tb3VudFN0b3BwZWQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtDb21wb25lbnRFcnJvcmVkKGZpYmVyLCB0aHJvd25WYWx1ZSwgbGFuZXMpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRFcnJvcmVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRFcnJvcmVkKGZpYmVyLCB0aHJvd25WYWx1ZSwgbGFuZXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0NvbXBvbmVudFN1c3BlbmRlZChmaWJlciwgd2FrZWFibGUsIGxhbmVzKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrQ29tcG9uZW50U3VzcGVuZGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtDb21wb25lbnRTdXNwZW5kZWQoZmliZXIsIHdha2VhYmxlLCBsYW5lcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQobGFuZXMpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQobGFuZXMpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya0xheW91dEVmZmVjdHNTdG9wcGVkKCkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0xheW91dEVmZmVjdHNTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCgpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gbWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZChsYW5lcykge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1Bhc3NpdmVFZmZlY3RzU3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUGFzc2l2ZUVmZmVjdHNTdGFydGVkKGxhbmVzKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQoKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUGFzc2l2ZUVmZmVjdHNTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtQYXNzaXZlRWZmZWN0c1N0b3BwZWQoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtSZW5kZXJTdGFydGVkKGxhbmVzKSB7XG4gIHtcbiAgICBpZiAoaW5qZWN0ZWRQcm9maWxpbmdIb29rcyAhPT0gbnVsbCAmJiB0eXBlb2YgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RhcnRlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrUmVuZGVyU3RhcnRlZChsYW5lcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrUmVuZGVyWWllbGRlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJZaWVsZGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJZaWVsZGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrUmVuZGVyU3RvcHBlZCgpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdG9wcGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTdG9wcGVkKCk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrUmVuZGVyU2NoZWR1bGVkKGxhbmUpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtSZW5kZXJTY2hlZHVsZWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya1JlbmRlclNjaGVkdWxlZChsYW5lKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSkge1xuICB7XG4gICAgaWYgKGluamVjdGVkUHJvZmlsaW5nSG9va3MgIT09IG51bGwgJiYgdHlwZW9mIGluamVjdGVkUHJvZmlsaW5nSG9va3MubWFya0ZvcmNlVXBkYXRlU2NoZWR1bGVkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpIHtcbiAge1xuICAgIGlmIChpbmplY3RlZFByb2ZpbGluZ0hvb2tzICE9PSBudWxsICYmIHR5cGVvZiBpbmplY3RlZFByb2ZpbGluZ0hvb2tzLm1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaW5qZWN0ZWRQcm9maWxpbmdIb29rcy5tYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9pc1xuICovXG5mdW5jdGlvbiBpcyh4LCB5KSB7XG4gIHJldHVybiB4ID09PSB5ICYmICh4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geSkgfHwgeCAhPT0geCAmJiB5ICE9PSB5IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG4gIDtcbn1cblxudmFyIG9iamVjdElzID0gLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxudHlwZW9mIE9iamVjdC5pcyA9PT0gJ2Z1bmN0aW9uJyA/IE9iamVjdC5pcyA6IGlzO1xuXG4vLyBUaGlzIGlzIGltcG9ydGVkIGJ5IHRoZSBldmVudCByZXBsYXlpbmcgaW1wbGVtZW50YXRpb24gaW4gUmVhY3QgRE9NLiBJdCdzXG4vLyBpbiBhIHNlcGFyYXRlIGZpbGUgdG8gYnJlYWsgYSBjaXJjdWxhciBkZXBlbmRlbmN5IGJldHdlZW4gdGhlIHJlbmRlcmVyIGFuZFxuLy8gdGhlIHJlY29uY2lsZXIuXG5mdW5jdGlvbiBpc1Jvb3REZWh5ZHJhdGVkKHJvb3QpIHtcbiAgdmFyIGN1cnJlbnRTdGF0ZSA9IHJvb3QuY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICByZXR1cm4gY3VycmVudFN0YXRlLmlzRGVoeWRyYXRlZDtcbn1cblxudmFyIENhcHR1cmVkU3RhY2tzID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHZhbHVlLCBzb3VyY2UpIHtcbiAgLy8gSWYgdGhlIHZhbHVlIGlzIGFuIGVycm9yLCBjYWxsIHRoaXMgZnVuY3Rpb24gaW1tZWRpYXRlbHkgYWZ0ZXIgaXQgaXMgdGhyb3duXG4gIC8vIHNvIHRoZSBzdGFjayBpcyBhY2N1cmF0ZS5cbiAgdmFyIHN0YWNrO1xuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICE9PSBudWxsKSB7XG4gICAgdmFyIGNhcHR1cmVkU3RhY2sgPSBDYXB0dXJlZFN0YWNrcy5nZXQodmFsdWUpO1xuXG4gICAgaWYgKHR5cGVvZiBjYXB0dXJlZFN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgc3RhY2sgPSBjYXB0dXJlZFN0YWNrO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFjayA9IGdldFN0YWNrQnlGaWJlckluRGV2QW5kUHJvZChzb3VyY2UpO1xuICAgICAgQ2FwdHVyZWRTdGFja3Muc2V0KHZhbHVlLCBzdGFjayk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHN0YWNrID0gZ2V0U3RhY2tCeUZpYmVySW5EZXZBbmRQcm9kKHNvdXJjZSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBzb3VyY2U6IHNvdXJjZSxcbiAgICBzdGFjazogc3RhY2tcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUNhcHR1cmVkVmFsdWVGcm9tRXJyb3IodmFsdWUsIHN0YWNrKSB7XG4gIGlmICh0eXBlb2Ygc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgQ2FwdHVyZWRTdGFja3Muc2V0KHZhbHVlLCBzdGFjayk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBzb3VyY2U6IG51bGwsXG4gICAgc3RhY2s6IHN0YWNrXG4gIH07XG59XG5cbi8vIEludGVudGlvbmFsbHkgbm90IHVzaW5nIGl0IHlldCB0byBkZXJpc2sgdGhlIGluaXRpYWwgaW1wbGVtZW50YXRpb24sIGJlY2F1c2Vcbi8vIHRoZSB3YXkgd2UgcHVzaC9wb3AgdGhlc2UgdmFsdWVzIGlzIGEgYml0IHVudXN1YWwuIElmIHRoZXJlJ3MgYSBtaXN0YWtlLCBJJ2Rcbi8vIHJhdGhlciB0aGUgaWRzIGJlIHdyb25nIHRoYW4gY3Jhc2ggdGhlIHdob2xlIHJlY29uY2lsZXIuXG5cbnZhciBmb3JrU3RhY2sgPSBbXTtcbnZhciBmb3JrU3RhY2tJbmRleCA9IDA7XG52YXIgdHJlZUZvcmtQcm92aWRlciA9IG51bGw7XG52YXIgdHJlZUZvcmtDb3VudCA9IDA7XG52YXIgaWRTdGFjayA9IFtdO1xudmFyIGlkU3RhY2tJbmRleCA9IDA7XG52YXIgdHJlZUNvbnRleHRQcm92aWRlciA9IG51bGw7XG52YXIgdHJlZUNvbnRleHRJZCA9IDE7XG52YXIgdHJlZUNvbnRleHRPdmVyZmxvdyA9ICcnO1xuZnVuY3Rpb24gaXNGb3JrZWRDaGlsZCh3b3JrSW5Qcm9ncmVzcykge1xuICB3YXJuSWZOb3RIeWRyYXRpbmcoKTtcbiAgcmV0dXJuICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIEZvcmtlZCkgIT09IE5vRmxhZ3MkMTtcbn1cbmZ1bmN0aW9uIGdldEZvcmtzQXRMZXZlbCh3b3JrSW5Qcm9ncmVzcykge1xuICB3YXJuSWZOb3RIeWRyYXRpbmcoKTtcbiAgcmV0dXJuIHRyZWVGb3JrQ291bnQ7XG59XG5mdW5jdGlvbiBnZXRUcmVlSWQoKSB7XG4gIHZhciBvdmVyZmxvdyA9IHRyZWVDb250ZXh0T3ZlcmZsb3c7XG4gIHZhciBpZFdpdGhMZWFkaW5nQml0ID0gdHJlZUNvbnRleHRJZDtcbiAgdmFyIGlkID0gaWRXaXRoTGVhZGluZ0JpdCAmIH5nZXRMZWFkaW5nQml0KGlkV2l0aExlYWRpbmdCaXQpO1xuICByZXR1cm4gaWQudG9TdHJpbmcoMzIpICsgb3ZlcmZsb3c7XG59XG5mdW5jdGlvbiBwdXNoVHJlZUZvcmsod29ya0luUHJvZ3Jlc3MsIHRvdGFsQ2hpbGRyZW4pIHtcbiAgLy8gVGhpcyBpcyBjYWxsZWQgcmlnaHQgYWZ0ZXIgd2UgcmVjb25jaWxlIGFuIGFycmF5IChvciBpdGVyYXRvcikgb2YgY2hpbGRcbiAgLy8gZmliZXJzLCBiZWNhdXNlIHRoYXQncyB0aGUgb25seSBwbGFjZSB3aGVyZSB3ZSBrbm93IGhvdyBtYW55IGNoaWxkcmVuIGluXG4gIC8vIHRoZSB3aG9sZSBzZXQgd2l0aG91dCBkb2luZyBleHRyYSB3b3JrIGxhdGVyLCBvciBzdG9yaW5nIGFkZHRpb25hbFxuICAvLyBpbmZvcm1hdGlvbiBvbiB0aGUgZmliZXIuXG4gIC8vXG4gIC8vIFRoYXQncyB3aHkgdGhpcyBmdW5jdGlvbiBpcyBzZXBhcmF0ZSBmcm9tIHB1c2hUcmVlSWQg4oCUIGl0J3MgY2FsbGVkIGR1cmluZ1xuICAvLyB0aGUgcmVuZGVyIHBoYXNlIG9mIHRoZSBmb3JrIHBhcmVudCwgbm90IHRoZSBjaGlsZCwgd2hpY2ggaXMgd2hlcmUgd2UgcHVzaFxuICAvLyB0aGUgb3RoZXIgY29udGV4dCB2YWx1ZXMuXG4gIC8vXG4gIC8vIEluIHRoZSBGaXp6IGltcGxlbWVudGF0aW9uIHRoaXMgaXMgbXVjaCBzaW1wbGVyIGJlY2F1c2UgdGhlIGNoaWxkIGlzXG4gIC8vIHJlbmRlcmVkIGluIHRoZSBzYW1lIGNhbGxzdGFjayBhcyB0aGUgcGFyZW50LlxuICAvL1xuICAvLyBJdCBtaWdodCBiZSBiZXR0ZXIgdG8ganVzdCBhZGQgYSBgZm9ya3NgIGZpZWxkIHRvIHRoZSBGaWJlciB0eXBlLiBJdCB3b3VsZFxuICAvLyBtYWtlIHRoaXMgbW9kdWxlIHNpbXBsZXIuXG4gIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuICBmb3JrU3RhY2tbZm9ya1N0YWNrSW5kZXgrK10gPSB0cmVlRm9ya0NvdW50O1xuICBmb3JrU3RhY2tbZm9ya1N0YWNrSW5kZXgrK10gPSB0cmVlRm9ya1Byb3ZpZGVyO1xuICB0cmVlRm9ya1Byb3ZpZGVyID0gd29ya0luUHJvZ3Jlc3M7XG4gIHRyZWVGb3JrQ291bnQgPSB0b3RhbENoaWxkcmVuO1xufVxuZnVuY3Rpb24gcHVzaFRyZWVJZCh3b3JrSW5Qcm9ncmVzcywgdG90YWxDaGlsZHJlbiwgaW5kZXgpIHtcbiAgd2FybklmTm90SHlkcmF0aW5nKCk7XG4gIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRJZDtcbiAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dE92ZXJmbG93O1xuICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0UHJvdmlkZXI7XG4gIHRyZWVDb250ZXh0UHJvdmlkZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgdmFyIGJhc2VJZFdpdGhMZWFkaW5nQml0ID0gdHJlZUNvbnRleHRJZDtcbiAgdmFyIGJhc2VPdmVyZmxvdyA9IHRyZWVDb250ZXh0T3ZlcmZsb3c7IC8vIFRoZSBsZWZ0bW9zdCAxIG1hcmtzIHRoZSBlbmQgb2YgdGhlIHNlcXVlbmNlLCBub24taW5jbHVzaXZlLiBJdCdzIG5vdCBwYXJ0XG4gIC8vIG9mIHRoZSBpZDsgd2UgdXNlIGl0IHRvIGFjY291bnQgZm9yIGxlYWRpbmcgMHMuXG5cbiAgdmFyIGJhc2VMZW5ndGggPSBnZXRCaXRMZW5ndGgoYmFzZUlkV2l0aExlYWRpbmdCaXQpIC0gMTtcbiAgdmFyIGJhc2VJZCA9IGJhc2VJZFdpdGhMZWFkaW5nQml0ICYgfigxIDw8IGJhc2VMZW5ndGgpO1xuICB2YXIgc2xvdCA9IGluZGV4ICsgMTtcbiAgdmFyIGxlbmd0aCA9IGdldEJpdExlbmd0aCh0b3RhbENoaWxkcmVuKSArIGJhc2VMZW5ndGg7IC8vIDMwIGlzIHRoZSBtYXggbGVuZ3RoIHdlIGNhbiBzdG9yZSB3aXRob3V0IG92ZXJmbG93aW5nLCB0YWtpbmcgaW50b1xuICAvLyBjb25zaWRlcmF0aW9uIHRoZSBsZWFkaW5nIDEgd2UgdXNlIHRvIG1hcmsgdGhlIGVuZCBvZiB0aGUgc2VxdWVuY2UuXG5cbiAgaWYgKGxlbmd0aCA+IDMwKSB7XG4gICAgLy8gV2Ugb3ZlcmZsb3dlZCB0aGUgYml0d2lzZS1zYWZlIHJhbmdlLiBGYWxsIGJhY2sgdG8gc2xvd2VyIGFsZ29yaXRobS5cbiAgICAvLyBUaGlzIGJyYW5jaCBhc3N1bWVzIHRoZSBsZW5ndGggb2YgdGhlIGJhc2UgaWQgaXMgZ3JlYXRlciB0aGFuIDU7IGl0IHdvbid0XG4gICAgLy8gd29yayBmb3Igc21hbGxlciBpZHMsIGJlY2F1c2UgeW91IG5lZWQgNSBiaXRzIHBlciBjaGFyYWN0ZXIuXG4gICAgLy9cbiAgICAvLyBXZSBlbmNvZGUgdGhlIGlkIGluIG11bHRpcGxlIHN0ZXBzOiBmaXJzdCB0aGUgYmFzZSBpZCwgdGhlbiB0aGVcbiAgICAvLyByZW1haW5pbmcgZGlnaXRzLlxuICAgIC8vXG4gICAgLy8gRWFjaCA1IGJpdCBzZXF1ZW5jZSBjb3JyZXNwb25kcyB0byBhIHNpbmdsZSBiYXNlIDMyIGNoYXJhY3Rlci4gU28gZm9yXG4gICAgLy8gZXhhbXBsZSwgaWYgdGhlIGN1cnJlbnQgaWQgaXMgMjMgYml0cyBsb25nLCB3ZSBjYW4gY29udmVydCAyMCBvZiB0aG9zZVxuICAgIC8vIGJpdHMgaW50byBhIHN0cmluZyBvZiA0IGNoYXJhY3RlcnMsIHdpdGggMyBiaXRzIGxlZnQgb3Zlci5cbiAgICAvL1xuICAgIC8vIEZpcnN0IGNhbGN1bGF0ZSBob3cgbWFueSBiaXRzIGluIHRoZSBiYXNlIGlkIHJlcHJlc2VudCBhIGNvbXBsZXRlXG4gICAgLy8gc2VxdWVuY2Ugb2YgY2hhcmFjdGVycy5cbiAgICB2YXIgbnVtYmVyT2ZPdmVyZmxvd0JpdHMgPSBiYXNlTGVuZ3RoIC0gYmFzZUxlbmd0aCAlIDU7IC8vIFRoZW4gY3JlYXRlIGEgYml0bWFzayB0aGF0IHNlbGVjdHMgb25seSB0aG9zZSBiaXRzLlxuXG4gICAgdmFyIG5ld092ZXJmbG93Qml0cyA9ICgxIDw8IG51bWJlck9mT3ZlcmZsb3dCaXRzKSAtIDE7IC8vIFNlbGVjdCB0aGUgYml0cywgYW5kIGNvbnZlcnQgdGhlbSB0byBhIGJhc2UgMzIgc3RyaW5nLlxuXG4gICAgdmFyIG5ld092ZXJmbG93ID0gKGJhc2VJZCAmIG5ld092ZXJmbG93Qml0cykudG9TdHJpbmcoMzIpOyAvLyBOb3cgd2UgY2FuIHJlbW92ZSB0aG9zZSBiaXRzIGZyb20gdGhlIGJhc2UgaWQuXG5cbiAgICB2YXIgcmVzdE9mQmFzZUlkID0gYmFzZUlkID4+IG51bWJlck9mT3ZlcmZsb3dCaXRzO1xuICAgIHZhciByZXN0T2ZCYXNlTGVuZ3RoID0gYmFzZUxlbmd0aCAtIG51bWJlck9mT3ZlcmZsb3dCaXRzOyAvLyBGaW5hbGx5LCBlbmNvZGUgdGhlIHJlc3Qgb2YgdGhlIGJpdHMgdXNpbmcgdGhlIG5vcm1hbCBhbGdvcml0aG0uIEJlY2F1c2VcbiAgICAvLyB3ZSBtYWRlIG1vcmUgcm9vbSwgdGhpcyB0aW1lIGl0IHdvbid0IG92ZXJmbG93LlxuXG4gICAgdmFyIHJlc3RPZkxlbmd0aCA9IGdldEJpdExlbmd0aCh0b3RhbENoaWxkcmVuKSArIHJlc3RPZkJhc2VMZW5ndGg7XG4gICAgdmFyIHJlc3RPZk5ld0JpdHMgPSBzbG90IDw8IHJlc3RPZkJhc2VMZW5ndGg7XG4gICAgdmFyIGlkID0gcmVzdE9mTmV3Qml0cyB8IHJlc3RPZkJhc2VJZDtcbiAgICB2YXIgb3ZlcmZsb3cgPSBuZXdPdmVyZmxvdyArIGJhc2VPdmVyZmxvdztcbiAgICB0cmVlQ29udGV4dElkID0gMSA8PCByZXN0T2ZMZW5ndGggfCBpZDtcbiAgICB0cmVlQ29udGV4dE92ZXJmbG93ID0gb3ZlcmZsb3c7XG4gIH0gZWxzZSB7XG4gICAgLy8gTm9ybWFsIHBhdGhcbiAgICB2YXIgbmV3Qml0cyA9IHNsb3QgPDwgYmFzZUxlbmd0aDtcblxuICAgIHZhciBfaWQgPSBuZXdCaXRzIHwgYmFzZUlkO1xuXG4gICAgdmFyIF9vdmVyZmxvdyA9IGJhc2VPdmVyZmxvdztcbiAgICB0cmVlQ29udGV4dElkID0gMSA8PCBsZW5ndGggfCBfaWQ7XG4gICAgdHJlZUNvbnRleHRPdmVyZmxvdyA9IF9vdmVyZmxvdztcbiAgfVxufVxuZnVuY3Rpb24gcHVzaE1hdGVyaWFsaXplZFRyZWVJZCh3b3JrSW5Qcm9ncmVzcykge1xuICB3YXJuSWZOb3RIeWRyYXRpbmcoKTsgLy8gVGhpcyBjb21wb25lbnQgbWF0ZXJpYWxpemVkIGFuIGlkLiBUaGlzIHdpbGwgYWZmZWN0IGFueSBpZHMgdGhhdCBhcHBlYXJcbiAgLy8gaW4gaXRzIGNoaWxkcmVuLlxuXG4gIHZhciByZXR1cm5GaWJlciA9IHdvcmtJblByb2dyZXNzLnJldHVybjtcblxuICBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICB2YXIgbnVtYmVyT2ZGb3JrcyA9IDE7XG4gICAgdmFyIHNsb3RJbmRleCA9IDA7XG4gICAgcHVzaFRyZWVGb3JrKHdvcmtJblByb2dyZXNzLCBudW1iZXJPZkZvcmtzKTtcbiAgICBwdXNoVHJlZUlkKHdvcmtJblByb2dyZXNzLCBudW1iZXJPZkZvcmtzLCBzbG90SW5kZXgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEJpdExlbmd0aChudW1iZXIpIHtcbiAgcmV0dXJuIDMyIC0gY2x6MzIobnVtYmVyKTtcbn1cblxuZnVuY3Rpb24gZ2V0TGVhZGluZ0JpdChpZCkge1xuICByZXR1cm4gMSA8PCBnZXRCaXRMZW5ndGgoaWQpIC0gMTtcbn1cblxuZnVuY3Rpb24gcG9wVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpIHtcbiAgLy8gUmVzdG9yZSB0aGUgcHJldmlvdXMgdmFsdWVzLlxuICAvLyBUaGlzIGlzIGEgYml0IG1vcmUgY29tcGxpY2F0ZWQgdGhhbiBvdGhlciBjb250ZXh0LWxpa2UgbW9kdWxlcyBpbiBGaWJlclxuICAvLyBiZWNhdXNlIHRoZSBzYW1lIEZpYmVyIG1heSBhcHBlYXIgb24gdGhlIHN0YWNrIG11bHRpcGxlIHRpbWVzIGFuZCBmb3JcbiAgLy8gZGlmZmVyZW50IHJlYXNvbnMuIFdlIGhhdmUgdG8ga2VlcCBwb3BwaW5nIHVudGlsIHRoZSB3b3JrLWluLXByb2dyZXNzIGlzXG4gIC8vIG5vIGxvbmdlciBhdCB0aGUgdG9wIG9mIHRoZSBzdGFjay5cbiAgd2hpbGUgKHdvcmtJblByb2dyZXNzID09PSB0cmVlRm9ya1Byb3ZpZGVyKSB7XG4gICAgdHJlZUZvcmtQcm92aWRlciA9IGZvcmtTdGFja1stLWZvcmtTdGFja0luZGV4XTtcbiAgICBmb3JrU3RhY2tbZm9ya1N0YWNrSW5kZXhdID0gbnVsbDtcbiAgICB0cmVlRm9ya0NvdW50ID0gZm9ya1N0YWNrWy0tZm9ya1N0YWNrSW5kZXhdO1xuICAgIGZvcmtTdGFja1tmb3JrU3RhY2tJbmRleF0gPSBudWxsO1xuICB9XG5cbiAgd2hpbGUgKHdvcmtJblByb2dyZXNzID09PSB0cmVlQ29udGV4dFByb3ZpZGVyKSB7XG4gICAgdHJlZUNvbnRleHRQcm92aWRlciA9IGlkU3RhY2tbLS1pZFN0YWNrSW5kZXhdO1xuICAgIGlkU3RhY2tbaWRTdGFja0luZGV4XSA9IG51bGw7XG4gICAgdHJlZUNvbnRleHRPdmVyZmxvdyA9IGlkU3RhY2tbLS1pZFN0YWNrSW5kZXhdO1xuICAgIGlkU3RhY2tbaWRTdGFja0luZGV4XSA9IG51bGw7XG4gICAgdHJlZUNvbnRleHRJZCA9IGlkU3RhY2tbLS1pZFN0YWNrSW5kZXhdO1xuICAgIGlkU3RhY2tbaWRTdGFja0luZGV4XSA9IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGdldFN1c3BlbmRlZFRyZWVDb250ZXh0KCkge1xuICB3YXJuSWZOb3RIeWRyYXRpbmcoKTtcblxuICBpZiAodHJlZUNvbnRleHRQcm92aWRlciAhPT0gbnVsbCkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogdHJlZUNvbnRleHRJZCxcbiAgICAgIG92ZXJmbG93OiB0cmVlQ29udGV4dE92ZXJmbG93XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuZnVuY3Rpb24gcmVzdG9yZVN1c3BlbmRlZFRyZWVDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzdXNwZW5kZWRDb250ZXh0KSB7XG4gIHdhcm5JZk5vdEh5ZHJhdGluZygpO1xuICBpZFN0YWNrW2lkU3RhY2tJbmRleCsrXSA9IHRyZWVDb250ZXh0SWQ7XG4gIGlkU3RhY2tbaWRTdGFja0luZGV4KytdID0gdHJlZUNvbnRleHRPdmVyZmxvdztcbiAgaWRTdGFja1tpZFN0YWNrSW5kZXgrK10gPSB0cmVlQ29udGV4dFByb3ZpZGVyO1xuICB0cmVlQ29udGV4dElkID0gc3VzcGVuZGVkQ29udGV4dC5pZDtcbiAgdHJlZUNvbnRleHRPdmVyZmxvdyA9IHN1c3BlbmRlZENvbnRleHQub3ZlcmZsb3c7XG4gIHRyZWVDb250ZXh0UHJvdmlkZXIgPSB3b3JrSW5Qcm9ncmVzcztcbn1cblxuZnVuY3Rpb24gd2FybklmTm90SHlkcmF0aW5nKCkge1xuICB7XG4gICAgaWYgKCFnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgdG8gYmUgaHlkcmF0aW5nLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSAnICsgJ2FuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgY29udGV4dFN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpO1xudmFyIGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpO1xudmFyIHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpOyAvLyBSZXByZXNlbnRzIHRoZSBuZWFyZXN0IGhvc3QgdHJhbnNpdGlvbiBwcm92aWRlciAoaW4gUmVhY3QgRE9NLCBhIDxmb3JtIC8+KVxuLy8gTk9URTogU2luY2UgZm9ybXMgY2Fubm90IGJlIG5lc3RlZCwgYW5kIHRoaXMgZmVhdHVyZSBpcyBvbmx5IGltcGxlbWVudGVkIGJ5XG4vLyBSZWFjdCBET00sIHdlIGRvbid0IHRlY2huaWNhbGx5IG5lZWQgdGhpcyB0byBiZSBhIHN0YWNrLiBJdCBjb3VsZCBiZSBhIHNpbmdsZVxuLy8gbW9kdWxlIHZhcmlhYmxlIGluc3RlYWQuXG5cbnZhciBob3N0VHJhbnNpdGlvblByb3ZpZGVyQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpOyAvLyBUT0RPOiBUaGlzIHNob3VsZCBpbml0aWFsaXplIHRvIE5vdFBlbmRpbmdUcmFuc2l0aW9uLCBhIGNvbnN0YW50XG4vLyBpbXBvcnRlZCBmcm9tIHRoZSBmaWJlciBjb25maWcuIEhvd2V2ZXIsIGJlY2F1c2Ugb2YgYSBjeWNsZSBpbiB0aGUgbW9kdWxlXG4vLyBncmFwaCwgdGhhdCB2YWx1ZSBpc24ndCBkZWZpbmVkIGR1cmluZyB0aGlzIG1vZHVsZSdzIGluaXRpYWxpemF0aW9uLiBJIGNhbid0XG4vLyB0aGluayBvZiBhIHdheSB0byB3b3JrIGFyb3VuZCB0aGlzIHdpdGhvdXQgbW92aW5nIHRoYXQgdmFsdWUgb3V0IG9mIHRoZVxuLy8gZmliZXIgY29uZmlnLiBGb3Igbm93LCB0aGUgXCJubyBwcm92aWRlclwiIGNhc2UgaXMgaGFuZGxlZCB3aGVuIHJlYWRpbmcsXG4vLyBpbnNpZGUgdXNlSG9zdFRyYW5zaXRpb25TdGF0dXMuXG5cbnZhciBIb3N0VHJhbnNpdGlvbkNvbnRleHQgPSB7XG4gICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gIFByb3ZpZGVyOiBudWxsLFxuICBDb25zdW1lcjogbnVsbCxcbiAgX2N1cnJlbnRWYWx1ZTogbnVsbCxcbiAgX2N1cnJlbnRWYWx1ZTI6IG51bGwsXG4gIF90aHJlYWRDb3VudDogMFxufTtcblxuZnVuY3Rpb24gcmVxdWlyZWRDb250ZXh0KGMpIHtcbiAge1xuICAgIGlmIChjID09PSBudWxsKSB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgaG9zdCBjb250ZXh0IHRvIGV4aXN0LiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgJyArICdpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGM7XG59XG5cbmZ1bmN0aW9uIGdldFJvb3RIb3N0Q29udGFpbmVyKCkge1xuICB2YXIgcm9vdEluc3RhbmNlID0gcmVxdWlyZWRDb250ZXh0KHJvb3RJbnN0YW5jZVN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICByZXR1cm4gcm9vdEluc3RhbmNlO1xufVxuXG5mdW5jdGlvbiBwdXNoSG9zdENvbnRhaW5lcihmaWJlciwgbmV4dFJvb3RJbnN0YW5jZSkge1xuICAvLyBQdXNoIGN1cnJlbnQgcm9vdCBpbnN0YW5jZSBvbnRvIHRoZSBzdGFjaztcbiAgLy8gVGhpcyBhbGxvd3MgdXMgdG8gcmVzZXQgcm9vdCB3aGVuIHBvcnRhbHMgYXJlIHBvcHBlZC5cbiAgcHVzaChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgbmV4dFJvb3RJbnN0YW5jZSwgZmliZXIpOyAvLyBUcmFjayB0aGUgY29udGV4dCBhbmQgdGhlIEZpYmVyIHRoYXQgcHJvdmlkZWQgaXQuXG4gIC8vIFRoaXMgZW5hYmxlcyB1cyB0byBwb3Agb25seSBGaWJlcnMgdGhhdCBwcm92aWRlIHVuaXF1ZSBjb250ZXh0cy5cblxuICBwdXNoKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpOyAvLyBGaW5hbGx5LCB3ZSBuZWVkIHRvIHB1c2ggdGhlIGhvc3QgY29udGV4dCB0byB0aGUgc3RhY2suXG4gIC8vIEhvd2V2ZXIsIHdlIGNhbid0IGp1c3QgY2FsbCBnZXRSb290SG9zdENvbnRleHQoKSBhbmQgcHVzaCBpdCBiZWNhdXNlXG4gIC8vIHdlJ2QgaGF2ZSBhIGRpZmZlcmVudCBudW1iZXIgb2YgZW50cmllcyBvbiB0aGUgc3RhY2sgZGVwZW5kaW5nIG9uXG4gIC8vIHdoZXRoZXIgZ2V0Um9vdEhvc3RDb250ZXh0KCkgdGhyb3dzIHNvbWV3aGVyZSBpbiByZW5kZXJlciBjb2RlIG9yIG5vdC5cbiAgLy8gU28gd2UgcHVzaCBhbiBlbXB0eSB2YWx1ZSBmaXJzdC4gVGhpcyBsZXRzIHVzIHNhZmVseSB1bndpbmQgb24gZXJyb3JzLlxuXG4gIHB1c2goY29udGV4dFN0YWNrQ3Vyc29yLCBudWxsLCBmaWJlcik7XG4gIHZhciBuZXh0Um9vdENvbnRleHQgPSBnZXRSb290SG9zdENvbnRleHQobmV4dFJvb3RJbnN0YW5jZSk7IC8vIE5vdyB0aGF0IHdlIGtub3cgdGhpcyBmdW5jdGlvbiBkb2Vzbid0IHRocm93LCByZXBsYWNlIGl0LlxuXG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcHVzaChjb250ZXh0U3RhY2tDdXJzb3IsIG5leHRSb290Q29udGV4dCwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBwb3BIb3N0Q29udGFpbmVyKGZpYmVyKSB7XG4gIHBvcChjb250ZXh0U3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKGNvbnRleHRGaWJlclN0YWNrQ3Vyc29yLCBmaWJlcik7XG4gIHBvcChyb290SW5zdGFuY2VTdGFja0N1cnNvciwgZmliZXIpO1xufVxuXG5mdW5jdGlvbiBnZXRIb3N0Q29udGV4dCgpIHtcbiAgdmFyIGNvbnRleHQgPSByZXF1aXJlZENvbnRleHQoY29udGV4dFN0YWNrQ3Vyc29yLmN1cnJlbnQpO1xuICByZXR1cm4gY29udGV4dDtcbn1cblxuZnVuY3Rpb24gcHVzaEhvc3RDb250ZXh0KGZpYmVyKSB7XG4gIHtcbiAgICB2YXIgc3RhdGVIb29rID0gZmliZXIubWVtb2l6ZWRTdGF0ZTtcblxuICAgIGlmIChzdGF0ZUhvb2sgIT09IG51bGwpIHtcbiAgICAgIC8vIE9ubHkgcHJvdmlkZSBjb250ZXh0IGlmIHRoaXMgZmliZXIgaGFzIGJlZW4gdXBncmFkZWQgYnkgYSBob3N0XG4gICAgICAvLyB0cmFuc2l0aW9uLiBXZSB1c2UgdGhlIHNhbWUgb3B0aW1pemF0aW9uIGZvciByZWd1bGFyIGhvc3QgY29udGV4dCBiZWxvdy5cbiAgICAgIHB1c2goaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvciwgZmliZXIsIGZpYmVyKTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udGV4dCA9IHJlcXVpcmVkQ29udGV4dChjb250ZXh0U3RhY2tDdXJzb3IuY3VycmVudCk7XG4gIHZhciBuZXh0Q29udGV4dCA9IGdldENoaWxkSG9zdENvbnRleHQoY29udGV4dCwgZmliZXIudHlwZSk7IC8vIERvbid0IHB1c2ggdGhpcyBGaWJlcidzIGNvbnRleHQgdW5sZXNzIGl0J3MgdW5pcXVlLlxuXG4gIGlmIChjb250ZXh0ICE9PSBuZXh0Q29udGV4dCkge1xuICAgIC8vIFRyYWNrIHRoZSBjb250ZXh0IGFuZCB0aGUgRmliZXIgdGhhdCBwcm92aWRlZCBpdC5cbiAgICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gcG9wIG9ubHkgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gICAgcHVzaChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIsIGZpYmVyKTtcbiAgICBwdXNoKGNvbnRleHRTdGFja0N1cnNvciwgbmV4dENvbnRleHQsIGZpYmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BIb3N0Q29udGV4dChmaWJlcikge1xuICBpZiAoY29udGV4dEZpYmVyU3RhY2tDdXJzb3IuY3VycmVudCA9PT0gZmliZXIpIHtcbiAgICAvLyBEbyBub3QgcG9wIHVubGVzcyB0aGlzIEZpYmVyIHByb3ZpZGVkIHRoZSBjdXJyZW50IGNvbnRleHQuXG4gICAgLy8gcHVzaEhvc3RDb250ZXh0KCkgb25seSBwdXNoZXMgRmliZXJzIHRoYXQgcHJvdmlkZSB1bmlxdWUgY29udGV4dHMuXG4gICAgcG9wKGNvbnRleHRTdGFja0N1cnNvciwgZmliZXIpO1xuICAgIHBvcChjb250ZXh0RmliZXJTdGFja0N1cnNvciwgZmliZXIpO1xuICB9XG5cbiAge1xuICAgIGlmIChob3N0VHJhbnNpdGlvblByb3ZpZGVyQ3Vyc29yLmN1cnJlbnQgPT09IGZpYmVyKSB7XG4gICAgICAvLyBEbyBub3QgcG9wIHVubGVzcyB0aGlzIEZpYmVyIHByb3ZpZGVkIHRoZSBjdXJyZW50IGNvbnRleHQuIFRoaXMgaXMgbW9zdGx5XG4gICAgICAvLyBhIHBlcmZvcm1hbmNlIG9wdGltaXphdGlvbiwgYnV0IGNvbnZlbmllbnRseSBpdCBhbHNvIHByZXZlbnRzIGEgcG90ZW50aWFsXG4gICAgICAvLyBkYXRhIHJhY2Ugd2hlcmUgYSBob3N0IHByb3ZpZGVyIGlzIHVwZ3JhZGVkIChpLmUuIG1lbW9pemVkU3RhdGUgYmVjb21lc1xuICAgICAgLy8gbm9uLW51bGwpIGR1cmluZyBhIGNvbmN1cnJlbnQgZXZlbnQuIFRoaXMgaXMgYSBiaXQgb2YgYSBmbGF3IGluIHRoZSB3YXlcbiAgICAgIC8vIHdlIHVwZ3JhZGUgaG9zdCBjb21wb25lbnRzLCBidXQgYmVjYXVzZSB3ZSdyZSBhY2NvdW50aW5nIGZvciBpdCBoZXJlLCBpdFxuICAgICAgLy8gc2hvdWxkIGJlIGZpbmUuXG4gICAgICBwb3AoaG9zdFRyYW5zaXRpb25Qcm92aWRlckN1cnNvciwgZmliZXIpOyAvLyBXaGVuIHBvcHBpbmcgdGhlIHRyYW5zaXRpb24gcHJvdmlkZXIsIHdlIHJlc2V0IHRoZSBjb250ZXh0IHZhbHVlIGJhY2tcbiAgICAgIC8vIHRvIGBudWxsYC4gV2UgY2FuIGRvIHRoaXMgYmVjYXVzZSB5b3UncmUgbm90IGFsbG93ZCB0byBuZXN0IGZvcm1zLiBJZlxuICAgICAgLy8gd2UgYWxsb3dlZCBmb3IgbXVsdGlwbGUgbmVzdGVkIGhvc3QgdHJhbnNpdGlvbiBwcm92aWRlcnMsIHRoZW4gd2UnZFxuICAgICAgLy8gbmVlZCB0byByZXNldCB0aGlzIHRvIHRoZSBwYXJlbnQgcHJvdmlkZXIncyBzdGF0dXMuXG5cbiAgICAgIGlmIChpc1ByaW1hcnlSZW5kZXJlcikge1xuICAgICAgICBIb3N0VHJhbnNpdGlvbkNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBIb3N0VHJhbnNpdGlvbkNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgbWF4Um93TGVuZ3RoID0gMTIwO1xudmFyIGlkZWFsRGVwdGggPSAxNTtcblxuZnVuY3Rpb24gZmluZE5vdGFibGVOb2RlKG5vZGUsIGluZGVudCkge1xuICBpZiAobm9kZS5zZXJ2ZXJQcm9wcyA9PT0gdW5kZWZpbmVkICYmIG5vZGUuc2VydmVyVGFpbC5sZW5ndGggPT09IDAgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgbm9kZS5kaXN0YW5jZUZyb21MZWFmID4gMyAmJiBub2RlLmRpc3RhbmNlRnJvbUxlYWYgPiBpZGVhbERlcHRoIC0gaW5kZW50KSB7XG4gICAgLy8gVGhpcyBpcyBub3QgYW4gaW50ZXJlc3Rpbmcgbm9kZSBmb3IgY29udGV4dHVhbCBwdXJwb3NlcyBzbyB3ZSBjYW4gc2tpcCBpdC5cbiAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkcmVuWzBdO1xuICAgIHJldHVybiBmaW5kTm90YWJsZU5vZGUoY2hpbGQsIGluZGVudCk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gaW5kZW50YXRpb24oaW5kZW50KSB7XG4gIHJldHVybiAnICAnICsgJyAgJy5yZXBlYXQoaW5kZW50KTtcbn1cblxuZnVuY3Rpb24gYWRkZWQoaW5kZW50KSB7XG4gIHJldHVybiAnKyAnICsgJyAgJy5yZXBlYXQoaW5kZW50KTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlZChpbmRlbnQpIHtcbiAgcmV0dXJuICctICcgKyAnICAnLnJlcGVhdChpbmRlbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZUZpYmVyVHlwZShmaWJlcikge1xuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdEhvaXN0YWJsZTpcbiAgICBjYXNlIEhvc3RTaW5nbGV0b246XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgcmV0dXJuIGZpYmVyLnR5cGU7XG5cbiAgICBjYXNlIExhenlDb21wb25lbnQ6XG4gICAgICByZXR1cm4gJ0xhenknO1xuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHJldHVybiAnU3VzcGVuc2UnO1xuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlTGlzdCc7XG5cbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHZhciBmbiA9IGZpYmVyLnR5cGU7XG4gICAgICByZXR1cm4gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSB8fCBudWxsO1xuXG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgdmFyIHJlbmRlciA9IGZpYmVyLnR5cGUucmVuZGVyO1xuICAgICAgcmV0dXJuIHJlbmRlci5kaXNwbGF5TmFtZSB8fCByZW5kZXIubmFtZSB8fCBudWxsO1xuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHZhciBjdHIgPSBmaWJlci50eXBlO1xuICAgICAgcmV0dXJuIGN0ci5kaXNwbGF5TmFtZSB8fCBjdHIubmFtZSB8fCBudWxsO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIFNraXBcbiAgICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbnZhciBuZWVkc0VzY2FwaW5nID0gL1tcIicmPD5cXG5cXHRdLztcblxuZnVuY3Rpb24gZGVzY3JpYmVUZXh0Tm9kZShjb250ZW50LCBtYXhMZW5ndGgpIHtcbiAgaWYgKG5lZWRzRXNjYXBpbmcudGVzdChjb250ZW50KSkge1xuICAgIHZhciBlbmNvZGVkID0gSlNPTi5zdHJpbmdpZnkoY29udGVudCk7XG5cbiAgICBpZiAoZW5jb2RlZC5sZW5ndGggPiBtYXhMZW5ndGggLSAyKSB7XG4gICAgICBpZiAobWF4TGVuZ3RoIDwgOCkge1xuICAgICAgICByZXR1cm4gJ3tcIi4uLlwifSc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAneycgKyBlbmNvZGVkLnNsaWNlKDAsIG1heExlbmd0aCAtIDcpICsgJy4uLlwifSc7XG4gICAgfVxuXG4gICAgcmV0dXJuICd7JyArIGVuY29kZWQgKyAnfSc7XG4gIH0gZWxzZSB7XG4gICAgaWYgKGNvbnRlbnQubGVuZ3RoID4gbWF4TGVuZ3RoKSB7XG4gICAgICBpZiAobWF4TGVuZ3RoIDwgNSkge1xuICAgICAgICByZXR1cm4gJ3tcIi4uLlwifSc7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBjb250ZW50LnNsaWNlKDAsIG1heExlbmd0aCAtIDMpICsgJy4uLic7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVUZXh0RGlmZihjbGllbnRUZXh0LCBzZXJ2ZXJQcm9wcywgaW5kZW50KSB7XG4gIHZhciBtYXhMZW5ndGggPSBtYXhSb3dMZW5ndGggLSBpbmRlbnQgKiAyO1xuXG4gIGlmIChzZXJ2ZXJQcm9wcyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBhZGRlZChpbmRlbnQpICsgZGVzY3JpYmVUZXh0Tm9kZShjbGllbnRUZXh0LCBtYXhMZW5ndGgpICsgJ1xcbic7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHNlcnZlclByb3BzID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzZXJ2ZXJUZXh0ID0gc2VydmVyUHJvcHM7XG4gICAgdmFyIGZpcnN0RGlmZiA9IDA7XG5cbiAgICBmb3IgKDsgZmlyc3REaWZmIDwgc2VydmVyVGV4dC5sZW5ndGggJiYgZmlyc3REaWZmIDwgY2xpZW50VGV4dC5sZW5ndGg7IGZpcnN0RGlmZisrKSB7XG4gICAgICBpZiAoc2VydmVyVGV4dC5jaGFyQ29kZUF0KGZpcnN0RGlmZikgIT09IGNsaWVudFRleHQuY2hhckNvZGVBdChmaXJzdERpZmYpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmaXJzdERpZmYgPiBtYXhMZW5ndGggLSA4ICYmIGZpcnN0RGlmZiA+IDEwKSB7XG4gICAgICAvLyBUaGUgZmlyc3QgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSB0d28gc3RyaW5ncyB3b3VsZCBiZSBjdXQgb2ZmLCBzbyBjdXQgb2ZmIGluXG4gICAgICAvLyB0aGUgYmVnaW5uaW5nIGluc3RlYWQuXG4gICAgICBjbGllbnRUZXh0ID0gJy4uLicgKyBjbGllbnRUZXh0LnNsaWNlKGZpcnN0RGlmZiAtIDgpO1xuICAgICAgc2VydmVyVGV4dCA9ICcuLi4nICsgc2VydmVyVGV4dC5zbGljZShmaXJzdERpZmYgLSA4KTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWRkZWQoaW5kZW50KSArIGRlc2NyaWJlVGV4dE5vZGUoY2xpZW50VGV4dCwgbWF4TGVuZ3RoKSArICdcXG4nICsgcmVtb3ZlZChpbmRlbnQpICsgZGVzY3JpYmVUZXh0Tm9kZShzZXJ2ZXJUZXh0LCBtYXhMZW5ndGgpICsgJ1xcbic7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGluZGVudGF0aW9uKGluZGVudCkgKyBkZXNjcmliZVRleHROb2RlKGNsaWVudFRleHQsIG1heExlbmd0aCkgKyAnXFxuJztcbiAgfVxufVxuXG5mdW5jdGlvbiBvYmplY3ROYW1lKG9iamVjdCkge1xuICAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG4gIHZhciBuYW1lID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iamVjdCk7XG4gIHJldHVybiBuYW1lLnJlcGxhY2UoL15cXFtvYmplY3QgKC4qKVxcXSQvLCBmdW5jdGlvbiAobSwgcDApIHtcbiAgICByZXR1cm4gcDA7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVZhbHVlKHZhbHVlLCBtYXhMZW5ndGgpIHtcbiAgc3dpdGNoICh0eXBlb2YgdmFsdWUpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAge1xuICAgICAgICB2YXIgZW5jb2RlZCA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcblxuICAgICAgICBpZiAoZW5jb2RlZC5sZW5ndGggPiBtYXhMZW5ndGgpIHtcbiAgICAgICAgICBpZiAobWF4TGVuZ3RoIDwgNSkge1xuICAgICAgICAgICAgcmV0dXJuICdcIi4uLlwiJztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gZW5jb2RlZC5zbGljZSgwLCBtYXhMZW5ndGggLSA0KSArICcuLi5cIic7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZW5jb2RlZDtcbiAgICAgIH1cblxuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiAnbnVsbCc7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gJ1suLi5dJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgICAgdmFyIHR5cGUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodmFsdWUudHlwZSk7XG4gICAgICAgICAgcmV0dXJuIHR5cGUgPyAnPCcgKyB0eXBlICsgJz4nIDogJzwuLi4+JztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuYW1lID0gb2JqZWN0TmFtZSh2YWx1ZSk7XG5cbiAgICAgICAgaWYgKG5hbWUgPT09ICdPYmplY3QnKSB7XG4gICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSAnJztcbiAgICAgICAgICBtYXhMZW5ndGggLT0gMjtcblxuICAgICAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGpzb25Qcm9wTmFtZSA9IEpTT04uc3RyaW5naWZ5KHByb3BOYW1lKTtcblxuICAgICAgICAgICAgaWYgKGpzb25Qcm9wTmFtZSAhPT0gJ1wiJyArIHByb3BOYW1lICsgJ1wiJykge1xuICAgICAgICAgICAgICBwcm9wTmFtZSA9IGpzb25Qcm9wTmFtZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWF4TGVuZ3RoIC09IHByb3BOYW1lLmxlbmd0aCAtIDI7XG4gICAgICAgICAgICB2YXIgcHJvcFZhbHVlID0gZGVzY3JpYmVWYWx1ZSh2YWx1ZVtwcm9wTmFtZV0sIG1heExlbmd0aCA8IDE1ID8gbWF4TGVuZ3RoIDogMTUpO1xuICAgICAgICAgICAgbWF4TGVuZ3RoIC09IHByb3BWYWx1ZS5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmIChtYXhMZW5ndGggPCAwKSB7XG4gICAgICAgICAgICAgIHByb3BlcnRpZXMgKz0gcHJvcGVydGllcyA9PT0gJycgPyAnLi4uJyA6ICcsIC4uLic7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcm9wZXJ0aWVzICs9IChwcm9wZXJ0aWVzID09PSAnJyA/ICcnIDogJywnKSArIHByb3BOYW1lICsgJzonICsgcHJvcFZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiAneycgKyBwcm9wZXJ0aWVzICsgJ30nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG5hbWU7XG4gICAgICB9XG5cbiAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICB7XG4gICAgICAgIHZhciBfbmFtZSA9IHZhbHVlLmRpc3BsYXlOYW1lIHx8IHZhbHVlLm5hbWU7XG5cbiAgICAgICAgcmV0dXJuIF9uYW1lID8gJ2Z1bmN0aW9uICcgKyBfbmFtZSA6ICdmdW5jdGlvbic7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXNjcmliZVByb3BWYWx1ZSh2YWx1ZSwgbWF4TGVuZ3RoKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmICFuZWVkc0VzY2FwaW5nLnRlc3QodmFsdWUpKSB7XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA+IG1heExlbmd0aCAtIDIpIHtcbiAgICAgIGlmIChtYXhMZW5ndGggPCA1KSB7XG4gICAgICAgIHJldHVybiAnXCIuLi5cIic7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnXCInICsgdmFsdWUuc2xpY2UoMCwgbWF4TGVuZ3RoIC0gNSkgKyAnLi4uXCInO1xuICAgIH1cblxuICAgIHJldHVybiAnXCInICsgdmFsdWUgKyAnXCInO1xuICB9XG5cbiAgcmV0dXJuICd7JyArIGRlc2NyaWJlVmFsdWUodmFsdWUsIG1heExlbmd0aCAtIDIpICsgJ30nO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZUNvbGxhcHNlZEVsZW1lbnQodHlwZSwgcHJvcHMsIGluZGVudCkge1xuICAvLyBUaGlzIGZ1bmN0aW9uIHRyaWVzIHRvIGZpdCB0aGUgcHJvcHMgaW50byBhIHNpbmdsZSBsaW5lIGZvciBub24tZXNzZW50aWFsIGVsZW1lbnRzLlxuICAvLyBXZSBhbHNvIGlnbm9yZSBjaGlsZHJlbiBiZWNhdXNlIHdlJ3JlIG5vdCBnb2luZyBkZWVwZXIuXG4gIHZhciBtYXhMZW5ndGggPSBtYXhSb3dMZW5ndGggLSBpbmRlbnQgKiAyIC0gdHlwZS5sZW5ndGggLSAyO1xuICB2YXIgY29udGVudCA9ICcnO1xuXG4gIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BzKSB7XG4gICAgaWYgKCFwcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChwcm9wTmFtZSA9PT0gJ2NoaWxkcmVuJykge1xuICAgICAgLy8gSWdub3JlZC5cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBwcm9wVmFsdWUgPSBkZXNjcmliZVByb3BWYWx1ZShwcm9wc1twcm9wTmFtZV0sIDE1KTtcbiAgICBtYXhMZW5ndGggLT0gcHJvcE5hbWUubGVuZ3RoICsgcHJvcFZhbHVlLmxlbmd0aCArIDI7XG5cbiAgICBpZiAobWF4TGVuZ3RoIDwgMCkge1xuICAgICAgY29udGVudCArPSAnIC4uLic7XG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICBjb250ZW50ICs9ICcgJyArIHByb3BOYW1lICsgJz0nICsgcHJvcFZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIGluZGVudGF0aW9uKGluZGVudCkgKyAnPCcgKyB0eXBlICsgY29udGVudCArICc+XFxuJztcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVFeHBhbmRlZEVsZW1lbnQodHlwZSwgcHJvcHMsIHJvd1ByZWZpeCkge1xuICAvLyBUaGlzIGZ1bmN0aW9uIHRyaWVzIHRvIGZpdCB0aGUgcHJvcHMgaW50byBhIHNpbmdsZSBsaW5lIGZvciBub24tZXNzZW50aWFsIGVsZW1lbnRzLlxuICAvLyBXZSBhbHNvIGlnbm9yZSBjaGlsZHJlbiBiZWNhdXNlIHdlJ3JlIG5vdCBnb2luZyBkZWVwZXIuXG4gIHZhciByZW1haW5pbmdSb3dMZW5ndGggPSBtYXhSb3dMZW5ndGggLSByb3dQcmVmaXgubGVuZ3RoIC0gdHlwZS5sZW5ndGg7IC8vIFdlIGFkZCB0aGUgcHJvcGVydGllcyB0byBhIHNldCBzbyB3ZSBjYW4gY2hvb3NlIGxhdGVyIHdoZXRoZXIgd2UnbGwgcHV0IGl0IG9uIG9uZVxuICAvLyBsaW5lIG9yIG11bHRpcGxlIGxpbmVzLlxuXG4gIHZhciBwcm9wZXJ0aWVzID0gW107XG5cbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcHMpIHtcbiAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKHByb3BOYW1lID09PSAnY2hpbGRyZW4nKSB7XG4gICAgICAvLyBJZ25vcmVkLlxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIG1heExlbmd0aCA9IG1heFJvd0xlbmd0aCAtIHJvd1ByZWZpeC5sZW5ndGggLSBwcm9wTmFtZS5sZW5ndGggLSAxO1xuICAgIHZhciBwcm9wVmFsdWUgPSBkZXNjcmliZVByb3BWYWx1ZShwcm9wc1twcm9wTmFtZV0sIG1heExlbmd0aCk7XG4gICAgcmVtYWluaW5nUm93TGVuZ3RoIC09IHByb3BOYW1lLmxlbmd0aCArIHByb3BWYWx1ZS5sZW5ndGggKyAyO1xuICAgIHByb3BlcnRpZXMucHVzaChwcm9wTmFtZSArICc9JyArIHByb3BWYWx1ZSk7XG4gIH1cblxuICBpZiAocHJvcGVydGllcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gcm93UHJlZml4ICsgJzwnICsgdHlwZSArICc+XFxuJztcbiAgfSBlbHNlIGlmIChyZW1haW5pbmdSb3dMZW5ndGggPiAwKSB7XG4gICAgLy8gV2UgY2FuIGZpdCBhbGwgb24gb25lIHJvdy5cbiAgICByZXR1cm4gcm93UHJlZml4ICsgJzwnICsgdHlwZSArICcgJyArIHByb3BlcnRpZXMuam9pbignICcpICsgJz5cXG4nO1xuICB9IGVsc2Uge1xuICAgIC8vIFNwbGl0IGludG8gb25lIHJvdyBwZXIgcHJvcGVydHk6XG4gICAgcmV0dXJuIHJvd1ByZWZpeCArICc8JyArIHR5cGUgKyAnXFxuJyArIHJvd1ByZWZpeCArICcgICcgKyBwcm9wZXJ0aWVzLmpvaW4oJ1xcbicgKyByb3dQcmVmaXggKyAnICAnKSArICdcXG4nICsgcm93UHJlZml4ICsgJz5cXG4nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlUHJvcGVydGllc0RpZmYoY2xpZW50T2JqZWN0LCBzZXJ2ZXJPYmplY3QsIGluZGVudCkge1xuICB2YXIgcHJvcGVydGllcyA9ICcnO1xuICB2YXIgcmVtYWluaW5nU2VydmVyUHJvcGVydGllcyA9IGFzc2lnbih7fSwgc2VydmVyT2JqZWN0KTtcblxuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBjbGllbnRPYmplY3QpIHtcbiAgICBpZiAoIWNsaWVudE9iamVjdC5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGRlbGV0ZSByZW1haW5pbmdTZXJ2ZXJQcm9wZXJ0aWVzW3Byb3BOYW1lXTtcbiAgICB2YXIgbWF4TGVuZ3RoID0gbWF4Um93TGVuZ3RoIC0gaW5kZW50ICogMiAtIHByb3BOYW1lLmxlbmd0aCAtIDI7XG4gICAgdmFyIGNsaWVudFZhbHVlID0gY2xpZW50T2JqZWN0W3Byb3BOYW1lXTtcbiAgICB2YXIgY2xpZW50UHJvcFZhbHVlID0gZGVzY3JpYmVWYWx1ZShjbGllbnRWYWx1ZSwgbWF4TGVuZ3RoKTtcblxuICAgIGlmIChzZXJ2ZXJPYmplY3QuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICB2YXIgc2VydmVyVmFsdWUgPSBzZXJ2ZXJPYmplY3RbcHJvcE5hbWVdO1xuICAgICAgdmFyIHNlcnZlclByb3BWYWx1ZSA9IGRlc2NyaWJlVmFsdWUoc2VydmVyVmFsdWUsIG1heExlbmd0aCk7XG4gICAgICBwcm9wZXJ0aWVzICs9IGFkZGVkKGluZGVudCkgKyBwcm9wTmFtZSArICc6ICcgKyBjbGllbnRQcm9wVmFsdWUgKyAnXFxuJztcbiAgICAgIHByb3BlcnRpZXMgKz0gcmVtb3ZlZChpbmRlbnQpICsgcHJvcE5hbWUgKyAnOiAnICsgc2VydmVyUHJvcFZhbHVlICsgJ1xcbic7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb3BlcnRpZXMgKz0gYWRkZWQoaW5kZW50KSArIHByb3BOYW1lICsgJzogJyArIGNsaWVudFByb3BWYWx1ZSArICdcXG4nO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIF9wcm9wTmFtZSBpbiByZW1haW5pbmdTZXJ2ZXJQcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCFyZW1haW5pbmdTZXJ2ZXJQcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KF9wcm9wTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBfbWF4TGVuZ3RoID0gbWF4Um93TGVuZ3RoIC0gaW5kZW50ICogMiAtIF9wcm9wTmFtZS5sZW5ndGggLSAyO1xuXG4gICAgdmFyIF9zZXJ2ZXJWYWx1ZSA9IHJlbWFpbmluZ1NlcnZlclByb3BlcnRpZXNbX3Byb3BOYW1lXTtcblxuICAgIHZhciBfc2VydmVyUHJvcFZhbHVlID0gZGVzY3JpYmVWYWx1ZShfc2VydmVyVmFsdWUsIF9tYXhMZW5ndGgpO1xuXG4gICAgcHJvcGVydGllcyArPSByZW1vdmVkKGluZGVudCkgKyBfcHJvcE5hbWUgKyAnOiAnICsgX3NlcnZlclByb3BWYWx1ZSArICdcXG4nO1xuICB9XG5cbiAgcmV0dXJuIHByb3BlcnRpZXM7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlRWxlbWVudERpZmYodHlwZSwgY2xpZW50UHJvcHMsIHNlcnZlclByb3BzLCBpbmRlbnQpIHtcbiAgdmFyIGNvbnRlbnQgPSAnJzsgLy8gTWFwcyBhbnkgcHJldmlvdXNseSB1bm1hdGNoZWQgbG93ZXIgY2FzZSBzZXJ2ZXIgcHJvcCBuYW1lIHRvIGl0cyBmdWxsIHByb3AgbmFtZVxuXG4gIHZhciBzZXJ2ZXJQcm9wTmFtZXMgPSBuZXcgTWFwKCk7XG5cbiAgZm9yICh2YXIgcHJvcE5hbWUgaW4gc2VydmVyUHJvcHMpIHtcbiAgICBpZiAoIXNlcnZlclByb3BzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgc2VydmVyUHJvcE5hbWVzLnNldChwcm9wTmFtZS50b0xvd2VyQ2FzZSgpLCBwcm9wTmFtZSk7XG4gIH1cblxuICBpZiAoc2VydmVyUHJvcE5hbWVzLnNpemUgPT09IDEgJiYgc2VydmVyUHJvcE5hbWVzLmhhcygnY2hpbGRyZW4nKSkge1xuICAgIGNvbnRlbnQgKz0gZGVzY3JpYmVFeHBhbmRlZEVsZW1lbnQodHlwZSwgY2xpZW50UHJvcHMsIGluZGVudGF0aW9uKGluZGVudCkpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIF9wcm9wTmFtZTIgaW4gY2xpZW50UHJvcHMpIHtcbiAgICAgIGlmICghY2xpZW50UHJvcHMuaGFzT3duUHJvcGVydHkoX3Byb3BOYW1lMikpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChfcHJvcE5hbWUyID09PSAnY2hpbGRyZW4nKSB7XG4gICAgICAgIC8vIEhhbmRsZWQgYmVsb3cuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF4TGVuZ3RoID0gbWF4Um93TGVuZ3RoIC0gKGluZGVudCArIDEpICogMiAtIF9wcm9wTmFtZTIubGVuZ3RoIC0gMTtcbiAgICAgIHZhciBzZXJ2ZXJQcm9wTmFtZSA9IHNlcnZlclByb3BOYW1lcy5nZXQoX3Byb3BOYW1lMi50b0xvd2VyQ2FzZSgpKTtcblxuICAgICAgaWYgKHNlcnZlclByb3BOYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgc2VydmVyUHJvcE5hbWVzLmRlbGV0ZShfcHJvcE5hbWUyLnRvTG93ZXJDYXNlKCkpOyAvLyBUaGVyZSdzIGEgZGlmZiBoZXJlLlxuXG4gICAgICAgIHZhciBjbGllbnRWYWx1ZSA9IGNsaWVudFByb3BzW19wcm9wTmFtZTJdO1xuICAgICAgICB2YXIgc2VydmVyVmFsdWUgPSBzZXJ2ZXJQcm9wc1tzZXJ2ZXJQcm9wTmFtZV07XG4gICAgICAgIHZhciBjbGllbnRQcm9wVmFsdWUgPSBkZXNjcmliZVByb3BWYWx1ZShjbGllbnRWYWx1ZSwgbWF4TGVuZ3RoKTtcbiAgICAgICAgdmFyIHNlcnZlclByb3BWYWx1ZSA9IGRlc2NyaWJlUHJvcFZhbHVlKHNlcnZlclZhbHVlLCBtYXhMZW5ndGgpO1xuXG4gICAgICAgIGlmICh0eXBlb2YgY2xpZW50VmFsdWUgPT09ICdvYmplY3QnICYmIGNsaWVudFZhbHVlICE9PSBudWxsICYmIHR5cGVvZiBzZXJ2ZXJWYWx1ZSA9PT0gJ29iamVjdCcgJiYgc2VydmVyVmFsdWUgIT09IG51bGwgJiYgb2JqZWN0TmFtZShjbGllbnRWYWx1ZSkgPT09ICdPYmplY3QnICYmIG9iamVjdE5hbWUoc2VydmVyVmFsdWUpID09PSAnT2JqZWN0JyAmJiAoIC8vIE9ubHkgZG8gdGhlIGRpZmYgaWYgdGhlIG9iamVjdCBoYXMgYSBsb3Qgb2Yga2V5cyBvciB3YXMgc2hvcnRlbmVkLlxuICAgICAgICBPYmplY3Qua2V5cyhjbGllbnRWYWx1ZSkubGVuZ3RoID4gMiB8fCBPYmplY3Qua2V5cyhzZXJ2ZXJWYWx1ZSkubGVuZ3RoID4gMiB8fCBjbGllbnRQcm9wVmFsdWUuaW5kZXhPZignLi4uJykgPiAtMSB8fCBzZXJ2ZXJQcm9wVmFsdWUuaW5kZXhPZignLi4uJykgPiAtMSkpIHtcbiAgICAgICAgICAvLyBXZSdyZSBjb21wYXJpbmcgdHdvIHBsYWluIG9iamVjdHMuIFdlIGNhbiBkaWZmIHRoZSBuZXN0ZWQgb2JqZWN0cyBpbnN0ZWFkLlxuICAgICAgICAgIGNvbnRlbnQgKz0gaW5kZW50YXRpb24oaW5kZW50ICsgMSkgKyBfcHJvcE5hbWUyICsgJz17e1xcbicgKyBkZXNjcmliZVByb3BlcnRpZXNEaWZmKGNsaWVudFZhbHVlLCBzZXJ2ZXJWYWx1ZSwgaW5kZW50ICsgMikgKyBpbmRlbnRhdGlvbihpbmRlbnQgKyAxKSArICd9fVxcbic7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGVudCArPSBhZGRlZChpbmRlbnQgKyAxKSArIF9wcm9wTmFtZTIgKyAnPScgKyBjbGllbnRQcm9wVmFsdWUgKyAnXFxuJztcbiAgICAgICAgICBjb250ZW50ICs9IHJlbW92ZWQoaW5kZW50ICsgMSkgKyBfcHJvcE5hbWUyICsgJz0nICsgc2VydmVyUHJvcFZhbHVlICsgJ1xcbic7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENvbnNpZGVyZWQgZXF1YWwuXG4gICAgICAgIGNvbnRlbnQgKz0gaW5kZW50YXRpb24oaW5kZW50ICsgMSkgKyBfcHJvcE5hbWUyICsgJz0nICsgZGVzY3JpYmVQcm9wVmFsdWUoY2xpZW50UHJvcHNbX3Byb3BOYW1lMl0sIG1heExlbmd0aCkgKyAnXFxuJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzZXJ2ZXJQcm9wTmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocHJvcE5hbWUpIHtcbiAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ2NoaWxkcmVuJykge1xuICAgICAgICAvLyBIYW5kbGVkIGJlbG93LlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBtYXhMZW5ndGggPSBtYXhSb3dMZW5ndGggLSAoaW5kZW50ICsgMSkgKiAyIC0gcHJvcE5hbWUubGVuZ3RoIC0gMTtcbiAgICAgIGNvbnRlbnQgKz0gcmVtb3ZlZChpbmRlbnQgKyAxKSArIHByb3BOYW1lICsgJz0nICsgZGVzY3JpYmVQcm9wVmFsdWUoc2VydmVyUHJvcHNbcHJvcE5hbWVdLCBtYXhMZW5ndGgpICsgJ1xcbic7XG4gICAgfSk7XG5cbiAgICBpZiAoY29udGVudCA9PT0gJycpIHtcbiAgICAgIC8vIE5vIHByb3BlcnRpZXNcbiAgICAgIGNvbnRlbnQgPSBpbmRlbnRhdGlvbihpbmRlbnQpICsgJzwnICsgdHlwZSArICc+XFxuJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSGFkIHByb3BlcnRpZXNcbiAgICAgIGNvbnRlbnQgPSBpbmRlbnRhdGlvbihpbmRlbnQpICsgJzwnICsgdHlwZSArICdcXG4nICsgY29udGVudCArIGluZGVudGF0aW9uKGluZGVudCkgKyAnPlxcbic7XG4gICAgfVxuICB9XG5cbiAgdmFyIHNlcnZlckNoaWxkcmVuID0gc2VydmVyUHJvcHMuY2hpbGRyZW47XG4gIHZhciBjbGllbnRDaGlsZHJlbiA9IGNsaWVudFByb3BzLmNoaWxkcmVuO1xuXG4gIGlmICh0eXBlb2Ygc2VydmVyQ2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBzZXJ2ZXJDaGlsZHJlbiA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHNlcnZlckNoaWxkcmVuID09PSAnYmlnaW50Jykge1xuICAgIC8vIFRoZXJlJ3MgYSBkaWZmIG9mIHRoZSBjaGlsZHJlbi5cbiAgICAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hZGRpdGlvbl1cbiAgICB2YXIgc2VydmVyVGV4dCA9ICcnICsgc2VydmVyQ2hpbGRyZW47XG4gICAgdmFyIGNsaWVudFRleHQgPSAnJztcblxuICAgIGlmICh0eXBlb2YgY2xpZW50Q2hpbGRyZW4gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBjbGllbnRDaGlsZHJlbiA9PT0gJ251bWJlcicgfHwgdHlwZW9mIGNsaWVudENoaWxkcmVuID09PSAnYmlnaW50Jykge1xuICAgICAgLy8gJEZsb3dGaXhNZVt1bnNhZmUtYWRkaXRpb25dXG4gICAgICBjbGllbnRUZXh0ID0gJycgKyBjbGllbnRDaGlsZHJlbjtcbiAgICB9XG5cbiAgICBjb250ZW50ICs9IGRlc2NyaWJlVGV4dERpZmYoY2xpZW50VGV4dCwgc2VydmVyVGV4dCwgaW5kZW50ICsgMSk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNsaWVudENoaWxkcmVuID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY2xpZW50Q2hpbGRyZW4gPT09ICdudW1iZXInIHx8IHR5cGVvZiBjbGllbnRDaGlsZHJlbiA9PT0gJ2JpZ2ludCcpIHtcbiAgICAvLyBUaGUgY2xpZW50IGhhcyBjaGlsZHJlbiBidXQgaXQncyBub3QgY29uc2lkZXJlZCBhIGRpZmZlcmVuY2UgZnJvbSB0aGUgc2VydmVyLlxuICAgIC8vICRGbG93Rml4TWVbdW5zYWZlLWFkZGl0aW9uXVxuICAgIGNvbnRlbnQgKz0gZGVzY3JpYmVUZXh0RGlmZignJyArIGNsaWVudENoaWxkcmVuLCB1bmRlZmluZWQsIGluZGVudCArIDEpO1xuICB9XG5cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlU2libGluZ0ZpYmVyKGZpYmVyLCBpbmRlbnQpIHtcbiAgdmFyIHR5cGUgPSBkZXNjcmliZUZpYmVyVHlwZShmaWJlcik7XG5cbiAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAvLyBTa2lwIHRoaXMgdHlwZSBvZiBmaWJlci4gV2UgY3VycmVudGx5IHRyZWF0IHRoaXMgYXMgYSBmcmFnbWVudFxuICAgIC8vIHNvIGl0J3MganVzdCBwYXJ0IG9mIHRoZSBwYXJlbnQncyBjaGlsZHJlbi5cbiAgICB2YXIgZmxhdENvbnRlbnQgPSAnJztcbiAgICB2YXIgY2hpbGRGaWJlciA9IGZpYmVyLmNoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkRmliZXIpIHtcbiAgICAgIGZsYXRDb250ZW50ICs9IGRlc2NyaWJlU2libGluZ0ZpYmVyKGNoaWxkRmliZXIsIGluZGVudCk7XG4gICAgICBjaGlsZEZpYmVyID0gY2hpbGRGaWJlci5zaWJsaW5nO1xuICAgIH1cblxuICAgIHJldHVybiBmbGF0Q29udGVudDtcbiAgfVxuXG4gIHJldHVybiBpbmRlbnRhdGlvbihpbmRlbnQpICsgJzwnICsgdHlwZSArICc+JyArICdcXG4nO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZU5vZGUobm9kZSwgaW5kZW50KSB7XG4gIHZhciBza2lwVG9Ob2RlID0gZmluZE5vdGFibGVOb2RlKG5vZGUsIGluZGVudCk7XG5cbiAgaWYgKHNraXBUb05vZGUgIT09IG5vZGUgJiYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoICE9PSAxIHx8IG5vZGUuY2hpbGRyZW5bMF0gIT09IHNraXBUb05vZGUpKSB7XG4gICAgcmV0dXJuIGluZGVudGF0aW9uKGluZGVudCkgKyAnLi4uXFxuJyArIGRlc2NyaWJlTm9kZShza2lwVG9Ob2RlLCBpbmRlbnQgKyAxKTtcbiAgfSAvLyBQcmVmaXggd2l0aCBhbnkgc2VydmVyIGNvbXBvbmVudHMgZm9yIGNvbnRleHRcblxuXG4gIHZhciBwYXJlbnRDb250ZW50ID0gJyc7XG4gIHZhciBkZWJ1Z0luZm8gPSBub2RlLmZpYmVyLl9kZWJ1Z0luZm87XG5cbiAgaWYgKGRlYnVnSW5mbykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVidWdJbmZvLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgc2VydmVyQ29tcG9uZW50TmFtZSA9IGRlYnVnSW5mb1tpXS5uYW1lO1xuXG4gICAgICBpZiAodHlwZW9mIHNlcnZlckNvbXBvbmVudE5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHBhcmVudENvbnRlbnQgKz0gaW5kZW50YXRpb24oaW5kZW50KSArICc8JyArIHNlcnZlckNvbXBvbmVudE5hbWUgKyAnPicgKyAnXFxuJztcbiAgICAgICAgaW5kZW50Kys7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFNlbGZcblxuXG4gIHZhciBzZWxmQ29udGVudCA9ICcnOyAvLyBXZSB1c2UgdGhlIHBlbmRpbmcgcHJvcHMgc2luY2Ugd2UgbWlnaHQgYmUgZ2VuZXJhdGluZyBhIGRpZmYgYmVmb3JlIHRoZSBjb21wbGV0ZSBwaGFzZVxuICAvLyB3aGVuIHNvbWV0aGluZyB0aHJvd3MuXG5cbiAgdmFyIGNsaWVudFByb3BzID0gbm9kZS5maWJlci5wZW5kaW5nUHJvcHM7XG5cbiAgaWYgKG5vZGUuZmliZXIudGFnID09PSBIb3N0VGV4dCkge1xuICAgIC8vIFRleHQgTm9kZVxuICAgIHNlbGZDb250ZW50ID0gZGVzY3JpYmVUZXh0RGlmZihjbGllbnRQcm9wcywgbm9kZS5zZXJ2ZXJQcm9wcywgaW5kZW50KTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdHlwZSA9IGRlc2NyaWJlRmliZXJUeXBlKG5vZGUuZmliZXIpO1xuXG4gICAgaWYgKHR5cGUgIT09IG51bGwpIHtcbiAgICAgIC8vIEVsZW1lbnQgTm9kZVxuICAgICAgaWYgKG5vZGUuc2VydmVyUHJvcHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBKdXN0IGEgcmVmZXJlbmNlIG5vZGUgZm9yIGNvbnRleHQuXG4gICAgICAgIHNlbGZDb250ZW50ID0gZGVzY3JpYmVDb2xsYXBzZWRFbGVtZW50KHR5cGUsIGNsaWVudFByb3BzLCBpbmRlbnQpO1xuICAgICAgICBpbmRlbnQrKztcbiAgICAgIH0gZWxzZSBpZiAobm9kZS5zZXJ2ZXJQcm9wcyA9PT0gbnVsbCkge1xuICAgICAgICBzZWxmQ29udGVudCA9IGRlc2NyaWJlRXhwYW5kZWRFbGVtZW50KHR5cGUsIGNsaWVudFByb3BzLCBhZGRlZChpbmRlbnQpKTsgLy8gSWYgdGhpcyB3YXMgYW4gaW5zZXJ0aW9uIHdlIHdvbid0IHN0ZXAgZG93biBmdXJ0aGVyLiBBbnkgdGFpbFxuICAgICAgICAvLyBhcmUgY29uc2lkZXJlZCBzaWJsaW5ncyBzbyB3ZSBkb24ndCBpbmRlbnQuXG4gICAgICAgIC8vIFRPRE86IE1vZGVsIHRoaXMgYSBsaXR0bGUgYmV0dGVyLlxuICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygbm9kZS5zZXJ2ZXJQcm9wcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAge1xuICAgICAgICAgIGVycm9yKCdTaG91bGQgbm90IGhhdmUgbWF0Y2hlZCBhIG5vbiBIb3N0VGV4dCBmaWJlciB0byBhIFRleHQgbm9kZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZkNvbnRlbnQgPSBkZXNjcmliZUVsZW1lbnREaWZmKHR5cGUsIGNsaWVudFByb3BzLCBub2RlLnNlcnZlclByb3BzLCBpbmRlbnQpO1xuICAgICAgICBpbmRlbnQrKztcbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ29tcHV0ZSBjaGlsZHJlblxuXG5cbiAgdmFyIGNoaWxkQ29udGVudCA9ICcnO1xuICB2YXIgY2hpbGRGaWJlciA9IG5vZGUuZmliZXIuY2hpbGQ7XG4gIHZhciBkaWZmSWR4ID0gMDtcblxuICB3aGlsZSAoY2hpbGRGaWJlciAmJiBkaWZmSWR4IDwgbm9kZS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICB2YXIgY2hpbGROb2RlID0gbm9kZS5jaGlsZHJlbltkaWZmSWR4XTtcblxuICAgIGlmIChjaGlsZE5vZGUuZmliZXIgPT09IGNoaWxkRmliZXIpIHtcbiAgICAgIC8vIFRoaXMgd2FzIGEgbWF0Y2ggaW4gdGhlIGRpZmYuXG4gICAgICBjaGlsZENvbnRlbnQgKz0gZGVzY3JpYmVOb2RlKGNoaWxkTm9kZSwgaW5kZW50KTtcbiAgICAgIGRpZmZJZHgrKztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyBhbiB1bnJlbGF0ZWQgcHJldmlvdXMgc2libGluZy5cbiAgICAgIGNoaWxkQ29udGVudCArPSBkZXNjcmliZVNpYmxpbmdGaWJlcihjaGlsZEZpYmVyLCBpbmRlbnQpO1xuICAgIH1cblxuICAgIGNoaWxkRmliZXIgPSBjaGlsZEZpYmVyLnNpYmxpbmc7XG4gIH1cblxuICBpZiAoY2hpbGRGaWJlciAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAvLyBJZiB3ZSBoYWQgYW55IGZ1cnRoZXIgc2libGluZ3MgYWZ0ZXIgdGhlIGxhc3QgbWlzbWF0Y2gsIHdlIGNhbid0IGJlIHN1cmUgaWYgaXQnc1xuICAgIC8vIGFjdHVhbGx5IGEgdmFsaWQgbWF0Y2ggc2luY2UgaXQgbWlnaHQgbm90IGhhdmUgZm91bmQgYSBtYXRjaC4gU28gd2UgZXhjbHVkZSBuZXh0XG4gICAgLy8gc2libGluZ3MgdG8gYXZvaWQgY29uZnVzaW9uLlxuICAgIGNoaWxkQ29udGVudCArPSBpbmRlbnRhdGlvbihpbmRlbnQpICsgJy4uLicgKyAnXFxuJztcbiAgfSAvLyBEZWxldGVkIHRhaWwgbm9kZXNcblxuXG4gIHZhciBzZXJ2ZXJUYWlsID0gbm9kZS5zZXJ2ZXJUYWlsO1xuXG4gIGZvciAodmFyIF9pID0gMDsgX2kgPCBzZXJ2ZXJUYWlsLmxlbmd0aDsgX2krKykge1xuICAgIHZhciB0YWlsTm9kZSA9IHNlcnZlclRhaWxbX2ldO1xuXG4gICAgaWYgKHR5cGVvZiB0YWlsTm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFJlbW92ZWQgdGV4dCBub2RlXG4gICAgICBjaGlsZENvbnRlbnQgKz0gcmVtb3ZlZChpbmRlbnQpICsgZGVzY3JpYmVUZXh0Tm9kZSh0YWlsTm9kZSwgbWF4Um93TGVuZ3RoIC0gaW5kZW50ICogMikgKyAnXFxuJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVtb3ZlZCBlbGVtZW50XG4gICAgICBjaGlsZENvbnRlbnQgKz0gZGVzY3JpYmVFeHBhbmRlZEVsZW1lbnQodGFpbE5vZGUudHlwZSwgdGFpbE5vZGUucHJvcHMsIHJlbW92ZWQoaW5kZW50KSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcmVudENvbnRlbnQgKyBzZWxmQ29udGVudCArIGNoaWxkQ29udGVudDtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVEaWZmKHJvb3ROb2RlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuICdcXG5cXG4nICsgZGVzY3JpYmVOb2RlKHJvb3ROb2RlLCAwKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG4vLyBUaGlzIG1heSBoYXZlIGJlZW4gYW4gaW5zZXJ0aW9uIG9yIGEgaHlkcmF0aW9uLlxuXG52YXIgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBudWxsO1xudmFyIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xudmFyIGlzSHlkcmF0aW5nID0gZmFsc2U7IC8vIFRoaXMgZmxhZyBhbGxvd3MgZm9yIHdhcm5pbmcgc3VwcmVzc2lvbiB3aGVuIHdlIGV4cGVjdCB0aGVyZSB0byBiZSBtaXNtYXRjaGVzXG4vLyBkdWUgdG8gZWFybGllciBtaXNtYXRjaGVzIG9yIGEgc3VzcGVuZGVkIGZpYmVyLlxuXG52YXIgZGlkU3VzcGVuZE9yRXJyb3JERVYgPSBmYWxzZTsgLy8gSHlkcmF0aW9uIGRpZmZlcmVuY2VzIGZvdW5kIHRoYXQgaGF2ZW4ndCB5ZXQgYmVlbiBsb2dnZWQuXG5cbnZhciBoeWRyYXRpb25EaWZmUm9vdERFViA9IG51bGw7IC8vIEh5ZHJhdGlvbiBlcnJvcnMgdGhhdCB3ZXJlIHRocm93biBpbnNpZGUgdGhpcyBib3VuZGFyeVxuXG52YXIgaHlkcmF0aW9uRXJyb3JzID0gbnVsbDtcbnZhciByb290T3JTaW5nbGV0b25Db250ZXh0ID0gZmFsc2U7IC8vIEJ1aWxkcyBhIGNvbW1vbiBhbmNlc3RvciB0cmVlIGZyb20gdGhlIHJvb3QgZG93biBmb3IgY29sbGVjdGluZyBkaWZmcy5cblxuZnVuY3Rpb24gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShmaWJlciwgZGlzdGFuY2VGcm9tTGVhZikge1xuICBpZiAoZmliZXIucmV0dXJuID09PSBudWxsKSB7XG4gICAgLy8gV2UncmUgYXQgdGhlIHJvb3QuXG4gICAgaWYgKGh5ZHJhdGlvbkRpZmZSb290REVWID09PSBudWxsKSB7XG4gICAgICBoeWRyYXRpb25EaWZmUm9vdERFViA9IHtcbiAgICAgICAgZmliZXI6IGZpYmVyLFxuICAgICAgICBjaGlsZHJlbjogW10sXG4gICAgICAgIHNlcnZlclByb3BzOiB1bmRlZmluZWQsXG4gICAgICAgIHNlcnZlclRhaWw6IFtdLFxuICAgICAgICBkaXN0YW5jZUZyb21MZWFmOiBkaXN0YW5jZUZyb21MZWFmXG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoaHlkcmF0aW9uRGlmZlJvb3RERVYuZmliZXIgIT09IGZpYmVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1NhdyBtdWx0aXBsZSBoeWRyYXRpb24gZGlmZiByb290cyBpbiBhIHBhc3MuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgfSBlbHNlIGlmIChoeWRyYXRpb25EaWZmUm9vdERFVi5kaXN0YW5jZUZyb21MZWFmID4gZGlzdGFuY2VGcm9tTGVhZikge1xuICAgICAgaHlkcmF0aW9uRGlmZlJvb3RERVYuZGlzdGFuY2VGcm9tTGVhZiA9IGRpc3RhbmNlRnJvbUxlYWY7XG4gICAgfVxuXG4gICAgcmV0dXJuIGh5ZHJhdGlvbkRpZmZSb290REVWO1xuICB9XG5cbiAgdmFyIHNpYmxpbmdzID0gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShmaWJlci5yZXR1cm4sIGRpc3RhbmNlRnJvbUxlYWYgKyAxKS5jaGlsZHJlbjsgLy8gVGhlIHNhbWUgbm9kZSBtYXkgYWxyZWFkeSBleGlzdCBpbiB0aGUgcGFyZW50LiBTaW5jZSB3ZSBjdXJyZW50bHkgYWx3YXlzIHJlbmRlciBkZXB0aCBmaXJzdFxuICAvLyBhbmQgcmVyZW5kZXIgaWYgd2Ugc3VzcGVuZCBvciB0ZXJtaW5hdGUgZWFybHksIGlmIGEgc2hhcmVkIGFuY2VzdG9yIHdhcyBhZGRlZCB3ZSBzaG91bGQgc3RpbGxcbiAgLy8gYmUgaW5zaWRlIG9mIHRoYXQgc2hhcmVkIGFuY2VzdG9yIHdoaWNoIG1lYW5zIGl0IHdhcyB0aGUgbGFzdCBvbmUgdG8gYmUgYWRkZWQuIElmIHRoaXMgY2hhbmdlc1xuICAvLyB3ZSBtYXkgaGF2ZSB0byBzY2FuIHRoZSB3aG9sZSBzZXQuXG5cbiAgaWYgKHNpYmxpbmdzLmxlbmd0aCA+IDAgJiYgc2libGluZ3Nbc2libGluZ3MubGVuZ3RoIC0gMV0uZmliZXIgPT09IGZpYmVyKSB7XG4gICAgdmFyIGV4aXN0aW5nID0gc2libGluZ3Nbc2libGluZ3MubGVuZ3RoIC0gMV07XG5cbiAgICBpZiAoZXhpc3RpbmcuZGlzdGFuY2VGcm9tTGVhZiA+IGRpc3RhbmNlRnJvbUxlYWYpIHtcbiAgICAgIGV4aXN0aW5nLmRpc3RhbmNlRnJvbUxlYWYgPSBkaXN0YW5jZUZyb21MZWFmO1xuICAgIH1cblxuICAgIHJldHVybiBleGlzdGluZztcbiAgfVxuXG4gIHZhciBuZXdOb2RlID0ge1xuICAgIGZpYmVyOiBmaWJlcixcbiAgICBjaGlsZHJlbjogW10sXG4gICAgc2VydmVyUHJvcHM6IHVuZGVmaW5lZCxcbiAgICBzZXJ2ZXJUYWlsOiBbXSxcbiAgICBkaXN0YW5jZUZyb21MZWFmOiBkaXN0YW5jZUZyb21MZWFmXG4gIH07XG4gIHNpYmxpbmdzLnB1c2gobmV3Tm9kZSk7XG4gIHJldHVybiBuZXdOb2RlO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZIeWRyYXRpbmcoKSB7XG4gIHtcbiAgICBpZiAoaXNIeWRyYXRpbmcpIHtcbiAgICAgIGVycm9yKCdXZSBzaG91bGQgbm90IGJlIGh5ZHJhdGluZyBoZXJlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhIGJ1Zy4nKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya0RpZFRocm93V2hpbGVIeWRyYXRpbmdERVYoKSB7XG4gIHtcbiAgICBkaWRTdXNwZW5kT3JFcnJvckRFViA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW50ZXJIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIHBhcmVudEluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG4gIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpbkNvbnRhaW5lcihwYXJlbnRJbnN0YW5jZSk7XG4gIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gIGlzSHlkcmF0aW5nID0gdHJ1ZTtcbiAgaHlkcmF0aW9uRXJyb3JzID0gbnVsbDtcbiAgZGlkU3VzcGVuZE9yRXJyb3JERVYgPSBmYWxzZTtcbiAgaHlkcmF0aW9uRGlmZlJvb3RERVYgPSBudWxsO1xuICByb290T3JTaW5nbGV0b25Db250ZXh0ID0gdHJ1ZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlZW50ZXJIeWRyYXRpb25TdGF0ZUZyb21EZWh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZShmaWJlciwgc3VzcGVuc2VJbnN0YW5jZSwgdHJlZUNvbnRleHQpIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSk7XG4gIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gZmliZXI7XG4gIGlzSHlkcmF0aW5nID0gdHJ1ZTtcbiAgaHlkcmF0aW9uRXJyb3JzID0gbnVsbDtcbiAgZGlkU3VzcGVuZE9yRXJyb3JERVYgPSBmYWxzZTtcbiAgaHlkcmF0aW9uRGlmZlJvb3RERVYgPSBudWxsO1xuICByb290T3JTaW5nbGV0b25Db250ZXh0ID0gZmFsc2U7XG5cbiAgaWYgKHRyZWVDb250ZXh0ICE9PSBudWxsKSB7XG4gICAgcmVzdG9yZVN1c3BlbmRlZFRyZWVDb250ZXh0KGZpYmVyLCB0cmVlQ29udGV4dCk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gd2Fybk5vbkh5ZHJhdGVkSW5zdGFuY2UoZmliZXIsIHJlamVjdGVkQ2FuZGlkYXRlKSB7XG4gIHtcbiAgICBpZiAoZGlkU3VzcGVuZE9yRXJyb3JERVYpIHtcbiAgICAgIC8vIEluc2lkZSBhIGJvdW5kYXJ5IHRoYXQgYWxyZWFkeSBzdXNwZW5kZWQuIFdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcgdGhlXG4gICAgICAvLyBzaWJsaW5ncyBvZiBhIHN1c3BlbmRlZCBub2RlLiBUaGUgbWlzbWF0Y2ggbWF5IGJlIGR1ZSB0byB0aGUgbWlzc2luZ1xuICAgICAgLy8gZGF0YSwgc28gaXQncyBwcm9iYWJseSBhIGZhbHNlIHBvc2l0aXZlLlxuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQWRkIHRoaXMgZmliZXIgdG8gdGhlIGRpZmYgdHJlZS5cblxuXG4gICAgdmFyIGRpZmZOb2RlID0gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShmaWJlciwgMCk7IC8vIFdlIHVzZSBudWxsIGFzIGEgc2lnbmFsIHRoYXQgdGhlcmUgd2FzIG5vIG5vZGUgdG8gbWF0Y2guXG5cbiAgICBkaWZmTm9kZS5zZXJ2ZXJQcm9wcyA9IG51bGw7XG5cbiAgICBpZiAocmVqZWN0ZWRDYW5kaWRhdGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBkZXNjcmlwdGlvbiA9IGRlc2NyaWJlSHlkcmF0YWJsZUluc3RhbmNlRm9yRGV2V2FybmluZ3MocmVqZWN0ZWRDYW5kaWRhdGUpO1xuICAgICAgZGlmZk5vZGUuc2VydmVyVGFpbC5wdXNoKGRlc2NyaXB0aW9uKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5SHlkcmF0ZUluc3RhbmNlKGZpYmVyLCBuZXh0SW5zdGFuY2UsIGhvc3RDb250ZXh0KSB7XG4gIC8vIGZpYmVyIGlzIGEgSG9zdENvbXBvbmVudCBGaWJlclxuICB2YXIgaW5zdGFuY2UgPSBjYW5IeWRyYXRlSW5zdGFuY2UobmV4dEluc3RhbmNlLCBmaWJlci50eXBlLCBmaWJlci5wZW5kaW5nUHJvcHMsIHJvb3RPclNpbmdsZXRvbkNvbnRleHQpO1xuXG4gIGlmIChpbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgIGZpYmVyLnN0YXRlTm9kZSA9IGluc3RhbmNlO1xuXG4gICAge1xuICAgICAgaWYgKCFkaWRTdXNwZW5kT3JFcnJvckRFVikge1xuICAgICAgICB2YXIgZGlmZmVyZW5jZXMgPSBkaWZmSHlkcmF0ZWRQcm9wc0ZvckRldldhcm5pbmdzKGluc3RhbmNlLCBmaWJlci50eXBlLCBmaWJlci5wZW5kaW5nUHJvcHMsIGhvc3RDb250ZXh0KTtcblxuICAgICAgICBpZiAoZGlmZmVyZW5jZXMgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgZGlmZk5vZGUgPSBidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKGZpYmVyLCAwKTtcbiAgICAgICAgICBkaWZmTm9kZS5zZXJ2ZXJQcm9wcyA9IGRpZmZlcmVuY2VzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQoaW5zdGFuY2UpO1xuICAgIHJvb3RPclNpbmdsZXRvbkNvbnRleHQgPSBmYWxzZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gdHJ5SHlkcmF0ZVRleHQoZmliZXIsIG5leHRJbnN0YW5jZSkge1xuICAvLyBmaWJlciBpcyBhIEhvc3RUZXh0IEZpYmVyXG4gIHZhciB0ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICB2YXIgdGV4dEluc3RhbmNlID0gY2FuSHlkcmF0ZVRleHRJbnN0YW5jZShuZXh0SW5zdGFuY2UsIHRleHQsIHJvb3RPclNpbmdsZXRvbkNvbnRleHQpO1xuXG4gIGlmICh0ZXh0SW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICBmaWJlci5zdGF0ZU5vZGUgPSB0ZXh0SW5zdGFuY2U7XG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjsgLy8gVGV4dCBJbnN0YW5jZXMgZG9uJ3QgaGF2ZSBjaGlsZHJlbiBzbyB0aGVyZSdzIG5vdGhpbmcgdG8gaHlkcmF0ZS5cblxuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiB0cnlIeWRyYXRlU3VzcGVuc2UoZmliZXIsIG5leHRJbnN0YW5jZSkge1xuICAvLyBmaWJlciBpcyBhIFN1c3BlbnNlQ29tcG9uZW50IEZpYmVyXG4gIHZhciBzdXNwZW5zZUluc3RhbmNlID0gY2FuSHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UobmV4dEluc3RhbmNlLCByb290T3JTaW5nbGV0b25Db250ZXh0KTtcblxuICBpZiAoc3VzcGVuc2VJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgIHZhciBzdXNwZW5zZVN0YXRlID0ge1xuICAgICAgZGVoeWRyYXRlZDogc3VzcGVuc2VJbnN0YW5jZSxcbiAgICAgIHRyZWVDb250ZXh0OiBnZXRTdXNwZW5kZWRUcmVlQ29udGV4dCgpLFxuICAgICAgcmV0cnlMYW5lOiBPZmZzY3JlZW5MYW5lXG4gICAgfTtcbiAgICBmaWJlci5tZW1vaXplZFN0YXRlID0gc3VzcGVuc2VTdGF0ZTsgLy8gU3RvcmUgdGhlIGRlaHlkcmF0ZWQgZnJhZ21lbnQgYXMgYSBjaGlsZCBmaWJlci5cbiAgICAvLyBUaGlzIHNpbXBsaWZpZXMgdGhlIGNvZGUgZm9yIGdldEhvc3RTaWJsaW5nIGFuZCBkZWxldGluZyBub2RlcyxcbiAgICAvLyBzaW5jZSBpdCBkb2Vzbid0IGhhdmUgdG8gY29uc2lkZXIgYWxsIFN1c3BlbnNlIGJvdW5kYXJpZXMgYW5kXG4gICAgLy8gY2hlY2sgaWYgdGhleSdyZSBkZWh5ZHJhdGVkIG9uZXMgb3Igbm90LlxuXG4gICAgdmFyIGRlaHlkcmF0ZWRGcmFnbWVudCA9IGNyZWF0ZUZpYmVyRnJvbURlaHlkcmF0ZWRGcmFnbWVudChzdXNwZW5zZUluc3RhbmNlKTtcbiAgICBkZWh5ZHJhdGVkRnJhZ21lbnQucmV0dXJuID0gZmliZXI7XG4gICAgZmliZXIuY2hpbGQgPSBkZWh5ZHJhdGVkRnJhZ21lbnQ7XG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjsgLy8gV2hpbGUgYSBTdXNwZW5zZSBJbnN0YW5jZSBkb2VzIGhhdmUgY2hpbGRyZW4sIHdlIHdvbid0IHN0ZXAgaW50b1xuICAgIC8vIGl0IGR1cmluZyB0aGUgZmlyc3QgcGFzcy4gSW5zdGVhZCwgd2UnbGwgcmVlbnRlciBpdCBsYXRlci5cblxuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgSHlkcmF0aW9uTWlzbWF0Y2hFeGNlcHRpb24gPSBuZXcgRXJyb3IoJ0h5ZHJhdGlvbiBNaXNtYXRjaCBFeGNlcHRpb246IFRoaXMgaXMgbm90IGEgcmVhbCBlcnJvciwgYW5kIHNob3VsZCBub3QgbGVhayBpbnRvICcgKyBcInVzZXJzcGFjZS4gSWYgeW91J3JlIHNlZWluZyB0aGlzLCBpdCdzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC5cIik7XG5cbmZ1bmN0aW9uIHRocm93T25IeWRyYXRpb25NaXNtYXRjaChmaWJlcikge1xuICB2YXIgZGlmZiA9ICcnO1xuXG4gIHtcbiAgICAvLyBDb25zdW1lIHRoZSBkaWZmIHJvb3QgZm9yIHRoaXMgbWlzbWF0Y2guXG4gICAgLy8gQW55IG90aGVyIGVycm9ycyB3aWxsIGdldCB0aGVpciBvd24gZGlmZnMuXG4gICAgdmFyIGRpZmZSb290ID0gaHlkcmF0aW9uRGlmZlJvb3RERVY7XG5cbiAgICBpZiAoZGlmZlJvb3QgIT09IG51bGwpIHtcbiAgICAgIGh5ZHJhdGlvbkRpZmZSb290REVWID0gbnVsbDtcbiAgICAgIGRpZmYgPSBkZXNjcmliZURpZmYoZGlmZlJvb3QpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihcIkh5ZHJhdGlvbiBmYWlsZWQgYmVjYXVzZSB0aGUgc2VydmVyIHJlbmRlcmVkIEhUTUwgZGlkbid0IG1hdGNoIHRoZSBjbGllbnQuIEFzIGEgcmVzdWx0IHRoaXMgdHJlZSB3aWxsIGJlIHJlZ2VuZXJhdGVkIG9uIHRoZSBjbGllbnQuIFRoaXMgY2FuIGhhcHBlbiBpZiBhIFNTUi1lZCBDbGllbnQgQ29tcG9uZW50IHVzZWQ6XFxuXCIgKyAnXFxuJyArIFwiLSBBIHNlcnZlci9jbGllbnQgYnJhbmNoIGBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpYC5cXG5cIiArIFwiLSBWYXJpYWJsZSBpbnB1dCBzdWNoIGFzIGBEYXRlLm5vdygpYCBvciBgTWF0aC5yYW5kb20oKWAgd2hpY2ggY2hhbmdlcyBlYWNoIHRpbWUgaXQncyBjYWxsZWQuXFxuXCIgKyBcIi0gRGF0ZSBmb3JtYXR0aW5nIGluIGEgdXNlcidzIGxvY2FsZSB3aGljaCBkb2Vzbid0IG1hdGNoIHRoZSBzZXJ2ZXIuXFxuXCIgKyAnLSBFeHRlcm5hbCBjaGFuZ2luZyBkYXRhIHdpdGhvdXQgc2VuZGluZyBhIHNuYXBzaG90IG9mIGl0IGFsb25nIHdpdGggdGhlIEhUTUwuXFxuJyArICctIEludmFsaWQgSFRNTCB0YWcgbmVzdGluZy5cXG4nICsgJ1xcbicgKyAnSXQgY2FuIGFsc28gaGFwcGVuIGlmIHRoZSBjbGllbnQgaGFzIGEgYnJvd3NlciBleHRlbnNpb24gaW5zdGFsbGVkIHdoaWNoIG1lc3NlcyB3aXRoIHRoZSBIVE1MIGJlZm9yZSBSZWFjdCBsb2FkZWQuXFxuJyArICdcXG4nICsgJ2h0dHBzOi8vcmVhY3QuZGV2L2xpbmsvaHlkcmF0aW9uLW1pc21hdGNoJyArIGRpZmYpO1xuICBxdWV1ZUh5ZHJhdGlvbkVycm9yKGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKGVycm9yLCBmaWJlcikpO1xuICB0aHJvdyBIeWRyYXRpb25NaXNtYXRjaEV4Y2VwdGlvbjtcbn1cblxuZnVuY3Rpb24gY2xhaW1IeWRyYXRhYmxlU2luZ2xldG9uKGZpYmVyKSB7XG4gIGlmIChzdXBwb3J0c1NpbmdsZXRvbnMpIHtcbiAgICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRSb290Q29udGFpbmVyID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcbiAgICB2YXIgY3VycmVudEhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGUgPSByZXNvbHZlU2luZ2xldG9uSW5zdGFuY2UoZmliZXIudHlwZSwgZmliZXIucGVuZGluZ1Byb3BzLCBjdXJyZW50Um9vdENvbnRhaW5lciwgY3VycmVudEhvc3RDb250ZXh0LCBmYWxzZSk7XG5cbiAgICB7XG4gICAgICBpZiAoIWRpZFN1c3BlbmRPckVycm9yREVWKSB7XG4gICAgICAgIHZhciBkaWZmZXJlbmNlcyA9IGRpZmZIeWRyYXRlZFByb3BzRm9yRGV2V2FybmluZ3MoaW5zdGFuY2UsIGZpYmVyLnR5cGUsIGZpYmVyLnBlbmRpbmdQcm9wcywgY3VycmVudEhvc3RDb250ZXh0KTtcblxuICAgICAgICBpZiAoZGlmZmVyZW5jZXMgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgZGlmZk5vZGUgPSBidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKGZpYmVyLCAwKTtcbiAgICAgICAgICBkaWZmTm9kZS5zZXJ2ZXJQcm9wcyA9IGRpZmZlcmVuY2VzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaHlkcmF0aW9uUGFyZW50RmliZXIgPSBmaWJlcjtcbiAgICByb290T3JTaW5nbGV0b25Db250ZXh0ID0gdHJ1ZTtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGQoaW5zdGFuY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUluc3RhbmNlKGZpYmVyKSB7XG4gIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICByZXR1cm47XG4gIH0gLy8gVmFsaWRhdGUgdGhhdCB0aGlzIGlzIG9rIHRvIHJlbmRlciBoZXJlIGJlZm9yZSBhbnkgbWlzbWF0Y2hlcy5cblxuXG4gIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICB2YXIgc2hvdWxkS2VlcFdhcm5pbmcgPSB2YWxpZGF0ZUh5ZHJhdGFibGVJbnN0YW5jZShmaWJlci50eXBlLCBmaWJlci5wZW5kaW5nUHJvcHMsIGN1cnJlbnRIb3N0Q29udGV4dCk7XG4gIHZhciBuZXh0SW5zdGFuY2UgPSBuZXh0SHlkcmF0YWJsZUluc3RhbmNlO1xuXG4gIGlmICghbmV4dEluc3RhbmNlIHx8ICF0cnlIeWRyYXRlSW5zdGFuY2UoZmliZXIsIG5leHRJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0KSkge1xuICAgIGlmIChzaG91bGRLZWVwV2FybmluZykge1xuICAgICAgd2Fybk5vbkh5ZHJhdGVkSW5zdGFuY2UoZmliZXIsIG5leHRJbnN0YW5jZSk7XG4gICAgfVxuXG4gICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGZpYmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVUZXh0SW5zdGFuY2UoZmliZXIpIHtcbiAgaWYgKCFpc0h5ZHJhdGluZykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciB0ZXh0ID0gZmliZXIucGVuZGluZ1Byb3BzO1xuICB2YXIgc2hvdWxkS2VlcFdhcm5pbmcgPSB0cnVlOyAvLyBWYWxpZGF0ZSB0aGF0IHRoaXMgaXMgb2sgdG8gcmVuZGVyIGhlcmUgYmVmb3JlIGFueSBtaXNtYXRjaGVzLlxuXG4gIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuICBzaG91bGRLZWVwV2FybmluZyA9IHZhbGlkYXRlSHlkcmF0YWJsZVRleHRJbnN0YW5jZSh0ZXh0LCBjdXJyZW50SG9zdENvbnRleHQpO1xuICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcblxuICBpZiAoIW5leHRJbnN0YW5jZSB8fCAhdHJ5SHlkcmF0ZVRleHQoZmliZXIsIG5leHRJbnN0YW5jZSkpIHtcbiAgICBpZiAoc2hvdWxkS2VlcFdhcm5pbmcpIHtcbiAgICAgIHdhcm5Ob25IeWRyYXRlZEluc3RhbmNlKGZpYmVyLCBuZXh0SW5zdGFuY2UpO1xuICAgIH1cblxuICAgIHRocm93T25IeWRyYXRpb25NaXNtYXRjaChmaWJlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZShmaWJlcikge1xuICBpZiAoIWlzSHlkcmF0aW5nKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG5cbiAgaWYgKCFuZXh0SW5zdGFuY2UgfHwgIXRyeUh5ZHJhdGVTdXNwZW5zZShmaWJlciwgbmV4dEluc3RhbmNlKSkge1xuICAgIHdhcm5Ob25IeWRyYXRlZEluc3RhbmNlKGZpYmVyLCBuZXh0SW5zdGFuY2UpO1xuICAgIHRocm93T25IeWRyYXRpb25NaXNtYXRjaChmaWJlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlRm9ybU1hcmtlckluc3RhbmNlKGZpYmVyKSB7XG4gIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBpZiAobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSkge1xuICAgIHZhciBtYXJrZXJJbnN0YW5jZSA9IGNhbkh5ZHJhdGVGb3JtU3RhdGVNYXJrZXIobmV4dEh5ZHJhdGFibGVJbnN0YW5jZSwgcm9vdE9yU2luZ2xldG9uQ29udGV4dCk7XG5cbiAgICBpZiAobWFya2VySW5zdGFuY2UpIHtcbiAgICAgIC8vIEZvdW5kIHRoZSBtYXJrZXIgaW5zdGFuY2UuXG4gICAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG1hcmtlckluc3RhbmNlKTsgLy8gUmV0dXJuIHRydWUgaWYgdGhpcyBtYXJrZXIgaW5zdGFuY2Ugc2hvdWxkIHVzZSB0aGUgc3RhdGUgcGFzc2VkXG4gICAgICAvLyB0byBoeWRyYXRlUm9vdC5cbiAgICAgIC8vIFRPRE86IEFzIGFuIG9wdGltaXphdGlvbiwgRml6eiBzaG91bGQgb25seSBlbWl0IHRoZXNlIG1hcmtlcnMgaWYgZm9ybVxuICAgICAgLy8gc3RhdGUgaXMgcGFzc2VkIGF0IHRoZSByb290LlxuXG4gICAgICByZXR1cm4gaXNGb3JtU3RhdGVNYXJrZXJNYXRjaGluZyhtYXJrZXJJbnN0YW5jZSk7XG4gICAgfVxuICB9IC8vIFNob3VsZCBoYXZlIGZvdW5kIGEgbWFya2VyIGluc3RhbmNlLiBUaHJvdyBhbiBlcnJvciB0byB0cmlnZ2VyIGNsaWVudFxuICAvLyByZW5kZXJpbmcuIFdlIGRvbid0IGJvdGhlciB0byBjaGVjayBpZiB3ZSdyZSBpbiBhIGNvbmN1cnJlbnQgcm9vdCBiZWNhdXNlXG4gIC8vIHVzZUFjdGlvblN0YXRlIGlzIGEgbmV3IEFQSSwgc28gYmFja3dhcmRzIGNvbXBhdCBpcyBub3QgYW4gaXNzdWUuXG5cblxuICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goZmliZXIpO1xuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UoZmliZXIsIGhvc3RDb250ZXh0KSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0SW5zdGFuY2UoKSB0byBuZXZlciBiZSBjYWxsZWQuICcgKyAnVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgdmFyIGRpZEh5ZHJhdGUgPSBoeWRyYXRlSW5zdGFuY2UoaW5zdGFuY2UsIGZpYmVyLnR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMsIGhvc3RDb250ZXh0LCBmaWJlcik7XG5cbiAgaWYgKCFkaWRIeWRyYXRlICYmIGZhdm9yU2FmZXR5T3Zlckh5ZHJhdGlvblBlcmYpIHtcbiAgICB0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2goZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKGZpYmVyKSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlKCkgdG8gbmV2ZXIgYmUgY2FsbGVkLiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICB2YXIgdGV4dEluc3RhbmNlID0gZmliZXIuc3RhdGVOb2RlO1xuICB2YXIgdGV4dENvbnRlbnQgPSBmaWJlci5tZW1vaXplZFByb3BzO1xuICB2YXIgc2hvdWxkV2FybklmTWlzbWF0Y2hEZXYgPSAhZGlkU3VzcGVuZE9yRXJyb3JERVY7XG4gIHZhciBwYXJlbnRQcm9wcyA9IG51bGw7IC8vIFdlIGFzc3VtZSB0aGF0IHByZXBhcmVUb0h5ZHJhdGVIb3N0VGV4dEluc3RhbmNlIGlzIGNhbGxlZCBpbiBhIGNvbnRleHQgd2hlcmUgdGhlXG4gIC8vIGh5ZHJhdGlvbiBwYXJlbnQgaXMgdGhlIHBhcmVudCBob3N0IGNvbXBvbmVudCBvZiB0aGlzIGhvc3QgdGV4dC5cblxuICB2YXIgcmV0dXJuRmliZXIgPSBoeWRyYXRpb25QYXJlbnRGaWJlcjtcblxuICBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICBzd2l0Y2ggKHJldHVybkZpYmVyLnRhZykge1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChzaG91bGRXYXJuSWZNaXNtYXRjaERldikge1xuICAgICAgICAgICAgICB2YXIgZGlmZmVyZW5jZSA9IGRpZmZIeWRyYXRlZFRleHRGb3JEZXZXYXJuaW5ncyh0ZXh0SW5zdGFuY2UsIHRleHRDb250ZW50LCBwYXJlbnRQcm9wcyk7XG5cbiAgICAgICAgICAgICAgaWYgKGRpZmZlcmVuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlmZk5vZGUgPSBidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKGZpYmVyLCAwKTtcbiAgICAgICAgICAgICAgICBkaWZmTm9kZS5zZXJ2ZXJQcm9wcyA9IGRpZmZlcmVuY2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBjYXNlIEhvc3RTaW5nbGV0b246XG4gICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBwYXJlbnRQcm9wcyA9IHJldHVybkZpYmVyLm1lbW9pemVkUHJvcHM7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkV2FybklmTWlzbWF0Y2hEZXYpIHtcbiAgICAgICAgICAgICAgdmFyIF9kaWZmZXJlbmNlID0gZGlmZkh5ZHJhdGVkVGV4dEZvckRldldhcm5pbmdzKHRleHRJbnN0YW5jZSwgdGV4dENvbnRlbnQsIHBhcmVudFByb3BzKTtcblxuICAgICAgICAgICAgICBpZiAoX2RpZmZlcmVuY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2RpZmZOb2RlID0gYnVpbGRIeWRyYXRpb25EaWZmTm9kZShmaWJlciwgMCk7XG5cbiAgICAgICAgICAgICAgICBfZGlmZk5vZGUuc2VydmVyUHJvcHMgPSBfZGlmZmVyZW5jZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSAvLyBUT0RPOiBXaGF0IGlmIGl0J3MgYSBTdXNwZW5zZUluc3RhbmNlP1xuXG4gIH1cblxuICB2YXIgZGlkSHlkcmF0ZSA9IGh5ZHJhdGVUZXh0SW5zdGFuY2UodGV4dEluc3RhbmNlLCB0ZXh0Q29udGVudCwgZmliZXIsIHBhcmVudFByb3BzKTtcblxuICBpZiAoIWRpZEh5ZHJhdGUgJiYgZmF2b3JTYWZldHlPdmVySHlkcmF0aW9uUGVyZikge1xuICAgIHRocm93T25IeWRyYXRpb25NaXNtYXRjaChmaWJlcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlcGFyZVRvSHlkcmF0ZUhvc3RTdXNwZW5zZUluc3RhbmNlKGZpYmVyKSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHByZXBhcmVUb0h5ZHJhdGVIb3N0U3VzcGVuc2VJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG5cbiAgdmFyIHN1c3BlbnNlU3RhdGUgPSBmaWJlci5tZW1vaXplZFN0YXRlO1xuICB2YXIgc3VzcGVuc2VJbnN0YW5jZSA9IHN1c3BlbnNlU3RhdGUgIT09IG51bGwgPyBzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQgOiBudWxsO1xuXG4gIGlmICghc3VzcGVuc2VJbnN0YW5jZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gaGF2ZSBhIGh5ZHJhdGVkIHN1c3BlbnNlIGluc3RhbmNlLiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICBoeWRyYXRlU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlLCBmaWJlcik7XG59XG5cbmZ1bmN0aW9uIHNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UoZmliZXIpIHtcbiAgaWYgKCFzdXBwb3J0c0h5ZHJhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgc2tpcFBhc3REZWh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZSgpIHRvIG5ldmVyIGJlIGNhbGxlZC4gJyArICdUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9XG5cbiAgdmFyIHN1c3BlbnNlU3RhdGUgPSBmaWJlci5tZW1vaXplZFN0YXRlO1xuICB2YXIgc3VzcGVuc2VJbnN0YW5jZSA9IHN1c3BlbnNlU3RhdGUgIT09IG51bGwgPyBzdXNwZW5zZVN0YXRlLmRlaHlkcmF0ZWQgOiBudWxsO1xuXG4gIGlmICghc3VzcGVuc2VJbnN0YW5jZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdG8gaGF2ZSBhIGh5ZHJhdGVkIHN1c3BlbnNlIGluc3RhbmNlLiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cblxuICByZXR1cm4gZ2V0TmV4dEh5ZHJhdGFibGVJbnN0YW5jZUFmdGVyU3VzcGVuc2VJbnN0YW5jZShzdXNwZW5zZUluc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcikge1xuICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IGZpYmVyLnJldHVybjtcblxuICB3aGlsZSAoaHlkcmF0aW9uUGFyZW50RmliZXIpIHtcbiAgICBzd2l0Y2ggKGh5ZHJhdGlvblBhcmVudEZpYmVyLnRhZykge1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICAgICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcblxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgICAgcm9vdE9yU2luZ2xldG9uQ29udGV4dCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGh5ZHJhdGlvblBhcmVudEZpYmVyID0gaHlkcmF0aW9uUGFyZW50RmliZXIucmV0dXJuO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BIeWRyYXRpb25TdGF0ZShmaWJlcikge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKGZpYmVyICE9PSBoeWRyYXRpb25QYXJlbnRGaWJlcikge1xuICAgIC8vIFdlJ3JlIGRlZXBlciB0aGFuIHRoZSBjdXJyZW50IGh5ZHJhdGlvbiBjb250ZXh0LCBpbnNpZGUgYW4gaW5zZXJ0ZWRcbiAgICAvLyB0cmVlLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICghaXNIeWRyYXRpbmcpIHtcbiAgICAvLyBJZiB3ZSdyZSBub3QgY3VycmVudGx5IGh5ZHJhdGluZyBidXQgd2UncmUgaW4gYSBoeWRyYXRpb24gY29udGV4dCwgdGhlblxuICAgIC8vIHdlIHdlcmUgYW4gaW5zZXJ0aW9uIGFuZCBub3cgbmVlZCB0byBwb3AgdXAgcmVlbnRlciBoeWRyYXRpb24gb2Ygb3VyXG4gICAgLy8gc2libGluZ3MuXG4gICAgcG9wVG9OZXh0SG9zdFBhcmVudChmaWJlcik7XG4gICAgaXNIeWRyYXRpbmcgPSB0cnVlO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBzaG91bGRDbGVhciA9IGZhbHNlO1xuXG4gIGlmIChzdXBwb3J0c1NpbmdsZXRvbnMpIHtcbiAgICAvLyBXaXRoIGZsb2F0IHdlIG5ldmVyIGNsZWFyIHRoZSBSb290LCBvciBTaW5nbGV0b24gaW5zdGFuY2VzLiBXZSBhbHNvIGRvIG5vdCBjbGVhciBJbnN0YW5jZXNcbiAgICAvLyB0aGF0IGhhdmUgc2luZ2xldG9uIHRleHQgY29udGVudFxuICAgIGlmIChmaWJlci50YWcgIT09IEhvc3RSb290ICYmIGZpYmVyLnRhZyAhPT0gSG9zdFNpbmdsZXRvbiAmJiAhKGZpYmVyLnRhZyA9PT0gSG9zdENvbXBvbmVudCAmJiAoIXNob3VsZERlbGV0ZVVuaHlkcmF0ZWRUYWlsSW5zdGFuY2VzKGZpYmVyLnR5cGUpIHx8IHNob3VsZFNldFRleHRDb250ZW50KGZpYmVyLnR5cGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpKSkpIHtcbiAgICAgIHNob3VsZENsZWFyID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBhbnkgcmVtYWluaW5nIGh5ZHJhdGFibGUgbm9kZXMsIHdlIG5lZWQgdG8gZGVsZXRlIHRoZW0gbm93LlxuICAgIC8vIFdlIG9ubHkgZG8gdGhpcyBkZWVwZXIgdGhhbiBoZWFkIGFuZCBib2R5IHNpbmNlIHRoZXkgdGVuZCB0byBoYXZlIHJhbmRvbVxuICAgIC8vIG90aGVyIG5vZGVzIGluIHRoZW0uIFdlIGFsc28gaWdub3JlIGNvbXBvbmVudHMgd2l0aCBwdXJlIHRleHQgY29udGVudCBpblxuICAgIC8vIHNpZGUgb2YgdGhlbS4gV2UgYWxzbyBkb24ndCBkZWxldGUgYW55dGhpbmcgaW5zaWRlIHRoZSByb290IGNvbnRhaW5lci5cbiAgICBpZiAoZmliZXIudGFnICE9PSBIb3N0Um9vdCAmJiAoZmliZXIudGFnICE9PSBIb3N0Q29tcG9uZW50IHx8IHNob3VsZERlbGV0ZVVuaHlkcmF0ZWRUYWlsSW5zdGFuY2VzKGZpYmVyLnR5cGUpICYmICFzaG91bGRTZXRUZXh0Q29udGVudChmaWJlci50eXBlLCBmaWJlci5tZW1vaXplZFByb3BzKSkpIHtcbiAgICAgIHNob3VsZENsZWFyID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoc2hvdWxkQ2xlYXIpIHtcbiAgICB2YXIgbmV4dEluc3RhbmNlID0gbmV4dEh5ZHJhdGFibGVJbnN0YW5jZTtcblxuICAgIGlmIChuZXh0SW5zdGFuY2UpIHtcbiAgICAgIHdhcm5JZlVuaHlkcmF0ZWRUYWlsTm9kZXMoZmliZXIpO1xuICAgICAgdGhyb3dPbkh5ZHJhdGlvbk1pc21hdGNoKGZpYmVyKTtcbiAgICB9XG4gIH1cblxuICBwb3BUb05leHRIb3N0UGFyZW50KGZpYmVyKTtcblxuICBpZiAoZmliZXIudGFnID09PSBTdXNwZW5zZUNvbXBvbmVudCkge1xuICAgIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBza2lwUGFzdERlaHlkcmF0ZWRTdXNwZW5zZUluc3RhbmNlKGZpYmVyKTtcbiAgfSBlbHNlIHtcbiAgICBuZXh0SHlkcmF0YWJsZUluc3RhbmNlID0gaHlkcmF0aW9uUGFyZW50RmliZXIgPyBnZXROZXh0SHlkcmF0YWJsZVNpYmxpbmcoZmliZXIuc3RhdGVOb2RlKSA6IG51bGw7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gd2FybklmVW5oeWRyYXRlZFRhaWxOb2RlcyhmaWJlcikge1xuICB7XG4gICAgdmFyIG5leHRJbnN0YW5jZSA9IG5leHRIeWRyYXRhYmxlSW5zdGFuY2U7XG5cbiAgICB3aGlsZSAobmV4dEluc3RhbmNlKSB7XG4gICAgICB2YXIgZGlmZk5vZGUgPSBidWlsZEh5ZHJhdGlvbkRpZmZOb2RlKGZpYmVyLCAwKTtcbiAgICAgIHZhciBkZXNjcmlwdGlvbiA9IGRlc2NyaWJlSHlkcmF0YWJsZUluc3RhbmNlRm9yRGV2V2FybmluZ3MobmV4dEluc3RhbmNlKTtcbiAgICAgIGRpZmZOb2RlLnNlcnZlclRhaWwucHVzaChkZXNjcmlwdGlvbik7XG5cbiAgICAgIGlmIChkZXNjcmlwdGlvbi50eXBlID09PSAnU3VzcGVuc2UnKSB7XG4gICAgICAgIHZhciBzdXNwZW5zZUluc3RhbmNlID0gbmV4dEluc3RhbmNlO1xuICAgICAgICBuZXh0SW5zdGFuY2UgPSBnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlKHN1c3BlbnNlSW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dEluc3RhbmNlID0gZ2V0TmV4dEh5ZHJhdGFibGVTaWJsaW5nKG5leHRJbnN0YW5jZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc2V0SHlkcmF0aW9uU3RhdGUoKSB7XG4gIGlmICghc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBoeWRyYXRpb25QYXJlbnRGaWJlciA9IG51bGw7XG4gIG5leHRIeWRyYXRhYmxlSW5zdGFuY2UgPSBudWxsO1xuICBpc0h5ZHJhdGluZyA9IGZhbHNlO1xuICBkaWRTdXNwZW5kT3JFcnJvckRFViA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiB1cGdyYWRlSHlkcmF0aW9uRXJyb3JzVG9SZWNvdmVyYWJsZSgpIHtcbiAgaWYgKGh5ZHJhdGlvbkVycm9ycyAhPT0gbnVsbCkge1xuICAgIC8vIFN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQgYSBmb3JjZWQgY2xpZW50IHJlbmRlci4gVGhlIGVycm9ycyB0aGF0IG9jY3VycmVkXG4gICAgLy8gZHVyaW5nIHRoZSBoeWRyYXRpb24gYXR0ZW1wdCBhcmUgbm93IHJlY292ZXJlZC4gV2Ugd2lsbCBsb2cgdGhlbSBpblxuICAgIC8vIGNvbW1pdCBwaGFzZSwgb25jZSB0aGUgZW50aXJlIHRyZWUgaGFzIGZpbmlzaGVkLlxuICAgIHF1ZXVlUmVjb3ZlcmFibGVFcnJvcnMoaHlkcmF0aW9uRXJyb3JzKTtcbiAgICBoeWRyYXRpb25FcnJvcnMgPSBudWxsO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldElzSHlkcmF0aW5nKCkge1xuICByZXR1cm4gaXNIeWRyYXRpbmc7XG59XG5cbmZ1bmN0aW9uIHF1ZXVlSHlkcmF0aW9uRXJyb3IoZXJyb3IpIHtcbiAgaWYgKGh5ZHJhdGlvbkVycm9ycyA9PT0gbnVsbCkge1xuICAgIGh5ZHJhdGlvbkVycm9ycyA9IFtlcnJvcl07XG4gIH0gZWxzZSB7XG4gICAgaHlkcmF0aW9uRXJyb3JzLnB1c2goZXJyb3IpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0UGVuZGluZ0h5ZHJhdGlvbldhcm5pbmdzKCkge1xuICB7XG4gICAgLy8gSWYgd2UgaGF2ZW4ndCB5ZXQgdGhyb3duIGFueSBoeWRyYXRpb24gZXJyb3JzIGJ5IHRoZSB0aW1lIHdlIHJlYWNoIHRoZSBlbmQgd2UndmUgc3VjY2Vzc2Z1bGx5XG4gICAgLy8gaHlkcmF0ZWQsIGhvd2V2ZXIsIHdlIG1pZ2h0IHN0aWxsIGhhdmUgREVWLW9ubHkgbWlzbWF0Y2hlcyB0aGF0IHdlIGxvZyBub3cuXG4gICAgdmFyIGRpZmZSb290ID0gaHlkcmF0aW9uRGlmZlJvb3RERVY7XG5cbiAgICBpZiAoZGlmZlJvb3QgIT09IG51bGwpIHtcbiAgICAgIGh5ZHJhdGlvbkRpZmZSb290REVWID0gbnVsbDtcbiAgICAgIHZhciBkaWZmID0gZGVzY3JpYmVEaWZmKGRpZmZSb290KTtcblxuICAgICAgZXJyb3IoXCJBIHRyZWUgaHlkcmF0ZWQgYnV0IHNvbWUgYXR0cmlidXRlcyBvZiB0aGUgc2VydmVyIHJlbmRlcmVkIEhUTUwgZGlkbid0IG1hdGNoIHRoZSBjbGllbnQgcHJvcGVydGllcy4gVGhpcyB3b24ndCBiZSBwYXRjaGVkIHVwLiBcIiArICdUaGlzIGNhbiBoYXBwZW4gaWYgYSBTU1ItZWQgQ2xpZW50IENvbXBvbmVudCB1c2VkOlxcbicgKyAnXFxuJyArIFwiLSBBIHNlcnZlci9jbGllbnQgYnJhbmNoIGBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpYC5cXG5cIiArIFwiLSBWYXJpYWJsZSBpbnB1dCBzdWNoIGFzIGBEYXRlLm5vdygpYCBvciBgTWF0aC5yYW5kb20oKWAgd2hpY2ggY2hhbmdlcyBlYWNoIHRpbWUgaXQncyBjYWxsZWQuXFxuXCIgKyBcIi0gRGF0ZSBmb3JtYXR0aW5nIGluIGEgdXNlcidzIGxvY2FsZSB3aGljaCBkb2Vzbid0IG1hdGNoIHRoZSBzZXJ2ZXIuXFxuXCIgKyAnLSBFeHRlcm5hbCBjaGFuZ2luZyBkYXRhIHdpdGhvdXQgc2VuZGluZyBhIHNuYXBzaG90IG9mIGl0IGFsb25nIHdpdGggdGhlIEhUTUwuXFxuJyArICctIEludmFsaWQgSFRNTCB0YWcgbmVzdGluZy5cXG4nICsgJ1xcbicgKyAnSXQgY2FuIGFsc28gaGFwcGVuIGlmIHRoZSBjbGllbnQgaGFzIGEgYnJvd3NlciBleHRlbnNpb24gaW5zdGFsbGVkIHdoaWNoIG1lc3NlcyB3aXRoIHRoZSBIVE1MIGJlZm9yZSBSZWFjdCBsb2FkZWQuXFxuJyArICdcXG4nICsgJyVzJXMnLCAnaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9oeWRyYXRpb24tbWlzbWF0Y2gnLCBkaWZmKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gd2Ugd2FpdCB1bnRpbCB0aGUgY3VycmVudCByZW5kZXIgaXMgb3ZlciAoZWl0aGVyIGZpbmlzaGVkIG9yIGludGVycnVwdGVkKVxuLy8gYmVmb3JlIGFkZGluZyBpdCB0byB0aGUgZmliZXIvaG9vayBxdWV1ZS4gUHVzaCB0byB0aGlzIGFycmF5IHNvIHdlIGNhblxuLy8gYWNjZXNzIHRoZSBxdWV1ZSwgZmliZXIsIHVwZGF0ZSwgZXQgYWwgbGF0ZXIuXG5cbnZhciBjb25jdXJyZW50UXVldWVzID0gW107XG52YXIgY29uY3VycmVudFF1ZXVlc0luZGV4ID0gMDtcbnZhciBjb25jdXJyZW50bHlVcGRhdGVkTGFuZXMgPSBOb0xhbmVzO1xuZnVuY3Rpb24gZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcygpIHtcbiAgdmFyIGVuZEluZGV4ID0gY29uY3VycmVudFF1ZXVlc0luZGV4O1xuICBjb25jdXJyZW50UXVldWVzSW5kZXggPSAwO1xuICBjb25jdXJyZW50bHlVcGRhdGVkTGFuZXMgPSBOb0xhbmVzO1xuICB2YXIgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBlbmRJbmRleCkge1xuICAgIHZhciBmaWJlciA9IGNvbmN1cnJlbnRRdWV1ZXNbaV07XG4gICAgY29uY3VycmVudFF1ZXVlc1tpKytdID0gbnVsbDtcbiAgICB2YXIgcXVldWUgPSBjb25jdXJyZW50UXVldWVzW2ldO1xuICAgIGNvbmN1cnJlbnRRdWV1ZXNbaSsrXSA9IG51bGw7XG4gICAgdmFyIHVwZGF0ZSA9IGNvbmN1cnJlbnRRdWV1ZXNbaV07XG4gICAgY29uY3VycmVudFF1ZXVlc1tpKytdID0gbnVsbDtcbiAgICB2YXIgbGFuZSA9IGNvbmN1cnJlbnRRdWV1ZXNbaV07XG4gICAgY29uY3VycmVudFF1ZXVlc1tpKytdID0gbnVsbDtcblxuICAgIGlmIChxdWV1ZSAhPT0gbnVsbCAmJiB1cGRhdGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBwZW5kaW5nID0gcXVldWUucGVuZGluZztcblxuICAgICAgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgdXBkYXRlLiBDcmVhdGUgYSBjaXJjdWxhciBsaXN0LlxuICAgICAgICB1cGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVwZGF0ZS5uZXh0ID0gcGVuZGluZy5uZXh0O1xuICAgICAgICBwZW5kaW5nLm5leHQgPSB1cGRhdGU7XG4gICAgICB9XG5cbiAgICAgIHF1ZXVlLnBlbmRpbmcgPSB1cGRhdGU7XG4gICAgfVxuXG4gICAgaWYgKGxhbmUgIT09IE5vTGFuZSkge1xuICAgICAgbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QoZmliZXIsIHVwZGF0ZSwgbGFuZSk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBnZXRDb25jdXJyZW50bHlVcGRhdGVkTGFuZXMoKSB7XG4gIHJldHVybiBjb25jdXJyZW50bHlVcGRhdGVkTGFuZXM7XG59XG5cbmZ1bmN0aW9uIGVucXVldWVVcGRhdGUkMShmaWJlciwgcXVldWUsIHVwZGF0ZSwgbGFuZSkge1xuICAvLyBEb24ndCB1cGRhdGUgdGhlIGBjaGlsZExhbmVzYCBvbiB0aGUgcmV0dXJuIHBhdGggeWV0LiBJZiB3ZSBhbHJlYWR5IGluXG4gIC8vIHRoZSBtaWRkbGUgb2YgcmVuZGVyaW5nLCB3YWl0IHVudGlsIGFmdGVyIGl0IGhhcyBjb21wbGV0ZWQuXG4gIGNvbmN1cnJlbnRRdWV1ZXNbY29uY3VycmVudFF1ZXVlc0luZGV4KytdID0gZmliZXI7XG4gIGNvbmN1cnJlbnRRdWV1ZXNbY29uY3VycmVudFF1ZXVlc0luZGV4KytdID0gcXVldWU7XG4gIGNvbmN1cnJlbnRRdWV1ZXNbY29uY3VycmVudFF1ZXVlc0luZGV4KytdID0gdXBkYXRlO1xuICBjb25jdXJyZW50UXVldWVzW2NvbmN1cnJlbnRRdWV1ZXNJbmRleCsrXSA9IGxhbmU7XG4gIGNvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcyA9IG1lcmdlTGFuZXMoY29uY3VycmVudGx5VXBkYXRlZExhbmVzLCBsYW5lKTsgLy8gVGhlIGZpYmVyJ3MgYGxhbmVgIGZpZWxkIGlzIHVzZWQgaW4gc29tZSBwbGFjZXMgdG8gY2hlY2sgaWYgYW55IHdvcmsgaXNcbiAgLy8gc2NoZWR1bGVkLCB0byBwZXJmb3JtIGFuIGVhZ2VyIGJhaWxvdXQsIHNvIHdlIG5lZWQgdG8gdXBkYXRlIGl0IGltbWVkaWF0ZWx5LlxuICAvLyBUT0RPOiBXZSBzaG91bGQgcHJvYmFibHkgbW92ZSB0aGlzIHRvIHRoZSBcInNoYXJlZFwiIHF1ZXVlIGluc3RlYWQuXG5cbiAgZmliZXIubGFuZXMgPSBtZXJnZUxhbmVzKGZpYmVyLmxhbmVzLCBsYW5lKTtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgYWx0ZXJuYXRlLmxhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUubGFuZXMsIGxhbmUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZShmaWJlciwgcXVldWUsIHVwZGF0ZSwgbGFuZSkge1xuICB2YXIgY29uY3VycmVudFF1ZXVlID0gcXVldWU7XG4gIHZhciBjb25jdXJyZW50VXBkYXRlID0gdXBkYXRlO1xuICBlbnF1ZXVlVXBkYXRlJDEoZmliZXIsIGNvbmN1cnJlbnRRdWV1ZSwgY29uY3VycmVudFVwZGF0ZSwgbGFuZSk7XG4gIHJldHVybiBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKGZpYmVyKTtcbn1cbmZ1bmN0aW9uIGVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZUFuZEVhZ2VybHlCYWlsb3V0KGZpYmVyLCBxdWV1ZSwgdXBkYXRlKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBxdWV1ZSBhbiB1cGRhdGUgdGhhdCBkb2Vzbid0IG5lZWQgYSByZXJlbmRlci4gVGhlXG4gIC8vIG9ubHkgcmVhc29uIHdlIHF1ZXVlIGl0IGlzIGluIGNhc2UgdGhlcmUncyBhIHN1YnNlcXVlbnQgaGlnaGVyIHByaW9yaXR5XG4gIC8vIHVwZGF0ZSB0aGF0IGNhdXNlcyBpdCB0byBiZSByZWJhc2VkLlxuICB2YXIgbGFuZSA9IE5vTGFuZTtcbiAgdmFyIGNvbmN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICB2YXIgY29uY3VycmVudFVwZGF0ZSA9IHVwZGF0ZTtcbiAgZW5xdWV1ZVVwZGF0ZSQxKGZpYmVyLCBjb25jdXJyZW50UXVldWUsIGNvbmN1cnJlbnRVcGRhdGUsIGxhbmUpOyAvLyBVc3VhbGx5IHdlIGNhbiByZWx5IG9uIHRoZSB1cGNvbWluZyByZW5kZXIgcGhhc2UgdG8gcHJvY2VzcyB0aGUgY29uY3VycmVudFxuICAvLyBxdWV1ZS4gSG93ZXZlciwgc2luY2UgdGhpcyBpcyBhIGJhaWwgb3V0LCB3ZSdyZSBub3Qgc2NoZWR1bGluZyBhbnkgd29ya1xuICAvLyBoZXJlLiBTbyB0aGUgdXBkYXRlIHdlIGp1c3QgcXVldWVkIHdpbGwgbGVhayB1bnRpbCBzb21ldGhpbmcgZWxzZSBoYXBwZW5zXG4gIC8vIHRvIHNjaGVkdWxlIHdvcmsgKGlmIGV2ZXIpLlxuICAvL1xuICAvLyBDaGVjayBpZiB3ZSdyZSBjdXJyZW50bHkgaW4gdGhlIG1pZGRsZSBvZiByZW5kZXJpbmcgYSB0cmVlLCBhbmQgaWYgbm90LFxuICAvLyBwcm9jZXNzIHRoZSBxdWV1ZSBpbW1lZGlhdGVseSB0byBwcmV2ZW50IGEgbGVhay5cblxuICB2YXIgaXNDb25jdXJyZW50bHlSZW5kZXJpbmcgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKSAhPT0gbnVsbDtcblxuICBpZiAoIWlzQ29uY3VycmVudGx5UmVuZGVyaW5nKSB7XG4gICAgZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcygpO1xuICB9XG59XG5mdW5jdGlvbiBlbnF1ZXVlQ29uY3VycmVudENsYXNzVXBkYXRlKGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCBsYW5lKSB7XG4gIHZhciBjb25jdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgdmFyIGNvbmN1cnJlbnRVcGRhdGUgPSB1cGRhdGU7XG4gIGVucXVldWVVcGRhdGUkMShmaWJlciwgY29uY3VycmVudFF1ZXVlLCBjb25jdXJyZW50VXBkYXRlLCBsYW5lKTtcbiAgcmV0dXJuIGdldFJvb3RGb3JVcGRhdGVkRmliZXIoZmliZXIpO1xufVxuZnVuY3Rpb24gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBsYW5lKSB7XG4gIGVucXVldWVVcGRhdGUkMShmaWJlciwgbnVsbCwgbnVsbCwgbGFuZSk7XG4gIHJldHVybiBnZXRSb290Rm9yVXBkYXRlZEZpYmVyKGZpYmVyKTtcbn0gLy8gQ2FsbGluZyB0aGlzIGZ1bmN0aW9uIG91dHNpZGUgdGhpcyBtb2R1bGUgc2hvdWxkIG9ubHkgYmUgZG9uZSBmb3IgYmFja3dhcmRzXG4vLyBjb21wYXRpYmlsaXR5IGFuZCBzaG91bGQgYWx3YXlzIGJlIGFjY29tcGFuaWVkIGJ5IGEgd2FybmluZy5cblxuZnVuY3Rpb24gdW5zYWZlX21hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KHNvdXJjZUZpYmVyLCBsYW5lKSB7XG4gIC8vIE5PVEU6IEZvciBIeXJ1bSdzIExhdyByZWFzb25zLCBpZiBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCBpcyBkZXRlY3RlZCwgaXRcbiAgLy8gc2hvdWxkIHRocm93IGJlZm9yZSBgbWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3RgIGlzIGNhbGxlZC4gQnV0IHRoaXMgaXNcbiAgLy8gdW5kZWZpbmVkIGJlaGF2aW9yIGFuZCB3ZSBjYW4gY2hhbmdlIGl0IGlmIHdlIG5lZWQgdG87IGl0IGp1c3Qgc28gaGFwcGVuc1xuICAvLyB0aGF0LCBhdCB0aGUgdGltZSBvZiB0aGlzIHdyaXRpbmcsIHRoZXJlJ3MgYW4gaW50ZXJuYWwgcHJvZHVjdCB0ZXN0IHRoYXRcbiAgLy8gaGFwcGVucyB0byByZWx5IG9uIHRoaXMuXG4gIHZhciByb290ID0gZ2V0Um9vdEZvclVwZGF0ZWRGaWJlcihzb3VyY2VGaWJlcik7XG4gIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KHNvdXJjZUZpYmVyLCBudWxsLCBsYW5lKTtcbiAgcmV0dXJuIHJvb3Q7XG59XG5cbmZ1bmN0aW9uIG1hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KHNvdXJjZUZpYmVyLCB1cGRhdGUsIGxhbmUpIHtcbiAgLy8gVXBkYXRlIHRoZSBzb3VyY2UgZmliZXIncyBsYW5lc1xuICBzb3VyY2VGaWJlci5sYW5lcyA9IG1lcmdlTGFuZXMoc291cmNlRmliZXIubGFuZXMsIGxhbmUpO1xuICB2YXIgYWx0ZXJuYXRlID0gc291cmNlRmliZXIuYWx0ZXJuYXRlO1xuXG4gIGlmIChhbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICBhbHRlcm5hdGUubGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5sYW5lcywgbGFuZSk7XG4gIH0gLy8gV2FsayB0aGUgcGFyZW50IHBhdGggdG8gdGhlIHJvb3QgYW5kIHVwZGF0ZSB0aGUgY2hpbGQgbGFuZXMuXG5cblxuICB2YXIgaXNIaWRkZW4gPSBmYWxzZTtcbiAgdmFyIHBhcmVudCA9IHNvdXJjZUZpYmVyLnJldHVybjtcbiAgdmFyIG5vZGUgPSBzb3VyY2VGaWJlcjtcblxuICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgcGFyZW50LmNoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKHBhcmVudC5jaGlsZExhbmVzLCBsYW5lKTtcbiAgICBhbHRlcm5hdGUgPSBwYXJlbnQuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgYWx0ZXJuYXRlLmNoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5jaGlsZExhbmVzLCBsYW5lKTtcbiAgICB9XG5cbiAgICBpZiAocGFyZW50LnRhZyA9PT0gT2Zmc2NyZWVuQ29tcG9uZW50KSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGlzIG9mZnNjcmVlbiBib3VuZGFyeSBpcyBjdXJyZW50bHkgaGlkZGVuLlxuICAgICAgLy9cbiAgICAgIC8vIFRoZSBpbnN0YW5jZSBtYXkgYmUgbnVsbCBpZiB0aGUgT2Zmc2NyZWVuIHBhcmVudCB3YXMgdW5tb3VudGVkLiBVc3VhbGx5XG4gICAgICAvLyB0aGUgcGFyZW50IHdvdWxkbid0IGJlIHJlYWNoYWJsZSBpbiB0aGF0IGNhc2UgYmVjYXVzZSB3ZSBkaXNjb25uZWN0XG4gICAgICAvLyBmaWJlcnMgZnJvbSB0aGUgdHJlZSB3aGVuIHRoZXkgYXJlIGRlbGV0ZWQuIEhvd2V2ZXIsIHRoZXJlJ3MgYSB3ZWlyZFxuICAgICAgLy8gZWRnZSBjYXNlIHdoZXJlIHNldFN0YXRlIGlzIGNhbGxlZCBvbiBhIGZpYmVyIHRoYXQgd2FzIGludGVycnVwdGVkXG4gICAgICAvLyBiZWZvcmUgaXQgZXZlciBtb3VudGVkLiBCZWNhdXNlIGl0IG5ldmVyIG1vdW50cywgaXQgYWxzbyBuZXZlciBnZXRzXG4gICAgICAvLyBkZWxldGVkLiBCZWNhdXNlIGl0IG5ldmVyIGdldHMgZGVsZXRlZCwgaXRzIHJldHVybiBwb2ludGVyIG5ldmVyIGdldHNcbiAgICAgIC8vIGRpc2Nvbm5lY3RlZC4gV2hpY2ggbWVhbnMgaXQgbWF5IGJlIGF0dGFjaGVkIHRvIGEgZGVsZXRlZCBPZmZzY3JlZW5cbiAgICAgIC8vIHBhcmVudCBub2RlLiAoVGhpcyBkaXNjb3Zlcnkgc3VnZ2VzdHMgaXQgbWF5IGJlIGJldHRlciBmb3IgbWVtb3J5IHVzYWdlXG4gICAgICAvLyBpZiB3ZSBkb24ndCBhdHRhY2ggdGhlIGByZXR1cm5gIHBvaW50ZXIgdW50aWwgdGhlIGNvbW1pdCBwaGFzZSwgdGhvdWdoXG4gICAgICAvLyBpbiBvcmRlciB0byBkbyB0aGF0IHdlJ2QgbmVlZCBzb21lIG90aGVyIHdheSB0byB0cmFjayB0aGUgcmV0dXJuXG4gICAgICAvLyBwb2ludGVyIGR1cmluZyB0aGUgaW5pdGlhbCByZW5kZXIsIGxpa2Ugb24gdGhlIHN0YWNrLilcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGNhc2UgaXMgYWx3YXlzIGFjY29tcGFuaWVkIGJ5IGEgd2FybmluZywgYnV0IHdlIHN0aWxsIG5lZWQgdG9cbiAgICAgIC8vIGFjY291bnQgZm9yIGl0LiAoVGhlcmUgbWF5IGJlIG90aGVyIGNhc2VzIHRoYXQgd2UgaGF2ZW4ndCBkaXNjb3ZlcmVkLFxuICAgICAgLy8gdG9vLilcbiAgICAgIHZhciBvZmZzY3JlZW5JbnN0YW5jZSA9IHBhcmVudC5zdGF0ZU5vZGU7XG5cbiAgICAgIGlmIChvZmZzY3JlZW5JbnN0YW5jZSAhPT0gbnVsbCAmJiAhKG9mZnNjcmVlbkluc3RhbmNlLl92aXNpYmlsaXR5ICYgT2Zmc2NyZWVuVmlzaWJsZSkpIHtcbiAgICAgICAgaXNIaWRkZW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIG5vZGUgPSBwYXJlbnQ7XG4gICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgfVxuXG4gIGlmIChpc0hpZGRlbiAmJiB1cGRhdGUgIT09IG51bGwgJiYgbm9kZS50YWcgPT09IEhvc3RSb290KSB7XG4gICAgdmFyIHJvb3QgPSBub2RlLnN0YXRlTm9kZTtcbiAgICBtYXJrSGlkZGVuVXBkYXRlKHJvb3QsIHVwZGF0ZSwgbGFuZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Um9vdEZvclVwZGF0ZWRGaWJlcihzb3VyY2VGaWJlcikge1xuICAvLyBUT0RPOiBXZSB3aWxsIGRldGVjdCBhbmQgaW5maW5pdGUgdXBkYXRlIGxvb3AgYW5kIHRocm93IGV2ZW4gaWYgdGhpcyBmaWJlclxuICAvLyBoYXMgYWxyZWFkeSB1bm1vdW50ZWQuIFRoaXMgaXNuJ3QgcmVhbGx5IG5lY2Vzc2FyeSBidXQgaXQgaGFwcGVucyB0byBiZSB0aGVcbiAgLy8gY3VycmVudCBiZWhhdmlvciB3ZSd2ZSB1c2VkIGZvciBzZXZlcmFsIHJlbGVhc2UgY3ljbGVzLiBDb25zaWRlciBub3RcbiAgLy8gcGVyZm9ybWluZyB0aGlzIGNoZWNrIGlmIHRoZSB1cGRhdGVkIGZpYmVyIGFscmVhZHkgdW5tb3VudGVkLCBzaW5jZSBpdCdzXG4gIC8vIG5vdCBwb3NzaWJsZSBmb3IgdGhhdCB0byBjYXVzZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcC5cbiAgdGhyb3dJZkluZmluaXRlVXBkYXRlTG9vcERldGVjdGVkKCk7IC8vIFdoZW4gYSBzZXRTdGF0ZSBoYXBwZW5zLCB3ZSBtdXN0IGVuc3VyZSB0aGUgcm9vdCBpcyBzY2hlZHVsZWQuIEJlY2F1c2VcbiAgLy8gdXBkYXRlIHF1ZXVlcyBkbyBub3QgaGF2ZSBhIGJhY2twb2ludGVyIHRvIHRoZSByb290LCB0aGUgb25seSB3YXkgdG8gZG9cbiAgLy8gdGhpcyBjdXJyZW50bHkgaXMgdG8gd2FsayB1cCB0aGUgcmV0dXJuIHBhdGguIFRoaXMgdXNlZCB0byBub3QgYmUgYSBiaWdcbiAgLy8gZGVhbCBiZWNhdXNlIHdlIHdvdWxkIGhhdmUgdG8gd2FsayB1cCB0aGUgcmV0dXJuIHBhdGggdG8gc2V0XG4gIC8vIHRoZSBgY2hpbGRMYW5lc2AsIGFueXdheSwgYnV0IG5vdyB0aG9zZSB0d28gdHJhdmVyc2FscyBoYXBwZW4gYXRcbiAgLy8gZGlmZmVyZW50IHRpbWVzLlxuICAvLyBUT0RPOiBDb25zaWRlciBhZGRpbmcgYSBgcm9vdGAgYmFja3BvaW50ZXIgb24gdGhlIHVwZGF0ZSBxdWV1ZS5cblxuICBkZXRlY3RVcGRhdGVPblVubW91bnRlZEZpYmVyKHNvdXJjZUZpYmVyLCBzb3VyY2VGaWJlcik7XG4gIHZhciBub2RlID0gc291cmNlRmliZXI7XG4gIHZhciBwYXJlbnQgPSBub2RlLnJldHVybjtcblxuICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgZGV0ZWN0VXBkYXRlT25Vbm1vdW50ZWRGaWJlcihzb3VyY2VGaWJlciwgbm9kZSk7XG4gICAgbm9kZSA9IHBhcmVudDtcbiAgICBwYXJlbnQgPSBub2RlLnJldHVybjtcbiAgfVxuXG4gIHJldHVybiBub2RlLnRhZyA9PT0gSG9zdFJvb3QgPyBub2RlLnN0YXRlTm9kZSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGRldGVjdFVwZGF0ZU9uVW5tb3VudGVkRmliZXIoc291cmNlRmliZXIsIHBhcmVudCkge1xuICB7XG4gICAgdmFyIGFsdGVybmF0ZSA9IHBhcmVudC5hbHRlcm5hdGU7XG5cbiAgICBpZiAoYWx0ZXJuYXRlID09PSBudWxsICYmIChwYXJlbnQuZmxhZ3MgJiAoUGxhY2VtZW50IHwgSHlkcmF0aW5nKSkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgd2FybkFib3V0VXBkYXRlT25Ob3RZZXRNb3VudGVkRmliZXJJbkRFVihzb3VyY2VGaWJlcik7XG4gICAgfVxuICB9XG59XG5cbi8vIHRoZXJlJ3Mgb25seSBhIHNpbmdsZSByb290LCBidXQgd2UgZG8gc3VwcG9ydCBtdWx0aSByb290IGFwcHMsIGhlbmNlIHRoaXNcbi8vIGV4dHJhIGNvbXBsZXhpdHkuIEJ1dCB0aGlzIG1vZHVsZSBpcyBvcHRpbWl6ZWQgZm9yIHRoZSBzaW5nbGUgcm9vdCBjYXNlLlxuXG52YXIgZmlyc3RTY2hlZHVsZWRSb290ID0gbnVsbDtcbnZhciBsYXN0U2NoZWR1bGVkUm9vdCA9IG51bGw7IC8vIFVzZWQgdG8gcHJldmVudCByZWR1bmRhbnQgbWlyY290YXNrcyBmcm9tIGJlaW5nIHNjaGVkdWxlZC5cblxudmFyIGRpZFNjaGVkdWxlTWljcm90YXNrID0gZmFsc2U7IC8vIGBhY3RgIFwibWljcm90YXNrc1wiIGFyZSBzY2hlZHVsZWQgb24gdGhlIGBhY3RgIHF1ZXVlIGluc3RlYWQgb2YgYW4gYWN0dWFsXG4vLyBtaWNyb3Rhc2ssIHNvIHdlIGhhdmUgdG8gZGVkdXBlIHRob3NlIHNlcGFyYXRlbHkuIFRoaXMgd291bGRuJ3QgYmUgYW4gaXNzdWVcbi8vIGlmIHdlIHJlcXVpcmVkIGFsbCBgYWN0YCBjYWxscyB0byBiZSBhd2FpdGVkLCB3aGljaCB3ZSBtaWdodCBpbiB0aGUgZnV0dXJlLlxuXG52YXIgZGlkU2NoZWR1bGVNaWNyb3Rhc2tfYWN0ID0gZmFsc2U7IC8vIFVzZWQgdG8gcXVpY2tseSBiYWlsIG91dCBvZiBmbHVzaFN5bmMgaWYgdGhlcmUncyBubyBzeW5jIHdvcmsgdG8gZG8uXG5cbnZhciBtaWdodEhhdmVQZW5kaW5nU3luY1dvcmsgPSBmYWxzZTtcbnZhciBpc0ZsdXNoaW5nV29yayA9IGZhbHNlO1xudmFyIGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lID0gTm9MYW5lO1xuZnVuY3Rpb24gZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgd2hlbmV2ZXIgYSByb290IHJlY2VpdmVzIGFuIHVwZGF0ZS4gSXQgZG9lcyB0d29cbiAgLy8gdGhpbmdzIDEpIGl0IGVuc3VyZXMgdGhlIHJvb3QgaXMgaW4gdGhlIHJvb3Qgc2NoZWR1bGUsIGFuZCAyKSBpdCBlbnN1cmVzXG4gIC8vIHRoZXJlJ3MgYSBwZW5kaW5nIG1pY3JvdGFzayB0byBwcm9jZXNzIHRoZSByb290IHNjaGVkdWxlLlxuICAvL1xuICAvLyBNb3N0IG9mIHRoZSBhY3R1YWwgc2NoZWR1bGluZyBsb2dpYyBkb2VzIG5vdCBoYXBwZW4gdW50aWxcbiAgLy8gYHNjaGVkdWxlVGFza0ZvclJvb3REdXJpbmdNaWNyb3Rhc2tgIHJ1bnMuXG4gIC8vIEFkZCB0aGUgcm9vdCB0byB0aGUgc2NoZWR1bGVcbiAgaWYgKHJvb3QgPT09IGxhc3RTY2hlZHVsZWRSb290IHx8IHJvb3QubmV4dCAhPT0gbnVsbCkgOyBlbHNlIHtcbiAgICBpZiAobGFzdFNjaGVkdWxlZFJvb3QgPT09IG51bGwpIHtcbiAgICAgIGZpcnN0U2NoZWR1bGVkUm9vdCA9IGxhc3RTY2hlZHVsZWRSb290ID0gcm9vdDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdFNjaGVkdWxlZFJvb3QubmV4dCA9IHJvb3Q7XG4gICAgICBsYXN0U2NoZWR1bGVkUm9vdCA9IHJvb3Q7XG4gICAgfVxuICB9IC8vIEFueSB0aW1lIGEgcm9vdCByZWNlaXZlZCBhbiB1cGRhdGUsIHdlIHNldCB0aGlzIHRvIHRydWUgdW50aWwgdGhlIG5leHQgdGltZVxuICAvLyB3ZSBwcm9jZXNzIHRoZSBzY2hlZHVsZS4gSWYgaXQncyBmYWxzZSwgdGhlbiB3ZSBjYW4gcXVpY2tseSBleGl0IGZsdXNoU3luY1xuICAvLyB3aXRob3V0IGNvbnN1bHRpbmcgdGhlIHNjaGVkdWxlLlxuXG5cbiAgbWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrID0gdHJ1ZTsgLy8gQXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBldmVudCwgZ28gdGhyb3VnaCBlYWNoIG9mIHRoZSByb290cyBhbmQgZW5zdXJlXG4gIC8vIHRoZXJlJ3MgYSB0YXNrIHNjaGVkdWxlZCBmb3IgZWFjaCBvbmUgYXQgdGhlIGNvcnJlY3QgcHJpb3JpdHkuXG5cbiAgaWYgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlICE9PSBudWxsKSB7XG4gICAgLy8gV2UncmUgaW5zaWRlIGFuIGBhY3RgIHNjb3BlLlxuICAgIGlmICghZGlkU2NoZWR1bGVNaWNyb3Rhc2tfYWN0KSB7XG4gICAgICBkaWRTY2hlZHVsZU1pY3JvdGFza19hY3QgPSB0cnVlO1xuICAgICAgc2NoZWR1bGVJbW1lZGlhdGVUYXNrKHByb2Nlc3NSb290U2NoZWR1bGVJbk1pY3JvdGFzayk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICghZGlkU2NoZWR1bGVNaWNyb3Rhc2spIHtcbiAgICAgIGRpZFNjaGVkdWxlTWljcm90YXNrID0gdHJ1ZTtcbiAgICAgIHNjaGVkdWxlSW1tZWRpYXRlVGFzayhwcm9jZXNzUm9vdFNjaGVkdWxlSW5NaWNyb3Rhc2spO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZmx1c2hTeW5jV29ya09uQWxsUm9vdHMoKSB7XG4gIC8vIFRoaXMgaXMgYWxsb3dlZCB0byBiZSBjYWxsZWQgc3luY2hyb25vdXNseSwgYnV0IHRoZSBjYWxsZXIgc2hvdWxkIGNoZWNrXG4gIC8vIHRoZSBleGVjdXRpb24gY29udGV4dCBmaXJzdC5cbiAgZmx1c2hTeW5jV29ya0Fjcm9zc1Jvb3RzX2ltcGwoZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbChvbmx5TGVnYWN5KSB7XG4gIGlmIChpc0ZsdXNoaW5nV29yaykge1xuICAgIC8vIFByZXZlbnQgcmVlbnRyYW5jeS5cbiAgICAvLyBUT0RPOiBJcyB0aGlzIG92ZXJseSBkZWZlbnNpdmU/IFRoZSBjYWxsZXJzIG11c3QgY2hlY2sgdGhlIGV4ZWN1dGlvblxuICAgIC8vIGNvbnRleHQgZmlyc3QgcmVnYXJkbGVzcy5cbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIW1pZ2h0SGF2ZVBlbmRpbmdTeW5jV29yaykge1xuICAgIC8vIEZhc3QgcGF0aC4gVGhlcmUncyBubyBzeW5jIHdvcmsgdG8gZG8uXG4gICAgcmV0dXJuO1xuICB9IC8vIFRoZXJlIG1heSBvciBtYXkgbm90IGJlIHN5bmNocm9ub3VzIHdvcmsgc2NoZWR1bGVkLiBMZXQncyBjaGVjay5cblxuXG4gIHZhciBkaWRQZXJmb3JtU29tZVdvcms7XG4gIGlzRmx1c2hpbmdXb3JrID0gdHJ1ZTtcblxuICBkbyB7XG4gICAgZGlkUGVyZm9ybVNvbWVXb3JrID0gZmFsc2U7XG4gICAgdmFyIHJvb3QgPSBmaXJzdFNjaGVkdWxlZFJvb3Q7XG5cbiAgICB3aGlsZSAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgaWYgKG9ubHlMZWdhY3kgJiYgKGRpc2FibGVMZWdhY3lNb2RlICkpIDsgZWxzZSB7XG4gICAgICAgIHZhciB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTtcbiAgICAgICAgdmFyIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMoKTtcbiAgICAgICAgdmFyIG5leHRMYW5lcyA9IGdldE5leHRMYW5lcyhyb290LCByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgPyB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA6IE5vTGFuZXMpO1xuXG4gICAgICAgIGlmIChpbmNsdWRlc1N5bmNMYW5lKG5leHRMYW5lcykpIHtcbiAgICAgICAgICAvLyBUaGlzIHJvb3QgaGFzIHBlbmRpbmcgc3luYyB3b3JrLiBGbHVzaCBpdCBub3cuXG4gICAgICAgICAgZGlkUGVyZm9ybVNvbWVXb3JrID0gdHJ1ZTtcbiAgICAgICAgICBwZXJmb3JtU3luY1dvcmtPblJvb3Qocm9vdCwgbmV4dExhbmVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByb290ID0gcm9vdC5uZXh0O1xuICAgIH1cbiAgfSB3aGlsZSAoZGlkUGVyZm9ybVNvbWVXb3JrKTtcblxuICBpc0ZsdXNoaW5nV29yayA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBwcm9jZXNzUm9vdFNjaGVkdWxlSW5NaWNyb3Rhc2soKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgYWx3YXlzIGNhbGxlZCBpbnNpZGUgYSBtaWNyb3Rhc2suIEl0IHNob3VsZCBuZXZlciBiZVxuICAvLyBjYWxsZWQgc3luY2hyb25vdXNseS5cbiAgZGlkU2NoZWR1bGVNaWNyb3Rhc2sgPSBmYWxzZTtcblxuICB7XG4gICAgZGlkU2NoZWR1bGVNaWNyb3Rhc2tfYWN0ID0gZmFsc2U7XG4gIH0gLy8gV2UnbGwgcmVjb21wdXRlIHRoaXMgYXMgd2UgaXRlcmF0ZSB0aHJvdWdoIGFsbCB0aGUgcm9vdHMgYW5kIHNjaGVkdWxlIHRoZW0uXG5cblxuICBtaWdodEhhdmVQZW5kaW5nU3luY1dvcmsgPSBmYWxzZTtcbiAgdmFyIGN1cnJlbnRUaW1lID0gbm93JDEoKTtcbiAgdmFyIHByZXYgPSBudWxsO1xuICB2YXIgcm9vdCA9IGZpcnN0U2NoZWR1bGVkUm9vdDtcblxuICB3aGlsZSAocm9vdCAhPT0gbnVsbCkge1xuICAgIHZhciBuZXh0ID0gcm9vdC5uZXh0O1xuXG4gICAgaWYgKGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lICE9PSBOb0xhbmUgJiYgc2hvdWxkQXR0ZW1wdEVhZ2VyVHJhbnNpdGlvbigpKSB7XG4gICAgICAvLyBBIHRyYW5zaXRpb24gd2FzIHNjaGVkdWxlZCBkdXJpbmcgYW4gZXZlbnQsIGJ1dCB3ZSdyZSBnb2luZyB0byB0cnkgdG9cbiAgICAgIC8vIHJlbmRlciBpdCBzeW5jaHJvbm91c2x5IGFueXdheS4gV2UgZG8gdGhpcyBkdXJpbmcgYSBwb3BzdGF0ZSBldmVudCB0b1xuICAgICAgLy8gcHJlc2VydmUgdGhlIHNjcm9sbCBwb3NpdGlvbiBvZiB0aGUgcHJldmlvdXMgcGFnZS5cbiAgICAgIHVwZ3JhZGVQZW5kaW5nTGFuZVRvU3luYyhyb290LCBjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSk7XG4gICAgfVxuXG4gICAgdmFyIG5leHRMYW5lcyA9IHNjaGVkdWxlVGFza0ZvclJvb3REdXJpbmdNaWNyb3Rhc2socm9vdCwgY3VycmVudFRpbWUpO1xuXG4gICAgaWYgKG5leHRMYW5lcyA9PT0gTm9MYW5lKSB7XG4gICAgICAvLyBUaGlzIHJvb3QgaGFzIG5vIG1vcmUgcGVuZGluZyB3b3JrLiBSZW1vdmUgaXQgZnJvbSB0aGUgc2NoZWR1bGUuIFRvXG4gICAgICAvLyBndWFyZCBhZ2FpbnN0IHN1YnRsZSByZWVudHJhbmN5IGJ1Z3MsIHRoaXMgbWljcm90YXNrIGlzIHRoZSBvbmx5IHBsYWNlXG4gICAgICAvLyB3ZSBkbyB0aGlzIOKAlCB5b3UgY2FuIGFkZCByb290cyB0byB0aGUgc2NoZWR1bGUgd2hlbmV2ZXIsIGJ1dCB5b3UgY2FuXG4gICAgICAvLyBvbmx5IHJlbW92ZSB0aGVtIGhlcmUuXG4gICAgICAvLyBOdWxsIHRoaXMgb3V0IHNvIHdlIGtub3cgaXQncyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgc2NoZWR1bGUuXG4gICAgICByb290Lm5leHQgPSBudWxsO1xuXG4gICAgICBpZiAocHJldiA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUaGlzIGlzIHRoZSBuZXcgaGVhZCBvZiB0aGUgbGlzdFxuICAgICAgICBmaXJzdFNjaGVkdWxlZFJvb3QgPSBuZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJldi5uZXh0ID0gbmV4dDtcbiAgICAgIH1cblxuICAgICAgaWYgKG5leHQgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgbmV3IHRhaWwgb2YgdGhlIGxpc3RcbiAgICAgICAgbGFzdFNjaGVkdWxlZFJvb3QgPSBwcmV2O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGlzIHJvb3Qgc3RpbGwgaGFzIHdvcmsuIEtlZXAgaXQgaW4gdGhlIGxpc3QuXG4gICAgICBwcmV2ID0gcm9vdDtcblxuICAgICAgaWYgKGluY2x1ZGVzU3luY0xhbmUobmV4dExhbmVzKSkge1xuICAgICAgICBtaWdodEhhdmVQZW5kaW5nU3luY1dvcmsgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJvb3QgPSBuZXh0O1xuICB9XG5cbiAgY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgPSBOb0xhbmU7IC8vIEF0IHRoZSBlbmQgb2YgdGhlIG1pY3JvdGFzaywgZmx1c2ggYW55IHBlbmRpbmcgc3luY2hyb25vdXMgd29yay4gVGhpcyBoYXNcbiAgLy8gdG8gY29tZSBhdCB0aGUgZW5kLCBiZWNhdXNlIGl0IGRvZXMgYWN0dWFsIHJlbmRlcmluZyB3b3JrIHRoYXQgbWlnaHQgdGhyb3cuXG5cbiAgZmx1c2hTeW5jV29ya09uQWxsUm9vdHMoKTtcbn1cblxuZnVuY3Rpb24gc2NoZWR1bGVUYXNrRm9yUm9vdER1cmluZ01pY3JvdGFzayhyb290LCBjdXJyZW50VGltZSkge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIGFsd2F5cyBjYWxsZWQgaW5zaWRlIGEgbWljcm90YXNrLCBvciBhdCB0aGUgdmVyeSBlbmQgb2YgYVxuICAvLyByZW5kZXJpbmcgdGFzayByaWdodCBiZWZvcmUgd2UgeWllbGQgdG8gdGhlIG1haW4gdGhyZWFkLiBJdCBzaG91bGQgbmV2ZXIgYmVcbiAgLy8gY2FsbGVkIHN5bmNocm9ub3VzbHkuXG4gIC8vXG4gIC8vIFRPRE86IFVubGVzcyBlbmFibGVEZWZlclJvb3RTY2hlZHVsaW5nVG9NaWNyb3Rhc2sgaXMgb2ZmLiBXZSBuZWVkIHRvIGxhbmRcbiAgLy8gdGhhdCBBU0FQIHRvIHVuYmxvY2sgYWRkaXRpb25hbCBmZWF0dXJlcyB3ZSBoYXZlIHBsYW5uZWQuXG4gIC8vXG4gIC8vIFRoaXMgZnVuY3Rpb24gYWxzbyBuZXZlciBwZXJmb3JtcyBSZWFjdCB3b3JrIHN5bmNocm9ub3VzbHk7IGl0IHNob3VsZFxuICAvLyBvbmx5IHNjaGVkdWxlIHdvcmsgdG8gYmUgcGVyZm9ybWVkIGxhdGVyLCBpbiBhIHNlcGFyYXRlIHRhc2sgb3IgbWljcm90YXNrLlxuICAvLyBDaGVjayBpZiBhbnkgbGFuZXMgYXJlIGJlaW5nIHN0YXJ2ZWQgYnkgb3RoZXIgd29yay4gSWYgc28sIG1hcmsgdGhlbSBhc1xuICAvLyBleHBpcmVkIHNvIHdlIGtub3cgdG8gd29yayBvbiB0aG9zZSBuZXh0LlxuICBtYXJrU3RhcnZlZExhbmVzQXNFeHBpcmVkKHJvb3QsIGN1cnJlbnRUaW1lKTsgLy8gRGV0ZXJtaW5lIHRoZSBuZXh0IGxhbmVzIHRvIHdvcmsgb24sIGFuZCB0aGVpciBwcmlvcml0eS5cblxuICB2YXIgd29ya0luUHJvZ3Jlc3NSb290ID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCk7XG4gIHZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IGdldFdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKCk7XG4gIHZhciBuZXh0TGFuZXMgPSBnZXROZXh0TGFuZXMocm9vdCwgcm9vdCA9PT0gd29ya0luUHJvZ3Jlc3NSb290ID8gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgOiBOb0xhbmVzKTtcbiAgdmFyIGV4aXN0aW5nQ2FsbGJhY2tOb2RlID0gcm9vdC5jYWxsYmFja05vZGU7XG5cbiAgaWYgKCAvLyBDaGVjayBpZiB0aGVyZSdzIG5vdGhpbmcgdG8gd29yayBvblxuICBuZXh0TGFuZXMgPT09IE5vTGFuZXMgfHwgLy8gSWYgdGhpcyByb290IGlzIGN1cnJlbnRseSBzdXNwZW5kZWQgYW5kIHdhaXRpbmcgZm9yIGRhdGEgdG8gcmVzb2x2ZSwgZG9uJ3RcbiAgLy8gc2NoZWR1bGUgYSB0YXNrIHRvIHJlbmRlciBpdC4gV2UnbGwgZWl0aGVyIHdhaXQgZm9yIGEgcGluZywgb3Igd2FpdCB0b1xuICAvLyByZWNlaXZlIGFuIHVwZGF0ZS5cbiAgLy9cbiAgLy8gU3VzcGVuZGVkIHJlbmRlciBwaGFzZVxuICByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgJiYgaXNXb3JrTG9vcFN1c3BlbmRlZE9uRGF0YSgpIHx8IC8vIFN1c3BlbmRlZCBjb21taXQgcGhhc2VcbiAgcm9vdC5jYW5jZWxQZW5kaW5nQ29tbWl0ICE9PSBudWxsKSB7XG4gICAgLy8gRmFzdCBwYXRoOiBUaGVyZSdzIG5vdGhpbmcgdG8gd29yayBvbi5cbiAgICBpZiAoZXhpc3RpbmdDYWxsYmFja05vZGUgIT09IG51bGwpIHtcbiAgICAgIGNhbmNlbENhbGxiYWNrKGV4aXN0aW5nQ2FsbGJhY2tOb2RlKTtcbiAgICB9XG5cbiAgICByb290LmNhbGxiYWNrTm9kZSA9IG51bGw7XG4gICAgcm9vdC5jYWxsYmFja1ByaW9yaXR5ID0gTm9MYW5lO1xuICAgIHJldHVybiBOb0xhbmU7XG4gIH0gLy8gU2NoZWR1bGUgYSBuZXcgY2FsbGJhY2sgaW4gdGhlIGhvc3QgZW52aXJvbm1lbnQuXG5cblxuICBpZiAoaW5jbHVkZXNTeW5jTGFuZShuZXh0TGFuZXMpKSB7XG4gICAgLy8gU3luY2hyb25vdXMgd29yayBpcyBhbHdheXMgZmx1c2hlZCBhdCB0aGUgZW5kIG9mIHRoZSBtaWNyb3Rhc2ssIHNvIHdlXG4gICAgLy8gZG9uJ3QgbmVlZCB0byBzY2hlZHVsZSBhbiBhZGRpdGlvbmFsIHRhc2suXG4gICAgaWYgKGV4aXN0aW5nQ2FsbGJhY2tOb2RlICE9PSBudWxsKSB7XG4gICAgICBjYW5jZWxDYWxsYmFjayhleGlzdGluZ0NhbGxiYWNrTm9kZSk7XG4gICAgfVxuXG4gICAgcm9vdC5jYWxsYmFja1ByaW9yaXR5ID0gU3luY0xhbmU7XG4gICAgcm9vdC5jYWxsYmFja05vZGUgPSBudWxsO1xuICAgIHJldHVybiBTeW5jTGFuZTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSB1c2UgdGhlIGhpZ2hlc3QgcHJpb3JpdHkgbGFuZSB0byByZXByZXNlbnQgdGhlIHByaW9yaXR5IG9mIHRoZSBjYWxsYmFjay5cbiAgICB2YXIgZXhpc3RpbmdDYWxsYmFja1ByaW9yaXR5ID0gcm9vdC5jYWxsYmFja1ByaW9yaXR5O1xuICAgIHZhciBuZXdDYWxsYmFja1ByaW9yaXR5ID0gZ2V0SGlnaGVzdFByaW9yaXR5TGFuZShuZXh0TGFuZXMpO1xuXG4gICAgaWYgKG5ld0NhbGxiYWNrUHJpb3JpdHkgPT09IGV4aXN0aW5nQ2FsbGJhY2tQcmlvcml0eSAmJiAvLyBTcGVjaWFsIGNhc2UgcmVsYXRlZCB0byBgYWN0YC4gSWYgdGhlIGN1cnJlbnRseSBzY2hlZHVsZWQgdGFzayBpcyBhXG4gICAgLy8gU2NoZWR1bGVyIHRhc2ssIHJhdGhlciB0aGFuIGFuIGBhY3RgIHRhc2ssIGNhbmNlbCBpdCBhbmQgcmUtc2NoZWR1bGVcbiAgICAvLyBvbiB0aGUgYGFjdGAgcXVldWUuXG4gICAgIShSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSAhPT0gbnVsbCAmJiBleGlzdGluZ0NhbGxiYWNrTm9kZSAhPT0gZmFrZUFjdENhbGxiYWNrTm9kZSQxKSkge1xuICAgICAgLy8gVGhlIHByaW9yaXR5IGhhc24ndCBjaGFuZ2VkLiBXZSBjYW4gcmV1c2UgdGhlIGV4aXN0aW5nIHRhc2suXG4gICAgICByZXR1cm4gbmV3Q2FsbGJhY2tQcmlvcml0eTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ2FuY2VsIHRoZSBleGlzdGluZyBjYWxsYmFjay4gV2UnbGwgc2NoZWR1bGUgYSBuZXcgb25lIGJlbG93LlxuICAgICAgY2FuY2VsQ2FsbGJhY2soZXhpc3RpbmdDYWxsYmFja05vZGUpO1xuICAgIH1cblxuICAgIHZhciBzY2hlZHVsZXJQcmlvcml0eUxldmVsO1xuXG4gICAgc3dpdGNoIChsYW5lc1RvRXZlbnRQcmlvcml0eShuZXh0TGFuZXMpKSB7XG4gICAgICBjYXNlIERpc2NyZXRlRXZlbnRQcmlvcml0eTpcbiAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHlMZXZlbCA9IEltbWVkaWF0ZVByaW9yaXR5O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDb250aW51b3VzRXZlbnRQcmlvcml0eTpcbiAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHlMZXZlbCA9IFVzZXJCbG9ja2luZ1ByaW9yaXR5O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBEZWZhdWx0RXZlbnRQcmlvcml0eTpcbiAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHlMZXZlbCA9IE5vcm1hbFByaW9yaXR5JDE7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIElkbGVFdmVudFByaW9yaXR5OlxuICAgICAgICBzY2hlZHVsZXJQcmlvcml0eUxldmVsID0gSWRsZVByaW9yaXR5O1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgc2NoZWR1bGVyUHJpb3JpdHlMZXZlbCA9IE5vcm1hbFByaW9yaXR5JDE7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBuZXdDYWxsYmFja05vZGUgPSBzY2hlZHVsZUNhbGxiYWNrJDIoc2NoZWR1bGVyUHJpb3JpdHlMZXZlbCwgcGVyZm9ybUNvbmN1cnJlbnRXb3JrT25Sb290LmJpbmQobnVsbCwgcm9vdCkpO1xuICAgIHJvb3QuY2FsbGJhY2tQcmlvcml0eSA9IG5ld0NhbGxiYWNrUHJpb3JpdHk7XG4gICAgcm9vdC5jYWxsYmFja05vZGUgPSBuZXdDYWxsYmFja05vZGU7XG4gICAgcmV0dXJuIG5ld0NhbGxiYWNrUHJpb3JpdHk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q29udGludWF0aW9uRm9yUm9vdChyb290LCBvcmlnaW5hbENhbGxiYWNrTm9kZSkge1xuICAvLyBUaGlzIGlzIGNhbGxlZCBhdCB0aGUgZW5kIG9mIGBwZXJmb3JtQ29uY3VycmVudFdvcmtPblJvb3RgIHRvIGRldGVybWluZVxuICAvLyBpZiB3ZSBuZWVkIHRvIHNjaGVkdWxlIGEgY29udGludWF0aW9uIHRhc2suXG4gIC8vXG4gIC8vIFVzdWFsbHkgYHNjaGVkdWxlVGFza0ZvclJvb3REdXJpbmdNaWNyb3Rhc2tgIG9ubHkgcnVucyBpbnNpZGUgYSBtaWNyb3Rhc2s7XG4gIC8vIGhvd2V2ZXIsIHNpbmNlIG1vc3Qgb2YgdGhlIGxvZ2ljIGZvciBkZXRlcm1pbmluZyBpZiB3ZSBuZWVkIGEgY29udGludWF0aW9uXG4gIC8vIHZlcnN1cyBhIG5ldyB0YXNrIGlzIHRoZSBzYW1lLCB3ZSBjaGVhdCBhIGJpdCBhbmQgY2FsbCBpdCBoZXJlLiBUaGlzIGlzXG4gIC8vIG9ubHkgc2FmZSB0byBkbyBiZWNhdXNlIHdlIGtub3cgd2UncmUgYXQgdGhlIGVuZCBvZiB0aGUgYnJvd3NlciB0YXNrLlxuICAvLyBTbyBhbHRob3VnaCBpdCdzIG5vdCBhbiBhY3R1YWwgbWljcm90YXNrLCBpdCBtaWdodCBhcyB3ZWxsIGJlLlxuICBzY2hlZHVsZVRhc2tGb3JSb290RHVyaW5nTWljcm90YXNrKHJvb3QsIG5vdyQxKCkpO1xuXG4gIGlmIChyb290LmNhbGxiYWNrTm9kZSA9PT0gb3JpZ2luYWxDYWxsYmFja05vZGUpIHtcbiAgICAvLyBUaGUgdGFzayBub2RlIHNjaGVkdWxlZCBmb3IgdGhpcyByb290IGlzIHRoZSBzYW1lIG9uZSB0aGF0J3NcbiAgICAvLyBjdXJyZW50bHkgZXhlY3V0ZWQuIE5lZWQgdG8gcmV0dXJuIGEgY29udGludWF0aW9uLlxuICAgIHJldHVybiBwZXJmb3JtQ29uY3VycmVudFdvcmtPblJvb3QuYmluZChudWxsLCByb290KTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxudmFyIGZha2VBY3RDYWxsYmFja05vZGUkMSA9IHt9O1xuXG5mdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrJDIocHJpb3JpdHlMZXZlbCwgY2FsbGJhY2spIHtcbiAgaWYgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlICE9PSBudWxsKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBXZSdyZSBpbnNpZGUgYW4gYGFjdGAgc2NvcGUgKGEgdGVzdGluZyB1dGlsaXR5KS5cbiAgICAvLyBJbnN0ZWFkIG9mIHNjaGVkdWxpbmcgd29yayBpbiB0aGUgaG9zdCBlbnZpcm9ubWVudCwgYWRkIGl0IHRvIGFcbiAgICAvLyBmYWtlIGludGVybmFsIHF1ZXVlIHRoYXQncyBtYW5hZ2VkIGJ5IHRoZSBgYWN0YCBpbXBsZW1lbnRhdGlvbi5cbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZS5wdXNoKGNhbGxiYWNrKTtcbiAgICByZXR1cm4gZmFrZUFjdENhbGxiYWNrTm9kZSQxO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzY2hlZHVsZUNhbGxiYWNrJDMocHJpb3JpdHlMZXZlbCwgY2FsbGJhY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbmNlbENhbGxiYWNrKGNhbGxiYWNrTm9kZSkge1xuICBpZiAoY2FsbGJhY2tOb2RlID09PSBmYWtlQWN0Q2FsbGJhY2tOb2RlJDEpIDsgZWxzZSBpZiAoY2FsbGJhY2tOb2RlICE9PSBudWxsKSB7XG4gICAgY2FuY2VsQ2FsbGJhY2skMShjYWxsYmFja05vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlSW1tZWRpYXRlVGFzayhjYikge1xuICBpZiAoUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWUgIT09IG51bGwpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IEluc2lkZSBhbiBgYWN0YCBzY29wZSwgd2UgcHVzaCBtaWNyb3Rhc2tzIHRvIHRoZSBmYWtlIGBhY3RgXG4gICAgLy8gY2FsbGJhY2sgcXVldWUuIFRoaXMgaXMgYmVjYXVzZSB3ZSBjdXJyZW50bHkgc3VwcG9ydCBjYWxsaW5nIGBhY3RgXG4gICAgLy8gd2l0aG91dCBhd2FpdGluZyB0aGUgcmVzdWx0LiBUaGUgcGxhbiBpcyB0byBkZXByZWNhdGUgdGhhdCwgYW5kIHJlcXVpcmVcbiAgICAvLyB0aGF0IHlvdSBhbHdheXMgYXdhaXQgdGhlIHJlc3VsdCBzbyB0aGF0IHRoZSBtaWNyb3Rhc2tzIGhhdmUgYSBjaGFuY2UgdG9cbiAgICAvLyBydW4uIEJ1dCBpdCBoYXNuJ3QgaGFwcGVuZWQgeWV0LlxuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlLnB1c2goZnVuY3Rpb24gKCkge1xuICAgICAgY2IoKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0pO1xuICB9IC8vIFRPRE86IENhbiB3ZSBsYW5kIHN1cHBvcnRzTWljcm90YXNrcz8gV2hpY2ggZW52aXJvbm1lbnRzIGRvbid0IHN1cHBvcnQgaXQ/XG4gIC8vIEFsdGVybmF0aXZlbHksIGNhbiB3ZSBtb3ZlIHRoaXMgY2hlY2sgdG8gdGhlIGhvc3QgY29uZmlnP1xuXG5cbiAgaWYgKHN1cHBvcnRzTWljcm90YXNrcykge1xuICAgIHNjaGVkdWxlTWljcm90YXNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIEluIFNhZmFyaSwgYXBwZW5kaW5nIGFuIGlmcmFtZSBmb3JjZXMgbWljcm90YXNrcyB0byBydW4uXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIyNDU5XG4gICAgICAvLyBXZSBkb24ndCBzdXBwb3J0IHJ1bm5pbmcgY2FsbGJhY2tzIGluIHRoZSBtaWRkbGUgb2YgcmVuZGVyXG4gICAgICAvLyBvciBjb21taXQgc28gd2UgbmVlZCB0byBjaGVjayBhZ2FpbnN0IHRoYXQuXG4gICAgICB2YXIgZXhlY3V0aW9uQ29udGV4dCA9IGdldEV4ZWN1dGlvbkNvbnRleHQoKTtcblxuICAgICAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgIT09IE5vQ29udGV4dCkge1xuICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyB3b3VsZCBzdGlsbCBwcmVtYXR1cmVseSBmbHVzaCB0aGUgY2FsbGJhY2tzXG4gICAgICAgIC8vIGlmIHRoaXMgaGFwcGVucyBvdXRzaWRlIHJlbmRlciBvciBjb21taXQgcGhhc2UgKGUuZy4gaW4gYW4gZXZlbnQpLlxuICAgICAgICAvLyBJbnRlbnRpb25hbGx5IHVzaW5nIGEgbWFjcm90YXNrIGluc3RlYWQgb2YgYSBtaWNyb3Rhc2sgaGVyZS4gVGhpcyBpc1xuICAgICAgICAvLyB3cm9uZyBzZW1hbnRpY2FsbHkgYnV0IGl0IHByZXZlbnRzIGFuIGluZmluaXRlIGxvb3AuIFRoZSBidWcgaXNcbiAgICAgICAgLy8gU2FmYXJpJ3MsIG5vdCBvdXJzLCBzbyB3ZSBqdXN0IGRvIG91ciBiZXN0IHRvIG5vdCBjcmFzaCBldmVuIHRob3VnaFxuICAgICAgICAvLyB0aGUgYmVoYXZpb3IgaXNuJ3QgY29tcGxldGVseSBjb3JyZWN0LlxuICAgICAgICBzY2hlZHVsZUNhbGxiYWNrJDMoSW1tZWRpYXRlUHJpb3JpdHksIGNiKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjYigpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIElmIG1pY3JvdGFza3MgYXJlIG5vdCBzdXBwb3J0ZWQsIHVzZSBTY2hlZHVsZXIuXG4gICAgc2NoZWR1bGVDYWxsYmFjayQzKEltbWVkaWF0ZVByaW9yaXR5LCBjYik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVxdWVzdFRyYW5zaXRpb25MYW5lKCAvLyBUaGlzIGFyZ3VtZW50IGlzbid0IHVzZWQsIGl0J3Mgb25seSBoZXJlIHRvIGVuY291cmFnZSB0aGUgY2FsbGVyIHRvXG4vLyBjaGVjayB0aGF0IGl0J3MgaW5zaWRlIGEgdHJhbnNpdGlvbiBiZWZvcmUgY2FsbGluZyB0aGlzIGZ1bmN0aW9uLlxuLy8gVE9ETzogTWFrZSB0aGlzIG5vbi1udWxsYWJsZS4gUmVxdWlyZXMgYSB0d2VhayB0byB1c2VPcHRpbWlzdGljLlxudHJhbnNpdGlvbikge1xuICAvLyBUaGUgYWxnb3JpdGhtIGZvciBhc3NpZ25pbmcgYW4gdXBkYXRlIHRvIGEgbGFuZSBzaG91bGQgYmUgc3RhYmxlIGZvciBhbGxcbiAgLy8gdXBkYXRlcyBhdCB0aGUgc2FtZSBwcmlvcml0eSB3aXRoaW4gdGhlIHNhbWUgZXZlbnQuIFRvIGRvIHRoaXMsIHRoZVxuICAvLyBpbnB1dHMgdG8gdGhlIGFsZ29yaXRobSBtdXN0IGJlIHRoZSBzYW1lLlxuICAvL1xuICAvLyBUaGUgdHJpY2sgd2UgdXNlIGlzIHRvIGNhY2hlIHRoZSBmaXJzdCBvZiBlYWNoIG9mIHRoZXNlIGlucHV0cyB3aXRoaW4gYW5cbiAgLy8gZXZlbnQuIFRoZW4gcmVzZXQgdGhlIGNhY2hlZCB2YWx1ZXMgb25jZSB3ZSBjYW4gYmUgc3VyZSB0aGUgZXZlbnQgaXNcbiAgLy8gb3Zlci4gT3VyIGhldXJpc3RpYyBmb3IgdGhhdCBpcyB3aGVuZXZlciB3ZSBlbnRlciBhIGNvbmN1cnJlbnQgd29yayBsb29wLlxuICBpZiAoY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgPT09IE5vTGFuZSkge1xuICAgIC8vIEFsbCB0cmFuc2l0aW9ucyB3aXRoaW4gdGhlIHNhbWUgZXZlbnQgYXJlIGFzc2lnbmVkIHRoZSBzYW1lIGxhbmUuXG4gICAgY3VycmVudEV2ZW50VHJhbnNpdGlvbkxhbmUgPSBjbGFpbU5leHRUcmFuc2l0aW9uTGFuZSgpO1xuICB9XG5cbiAgcmV0dXJuIGN1cnJlbnRFdmVudFRyYW5zaXRpb25MYW5lO1xufVxuXG4vLyB0cmFuc2l0aW9uIHVwZGF0ZXMgdGhhdCBvY2N1ciB3aGlsZSB0aGUgYXN5bmMgYWN0aW9uIGlzIHN0aWxsIGluIHByb2dyZXNzXG4vLyBhcmUgdHJlYXRlZCBhcyBwYXJ0IG9mIHRoZSBhY3Rpb24uXG4vL1xuLy8gVGhlIGlkZWFsIGJlaGF2aW9yIHdvdWxkIGJlIHRvIHRyZWF0IGVhY2ggYXN5bmMgZnVuY3Rpb24gYXMgYW4gaW5kZXBlbmRlbnRcbi8vIGFjdGlvbi4gSG93ZXZlciwgd2l0aG91dCBhIG1lY2hhbmlzbSBsaWtlIEFzeW5jQ29udGV4dCwgd2UgY2FuJ3QgdGVsbCB3aGljaFxuLy8gYWN0aW9uIGFuIHVwZGF0ZSBjb3JyZXNwb25kcyB0by4gU28gaW5zdGVhZCwgd2UgZW50YW5nbGUgdGhlbSBhbGwgaW50byBvbmUuXG4vLyBUaGUgbGlzdGVuZXJzIHRvIG5vdGlmeSBvbmNlIHRoZSBlbnRhbmdsZWQgc2NvcGUgY29tcGxldGVzLlxuXG52YXIgY3VycmVudEVudGFuZ2xlZExpc3RlbmVycyA9IG51bGw7IC8vIFRoZSBudW1iZXIgb2YgcGVuZGluZyBhc3luYyBhY3Rpb25zIGluIHRoZSBlbnRhbmdsZWQgc2NvcGUuXG5cbnZhciBjdXJyZW50RW50YW5nbGVkUGVuZGluZ0NvdW50ID0gMDsgLy8gVGhlIHRyYW5zaXRpb24gbGFuZSBzaGFyZWQgYnkgYWxsIHVwZGF0ZXMgaW4gdGhlIGVudGFuZ2xlZCBzY29wZS5cblxudmFyIGN1cnJlbnRFbnRhbmdsZWRMYW5lID0gTm9MYW5lOyAvLyBBIHRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgd2hlbiB0aGUgZW50YW5nbGVkIHNjb3BlIGNvbXBsZXRlcy4gSXQgZG9lcyBub3Rcbi8vIHJlc29sdmUgdG8gYSBwYXJ0aWN1bGFyIHZhbHVlIGJlY2F1c2UgaXQncyBvbmx5IHVzZWQgZm9yIHN1c3BlbmRpbmcgdGhlIFVJXG4vLyB1bnRpbCB0aGUgYXN5bmMgYWN0aW9uIHNjb3BlIGhhcyBjb21wbGV0ZWQuXG5cbnZhciBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUgPSBudWxsO1xuZnVuY3Rpb24gZW50YW5nbGVBc3luY0FjdGlvbih0cmFuc2l0aW9uLCB0aGVuYWJsZSkge1xuICAvLyBgdGhlbmFibGVgIGlzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGFzeW5jIGFjdGlvbiBzY29wZSBmdW5jdGlvbi4gQ3JlYXRlXG4gIC8vIGEgY29tYmluZWQgdGhlbmFibGUgdGhhdCByZXNvbHZlcyBvbmNlIGV2ZXJ5IGVudGFuZ2xlZCBzY29wZSBmdW5jdGlvblxuICAvLyBoYXMgZmluaXNoZWQuXG4gIGlmIChjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzID09PSBudWxsKSB7XG4gICAgLy8gVGhlcmUncyBubyBvdXRlciBhc3luYyBhY3Rpb24gc2NvcGUuIENyZWF0ZSBhIG5ldyBvbmUuXG4gICAgdmFyIGVudGFuZ2xlZExpc3RlbmVycyA9IGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMgPSBbXTtcbiAgICBjdXJyZW50RW50YW5nbGVkUGVuZGluZ0NvdW50ID0gMDtcbiAgICBjdXJyZW50RW50YW5nbGVkTGFuZSA9IHJlcXVlc3RUcmFuc2l0aW9uTGFuZSgpO1xuICAgIHZhciBlbnRhbmdsZWRUaGVuYWJsZSA9IHtcbiAgICAgIHN0YXR1czogJ3BlbmRpbmcnLFxuICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIHRoZW46IGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgIGVudGFuZ2xlZExpc3RlbmVycy5wdXNoKHJlc29sdmUpO1xuICAgICAgfVxuICAgIH07XG4gICAgY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlID0gZW50YW5nbGVkVGhlbmFibGU7XG4gIH1cblxuICBjdXJyZW50RW50YW5nbGVkUGVuZGluZ0NvdW50Kys7XG4gIHRoZW5hYmxlLnRoZW4ocGluZ0VuZ3RhbmdsZWRBY3Rpb25TY29wZSwgcGluZ0VuZ3RhbmdsZWRBY3Rpb25TY29wZSk7XG4gIHJldHVybiB0aGVuYWJsZTtcbn1cblxuZnVuY3Rpb24gcGluZ0VuZ3RhbmdsZWRBY3Rpb25TY29wZSgpIHtcbiAgaWYgKGN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMgIT09IG51bGwgJiYgLS1jdXJyZW50RW50YW5nbGVkUGVuZGluZ0NvdW50ID09PSAwKSB7XG4gICAgLy8gQWxsIHRoZSBhY3Rpb25zIGhhdmUgZmluaXNoZWQuIENsb3NlIHRoZSBlbnRhbmdsZWQgYXN5bmMgYWN0aW9uIHNjb3BlXG4gICAgLy8gYW5kIG5vdGlmeSBhbGwgdGhlIGxpc3RlbmVycy5cbiAgICBpZiAoY3VycmVudEVudGFuZ2xlZEFjdGlvblRoZW5hYmxlICE9PSBudWxsKSB7XG4gICAgICB2YXIgZnVsZmlsbGVkVGhlbmFibGUgPSBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGU7XG4gICAgICBmdWxmaWxsZWRUaGVuYWJsZS5zdGF0dXMgPSAnZnVsZmlsbGVkJztcbiAgICB9XG5cbiAgICB2YXIgbGlzdGVuZXJzID0gY3VycmVudEVudGFuZ2xlZExpc3RlbmVycztcbiAgICBjdXJyZW50RW50YW5nbGVkTGlzdGVuZXJzID0gbnVsbDtcbiAgICBjdXJyZW50RW50YW5nbGVkTGFuZSA9IE5vTGFuZTtcbiAgICBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBsaXN0ZW5lciA9IGxpc3RlbmVyc1tpXTtcbiAgICAgIGxpc3RlbmVyKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoYWluVGhlbmFibGVWYWx1ZSh0aGVuYWJsZSwgcmVzdWx0KSB7XG4gIC8vIEVxdWl2YWxlbnQgdG86IFByb21pc2UucmVzb2x2ZSh0aGVuYWJsZSkudGhlbigoKSA9PiByZXN1bHQpLCBleGNlcHQgd2UgY2FuXG4gIC8vIGNoZWF0IGEgYml0IHNpbmNlIHdlIGtub3cgdGhhdCB0aGF0IHRoaXMgdGhlbmFibGUgaXMgb25seSBldmVyIGNvbnN1bWVkXG4gIC8vIGJ5IFJlYWN0LlxuICAvL1xuICAvLyBXZSBkb24ndCB0ZWNobmljYWxseSByZXF1aXJlIHByb21pc2Ugc3VwcG9ydCBvbiB0aGUgY2xpZW50IHlldCwgaGVuY2UgdGhpc1xuICAvLyBleHRyYSBjb2RlLlxuICB2YXIgbGlzdGVuZXJzID0gW107XG4gIHZhciB0aGVuYWJsZVdpdGhPdmVycmlkZSA9IHtcbiAgICBzdGF0dXM6ICdwZW5kaW5nJyxcbiAgICB2YWx1ZTogbnVsbCxcbiAgICByZWFzb246IG51bGwsXG4gICAgdGhlbjogZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIGxpc3RlbmVycy5wdXNoKHJlc29sdmUpO1xuICAgIH1cbiAgfTtcbiAgdGhlbmFibGUudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB2YXIgZnVsZmlsbGVkVGhlbmFibGUgPSB0aGVuYWJsZVdpdGhPdmVycmlkZTtcbiAgICBmdWxmaWxsZWRUaGVuYWJsZS5zdGF0dXMgPSAnZnVsZmlsbGVkJztcbiAgICBmdWxmaWxsZWRUaGVuYWJsZS52YWx1ZSA9IHJlc3VsdDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07XG4gICAgICBsaXN0ZW5lcihyZXN1bHQpO1xuICAgIH1cbiAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgdmFyIHJlamVjdGVkVGhlbmFibGUgPSB0aGVuYWJsZVdpdGhPdmVycmlkZTtcbiAgICByZWplY3RlZFRoZW5hYmxlLnN0YXR1cyA9ICdyZWplY3RlZCc7XG4gICAgcmVqZWN0ZWRUaGVuYWJsZS5yZWFzb24gPSBlcnJvcjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lcnNbaV07IC8vIFRoaXMgaXMgYSBwZXJmIGhhY2sgd2hlcmUgd2UgY2FsbCB0aGUgYG9uRnVsZmlsbGAgcGluZyBmdW5jdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBgb25SZWplY3RgLCBiZWNhdXNlIHdlIGtub3cgdGhhdCBSZWFjdCBpcyB0aGUgb25seVxuICAgICAgLy8gY29uc3VtZXIgb2YgdGhlc2UgcHJvbWlzZXMsIGFuZCBpdCBwYXNzZXMgdGhlIHNhbWUgbGlzdGVuZXIgdG8gYm90aC5cbiAgICAgIC8vIFdlIGFsc28ga25vdyB0aGF0IGl0IHdpbGwgcmVhZCB0aGUgZXJyb3IgZGlyZWN0bHkgb2ZmIHRoZVxuICAgICAgLy8gYC5yZWFzb25gIGZpZWxkLlxuXG4gICAgICBsaXN0ZW5lcih1bmRlZmluZWQpO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB0aGVuYWJsZVdpdGhPdmVycmlkZTtcbn1cbmZ1bmN0aW9uIHBlZWtFbnRhbmdsZWRBY3Rpb25MYW5lKCkge1xuICByZXR1cm4gY3VycmVudEVudGFuZ2xlZExhbmU7XG59XG5mdW5jdGlvbiBwZWVrRW50YW5nbGVkQWN0aW9uVGhlbmFibGUoKSB7XG4gIHJldHVybiBjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGU7XG59XG5cbnZhciBVcGRhdGVTdGF0ZSA9IDA7XG52YXIgUmVwbGFjZVN0YXRlID0gMTtcbnZhciBGb3JjZVVwZGF0ZSA9IDI7XG52YXIgQ2FwdHVyZVVwZGF0ZSA9IDM7IC8vIEdsb2JhbCBzdGF0ZSB0aGF0IGlzIHJlc2V0IGF0IHRoZSBiZWdpbm5pbmcgb2YgY2FsbGluZyBgcHJvY2Vzc1VwZGF0ZVF1ZXVlYC5cbi8vIEl0IHNob3VsZCBvbmx5IGJlIHJlYWQgcmlnaHQgYWZ0ZXIgY2FsbGluZyBgcHJvY2Vzc1VwZGF0ZVF1ZXVlYCwgdmlhXG4vLyBgY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZ2AuXG5cbnZhciBoYXNGb3JjZVVwZGF0ZSA9IGZhbHNlO1xudmFyIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGU7XG52YXIgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlO1xuXG57XG4gIGRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUgPSBmYWxzZTtcbiAgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKGZpYmVyKSB7XG4gIHZhciBxdWV1ZSA9IHtcbiAgICBiYXNlU3RhdGU6IGZpYmVyLm1lbW9pemVkU3RhdGUsXG4gICAgZmlyc3RCYXNlVXBkYXRlOiBudWxsLFxuICAgIGxhc3RCYXNlVXBkYXRlOiBudWxsLFxuICAgIHNoYXJlZDoge1xuICAgICAgcGVuZGluZzogbnVsbCxcbiAgICAgIGxhbmVzOiBOb0xhbmVzLFxuICAgICAgaGlkZGVuQ2FsbGJhY2tzOiBudWxsXG4gICAgfSxcbiAgICBjYWxsYmFja3M6IG51bGxcbiAgfTtcbiAgZmliZXIudXBkYXRlUXVldWUgPSBxdWV1ZTtcbn1cbmZ1bmN0aW9uIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpIHtcbiAgLy8gQ2xvbmUgdGhlIHVwZGF0ZSBxdWV1ZSBmcm9tIGN1cnJlbnQuIFVubGVzcyBpdCdzIGFscmVhZHkgYSBjbG9uZS5cbiAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gIHZhciBjdXJyZW50UXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlO1xuXG4gIGlmIChxdWV1ZSA9PT0gY3VycmVudFF1ZXVlKSB7XG4gICAgdmFyIGNsb25lID0ge1xuICAgICAgYmFzZVN0YXRlOiBjdXJyZW50UXVldWUuYmFzZVN0YXRlLFxuICAgICAgZmlyc3RCYXNlVXBkYXRlOiBjdXJyZW50UXVldWUuZmlyc3RCYXNlVXBkYXRlLFxuICAgICAgbGFzdEJhc2VVcGRhdGU6IGN1cnJlbnRRdWV1ZS5sYXN0QmFzZVVwZGF0ZSxcbiAgICAgIHNoYXJlZDogY3VycmVudFF1ZXVlLnNoYXJlZCxcbiAgICAgIGNhbGxiYWNrczogbnVsbFxuICAgIH07XG4gICAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjbG9uZTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlVXBkYXRlKGxhbmUpIHtcbiAgdmFyIHVwZGF0ZSA9IHtcbiAgICBsYW5lOiBsYW5lLFxuICAgIHRhZzogVXBkYXRlU3RhdGUsXG4gICAgcGF5bG9hZDogbnVsbCxcbiAgICBjYWxsYmFjazogbnVsbCxcbiAgICBuZXh0OiBudWxsXG4gIH07XG4gIHJldHVybiB1cGRhdGU7XG59XG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUsIGxhbmUpIHtcbiAgdmFyIHVwZGF0ZVF1ZXVlID0gZmliZXIudXBkYXRlUXVldWU7XG5cbiAgaWYgKHVwZGF0ZVF1ZXVlID09PSBudWxsKSB7XG4gICAgLy8gT25seSBvY2N1cnMgaWYgdGhlIGZpYmVyIGhhcyBiZWVuIHVubW91bnRlZC5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBzaGFyZWRRdWV1ZSA9IHVwZGF0ZVF1ZXVlLnNoYXJlZDtcblxuICB7XG4gICAgaWYgKGN1cnJlbnRseVByb2Nlc3NpbmdRdWV1ZSA9PT0gc2hhcmVkUXVldWUgJiYgIWRpZFdhcm5VcGRhdGVJbnNpZGVVcGRhdGUpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcik7XG5cbiAgICAgIGVycm9yKCdBbiB1cGRhdGUgKHNldFN0YXRlLCByZXBsYWNlU3RhdGUsIG9yIGZvcmNlVXBkYXRlKSB3YXMgc2NoZWR1bGVkICcgKyAnZnJvbSBpbnNpZGUgYW4gdXBkYXRlIGZ1bmN0aW9uLiBVcGRhdGUgZnVuY3Rpb25zIHNob3VsZCBiZSBwdXJlLCAnICsgJ3dpdGggemVybyBzaWRlLWVmZmVjdHMuIENvbnNpZGVyIHVzaW5nIGNvbXBvbmVudERpZFVwZGF0ZSBvciBhICcgKyAnY2FsbGJhY2suXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudDogJXMnLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgZGlkV2FyblVwZGF0ZUluc2lkZVVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgaWYgKGlzVW5zYWZlQ2xhc3NSZW5kZXJQaGFzZVVwZGF0ZSgpKSB7XG4gICAgLy8gVGhpcyBpcyBhbiB1bnNhZmUgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gQWRkIGRpcmVjdGx5IHRvIHRoZSB1cGRhdGVcbiAgICAvLyBxdWV1ZSBzbyB3ZSBjYW4gcHJvY2VzcyBpdCBpbW1lZGlhdGVseSBkdXJpbmcgdGhlIGN1cnJlbnQgcmVuZGVyLlxuICAgIHZhciBwZW5kaW5nID0gc2hhcmVkUXVldWUucGVuZGluZztcblxuICAgIGlmIChwZW5kaW5nID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG4gICAgICB1cGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlLm5leHQgPSBwZW5kaW5nLm5leHQ7XG4gICAgICBwZW5kaW5nLm5leHQgPSB1cGRhdGU7XG4gICAgfVxuXG4gICAgc2hhcmVkUXVldWUucGVuZGluZyA9IHVwZGF0ZTsgLy8gVXBkYXRlIHRoZSBjaGlsZExhbmVzIGV2ZW4gdGhvdWdoIHdlJ3JlIG1vc3QgbGlrZWx5IGFscmVhZHkgcmVuZGVyaW5nXG4gICAgLy8gdGhpcyBmaWJlci4gVGhpcyBpcyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgaW4gdGhlIGNhc2Ugd2hlcmUgeW91XG4gICAgLy8gdXBkYXRlIGEgZGlmZmVyZW50IGNvbXBvbmVudCBkdXJpbmcgcmVuZGVyIHBoYXNlIHRoYW4gdGhlIG9uZSB0aGF0IGlzXG4gICAgLy8gY3VycmVudGx5IHJlbmRlcmluZ3MgKGEgcGF0dGVybiB0aGF0IGlzIGFjY29tcGFuaWVkIGJ5IGEgd2FybmluZykuXG5cbiAgICByZXR1cm4gdW5zYWZlX21hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290KGZpYmVyLCBsYW5lKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZW5xdWV1ZUNvbmN1cnJlbnRDbGFzc1VwZGF0ZShmaWJlciwgc2hhcmVkUXVldWUsIHVwZGF0ZSwgbGFuZSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgZmliZXIsIGxhbmUpIHtcbiAgdmFyIHVwZGF0ZVF1ZXVlID0gZmliZXIudXBkYXRlUXVldWU7XG5cbiAgaWYgKHVwZGF0ZVF1ZXVlID09PSBudWxsKSB7XG4gICAgLy8gT25seSBvY2N1cnMgaWYgdGhlIGZpYmVyIGhhcyBiZWVuIHVubW91bnRlZC5cbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2hhcmVkUXVldWUgPSB1cGRhdGVRdWV1ZS5zaGFyZWQ7XG5cbiAgaWYgKGlzVHJhbnNpdGlvbkxhbmUobGFuZSkpIHtcbiAgICB2YXIgcXVldWVMYW5lcyA9IHNoYXJlZFF1ZXVlLmxhbmVzOyAvLyBJZiBhbnkgZW50YW5nbGVkIGxhbmVzIGFyZSBubyBsb25nZXIgcGVuZGluZyBvbiB0aGUgcm9vdCwgdGhlbiB0aGV5IG11c3RcbiAgICAvLyBoYXZlIGZpbmlzaGVkLiBXZSBjYW4gcmVtb3ZlIHRoZW0gZnJvbSB0aGUgc2hhcmVkIHF1ZXVlLCB3aGljaCByZXByZXNlbnRzXG4gICAgLy8gYSBzdXBlcnNldCBvZiB0aGUgYWN0dWFsbHkgcGVuZGluZyBsYW5lcy4gSW4gc29tZSBjYXNlcyB3ZSBtYXkgZW50YW5nbGVcbiAgICAvLyBtb3JlIHRoYW4gd2UgbmVlZCB0bywgYnV0IHRoYXQncyBPSy4gSW4gZmFjdCBpdCdzIHdvcnNlIGlmIHdlICpkb24ndCpcbiAgICAvLyBlbnRhbmdsZSB3aGVuIHdlIHNob3VsZC5cblxuICAgIHF1ZXVlTGFuZXMgPSBpbnRlcnNlY3RMYW5lcyhxdWV1ZUxhbmVzLCByb290LnBlbmRpbmdMYW5lcyk7IC8vIEVudGFuZ2xlIHRoZSBuZXcgdHJhbnNpdGlvbiBsYW5lIHdpdGggdGhlIG90aGVyIHRyYW5zaXRpb24gbGFuZXMuXG5cbiAgICB2YXIgbmV3UXVldWVMYW5lcyA9IG1lcmdlTGFuZXMocXVldWVMYW5lcywgbGFuZSk7XG4gICAgc2hhcmVkUXVldWUubGFuZXMgPSBuZXdRdWV1ZUxhbmVzOyAvLyBFdmVuIGlmIHF1ZXVlLmxhbmVzIGFscmVhZHkgaW5jbHVkZSBsYW5lLCB3ZSBkb24ndCBrbm93IGZvciBjZXJ0YWluIGlmXG4gICAgLy8gdGhlIGxhbmUgZmluaXNoZWQgc2luY2UgdGhlIGxhc3QgdGltZSB3ZSBlbnRhbmdsZWQgaXQuIFNvIHdlIG5lZWQgdG9cbiAgICAvLyBlbnRhbmdsZSBpdCBhZ2FpbiwganVzdCB0byBiZSBzdXJlLlxuXG4gICAgbWFya1Jvb3RFbnRhbmdsZWQocm9vdCwgbmV3UXVldWVMYW5lcyk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgY2FwdHVyZWRVcGRhdGUpIHtcbiAgLy8gQ2FwdHVyZWQgdXBkYXRlcyBhcmUgdXBkYXRlcyB0aGF0IGFyZSB0aHJvd24gYnkgYSBjaGlsZCBkdXJpbmcgdGhlIHJlbmRlclxuICAvLyBwaGFzZS4gVGhleSBzaG91bGQgYmUgZGlzY2FyZGVkIGlmIHRoZSByZW5kZXIgaXMgYWJvcnRlZC4gVGhlcmVmb3JlLFxuICAvLyB3ZSBzaG91bGQgb25seSBwdXQgdGhlbSBvbiB0aGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSwgbm90IHRoZSBjdXJyZW50IG9uZS5cbiAgdmFyIHF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7IC8vIENoZWNrIGlmIHRoZSB3b3JrLWluLXByb2dyZXNzIHF1ZXVlIGlzIGEgY2xvbmUuXG5cbiAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICB2YXIgY3VycmVudFF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcblxuICAgIGlmIChxdWV1ZSA9PT0gY3VycmVudFF1ZXVlKSB7XG4gICAgICAvLyBUaGUgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSBpcyB0aGUgc2FtZSBhcyBjdXJyZW50LiBUaGlzIGhhcHBlbnMgd2hlblxuICAgICAgLy8gd2UgYmFpbCBvdXQgb24gYSBwYXJlbnQgZmliZXIgdGhhdCB0aGVuIGNhcHR1cmVzIGFuIGVycm9yIHRocm93biBieVxuICAgICAgLy8gYSBjaGlsZC4gU2luY2Ugd2Ugd2FudCB0byBhcHBlbmQgdGhlIHVwZGF0ZSBvbmx5IHRvIHRoZSB3b3JrLWluXG4gICAgICAvLyAtcHJvZ3Jlc3MgcXVldWUsIHdlIG5lZWQgdG8gY2xvbmUgdGhlIHVwZGF0ZXMuIFdlIHVzdWFsbHkgY2xvbmUgZHVyaW5nXG4gICAgICAvLyBwcm9jZXNzVXBkYXRlUXVldWUsIGJ1dCB0aGF0IGRpZG4ndCBoYXBwZW4gaW4gdGhpcyBjYXNlIGJlY2F1c2Ugd2VcbiAgICAgIC8vIHNraXBwZWQgb3ZlciB0aGUgcGFyZW50IHdoZW4gd2UgYmFpbGVkIG91dC5cbiAgICAgIHZhciBuZXdGaXJzdCA9IG51bGw7XG4gICAgICB2YXIgbmV3TGFzdCA9IG51bGw7XG4gICAgICB2YXIgZmlyc3RCYXNlVXBkYXRlID0gcXVldWUuZmlyc3RCYXNlVXBkYXRlO1xuXG4gICAgICBpZiAoZmlyc3RCYXNlVXBkYXRlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIExvb3AgdGhyb3VnaCB0aGUgdXBkYXRlcyBhbmQgY2xvbmUgdGhlbS5cbiAgICAgICAgdmFyIHVwZGF0ZSA9IGZpcnN0QmFzZVVwZGF0ZTtcblxuICAgICAgICBkbyB7XG4gICAgICAgICAgdmFyIGNsb25lID0ge1xuICAgICAgICAgICAgbGFuZTogdXBkYXRlLmxhbmUsXG4gICAgICAgICAgICB0YWc6IHVwZGF0ZS50YWcsXG4gICAgICAgICAgICBwYXlsb2FkOiB1cGRhdGUucGF5bG9hZCxcbiAgICAgICAgICAgIC8vIFdoZW4gdGhpcyB1cGRhdGUgaXMgcmViYXNlZCwgd2Ugc2hvdWxkIG5vdCBmaXJlIGl0c1xuICAgICAgICAgICAgLy8gY2FsbGJhY2sgYWdhaW4uXG4gICAgICAgICAgICBjYWxsYmFjazogbnVsbCxcbiAgICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKG5ld0xhc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgIG5ld0ZpcnN0ID0gbmV3TGFzdCA9IGNsb25lO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdMYXN0Lm5leHQgPSBjbG9uZTtcbiAgICAgICAgICAgIG5ld0xhc3QgPSBjbG9uZTtcbiAgICAgICAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIHdlIGJhaWwgb3V0IHdoZW4gd2UgZ2V0IGEgbnVsbFxuXG5cbiAgICAgICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICAgICAgfSB3aGlsZSAodXBkYXRlICE9PSBudWxsKTsgLy8gQXBwZW5kIHRoZSBjYXB0dXJlZCB1cGRhdGUgdGhlIGVuZCBvZiB0aGUgY2xvbmVkIGxpc3QuXG5cblxuICAgICAgICBpZiAobmV3TGFzdCA9PT0gbnVsbCkge1xuICAgICAgICAgIG5ld0ZpcnN0ID0gbmV3TGFzdCA9IGNhcHR1cmVkVXBkYXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0xhc3QubmV4dCA9IGNhcHR1cmVkVXBkYXRlO1xuICAgICAgICAgIG5ld0xhc3QgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlcmUgYXJlIG5vIGJhc2UgdXBkYXRlcy5cbiAgICAgICAgbmV3Rmlyc3QgPSBuZXdMYXN0ID0gY2FwdHVyZWRVcGRhdGU7XG4gICAgICB9XG5cbiAgICAgIHF1ZXVlID0ge1xuICAgICAgICBiYXNlU3RhdGU6IGN1cnJlbnRRdWV1ZS5iYXNlU3RhdGUsXG4gICAgICAgIGZpcnN0QmFzZVVwZGF0ZTogbmV3Rmlyc3QsXG4gICAgICAgIGxhc3RCYXNlVXBkYXRlOiBuZXdMYXN0LFxuICAgICAgICBzaGFyZWQ6IGN1cnJlbnRRdWV1ZS5zaGFyZWQsXG4gICAgICAgIGNhbGxiYWNrczogY3VycmVudFF1ZXVlLmNhbGxiYWNrc1xuICAgICAgfTtcbiAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gcXVldWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IC8vIEFwcGVuZCB0aGUgdXBkYXRlIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG5cblxuICB2YXIgbGFzdEJhc2VVcGRhdGUgPSBxdWV1ZS5sYXN0QmFzZVVwZGF0ZTtcblxuICBpZiAobGFzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICBxdWV1ZS5maXJzdEJhc2VVcGRhdGUgPSBjYXB0dXJlZFVwZGF0ZTtcbiAgfSBlbHNlIHtcbiAgICBsYXN0QmFzZVVwZGF0ZS5uZXh0ID0gY2FwdHVyZWRVcGRhdGU7XG4gIH1cblxuICBxdWV1ZS5sYXN0QmFzZVVwZGF0ZSA9IGNhcHR1cmVkVXBkYXRlO1xufVxuXG5mdW5jdGlvbiBnZXRTdGF0ZUZyb21VcGRhdGUod29ya0luUHJvZ3Jlc3MsIHF1ZXVlLCB1cGRhdGUsIHByZXZTdGF0ZSwgbmV4dFByb3BzLCBpbnN0YW5jZSkge1xuICBzd2l0Y2ggKHVwZGF0ZS50YWcpIHtcbiAgICBjYXNlIFJlcGxhY2VTdGF0ZTpcbiAgICAgIHtcbiAgICAgICAgdmFyIHBheWxvYWQgPSB1cGRhdGUucGF5bG9hZDtcblxuICAgICAgICBpZiAodHlwZW9mIHBheWxvYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBVcGRhdGVyIGZ1bmN0aW9uXG4gICAgICAgICAge1xuICAgICAgICAgICAgZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBuZXh0U3RhdGUgPSBwYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTtcblxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBheWxvYWQuY2FsbChpbnN0YW5jZSwgcHJldlN0YXRlLCBuZXh0UHJvcHMpO1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBleGl0RGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gbmV4dFN0YXRlO1xuICAgICAgICB9IC8vIFN0YXRlIG9iamVjdFxuXG5cbiAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICB9XG5cbiAgICBjYXNlIENhcHR1cmVVcGRhdGU6XG4gICAgICB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7XG4gICAgICB9XG4gICAgLy8gSW50ZW50aW9uYWwgZmFsbHRocm91Z2hcblxuICAgIGNhc2UgVXBkYXRlU3RhdGU6XG4gICAgICB7XG4gICAgICAgIHZhciBfcGF5bG9hZCA9IHVwZGF0ZS5wYXlsb2FkO1xuICAgICAgICB2YXIgcGFydGlhbFN0YXRlO1xuXG4gICAgICAgIGlmICh0eXBlb2YgX3BheWxvYWQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAvLyBVcGRhdGVyIGZ1bmN0aW9uXG4gICAgICAgICAge1xuICAgICAgICAgICAgZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcnRpYWxTdGF0ZSA9IF9wYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTtcblxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIF9wYXlsb2FkLmNhbGwoaW5zdGFuY2UsIHByZXZTdGF0ZSwgbmV4dFByb3BzKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZXhpdERpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFBhcnRpYWwgc3RhdGUgb2JqZWN0XG4gICAgICAgICAgcGFydGlhbFN0YXRlID0gX3BheWxvYWQ7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocGFydGlhbFN0YXRlID09PSBudWxsIHx8IHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgLy8gTnVsbCBhbmQgdW5kZWZpbmVkIGFyZSB0cmVhdGVkIGFzIG5vLW9wcy5cbiAgICAgICAgICByZXR1cm4gcHJldlN0YXRlO1xuICAgICAgICB9IC8vIE1lcmdlIHRoZSBwYXJ0aWFsIHN0YXRlIGFuZCB0aGUgcHJldmlvdXMgc3RhdGUuXG5cblxuICAgICAgICByZXR1cm4gYXNzaWduKHt9LCBwcmV2U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gICAgICB9XG5cbiAgICBjYXNlIEZvcmNlVXBkYXRlOlxuICAgICAge1xuICAgICAgICBoYXNGb3JjZVVwZGF0ZSA9IHRydWU7XG4gICAgICAgIHJldHVybiBwcmV2U3RhdGU7XG4gICAgICB9XG4gIH1cblxuICByZXR1cm4gcHJldlN0YXRlO1xufVxuXG52YXIgZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiA9IGZhbHNlOyAvLyBFYWNoIGNhbGwgdG8gcHJvY2Vzc1VwZGF0ZVF1ZXVlIHNob3VsZCBiZSBhY2NvbXBhbmllZCBieSBhIGNhbGwgdG8gdGhpcy4gSXQnc1xuLy8gb25seSBpbiBhIHNlcGFyYXRlIGZ1bmN0aW9uIGJlY2F1c2UgaW4gdXBkYXRlSG9zdFJvb3QsIGl0IG11c3QgaGFwcGVuIGFmdGVyXG4vLyBhbGwgdGhlIGNvbnRleHQgc3RhY2tzIGhhdmUgYmVlbiBwdXNoZWQgdG8sIHRvIHByZXZlbnQgYSBzdGFjayBtaXNtYXRjaC4gQVxuLy8gYml0IHVuZm9ydHVuYXRlLlxuXG5mdW5jdGlvbiBzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKCkge1xuICAvLyBDaGVjayBpZiB0aGlzIHVwZGF0ZSBpcyBwYXJ0IG9mIGEgcGVuZGluZyBhc3luYyBhY3Rpb24uIElmIHNvLCB3ZSdsbFxuICAvLyBuZWVkIHRvIHN1c3BlbmQgdW50aWwgdGhlIGFjdGlvbiBoYXMgZmluaXNoZWQsIHNvIHRoYXQgaXQncyBiYXRjaGVkXG4gIC8vIHRvZ2V0aGVyIHdpdGggZnV0dXJlIHVwZGF0ZXMgaW4gdGhlIHNhbWUgYWN0aW9uLlxuICAvLyBUT0RPOiBPbmNlIHdlIHN1cHBvcnQgaG9va3MgaW5zaWRlIHVzZU1lbW8gKG9yIGFuIGVxdWl2YWxlbnRcbiAgLy8gbWVtb2l6YXRpb24gYm91bmRhcnkgbGlrZSBGb3JnZXQpLCBob2lzdCB0aGlzIGxvZ2ljIHNvIHRoYXQgaXQgb25seVxuICAvLyBzdXNwZW5kcyBpZiB0aGUgbWVtbyBib3VuZGFyeSBwcm9kdWNlcyBhIG5ldyB2YWx1ZS5cbiAgaWYgKGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24pIHtcbiAgICB2YXIgZW50YW5nbGVkQWN0aW9uVGhlbmFibGUgPSBwZWVrRW50YW5nbGVkQWN0aW9uVGhlbmFibGUoKTtcblxuICAgIGlmIChlbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSW5zdGVhZCBvZiB0aGUgdGhyb3dpbmcgdGhlIHRoZW5hYmxlIGRpcmVjdGx5LCB0aHJvdyBhXG4gICAgICAvLyBzcGVjaWFsIG9iamVjdCBsaWtlIGB1c2VgIGRvZXMgc28gd2UgY2FuIGRldGVjdCBpZiBpdCdzIGNhcHR1cmVkXG4gICAgICAvLyBieSB1c2Vyc3BhY2UuXG4gICAgICB0aHJvdyBlbnRhbmdsZWRBY3Rpb25UaGVuYWJsZTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgcHJvcHMsIGluc3RhbmNlLCByZW5kZXJMYW5lcykge1xuICBkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gZmFsc2U7IC8vIFRoaXMgaXMgYWx3YXlzIG5vbi1udWxsIG9uIGEgQ2xhc3NDb21wb25lbnQgb3IgSG9zdFJvb3RcblxuICB2YXIgcXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgaGFzRm9yY2VVcGRhdGUgPSBmYWxzZTtcblxuICB7XG4gICAgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gcXVldWUuc2hhcmVkO1xuICB9XG5cbiAgdmFyIGZpcnN0QmFzZVVwZGF0ZSA9IHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZTtcbiAgdmFyIGxhc3RCYXNlVXBkYXRlID0gcXVldWUubGFzdEJhc2VVcGRhdGU7IC8vIENoZWNrIGlmIHRoZXJlIGFyZSBwZW5kaW5nIHVwZGF0ZXMuIElmIHNvLCB0cmFuc2ZlciB0aGVtIHRvIHRoZSBiYXNlIHF1ZXVlLlxuXG4gIHZhciBwZW5kaW5nUXVldWUgPSBxdWV1ZS5zaGFyZWQucGVuZGluZztcblxuICBpZiAocGVuZGluZ1F1ZXVlICE9PSBudWxsKSB7XG4gICAgcXVldWUuc2hhcmVkLnBlbmRpbmcgPSBudWxsOyAvLyBUaGUgcGVuZGluZyBxdWV1ZSBpcyBjaXJjdWxhci4gRGlzY29ubmVjdCB0aGUgcG9pbnRlciBiZXR3ZWVuIGZpcnN0XG4gICAgLy8gYW5kIGxhc3Qgc28gdGhhdCBpdCdzIG5vbi1jaXJjdWxhci5cblxuICAgIHZhciBsYXN0UGVuZGluZ1VwZGF0ZSA9IHBlbmRpbmdRdWV1ZTtcbiAgICB2YXIgZmlyc3RQZW5kaW5nVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGUubmV4dDtcbiAgICBsYXN0UGVuZGluZ1VwZGF0ZS5uZXh0ID0gbnVsbDsgLy8gQXBwZW5kIHBlbmRpbmcgdXBkYXRlcyB0byBiYXNlIHF1ZXVlXG5cbiAgICBpZiAobGFzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgIGZpcnN0QmFzZVVwZGF0ZSA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGFzdEJhc2VVcGRhdGUubmV4dCA9IGZpcnN0UGVuZGluZ1VwZGF0ZTtcbiAgICB9XG5cbiAgICBsYXN0QmFzZVVwZGF0ZSA9IGxhc3RQZW5kaW5nVXBkYXRlOyAvLyBJZiB0aGVyZSdzIGEgY3VycmVudCBxdWV1ZSwgYW5kIGl0J3MgZGlmZmVyZW50IGZyb20gdGhlIGJhc2UgcXVldWUsIHRoZW5cbiAgICAvLyB3ZSBuZWVkIHRvIHRyYW5zZmVyIHRoZSB1cGRhdGVzIHRvIHRoYXQgcXVldWUsIHRvby4gQmVjYXVzZSB0aGUgYmFzZVxuICAgIC8vIHF1ZXVlIGlzIGEgc2luZ2x5LWxpbmtlZCBsaXN0IHdpdGggbm8gY3ljbGVzLCB3ZSBjYW4gYXBwZW5kIHRvIGJvdGhcbiAgICAvLyBsaXN0cyBhbmQgdGFrZSBhZHZhbnRhZ2Ugb2Ygc3RydWN0dXJhbCBzaGFyaW5nLlxuICAgIC8vIFRPRE86IFBhc3MgYGN1cnJlbnRgIGFzIGFyZ3VtZW50XG5cbiAgICB2YXIgY3VycmVudCA9IHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZTtcblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGlzIGFsd2F5cyBub24tbnVsbCBvbiBhIENsYXNzQ29tcG9uZW50IG9yIEhvc3RSb290XG4gICAgICB2YXIgY3VycmVudFF1ZXVlID0gY3VycmVudC51cGRhdGVRdWV1ZTtcbiAgICAgIHZhciBjdXJyZW50TGFzdEJhc2VVcGRhdGUgPSBjdXJyZW50UXVldWUubGFzdEJhc2VVcGRhdGU7XG5cbiAgICAgIGlmIChjdXJyZW50TGFzdEJhc2VVcGRhdGUgIT09IGxhc3RCYXNlVXBkYXRlKSB7XG4gICAgICAgIGlmIChjdXJyZW50TGFzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICBjdXJyZW50UXVldWUuZmlyc3RCYXNlVXBkYXRlID0gZmlyc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGN1cnJlbnRMYXN0QmFzZVVwZGF0ZS5uZXh0ID0gZmlyc3RQZW5kaW5nVXBkYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VycmVudFF1ZXVlLmxhc3RCYXNlVXBkYXRlID0gbGFzdFBlbmRpbmdVcGRhdGU7XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFRoZXNlIHZhbHVlcyBtYXkgY2hhbmdlIGFzIHdlIHByb2Nlc3MgdGhlIHF1ZXVlLlxuXG5cbiAgaWYgKGZpcnN0QmFzZVVwZGF0ZSAhPT0gbnVsbCkge1xuICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCB0aGUgbGlzdCBvZiB1cGRhdGVzIHRvIGNvbXB1dGUgdGhlIHJlc3VsdC5cbiAgICB2YXIgbmV3U3RhdGUgPSBxdWV1ZS5iYXNlU3RhdGU7IC8vIFRPRE86IERvbid0IG5lZWQgdG8gYWNjdW11bGF0ZSB0aGlzLiBJbnN0ZWFkLCB3ZSBjYW4gcmVtb3ZlIHJlbmRlckxhbmVzXG4gICAgLy8gZnJvbSB0aGUgb3JpZ2luYWwgbGFuZXMuXG5cbiAgICB2YXIgbmV3TGFuZXMgPSBOb0xhbmVzO1xuICAgIHZhciBuZXdCYXNlU3RhdGUgPSBudWxsO1xuICAgIHZhciBuZXdGaXJzdEJhc2VVcGRhdGUgPSBudWxsO1xuICAgIHZhciBuZXdMYXN0QmFzZVVwZGF0ZSA9IG51bGw7XG4gICAgdmFyIHVwZGF0ZSA9IGZpcnN0QmFzZVVwZGF0ZTtcblxuICAgIGRvIHtcbiAgICAgIC8vIEFuIGV4dHJhIE9mZnNjcmVlbkxhbmUgYml0IGlzIGFkZGVkIHRvIHVwZGF0ZXMgdGhhdCB3ZXJlIG1hZGUgdG9cbiAgICAgIC8vIGEgaGlkZGVuIHRyZWUsIHNvIHRoYXQgd2UgY2FuIGRpc3Rpbmd1aXNoIHRoZW0gZnJvbSB1cGRhdGVzIHRoYXQgd2VyZVxuICAgICAgLy8gYWxyZWFkeSB0aGVyZSB3aGVuIHRoZSB0cmVlIHdhcyBoaWRkZW4uXG4gICAgICB2YXIgdXBkYXRlTGFuZSA9IHJlbW92ZUxhbmVzKHVwZGF0ZS5sYW5lLCBPZmZzY3JlZW5MYW5lKTtcbiAgICAgIHZhciBpc0hpZGRlblVwZGF0ZSA9IHVwZGF0ZUxhbmUgIT09IHVwZGF0ZS5sYW5lOyAvLyBDaGVjayBpZiB0aGlzIHVwZGF0ZSB3YXMgbWFkZSB3aGlsZSB0aGUgdHJlZSB3YXMgaGlkZGVuLiBJZiBzbywgdGhlblxuICAgICAgLy8gaXQncyBub3QgYSBcImJhc2VcIiB1cGRhdGUgYW5kIHdlIHNob3VsZCBkaXNyZWdhcmQgdGhlIGV4dHJhIGJhc2UgbGFuZXNcbiAgICAgIC8vIHRoYXQgd2VyZSBhZGRlZCB0byByZW5kZXJMYW5lcyB3aGVuIHdlIGVudGVyZWQgdGhlIE9mZnNjcmVlbiB0cmVlLlxuXG4gICAgICB2YXIgc2hvdWxkU2tpcFVwZGF0ZSA9IGlzSGlkZGVuVXBkYXRlID8gIWlzU3Vic2V0T2ZMYW5lcyhnZXRXb3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcygpLCB1cGRhdGVMYW5lKSA6ICFpc1N1YnNldE9mTGFuZXMocmVuZGVyTGFuZXMsIHVwZGF0ZUxhbmUpO1xuXG4gICAgICBpZiAoc2hvdWxkU2tpcFVwZGF0ZSkge1xuICAgICAgICAvLyBQcmlvcml0eSBpcyBpbnN1ZmZpY2llbnQuIFNraXAgdGhpcyB1cGRhdGUuIElmIHRoaXMgaXMgdGhlIGZpcnN0XG4gICAgICAgIC8vIHNraXBwZWQgdXBkYXRlLCB0aGUgcHJldmlvdXMgdXBkYXRlL3N0YXRlIGlzIHRoZSBuZXcgYmFzZVxuICAgICAgICAvLyB1cGRhdGUvc3RhdGUuXG4gICAgICAgIHZhciBjbG9uZSA9IHtcbiAgICAgICAgICBsYW5lOiB1cGRhdGVMYW5lLFxuICAgICAgICAgIHRhZzogdXBkYXRlLnRhZyxcbiAgICAgICAgICBwYXlsb2FkOiB1cGRhdGUucGF5bG9hZCxcbiAgICAgICAgICBjYWxsYmFjazogdXBkYXRlLmNhbGxiYWNrLFxuICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobmV3TGFzdEJhc2VVcGRhdGUgPT09IG51bGwpIHtcbiAgICAgICAgICBuZXdGaXJzdEJhc2VVcGRhdGUgPSBuZXdMYXN0QmFzZVVwZGF0ZSA9IGNsb25lO1xuICAgICAgICAgIG5ld0Jhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld0xhc3RCYXNlVXBkYXRlID0gbmV3TGFzdEJhc2VVcGRhdGUubmV4dCA9IGNsb25lO1xuICAgICAgICB9IC8vIFVwZGF0ZSB0aGUgcmVtYWluaW5nIHByaW9yaXR5IGluIHRoZSBxdWV1ZS5cblxuXG4gICAgICAgIG5ld0xhbmVzID0gbWVyZ2VMYW5lcyhuZXdMYW5lcywgdXBkYXRlTGFuZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIHVwZGF0ZSBkb2VzIGhhdmUgc3VmZmljaWVudCBwcmlvcml0eS5cbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyB1cGRhdGUgaXMgcGFydCBvZiBhIHBlbmRpbmcgYXN5bmMgYWN0aW9uLiBJZiBzbyxcbiAgICAgICAgLy8gd2UnbGwgbmVlZCB0byBzdXNwZW5kIHVudGlsIHRoZSBhY3Rpb24gaGFzIGZpbmlzaGVkLCBzbyB0aGF0IGl0J3NcbiAgICAgICAgLy8gYmF0Y2hlZCB0b2dldGhlciB3aXRoIGZ1dHVyZSB1cGRhdGVzIGluIHRoZSBzYW1lIGFjdGlvbi5cbiAgICAgICAgaWYgKHVwZGF0ZUxhbmUgIT09IE5vTGFuZSAmJiB1cGRhdGVMYW5lID09PSBwZWVrRW50YW5nbGVkQWN0aW9uTGFuZSgpKSB7XG4gICAgICAgICAgZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV3TGFzdEJhc2VVcGRhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgX2Nsb25lID0ge1xuICAgICAgICAgICAgLy8gVGhpcyB1cGRhdGUgaXMgZ29pbmcgdG8gYmUgY29tbWl0dGVkIHNvIHdlIG5ldmVyIHdhbnQgdW5jb21taXRcbiAgICAgICAgICAgIC8vIGl0LiBVc2luZyBOb0xhbmUgd29ya3MgYmVjYXVzZSAwIGlzIGEgc3Vic2V0IG9mIGFsbCBiaXRtYXNrcywgc29cbiAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBuZXZlciBiZSBza2lwcGVkIGJ5IHRoZSBjaGVjayBhYm92ZS5cbiAgICAgICAgICAgIGxhbmU6IE5vTGFuZSxcbiAgICAgICAgICAgIHRhZzogdXBkYXRlLnRhZyxcbiAgICAgICAgICAgIHBheWxvYWQ6IHVwZGF0ZS5wYXlsb2FkLFxuICAgICAgICAgICAgLy8gV2hlbiB0aGlzIHVwZGF0ZSBpcyByZWJhc2VkLCB3ZSBzaG91bGQgbm90IGZpcmUgaXRzXG4gICAgICAgICAgICAvLyBjYWxsYmFjayBhZ2Fpbi5cbiAgICAgICAgICAgIGNhbGxiYWNrOiBudWxsLFxuICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgICAgbmV3TGFzdEJhc2VVcGRhdGUgPSBuZXdMYXN0QmFzZVVwZGF0ZS5uZXh0ID0gX2Nsb25lO1xuICAgICAgICB9IC8vIFByb2Nlc3MgdGhpcyB1cGRhdGUuXG5cblxuICAgICAgICBuZXdTdGF0ZSA9IGdldFN0YXRlRnJvbVVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgcXVldWUsIHVwZGF0ZSwgbmV3U3RhdGUsIHByb3BzLCBpbnN0YW5jZSk7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHVwZGF0ZS5jYWxsYmFjaztcblxuICAgICAgICBpZiAoY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBDYWxsYmFjaztcblxuICAgICAgICAgIGlmIChpc0hpZGRlblVwZGF0ZSkge1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVmlzaWJpbGl0eTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY2FsbGJhY2tzID0gcXVldWUuY2FsbGJhY2tzO1xuXG4gICAgICAgICAgaWYgKGNhbGxiYWNrcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcXVldWUuY2FsbGJhY2tzID0gW2NhbGxiYWNrXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSB3ZSBiYWlsIG91dCB3aGVuIHdlIGdldCBhIG51bGxcblxuXG4gICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcblxuICAgICAgaWYgKHVwZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICBwZW5kaW5nUXVldWUgPSBxdWV1ZS5zaGFyZWQucGVuZGluZztcblxuICAgICAgICBpZiAocGVuZGluZ1F1ZXVlID09PSBudWxsKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQW4gdXBkYXRlIHdhcyBzY2hlZHVsZWQgZnJvbSBpbnNpZGUgYSByZWR1Y2VyLiBBZGQgdGhlIG5ld1xuICAgICAgICAgIC8vIHBlbmRpbmcgdXBkYXRlcyB0byB0aGUgZW5kIG9mIHRoZSBsaXN0IGFuZCBrZWVwIHByb2Nlc3NpbmcuXG4gICAgICAgICAgdmFyIF9sYXN0UGVuZGluZ1VwZGF0ZSA9IHBlbmRpbmdRdWV1ZTsgLy8gSW50ZW50aW9uYWxseSB1bnNvdW5kLiBQZW5kaW5nIHVwZGF0ZXMgZm9ybSBhIGNpcmN1bGFyIGxpc3QsIGJ1dCB3ZVxuICAgICAgICAgIC8vIHVucmF2ZWwgdGhlbSB3aGVuIHRyYW5zZmVycmluZyB0aGVtIHRvIHRoZSBiYXNlIHF1ZXVlLlxuXG4gICAgICAgICAgdmFyIF9maXJzdFBlbmRpbmdVcGRhdGUgPSBfbGFzdFBlbmRpbmdVcGRhdGUubmV4dDtcbiAgICAgICAgICBfbGFzdFBlbmRpbmdVcGRhdGUubmV4dCA9IG51bGw7XG4gICAgICAgICAgdXBkYXRlID0gX2ZpcnN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgICAgICBxdWV1ZS5sYXN0QmFzZVVwZGF0ZSA9IF9sYXN0UGVuZGluZ1VwZGF0ZTtcbiAgICAgICAgICBxdWV1ZS5zaGFyZWQucGVuZGluZyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IHdoaWxlICh0cnVlKTtcblxuICAgIGlmIChuZXdMYXN0QmFzZVVwZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgbmV3QmFzZVN0YXRlID0gbmV3U3RhdGU7XG4gICAgfVxuXG4gICAgcXVldWUuYmFzZVN0YXRlID0gbmV3QmFzZVN0YXRlO1xuICAgIHF1ZXVlLmZpcnN0QmFzZVVwZGF0ZSA9IG5ld0ZpcnN0QmFzZVVwZGF0ZTtcbiAgICBxdWV1ZS5sYXN0QmFzZVVwZGF0ZSA9IG5ld0xhc3RCYXNlVXBkYXRlO1xuXG4gICAgaWYgKGZpcnN0QmFzZVVwZGF0ZSA9PT0gbnVsbCkge1xuICAgICAgLy8gYHF1ZXVlLmxhbmVzYCBpcyB1c2VkIGZvciBlbnRhbmdsaW5nIHRyYW5zaXRpb25zLiBXZSBjYW4gc2V0IGl0IGJhY2sgdG9cbiAgICAgIC8vIHplcm8gb25jZSB0aGUgcXVldWUgaXMgZW1wdHkuXG4gICAgICBxdWV1ZS5zaGFyZWQubGFuZXMgPSBOb0xhbmVzO1xuICAgIH0gLy8gU2V0IHRoZSByZW1haW5pbmcgZXhwaXJhdGlvbiB0aW1lIHRvIGJlIHdoYXRldmVyIGlzIHJlbWFpbmluZyBpbiB0aGUgcXVldWUuXG4gICAgLy8gVGhpcyBzaG91bGQgYmUgZmluZSBiZWNhdXNlIHRoZSBvbmx5IHR3byBvdGhlciB0aGluZ3MgdGhhdCBjb250cmlidXRlIHRvXG4gICAgLy8gZXhwaXJhdGlvbiB0aW1lIGFyZSBwcm9wcyBhbmQgY29udGV4dC4gV2UncmUgYWxyZWFkeSBpbiB0aGUgbWlkZGxlIG9mIHRoZVxuICAgIC8vIGJlZ2luIHBoYXNlIGJ5IHRoZSB0aW1lIHdlIHN0YXJ0IHByb2Nlc3NpbmcgdGhlIHF1ZXVlLCBzbyB3ZSd2ZSBhbHJlYWR5XG4gICAgLy8gZGVhbHQgd2l0aCB0aGUgcHJvcHMuIENvbnRleHQgaW4gY29tcG9uZW50cyB0aGF0IHNwZWNpZnlcbiAgICAvLyBzaG91bGRDb21wb25lbnRVcGRhdGUgaXMgdHJpY2t5OyBidXQgd2UnbGwgaGF2ZSB0byBhY2NvdW50IGZvclxuICAgIC8vIHRoYXQgcmVnYXJkbGVzcy5cblxuXG4gICAgbWFya1NraXBwZWRVcGRhdGVMYW5lcyhuZXdMYW5lcyk7XG4gICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBuZXdMYW5lcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gIH1cblxuICB7XG4gICAgY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlID0gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsQ2FsbGJhY2soY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudCBwYXNzZWQgYXMgY2FsbGJhY2suIEV4cGVjdGVkIGEgZnVuY3Rpb24uIEluc3RlYWQgJyArIChcInJlY2VpdmVkOiBcIiArIGNhbGxiYWNrKSk7XG4gIH1cblxuICBjYWxsYmFjay5jYWxsKGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiByZXNldEhhc0ZvcmNlVXBkYXRlQmVmb3JlUHJvY2Vzc2luZygpIHtcbiAgaGFzRm9yY2VVcGRhdGUgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSB7XG4gIHJldHVybiBoYXNGb3JjZVVwZGF0ZTtcbn1cbmZ1bmN0aW9uIGRlZmVySGlkZGVuQ2FsbGJhY2tzKHVwZGF0ZVF1ZXVlKSB7XG4gIC8vIFdoZW4gYW4gdXBkYXRlIGZpbmlzaGVzIG9uIGEgaGlkZGVuIGNvbXBvbmVudCwgaXRzIGNhbGxiYWNrIHNob3VsZCBub3RcbiAgLy8gYmUgZmlyZWQgdW50aWwvdW5sZXNzIHRoZSBjb21wb25lbnQgaXMgbWFkZSB2aXNpYmxlIGFnYWluLiBTdGFzaCB0aGVcbiAgLy8gY2FsbGJhY2sgb24gdGhlIHNoYXJlZCBxdWV1ZSBvYmplY3Qgc28gaXQgY2FuIGJlIGZpcmVkIGxhdGVyLlxuICB2YXIgbmV3SGlkZGVuQ2FsbGJhY2tzID0gdXBkYXRlUXVldWUuY2FsbGJhY2tzO1xuXG4gIGlmIChuZXdIaWRkZW5DYWxsYmFja3MgIT09IG51bGwpIHtcbiAgICB2YXIgZXhpc3RpbmdIaWRkZW5DYWxsYmFja3MgPSB1cGRhdGVRdWV1ZS5zaGFyZWQuaGlkZGVuQ2FsbGJhY2tzO1xuXG4gICAgaWYgKGV4aXN0aW5nSGlkZGVuQ2FsbGJhY2tzID09PSBudWxsKSB7XG4gICAgICB1cGRhdGVRdWV1ZS5zaGFyZWQuaGlkZGVuQ2FsbGJhY2tzID0gbmV3SGlkZGVuQ2FsbGJhY2tzO1xuICAgIH0gZWxzZSB7XG4gICAgICB1cGRhdGVRdWV1ZS5zaGFyZWQuaGlkZGVuQ2FsbGJhY2tzID0gZXhpc3RpbmdIaWRkZW5DYWxsYmFja3MuY29uY2F0KG5ld0hpZGRlbkNhbGxiYWNrcyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjb21taXRIaWRkZW5DYWxsYmFja3ModXBkYXRlUXVldWUsIGNvbnRleHQpIHtcbiAgLy8gVGhpcyBjb21wb25lbnQgaXMgc3dpdGNoaW5nIGZyb20gaGlkZGVuIC0+IHZpc2libGUuIENvbW1pdCBhbnkgY2FsbGJhY2tzXG4gIC8vIHRoYXQgd2VyZSBwcmV2aW91c2x5IGRlZmVycmVkLlxuICB2YXIgaGlkZGVuQ2FsbGJhY2tzID0gdXBkYXRlUXVldWUuc2hhcmVkLmhpZGRlbkNhbGxiYWNrcztcblxuICBpZiAoaGlkZGVuQ2FsbGJhY2tzICE9PSBudWxsKSB7XG4gICAgdXBkYXRlUXVldWUuc2hhcmVkLmhpZGRlbkNhbGxiYWNrcyA9IG51bGw7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhpZGRlbkNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNhbGxiYWNrID0gaGlkZGVuQ2FsbGJhY2tzW2ldO1xuICAgICAgY2FsbENhbGxiYWNrKGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbW1pdENhbGxiYWNrcyh1cGRhdGVRdWV1ZSwgY29udGV4dCkge1xuICB2YXIgY2FsbGJhY2tzID0gdXBkYXRlUXVldWUuY2FsbGJhY2tzO1xuXG4gIGlmIChjYWxsYmFja3MgIT09IG51bGwpIHtcbiAgICB1cGRhdGVRdWV1ZS5jYWxsYmFja3MgPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrc1tpXTtcbiAgICAgIGNhbGxDYWxsYmFjayhjYWxsYmFjaywgY29udGV4dCk7XG4gICAgfVxuICB9XG59XG5cbi8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZyBmYWxzZVxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgdmFsdWVzIG9mIGFsbCBrZXlzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqL1xuXG5mdW5jdGlvbiBzaGFsbG93RXF1YWwob2JqQSwgb2JqQikge1xuICBpZiAob2JqZWN0SXMob2JqQSwgb2JqQikpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gJ29iamVjdCcgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gLy8gVGVzdCBmb3IgQSdzIGtleXMgZGlmZmVyZW50IGZyb20gQi5cblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5c0EubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY3VycmVudEtleSA9IGtleXNBW2ldO1xuXG4gICAgaWYgKCFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iakIsIGN1cnJlbnRLZXkpIHx8IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gbG9zdCByZWZpbmVtZW50IG9mIGBvYmpCYFxuICAgICFvYmplY3RJcyhvYmpBW2N1cnJlbnRLZXldLCBvYmpCW2N1cnJlbnRLZXldKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG52YXIgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MgPSB7XG4gIHJlY29yZFVuc2FmZUxpZmVjeWNsZVdhcm5pbmdzOiBmdW5jdGlvbiAoZmliZXIsIGluc3RhbmNlKSB7fSxcbiAgZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3M6IGZ1bmN0aW9uICgpIHt9LFxuICByZWNvcmRMZWdhY3lDb250ZXh0V2FybmluZzogZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge30sXG4gIGZsdXNoTGVnYWN5Q29udGV4dFdhcm5pbmc6IGZ1bmN0aW9uICgpIHt9LFxuICBkaXNjYXJkUGVuZGluZ1dhcm5pbmdzOiBmdW5jdGlvbiAoKSB7fVxufTtcblxue1xuICB2YXIgZmluZFN0cmljdFJvb3QgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgICB2YXIgbWF5YmVTdHJpY3RSb290ID0gbnVsbDtcbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuXG4gICAgd2hpbGUgKG5vZGUgIT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgIG1heWJlU3RyaWN0Um9vdCA9IG5vZGU7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG5cbiAgICByZXR1cm4gbWF5YmVTdHJpY3RSb290O1xuICB9O1xuXG4gIHZhciBzZXRUb1NvcnRlZFN0cmluZyA9IGZ1bmN0aW9uIChzZXQpIHtcbiAgICB2YXIgYXJyYXkgPSBbXTtcbiAgICBzZXQuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIGFycmF5LnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBhcnJheS5zb3J0KCkuam9pbignLCAnKTtcbiAgfTtcblxuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gIHZhciBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gIHZhciBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gIHZhciBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICB2YXIgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTsgLy8gVHJhY2tzIGNvbXBvbmVudHMgd2UgaGF2ZSBhbHJlYWR5IHdhcm5lZCBhYm91dC5cblxuICB2YXIgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcyA9IG5ldyBTZXQoKTtcblxuICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5yZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyA9IGZ1bmN0aW9uIChmaWJlciwgaW5zdGFuY2UpIHtcbiAgICAvLyBEZWR1cGUgc3RyYXRlZ3k6IFdhcm4gb25jZSBwZXIgY29tcG9uZW50LlxuICAgIGlmIChkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmhhcyhmaWJlci50eXBlKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nICYmIC8vIERvbid0IHdhcm4gYWJvdXQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLlxuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxNb3VudC5fX3N1cHByZXNzRGVwcmVjYXRpb25XYXJuaW5nICE9PSB0cnVlKSB7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlICYmIHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLnB1c2goZmliZXIpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKGZpYmVyLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlICYmIHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MucHVzaChmaWJlcik7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG5cbiAgICBpZiAoZmliZXIubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUgJiYgdHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5wdXNoKGZpYmVyKTtcbiAgICB9XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gV2UgZG8gYW4gaW5pdGlhbCBwYXNzIHRvIGdhdGhlciBjb21wb25lbnQgbmFtZXNcbiAgICB2YXIgY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsTW91bnRXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICBjb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIFVOU0FGRV9jb21wb25lbnRXaWxsTW91bnRVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzLmxlbmd0aCA+IDApIHtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgfVxuXG4gICAgdmFyIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMgPSBuZXcgU2V0KCk7XG5cbiAgICBpZiAocGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MuZm9yRWFjaChmdW5jdGlvbiAoZmliZXIpIHtcbiAgICAgICAgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRVbnNhZmVMaWZlY3ljbGVzLmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgcGVuZGluZ1VOU0FGRV9Db21wb25lbnRXaWxsUmVjZWl2ZVByb3BzV2FybmluZ3MgPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MubGVuZ3RoID4gMCkge1xuICAgICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICBjb21wb25lbnRXaWxsVXBkYXRlVW5pcXVlTmFtZXMuYWRkKGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgICAgZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcy5hZGQoZmliZXIudHlwZSk7XG4gICAgICB9KTtcbiAgICAgIHBlbmRpbmdDb21wb25lbnRXaWxsVXBkYXRlV2FybmluZ3MgPSBbXTtcbiAgICB9XG5cbiAgICB2YXIgVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5sZW5ndGggPiAwKSB7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncy5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICBVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLmFkZChnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuc2FmZUxpZmVjeWNsZXMuYWRkKGZpYmVyLnR5cGUpO1xuICAgICAgfSk7XG4gICAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICAgIH0gLy8gRmluYWxseSwgd2UgZmx1c2ggYWxsIHRoZSB3YXJuaW5nc1xuICAgIC8vIFVOU0FGRV8gb25lcyBiZWZvcmUgdGhlIGRlcHJlY2F0ZWQgb25lcywgc2luY2UgdGhleSdsbCBiZSAnbG91ZGVyJ1xuXG5cbiAgICBpZiAoVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgc29ydGVkTmFtZXMgPSBzZXRUb1NvcnRlZFN0cmluZyhVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMpO1xuXG4gICAgICBlcnJvcignVXNpbmcgVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCBpbiBzdHJpY3QgbW9kZSBpcyBub3QgcmVjb21tZW5kZWQgYW5kIG1heSBpbmRpY2F0ZSBidWdzIGluIHlvdXIgY29kZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgY29kZSB3aXRoIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRNb3VudCwgYW5kIHNldCBpbml0aWFsIHN0YXRlIGluIHRoZSBjb25zdHJ1Y3Rvci5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIHNvcnRlZE5hbWVzKTtcbiAgICB9XG5cbiAgICBpZiAoVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIF9zb3J0ZWROYW1lcyA9IHNldFRvU29ydGVkU3RyaW5nKFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMpO1xuXG4gICAgICBlcnJvcignVXNpbmcgVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgaW4gc3RyaWN0IG1vZGUgaXMgbm90IHJlY29tbWVuZGVkICcgKyAnYW5kIG1heSBpbmRpY2F0ZSBidWdzIGluIHlvdXIgY29kZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgZGF0YSBmZXRjaGluZyBjb2RlIG9yIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRVcGRhdGUuXFxuJyArIFwiKiBJZiB5b3UncmUgdXBkYXRpbmcgc3RhdGUgd2hlbmV2ZXIgcHJvcHMgY2hhbmdlLCBcIiArICdyZWZhY3RvciB5b3VyIGNvZGUgdG8gdXNlIG1lbW9pemF0aW9uIHRlY2huaXF1ZXMgb3IgbW92ZSBpdCB0byAnICsgJ3N0YXRpYyBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuIExlYXJuIG1vcmUgYXQ6IGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvZGVyaXZlZC1zdGF0ZVxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX3NvcnRlZE5hbWVzKTtcbiAgICB9XG5cbiAgICBpZiAoVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcy5zaXplID4gMCkge1xuICAgICAgdmFyIF9zb3J0ZWROYW1lczIgPSBzZXRUb1NvcnRlZFN0cmluZyhVTlNBRkVfY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzKTtcblxuICAgICAgZXJyb3IoJ1VzaW5nIFVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIGluIHN0cmljdCBtb2RlIGlzIG5vdCByZWNvbW1lbmRlZCAnICsgJ2FuZCBtYXkgaW5kaWNhdGUgYnVncyBpbiB5b3VyIGNvZGUuICcgKyAnU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvdW5zYWZlLWNvbXBvbmVudC1saWZlY3ljbGVzIGZvciBkZXRhaWxzLlxcblxcbicgKyAnKiBNb3ZlIGRhdGEgZmV0Y2hpbmcgY29kZSBvciBzaWRlIGVmZmVjdHMgdG8gY29tcG9uZW50RGlkVXBkYXRlLlxcbicgKyAnXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJywgX3NvcnRlZE5hbWVzMik7XG4gICAgfVxuXG4gICAgaWYgKGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgX3NvcnRlZE5hbWVzMyA9IHNldFRvU29ydGVkU3RyaW5nKGNvbXBvbmVudFdpbGxNb3VudFVuaXF1ZU5hbWVzKTtcblxuICAgICAgd2FybignY29tcG9uZW50V2lsbE1vdW50IGhhcyBiZWVuIHJlbmFtZWQsIGFuZCBpcyBub3QgcmVjb21tZW5kZWQgZm9yIHVzZS4gJyArICdTZWUgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay91bnNhZmUtY29tcG9uZW50LWxpZmVjeWNsZXMgZm9yIGRldGFpbHMuXFxuXFxuJyArICcqIE1vdmUgY29kZSB3aXRoIHNpZGUgZWZmZWN0cyB0byBjb21wb25lbnREaWRNb3VudCwgYW5kIHNldCBpbml0aWFsIHN0YXRlIGluIHRoZSBjb25zdHJ1Y3Rvci5cXG4nICsgJyogUmVuYW1lIGNvbXBvbmVudFdpbGxNb3VudCB0byBVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IHRvIHN1cHByZXNzICcgKyAndGhpcyB3YXJuaW5nIGluIG5vbi1zdHJpY3QgbW9kZS4gSW4gUmVhY3QgMTgueCwgb25seSB0aGUgVU5TQUZFXyBuYW1lIHdpbGwgd29yay4gJyArICdUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuICcgKyAnYG5weCByZWFjdC1jb2RlbW9kIHJlbmFtZS11bnNhZmUtbGlmZWN5Y2xlc2AgaW4geW91ciBwcm9qZWN0IHNvdXJjZSBmb2xkZXIuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBfc29ydGVkTmFtZXMzKTtcbiAgICB9XG5cbiAgICBpZiAoY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgX3NvcnRlZE5hbWVzNCA9IHNldFRvU29ydGVkU3RyaW5nKGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNVbmlxdWVOYW1lcyk7XG5cbiAgICAgIHdhcm4oJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4nICsgXCIqIElmIHlvdSdyZSB1cGRhdGluZyBzdGF0ZSB3aGVuZXZlciBwcm9wcyBjaGFuZ2UsIHJlZmFjdG9yIHlvdXIgXCIgKyAnY29kZSB0byB1c2UgbWVtb2l6YXRpb24gdGVjaG5pcXVlcyBvciBtb3ZlIGl0IHRvICcgKyAnc3RhdGljIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcy4gTGVhcm4gbW9yZSBhdDogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9kZXJpdmVkLXN0YXRlXFxuJyArICcqIFJlbmFtZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIHRvIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIHRvIHN1cHByZXNzICcgKyAndGhpcyB3YXJuaW5nIGluIG5vbi1zdHJpY3QgbW9kZS4gSW4gUmVhY3QgMTgueCwgb25seSB0aGUgVU5TQUZFXyBuYW1lIHdpbGwgd29yay4gJyArICdUbyByZW5hbWUgYWxsIGRlcHJlY2F0ZWQgbGlmZWN5Y2xlcyB0byB0aGVpciBuZXcgbmFtZXMsIHlvdSBjYW4gcnVuICcgKyAnYG5weCByZWFjdC1jb2RlbW9kIHJlbmFtZS11bnNhZmUtbGlmZWN5Y2xlc2AgaW4geW91ciBwcm9qZWN0IHNvdXJjZSBmb2xkZXIuXFxuJyArICdcXG5QbGVhc2UgdXBkYXRlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50czogJXMnLCBfc29ydGVkTmFtZXM0KTtcbiAgICB9XG5cbiAgICBpZiAoY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzLnNpemUgPiAwKSB7XG4gICAgICB2YXIgX3NvcnRlZE5hbWVzNSA9IHNldFRvU29ydGVkU3RyaW5nKGNvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyk7XG5cbiAgICAgIHdhcm4oJ2NvbXBvbmVudFdpbGxVcGRhdGUgaGFzIGJlZW4gcmVuYW1lZCwgYW5kIGlzIG5vdCByZWNvbW1lbmRlZCBmb3IgdXNlLiAnICsgJ1NlZSBodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcyBmb3IgZGV0YWlscy5cXG5cXG4nICsgJyogTW92ZSBkYXRhIGZldGNoaW5nIGNvZGUgb3Igc2lkZSBlZmZlY3RzIHRvIGNvbXBvbmVudERpZFVwZGF0ZS5cXG4nICsgJyogUmVuYW1lIGNvbXBvbmVudFdpbGxVcGRhdGUgdG8gVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgdG8gc3VwcHJlc3MgJyArICd0aGlzIHdhcm5pbmcgaW4gbm9uLXN0cmljdCBtb2RlLiBJbiBSZWFjdCAxOC54LCBvbmx5IHRoZSBVTlNBRkVfIG5hbWUgd2lsbCB3b3JrLiAnICsgJ1RvIHJlbmFtZSBhbGwgZGVwcmVjYXRlZCBsaWZlY3ljbGVzIHRvIHRoZWlyIG5ldyBuYW1lcywgeW91IGNhbiBydW4gJyArICdgbnB4IHJlYWN0LWNvZGVtb2QgcmVuYW1lLXVuc2FmZS1saWZlY3ljbGVzYCBpbiB5b3VyIHByb2plY3Qgc291cmNlIGZvbGRlci5cXG4nICsgJ1xcblBsZWFzZSB1cGRhdGUgdGhlIGZvbGxvd2luZyBjb21wb25lbnRzOiAlcycsIF9zb3J0ZWROYW1lczUpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nID0gbmV3IE1hcCgpOyAvLyBUcmFja3MgY29tcG9uZW50cyB3ZSBoYXZlIGFscmVhZHkgd2FybmVkIGFib3V0LlxuXG4gIHZhciBkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0ID0gbmV3IFNldCgpO1xuXG4gIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nID0gZnVuY3Rpb24gKGZpYmVyLCBpbnN0YW5jZSkge1xuICAgIHZhciBzdHJpY3RSb290ID0gZmluZFN0cmljdFJvb3QoZmliZXIpO1xuXG4gICAgaWYgKHN0cmljdFJvb3QgPT09IG51bGwpIHtcbiAgICAgIGVycm9yKCdFeHBlY3RlZCB0byBmaW5kIGEgU3RyaWN0TW9kZSBjb21wb25lbnQgaW4gYSBzdHJpY3QgbW9kZSB0cmVlLiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIERlZHVwIHN0cmF0ZWd5OiBXYXJuIG9uY2UgcGVyIGNvbXBvbmVudC5cblxuXG4gICAgaWYgKGRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQuaGFzKGZpYmVyLnR5cGUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHdhcm5pbmdzRm9yUm9vdCA9IHBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZy5nZXQoc3RyaWN0Um9vdCk7XG5cbiAgICBpZiAoZmliZXIudHlwZS5jb250ZXh0VHlwZXMgIT0gbnVsbCB8fCBmaWJlci50eXBlLmNoaWxkQ29udGV4dFR5cGVzICE9IG51bGwgfHwgaW5zdGFuY2UgIT09IG51bGwgJiYgdHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHdhcm5pbmdzRm9yUm9vdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHdhcm5pbmdzRm9yUm9vdCA9IFtdO1xuICAgICAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuc2V0KHN0cmljdFJvb3QsIHdhcm5pbmdzRm9yUm9vdCk7XG4gICAgICB9XG5cbiAgICAgIHdhcm5pbmdzRm9yUm9vdC5wdXNoKGZpYmVyKTtcbiAgICB9XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hMZWdhY3lDb250ZXh0V2FybmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwZW5kaW5nTGVnYWN5Q29udGV4dFdhcm5pbmcuZm9yRWFjaChmdW5jdGlvbiAoZmliZXJBcnJheSwgc3RyaWN0Um9vdCkge1xuICAgICAgaWYgKGZpYmVyQXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpcnN0RmliZXIgPSBmaWJlckFycmF5WzBdO1xuICAgICAgdmFyIHVuaXF1ZU5hbWVzID0gbmV3IFNldCgpO1xuICAgICAgZmliZXJBcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChmaWJlcikge1xuICAgICAgICB1bmlxdWVOYW1lcy5hZGQoZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ0NvbXBvbmVudCcpO1xuICAgICAgICBkaWRXYXJuQWJvdXRMZWdhY3lDb250ZXh0LmFkZChmaWJlci50eXBlKTtcbiAgICAgIH0pO1xuICAgICAgdmFyIHNvcnRlZE5hbWVzID0gc2V0VG9Tb3J0ZWRTdHJpbmcodW5pcXVlTmFtZXMpO1xuXG4gICAgICB0cnkge1xuICAgICAgICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKGZpcnN0RmliZXIpO1xuXG4gICAgICAgIGVycm9yKCdMZWdhY3kgY29udGV4dCBBUEkgaGFzIGJlZW4gZGV0ZWN0ZWQgd2l0aGluIGEgc3RyaWN0LW1vZGUgdHJlZS4nICsgJ1xcblxcblRoZSBvbGQgQVBJIHdpbGwgYmUgc3VwcG9ydGVkIGluIGFsbCAxNi54IHJlbGVhc2VzLCBidXQgYXBwbGljYXRpb25zICcgKyAndXNpbmcgaXQgc2hvdWxkIG1pZ3JhdGUgdG8gdGhlIG5ldyB2ZXJzaW9uLicgKyAnXFxuXFxuUGxlYXNlIHVwZGF0ZSB0aGUgZm9sbG93aW5nIGNvbXBvbmVudHM6ICVzJyArICdcXG5cXG5MZWFybiBtb3JlIGFib3V0IHRoaXMgd2FybmluZyBoZXJlOiBodHRwczovL3JlYWN0LmRldi9saW5rL2xlZ2FjeS1jb250ZXh0Jywgc29ydGVkTmFtZXMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgcmVzZXRDdXJyZW50RGVidWdGaWJlckluREVWKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG5cbiAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZGlzY2FyZFBlbmRpbmdXYXJuaW5ncyA9IGZ1bmN0aW9uICgpIHtcbiAgICBwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MgPSBbXTtcbiAgICBwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyA9IFtdO1xuICAgIHBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzID0gW107XG4gICAgcGVuZGluZ0xlZ2FjeUNvbnRleHRXYXJuaW5nID0gbmV3IE1hcCgpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRUaGVuYWJsZXNGcm9tU3RhdGUoc3RhdGUpIHtcbiAge1xuICAgIHZhciBkZXZTdGF0ZSA9IHN0YXRlO1xuICAgIHJldHVybiBkZXZTdGF0ZS50aGVuYWJsZXM7XG4gIH1cbn0gLy8gQW4gZXJyb3IgdGhhdCBpcyB0aHJvd24gKGUuZy4gYnkgYHVzZWApIHRvIHRyaWdnZXIgU3VzcGVuc2UuIElmIHdlXG4vLyBkZXRlY3QgdGhpcyBpcyBjYXVnaHQgYnkgdXNlcnNwYWNlLCB3ZSdsbCBsb2cgYSB3YXJuaW5nIGluIGRldmVsb3BtZW50LlxuXG5cbnZhciBTdXNwZW5zZUV4Y2VwdGlvbiA9IG5ldyBFcnJvcihcIlN1c3BlbnNlIEV4Y2VwdGlvbjogVGhpcyBpcyBub3QgYSByZWFsIGVycm9yISBJdCdzIGFuIGltcGxlbWVudGF0aW9uIFwiICsgJ2RldGFpbCBvZiBgdXNlYCB0byBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgcmVuZGVyLiBZb3UgbXVzdCBlaXRoZXIgJyArICdyZXRocm93IGl0IGltbWVkaWF0ZWx5LCBvciBtb3ZlIHRoZSBgdXNlYCBjYWxsIG91dHNpZGUgb2YgdGhlICcgKyAnYHRyeS9jYXRjaGAgYmxvY2suIENhcHR1cmluZyB3aXRob3V0IHJldGhyb3dpbmcgd2lsbCBsZWFkIHRvICcgKyAndW5leHBlY3RlZCBiZWhhdmlvci5cXG5cXG4nICsgJ1RvIGhhbmRsZSBhc3luYyBlcnJvcnMsIHdyYXAgeW91ciBjb21wb25lbnQgaW4gYW4gZXJyb3IgYm91bmRhcnksIG9yICcgKyBcImNhbGwgdGhlIHByb21pc2UncyBgLmNhdGNoYCBtZXRob2QgYW5kIHBhc3MgdGhlIHJlc3VsdCB0byBgdXNlYFwiKTtcbnZhciBTdXNwZW5zZXlDb21taXRFeGNlcHRpb24gPSBuZXcgRXJyb3IoJ1N1c3BlbnNlIEV4Y2VwdGlvbjogVGhpcyBpcyBub3QgYSByZWFsIGVycm9yLCBhbmQgc2hvdWxkIG5vdCBsZWFrIGludG8gJyArIFwidXNlcnNwYWNlLiBJZiB5b3UncmUgc2VlaW5nIHRoaXMsIGl0J3MgbGlrZWx5IGEgYnVnIGluIFJlYWN0LlwiKTsgLy8gVGhpcyBpcyBhIG5vb3AgdGhlbmFibGUgdGhhdCB3ZSB1c2UgdG8gdHJpZ2dlciBhIGZhbGxiYWNrIGluIHRocm93RXhjZXB0aW9uLlxuLy8gVE9ETzogSXQgd291bGQgYmUgYmV0dGVyIHRvIHJlZmFjdG9yIHRocm93RXhjZXB0aW9uIGludG8gbXVsdGlwbGUgZnVuY3Rpb25zXG4vLyBzbyB3ZSBjYW4gdHJpZ2dlciBhIGZhbGxiYWNrIGRpcmVjdGx5IHdpdGhvdXQgaGF2aW5nIHRvIGNoZWNrIHRoZSB0eXBlLiBCdXRcbi8vIGZvciBub3cgdGhpcyB3aWxsIGRvLlxuXG52YXIgbm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlID0ge1xuICB0aGVuOiBmdW5jdGlvbiAoKSB7XG4gICAge1xuICAgICAgZXJyb3IoJ0ludGVybmFsIFJlYWN0IGVycm9yOiBBIGxpc3RlbmVyIHdhcyB1bmV4cGVjdGVkbHkgYXR0YWNoZWQgdG8gYSAnICsgJ1wibm9vcFwiIHRoZW5hYmxlLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn07XG5mdW5jdGlvbiBjcmVhdGVUaGVuYWJsZVN0YXRlKCkge1xuICAvLyBUaGUgVGhlbmFibGVTdGF0ZSBpcyBjcmVhdGVkIHRoZSBmaXJzdCB0aW1lIGEgY29tcG9uZW50IHN1c3BlbmRzLiBJZiBpdFxuICAvLyBzdXNwZW5kcyBhZ2Fpbiwgd2UnbGwgcmV1c2UgdGhlIHNhbWUgc3RhdGUuXG4gIHtcbiAgICByZXR1cm4ge1xuICAgICAgZGlkV2FybkFib3V0VW5jYWNoZWRQcm9taXNlOiBmYWxzZSxcbiAgICAgIHRoZW5hYmxlczogW11cbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBpc1RoZW5hYmxlUmVzb2x2ZWQodGhlbmFibGUpIHtcbiAgdmFyIHN0YXR1cyA9IHRoZW5hYmxlLnN0YXR1cztcbiAgcmV0dXJuIHN0YXR1cyA9PT0gJ2Z1bGZpbGxlZCcgfHwgc3RhdHVzID09PSAncmVqZWN0ZWQnO1xufVxuXG5mdW5jdGlvbiBub29wJDEoKSB7fVxuXG5mdW5jdGlvbiB0cmFja1VzZWRUaGVuYWJsZSh0aGVuYWJsZVN0YXRlLCB0aGVuYWJsZSwgaW5kZXgpIHtcbiAgaWYgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlICE9PSBudWxsKSB7XG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuZGlkVXNlUHJvbWlzZSA9IHRydWU7XG4gIH1cblxuICB2YXIgdHJhY2tlZFRoZW5hYmxlcyA9IGdldFRoZW5hYmxlc0Zyb21TdGF0ZSh0aGVuYWJsZVN0YXRlKTtcbiAgdmFyIHByZXZpb3VzID0gdHJhY2tlZFRoZW5hYmxlc1tpbmRleF07XG5cbiAgaWYgKHByZXZpb3VzID09PSB1bmRlZmluZWQpIHtcbiAgICB0cmFja2VkVGhlbmFibGVzLnB1c2godGhlbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIGlmIChwcmV2aW91cyAhPT0gdGhlbmFibGUpIHtcbiAgICAgIC8vIFJldXNlIHRoZSBwcmV2aW91cyB0aGVuYWJsZSwgYW5kIGRyb3AgdGhlIG5ldyBvbmUuIFdlIGNhbiBhc3N1bWVcbiAgICAgIC8vIHRoZXkgcmVwcmVzZW50IHRoZSBzYW1lIHZhbHVlLCBiZWNhdXNlIGNvbXBvbmVudHMgYXJlIGlkZW1wb3RlbnQuXG4gICAgICB7XG4gICAgICAgIHZhciB0aGVuYWJsZVN0YXRlRGV2ID0gdGhlbmFibGVTdGF0ZTtcblxuICAgICAgICBpZiAoIXRoZW5hYmxlU3RhdGVEZXYuZGlkV2FybkFib3V0VW5jYWNoZWRQcm9taXNlKSB7XG4gICAgICAgICAgLy8gV2Ugc2hvdWxkIG9ubHkgd2FybiB0aGUgZmlyc3QgdGltZSBhbiB1bmNhY2hlZCB0aGVuYWJsZSBpc1xuICAgICAgICAgIC8vIGRpc2NvdmVyZWQgcGVyIGNvbXBvbmVudCwgYmVjYXVzZSBpZiB0aGVyZSBhcmUgbXVsdGlwbGUsIHRoZVxuICAgICAgICAgIC8vIHN1YnNlcXVlbnQgb25lcyBhcmUgbGlrZWx5IGRlcml2ZWQgZnJvbSB0aGUgZmlyc3QuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBXZSB0cmFjayB0aGlzIG9uIHRoZSB0aGVuYWJsZVN0YXRlIGluc3RlYWQgb2YgZGVkdXBpbmcgdXNpbmcgdGhlXG4gICAgICAgICAgLy8gY29tcG9uZW50IG5hbWUgbGlrZSB3ZSB1c3VhbGx5IGRvLCBiZWNhdXNlIGluIHRoZSBjYXNlIG9mIGFcbiAgICAgICAgICAvLyBwcm9taXNlLWFzLVJlYWN0LW5vZGUsIHRoZSBvd25lciBjb21wb25lbnQgaXMgbGlrZWx5IGRpZmZlcmVudCBmcm9tXG4gICAgICAgICAgLy8gdGhlIHBhcmVudCB0aGF0J3MgY3VycmVudGx5IGJlaW5nIHJlY29uY2lsZWQuIFdlJ2QgaGF2ZSB0byB0cmFja1xuICAgICAgICAgIC8vIHRoZSBvd25lciB1c2luZyBzdGF0ZSwgd2hpY2ggd2UncmUgdHJ5aW5nIHRvIG1vdmUgYXdheSBmcm9tLiBUaG91Z2hcbiAgICAgICAgICAvLyBzaW5jZSB0aGlzIGlzIGRldi1vbmx5LCBtYXliZSB0aGF0J2QgYmUgT0suXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBIb3dldmVyLCBhbm90aGVyIGJlbmVmaXQgb2YgZG9pbmcgaXQgdGhpcyB3YXkgaXMgd2UgbWlnaHRcbiAgICAgICAgICAvLyBldmVudHVhbGx5IGhhdmUgYSB0aGVuYWJsZVN0YXRlIHBlciBtZW1vL0ZvcmdldCBib3VuZGFyeSBpbnN0ZWFkXG4gICAgICAgICAgLy8gb2YgcGVyIGNvbXBvbmVudCwgc28gdGhpcyB3b3VsZCBhbGxvdyB1cyB0byBoYXZlIG1vcmVcbiAgICAgICAgICAvLyBncmFudWxhciB3YXJuaW5ncy5cbiAgICAgICAgICB0aGVuYWJsZVN0YXRlRGV2LmRpZFdhcm5BYm91dFVuY2FjaGVkUHJvbWlzZSA9IHRydWU7IC8vIFRPRE86IFRoaXMgd2FybmluZyBzaG91bGQgbGluayB0byBhIGNvcnJlc3BvbmRpbmcgZG9jcyBwYWdlLlxuXG4gICAgICAgICAgZXJyb3IoJ0EgY29tcG9uZW50IHdhcyBzdXNwZW5kZWQgYnkgYW4gdW5jYWNoZWQgcHJvbWlzZS4gQ3JlYXRpbmcgJyArICdwcm9taXNlcyBpbnNpZGUgYSBDbGllbnQgQ29tcG9uZW50IG9yIGhvb2sgaXMgbm90IHlldCAnICsgJ3N1cHBvcnRlZCwgZXhjZXB0IHZpYSBhIFN1c3BlbnNlLWNvbXBhdGlibGUgbGlicmFyeSBvciBmcmFtZXdvcmsuJyk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gQXZvaWQgYW4gdW5oYW5kbGVkIHJlamVjdGlvbiBlcnJvcnMgZm9yIHRoZSBQcm9taXNlcyB0aGF0IHdlJ2xsXG4gICAgICAvLyBpbnRlbnRpb25hbGx5IGlnbm9yZS5cblxuXG4gICAgICB0aGVuYWJsZS50aGVuKG5vb3AkMSwgbm9vcCQxKTtcbiAgICAgIHRoZW5hYmxlID0gcHJldmlvdXM7XG4gICAgfVxuICB9IC8vIFdlIHVzZSBhbiBleHBhbmRvIHRvIHRyYWNrIHRoZSBzdGF0dXMgYW5kIHJlc3VsdCBvZiBhIHRoZW5hYmxlIHNvIHRoYXQgd2VcbiAgLy8gY2FuIHN5bmNocm9ub3VzbHkgdW53cmFwIHRoZSB2YWx1ZS4gVGhpbmsgb2YgdGhpcyBhcyBhbiBleHRlbnNpb24gb2YgdGhlXG4gIC8vIFByb21pc2UgQVBJLCBvciBhIGN1c3RvbSBpbnRlcmZhY2UgdGhhdCBpcyBhIHN1cGVyc2V0IG9mIFRoZW5hYmxlLlxuICAvL1xuICAvLyBJZiB0aGUgdGhlbmFibGUgZG9lc24ndCBoYXZlIGEgc3RhdHVzLCBzZXQgaXQgdG8gXCJwZW5kaW5nXCIgYW5kIGF0dGFjaFxuICAvLyBhIGxpc3RlbmVyIHRoYXQgd2lsbCB1cGRhdGUgaXRzIHN0YXR1cyBhbmQgcmVzdWx0IHdoZW4gaXQgcmVzb2x2ZXMuXG5cblxuICBzd2l0Y2ggKHRoZW5hYmxlLnN0YXR1cykge1xuICAgIGNhc2UgJ2Z1bGZpbGxlZCc6XG4gICAgICB7XG4gICAgICAgIHZhciBmdWxmaWxsZWRWYWx1ZSA9IHRoZW5hYmxlLnZhbHVlO1xuICAgICAgICByZXR1cm4gZnVsZmlsbGVkVmFsdWU7XG4gICAgICB9XG5cbiAgICBjYXNlICdyZWplY3RlZCc6XG4gICAgICB7XG4gICAgICAgIHZhciByZWplY3RlZEVycm9yID0gdGhlbmFibGUucmVhc29uO1xuICAgICAgICBjaGVja0lmVXNlV3JhcHBlZEluQXN5bmNDYXRjaChyZWplY3RlZEVycm9yKTtcbiAgICAgICAgdGhyb3cgcmVqZWN0ZWRFcnJvcjtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhlbmFibGUuc3RhdHVzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIC8vIE9ubHkgaW5zdHJ1bWVudCB0aGUgdGhlbmFibGUgaWYgdGhlIHN0YXR1cyBpZiBub3QgZGVmaW5lZC4gSWZcbiAgICAgICAgICAvLyBpdCdzIGRlZmluZWQsIGJ1dCBhbiB1bmtub3duIHZhbHVlLCBhc3N1bWUgaXQncyBiZWVuIGluc3RydW1lbnRlZCBieVxuICAgICAgICAgIC8vIHNvbWUgY3VzdG9tIHVzZXJzcGFjZSBpbXBsZW1lbnRhdGlvbi4gV2UgdHJlYXQgaXQgYXMgXCJwZW5kaW5nXCIuXG4gICAgICAgICAgLy8gQXR0YWNoIGEgZHVtbXkgbGlzdGVuZXIsIHRvIGVuc3VyZSB0aGF0IGFueSBsYXp5IGluaXRpYWxpemF0aW9uIGNhblxuICAgICAgICAgIC8vIGhhcHBlbi4gRmxpZ2h0IGxhemlseSBwYXJzZXMgSlNPTiB3aGVuIHRoZSB2YWx1ZSBpcyBhY3R1YWxseSBhd2FpdGVkLlxuICAgICAgICAgIHRoZW5hYmxlLnRoZW4obm9vcCQxLCBub29wJDEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYW4gdW5jYWNoZWQgdGhlbmFibGUgdGhhdCB3ZSBoYXZlbid0IHNlZW4gYmVmb3JlLlxuICAgICAgICAgIC8vIERldGVjdCBpbmZpbml0ZSBwaW5nIGxvb3BzIGNhdXNlZCBieSB1bmNhY2hlZCBwcm9taXNlcy5cbiAgICAgICAgICB2YXIgcm9vdCA9IGdldFdvcmtJblByb2dyZXNzUm9vdCgpO1xuXG4gICAgICAgICAgaWYgKHJvb3QgIT09IG51bGwgJiYgcm9vdC5zaGVsbFN1c3BlbmRDb3VudGVyID4gMTAwKSB7XG4gICAgICAgICAgICAvLyBUaGlzIHJvb3QgaGFzIHN1c3BlbmRlZCByZXBlYXRlZGx5IGluIHRoZSBzaGVsbCB3aXRob3V0IG1ha2luZyBhbnlcbiAgICAgICAgICAgIC8vIHByb2dyZXNzIChpLmUuIGNvbW1pdHRpbmcgc29tZXRoaW5nKS4gVGhpcyBpcyBoaWdobHkgc3VnZ2VzdGl2ZSBvZlxuICAgICAgICAgICAgLy8gYW4gaW5maW5pdGUgcGluZyBsb29wLCBvZnRlbiBjYXVzZWQgYnkgYW4gYWNjaWRlbnRhbCBBc3luYyBDbGllbnRcbiAgICAgICAgICAgIC8vIENvbXBvbmVudC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBEdXJpbmcgYSB0cmFuc2l0aW9uLCB3ZSBjYW4gc3VzcGVuZCB0aGUgd29yayBsb29wIHVudGlsIHRoZSBwcm9taXNlXG4gICAgICAgICAgICAvLyB0byByZXNvbHZlLCBidXQgdGhpcyBpcyBhIHN5bmMgcmVuZGVyLCBzbyB0aGF0J3Mgbm90IGFuIG9wdGlvbi4gV2VcbiAgICAgICAgICAgIC8vIGFsc28gY2FuJ3Qgc2hvdyBhIGZhbGxiYWNrLCBiZWNhdXNlIG5vbmUgd2FzIHByb3ZpZGVkLiBTbyBvdXIgbGFzdFxuICAgICAgICAgICAgLy8gcmVzb3J0IGlzIHRvIHRocm93IGFuIGVycm9yLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRPRE86IFJlbW92ZSB0aGlzIGVycm9yIGluIGEgZnV0dXJlIHJlbGVhc2UuIE90aGVyIHdheXMgb2YgaGFuZGxpbmdcbiAgICAgICAgICAgIC8vIHRoaXMgY2FzZSBpbmNsdWRlIGZvcmNpbmcgYSBjb25jdXJyZW50IHJlbmRlciwgb3IgcHV0dGluZyB0aGUgd2hvbGVcbiAgICAgICAgICAgIC8vIHJvb3QgaW50byBvZmZzY3JlZW4gbW9kZS5cbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXN5bmMvYXdhaXQgaXMgbm90IHlldCBzdXBwb3J0ZWQgaW4gQ2xpZW50IENvbXBvbmVudHMsIG9ubHkgJyArICdTZXJ2ZXIgQ29tcG9uZW50cy4gVGhpcyBlcnJvciBpcyBvZnRlbiBjYXVzZWQgYnkgYWNjaWRlbnRhbGx5ICcgKyBcImFkZGluZyBgJ3VzZSBjbGllbnQnYCB0byBhIG1vZHVsZSB0aGF0IHdhcyBvcmlnaW5hbGx5IHdyaXR0ZW4gXCIgKyAnZm9yIHRoZSBzZXJ2ZXIuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHBlbmRpbmdUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgIHBlbmRpbmdUaGVuYWJsZS5zdGF0dXMgPSAncGVuZGluZyc7XG4gICAgICAgICAgcGVuZGluZ1RoZW5hYmxlLnRoZW4oZnVuY3Rpb24gKGZ1bGZpbGxlZFZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodGhlbmFibGUuc3RhdHVzID09PSAncGVuZGluZycpIHtcbiAgICAgICAgICAgICAgdmFyIGZ1bGZpbGxlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgIGZ1bGZpbGxlZFRoZW5hYmxlLnN0YXR1cyA9ICdmdWxmaWxsZWQnO1xuICAgICAgICAgICAgICBmdWxmaWxsZWRUaGVuYWJsZS52YWx1ZSA9IGZ1bGZpbGxlZFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKHRoZW5hYmxlLnN0YXR1cyA9PT0gJ3BlbmRpbmcnKSB7XG4gICAgICAgICAgICAgIHZhciByZWplY3RlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgIHJlamVjdGVkVGhlbmFibGUuc3RhdHVzID0gJ3JlamVjdGVkJztcbiAgICAgICAgICAgICAgcmVqZWN0ZWRUaGVuYWJsZS5yZWFzb24gPSBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSAvLyBDaGVjayBvbmUgbW9yZSB0aW1lIGluIGNhc2UgdGhlIHRoZW5hYmxlIHJlc29sdmVkIHN5bmNocm9ub3VzbHkuXG5cblxuICAgICAgICBzd2l0Y2ggKHRoZW5hYmxlLnN0YXR1cykge1xuICAgICAgICAgIGNhc2UgJ2Z1bGZpbGxlZCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBmdWxmaWxsZWRUaGVuYWJsZSA9IHRoZW5hYmxlO1xuICAgICAgICAgICAgICByZXR1cm4gZnVsZmlsbGVkVGhlbmFibGUudmFsdWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlICdyZWplY3RlZCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciByZWplY3RlZFRoZW5hYmxlID0gdGhlbmFibGU7XG4gICAgICAgICAgICAgIHZhciBfcmVqZWN0ZWRFcnJvciA9IHJlamVjdGVkVGhlbmFibGUucmVhc29uO1xuICAgICAgICAgICAgICBjaGVja0lmVXNlV3JhcHBlZEluQXN5bmNDYXRjaChfcmVqZWN0ZWRFcnJvcik7XG4gICAgICAgICAgICAgIHRocm93IF9yZWplY3RlZEVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IC8vIFN1c3BlbmQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRocm93aW5nIGhlcmUgaXMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIHRoYXQgYWxsb3dzIHVzIHRvIHVud2luZCB0aGVcbiAgICAgICAgLy8gY2FsbCBzdGFjay4gQnV0IHdlIHNob3VsZG4ndCBhbGxvdyBpdCB0byBsZWFrIGludG8gdXNlcnNwYWNlLiBUaHJvdyBhblxuICAgICAgICAvLyBvcGFxdWUgcGxhY2Vob2xkZXIgdmFsdWUgaW5zdGVhZCBvZiB0aGUgYWN0dWFsIHRoZW5hYmxlLiBJZiBpdCBkb2Vzbid0XG4gICAgICAgIC8vIGdldCBjYXB0dXJlZCBieSB0aGUgd29yayBsb29wLCBsb2cgYSB3YXJuaW5nLCBiZWNhdXNlIHRoYXQgbWVhbnNcbiAgICAgICAgLy8gc29tZXRoaW5nIGluIHVzZXJzcGFjZSBtdXN0IGhhdmUgY2F1Z2h0IGl0LlxuXG5cbiAgICAgICAgc3VzcGVuZGVkVGhlbmFibGUgPSB0aGVuYWJsZTtcblxuICAgICAgICB7XG4gICAgICAgICAgbmVlZHNUb1Jlc2V0U3VzcGVuZGVkVGhlbmFibGVERVYgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgU3VzcGVuc2VFeGNlcHRpb247XG4gICAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHN1c3BlbmRDb21taXQoKSB7XG4gIC8vIFRoaXMgZXh0cmEgaW5kaXJlY3Rpb24gb25seSBleGlzdHMgc28gaXQgY2FuIGhhbmRsZSBwYXNzaW5nXG4gIC8vIG5vb3BTdXNwZW5zZXlDb21taXRUaGVuYWJsZSB0aHJvdWdoIHRvIHRocm93RXhjZXB0aW9uLlxuICAvLyBUT0RPOiBGYWN0b3IgdGhlIHRoZW5hYmxlIGNoZWNrIG91dCBvZiB0aHJvd0V4Y2VwdGlvblxuICBzdXNwZW5kZWRUaGVuYWJsZSA9IG5vb3BTdXNwZW5zZXlDb21taXRUaGVuYWJsZTtcbiAgdGhyb3cgU3VzcGVuc2V5Q29tbWl0RXhjZXB0aW9uO1xufSAvLyBUaGlzIGlzIHVzZWQgdG8gdHJhY2sgdGhlIGFjdHVhbCB0aGVuYWJsZSB0aGF0IHN1c3BlbmRlZCBzbyBpdCBjYW4gYmVcbi8vIHBhc3NlZCB0byB0aGUgcmVzdCBvZiB0aGUgU3VzcGVuc2UgaW1wbGVtZW50YXRpb24g4oCUIHdoaWNoLCBmb3IgaGlzdG9yaWNhbFxuLy8gcmVhc29ucywgZXhwZWN0cyB0byByZWNlaXZlIGEgdGhlbmFibGUuXG5cbnZhciBzdXNwZW5kZWRUaGVuYWJsZSA9IG51bGw7XG52YXIgbmVlZHNUb1Jlc2V0U3VzcGVuZGVkVGhlbmFibGVERVYgPSBmYWxzZTtcbmZ1bmN0aW9uIGdldFN1c3BlbmRlZFRoZW5hYmxlKCkge1xuICAvLyBUaGlzIGlzIGNhbGxlZCByaWdodCBhZnRlciBgdXNlYCBzdXNwZW5kcyBieSB0aHJvd2luZyBhbiBleGNlcHRpb24uIGB1c2VgXG4gIC8vIHRocm93cyBhbiBvcGFxdWUgdmFsdWUgaW5zdGVhZCBvZiB0aGUgdGhlbmFibGUgaXRzZWxmIHNvIHRoYXQgaXQgY2FuJ3QgYmVcbiAgLy8gY2F1Z2h0IGluIHVzZXJzcGFjZS4gVGhlbiB0aGUgd29yayBsb29wIGFjY2Vzc2VzIHRoZSBhY3R1YWwgdGhlbmFibGUgdXNpbmdcbiAgLy8gdGhpcyBmdW5jdGlvbi5cbiAgaWYgKHN1c3BlbmRlZFRoZW5hYmxlID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIHN1c3BlbmRlZCB0aGVuYWJsZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgJyArICdhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHZhciB0aGVuYWJsZSA9IHN1c3BlbmRlZFRoZW5hYmxlO1xuICBzdXNwZW5kZWRUaGVuYWJsZSA9IG51bGw7XG5cbiAge1xuICAgIG5lZWRzVG9SZXNldFN1c3BlbmRlZFRoZW5hYmxlREVWID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdGhlbmFibGU7XG59XG5mdW5jdGlvbiBjaGVja0lmVXNlV3JhcHBlZEluVHJ5Q2F0Y2goKSB7XG4gIHtcbiAgICAvLyBUaGlzIHdhcyBzZXQgcmlnaHQgYmVmb3JlIFN1c3BlbnNlRXhjZXB0aW9uIHdhcyB0aHJvd24sIGFuZCBpdCBzaG91bGRcbiAgICAvLyBoYXZlIGJlZW4gY2xlYXJlZCB3aGVuIHRoZSBleGNlcHRpb24gd2FzIGhhbmRsZWQuIElmIGl0IHdhc24ndCxcbiAgICAvLyBpdCBtdXN0IGhhdmUgYmVlbiBjYXVnaHQgYnkgdXNlcnNwYWNlLlxuICAgIGlmIChuZWVkc1RvUmVzZXRTdXNwZW5kZWRUaGVuYWJsZURFVikge1xuICAgICAgbmVlZHNUb1Jlc2V0U3VzcGVuZGVkVGhlbmFibGVERVYgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGNoZWNrSWZVc2VXcmFwcGVkSW5Bc3luY0NhdGNoKHJlamVjdGVkUmVhc29uKSB7XG4gIC8vIFRoaXMgY2hlY2sgcnVucyBpbiBwcm9kLCB0b28sIGJlY2F1c2UgaXQgcHJldmVudHMgYSBtb3JlIGNvbmZ1c2luZ1xuICAvLyBkb3duc3RyZWFtIGVycm9yLCB3aGVyZSBTdXNwZW5zZUV4Y2VwdGlvbiBpcyBjYXVnaHQgYnkgYSBwcm9taXNlIGFuZFxuICAvLyB0aHJvd24gYXN5bmNocm9ub3VzbHkuXG4gIC8vIFRPRE86IEFub3RoZXIgd2F5IHRvIHByZXZlbnQgU3VzcGVuc2VFeGNlcHRpb24gZnJvbSBsZWFraW5nIGludG8gYW4gYXN5bmNcbiAgLy8gZXhlY3V0aW9uIGNvbnRleHQgaXMgdG8gY2hlY2sgdGhlIGRpc3BhdGNoZXIgZXZlcnkgdGltZSBgdXNlYCBpcyBjYWxsZWQsXG4gIC8vIG9yIHNvbWUgZXF1aXZhbGVudC4gVGhhdCBtaWdodCBiZSBwcmVmZXJhYmxlIGZvciBvdGhlciByZWFzb25zLCB0b28sIHNpbmNlXG4gIC8vIGl0IG1hdGNoZXMgaG93IHdlIHByZXZlbnQgc2ltaWxhciBtaXN0YWtlcyBmb3Igb3RoZXIgaG9va3MuXG4gIGlmIChyZWplY3RlZFJlYXNvbiA9PT0gU3VzcGVuc2VFeGNlcHRpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0hvb2tzIGFyZSBub3Qgc3VwcG9ydGVkIGluc2lkZSBhbiBhc3luYyBjb21wb25lbnQuIFRoaXMgJyArIFwiZXJyb3IgaXMgb2Z0ZW4gY2F1c2VkIGJ5IGFjY2lkZW50YWxseSBhZGRpbmcgYCd1c2UgY2xpZW50J2AgXCIgKyAndG8gYSBtb2R1bGUgdGhhdCB3YXMgb3JpZ2luYWxseSB3cml0dGVuIGZvciB0aGUgc2VydmVyLicpO1xuICB9XG59XG5cbnZhciB0aGVuYWJsZVN0YXRlJDEgPSBudWxsO1xudmFyIHRoZW5hYmxlSW5kZXhDb3VudGVyJDEgPSAwO1xuXG5mdW5jdGlvbiBtZXJnZURlYnVnSW5mbyhvdXRlciwgaW5uZXIpIHtcblxuICBpZiAoaW5uZXIgPT0gbnVsbCkge1xuICAgIHJldHVybiBvdXRlcjtcbiAgfSBlbHNlIGlmIChvdXRlciA9PT0gbnVsbCkge1xuICAgIHJldHVybiBpbm5lcjtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB3ZSBoYXZlIHR3byBkZWJ1Z0luZm8sIHdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IG9uZS4gVGhpcyBtYWtlcyB0aGUgYXJyYXkgbm8gbG9uZ2VyXG4gICAgLy8gbGl2ZSBzbyB3ZSdsbCBtaXNzIGFueSBmdXR1cmUgdXBkYXRlcyBpZiB3ZSByZWNlaXZlZCBtb3JlIHNvIGlkZWFsbHkgd2Ugc2hvdWxkIGFsd2F5c1xuICAgIC8vIGRvIHRoaXMgYWZ0ZXIgYm90aCBoYXZlIGZ1bGx5IHJlc29sdmVkL3Vuc3VzcGVuZGVkLlxuICAgIHJldHVybiBvdXRlci5jb25jYXQoaW5uZXIpO1xuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzO1xudmFyIGRpZFdhcm5BYm91dEdlbmVyYXRvcnM7XG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nO1xudmFyIG93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZztcbnZhciBvd25lckhhc1N5bWJvbFR5cGVXYXJuaW5nO1xuXG52YXIgd2FybkZvck1pc3NpbmdLZXkgPSBmdW5jdGlvbiAoY2hpbGQsIHJldHVybkZpYmVyKSB7fTtcblxue1xuICBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG4gIGRpZFdhcm5BYm91dEdlbmVyYXRvcnMgPSBmYWxzZTtcbiAgLyoqXG4gICAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAgICogb2JqZWN0IGtleXMgYXJlIG5vdCB2YWxpZC4gVGhpcyBhbGxvd3MgdXMgdG8ga2VlcCB0cmFjayBvZiBjaGlsZHJlbiBiZXR3ZWVuXG4gICAqIHVwZGF0ZXMuXG4gICAqL1xuXG4gIG93bmVySGFzS2V5VXNlV2FybmluZyA9IHt9O1xuICBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmcgPSB7fTtcbiAgb3duZXJIYXNTeW1ib2xUeXBlV2FybmluZyA9IHt9O1xuXG4gIHdhcm5Gb3JNaXNzaW5nS2V5ID0gZnVuY3Rpb24gKGNoaWxkLCByZXR1cm5GaWJlcikge1xuICAgIGlmIChjaGlsZCA9PT0gbnVsbCB8fCB0eXBlb2YgY2hpbGQgIT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCFjaGlsZC5fc3RvcmUgfHwgKGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgfHwgY2hpbGQua2V5ICE9IG51bGwpICYmIGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgIT09IDIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGNoaWxkLl9zdG9yZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVhY3QgQ29tcG9uZW50IGluIHdhcm5Gb3JNaXNzaW5nS2V5IHNob3VsZCBoYXZlIGEgX3N0b3JlLiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfSAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV0gdW5hYmxlIHRvIG5hcnJvdyB0eXBlIGZyb20gbWl4ZWQgdG8gd3JpdGFibGUgb2JqZWN0XG5cblxuICAgIGNoaWxkLl9zdG9yZS52YWxpZGF0ZWQgPSAxO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihyZXR1cm5GaWJlcik7XG4gICAgdmFyIGNvbXBvbmVudEtleSA9IGNvbXBvbmVudE5hbWUgfHwgJ251bGwnO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjb21wb25lbnRLZXldKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2NvbXBvbmVudEtleV0gPSB0cnVlO1xuICAgIHZhciBjaGlsZE93bmVyID0gY2hpbGQuX293bmVyO1xuICAgIHZhciBwYXJlbnRPd25lciA9IHJldHVybkZpYmVyLl9kZWJ1Z093bmVyO1xuICAgIHZhciBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvID0gJyc7XG5cbiAgICBpZiAocGFyZW50T3duZXIgJiYgdHlwZW9mIHBhcmVudE93bmVyLnRhZyA9PT0gJ251bWJlcicpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihwYXJlbnRPd25lcik7XG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWN1cnJlbnRDb21wb25lbnRFcnJvckluZm8pIHtcbiAgICAgIGlmIChjb21wb25lbnROYW1lKSB7XG4gICAgICAgIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgY29tcG9uZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuXG4gICAgdmFyIGNoaWxkT3duZXJBcHBlbmRpeCA9ICcnO1xuXG4gICAgaWYgKGNoaWxkT3duZXIgIT0gbnVsbCAmJiBwYXJlbnRPd25lciAhPT0gY2hpbGRPd25lcikge1xuICAgICAgdmFyIG93bmVyTmFtZSA9IG51bGw7XG5cbiAgICAgIGlmICh0eXBlb2YgY2hpbGRPd25lci50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICAgIG93bmVyTmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoY2hpbGRPd25lcik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBjaGlsZE93bmVyLm5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG93bmVyTmFtZSA9IGNoaWxkT3duZXIubmFtZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG93bmVyTmFtZSkge1xuICAgICAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICAgICAgY2hpbGRPd25lckFwcGVuZGl4ID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBvd25lck5hbWUgKyBcIi5cIjtcbiAgICAgIH1cbiAgICB9IC8vIFdlIGNyZWF0ZSBhIGZha2UgRmliZXIgZm9yIHRoZSBjaGlsZCB0byBsb2cgdGhlIHN0YWNrIHRyYWNlIGZyb20uXG4gICAgLy8gVE9ETzogUmVmYWN0b3IgdGhlIHdhcm5Gb3JNaXNzaW5nS2V5IGNhbGxzIHRvIGhhcHBlbiBhZnRlciBmaWJlciBjcmVhdGlvblxuICAgIC8vIHNvIHRoYXQgd2UgY2FuIGdldCBhY2Nlc3MgdG8gdGhlIGZpYmVyIHRoYXQgd2lsbCBldmVudHVhbGx5IGJlIGNyZWF0ZWQuXG4gICAgLy8gVGhhdCB3YXkgdGhlIGxvZyBjYW4gc2hvdyB1cCBhc3NvY2lhdGVkIHdpdGggdGhlIHJpZ2h0IGluc3RhbmNlIGluIERldlRvb2xzLlxuXG5cbiAgICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KGNoaWxkLCByZXR1cm5GaWJlci5tb2RlLCAwKTtcbiAgICBmaWJlci5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICB2YXIgcHJldkRlYnVnRmliZXIgPSBnZXRDdXJyZW50RmliZXIoKTtcbiAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuXG4gICAgZXJyb3IoJ0VhY2ggY2hpbGQgaW4gYSBsaXN0IHNob3VsZCBoYXZlIGEgdW5pcXVlIFwia2V5XCIgcHJvcC4nICsgJyVzJXMgU2VlIGh0dHBzOi8vcmVhY3QuZGV2L2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXJBcHBlbmRpeCk7XG5cbiAgICBzZXRDdXJyZW50RmliZXIocHJldkRlYnVnRmliZXIpO1xuICB9O1xufSAvLyBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbi8vIFdlIGRvIHRoaXMgaGVyZSBpbnN0ZWFkIG9mIEJlZ2luV29yayBiZWNhdXNlIHRoZSBGcmFnbWVudCBmaWJlciBkb2Vzbid0IGhhdmVcbi8vIHRoZSB3aG9sZSBwcm9wcyBvYmplY3QsIG9ubHkgdGhlIGNoaWxkcmVuIGFuZCBpcyBzaGFyZWQgd2l0aCBhcnJheXMuXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQsIGZpYmVyLCByZXR1cm5GaWJlcikge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhlbGVtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBpZiAoZmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBGb3IgdW5rZXllZCByb290IGZyYWdtZW50cyB0aGVyZSdzIG5vIEZpYmVyLiBXZSBjcmVhdGUgYSBmYWtlIG9uZSBqdXN0IGZvclxuICAgICAgICAgIC8vIGVycm9yIHN0YWNrIGhhbmRsaW5nLlxuICAgICAgICAgIGZpYmVyID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChlbGVtZW50LCByZXR1cm5GaWJlci5tb2RlLCAwKTtcbiAgICAgICAgICBmaWJlci5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwcmV2RGVidWdGaWJlciA9IGdldEN1cnJlbnRGaWJlcigpO1xuICAgICAgICBzZXRDdXJyZW50RmliZXIoZmliZXIpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50RmliZXIocHJldkRlYnVnRmliZXIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdW53cmFwVGhlbmFibGUodGhlbmFibGUpIHtcbiAgdmFyIGluZGV4ID0gdGhlbmFibGVJbmRleENvdW50ZXIkMTtcbiAgdGhlbmFibGVJbmRleENvdW50ZXIkMSArPSAxO1xuXG4gIGlmICh0aGVuYWJsZVN0YXRlJDEgPT09IG51bGwpIHtcbiAgICB0aGVuYWJsZVN0YXRlJDEgPSBjcmVhdGVUaGVuYWJsZVN0YXRlKCk7XG4gIH1cblxuICByZXR1cm4gdHJhY2tVc2VkVGhlbmFibGUodGhlbmFibGVTdGF0ZSQxLCB0aGVuYWJsZSwgaW5kZXgpO1xufVxuXG5mdW5jdGlvbiBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBlbGVtZW50KSB7XG4gIHZhciByZWY7XG5cbiAge1xuICAgIC8vIFRPRE86IFRoaXMgaXMgYSB0ZW1wb3JhcnksIGludGVybWVkaWF0ZSBzdGVwLiBXaGVuIGVuYWJsZVJlZkFzUHJvcCBpcyBvbixcbiAgICAvLyB3ZSBzaG91bGQgcmVzb2x2ZSB0aGUgYHJlZmAgcHJvcCBkdXJpbmcgdGhlIGJlZ2luIHBoYXNlIG9mIHRoZSBjb21wb25lbnRcbiAgICAvLyBpdCdzIGF0dGFjaGVkIHRvIChIb3N0Q29tcG9uZW50LCBDbGFzc0NvbXBvbmVudCwgZXRjKS5cbiAgICB2YXIgcmVmUHJvcCA9IGVsZW1lbnQucHJvcHMucmVmO1xuICAgIHJlZiA9IHJlZlByb3AgIT09IHVuZGVmaW5lZCA/IHJlZlByb3AgOiBudWxsO1xuICB9IC8vIFRPRE86IElmIGVuYWJsZVJlZkFzUHJvcCBpcyBvbiwgd2Ugc2hvdWxkbid0IHVzZSB0aGUgYHJlZmAgZmllbGQuIFdlXG4gIC8vIHNob3VsZCBhbHdheXMgcmVhZCB0aGUgcmVmIGZyb20gdGhlIHByb3AuXG5cblxuICB3b3JrSW5Qcm9ncmVzcy5yZWYgPSByZWY7XG59XG5cbmZ1bmN0aW9uIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpIHtcbiAgaWYgKG5ld0NoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9MRUdBQ1lfRUxFTUVOVF9UWVBFKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBIFJlYWN0IEVsZW1lbnQgZnJvbSBhbiBvbGRlciB2ZXJzaW9uIG9mIFJlYWN0IHdhcyByZW5kZXJlZC4gJyArICdUaGlzIGlzIG5vdCBzdXBwb3J0ZWQuIEl0IGNhbiBoYXBwZW4gaWY6XFxuJyArICctIE11bHRpcGxlIGNvcGllcyBvZiB0aGUgXCJyZWFjdFwiIHBhY2thZ2UgaXMgdXNlZC5cXG4nICsgJy0gQSBsaWJyYXJ5IHByZS1idW5kbGVkIGFuIG9sZCBjb3B5IG9mIFwicmVhY3RcIiBvciBcInJlYWN0L2pzeC1ydW50aW1lXCIuXFxuJyArICctIEEgY29tcGlsZXIgdHJpZXMgdG8gXCJpbmxpbmVcIiBKU1ggaW5zdGVhZCBvZiB1c2luZyB0aGUgcnVudGltZS4nKTtcbiAgfSAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG5cblxuICB2YXIgY2hpbGRTdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobmV3Q2hpbGQpO1xuICB0aHJvdyBuZXcgRXJyb3IoXCJPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6IFwiICsgKGNoaWxkU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMobmV3Q2hpbGQpLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZFN0cmluZykgKyBcIikuIFwiICsgJ0lmIHlvdSBtZWFudCB0byByZW5kZXIgYSBjb2xsZWN0aW9uIG9mIGNoaWxkcmVuLCB1c2UgYW4gYXJyYXkgJyArICdpbnN0ZWFkLicpO1xufVxuXG5mdW5jdGlvbiB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIsIGludmFsaWRDaGlsZCkge1xuICB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKHJldHVybkZpYmVyKSB8fCAnQ29tcG9uZW50JztcblxuICAgIGlmIChvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbcGFyZW50TmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc0Z1bmN0aW9uVHlwZVdhcm5pbmdbcGFyZW50TmFtZV0gPSB0cnVlO1xuICAgIHZhciBuYW1lID0gaW52YWxpZENoaWxkLmRpc3BsYXlOYW1lIHx8IGludmFsaWRDaGlsZC5uYW1lIHx8ICdDb21wb25lbnQnO1xuXG4gICAgaWYgKHJldHVybkZpYmVyLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgIGVycm9yKCdGdW5jdGlvbnMgYXJlIG5vdCB2YWxpZCBhcyBhIFJlYWN0IGNoaWxkLiBUaGlzIG1heSBoYXBwZW4gaWYgJyArICd5b3UgcmV0dXJuICVzIGluc3RlYWQgb2YgPCVzIC8+IGZyb20gcmVuZGVyLiAnICsgJ09yIG1heWJlIHlvdSBtZWFudCB0byBjYWxsIHRoaXMgZnVuY3Rpb24gcmF0aGVyIHRoYW4gcmV0dXJuIGl0LlxcbicgKyAnICByb290LnJlbmRlciglcyknLCBuYW1lLCBuYW1lLCBuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3IoJ0Z1bmN0aW9ucyBhcmUgbm90IHZhbGlkIGFzIGEgUmVhY3QgY2hpbGQuIFRoaXMgbWF5IGhhcHBlbiBpZiAnICsgJ3lvdSByZXR1cm4gJXMgaW5zdGVhZCBvZiA8JXMgLz4gZnJvbSByZW5kZXIuICcgKyAnT3IgbWF5YmUgeW91IG1lYW50IHRvIGNhbGwgdGhpcyBmdW5jdGlvbiByYXRoZXIgdGhhbiByZXR1cm4gaXQuXFxuJyArICcgIDwlcz57JXN9PC8lcz4nLCBuYW1lLCBuYW1lLCBwYXJlbnROYW1lLCBuYW1lLCBwYXJlbnROYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uU3ltYm9sVHlwZShyZXR1cm5GaWJlciwgaW52YWxpZENoaWxkKSB7XG4gIHtcbiAgICB2YXIgcGFyZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIocmV0dXJuRmliZXIpIHx8ICdDb21wb25lbnQnO1xuXG4gICAgaWYgKG93bmVySGFzU3ltYm9sVHlwZVdhcm5pbmdbcGFyZW50TmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBvd25lckhhc1N5bWJvbFR5cGVXYXJuaW5nW3BhcmVudE5hbWVdID0gdHJ1ZTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG5cbiAgICB2YXIgbmFtZSA9IFN0cmluZyhpbnZhbGlkQ2hpbGQpO1xuXG4gICAgaWYgKHJldHVybkZpYmVyLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgIGVycm9yKCdTeW1ib2xzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC5cXG4nICsgJyAgcm9vdC5yZW5kZXIoJXMpJywgbmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVycm9yKCdTeW1ib2xzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZC5cXG4nICsgJyAgPCVzPiVzPC8lcz4nLCBwYXJlbnROYW1lLCBuYW1lLCBwYXJlbnROYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUxhenkobGF6eVR5cGUpIHtcbiAgdmFyIHBheWxvYWQgPSBsYXp5VHlwZS5fcGF5bG9hZDtcbiAgdmFyIGluaXQgPSBsYXp5VHlwZS5faW5pdDtcbiAgcmV0dXJuIGluaXQocGF5bG9hZCk7XG59IC8vIFRoaXMgd3JhcHBlciBmdW5jdGlvbiBleGlzdHMgYmVjYXVzZSBJIGV4cGVjdCB0byBjbG9uZSB0aGUgY29kZSBpbiBlYWNoIHBhdGhcbi8vIHRvIGJlIGFibGUgdG8gb3B0aW1pemUgZWFjaCBwYXRoIGluZGl2aWR1YWxseSBieSBicmFuY2hpbmcgZWFybHkuIFRoaXMgbmVlZHNcbi8vIGEgY29tcGlsZXIgb3Igd2UgY2FuIGRvIGl0IG1hbnVhbGx5LiBIZWxwZXJzIHRoYXQgZG9uJ3QgbmVlZCB0aGlzIGJyYW5jaGluZ1xuLy8gbGl2ZSBvdXRzaWRlIG9mIHRoaXMgZnVuY3Rpb24uXG5cblxuZnVuY3Rpb24gY3JlYXRlQ2hpbGRSZWNvbmNpbGVyKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgZnVuY3Rpb24gZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkVG9EZWxldGUpIHtcbiAgICBpZiAoIXNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIE5vb3AuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGRlbGV0aW9ucyA9IHJldHVybkZpYmVyLmRlbGV0aW9ucztcblxuICAgIGlmIChkZWxldGlvbnMgPT09IG51bGwpIHtcbiAgICAgIHJldHVybkZpYmVyLmRlbGV0aW9ucyA9IFtjaGlsZFRvRGVsZXRlXTtcbiAgICAgIHJldHVybkZpYmVyLmZsYWdzIHw9IENoaWxkRGVsZXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0aW9ucy5wdXNoKGNoaWxkVG9EZWxldGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCkge1xuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gTm9vcC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gLy8gVE9ETzogRm9yIHRoZSBzaG91bGRDbG9uZSBjYXNlLCB0aGlzIGNvdWxkIGJlIG1pY3JvLW9wdGltaXplZCBhIGJpdCBieVxuICAgIC8vIGFzc3VtaW5nIHRoYXQgYWZ0ZXIgdGhlIGZpcnN0IGNoaWxkIHdlJ3ZlIGFscmVhZHkgYWRkZWQgZXZlcnl0aGluZy5cblxuXG4gICAgdmFyIGNoaWxkVG9EZWxldGUgPSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZFRvRGVsZXRlICE9PSBudWxsKSB7XG4gICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGRUb0RlbGV0ZSk7XG4gICAgICBjaGlsZFRvRGVsZXRlID0gY2hpbGRUb0RlbGV0ZS5zaWJsaW5nO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFwUmVtYWluaW5nQ2hpbGRyZW4oY3VycmVudEZpcnN0Q2hpbGQpIHtcbiAgICAvLyBBZGQgdGhlIHJlbWFpbmluZyBjaGlsZHJlbiB0byBhIHRlbXBvcmFyeSBtYXAgc28gdGhhdCB3ZSBjYW4gZmluZCB0aGVtIGJ5XG4gICAgLy8ga2V5cyBxdWlja2x5LiBJbXBsaWNpdCAobnVsbCkga2V5cyBnZXQgYWRkZWQgdG8gdGhpcyBzZXQgd2l0aCB0aGVpciBpbmRleFxuICAgIC8vIGluc3RlYWQuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBuZXcgTWFwKCk7XG4gICAgdmFyIGV4aXN0aW5nQ2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChleGlzdGluZ0NoaWxkICE9PSBudWxsKSB7XG4gICAgICBpZiAoZXhpc3RpbmdDaGlsZC5rZXkgIT09IG51bGwpIHtcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5zZXQoZXhpc3RpbmdDaGlsZC5rZXksIGV4aXN0aW5nQ2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5zZXQoZXhpc3RpbmdDaGlsZC5pbmRleCwgZXhpc3RpbmdDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGV4aXN0aW5nQ2hpbGQgPSBleGlzdGluZ0NoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIGV4aXN0aW5nQ2hpbGRyZW47XG4gIH1cblxuICBmdW5jdGlvbiB1c2VGaWJlcihmaWJlciwgcGVuZGluZ1Byb3BzKSB7XG4gICAgLy8gV2UgY3VycmVudGx5IHNldCBzaWJsaW5nIHRvIG51bGwgYW5kIGluZGV4IHRvIDAgaGVyZSBiZWNhdXNlIGl0IGlzIGVhc3lcbiAgICAvLyB0byBmb3JnZXQgdG8gZG8gYmVmb3JlIHJldHVybmluZyBpdC4gRS5nLiBmb3IgdGhlIHNpbmdsZSBjaGlsZCBjYXNlLlxuICAgIHZhciBjbG9uZSA9IGNyZWF0ZVdvcmtJblByb2dyZXNzKGZpYmVyLCBwZW5kaW5nUHJvcHMpO1xuICAgIGNsb25lLmluZGV4ID0gMDtcbiAgICBjbG9uZS5zaWJsaW5nID0gbnVsbDtcbiAgICByZXR1cm4gY2xvbmU7XG4gIH1cblxuICBmdW5jdGlvbiBwbGFjZUNoaWxkKG5ld0ZpYmVyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0luZGV4KSB7XG4gICAgbmV3RmliZXIuaW5kZXggPSBuZXdJbmRleDtcblxuICAgIGlmICghc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgLy8gRHVyaW5nIGh5ZHJhdGlvbiwgdGhlIHVzZUlkIGFsZ29yaXRobSBuZWVkcyB0byBrbm93IHdoaWNoIGZpYmVycyBhcmVcbiAgICAgIC8vIHBhcnQgb2YgYSBsaXN0IG9mIGNoaWxkcmVuIChhcnJheXMsIGl0ZXJhdG9ycykuXG4gICAgICBuZXdGaWJlci5mbGFncyB8PSBGb3JrZWQ7XG4gICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgIH1cblxuICAgIHZhciBjdXJyZW50ID0gbmV3RmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciBvbGRJbmRleCA9IGN1cnJlbnQuaW5kZXg7XG5cbiAgICAgIGlmIChvbGRJbmRleCA8IGxhc3RQbGFjZWRJbmRleCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgbW92ZS5cbiAgICAgICAgbmV3RmliZXIuZmxhZ3MgfD0gUGxhY2VtZW50IHwgUGxhY2VtZW50REVWO1xuICAgICAgICByZXR1cm4gbGFzdFBsYWNlZEluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpdGVtIGNhbiBzdGF5IGluIHBsYWNlLlxuICAgICAgICByZXR1cm4gb2xkSW5kZXg7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgYW4gaW5zZXJ0aW9uLlxuICAgICAgbmV3RmliZXIuZmxhZ3MgfD0gUGxhY2VtZW50IHwgUGxhY2VtZW50REVWO1xuICAgICAgcmV0dXJuIGxhc3RQbGFjZWRJbmRleDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBwbGFjZVNpbmdsZUNoaWxkKG5ld0ZpYmVyKSB7XG4gICAgLy8gVGhpcyBpcyBzaW1wbGVyIGZvciB0aGUgc2luZ2xlIGNoaWxkIGNhc2UuIFdlIG9ubHkgbmVlZCB0byBkbyBhXG4gICAgLy8gcGxhY2VtZW50IGZvciBpbnNlcnRpbmcgbmV3IGNoaWxkcmVuLlxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgbmV3RmliZXIuZmxhZ3MgfD0gUGxhY2VtZW50IHwgUGxhY2VtZW50REVWO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdGaWJlcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50LCB0ZXh0Q29udGVudCwgbGFuZXMsIGRlYnVnSW5mbykge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBIb3N0VGV4dCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbVRleHQodGV4dENvbnRlbnQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlZC5fZGVidWdJbmZvID0gZGVidWdJbmZvO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCB0ZXh0Q29udGVudCk7XG4gICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgICAge1xuICAgICAgICBleGlzdGluZy5fZGVidWdJbmZvID0gZGVidWdJbmZvO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudCwgbGFuZXMsIGRlYnVnSW5mbykge1xuICAgIHZhciBlbGVtZW50VHlwZSA9IGVsZW1lbnQudHlwZTtcblxuICAgIGlmIChlbGVtZW50VHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgdmFyIHVwZGF0ZWQgPSB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgbGFuZXMsIGVsZW1lbnQua2V5LCBkZWJ1Z0luZm8pO1xuICAgICAgdmFsaWRhdGVGcmFnbWVudFByb3BzKGVsZW1lbnQsIHVwZGF0ZWQsIHJldHVybkZpYmVyKTtcbiAgICAgIHJldHVybiB1cGRhdGVkO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICBpZiAoY3VycmVudC5lbGVtZW50VHlwZSA9PT0gZWxlbWVudFR5cGUgfHwgKCAvLyBLZWVwIHRoaXMgY2hlY2sgaW5saW5lIHNvIGl0IG9ubHkgcnVucyBvbiB0aGUgZmFsc2UgcGF0aDpcbiAgICAgIGlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyhjdXJyZW50LCBlbGVtZW50KSApIHx8IC8vIExhenkgdHlwZXMgc2hvdWxkIHJlY29uY2lsZSB0aGVpciByZXNvbHZlZCB0eXBlLlxuICAgICAgLy8gV2UgbmVlZCB0byBkbyB0aGlzIGFmdGVyIHRoZSBIb3QgUmVsb2FkaW5nIGNoZWNrIGFib3ZlLFxuICAgICAgLy8gYmVjYXVzZSBob3QgcmVsb2FkaW5nIGhhcyBkaWZmZXJlbnQgc2VtYW50aWNzIHRoYW4gcHJvZCBiZWNhdXNlXG4gICAgICAvLyBpdCBkb2Vzbid0IHJlc3VzcGVuZC4gU28gd2UgY2FuJ3QgbGV0IHRoZSBjYWxsIGJlbG93IHN1c3BlbmQuXG4gICAgICB0eXBlb2YgZWxlbWVudFR5cGUgPT09ICdvYmplY3QnICYmIGVsZW1lbnRUeXBlICE9PSBudWxsICYmIGVsZW1lbnRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgJiYgcmVzb2x2ZUxhenkoZWxlbWVudFR5cGUpID09PSBjdXJyZW50LnR5cGUpIHtcbiAgICAgICAgLy8gTW92ZSBiYXNlZCBvbiBpbmRleFxuICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBlbGVtZW50LnByb3BzKTtcbiAgICAgICAgY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50LCBleGlzdGluZywgZWxlbWVudCk7XG4gICAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBleGlzdGluZy5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgICAgIGV4aXN0aW5nLl9kZWJ1Z0luZm8gPSBkZWJ1Z0luZm87XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgICB9XG4gICAgfSAvLyBJbnNlcnRcblxuXG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcbiAgICBjb2VyY2VSZWYocmV0dXJuRmliZXIsIGN1cnJlbnQsIGNyZWF0ZWQsIGVsZW1lbnQpO1xuICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICB7XG4gICAgICBjcmVhdGVkLl9kZWJ1Z0luZm8gPSBkZWJ1Z0luZm87XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZWQ7XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnQsIHBvcnRhbCwgbGFuZXMsIGRlYnVnSW5mbykge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBIb3N0UG9ydGFsIHx8IGN1cnJlbnQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gIT09IHBvcnRhbC5jb250YWluZXJJbmZvIHx8IGN1cnJlbnQuc3RhdGVOb2RlLmltcGxlbWVudGF0aW9uICE9PSBwb3J0YWwuaW1wbGVtZW50YXRpb24pIHtcbiAgICAgIC8vIEluc2VydFxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICB7XG4gICAgICAgIGNyZWF0ZWQuX2RlYnVnSW5mbyA9IGRlYnVnSW5mbztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFVwZGF0ZVxuICAgICAgdmFyIGV4aXN0aW5nID0gdXNlRmliZXIoY3VycmVudCwgcG9ydGFsLmNoaWxkcmVuIHx8IFtdKTtcbiAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICB7XG4gICAgICAgIGV4aXN0aW5nLl9kZWJ1Z0luZm8gPSBkZWJ1Z0luZm87XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBleGlzdGluZztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgY3VycmVudCwgZnJhZ21lbnQsIGxhbmVzLCBrZXksIGRlYnVnSW5mbykge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQudGFnICE9PSBGcmFnbWVudCkge1xuICAgICAgLy8gSW5zZXJ0XG4gICAgICB2YXIgY3JlYXRlZCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZyYWdtZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcywga2V5KTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlZC5fZGVidWdJbmZvID0gZGVidWdJbmZvO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gY3JlYXRlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVXBkYXRlXG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50LCBmcmFnbWVudCk7XG4gICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgICAge1xuICAgICAgICBleGlzdGluZy5fZGVidWdJbmZvID0gZGVidWdJbmZvO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQ2hpbGQocmV0dXJuRmliZXIsIG5ld0NoaWxkLCBsYW5lcywgZGVidWdJbmZvKSB7XG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N0cmluZycgJiYgbmV3Q2hpbGQgIT09ICcnIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnYmlnaW50Jykge1xuICAgICAgLy8gVGV4dCBub2RlcyBkb24ndCBoYXZlIGtleXMuIElmIHRoZSBwcmV2aW91cyBub2RlIGlzIGltcGxpY2l0bHkga2V5ZWRcbiAgICAgIC8vIHdlIGNhbiBjb250aW51ZSB0byByZXBsYWNlIGl0IHdpdGhvdXQgYWJvcnRpbmcgZXZlbiBpZiBpdCBpcyBub3QgYSB0ZXh0XG4gICAgICAvLyBub2RlLlxuICAgICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KCAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hZGRpdGlvbl0gRmxvdyBkb2Vzbid0IHdhbnQgdXMgdG8gdXNlIGArYCBvcGVyYXRvciB3aXRoIHN0cmluZyBhbmQgYmlnaW50XG4gICAgICAnJyArIG5ld0NoaWxkLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgICBjcmVhdGVkLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICB7XG4gICAgICAgIGNyZWF0ZWQuX2RlYnVnSW5mbyA9IGRlYnVnSW5mbztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9jcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRWxlbWVudChuZXdDaGlsZCwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMpO1xuXG4gICAgICAgICAgICBjb2VyY2VSZWYocmV0dXJuRmliZXIsIG51bGwsIF9jcmVhdGVkLCBuZXdDaGlsZCk7XG4gICAgICAgICAgICBfY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBfY3JlYXRlZC5fZGVidWdJbmZvID0gbWVyZ2VEZWJ1Z0luZm8oZGVidWdJbmZvLCBuZXdDaGlsZC5fZGVidWdJbmZvKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIF9jcmVhdGVkO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfY3JlYXRlZDIgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwobmV3Q2hpbGQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcblxuICAgICAgICAgICAgX2NyZWF0ZWQyLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIF9jcmVhdGVkMi5fZGVidWdJbmZvID0gZGVidWdJbmZvO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gX2NyZWF0ZWQyO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcGF5bG9hZCA9IG5ld0NoaWxkLl9wYXlsb2FkO1xuICAgICAgICAgICAgdmFyIGluaXQgPSBuZXdDaGlsZC5faW5pdDtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgaW5pdChwYXlsb2FkKSwgbGFuZXMsIG1lcmdlRGVidWdJbmZvKGRlYnVnSW5mbywgbmV3Q2hpbGQuX2RlYnVnSW5mbykgLy8gY2FsbCBtZXJnZSBhZnRlciBpbml0XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpIHx8IGVuYWJsZUFzeW5jSXRlcmFibGVDaGlsZHJlbiApIHtcbiAgICAgICAgdmFyIF9jcmVhdGVkMyA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KG5ld0NoaWxkLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcywgbnVsbCk7XG5cbiAgICAgICAgX2NyZWF0ZWQzLnJldHVybiA9IHJldHVybkZpYmVyO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBfY3JlYXRlZDMuX2RlYnVnSW5mbyA9IG1lcmdlRGVidWdJbmZvKGRlYnVnSW5mbywgbmV3Q2hpbGQuX2RlYnVnSW5mbyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gX2NyZWF0ZWQzO1xuICAgICAgfSAvLyBVc2FibGUgbm9kZSB0eXBlc1xuICAgICAgLy9cbiAgICAgIC8vIFVud3JhcCB0aGUgaW5uZXIgdmFsdWUgYW5kIHJlY3Vyc2l2ZWx5IGNhbGwgdGhpcyBmdW5jdGlvbiBhZ2Fpbi5cblxuXG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHRoZW5hYmxlID0gbmV3Q2hpbGQ7XG4gICAgICAgIHJldHVybiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgdW53cmFwVGhlbmFibGUodGhlbmFibGUpLCBsYW5lcywgbWVyZ2VEZWJ1Z0luZm8oZGVidWdJbmZvLCBuZXdDaGlsZC5fZGVidWdJbmZvKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChuZXdDaGlsZC4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gbmV3Q2hpbGQ7XG4gICAgICAgIHJldHVybiBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihyZXR1cm5GaWJlciwgY29udGV4dCwgbGFuZXMpLCBsYW5lcywgZGVidWdJbmZvKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgd2Fybk9uU3ltYm9sVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcywgZGVidWdJbmZvKSB7XG4gICAgLy8gVXBkYXRlIHRoZSBmaWJlciBpZiB0aGUga2V5cyBtYXRjaCwgb3RoZXJ3aXNlIHJldHVybiBudWxsLlxuICAgIHZhciBrZXkgPSBvbGRGaWJlciAhPT0gbnVsbCA/IG9sZEZpYmVyLmtleSA6IG51bGw7XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyAmJiBuZXdDaGlsZCAhPT0gJycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdiaWdpbnQnKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cy4gSWYgdGhlIHByZXZpb3VzIG5vZGUgaXMgaW1wbGljaXRseSBrZXllZFxuICAgICAgLy8gd2UgY2FuIGNvbnRpbnVlIHRvIHJlcGxhY2UgaXQgd2l0aG91dCBhYm9ydGluZyBldmVuIGlmIGl0IGlzIG5vdCBhIHRleHRcbiAgICAgIC8vIG5vZGUuXG4gICAgICBpZiAoa2V5ICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIG9sZEZpYmVyLCAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hZGRpdGlvbl0gRmxvdyBkb2Vzbid0IHdhbnQgdXMgdG8gdXNlIGArYCBvcGVyYXRvciB3aXRoIHN0cmluZyBhbmQgYmlnaW50XG4gICAgICAnJyArIG5ld0NoaWxkLCBsYW5lcywgZGVidWdJbmZvKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnb2JqZWN0JyAmJiBuZXdDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChuZXdDaGlsZC4kJHR5cGVvZikge1xuICAgICAgICBjYXNlIFJFQUNUX0VMRU1FTlRfVFlQRTpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAobmV3Q2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZUVsZW1lbnQocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMsIG1lcmdlRGVidWdJbmZvKGRlYnVnSW5mbywgbmV3Q2hpbGQuX2RlYnVnSW5mbykpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKG5ld0NoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgICAgICAgIHJldHVybiB1cGRhdGVQb3J0YWwocmV0dXJuRmliZXIsIG9sZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMsIGRlYnVnSW5mbyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBheWxvYWQgPSBuZXdDaGlsZC5fcGF5bG9hZDtcbiAgICAgICAgICAgIHZhciBpbml0ID0gbmV3Q2hpbGQuX2luaXQ7XG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIGluaXQocGF5bG9hZCksIGxhbmVzLCBtZXJnZURlYnVnSW5mbyhkZWJ1Z0luZm8sIG5ld0NoaWxkLl9kZWJ1Z0luZm8pKTtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KG5ld0NoaWxkKSB8fCBnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSB8fCBlbmFibGVBc3luY0l0ZXJhYmxlQ2hpbGRyZW4gKSB7XG4gICAgICAgIGlmIChrZXkgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgb2xkRmliZXIsIG5ld0NoaWxkLCBsYW5lcywgbnVsbCwgbWVyZ2VEZWJ1Z0luZm8oZGVidWdJbmZvLCBuZXdDaGlsZC5fZGVidWdJbmZvKSk7XG4gICAgICB9IC8vIFVzYWJsZSBub2RlIHR5cGVzXG4gICAgICAvL1xuICAgICAgLy8gVW53cmFwIHRoZSBpbm5lciB2YWx1ZSBhbmQgcmVjdXJzaXZlbHkgY2FsbCB0aGlzIGZ1bmN0aW9uIGFnYWluLlxuXG5cbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgdGhlbmFibGUgPSBuZXdDaGlsZDtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVNsb3QocmV0dXJuRmliZXIsIG9sZEZpYmVyLCB1bndyYXBUaGVuYWJsZSh0aGVuYWJsZSksIGxhbmVzLCBkZWJ1Z0luZm8pO1xuICAgICAgfVxuXG4gICAgICBpZiAobmV3Q2hpbGQuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSkge1xuICAgICAgICB2YXIgY29udGV4dCA9IG5ld0NoaWxkO1xuICAgICAgICByZXR1cm4gdXBkYXRlU2xvdChyZXR1cm5GaWJlciwgb2xkRmliZXIsIHJlYWRDb250ZXh0RHVyaW5nUmVjb25jaWxpYXRpb24ocmV0dXJuRmliZXIsIGNvbnRleHQsIGxhbmVzKSwgbGFuZXMsIGRlYnVnSW5mbyk7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgd2Fybk9uRnVuY3Rpb25UeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzeW1ib2wnKSB7XG4gICAgICAgIHdhcm5PblN5bWJvbFR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgbmV3Q2hpbGQsIGxhbmVzLCBkZWJ1Z0luZm8pIHtcbiAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3RyaW5nJyAmJiBuZXdDaGlsZCAhPT0gJycgfHwgdHlwZW9mIG5ld0NoaWxkID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdiaWdpbnQnKSB7XG4gICAgICAvLyBUZXh0IG5vZGVzIGRvbid0IGhhdmUga2V5cywgc28gd2UgbmVpdGhlciBoYXZlIHRvIGNoZWNrIHRoZSBvbGQgbm9yXG4gICAgICAvLyBuZXcgbm9kZSBmb3IgdGhlIGtleS4gSWYgYm90aCBhcmUgdGV4dCBub2RlcywgdGhleSBtYXRjaC5cbiAgICAgIHZhciBtYXRjaGVkRmliZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdJZHgpIHx8IG51bGw7XG4gICAgICByZXR1cm4gdXBkYXRlVGV4dE5vZGUocmV0dXJuRmliZXIsIG1hdGNoZWRGaWJlciwgLy8gJEZsb3dGaXhNZVt1bnNhZmUtYWRkaXRpb25dIEZsb3cgZG9lc24ndCB3YW50IHVzIHRvIHVzZSBgK2Agb3BlcmF0b3Igd2l0aCBzdHJpbmcgYW5kIGJpZ2ludFxuICAgICAgJycgKyBuZXdDaGlsZCwgbGFuZXMsIGRlYnVnSW5mbyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIgPSBleGlzdGluZ0NoaWxkcmVuLmdldChuZXdDaGlsZC5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBuZXdDaGlsZC5rZXkpIHx8IG51bGw7XG5cbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVFbGVtZW50KHJldHVybkZpYmVyLCBfbWF0Y2hlZEZpYmVyLCBuZXdDaGlsZCwgbGFuZXMsIG1lcmdlRGVidWdJbmZvKGRlYnVnSW5mbywgbmV3Q2hpbGQuX2RlYnVnSW5mbykpO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBfbWF0Y2hlZEZpYmVyMiA9IGV4aXN0aW5nQ2hpbGRyZW4uZ2V0KG5ld0NoaWxkLmtleSA9PT0gbnVsbCA/IG5ld0lkeCA6IG5ld0NoaWxkLmtleSkgfHwgbnVsbDtcblxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVBvcnRhbChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjIsIG5ld0NoaWxkLCBsYW5lcywgZGVidWdJbmZvKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBuZXdDaGlsZC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IG5ld0NoaWxkLl9pbml0O1xuICAgICAgICAgIHJldHVybiB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIGluaXQocGF5bG9hZCksIGxhbmVzLCBtZXJnZURlYnVnSW5mbyhkZWJ1Z0luZm8sIG5ld0NoaWxkLl9kZWJ1Z0luZm8pKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzQXJyYXkobmV3Q2hpbGQpIHx8IGdldEl0ZXJhdG9yRm4obmV3Q2hpbGQpIHx8IGVuYWJsZUFzeW5jSXRlcmFibGVDaGlsZHJlbiApIHtcbiAgICAgICAgdmFyIF9tYXRjaGVkRmliZXIzID0gZXhpc3RpbmdDaGlsZHJlbi5nZXQobmV3SWR4KSB8fCBudWxsO1xuXG4gICAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChyZXR1cm5GaWJlciwgX21hdGNoZWRGaWJlcjMsIG5ld0NoaWxkLCBsYW5lcywgbnVsbCwgbWVyZ2VEZWJ1Z0luZm8oZGVidWdJbmZvLCBuZXdDaGlsZC5fZGVidWdJbmZvKSk7XG4gICAgICB9IC8vIFVzYWJsZSBub2RlIHR5cGVzXG4gICAgICAvL1xuICAgICAgLy8gVW53cmFwIHRoZSBpbm5lciB2YWx1ZSBhbmQgcmVjdXJzaXZlbHkgY2FsbCB0aGlzIGZ1bmN0aW9uIGFnYWluLlxuXG5cbiAgICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YXIgdGhlbmFibGUgPSBuZXdDaGlsZDtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgdW53cmFwVGhlbmFibGUodGhlbmFibGUpLCBsYW5lcywgZGVidWdJbmZvKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld0NoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBuZXdDaGlsZDtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgcmVhZENvbnRleHREdXJpbmdSZWNvbmNpbGlhdGlvbihyZXR1cm5GaWJlciwgY29udGV4dCwgbGFuZXMpLCBsYW5lcywgZGVidWdJbmZvKTtcbiAgICAgIH1cblxuICAgICAgdGhyb3dPbkludmFsaWRPYmplY3RUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgfVxuXG4gICAge1xuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB3YXJuT25GdW5jdGlvblR5cGUocmV0dXJuRmliZXIsIG5ld0NoaWxkKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgICAgd2Fybk9uU3ltYm9sVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8qKlxuICAgKiBXYXJucyBpZiB0aGVyZSBpcyBhIGR1cGxpY2F0ZSBvciBtaXNzaW5nIGtleVxuICAgKi9cblxuXG4gIGZ1bmN0aW9uIHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cywgcmV0dXJuRmliZXIpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIGNoaWxkICE9PSAnb2JqZWN0JyB8fCBjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4ga25vd25LZXlzO1xuICAgICAgfVxuXG4gICAgICBzd2l0Y2ggKGNoaWxkLiQkdHlwZW9mKSB7XG4gICAgICAgIGNhc2UgUkVBQ1RfRUxFTUVOVF9UWVBFOlxuICAgICAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgICAgIHdhcm5Gb3JNaXNzaW5nS2V5KGNoaWxkLCByZXR1cm5GaWJlcik7XG4gICAgICAgICAgdmFyIGtleSA9IGNoaWxkLmtleTtcblxuICAgICAgICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGtub3duS2V5cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAga25vd25LZXlzID0gbmV3IFNldCgpO1xuICAgICAgICAgICAga25vd25LZXlzLmFkZChrZXkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKCFrbm93bktleXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGtub3duS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yKCdFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksIGAlc2AuICcgKyAnS2V5cyBzaG91bGQgYmUgdW5pcXVlIHNvIHRoYXQgY29tcG9uZW50cyBtYWludGFpbiB0aGVpciBpZGVudGl0eSAnICsgJ2Fjcm9zcyB1cGRhdGVzLiBOb24tdW5pcXVlIGtleXMgbWF5IGNhdXNlIGNoaWxkcmVuIHRvIGJlICcgKyAnZHVwbGljYXRlZCBhbmQvb3Igb21pdHRlZCDigJQgdGhlIGJlaGF2aW9yIGlzIHVuc3VwcG9ydGVkIGFuZCAnICsgJ2NvdWxkIGNoYW5nZSBpbiBhIGZ1dHVyZSB2ZXJzaW9uLicsIGtleSk7XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGNoaWxkLl9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gY2hpbGQuX2luaXQ7XG4gICAgICAgICAgd2Fybk9uSW52YWxpZEtleShpbml0KHBheWxvYWQpLCBrbm93bktleXMsIHJldHVybkZpYmVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ga25vd25LZXlzO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkcmVuLCBsYW5lcywgZGVidWdJbmZvKSB7XG4gICAgLy8gVGhpcyBhbGdvcml0aG0gY2FuJ3Qgb3B0aW1pemUgYnkgc2VhcmNoaW5nIGZyb20gYm90aCBlbmRzIHNpbmNlIHdlXG4gICAgLy8gZG9uJ3QgaGF2ZSBiYWNrcG9pbnRlcnMgb24gZmliZXJzLiBJJ20gdHJ5aW5nIHRvIHNlZSBob3cgZmFyIHdlIGNhbiBnZXRcbiAgICAvLyB3aXRoIHRoYXQgbW9kZWwuIElmIGl0IGVuZHMgdXAgbm90IGJlaW5nIHdvcnRoIHRoZSB0cmFkZW9mZnMsIHdlIGNhblxuICAgIC8vIGFkZCBpdCBsYXRlci5cbiAgICAvLyBFdmVuIHdpdGggYSB0d28gZW5kZWQgb3B0aW1pemF0aW9uLCB3ZSdkIHdhbnQgdG8gb3B0aW1pemUgZm9yIHRoZSBjYXNlXG4gICAgLy8gd2hlcmUgdGhlcmUgYXJlIGZldyBjaGFuZ2VzIGFuZCBicnV0ZSBmb3JjZSB0aGUgY29tcGFyaXNvbiBpbnN0ZWFkIG9mXG4gICAgLy8gZ29pbmcgZm9yIHRoZSBNYXAuIEl0J2QgbGlrZSB0byBleHBsb3JlIGhpdHRpbmcgdGhhdCBwYXRoIGZpcnN0IGluXG4gICAgLy8gZm9yd2FyZC1vbmx5IG1vZGUgYW5kIG9ubHkgZ28gZm9yIHRoZSBNYXAgb25jZSB3ZSBub3RpY2UgdGhhdCB3ZSBuZWVkXG4gICAgLy8gbG90cyBvZiBsb29rIGFoZWFkLiBUaGlzIGRvZXNuJ3QgaGFuZGxlIHJldmVyc2FsIGFzIHdlbGwgYXMgdHdvIGVuZGVkXG4gICAgLy8gc2VhcmNoIGJ1dCB0aGF0J3MgdW51c3VhbC4gQmVzaWRlcywgZm9yIHRoZSB0d28gZW5kZWQgb3B0aW1pemF0aW9uIHRvXG4gICAgLy8gd29yayBvbiBJdGVyYWJsZXMsIHdlJ2QgbmVlZCB0byBjb3B5IHRoZSB3aG9sZSBzZXQuXG4gICAgLy8gSW4gdGhpcyBmaXJzdCBpdGVyYXRpb24sIHdlJ2xsIGp1c3QgbGl2ZSB3aXRoIGhpdHRpbmcgdGhlIGJhZCBjYXNlXG4gICAgLy8gKGFkZGluZyBldmVyeXRoaW5nIHRvIGEgTWFwKSBpbiBmb3IgZXZlcnkgaW5zZXJ0L21vdmUuXG4gICAgLy8gSWYgeW91IGNoYW5nZSB0aGlzIGNvZGUsIGFsc28gdXBkYXRlIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IoKSB3aGljaFxuICAgIC8vIHVzZXMgdGhlIHNhbWUgYWxnb3JpdGhtLlxuICAgIHtcbiAgICAgIC8vIEZpcnN0LCB2YWxpZGF0ZSBrZXlzLlxuICAgICAgdmFyIGtub3duS2V5cyA9IG51bGw7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbmV3Q2hpbGRyZW5baV07XG4gICAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoY2hpbGQsIGtub3duS2V5cywgcmV0dXJuRmliZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZXN1bHRpbmdGaXJzdENoaWxkID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXNOZXdGaWJlciA9IG51bGw7XG4gICAgdmFyIG9sZEZpYmVyID0gY3VycmVudEZpcnN0Q2hpbGQ7XG4gICAgdmFyIGxhc3RQbGFjZWRJbmRleCA9IDA7XG4gICAgdmFyIG5ld0lkeCA9IDA7XG4gICAgdmFyIG5leHRPbGRGaWJlciA9IG51bGw7XG5cbiAgICBmb3IgKDsgb2xkRmliZXIgIT09IG51bGwgJiYgbmV3SWR4IDwgbmV3Q2hpbGRyZW4ubGVuZ3RoOyBuZXdJZHgrKykge1xuICAgICAgaWYgKG9sZEZpYmVyLmluZGV4ID4gbmV3SWR4KSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyO1xuICAgICAgICBvbGRGaWJlciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgbGFuZXMsIGRlYnVnSW5mbyk7XG5cbiAgICAgIGlmIChuZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGJyZWFrcyBvbiBlbXB0eSBzbG90cyBsaWtlIG51bGwgY2hpbGRyZW4uIFRoYXQnc1xuICAgICAgICAvLyB1bmZvcnR1bmF0ZSBiZWNhdXNlIGl0IHRyaWdnZXJzIHRoZSBzbG93IHBhdGggYWxsIHRoZSB0aW1lLiBXZSBuZWVkXG4gICAgICAgIC8vIGEgYmV0dGVyIHdheSB0byBjb21tdW5pY2F0ZSB3aGV0aGVyIHRoaXMgd2FzIGEgbWlzcyBvciBudWxsLFxuICAgICAgICAvLyBib29sZWFuLCB1bmRlZmluZWQsIGV0Yy5cbiAgICAgICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaWYgKG9sZEZpYmVyICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIHNsb3QsIGJ1dCB3ZSBkaWRuJ3QgcmV1c2UgdGhlIGV4aXN0aW5nIGZpYmVyLCBzbyB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gZGVsZXRlIHRoZSBleGlzdGluZyBjaGlsZC5cbiAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcblxuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuXG4gICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICB9XG5cbiAgICBpZiAobmV3SWR4ID09PSBuZXdDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIC8vIFdlJ3ZlIHJlYWNoZWQgdGhlIGVuZCBvZiB0aGUgbmV3IGNoaWxkcmVuLiBXZSBjYW4gZGVsZXRlIHRoZSByZXN0LlxuICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIG9sZEZpYmVyKTtcblxuICAgICAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAgICAgdmFyIG51bWJlck9mRm9ya3MgPSBuZXdJZHg7XG4gICAgICAgIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgbnVtYmVyT2ZGb3Jrcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHRpbmdGaXJzdENoaWxkO1xuICAgIH1cblxuICAgIGlmIChvbGRGaWJlciA9PT0gbnVsbCkge1xuICAgICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhbnkgbW9yZSBleGlzdGluZyBjaGlsZHJlbiB3ZSBjYW4gY2hvb3NlIGEgZmFzdCBwYXRoXG4gICAgICAvLyBzaW5jZSB0aGUgcmVzdCB3aWxsIGFsbCBiZSBpbnNlcnRpb25zLlxuICAgICAgZm9yICg7IG5ld0lkeCA8IG5ld0NoaWxkcmVuLmxlbmd0aDsgbmV3SWR4KyspIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlciA9IGNyZWF0ZUNoaWxkKHJldHVybkZpYmVyLCBuZXdDaGlsZHJlbltuZXdJZHhdLCBsYW5lcywgZGVidWdJbmZvKTtcblxuICAgICAgICBpZiAoX25ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cblxuICAgICAgICBsYXN0UGxhY2VkSW5kZXggPSBwbGFjZUNoaWxkKF9uZXdGaWJlciwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjtcbiAgICAgIH1cblxuICAgICAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAgICAgdmFyIF9udW1iZXJPZkZvcmtzID0gbmV3SWR4O1xuICAgICAgICBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIF9udW1iZXJPZkZvcmtzKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gICAgfSAvLyBBZGQgYWxsIGNoaWxkcmVuIHRvIGEga2V5IG1hcCBmb3IgcXVpY2sgbG9va3Vwcy5cblxuXG4gICAgdmFyIGV4aXN0aW5nQ2hpbGRyZW4gPSBtYXBSZW1haW5pbmdDaGlsZHJlbihvbGRGaWJlcik7IC8vIEtlZXAgc2Nhbm5pbmcgYW5kIHVzZSB0aGUgbWFwIHRvIHJlc3RvcmUgZGVsZXRlZCBpdGVtcyBhcyBtb3Zlcy5cblxuICAgIGZvciAoOyBuZXdJZHggPCBuZXdDaGlsZHJlbi5sZW5ndGg7IG5ld0lkeCsrKSB7XG4gICAgICB2YXIgX25ld0ZpYmVyMiA9IHVwZGF0ZUZyb21NYXAoZXhpc3RpbmdDaGlsZHJlbiwgcmV0dXJuRmliZXIsIG5ld0lkeCwgbmV3Q2hpbGRyZW5bbmV3SWR4XSwgbGFuZXMsIGRlYnVnSW5mbyk7XG5cbiAgICAgIGlmIChfbmV3RmliZXIyICE9PSBudWxsKSB7XG4gICAgICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAgICAgaWYgKF9uZXdGaWJlcjIuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBUaGUgbmV3IGZpYmVyIGlzIGEgd29yayBpbiBwcm9ncmVzcywgYnV0IGlmIHRoZXJlIGV4aXN0cyBhXG4gICAgICAgICAgICAvLyBjdXJyZW50LCB0aGF0IG1lYW5zIHRoYXQgd2UgcmV1c2VkIHRoZSBmaWJlci4gV2UgbmVlZCB0byBkZWxldGVcbiAgICAgICAgICAgIC8vIGl0IGZyb20gdGhlIGNoaWxkIGxpc3Qgc28gdGhhdCB3ZSBkb24ndCBhZGQgaXQgdG8gdGhlIGRlbGV0aW9uXG4gICAgICAgICAgICAvLyBsaXN0LlxuICAgICAgICAgICAgZXhpc3RpbmdDaGlsZHJlbi5kZWxldGUoX25ld0ZpYmVyMi5rZXkgPT09IG51bGwgPyBuZXdJZHggOiBfbmV3RmliZXIyLmtleSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGFzdFBsYWNlZEluZGV4ID0gcGxhY2VDaGlsZChfbmV3RmliZXIyLCBsYXN0UGxhY2VkSW5kZXgsIG5ld0lkeCk7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gX25ld0ZpYmVyMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwcmV2aW91c05ld0ZpYmVyLnNpYmxpbmcgPSBfbmV3RmliZXIyO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJldmlvdXNOZXdGaWJlciA9IF9uZXdGaWJlcjI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgIC8vIEFueSBleGlzdGluZyBjaGlsZHJlbiB0aGF0IHdlcmVuJ3QgY29uc3VtZWQgYWJvdmUgd2VyZSBkZWxldGVkLiBXZSBuZWVkXG4gICAgICAvLyB0byBhZGQgdGhlbSB0byB0aGUgZGVsZXRpb24gbGlzdC5cbiAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIGRlbGV0ZUNoaWxkKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgICAgdmFyIF9udW1iZXJPZkZvcmtzMiA9IG5ld0lkeDtcbiAgICAgIHB1c2hUcmVlRm9yayhyZXR1cm5GaWJlciwgX251bWJlck9mRm9ya3MyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0YWJsZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkcmVuSXRlcmFibGUsIGxhbmVzLCBkZWJ1Z0luZm8pIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBzYW1lIGltcGxlbWVudGF0aW9uIGFzIHJlY29uY2lsZUNoaWxkcmVuQXJyYXkoKSxcbiAgICAvLyBidXQgdXNpbmcgdGhlIGl0ZXJhdG9yIGluc3RlYWQuXG4gICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5ld0NoaWxkcmVuSXRlcmFibGUpO1xuXG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FuIG9iamVjdCBpcyBub3QgYW4gaXRlcmFibGUuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiAnICsgJ1JlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICB2YXIgbmV3Q2hpbGRyZW4gPSBpdGVyYXRvckZuLmNhbGwobmV3Q2hpbGRyZW5JdGVyYWJsZSk7XG5cbiAgICB7XG4gICAgICBpZiAobmV3Q2hpbGRyZW4gPT09IG5ld0NoaWxkcmVuSXRlcmFibGUpIHtcbiAgICAgICAgLy8gV2UgZG9uJ3Qgc3VwcG9ydCByZW5kZXJpbmcgR2VuZXJhdG9ycyBhcyBwcm9wcyBiZWNhdXNlIGl0J3MgYSBtdXRhdGlvbi5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTI5OTVcbiAgICAgICAgLy8gV2UgZG8gc3VwcG9ydCBnZW5lcmF0b3JzIGlmIHRoZXkgd2VyZSBjcmVhdGVkIGJ5IGEgR2VuZXJhdG9yRnVuY3Rpb24gY29tcG9uZW50XG4gICAgICAgIC8vIGFzIGl0cyBkaXJlY3QgY2hpbGQgc2luY2Ugd2UgY2FuIHJlY3JlYXRlIHRob3NlIGJ5IHJlcmVuZGVyaW5nIHRoZSBjb21wb25lbnRcbiAgICAgICAgLy8gYXMgbmVlZGVkLlxuICAgICAgICB2YXIgaXNHZW5lcmF0b3JDb21wb25lbnQgPSByZXR1cm5GaWJlci50YWcgPT09IEZ1bmN0aW9uQ29tcG9uZW50ICYmIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHJldHVybkZpYmVyLnR5cGUpID09PSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nICYmIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0NoaWxkcmVuKSA9PT0gJ1tvYmplY3QgR2VuZXJhdG9yXSc7XG5cbiAgICAgICAgaWYgKCFpc0dlbmVyYXRvckNvbXBvbmVudCkge1xuICAgICAgICAgIGlmICghZGlkV2FybkFib3V0R2VuZXJhdG9ycykge1xuICAgICAgICAgICAgZXJyb3IoJ1VzaW5nIEl0ZXJhdG9ycyBhcyBjaGlsZHJlbiBpcyB1bnN1cHBvcnRlZCBhbmQgd2lsbCBsaWtlbHkgeWllbGQgJyArICd1bmV4cGVjdGVkIHJlc3VsdHMgYmVjYXVzZSBlbnVtZXJhdGluZyBhIGdlbmVyYXRvciBtdXRhdGVzIGl0LiAnICsgJ1lvdSBtYXkgY29udmVydCBpdCB0byBhbiBhcnJheSB3aXRoIGBBcnJheS5mcm9tKClgIG9yIHRoZSAnICsgJ2BbLi4uc3ByZWFkXWAgb3BlcmF0b3IgYmVmb3JlIHJlbmRlcmluZy4gWW91IGNhbiBhbHNvIHVzZSBhbiAnICsgJ0l0ZXJhYmxlIHRoYXQgY2FuIGl0ZXJhdGUgbXVsdGlwbGUgdGltZXMgb3ZlciB0aGUgc2FtZSBpdGVtcy4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBkaWRXYXJuQWJvdXRHZW5lcmF0b3JzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChuZXdDaGlsZHJlbkl0ZXJhYmxlLmVudHJpZXMgPT09IGl0ZXJhdG9yRm4pIHtcbiAgICAgICAgLy8gV2FybiBhYm91dCB1c2luZyBNYXBzIGFzIGNoaWxkcmVuXG4gICAgICAgIGlmICghZGlkV2FybkFib3V0TWFwcykge1xuICAgICAgICAgIGVycm9yKCdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCBzdXBwb3J0ZWQuICcgKyAnVXNlIGFuIGFycmF5IG9mIGtleWVkIFJlYWN0RWxlbWVudHMgaW5zdGVhZC4nKTtcblxuICAgICAgICAgIGRpZFdhcm5BYm91dE1hcHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkcmVuSXRlcmF0b3IocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZHJlbiwgbGFuZXMsIGRlYnVnSW5mbyk7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGRyZW4sIGxhbmVzLCBkZWJ1Z0luZm8pIHtcbiAgICBpZiAobmV3Q2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdBbiBpdGVyYWJsZSBvYmplY3QgcHJvdmlkZWQgbm8gaXRlcmF0b3IuJyk7XG4gICAgfVxuXG4gICAgdmFyIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBudWxsO1xuICAgIHZhciBwcmV2aW91c05ld0ZpYmVyID0gbnVsbDtcbiAgICB2YXIgb2xkRmliZXIgPSBjdXJyZW50Rmlyc3RDaGlsZDtcbiAgICB2YXIgbGFzdFBsYWNlZEluZGV4ID0gMDtcbiAgICB2YXIgbmV3SWR4ID0gMDtcbiAgICB2YXIgbmV4dE9sZEZpYmVyID0gbnVsbDtcbiAgICB2YXIga25vd25LZXlzID0gbnVsbDtcbiAgICB2YXIgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKTtcblxuICAgIHtcbiAgICAgIGtub3duS2V5cyA9IHdhcm5PbkludmFsaWRLZXkoc3RlcC52YWx1ZSwga25vd25LZXlzLCByZXR1cm5GaWJlcik7XG4gICAgfVxuXG4gICAgZm9yICg7IG9sZEZpYmVyICE9PSBudWxsICYmICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpLCBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KHN0ZXAudmFsdWUsIGtub3duS2V5cywgcmV0dXJuRmliZXIpICkge1xuICAgICAgaWYgKG9sZEZpYmVyLmluZGV4ID4gbmV3SWR4KSB7XG4gICAgICAgIG5leHRPbGRGaWJlciA9IG9sZEZpYmVyO1xuICAgICAgICBvbGRGaWJlciA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXh0T2xkRmliZXIgPSBvbGRGaWJlci5zaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICB2YXIgbmV3RmliZXIgPSB1cGRhdGVTbG90KHJldHVybkZpYmVyLCBvbGRGaWJlciwgc3RlcC52YWx1ZSwgbGFuZXMsIGRlYnVnSW5mbyk7XG5cbiAgICAgIGlmIChuZXdGaWJlciA9PT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBUaGlzIGJyZWFrcyBvbiBlbXB0eSBzbG90cyBsaWtlIG51bGwgY2hpbGRyZW4uIFRoYXQnc1xuICAgICAgICAvLyB1bmZvcnR1bmF0ZSBiZWNhdXNlIGl0IHRyaWdnZXJzIHRoZSBzbG93IHBhdGggYWxsIHRoZSB0aW1lLiBXZSBuZWVkXG4gICAgICAgIC8vIGEgYmV0dGVyIHdheSB0byBjb21tdW5pY2F0ZSB3aGV0aGVyIHRoaXMgd2FzIGEgbWlzcyBvciBudWxsLFxuICAgICAgICAvLyBib29sZWFuLCB1bmRlZmluZWQsIGV0Yy5cbiAgICAgICAgaWYgKG9sZEZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgb2xkRmliZXIgPSBuZXh0T2xkRmliZXI7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHNob3VsZFRyYWNrU2lkZUVmZmVjdHMpIHtcbiAgICAgICAgaWYgKG9sZEZpYmVyICYmIG5ld0ZpYmVyLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIG1hdGNoZWQgdGhlIHNsb3QsIGJ1dCB3ZSBkaWRuJ3QgcmV1c2UgdGhlIGV4aXN0aW5nIGZpYmVyLCBzbyB3ZVxuICAgICAgICAgIC8vIG5lZWQgdG8gZGVsZXRlIHRoZSBleGlzdGluZyBjaGlsZC5cbiAgICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgb2xkRmliZXIpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQobmV3RmliZXIsIGxhc3RQbGFjZWRJbmRleCwgbmV3SWR4KTtcblxuICAgICAgaWYgKHByZXZpb3VzTmV3RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICByZXN1bHRpbmdGaXJzdENoaWxkID0gbmV3RmliZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUT0RPOiBEZWZlciBzaWJsaW5ncyBpZiB3ZSdyZSBub3QgYXQgdGhlIHJpZ2h0IGluZGV4IGZvciB0aGlzIHNsb3QuXG4gICAgICAgIC8vIEkuZS4gaWYgd2UgaGFkIG51bGwgdmFsdWVzIGJlZm9yZSwgdGhlbiB3ZSB3YW50IHRvIGRlZmVyIHRoaXNcbiAgICAgICAgLy8gZm9yIGVhY2ggbnVsbCB2YWx1ZS4gSG93ZXZlciwgd2UgYWxzbyBkb24ndCB3YW50IHRvIGNhbGwgdXBkYXRlU2xvdFxuICAgICAgICAvLyB3aXRoIHRoZSBwcmV2aW91cyBvbmUuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IG5ld0ZpYmVyO1xuICAgICAgfVxuXG4gICAgICBwcmV2aW91c05ld0ZpYmVyID0gbmV3RmliZXI7XG4gICAgICBvbGRGaWJlciA9IG5leHRPbGRGaWJlcjtcbiAgICB9XG5cbiAgICBpZiAoc3RlcC5kb25lKSB7XG4gICAgICAvLyBXZSd2ZSByZWFjaGVkIHRoZSBlbmQgb2YgdGhlIG5ldyBjaGlsZHJlbi4gV2UgY2FuIGRlbGV0ZSB0aGUgcmVzdC5cbiAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBvbGRGaWJlcik7XG5cbiAgICAgIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgICAgIHZhciBudW1iZXJPZkZvcmtzID0gbmV3SWR4O1xuICAgICAgICBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIG51bWJlck9mRm9ya3MpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9XG5cbiAgICBpZiAob2xkRmliZXIgPT09IG51bGwpIHtcbiAgICAgIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IG1vcmUgZXhpc3RpbmcgY2hpbGRyZW4gd2UgY2FuIGNob29zZSBhIGZhc3QgcGF0aFxuICAgICAgLy8gc2luY2UgdGhlIHJlc3Qgd2lsbCBhbGwgYmUgaW5zZXJ0aW9ucy5cbiAgICAgIGZvciAoOyAhc3RlcC5kb25lOyBuZXdJZHgrKywgc3RlcCA9IG5ld0NoaWxkcmVuLm5leHQoKSwga25vd25LZXlzID0gd2Fybk9uSW52YWxpZEtleShzdGVwLnZhbHVlLCBrbm93bktleXMsIHJldHVybkZpYmVyKSApIHtcbiAgICAgICAgdmFyIF9uZXdGaWJlcjMgPSBjcmVhdGVDaGlsZChyZXR1cm5GaWJlciwgc3RlcC52YWx1ZSwgbGFuZXMsIGRlYnVnSW5mbyk7XG5cbiAgICAgICAgaWYgKF9uZXdGaWJlcjMgPT09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyMywgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gVE9ETzogTW92ZSBvdXQgb2YgdGhlIGxvb3AuIFRoaXMgb25seSBoYXBwZW5zIGZvciB0aGUgZmlyc3QgcnVuLlxuICAgICAgICAgIHJlc3VsdGluZ0ZpcnN0Q2hpbGQgPSBfbmV3RmliZXIzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByZXZpb3VzTmV3RmliZXIuc2libGluZyA9IF9uZXdGaWJlcjM7XG4gICAgICAgIH1cblxuICAgICAgICBwcmV2aW91c05ld0ZpYmVyID0gX25ld0ZpYmVyMztcbiAgICAgIH1cblxuICAgICAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAgICAgdmFyIF9udW1iZXJPZkZvcmtzMyA9IG5ld0lkeDtcbiAgICAgICAgcHVzaFRyZWVGb3JrKHJldHVybkZpYmVyLCBfbnVtYmVyT2ZGb3JrczMpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0aW5nRmlyc3RDaGlsZDtcbiAgICB9IC8vIEFkZCBhbGwgY2hpbGRyZW4gdG8gYSBrZXkgbWFwIGZvciBxdWljayBsb29rdXBzLlxuXG5cbiAgICB2YXIgZXhpc3RpbmdDaGlsZHJlbiA9IG1hcFJlbWFpbmluZ0NoaWxkcmVuKG9sZEZpYmVyKTsgLy8gS2VlcCBzY2FubmluZyBhbmQgdXNlIHRoZSBtYXAgdG8gcmVzdG9yZSBkZWxldGVkIGl0ZW1zIGFzIG1vdmVzLlxuXG4gICAgZm9yICg7ICFzdGVwLmRvbmU7IG5ld0lkeCsrLCBzdGVwID0gbmV3Q2hpbGRyZW4ubmV4dCgpLCBrbm93bktleXMgPSB3YXJuT25JbnZhbGlkS2V5KHN0ZXAudmFsdWUsIGtub3duS2V5cywgcmV0dXJuRmliZXIpICkge1xuICAgICAgdmFyIF9uZXdGaWJlcjQgPSB1cGRhdGVGcm9tTWFwKGV4aXN0aW5nQ2hpbGRyZW4sIHJldHVybkZpYmVyLCBuZXdJZHgsIHN0ZXAudmFsdWUsIGxhbmVzLCBkZWJ1Z0luZm8pO1xuXG4gICAgICBpZiAoX25ld0ZpYmVyNCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAoc2hvdWxkVHJhY2tTaWRlRWZmZWN0cykge1xuICAgICAgICAgIGlmIChfbmV3RmliZXI0LmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIG5ldyBmaWJlciBpcyBhIHdvcmsgaW4gcHJvZ3Jlc3MsIGJ1dCBpZiB0aGVyZSBleGlzdHMgYVxuICAgICAgICAgICAgLy8gY3VycmVudCwgdGhhdCBtZWFucyB0aGF0IHdlIHJldXNlZCB0aGUgZmliZXIuIFdlIG5lZWQgdG8gZGVsZXRlXG4gICAgICAgICAgICAvLyBpdCBmcm9tIHRoZSBjaGlsZCBsaXN0IHNvIHRoYXQgd2UgZG9uJ3QgYWRkIGl0IHRvIHRoZSBkZWxldGlvblxuICAgICAgICAgICAgLy8gbGlzdC5cbiAgICAgICAgICAgIGV4aXN0aW5nQ2hpbGRyZW4uZGVsZXRlKF9uZXdGaWJlcjQua2V5ID09PSBudWxsID8gbmV3SWR4IDogX25ld0ZpYmVyNC5rZXkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGxhc3RQbGFjZWRJbmRleCA9IHBsYWNlQ2hpbGQoX25ld0ZpYmVyNCwgbGFzdFBsYWNlZEluZGV4LCBuZXdJZHgpO1xuXG4gICAgICAgIGlmIChwcmV2aW91c05ld0ZpYmVyID09PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0aW5nRmlyc3RDaGlsZCA9IF9uZXdGaWJlcjQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJldmlvdXNOZXdGaWJlci5zaWJsaW5nID0gX25ld0ZpYmVyNDtcbiAgICAgICAgfVxuXG4gICAgICAgIHByZXZpb3VzTmV3RmliZXIgPSBfbmV3RmliZXI0O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRUcmFja1NpZGVFZmZlY3RzKSB7XG4gICAgICAvLyBBbnkgZXhpc3RpbmcgY2hpbGRyZW4gdGhhdCB3ZXJlbid0IGNvbnN1bWVkIGFib3ZlIHdlcmUgZGVsZXRlZC4gV2UgbmVlZFxuICAgICAgLy8gdG8gYWRkIHRoZW0gdG8gdGhlIGRlbGV0aW9uIGxpc3QuXG4gICAgICBleGlzdGluZ0NoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgIHJldHVybiBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAgIHZhciBfbnVtYmVyT2ZGb3JrczQgPSBuZXdJZHg7XG4gICAgICBwdXNoVHJlZUZvcmsocmV0dXJuRmliZXIsIF9udW1iZXJPZkZvcmtzNCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdGluZ0ZpcnN0Q2hpbGQ7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVUZXh0Tm9kZShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHRleHRDb250ZW50LCBsYW5lcykge1xuICAgIC8vIFRoZXJlJ3Mgbm8gbmVlZCB0byBjaGVjayBmb3Iga2V5cyBvbiB0ZXh0IG5vZGVzIHNpbmNlIHdlIGRvbid0IGhhdmUgYVxuICAgIC8vIHdheSB0byBkZWZpbmUgdGhlbS5cbiAgICBpZiAoY3VycmVudEZpcnN0Q2hpbGQgIT09IG51bGwgJiYgY3VycmVudEZpcnN0Q2hpbGQudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgLy8gV2UgYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG5vZGUgc28gbGV0J3MganVzdCB1cGRhdGUgaXQgYW5kIGRlbGV0ZVxuICAgICAgLy8gdGhlIHJlc3QuXG4gICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQuc2libGluZyk7XG4gICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjdXJyZW50Rmlyc3RDaGlsZCwgdGV4dENvbnRlbnQpO1xuICAgICAgZXhpc3RpbmcucmV0dXJuID0gcmV0dXJuRmliZXI7XG4gICAgICByZXR1cm4gZXhpc3Rpbmc7XG4gICAgfSAvLyBUaGUgZXhpc3RpbmcgZmlyc3QgY2hpbGQgaXMgbm90IGEgdGV4dCBub2RlIHNvIHdlIG5lZWQgdG8gY3JlYXRlIG9uZVxuICAgIC8vIGFuZCBkZWxldGUgdGhlIGV4aXN0aW5nIG9uZXMuXG5cblxuICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCk7XG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21UZXh0KHRleHRDb250ZW50LCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZVNpbmdsZUVsZW1lbnQocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBlbGVtZW50LCBsYW5lcywgZGVidWdJbmZvKSB7XG4gICAgdmFyIGtleSA9IGVsZW1lbnQua2V5O1xuICAgIHZhciBjaGlsZCA9IGN1cnJlbnRGaXJzdENoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBJZiBrZXkgPT09IG51bGwgYW5kIGNoaWxkLmtleSA9PT0gbnVsbCwgdGhlbiB0aGlzIG9ubHkgYXBwbGllcyB0b1xuICAgICAgLy8gdGhlIGZpcnN0IGl0ZW0gaW4gdGhlIGxpc3QuXG4gICAgICBpZiAoY2hpbGQua2V5ID09PSBrZXkpIHtcbiAgICAgICAgdmFyIGVsZW1lbnRUeXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgICAgIGlmIChlbGVtZW50VHlwZSA9PT0gUkVBQ1RfRlJBR01FTlRfVFlQRSkge1xuICAgICAgICAgIGlmIChjaGlsZC50YWcgPT09IEZyYWdtZW50KSB7XG4gICAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQuc2libGluZyk7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmcgPSB1c2VGaWJlcihjaGlsZCwgZWxlbWVudC5wcm9wcy5jaGlsZHJlbik7XG4gICAgICAgICAgICBleGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBleGlzdGluZy5fZGVidWdPd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgICAgICAgICBleGlzdGluZy5fZGVidWdJbmZvID0gZGVidWdJbmZvO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCwgZXhpc3RpbmcsIHJldHVybkZpYmVyKTtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNoaWxkLmVsZW1lbnRUeXBlID09PSBlbGVtZW50VHlwZSB8fCAoIC8vIEtlZXAgdGhpcyBjaGVjayBpbmxpbmUgc28gaXQgb25seSBydW5zIG9uIHRoZSBmYWxzZSBwYXRoOlxuICAgICAgICAgIGlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyhjaGlsZCwgZWxlbWVudCkgKSB8fCAvLyBMYXp5IHR5cGVzIHNob3VsZCByZWNvbmNpbGUgdGhlaXIgcmVzb2x2ZWQgdHlwZS5cbiAgICAgICAgICAvLyBXZSBuZWVkIHRvIGRvIHRoaXMgYWZ0ZXIgdGhlIEhvdCBSZWxvYWRpbmcgY2hlY2sgYWJvdmUsXG4gICAgICAgICAgLy8gYmVjYXVzZSBob3QgcmVsb2FkaW5nIGhhcyBkaWZmZXJlbnQgc2VtYW50aWNzIHRoYW4gcHJvZCBiZWNhdXNlXG4gICAgICAgICAgLy8gaXQgZG9lc24ndCByZXN1c3BlbmQuIFNvIHdlIGNhbid0IGxldCB0aGUgY2FsbCBiZWxvdyBzdXNwZW5kLlxuICAgICAgICAgIHR5cGVvZiBlbGVtZW50VHlwZSA9PT0gJ29iamVjdCcgJiYgZWxlbWVudFR5cGUgIT09IG51bGwgJiYgZWxlbWVudFR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSAmJiByZXNvbHZlTGF6eShlbGVtZW50VHlwZSkgPT09IGNoaWxkLnR5cGUpIHtcbiAgICAgICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZC5zaWJsaW5nKTtcblxuICAgICAgICAgICAgdmFyIF9leGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBlbGVtZW50LnByb3BzKTtcblxuICAgICAgICAgICAgY29lcmNlUmVmKHJldHVybkZpYmVyLCBjaGlsZCwgX2V4aXN0aW5nLCBlbGVtZW50KTtcbiAgICAgICAgICAgIF9leGlzdGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBfZXhpc3RpbmcuX2RlYnVnT3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICAgICAgX2V4aXN0aW5nLl9kZWJ1Z0luZm8gPSBkZWJ1Z0luZm87XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBfZXhpc3Rpbmc7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIERpZG4ndCBtYXRjaC5cblxuXG4gICAgICAgIGRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuKHJldHVybkZpYmVyLCBjaGlsZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlQ2hpbGQocmV0dXJuRmliZXIsIGNoaWxkKTtcbiAgICAgIH1cblxuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cblxuICAgIGlmIChlbGVtZW50LnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhciBjcmVhdGVkID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZWxlbWVudC5wcm9wcy5jaGlsZHJlbiwgcmV0dXJuRmliZXIubW9kZSwgbGFuZXMsIGVsZW1lbnQua2V5KTtcbiAgICAgIGNyZWF0ZWQucmV0dXJuID0gcmV0dXJuRmliZXI7XG5cbiAgICAgIHtcbiAgICAgICAgY3JlYXRlZC5fZGVidWdJbmZvID0gZGVidWdJbmZvO1xuICAgICAgfVxuXG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCwgY3JlYXRlZCwgcmV0dXJuRmliZXIpO1xuICAgICAgcmV0dXJuIGNyZWF0ZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfY3JlYXRlZDQgPSBjcmVhdGVGaWJlckZyb21FbGVtZW50KGVsZW1lbnQsIHJldHVybkZpYmVyLm1vZGUsIGxhbmVzKTtcblxuICAgICAgY29lcmNlUmVmKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgX2NyZWF0ZWQ0LCBlbGVtZW50KTtcbiAgICAgIF9jcmVhdGVkNC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcblxuICAgICAge1xuICAgICAgICBfY3JlYXRlZDQuX2RlYnVnSW5mbyA9IGRlYnVnSW5mbztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIF9jcmVhdGVkNDtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmNpbGVTaW5nbGVQb3J0YWwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBwb3J0YWwsIGxhbmVzLCBkZWJ1Z0luZm8pIHtcbiAgICB2YXIga2V5ID0gcG9ydGFsLmtleTtcbiAgICB2YXIgY2hpbGQgPSBjdXJyZW50Rmlyc3RDaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgLy8gVE9ETzogSWYga2V5ID09PSBudWxsIGFuZCBjaGlsZC5rZXkgPT09IG51bGwsIHRoZW4gdGhpcyBvbmx5IGFwcGxpZXMgdG9cbiAgICAgIC8vIHRoZSBmaXJzdCBpdGVtIGluIHRoZSBsaXN0LlxuICAgICAgaWYgKGNoaWxkLmtleSA9PT0ga2V5KSB7XG4gICAgICAgIGlmIChjaGlsZC50YWcgPT09IEhvc3RQb3J0YWwgJiYgY2hpbGQuc3RhdGVOb2RlLmNvbnRhaW5lckluZm8gPT09IHBvcnRhbC5jb250YWluZXJJbmZvICYmIGNoaWxkLnN0YXRlTm9kZS5pbXBsZW1lbnRhdGlvbiA9PT0gcG9ydGFsLmltcGxlbWVudGF0aW9uKSB7XG4gICAgICAgICAgZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGNoaWxkLnNpYmxpbmcpO1xuICAgICAgICAgIHZhciBleGlzdGluZyA9IHVzZUZpYmVyKGNoaWxkLCBwb3J0YWwuY2hpbGRyZW4gfHwgW10pO1xuICAgICAgICAgIGV4aXN0aW5nLnJldHVybiA9IHJldHVybkZpYmVyO1xuICAgICAgICAgIHJldHVybiBleGlzdGluZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGVSZW1haW5pbmdDaGlsZHJlbihyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGVDaGlsZChyZXR1cm5GaWJlciwgY2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuXG4gICAgdmFyIGNyZWF0ZWQgPSBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCByZXR1cm5GaWJlci5tb2RlLCBsYW5lcyk7XG4gICAgY3JlYXRlZC5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICByZXR1cm4gY3JlYXRlZDtcbiAgfSAvLyBUaGlzIEFQSSB3aWxsIHRhZyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgc2lkZS1lZmZlY3Qgb2YgdGhlIHJlY29uY2lsaWF0aW9uXG4gIC8vIGl0c2VsZi4gVGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBzaWRlLWVmZmVjdCBsaXN0IGFzIHdlIHBhc3MgdGhyb3VnaCB0aGVcbiAgLy8gY2hpbGRyZW4gYW5kIHRoZSBwYXJlbnQuXG5cblxuICBmdW5jdGlvbiByZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBuZXdDaGlsZCwgbGFuZXMsIGRlYnVnSW5mbykge1xuICAgIC8vIFRoaXMgZnVuY3Rpb24gaXMgb25seSByZWN1cnNpdmUgZm9yIFVzYWJsZXMvTGF6eSBhbmQgbm90IG5lc3RlZCBhcnJheXMuXG4gICAgLy8gVGhhdCdzIHNvIHRoYXQgdXNpbmcgYSBMYXp5IHdyYXBwZXIgaXMgdW5vYnNlcnZhYmxlIHRvIHRoZSBGcmFnbWVudFxuICAgIC8vIGNvbnZlbnRpb24uXG4gICAgLy8gSWYgdGhlIHRvcCBsZXZlbCBpdGVtIGlzIGFuIGFycmF5LCB3ZSB0cmVhdCBpdCBhcyBhIHNldCBvZiBjaGlsZHJlbixcbiAgICAvLyBub3QgYXMgYSBmcmFnbWVudC4gTmVzdGVkIGFycmF5cyBvbiB0aGUgb3RoZXIgaGFuZCB3aWxsIGJlIHRyZWF0ZWQgYXNcbiAgICAvLyBmcmFnbWVudCBub2Rlcy4gUmVjdXJzaW9uIGhhcHBlbnMgYXQgdGhlIG5vcm1hbCBmbG93LlxuICAgIC8vIEhhbmRsZSB0b3AgbGV2ZWwgdW5rZXllZCBmcmFnbWVudHMgYXMgaWYgdGhleSB3ZXJlIGFycmF5cy5cbiAgICAvLyBUaGlzIGxlYWRzIHRvIGFuIGFtYmlndWl0eSBiZXR3ZWVuIDw+e1suLi5dfTwvPiBhbmQgPD4uLi48Lz4uXG4gICAgLy8gV2UgdHJlYXQgdGhlIGFtYmlndW91cyBjYXNlcyBhYm92ZSB0aGUgc2FtZS5cbiAgICAvLyBXZSBkb24ndCB1c2UgcmVjdXJzaW9uIGhlcmUgYmVjYXVzZSBhIGZyYWdtZW50IGluc2lkZSBhIGZyYWdtZW50XG4gICAgLy8gaXMgbm8gbG9uZ2VyIGNvbnNpZGVyZWQgXCJ0b3AgbGV2ZWxcIiBmb3IgdGhlc2UgcHVycG9zZXMuXG4gICAgdmFyIGlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQgPSB0eXBlb2YgbmV3Q2hpbGQgPT09ICdvYmplY3QnICYmIG5ld0NoaWxkICE9PSBudWxsICYmIG5ld0NoaWxkLnR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUgJiYgbmV3Q2hpbGQua2V5ID09PSBudWxsO1xuXG4gICAgaWYgKGlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhuZXdDaGlsZCwgbnVsbCwgcmV0dXJuRmliZXIpO1xuICAgICAgbmV3Q2hpbGQgPSBuZXdDaGlsZC5wcm9wcy5jaGlsZHJlbjtcbiAgICB9IC8vIEhhbmRsZSBvYmplY3QgdHlwZXNcblxuXG4gICAgaWYgKHR5cGVvZiBuZXdDaGlsZCA9PT0gJ29iamVjdCcgJiYgbmV3Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgIHN3aXRjaCAobmV3Q2hpbGQuJCR0eXBlb2YpIHtcbiAgICAgICAgY2FzZSBSRUFDVF9FTEVNRU5UX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlRWxlbWVudChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcywgbWVyZ2VEZWJ1Z0luZm8oZGVidWdJbmZvLCBuZXdDaGlsZC5fZGVidWdJbmZvKSkpO1xuXG4gICAgICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICAgICAgcmV0dXJuIHBsYWNlU2luZ2xlQ2hpbGQocmVjb25jaWxlU2luZ2xlUG9ydGFsKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGxhbmVzKSk7XG5cbiAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBuZXdDaGlsZC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IG5ld0NoaWxkLl9pbml0O1xuICAgICAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCBpbml0KHBheWxvYWQpLCBsYW5lcywgbWVyZ2VEZWJ1Z0luZm8oZGVidWdJbmZvLCBuZXdDaGlsZC5fZGVidWdJbmZvKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChpc0FycmF5KG5ld0NoaWxkKSkge1xuICAgICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5BcnJheShyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcywgbWVyZ2VEZWJ1Z0luZm8oZGVidWdJbmZvLCBuZXdDaGlsZC5fZGVidWdJbmZvKSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChnZXRJdGVyYXRvckZuKG5ld0NoaWxkKSkge1xuICAgICAgICByZXR1cm4gcmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRhYmxlKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGxhbmVzLCBtZXJnZURlYnVnSW5mbyhkZWJ1Z0luZm8sIG5ld0NoaWxkLl9kZWJ1Z0luZm8pKTtcbiAgICAgIH1cbiAgICAgIC8vIGEgY2hpbGQgcG9zaXRpb24sIGl0IHVud3JhcHMgaXQgdXNpbmcgdGhlIHNhbWUgYWxnb3JpdGhtIGFzIGB1c2VgLiBGb3JcbiAgICAgIC8vIGV4YW1wbGUsIGZvciBwcm9taXNlcywgUmVhY3Qgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gdG8gdW53aW5kIHRoZVxuICAgICAgLy8gc3RhY2ssIHRoZW4gcmVwbGF5IHRoZSBjb21wb25lbnQgb25jZSB0aGUgcHJvbWlzZSByZXNvbHZlcy5cbiAgICAgIC8vXG4gICAgICAvLyBBIGRpZmZlcmVuY2UgZnJvbSBgdXNlYCBpcyB0aGF0IFJlYWN0IHdpbGwga2VlcCB1bndyYXBwaW5nIHRoZSB2YWx1ZVxuICAgICAgLy8gdW50aWwgaXQgcmVhY2hlcyBhIG5vbi1Vc2FibGUgdHlwZS5cbiAgICAgIC8vXG4gICAgICAvLyBlLmcuIFVzYWJsZTxVc2FibGU8VXNhYmxlPFQ+Pj4gc2hvdWxkIHJlc29sdmUgdG8gVFxuICAgICAgLy9cbiAgICAgIC8vIFRoZSBzdHJ1Y3R1cmUgaXMgYSBiaXQgdW5mb3J0dW5hdGUuIElkZWFsbHksIHdlIHNob3VsZG4ndCBuZWVkIHRvXG4gICAgICAvLyByZXBsYXkgdGhlIGVudGlyZSBiZWdpbiBwaGFzZSBvZiB0aGUgcGFyZW50IGZpYmVyIGluIG9yZGVyIHRvIHJlY29uY2lsZVxuICAgICAgLy8gdGhlIGNoaWxkcmVuIGFnYWluLiBUaGlzIHdvdWxkIHJlcXVpcmUgYSBzb21ld2hhdCBzaWduaWZpY2FudCByZWZhY3RvcixcbiAgICAgIC8vIGJlY2F1c2UgcmVjb25jaWxhdGlvbiBoYXBwZW5zIGRlZXAgd2l0aGluIHRoZSBiZWdpbiBwaGFzZSwgYW5kXG4gICAgICAvLyBkZXBlbmRpbmcgb24gdGhlIHR5cGUgb2Ygd29yaywgbm90IGFsd2F5cyBhdCB0aGUgZW5kLiBXZSBzaG91bGRcbiAgICAgIC8vIGNvbnNpZGVyIGFzIGFuIGZ1dHVyZSBpbXByb3ZlbWVudC5cblxuXG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHRoZW5hYmxlID0gbmV3Q2hpbGQ7XG4gICAgICAgIHJldHVybiByZWNvbmNpbGVDaGlsZEZpYmVyc0ltcGwocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkLCB1bndyYXBUaGVuYWJsZSh0aGVuYWJsZSksIGxhbmVzLCBtZXJnZURlYnVnSW5mbyhkZWJ1Z0luZm8sIHRoZW5hYmxlLl9kZWJ1Z0luZm8pKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld0NoaWxkLiQkdHlwZW9mID09PSBSRUFDVF9DT05URVhUX1RZUEUpIHtcbiAgICAgICAgdmFyIGNvbnRleHQgPSBuZXdDaGlsZDtcbiAgICAgICAgcmV0dXJuIHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIHJlYWRDb250ZXh0RHVyaW5nUmVjb25jaWxpYXRpb24ocmV0dXJuRmliZXIsIGNvbnRleHQsIGxhbmVzKSwgbGFuZXMsIGRlYnVnSW5mbyk7XG4gICAgICB9XG5cbiAgICAgIHRocm93T25JbnZhbGlkT2JqZWN0VHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgbmV3Q2hpbGQgPT09ICdzdHJpbmcnICYmIG5ld0NoaWxkICE9PSAnJyB8fCB0eXBlb2YgbmV3Q2hpbGQgPT09ICdudW1iZXInIHx8IHR5cGVvZiBuZXdDaGlsZCA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgIHJldHVybiBwbGFjZVNpbmdsZUNoaWxkKHJlY29uY2lsZVNpbmdsZVRleHROb2RlKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgLy8gJEZsb3dGaXhNZVt1bnNhZmUtYWRkaXRpb25dIEZsb3cgZG9lc24ndCB3YW50IHVzIHRvIHVzZSBgK2Agb3BlcmF0b3Igd2l0aCBzdHJpbmcgYW5kIGJpZ2ludFxuICAgICAgJycgKyBuZXdDaGlsZCwgbGFuZXMpKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5PbkZ1bmN0aW9uVHlwZShyZXR1cm5GaWJlciwgbmV3Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIG5ld0NoaWxkID09PSAnc3ltYm9sJykge1xuICAgICAgICB3YXJuT25TeW1ib2xUeXBlKHJldHVybkZpYmVyLCBuZXdDaGlsZCk7XG4gICAgICB9XG4gICAgfSAvLyBSZW1haW5pbmcgY2FzZXMgYXJlIGFsbCB0cmVhdGVkIGFzIGVtcHR5LlxuXG5cbiAgICByZXR1cm4gZGVsZXRlUmVtYWluaW5nQ2hpbGRyZW4ocmV0dXJuRmliZXIsIGN1cnJlbnRGaXJzdENoaWxkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlY29uY2lsZUNoaWxkRmliZXJzKHJldHVybkZpYmVyLCBjdXJyZW50Rmlyc3RDaGlsZCwgbmV3Q2hpbGQsIGxhbmVzKSB7XG4gICAgLy8gVGhpcyBpbmRpcmVjdGlvbiBvbmx5IGV4aXN0cyBzbyB3ZSBjYW4gcmVzZXQgYHRoZW5hYmxlU3RhdGVgIGF0IHRoZSBlbmQuXG4gICAgLy8gSXQgc2hvdWxkIGdldCBpbmxpbmVkIGJ5IENsb3N1cmUuXG4gICAgdGhlbmFibGVJbmRleENvdW50ZXIkMSA9IDA7XG4gICAgdmFyIGZpcnN0Q2hpbGRGaWJlciA9IHJlY29uY2lsZUNoaWxkRmliZXJzSW1wbChyZXR1cm5GaWJlciwgY3VycmVudEZpcnN0Q2hpbGQsIG5ld0NoaWxkLCBsYW5lcywgbnVsbCAvLyBkZWJ1Z0luZm9cbiAgICApO1xuICAgIHRoZW5hYmxlU3RhdGUkMSA9IG51bGw7IC8vIERvbid0IGJvdGhlciB0byByZXNldCBgdGhlbmFibGVJbmRleENvdW50ZXJgIHRvIDAgYmVjYXVzZSBpdCBhbHdheXMgZ2V0c1xuICAgIC8vIHNldCBhdCB0aGUgYmVnaW5uaW5nLlxuXG4gICAgcmV0dXJuIGZpcnN0Q2hpbGRGaWJlcjtcbiAgfVxuXG4gIHJldHVybiByZWNvbmNpbGVDaGlsZEZpYmVycztcbn1cblxudmFyIHJlY29uY2lsZUNoaWxkRmliZXJzID0gY3JlYXRlQ2hpbGRSZWNvbmNpbGVyKHRydWUpO1xudmFyIG1vdW50Q2hpbGRGaWJlcnMgPSBjcmVhdGVDaGlsZFJlY29uY2lsZXIoZmFsc2UpO1xuZnVuY3Rpb24gcmVzZXRDaGlsZFJlY29uY2lsZXJPblVud2luZCgpIHtcbiAgLy8gT24gdW53aW5kLCBjbGVhciBhbnkgcGVuZGluZyB0aGVuYWJsZXMgdGhhdCB3ZXJlIHVzZWQuXG4gIHRoZW5hYmxlU3RhdGUkMSA9IG51bGw7XG4gIHRoZW5hYmxlSW5kZXhDb3VudGVyJDEgPSAwO1xufVxuZnVuY3Rpb24gY2xvbmVDaGlsZEZpYmVycyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5jaGlsZCAhPT0gY3VycmVudC5jaGlsZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignUmVzdW1pbmcgd29yayBub3QgeWV0IGltcGxlbWVudGVkLicpO1xuICB9XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzLmNoaWxkID09PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRDaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICB2YXIgbmV3Q2hpbGQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50Q2hpbGQsIGN1cnJlbnRDaGlsZC5wZW5kaW5nUHJvcHMpO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5ld0NoaWxkO1xuICBuZXdDaGlsZC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcblxuICB3aGlsZSAoY3VycmVudENoaWxkLnNpYmxpbmcgIT09IG51bGwpIHtcbiAgICBjdXJyZW50Q2hpbGQgPSBjdXJyZW50Q2hpbGQuc2libGluZztcbiAgICBuZXdDaGlsZCA9IG5ld0NoaWxkLnNpYmxpbmcgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50Q2hpbGQsIGN1cnJlbnRDaGlsZC5wZW5kaW5nUHJvcHMpO1xuICAgIG5ld0NoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB9XG5cbiAgbmV3Q2hpbGQuc2libGluZyA9IG51bGw7XG59IC8vIFJlc2V0IGEgd29ya0luUHJvZ3Jlc3MgY2hpbGQgc2V0IHRvIHByZXBhcmUgaXQgZm9yIGEgc2Vjb25kIHBhc3MuXG5cbmZ1bmN0aW9uIHJlc2V0Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGxhbmVzKSB7XG4gIHZhciBjaGlsZCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgIHJlc2V0V29ya0luUHJvZ3Jlc3MoY2hpbGQsIGxhbmVzKTtcbiAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gIH1cbn1cblxuLy8gVE9ETzogVGhpcyBpc24ndCBiZWluZyB1c2VkIHlldCwgYnV0IGl0J3MgaW50ZW5kZWQgdG8gcmVwbGFjZSB0aGVcbi8vIEludmlzaWJsZVBhcmVudENvbnRleHQgdGhhdCBpcyBjdXJyZW50bHkgbWFuYWdlZCBieSBTdXNwZW5zZUNvbnRleHQuXG5cbnZhciBjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpO1xudmFyIHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvciA9IGNyZWF0ZUN1cnNvcihOb0xhbmVzKTtcbmZ1bmN0aW9uIHB1c2hIaWRkZW5Db250ZXh0KGZpYmVyLCBjb250ZXh0KSB7XG4gIHZhciBwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXMgPSBnZXRFbnRhbmdsZWRSZW5kZXJMYW5lcygpO1xuICBwdXNoKHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvciwgcHJldkVudGFuZ2xlZFJlbmRlckxhbmVzLCBmaWJlcik7XG4gIHB1c2goY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvciwgY29udGV4dCwgZmliZXIpOyAvLyBXaGVuIHJlbmRlcmluZyBhIHN1YnRyZWUgdGhhdCdzIGN1cnJlbnRseSBoaWRkZW4sIHdlIG11c3QgaW5jbHVkZSBhbGxcbiAgLy8gbGFuZXMgdGhhdCB3b3VsZCBoYXZlIHJlbmRlcmVkIGlmIHRoZSBoaWRkZW4gc3VidHJlZSBoYWRuJ3QgYmVlbiBkZWZlcnJlZC5cbiAgLy8gVGhhdCBpcywgaW4gb3JkZXIgdG8gcmV2ZWFsIGNvbnRlbnQgZnJvbSBoaWRkZW4gLT4gdmlzaWJsZSwgd2UgbXVzdCBjb21taXRcbiAgLy8gYWxsIHRoZSB1cGRhdGVzIHRoYXQgd2Ugc2tpcHBlZCB3aGVuIHdlIG9yaWdpbmFsbHkgaGlkIHRoZSB0cmVlLlxuXG4gIHNldEVudGFuZ2xlZFJlbmRlckxhbmVzKG1lcmdlTGFuZXMocHJldkVudGFuZ2xlZFJlbmRlckxhbmVzLCBjb250ZXh0LmJhc2VMYW5lcykpO1xufVxuZnVuY3Rpb24gcmV1c2VIaWRkZW5Db250ZXh0T25TdGFjayhmaWJlcikge1xuICAvLyBUaGlzIHN1YnRyZWUgaXMgbm90IGN1cnJlbnRseSBoaWRkZW4sIHNvIHdlIGRvbid0IG5lZWQgdG8gYWRkIGFueSBsYW5lc1xuICAvLyB0byB0aGUgcmVuZGVyIGxhbmVzLiBCdXQgd2Ugc3RpbGwgbmVlZCB0byBwdXNoIHNvbWV0aGluZyB0byBhdm9pZCBhXG4gIC8vIGNvbnRleHQgbWlzbWF0Y2guIFJldXNlIHRoZSBleGlzdGluZyBjb250ZXh0IG9uIHRoZSBzdGFjay5cbiAgcHVzaChwcmV2RW50YW5nbGVkUmVuZGVyTGFuZXNDdXJzb3IsIGdldEVudGFuZ2xlZFJlbmRlckxhbmVzKCksIGZpYmVyKTtcbiAgcHVzaChjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yLCBjdXJyZW50VHJlZUhpZGRlblN0YWNrQ3Vyc29yLmN1cnJlbnQsIGZpYmVyKTtcbn1cbmZ1bmN0aW9uIHBvcEhpZGRlbkNvbnRleHQoZmliZXIpIHtcbiAgLy8gUmVzdG9yZSB0aGUgcHJldmlvdXMgcmVuZGVyIGxhbmVzIGZyb20gdGhlIHN0YWNrXG4gIHNldEVudGFuZ2xlZFJlbmRlckxhbmVzKHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvci5jdXJyZW50KTtcbiAgcG9wKGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IsIGZpYmVyKTtcbiAgcG9wKHByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvciwgZmliZXIpO1xufVxuZnVuY3Rpb24gaXNDdXJyZW50VHJlZUhpZGRlbigpIHtcbiAgcmV0dXJuIGN1cnJlbnRUcmVlSGlkZGVuU3RhY2tDdXJzb3IuY3VycmVudCAhPT0gbnVsbDtcbn1cblxuLy8gc3VzcGVuZHMsIGkuZS4gaXQncyB0aGUgbmVhcmVzdCBgY2F0Y2hgIGJsb2NrIG9uIHRoZSBzdGFjay5cblxudmFyIHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yID0gY3JlYXRlQ3Vyc29yKG51bGwpOyAvLyBSZXByZXNlbnRzIHRoZSBvdXRlcm1vc3QgYm91bmRhcnkgdGhhdCBpcyBub3QgdmlzaWJsZSBpbiB0aGUgY3VycmVudCB0cmVlLlxuLy8gRXZlcnl0aGluZyBhYm92ZSB0aGlzIGlzIHRoZSBcInNoZWxsXCIuIFdoZW4gdGhpcyBpcyBudWxsLCBpdCBtZWFucyB3ZSdyZVxuLy8gcmVuZGVyaW5nIGluIHRoZSBzaGVsbCBvZiB0aGUgYXBwLiBJZiBpdCdzIG5vbi1udWxsLCBpdCBtZWFucyB3ZSdyZSByZW5kZXJpbmdcbi8vIGRlZXBlciB0aGFuIHRoZSBzaGVsbCwgaW5zaWRlIGEgbmV3IHRyZWUgdGhhdCB3YXNuJ3QgYWxyZWFkeSB2aXNpYmxlLlxuLy9cbi8vIFRoZSBtYWluIHdheSB3ZSB1c2UgdGhpcyBjb25jZXB0IGlzIHRvIGRldGVybWluZSB3aGV0aGVyIHNob3dpbmcgYSBmYWxsYmFja1xuLy8gd291bGQgcmVzdWx0IGluIGEgZGVzaXJhYmxlIG9yIHVuZGVzaXJhYmxlIGxvYWRpbmcgc3RhdGUuIEFjdGl2aW5nIGEgZmFsbGJhY2tcbi8vIGluIHRoZSBzaGVsbCBpcyBjb25zaWRlcmVkIGFuIHVuZGVyc2lyYWJsZSBsb2FkaW5nIHN0YXRlLCBiZWNhdXNlIGl0IHdvdWxkXG4vLyBtZWFuIGhpZGluZyB2aXNpYmxlIChhbGJlaXQgc3RhbGUpIGNvbnRlbnQgaW4gdGhlIGN1cnJlbnQgdHJlZSDigJQgd2UgcHJlZmVyIHRvXG4vLyBzaG93IHRoZSBzdGFsZSBjb250ZW50LCByYXRoZXIgdGhhbiBzd2l0Y2ggdG8gYSBmYWxsYmFjay4gQnV0IHNob3dpbmcgYVxuLy8gZmFsbGJhY2sgaW4gYSBuZXcgdHJlZSBpcyBmaW5lLCBiZWNhdXNlIHRoZXJlJ3Mgbm8gc3RhbGUgY29udGVudCB0b1xuLy8gcHJlZmVyIGluc3RlYWQuXG5cbnZhciBzaGVsbEJvdW5kYXJ5ID0gbnVsbDtcbmZ1bmN0aW9uIGdldFNoZWxsQm91bmRhcnkoKSB7XG4gIHJldHVybiBzaGVsbEJvdW5kYXJ5O1xufVxuZnVuY3Rpb24gcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKGhhbmRsZXIpIHtcbiAgLy8gVE9ETzogUGFzcyBhcyBhcmd1bWVudFxuICB2YXIgY3VycmVudCA9IGhhbmRsZXIuYWx0ZXJuYXRlO1xuICAvLyBwcm9wYWdhdGVkIGEgc2luZ2xlIGxldmVsLiBGb3IgZXhhbXBsZSwgd2hlbiBGb3JjZVN1c3BlbnNlRmFsbGJhY2sgaXMgc2V0LFxuICAvLyBpdCBzaG91bGQgb25seSBmb3JjZSB0aGUgbmVhcmVzdCBTdXNwZW5zZSBib3VuZGFyeSBpbnRvIGZhbGxiYWNrIG1vZGUuXG5cbiAgcHVzaFN1c3BlbnNlTGlzdENvbnRleHQoaGFuZGxlciwgc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUxpc3RDb250ZXh0KHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCkpOyAvLyBFeHBlcmltZW50YWwgZmVhdHVyZTogU29tZSBTdXNwZW5zZSBib3VuZGFyaWVzIGFyZSBtYXJrZWQgYXMgaGF2aW5nIGFuXG4gIC8vIHRvIHB1c2ggYSBuZXN0ZWQgU3VzcGVuc2UgaGFuZGxlciwgYmVjYXVzZSBpdCB3aWxsIGdldCByZXBsYWNlZCBieSB0aGVcbiAgLy8gb3V0ZXIgZmFsbGJhY2ssIGFueXdheS4gQ29uc2lkZXIgdGhpcyBhcyBhIGZ1dHVyZSBvcHRpbWl6YXRpb24uXG5cblxuICBwdXNoKHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLCBoYW5kbGVyLCBoYW5kbGVyKTtcblxuICBpZiAoc2hlbGxCb3VuZGFyeSA9PT0gbnVsbCkge1xuICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGlzQ3VycmVudFRyZWVIaWRkZW4oKSkge1xuICAgICAgLy8gVGhpcyBib3VuZGFyeSBpcyBub3QgdmlzaWJsZSBpbiB0aGUgY3VycmVudCBVSS5cbiAgICAgIHNoZWxsQm91bmRhcnkgPSBoYW5kbGVyO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG4gICAgICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFRoaXMgYm91bmRhcnkgaXMgc2hvd2luZyBhIGZhbGxiYWNrIGluIHRoZSBjdXJyZW50IFVJLlxuICAgICAgICBzaGVsbEJvdW5kYXJ5ID0gaGFuZGxlcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHB1c2hGYWxsYmFja1RyZWVTdXNwZW5zZUhhbmRsZXIoZmliZXIpIHtcbiAgLy8gV2UncmUgYWJvdXQgdG8gcmVuZGVyIHRoZSBmYWxsYmFjay4gSWYgc29tZXRoaW5nIGluIHRoZSBmYWxsYmFjayBzdXNwZW5kcyxcbiAgLy8gaXQncyBha2luIHRvIHRocm93aW5nIGluc2lkZSBvZiBhIGBjYXRjaGAgYmxvY2suIFRoaXMgYm91bmRhcnkgc2hvdWxkIG5vdFxuICAvLyBjYXB0dXJlLiBSZXVzZSB0aGUgZXhpc3RpbmcgaGFuZGxlciBvbiB0aGUgc3RhY2suXG4gIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayhmaWJlcik7XG59XG5mdW5jdGlvbiBwdXNoT2Zmc2NyZWVuU3VzcGVuc2VIYW5kbGVyKGZpYmVyKSB7XG4gIGlmIChmaWJlci50YWcgPT09IE9mZnNjcmVlbkNvbXBvbmVudCkge1xuICAgIC8vIEEgU3VzcGVuc2VMaXN0IGNvbnRleHQgaXMgb25seSBwdXNoZWQgaGVyZSB0byBhdm9pZCBhIHB1c2gvcG9wIG1pc21hdGNoLlxuICAgIC8vIFJldXNlIHRoZSBjdXJyZW50IHZhbHVlIG9uIHRoZSBzdGFjay5cbiAgICAvLyBUT0RPOiBXZSBjYW4gYXZvaWQgbmVlZGluZyB0byBwdXNoIGhlcmUgYnkgYnkgZm9ya2luZyBwb3BTdXNwZW5zZUhhbmRsZXJcbiAgICAvLyBpbnRvIHNlcGFyYXRlIGZ1bmN0aW9ucyBmb3IgU3VzcGVuc2UgYW5kIE9mZnNjcmVlbi5cbiAgICBwdXNoU3VzcGVuc2VMaXN0Q29udGV4dChmaWJlciwgc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgICBwdXNoKHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLCBmaWJlciwgZmliZXIpO1xuXG4gICAgaWYgKHNoZWxsQm91bmRhcnkgIT09IG51bGwpIDsgZWxzZSB7XG4gICAgICB2YXIgY3VycmVudCA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgYm91bmRhcnkgaW4gdGhlIHN0YWNrIHRoYXQncyBhbHJlYWR5IHNob3dpbmdcbiAgICAgICAgICAvLyBhIGZhbGxiYWNrLiBTbyBldmVyeXRoaW5nIG91dHNpZGUgaXMgY29uc2lkZXJlZCB0aGUgc2hlbGwuXG4gICAgICAgICAgc2hlbGxCb3VuZGFyeSA9IGZpYmVyO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgYSBMZWdhY3lIaWRkZW4gY29tcG9uZW50LlxuICAgIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayhmaWJlcik7XG4gIH1cbn1cbmZ1bmN0aW9uIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayhmaWJlcikge1xuICBwdXNoU3VzcGVuc2VMaXN0Q29udGV4dChmaWJlciwgc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KTtcbiAgcHVzaChzdXNwZW5zZUhhbmRsZXJTdGFja0N1cnNvciwgZ2V0U3VzcGVuc2VIYW5kbGVyKCksIGZpYmVyKTtcbn1cbmZ1bmN0aW9uIGdldFN1c3BlbnNlSGFuZGxlcigpIHtcbiAgcmV0dXJuIHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLmN1cnJlbnQ7XG59XG5mdW5jdGlvbiBwb3BTdXNwZW5zZUhhbmRsZXIoZmliZXIpIHtcbiAgcG9wKHN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yLCBmaWJlcik7XG5cbiAgaWYgKHNoZWxsQm91bmRhcnkgPT09IGZpYmVyKSB7XG4gICAgLy8gUG9wcGluZyBiYWNrIGludG8gdGhlIHNoZWxsLlxuICAgIHNoZWxsQm91bmRhcnkgPSBudWxsO1xuICB9XG5cbiAgcG9wU3VzcGVuc2VMaXN0Q29udGV4dChmaWJlcik7XG59IC8vIFN1c3BlbnNlTGlzdCBjb250ZXh0XG4vLyBUT0RPOiBNb3ZlIHRvIGEgc2VwYXJhdGUgbW9kdWxlPyBXZSBtYXkgY2hhbmdlIHRoZSBTdXNwZW5zZUxpc3Rcbi8vIGltcGxlbWVudGF0aW9uIHRvIGhpZGUvc2hvdyBpbiB0aGUgY29tbWl0IHBoYXNlLCBhbnl3YXkuXG5cbnZhciBEZWZhdWx0U3VzcGVuc2VDb250ZXh0ID0gMDtcbnZhciBTdWJ0cmVlU3VzcGVuc2VDb250ZXh0TWFzayA9IDE7IC8vIEZvcmNlU3VzcGVuc2VGYWxsYmFjayBjYW4gYmUgdXNlZCBieSBTdXNwZW5zZUxpc3QgdG8gZm9yY2UgbmV3bHkgYWRkZWRcbi8vIGl0ZW1zIGludG8gdGhlaXIgZmFsbGJhY2sgc3RhdGUgZHVyaW5nIG9uZSBvZiB0aGUgcmVuZGVyIHBhc3Nlcy5cblxudmFyIEZvcmNlU3VzcGVuc2VGYWxsYmFjayA9IDI7XG52YXIgc3VzcGVuc2VTdGFja0N1cnNvciA9IGNyZWF0ZUN1cnNvcihEZWZhdWx0U3VzcGVuc2VDb250ZXh0KTtcbmZ1bmN0aW9uIGhhc1N1c3BlbnNlTGlzdENvbnRleHQocGFyZW50Q29udGV4dCwgZmxhZykge1xuICByZXR1cm4gKHBhcmVudENvbnRleHQgJiBmbGFnKSAhPT0gMDtcbn1cbmZ1bmN0aW9uIHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VMaXN0Q29udGV4dChwYXJlbnRDb250ZXh0KSB7XG4gIHJldHVybiBwYXJlbnRDb250ZXh0ICYgU3VidHJlZVN1c3BlbnNlQ29udGV4dE1hc2s7XG59XG5mdW5jdGlvbiBzZXRTaGFsbG93U3VzcGVuc2VMaXN0Q29udGV4dChwYXJlbnRDb250ZXh0LCBzaGFsbG93Q29udGV4dCkge1xuICByZXR1cm4gcGFyZW50Q29udGV4dCAmIFN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrIHwgc2hhbGxvd0NvbnRleHQ7XG59XG5mdW5jdGlvbiBwdXNoU3VzcGVuc2VMaXN0Q29udGV4dChmaWJlciwgbmV3Q29udGV4dCkge1xuICBwdXNoKHN1c3BlbnNlU3RhY2tDdXJzb3IsIG5ld0NvbnRleHQsIGZpYmVyKTtcbn1cbmZ1bmN0aW9uIHBvcFN1c3BlbnNlTGlzdENvbnRleHQoZmliZXIpIHtcbiAgcG9wKHN1c3BlbnNlU3RhY2tDdXJzb3IsIGZpYmVyKTtcbn1cblxuLy8gQSBub24tbnVsbCBTdXNwZW5zZVN0YXRlIG1lYW5zIHRoYXQgaXQgaXMgYmxvY2tlZCBmb3Igb25lIHJlYXNvbiBvciBhbm90aGVyLlxuLy8gLSBBIG5vbi1udWxsIGRlaHlkcmF0ZWQgZmllbGQgbWVhbnMgaXQncyBibG9ja2VkIHBlbmRpbmcgaHlkcmF0aW9uLlxuLy8gICAtIEEgbm9uLW51bGwgZGVoeWRyYXRlZCBmaWVsZCBjYW4gdXNlIGlzU3VzcGVuc2VJbnN0YW5jZVBlbmRpbmcgb3Jcbi8vICAgICBpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayB0byBxdWVyeSB0aGUgcmVhc29uIGZvciBiZWluZyBkZWh5ZHJhdGVkLlxuLy8gLSBBIG51bGwgZGVoeWRyYXRlZCBmaWVsZCBtZWFucyBpdCdzIGJsb2NrZWQgYnkgc29tZXRoaW5nIHN1c3BlbmRpbmcgYW5kXG4vLyAgIHdlJ3JlIGN1cnJlbnRseSBzaG93aW5nIGEgZmFsbGJhY2sgaW5zdGVhZC5cblxuZnVuY3Rpb24gZmluZEZpcnN0U3VzcGVuZGVkKHJvdykge1xuICB2YXIgbm9kZSA9IHJvdztcblxuICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAgIHZhciBzdGF0ZSA9IG5vZGUubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgaWYgKHN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBkZWh5ZHJhdGVkID0gc3RhdGUuZGVoeWRyYXRlZDtcblxuICAgICAgICBpZiAoZGVoeWRyYXRlZCA9PT0gbnVsbCB8fCBpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nKGRlaHlkcmF0ZWQpIHx8IGlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrKGRlaHlkcmF0ZWQpKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBTdXNwZW5zZUxpc3RDb21wb25lbnQgJiYgLy8gcmV2ZWFsT3JkZXIgdW5kZWZpbmVkIGNhbid0IGJlIHRydXN0ZWQgYmVjYXVzZSBpdCBkb24ndFxuICAgIC8vIGtlZXAgdHJhY2sgb2Ygd2hldGhlciBpdCBzdXNwZW5kZWQgb3Igbm90LlxuICAgIG5vZGUubWVtb2l6ZWRQcm9wcy5yZXZlYWxPcmRlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZGlkU3VzcGVuZCA9IChub2RlLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3MkMTtcblxuICAgICAgaWYgKGRpZFN1c3BlbmQpIHtcbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIGlmIChub2RlID09PSByb3cpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gcm93KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIE5vRmxhZ3MgPVxuLyogICAqL1xuMDsgLy8gUmVwcmVzZW50cyB3aGV0aGVyIGVmZmVjdCBzaG91bGQgZmlyZS5cblxudmFyIEhhc0VmZmVjdCA9XG4vKiAqL1xuMTsgLy8gUmVwcmVzZW50cyB0aGUgcGhhc2UgaW4gd2hpY2ggdGhlIGVmZmVjdCAobm90IHRoZSBjbGVhbi11cCkgZmlyZXMuXG5cbnZhciBJbnNlcnRpb24gPVxuLyogKi9cbjI7XG52YXIgTGF5b3V0ID1cbi8qICAgICovXG40O1xudmFyIFBhc3NpdmUgPVxuLyogICAqL1xuODtcblxudmFyIGRpZFdhcm5BYm91dE1pc21hdGNoZWRIb29rc0ZvckNvbXBvbmVudDtcbnZhciBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdDtcbnZhciBkaWRXYXJuQWJvdXRVc2VXcmFwcGVkSW5UcnlDYXRjaDtcbnZhciBkaWRXYXJuQWJvdXRBc3luY0NsaWVudENvbXBvbmVudDtcbnZhciBkaWRXYXJuQWJvdXRVc2VGb3JtU3RhdGU7XG5cbntcbiAgZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50ID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRVc2VXcmFwcGVkSW5UcnlDYXRjaCA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0QXN5bmNDbGllbnRDb21wb25lbnQgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dFVzZUZvcm1TdGF0ZSA9IG5ldyBTZXQoKTtcbn0gLy8gVGhlIGVmZmVjdCBcImluc3RhbmNlXCIgaXMgYSBzaGFyZWQgb2JqZWN0IHRoYXQgcmVtYWlucyB0aGUgc2FtZSBmb3IgdGhlIGVudGlyZVxuLy8gbGlmZXRpbWUgb2YgYW4gZWZmZWN0LiBJbiBSdXN0IHRlcm1zLCBhIFJlZkNlbGwuIFdlIHVzZSBpdCB0byBzdG9yZSB0aGVcbi8vIFwiZGVzdHJveVwiIGZ1bmN0aW9uIHRoYXQgaXMgcmV0dXJuZWQgZnJvbSBhbiBlZmZlY3QsIGJlY2F1c2UgdGhhdCBpcyBzdGF0ZWZ1bC5cbi8vIFRoZSBmaWVsZCBpcyBgdW5kZWZpbmVkYCBpZiB0aGUgZWZmZWN0IGlzIHVubW91bnRlZCwgb3IgaWYgdGhlIGVmZmVjdCByYW5cbi8vIGJ1dCBpcyBub3Qgc3RhdGVmdWwuIFdlIGRvbid0IGV4cGxpY2l0bHkgdHJhY2sgd2hldGhlciB0aGUgZWZmZWN0IGlzIG1vdW50ZWRcbi8vIG9yIHVubW91bnRlZCBiZWNhdXNlIHRoYXQgY2FuIGJlIGluZmVycmVkIGJ5IHRoZSBoaWRkZW5uZXNzIG9mIHRoZSBmaWJlciBpblxuLy8gdGhlIHRyZWUsIGkuZS4gd2hldGhlciB0aGVyZSBpcyBhIGhpZGRlbiBPZmZzY3JlZW4gZmliZXIgYWJvdmUgaXQuXG4vL1xuLy8gSXQncyB1bmZvcnR1bmF0ZSB0aGF0IHRoaXMgaXMgc3RvcmVkIG9uIGEgc2VwYXJhdGUgb2JqZWN0LCBiZWNhdXNlIGl0IGFkZHNcbi8vIG1vcmUgbWVtb3J5IHBlciBlZmZlY3QgaW5zdGFuY2UsIGJ1dCBpdCdzIGNvbmNlcHR1YWxseSBzb3VuZC4gSSB0aGluayB0aGVyZSdzXG4vLyBsaWtlbHkgYSBiZXR0ZXIgZGF0YSBzdHJ1Y3R1cmUgd2UgY291bGQgdXNlIGZvciBlZmZlY3RzOyBwZXJoYXBzIGp1c3Qgb25lXG4vLyBhcnJheSBvZiBlZmZlY3QgaW5zdGFuY2VzIHBlciBmaWJlci4gQnV0IEkgdGhpbmsgdGhpcyBpcyBPSyBmb3Igbm93IGRlc3BpdGVcbi8vIHRoZSBhZGRpdGlvbmFsIG1lbW9yeSBhbmQgd2UgY2FuIGZvbGxvdyB1cCB3aXRoIHBlcmZvcm1hbmNlXG4vLyBvcHRpbWl6YXRpb25zIGxhdGVyLlxuLy8gVGhlc2UgYXJlIHNldCByaWdodCBiZWZvcmUgY2FsbGluZyB0aGUgY29tcG9uZW50LlxuXG5cbnZhciByZW5kZXJMYW5lcyA9IE5vTGFuZXM7IC8vIFRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLiBJJ3ZlIG5hbWVkIGl0IGRpZmZlcmVudGx5IHRvIGRpc3Rpbmd1aXNoIGl0IGZyb21cbi8vIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2suXG5cbnZhciBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gbnVsbDsgLy8gSG9va3MgYXJlIHN0b3JlZCBhcyBhIGxpbmtlZCBsaXN0IG9uIHRoZSBmaWJlcidzIG1lbW9pemVkU3RhdGUgZmllbGQuIFRoZVxuLy8gY3VycmVudCBob29rIGxpc3QgaXMgdGhlIGxpc3QgdGhhdCBiZWxvbmdzIHRvIHRoZSBjdXJyZW50IGZpYmVyLiBUaGVcbi8vIHdvcmstaW4tcHJvZ3Jlc3MgaG9vayBsaXN0IGlzIGEgbmV3IGxpc3QgdGhhdCB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuLy8gd29yay1pbi1wcm9ncmVzcyBmaWJlci5cblxudmFyIGN1cnJlbnRIb29rID0gbnVsbDtcbnZhciB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsOyAvLyBXaGV0aGVyIGFuIHVwZGF0ZSB3YXMgc2NoZWR1bGVkIGF0IGFueSBwb2ludCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS4gVGhpc1xuLy8gZG9lcyBub3QgZ2V0IHJlc2V0IGlmIHdlIGRvIGFub3RoZXIgcmVuZGVyIHBhc3M7IG9ubHkgd2hlbiB3ZSdyZSBjb21wbGV0ZWx5XG4vLyBmaW5pc2hlZCBldmFsdWF0aW5nIHRoaXMgY29tcG9uZW50LiBUaGlzIGlzIGFuIG9wdGltaXphdGlvbiBzbyB3ZSBrbm93XG4vLyB3aGV0aGVyIHdlIG5lZWQgdG8gY2xlYXIgcmVuZGVyIHBoYXNlIHVwZGF0ZXMgYWZ0ZXIgYSB0aHJvdy5cblxudmFyIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTsgLy8gV2hlcmUgYW4gdXBkYXRlIHdhcyBzY2hlZHVsZWQgb25seSBkdXJpbmcgdGhlIGN1cnJlbnQgcmVuZGVyIHBhc3MuIFRoaXNcbi8vIGdldHMgcmVzZXQgYWZ0ZXIgZWFjaCBhdHRlbXB0LlxuLy8gVE9ETzogTWF5YmUgdGhlcmUncyBzb21lIHdheSB0byBjb25zb2xpZGF0ZSB0aGlzIHdpdGhcbi8vIGBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlYC4gT3Igd2l0aCBgbnVtYmVyT2ZSZVJlbmRlcnNgLlxuXG52YXIgZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZUR1cmluZ1RoaXNQYXNzID0gZmFsc2U7XG52YXIgc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYgPSBmYWxzZTsgLy8gQ291bnRzIHRoZSBudW1iZXIgb2YgdXNlSWQgaG9va3MgaW4gdGhpcyBjb21wb25lbnQuXG5cbnZhciBsb2NhbElkQ291bnRlciA9IDA7IC8vIENvdW50cyBudW1iZXIgb2YgYHVzZWAtZCB0aGVuYWJsZXNcblxudmFyIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMDtcbnZhciB0aGVuYWJsZVN0YXRlID0gbnVsbDsgLy8gVXNlZCBmb3IgaWRzIHRoYXQgYXJlIGdlbmVyYXRlZCBjb21wbGV0ZWx5IGNsaWVudC1zaWRlIChpLmUuIG5vdCBkdXJpbmdcbi8vIGh5ZHJhdGlvbikuIFRoaXMgY291bnRlciBpcyBnbG9iYWwsIHNvIGNsaWVudCBpZHMgYXJlIG5vdCBzdGFibGUgYWNyb3NzXG4vLyByZW5kZXIgYXR0ZW1wdHMuXG5cbnZhciBnbG9iYWxDbGllbnRJZENvdW50ZXIgPSAwO1xudmFyIFJFX1JFTkRFUl9MSU1JVCA9IDI1OyAvLyBJbiBERVYsIHRoaXMgaXMgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnRseSBleGVjdXRpbmcgcHJpbWl0aXZlIGhvb2tcblxudmFyIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gbnVsbDsgLy8gSW4gREVWLCB0aGlzIGxpc3QgZW5zdXJlcyB0aGF0IGhvb2tzIGFyZSBjYWxsZWQgaW4gdGhlIHNhbWUgb3JkZXIgYmV0d2VlbiByZW5kZXJzLlxuLy8gVGhlIGxpc3Qgc3RvcmVzIHRoZSBvcmRlciBvZiBob29rcyB1c2VkIGR1cmluZyB0aGUgaW5pdGlhbCByZW5kZXIgKG1vdW50KS5cbi8vIFN1YnNlcXVlbnQgcmVuZGVycyAodXBkYXRlcykgcmVmZXJlbmNlIHRoaXMgbGlzdC5cblxudmFyIGhvb2tUeXBlc0RldiA9IG51bGw7XG52YXIgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTsgLy8gSW4gREVWLCB0aGlzIHRyYWNrcyB3aGV0aGVyIGN1cnJlbnRseSByZW5kZXJpbmcgY29tcG9uZW50IG5lZWRzIHRvIGlnbm9yZVxuLy8gdGhlIGRlcGVuZGVuY2llcyBmb3IgSG9va3MgdGhhdCBuZWVkIHRoZW0gKGUuZy4gdXNlRWZmZWN0IG9yIHVzZU1lbW8pLlxuLy8gV2hlbiB0cnVlLCBzdWNoIEhvb2tzIHdpbGwgYWx3YXlzIGJlIFwicmVtb3VudGVkXCIuIE9ubHkgdXNlZCBkdXJpbmcgaG90IHJlbG9hZC5cblxudmFyIGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzID0gZmFsc2U7XG5cbmZ1bmN0aW9uIG1vdW50SG9va1R5cGVzRGV2KCkge1xuICB7XG4gICAgdmFyIGhvb2tOYW1lID0gY3VycmVudEhvb2tOYW1lSW5EZXY7XG5cbiAgICBpZiAoaG9va1R5cGVzRGV2ID09PSBudWxsKSB7XG4gICAgICBob29rVHlwZXNEZXYgPSBbaG9va05hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBob29rVHlwZXNEZXYucHVzaChob29rTmFtZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvb2tUeXBlc0RldigpIHtcbiAge1xuICAgIHZhciBob29rTmFtZSA9IGN1cnJlbnRIb29rTmFtZUluRGV2O1xuXG4gICAgaWYgKGhvb2tUeXBlc0RldiAhPT0gbnVsbCkge1xuICAgICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYrKztcblxuICAgICAgaWYgKGhvb2tUeXBlc0Rldltob29rVHlwZXNVcGRhdGVJbmRleERldl0gIT09IGhvb2tOYW1lKSB7XG4gICAgICAgIHdhcm5Pbkhvb2tNaXNtYXRjaEluRGV2KGhvb2tOYW1lKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcykge1xuICB7XG4gICAgaWYgKGRlcHMgIT09IHVuZGVmaW5lZCAmJiBkZXBzICE9PSBudWxsICYmICFpc0FycmF5KGRlcHMpKSB7XG4gICAgICAvLyBWZXJpZnkgZGVwcywgYnV0IG9ubHkgb24gbW91bnQgdG8gYXZvaWQgZXh0cmEgY2hlY2tzLlxuICAgICAgLy8gSXQncyB1bmxpa2VseSB0aGVpciB0eXBlIHdvdWxkIGNoYW5nZSBhcyB1c3VhbGx5IHlvdSBkZWZpbmUgdGhlbSBpbmxpbmUuXG4gICAgICBlcnJvcignJXMgcmVjZWl2ZWQgYSBmaW5hbCBhcmd1bWVudCB0aGF0IGlzIG5vdCBhbiBhcnJheSAoaW5zdGVhZCwgcmVjZWl2ZWQgYCVzYCkuIFdoZW4gJyArICdzcGVjaWZpZWQsIHRoZSBmaW5hbCBhcmd1bWVudCBtdXN0IGJlIGFuIGFycmF5LicsIGN1cnJlbnRIb29rTmFtZUluRGV2LCB0eXBlb2YgZGVwcyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5Pbkhvb2tNaXNtYXRjaEluRGV2KGN1cnJlbnRIb29rTmFtZSkge1xuICB7XG4gICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEpO1xuXG4gICAgaWYgKCFkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICBkaWRXYXJuQWJvdXRNaXNtYXRjaGVkSG9va3NGb3JDb21wb25lbnQuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICBpZiAoaG9va1R5cGVzRGV2ICE9PSBudWxsKSB7XG4gICAgICAgIHZhciB0YWJsZSA9ICcnO1xuICAgICAgICB2YXIgc2Vjb25kQ29sdW1uU3RhcnQgPSAzMDtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBob29rVHlwZXNVcGRhdGVJbmRleERldjsgaSsrKSB7XG4gICAgICAgICAgdmFyIG9sZEhvb2tOYW1lID0gaG9va1R5cGVzRGV2W2ldO1xuICAgICAgICAgIHZhciBuZXdIb29rTmFtZSA9IGkgPT09IGhvb2tUeXBlc1VwZGF0ZUluZGV4RGV2ID8gY3VycmVudEhvb2tOYW1lIDogb2xkSG9va05hbWU7XG4gICAgICAgICAgdmFyIHJvdyA9IGkgKyAxICsgXCIuIFwiICsgb2xkSG9va05hbWU7IC8vIEV4dHJhIHNwYWNlIHNvIHNlY29uZCBjb2x1bW4gbGluZXMgdXBcbiAgICAgICAgICAvLyBsb2wgQCBJRSBub3Qgc3VwcG9ydGluZyBTdHJpbmcjcmVwZWF0XG5cbiAgICAgICAgICB3aGlsZSAocm93Lmxlbmd0aCA8IHNlY29uZENvbHVtblN0YXJ0KSB7XG4gICAgICAgICAgICByb3cgKz0gJyAnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJvdyArPSBuZXdIb29rTmFtZSArICdcXG4nO1xuICAgICAgICAgIHRhYmxlICs9IHJvdztcbiAgICAgICAgfVxuXG4gICAgICAgIGVycm9yKCdSZWFjdCBoYXMgZGV0ZWN0ZWQgYSBjaGFuZ2UgaW4gdGhlIG9yZGVyIG9mIEhvb2tzIGNhbGxlZCBieSAlcy4gJyArICdUaGlzIHdpbGwgbGVhZCB0byBidWdzIGFuZCBlcnJvcnMgaWYgbm90IGZpeGVkLiAnICsgJ0ZvciBtb3JlIGluZm9ybWF0aW9uLCByZWFkIHRoZSBSdWxlcyBvZiBIb29rczogaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9ydWxlcy1vZi1ob29rc1xcblxcbicgKyAnICAgUHJldmlvdXMgcmVuZGVyICAgICAgICAgICAgTmV4dCByZW5kZXJcXG4nICsgJyAgIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxcbicgKyAnJXMnICsgJyAgIF5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXl5eXlxcbicsIGNvbXBvbmVudE5hbWUsIHRhYmxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uVXNlRm9ybVN0YXRlSW5EZXYoKSB7XG4gIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSk7XG5cbiAgICBpZiAoIWRpZFdhcm5BYm91dFVzZUZvcm1TdGF0ZS5oYXMoY29tcG9uZW50TmFtZSkpIHtcbiAgICAgIGRpZFdhcm5BYm91dFVzZUZvcm1TdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgIGVycm9yKCdSZWFjdERPTS51c2VGb3JtU3RhdGUgaGFzIGJlZW4gcmVuYW1lZCB0byBSZWFjdC51c2VBY3Rpb25TdGF0ZS4gJyArICdQbGVhc2UgdXBkYXRlICVzIHRvIHVzZSBSZWFjdC51c2VBY3Rpb25TdGF0ZS4nLCBjb21wb25lbnROYW1lKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2FybklmQXN5bmNDbGllbnRDb21wb25lbnQoQ29tcG9uZW50KSB7XG4gIHtcbiAgICAvLyBUaGlzIGRldi1vbmx5IGNoZWNrIG9ubHkgd29ya3MgZm9yIGRldGVjdGluZyBuYXRpdmUgYXN5bmMgZnVuY3Rpb25zLFxuICAgIC8vIG5vdCB0cmFuc3BpbGVkIG9uZXMuIFRoZXJlJ3MgYWxzbyBhIHByb2QgY2hlY2sgdGhhdCB3ZSB1c2UgdG8gcHJldmVudFxuICAgIC8vIGFzeW5jIGNsaWVudCBjb21wb25lbnRzIGZyb20gY3Jhc2hpbmcgdGhlIGFwcDsgdGhlIHByb2Qgb25lIHdvcmtzIGV2ZW5cbiAgICAvLyBmb3IgdHJhbnNwaWxlZCBhc3luYyBmdW5jdGlvbnMuIE5laXRoZXIgbWVjaGFuaXNtIGlzIGNvbXBsZXRlbHlcbiAgICAvLyBidWxsZXRwcm9vZiBidXQgdG9nZXRoZXIgdGhleSBjb3ZlciB0aGUgbW9zdCBjb21tb24gY2FzZXMuXG4gICAgdmFyIGlzQXN5bmNGdW5jdGlvbiA9IC8vICRGbG93SWdub3JlW21ldGhvZC11bmJpbmRpbmddXG4gICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKENvbXBvbmVudCkgPT09ICdbb2JqZWN0IEFzeW5jRnVuY3Rpb25dJyB8fCAvLyAkRmxvd0lnbm9yZVttZXRob2QtdW5iaW5kaW5nXVxuICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChDb21wb25lbnQpID09PSAnW29iamVjdCBBc3luY0dlbmVyYXRvckZ1bmN0aW9uXSc7XG5cbiAgICBpZiAoaXNBc3luY0Z1bmN0aW9uKSB7XG4gICAgICAvLyBFbmNvdW50ZXJlZCBhbiBhc3luYyBDbGllbnQgQ29tcG9uZW50LiBUaGlzIGlzIG5vdCB5ZXQgc3VwcG9ydGVkLlxuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEFzeW5jQ2xpZW50Q29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRBc3luY0NsaWVudENvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZXJyb3IoJ2FzeW5jL2F3YWl0IGlzIG5vdCB5ZXQgc3VwcG9ydGVkIGluIENsaWVudCBDb21wb25lbnRzLCBvbmx5ICcgKyAnU2VydmVyIENvbXBvbmVudHMuIFRoaXMgZXJyb3IgaXMgb2Z0ZW4gY2F1c2VkIGJ5IGFjY2lkZW50YWxseSAnICsgXCJhZGRpbmcgYCd1c2UgY2xpZW50J2AgdG8gYSBtb2R1bGUgdGhhdCB3YXMgb3JpZ2luYWxseSB3cml0dGVuIFwiICsgJ2ZvciB0aGUgc2VydmVyLicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB0aHJvd0ludmFsaWRIb29rRXJyb3IoKSB7XG4gIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBob29rIGNhbGwuIEhvb2tzIGNhbiBvbmx5IGJlIGNhbGxlZCBpbnNpZGUgb2YgdGhlIGJvZHkgb2YgYSBmdW5jdGlvbiBjb21wb25lbnQuIFRoaXMgY291bGQgaGFwcGVuIGZvcicgKyAnIG9uZSBvZiB0aGUgZm9sbG93aW5nIHJlYXNvbnM6XFxuJyArICcxLiBZb3UgbWlnaHQgaGF2ZSBtaXNtYXRjaGluZyB2ZXJzaW9ucyBvZiBSZWFjdCBhbmQgdGhlIHJlbmRlcmVyIChzdWNoIGFzIFJlYWN0IERPTSlcXG4nICsgJzIuIFlvdSBtaWdodCBiZSBicmVha2luZyB0aGUgUnVsZXMgb2YgSG9va3NcXG4nICsgJzMuIFlvdSBtaWdodCBoYXZlIG1vcmUgdGhhbiBvbmUgY29weSBvZiBSZWFjdCBpbiB0aGUgc2FtZSBhcHBcXG4nICsgJ1NlZSBodHRwczovL3JlYWN0LmRldi9saW5rL2ludmFsaWQtaG9vay1jYWxsIGZvciB0aXBzIGFib3V0IGhvdyB0byBkZWJ1ZyBhbmQgZml4IHRoaXMgcHJvYmxlbS4nKTtcbn1cblxuZnVuY3Rpb24gYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykge1xuICB7XG4gICAgaWYgKGlnbm9yZVByZXZpb3VzRGVwZW5kZW5jaWVzKSB7XG4gICAgICAvLyBPbmx5IHRydWUgd2hlbiB0aGlzIGNvbXBvbmVudCBpcyBiZWluZyBob3QgcmVsb2FkZWQuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgaWYgKHByZXZEZXBzID09PSBudWxsKSB7XG4gICAge1xuICAgICAgZXJyb3IoJyVzIHJlY2VpdmVkIGEgZmluYWwgYXJndW1lbnQgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgbm90IGR1cmluZyAnICsgJ3RoZSBwcmV2aW91cyByZW5kZXIuIEV2ZW4gdGhvdWdoIHRoZSBmaW5hbCBhcmd1bWVudCBpcyBvcHRpb25hbCwgJyArICdpdHMgdHlwZSBjYW5ub3QgY2hhbmdlIGJldHdlZW4gcmVuZGVycy4nLCBjdXJyZW50SG9va05hbWVJbkRldik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAge1xuICAgIC8vIERvbid0IGJvdGhlciBjb21wYXJpbmcgbGVuZ3RocyBpbiBwcm9kIGJlY2F1c2UgdGhlc2UgYXJyYXlzIHNob3VsZCBiZVxuICAgIC8vIHBhc3NlZCBpbmxpbmUuXG4gICAgaWYgKG5leHREZXBzLmxlbmd0aCAhPT0gcHJldkRlcHMubGVuZ3RoKSB7XG4gICAgICBlcnJvcignVGhlIGZpbmFsIGFyZ3VtZW50IHBhc3NlZCB0byAlcyBjaGFuZ2VkIHNpemUgYmV0d2VlbiByZW5kZXJzLiBUaGUgJyArICdvcmRlciBhbmQgc2l6ZSBvZiB0aGlzIGFycmF5IG11c3QgcmVtYWluIGNvbnN0YW50LlxcblxcbicgKyAnUHJldmlvdXM6ICVzXFxuJyArICdJbmNvbWluZzogJXMnLCBjdXJyZW50SG9va05hbWVJbkRldiwgXCJbXCIgKyBwcmV2RGVwcy5qb2luKCcsICcpICsgXCJdXCIsIFwiW1wiICsgbmV4dERlcHMuam9pbignLCAnKSArIFwiXVwiKTtcbiAgICB9XG4gIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXZEZXBzLmxlbmd0aCAmJiBpIDwgbmV4dERlcHMubGVuZ3RoOyBpKyspIHtcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICBpZiAob2JqZWN0SXMobmV4dERlcHNbaV0sIHByZXZEZXBzW2ldKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlbmRlcldpdGhIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBwcm9wcywgc2Vjb25kQXJnLCBuZXh0UmVuZGVyTGFuZXMpIHtcbiAgcmVuZGVyTGFuZXMgPSBuZXh0UmVuZGVyTGFuZXM7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSB3b3JrSW5Qcm9ncmVzcztcblxuICB7XG4gICAgaG9va1R5cGVzRGV2ID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQuX2RlYnVnSG9va1R5cGVzIDogbnVsbDtcbiAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xOyAvLyBVc2VkIGZvciBob3QgcmVsb2FkaW5nOlxuXG4gICAgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPSBjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICB3YXJuSWZBc3luY0NsaWVudENvbXBvbmVudChDb21wb25lbnQpO1xuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBOb0xhbmVzOyAvLyBUaGUgZm9sbG93aW5nIHNob3VsZCBoYXZlIGFscmVhZHkgYmVlbiByZXNldFxuICAvLyBjdXJyZW50SG9vayA9IG51bGw7XG4gIC8vIHdvcmtJblByb2dyZXNzSG9vayA9IG51bGw7XG4gIC8vIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbiAgLy8gbG9jYWxJZENvdW50ZXIgPSAwO1xuICAvLyB0aGVuYWJsZUluZGV4Q291bnRlciA9IDA7XG4gIC8vIHRoZW5hYmxlU3RhdGUgPSBudWxsO1xuICAvLyBUT0RPIFdhcm4gaWYgbm8gaG9va3MgYXJlIHVzZWQgYXQgYWxsIGR1cmluZyBtb3VudCwgdGhlbiBzb21lIGFyZSB1c2VkIGR1cmluZyB1cGRhdGUuXG4gIC8vIEN1cnJlbnRseSB3ZSB3aWxsIGlkZW50aWZ5IHRoZSB1cGRhdGUgcmVuZGVyIGFzIGEgbW91bnQgYmVjYXVzZSBtZW1vaXplZFN0YXRlID09PSBudWxsLlxuICAvLyBUaGlzIGlzIHRyaWNreSBiZWNhdXNlIGl0J3MgdmFsaWQgZm9yIGNlcnRhaW4gdHlwZXMgb2YgY29tcG9uZW50cyAoZS5nLiBSZWFjdC5sYXp5KVxuICAvLyBVc2luZyBtZW1vaXplZFN0YXRlIHRvIGRpZmZlcmVudGlhdGUgYmV0d2VlbiBtb3VudC91cGRhdGUgb25seSB3b3JrcyBpZiBhdCBsZWFzdCBvbmUgc3RhdGVmdWwgaG9vayBpcyB1c2VkLlxuICAvLyBOb24tc3RhdGVmdWwgaG9va3MgKGUuZy4gY29udGV4dCkgZG9uJ3QgZ2V0IGFkZGVkIHRvIG1lbW9pemVkU3RhdGUsXG4gIC8vIHNvIG1lbW9pemVkU3RhdGUgd291bGQgYmUgbnVsbCBkdXJpbmcgdXBkYXRlcyBhbmQgbW91bnRzLlxuXG4gIHtcbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50Lm1lbW9pemVkU3RhdGUgIT09IG51bGwpIHtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuICAgIH0gZWxzZSBpZiAoaG9va1R5cGVzRGV2ICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGRpc3BhdGNoZXIgaGFuZGxlcyBhbiBlZGdlIGNhc2Ugd2hlcmUgYSBjb21wb25lbnQgaXMgdXBkYXRpbmcsXG4gICAgICAvLyBidXQgbm8gc3RhdGVmdWwgaG9va3MgaGF2ZSBiZWVuIHVzZWQuXG4gICAgICAvLyBXZSB3YW50IHRvIG1hdGNoIHRoZSBwcm9kdWN0aW9uIGNvZGUgYmVoYXZpb3IgKHdoaWNoIHdpbGwgdXNlIEhvb2tzRGlzcGF0Y2hlck9uTW91bnQpLFxuICAgICAgLy8gYnV0IHdpdGggdGhlIGV4dHJhIERFViB2YWxpZGF0aW9uIHRvIGVuc3VyZSBob29rcyBvcmRlcmluZyBoYXNuJ3QgY2hhbmdlZC5cbiAgICAgIC8vIFRoaXMgZGlzcGF0Y2hlciBkb2VzIHRoYXQuXG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFVjtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcbiAgICB9XG4gIH0gLy8gSW4gU3RyaWN0IE1vZGUsIGR1cmluZyBkZXZlbG9wbWVudCwgdXNlciBmdW5jdGlvbnMgYXJlIGRvdWJsZSBpbnZva2VkIHRvXG4gIC8vIGhlbHAgZGV0ZWN0IHNpZGUgZWZmZWN0cy4gVGhlIGxvZ2ljIGZvciBob3cgdGhpcyBpcyBpbXBsZW1lbnRlZCBmb3IgaW5cbiAgLy8gaG9vayBjb21wb25lbnRzIGlzIGEgYml0IGNvbXBsZXggc28gbGV0J3MgYnJlYWsgaXQgZG93bi5cbiAgLy9cbiAgLy8gV2Ugd2lsbCBpbnZva2UgdGhlIGVudGlyZSBjb21wb25lbnQgZnVuY3Rpb24gdHdpY2UuIEhvd2V2ZXIsIGR1cmluZyB0aGVcbiAgLy8gc2Vjb25kIGludm9jYXRpb24gb2YgdGhlIGNvbXBvbmVudCwgdGhlIGhvb2sgc3RhdGUgZnJvbSB0aGUgZmlyc3RcbiAgLy8gaW52b2NhdGlvbiB3aWxsIGJlIHJldXNlZC4gVGhhdCBtZWFucyB0aGluZ3MgbGlrZSBgdXNlTWVtb2AgZnVuY3Rpb25zIHdvbid0XG4gIC8vIHJ1biBhZ2FpbiwgYmVjYXVzZSB0aGUgZGVwcyB3aWxsIG1hdGNoIGFuZCB0aGUgbWVtb2l6ZWQgcmVzdWx0IHdpbGxcbiAgLy8gYmUgcmV1c2VkLlxuICAvL1xuICAvLyBXZSB3YW50IG1lbW9pemVkIGZ1bmN0aW9ucyB0byBydW4gdHdpY2UsIHRvbywgc28gYWNjb3VudCBmb3IgdGhpcywgdXNlclxuICAvLyBmdW5jdGlvbnMgYXJlIGRvdWJsZSBpbnZva2VkIGR1cmluZyB0aGUgKmZpcnN0KiBpbnZvY2F0aW9uIG9mIHRoZSBjb21wb25lbnRcbiAgLy8gZnVuY3Rpb24sIGFuZCBhcmUgKm5vdCogZG91YmxlIGludm9rZWQgZHVyaW5nIHRoZSBzZWNvbmQgaW5jb3ZhdGlvbjpcbiAgLy9cbiAgLy8gLSBGaXJzdCBleGVjdXRpb24gb2YgY29tcG9uZW50IGZ1bmN0aW9uOiB1c2VyIGZ1bmN0aW9ucyBhcmUgZG91YmxlIGludm9rZWRcbiAgLy8gLSBTZWNvbmQgZXhlY3V0aW9uIG9mIGNvbXBvbmVudCBmdW5jdGlvbiAoaW4gU3RyaWN0IE1vZGUsIGR1cmluZ1xuICAvLyAgIGRldmVsb3BtZW50KTogdXNlciBmdW5jdGlvbnMgYXJlIG5vdCBkb3VibGUgaW52b2tlZC5cbiAgLy9cbiAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbCBmb3IgYSBmZXcgcmVhc29uczsgbW9zdCBpbXBvcnRhbnRseSwgaXQncyBiZWNhdXNlIG9mXG4gIC8vIGhvdyBgdXNlYCB3b3JrcyB3aGVuIHNvbWV0aGluZyBzdXNwZW5kczogaXQgcmV1c2VzIHRoZSBwcm9taXNlIHRoYXQgd2FzXG4gIC8vIHBhc3NlZCBkdXJpbmcgdGhlIGZpcnN0IGF0dGVtcHQuIFRoaXMgaXMgaXRzZWxmIGEgZm9ybSBvZiBtZW1vaXphdGlvbi5cbiAgLy8gV2UgbmVlZCB0byBiZSBhYmxlIHRvIG1lbW9pemUgdGhlIHJlYWN0aXZlIGlucHV0cyB0byB0aGUgYHVzZWAgY2FsbCB1c2luZ1xuICAvLyBhIGhvb2sgKGkuZS4gYHVzZU1lbW9gKSwgd2hpY2ggbWVhbnMsIHRoZSByZWFjdGl2ZSBpbnB1dHMgdG8gYHVzZWAgbXVzdFxuICAvLyBjb21lIGZyb20gdGhlIHNhbWUgY29tcG9uZW50IGludm9jYXRpb24gYXMgdGhlIG91dHB1dC5cbiAgLy9cbiAgLy8gVGhlcmUgYXJlIHBsZW50eSBvZiB0ZXN0cyB0byBlbnN1cmUgdGhpcyBiZWhhdmlvciBpcyBjb3JyZWN0LlxuXG5cbiAgdmFyIHNob3VsZERvdWJsZVJlbmRlckRFViA9ICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkgIT09IE5vTW9kZTtcbiAgc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYgPSBzaG91bGREb3VibGVSZW5kZXJERVY7XG4gIHZhciBjaGlsZHJlbiA9IENvbXBvbmVudChwcm9wcywgc2Vjb25kQXJnKTtcbiAgc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYgPSBmYWxzZTsgLy8gQ2hlY2sgaWYgdGhlcmUgd2FzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZVxuXG4gIGlmIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MpIHtcbiAgICAvLyBLZWVwIHJlbmRlcmluZyB1bnRpbCB0aGUgY29tcG9uZW50IHN0YWJpbGl6ZXMgKHRoZXJlIGFyZSBubyBtb3JlIHJlbmRlclxuICAgIC8vIHBoYXNlIHVwZGF0ZXMpLlxuICAgIGNoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzQWdhaW4od29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZyk7XG4gIH1cblxuICBpZiAoc2hvdWxkRG91YmxlUmVuZGVyREVWKSB7XG4gICAgLy8gSW4gZGV2ZWxvcG1lbnQsIGNvbXBvbmVudHMgYXJlIGludm9rZWQgdHdpY2UgdG8gaGVscCBkZXRlY3Qgc2lkZSBlZmZlY3RzLlxuICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGNoaWxkcmVuID0gcmVuZGVyV2l0aEhvb2tzQWdhaW4od29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBmaW5pc2hSZW5kZXJpbmdIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gZmluaXNoUmVuZGVyaW5nSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCkge1xuICB7XG4gICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnSG9va1R5cGVzID0gaG9va1R5cGVzRGV2O1xuICB9IC8vIFdlIGNhbiBhc3N1bWUgdGhlIHByZXZpb3VzIGRpc3BhdGNoZXIgaXMgYWx3YXlzIHRoaXMgb25lLCBzaW5jZSB3ZSBzZXQgaXRcbiAgLy8gYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgcmVuZGVyIHBoYXNlIGFuZCB0aGVyZSdzIG5vIHJlLWVudHJhbmNlLlxuXG5cbiAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IENvbnRleHRPbmx5RGlzcGF0Y2hlcjsgLy8gVGhpcyBjaGVjayB1c2VzIGN1cnJlbnRIb29rIHNvIHRoYXQgaXQgd29ya3MgdGhlIHNhbWUgaW4gREVWIGFuZCBwcm9kIGJ1bmRsZXMuXG4gIC8vIGhvb2tUeXBlc0RldiBjb3VsZCBjYXRjaCBtb3JlIGNhc2VzIChlLmcuIGNvbnRleHQpIGJ1dCBvbmx5IGluIERFViBidW5kbGVzLlxuXG4gIHZhciBkaWRSZW5kZXJUb29GZXdIb29rcyA9IGN1cnJlbnRIb29rICE9PSBudWxsICYmIGN1cnJlbnRIb29rLm5leHQgIT09IG51bGw7XG4gIHJlbmRlckxhbmVzID0gTm9MYW5lcztcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IG51bGw7XG4gIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxuICB7XG4gICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSBudWxsO1xuICAgIGhvb2tUeXBlc0RldiA9IG51bGw7XG4gICAgaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYgPSAtMTsgLy8gQ29uZmlybSB0aGF0IGEgc3RhdGljIGZsYWcgd2FzIG5vdCBhZGRlZCBvciByZW1vdmVkIHNpbmNlIHRoZSBsYXN0XG4gICAgLy8gcmVuZGVyLiBJZiB0aGlzIGZpcmVzLCBpdCBzdWdnZXN0cyB0aGF0IHdlIGluY29ycmVjdGx5IHJlc2V0IHRoZSBzdGF0aWNcbiAgICAvLyBmbGFncyBpbiBzb21lIG90aGVyIHBhcnQgb2YgdGhlIGNvZGViYXNlLiBUaGlzIGhhcyBoYXBwZW5lZCBiZWZvcmUsIGZvclxuICAgIC8vIGV4YW1wbGUsIGluIHRoZSBTdXNwZW5zZUxpc3QgaW1wbGVtZW50YXRpb24uXG5cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiAoY3VycmVudC5mbGFncyAmIFN0YXRpY01hc2spICE9PSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBTdGF0aWNNYXNrKSAmJiAoIC8vIERpc2FibGUgdGhpcyB3YXJuaW5nIGluIGxlZ2FjeSBtb2RlLCBiZWNhdXNlIGxlZ2FjeSBTdXNwZW5zZSBpcyB3ZWlyZFxuICAgIC8vIGFuZCBjcmVhdGVzIGZhbHNlIHBvc2l0aXZlcy4gVG8gbWFrZSB0aGlzIHdvcmsgaW4gbGVnYWN5IG1vZGUsIHdlJ2RcbiAgICAvLyBuZWVkIHRvIG1hcmsgZmliZXJzIHRoYXQgY29tbWl0IGluIGFuIGluY29tcGxldGUgc3RhdGUsIHNvbWVob3cuIEZvclxuICAgIC8vIG5vdyBJJ2xsIGRpc2FibGUgdGhlIHdhcm5pbmcgdGhhdCBtb3N0IG9mIHRoZSBidWdzIHRoYXQgd291bGQgdHJpZ2dlclxuICAgIC8vIGl0IGFyZSBlaXRoZXIgZXhjbHVzaXZlIHRvIGNvbmN1cnJlbnQgbW9kZSBvciBleGlzdCBpbiBib3RoLlxuICAgIGRpc2FibGVMZWdhY3lNb2RlICkpIHtcbiAgICAgIGVycm9yKCdJbnRlcm5hbCBSZWFjdCBlcnJvcjogRXhwZWN0ZWQgc3RhdGljIGZsYWcgd2FzIG1pc3NpbmcuIFBsZWFzZSAnICsgJ25vdGlmeSB0aGUgUmVhY3QgdGVhbS4nKTtcbiAgICB9XG4gIH1cblxuICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlID0gZmFsc2U7IC8vIFRoaXMgaXMgcmVzZXQgYnkgY2hlY2tEaWRSZW5kZXJJZEhvb2tcbiAgLy8gbG9jYWxJZENvdW50ZXIgPSAwO1xuXG4gIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMDtcbiAgdGhlbmFibGVTdGF0ZSA9IG51bGw7XG5cbiAgaWYgKGRpZFJlbmRlclRvb0Zld0hvb2tzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSZW5kZXJlZCBmZXdlciBob29rcyB0aGFuIGV4cGVjdGVkLiBUaGlzIG1heSBiZSBjYXVzZWQgYnkgYW4gYWNjaWRlbnRhbCAnICsgJ2Vhcmx5IHJldHVybiBzdGF0ZW1lbnQuJyk7XG4gIH1cblxuICB7XG4gICAgaWYgKGNoZWNrSWZVc2VXcmFwcGVkSW5UcnlDYXRjaCgpKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpIHx8ICdVbmtub3duJztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVc2VXcmFwcGVkSW5UcnlDYXRjaC5oYXMoY29tcG9uZW50TmFtZSkgJiYgLy8gVGhpcyB3YXJuaW5nIGFsc28gZmlyZXMgaWYgeW91IHN1c3BlbmQgd2l0aCBgdXNlYCBpbnNpZGUgYW5cbiAgICAgIC8vIGFzeW5jIGNvbXBvbmVudC4gU2luY2Ugd2Ugd2FybiBmb3IgdGhhdCBhYm92ZSwgd2UnbGwgc2lsZW5jZSB0aGlzXG4gICAgICAvLyBzZWNvbmQgd2FybmluZyBieSBjaGVja2luZyBoZXJlLlxuICAgICAgIWRpZFdhcm5BYm91dEFzeW5jQ2xpZW50Q29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRVc2VXcmFwcGVkSW5UcnlDYXRjaC5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZXJyb3IoJ2B1c2VgIHdhcyBjYWxsZWQgZnJvbSBpbnNpZGUgYSB0cnkvY2F0Y2ggYmxvY2suIFRoaXMgaXMgbm90IGFsbG93ZWQgJyArICdhbmQgY2FuIGxlYWQgdG8gdW5leHBlY3RlZCBiZWhhdmlvci4gVG8gaGFuZGxlIGVycm9ycyB0cmlnZ2VyZWQgJyArICdieSBgdXNlYCwgd3JhcCB5b3VyIGNvbXBvbmVudCBpbiBhIGVycm9yIGJvdW5kYXJ5LicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXBsYXlTdXNwZW5kZWRDb21wb25lbnRXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZykge1xuICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcmVwbGF5IGEgY29tcG9uZW50IHRoYXQgcHJldmlvdXNseSBzdXNwZW5kZWQsXG4gIC8vIGFmdGVyIGl0cyBkYXRhIHJlc29sdmVzLlxuICAvL1xuICAvLyBJdCdzIGEgc2ltcGxpZmllZCB2ZXJzaW9uIG9mIHJlbmRlcldpdGhIb29rcywgYnV0IGl0IGRvZXNuJ3QgbmVlZCB0byBkb1xuICAvLyBtb3N0IG9mIHRoZSBzZXQgdXAgd29yayBiZWNhdXNlIHRoZXkgd2VyZW4ndCByZXNldCB3aGVuIHdlIHN1c3BlbmRlZDsgdGhleVxuICAvLyBvbmx5IGdldCByZXNldCB3aGVuIHRoZSBjb21wb25lbnQgZWl0aGVyIGNvbXBsZXRlcyAoZmluaXNoUmVuZGVyaW5nSG9va3MpXG4gIC8vIG9yIHVud2luZHMgKHJlc2V0SG9va3NPblVud2luZCkuXG4gIHtcbiAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xOyAvLyBVc2VkIGZvciBob3QgcmVsb2FkaW5nOlxuXG4gICAgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPSBjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQudHlwZSAhPT0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgfVxuXG4gIHZhciBjaGlsZHJlbiA9IHJlbmRlcldpdGhIb29rc0FnYWluKHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHByb3BzLCBzZWNvbmRBcmcpO1xuICBmaW5pc2hSZW5kZXJpbmdIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gcmVuZGVyV2l0aEhvb2tzQWdhaW4od29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgcHJvcHMsIHNlY29uZEFyZykge1xuICAvLyBUaGlzIGlzIHVzZWQgdG8gcGVyZm9ybSBhbm90aGVyIHJlbmRlciBwYXNzLiBJdCdzIHVzZWQgd2hlbiBzZXRTdGF0ZSBpc1xuICAvLyBjYWxsZWQgZHVyaW5nIHJlbmRlciwgYW5kIGZvciBkb3VibGUgaW52b2tpbmcgY29tcG9uZW50cyBpbiBTdHJpY3QgTW9kZVxuICAvLyBkdXJpbmcgZGV2ZWxvcG1lbnQuXG4gIC8vXG4gIC8vIFRoZSBzdGF0ZSBmcm9tIHRoZSBwcmV2aW91cyBwYXNzIGlzIHJldXNlZCB3aGVuZXZlciBwb3NzaWJsZS4gU28sIHN0YXRlXG4gIC8vIHVwZGF0ZXMgdGhhdCB3ZXJlIGFscmVhZHkgcHJvY2Vzc2VkIGFyZSBub3QgcHJvY2Vzc2VkIGFnYWluLCBhbmQgbWVtb2l6ZWRcbiAgLy8gZnVuY3Rpb25zIChgdXNlTWVtb2ApIGFyZSBub3QgaW52b2tlZCBhZ2Fpbi5cbiAgLy9cbiAgLy8gS2VlcCByZW5kZXJpbmcgaW4gYSBsb29wIGZvciBhcyBsb25nIGFzIHJlbmRlciBwaGFzZSB1cGRhdGVzIGNvbnRpbnVlIHRvXG4gIC8vIGJlIHNjaGVkdWxlZC4gVXNlIGEgY291bnRlciB0byBwcmV2ZW50IGluZmluaXRlIGxvb3BzLlxuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxID0gd29ya0luUHJvZ3Jlc3M7XG4gIHZhciBudW1iZXJPZlJlUmVuZGVycyA9IDA7XG4gIHZhciBjaGlsZHJlbjtcblxuICBkbyB7XG4gICAgaWYgKGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcykge1xuICAgICAgLy8gSXQncyBwb3NzaWJsZSB0aGF0IGEgdXNlKCkgdmFsdWUgZGVwZW5kZWQgb24gYSBzdGF0ZSB0aGF0IHdhcyB1cGRhdGVkIGluXG4gICAgICAvLyB0aGlzIHJlcmVuZGVyLCBzbyB3ZSBuZWVkIHRvIHdhdGNoIGZvciBkaWZmZXJlbnQgdGhlbmFibGVzIHRoaXMgdGltZS5cbiAgICAgIHRoZW5hYmxlU3RhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMDtcbiAgICBkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MgPSBmYWxzZTtcblxuICAgIGlmIChudW1iZXJPZlJlUmVuZGVycyA+PSBSRV9SRU5ERVJfTElNSVQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVG9vIG1hbnkgcmUtcmVuZGVycy4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgcmVuZGVycyB0byBwcmV2ZW50ICcgKyAnYW4gaW5maW5pdGUgbG9vcC4nKTtcbiAgICB9XG5cbiAgICBudW1iZXJPZlJlUmVuZGVycyArPSAxO1xuXG4gICAge1xuICAgICAgLy8gRXZlbiB3aGVuIGhvdCByZWxvYWRpbmcsIGFsbG93IGRlcGVuZGVuY2llcyB0byBzdGFiaWxpemVcbiAgICAgIC8vIGFmdGVyIGZpcnN0IHJlbmRlciB0byBwcmV2ZW50IGluZmluaXRlIHJlbmRlciBwaGFzZSB1cGRhdGVzLlxuICAgICAgaWdub3JlUHJldmlvdXNEZXBlbmRlbmNpZXMgPSBmYWxzZTtcbiAgICB9IC8vIFN0YXJ0IG92ZXIgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0XG5cblxuICAgIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gbnVsbDtcblxuICAgIHtcbiAgICAgIC8vIEFsc28gdmFsaWRhdGUgaG9vayBvcmRlciBmb3IgY2FzY2FkaW5nIHVwZGF0ZXMuXG4gICAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xO1xuICAgIH1cblxuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYgO1xuICAgIGNoaWxkcmVuID0gQ29tcG9uZW50KHByb3BzLCBzZWNvbmRBcmcpO1xuICB9IHdoaWxlIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlRHVyaW5nVGhpc1Bhc3MpO1xuXG4gIHJldHVybiBjaGlsZHJlbjtcbn1cblxuZnVuY3Rpb24gcmVuZGVyVHJhbnNpdGlvbkF3YXJlSG9zdENvbXBvbmVudFdpdGhIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbGFuZXMpIHtcblxuICByZXR1cm4gcmVuZGVyV2l0aEhvb2tzKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBUcmFuc2l0aW9uQXdhcmVIb3N0Q29tcG9uZW50LCBudWxsLCBudWxsLCBsYW5lcyk7XG59XG5mdW5jdGlvbiBUcmFuc2l0aW9uQXdhcmVIb3N0Q29tcG9uZW50KCkge1xuXG4gIHZhciBkaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcblxuICB2YXIgX2Rpc3BhdGNoZXIkdXNlU3RhdGUgPSBkaXNwYXRjaGVyLnVzZVN0YXRlKCksXG4gICAgICBtYXliZVRoZW5hYmxlID0gX2Rpc3BhdGNoZXIkdXNlU3RhdGVbMF07XG5cbiAgdmFyIG5leHRTdGF0ZTtcblxuICBpZiAodHlwZW9mIG1heWJlVGhlbmFibGUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciB0aGVuYWJsZSA9IG1heWJlVGhlbmFibGU7XG4gICAgbmV4dFN0YXRlID0gdXNlVGhlbmFibGUodGhlbmFibGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBzdGF0dXMgPSBtYXliZVRoZW5hYmxlO1xuICAgIG5leHRTdGF0ZSA9IHN0YXR1cztcbiAgfSAvLyBUaGUgXCJyZXNldCBzdGF0ZVwiIGlzIGFuIG9iamVjdC4gSWYgaXQgY2hhbmdlcywgdGhhdCBtZWFucyBzb21ldGhpbmdcbiAgLy8gcmVxdWVzdGVkIHRoYXQgd2UgcmVzZXQgdGhlIGZvcm0uXG5cblxuICB2YXIgX2Rpc3BhdGNoZXIkdXNlU3RhdGUyID0gZGlzcGF0Y2hlci51c2VTdGF0ZSgpLFxuICAgICAgbmV4dFJlc2V0U3RhdGUgPSBfZGlzcGF0Y2hlciR1c2VTdGF0ZTJbMF07XG5cbiAgdmFyIHByZXZSZXNldFN0YXRlID0gY3VycmVudEhvb2sgIT09IG51bGwgPyBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlIDogbnVsbDtcblxuICBpZiAocHJldlJlc2V0U3RhdGUgIT09IG5leHRSZXNldFN0YXRlKSB7XG4gICAgLy8gU2NoZWR1bGUgYSBmb3JtIHJlc2V0XG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSBGb3JtUmVzZXQ7XG4gIH1cblxuICByZXR1cm4gbmV4dFN0YXRlO1xufVxuZnVuY3Rpb24gY2hlY2tEaWRSZW5kZXJJZEhvb2soKSB7XG4gIC8vIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBpbW1lZGlhdGVseSBhZnRlciBldmVyeSByZW5kZXJXaXRoSG9va3MgY2FsbC5cbiAgLy8gQ29uY2VwdHVhbGx5LCBpdCdzIHBhcnQgb2YgdGhlIHJldHVybiB2YWx1ZSBvZiByZW5kZXJXaXRoSG9va3M7IGl0J3Mgb25seSBhXG4gIC8vIHNlcGFyYXRlIGZ1bmN0aW9uIHRvIGF2b2lkIHVzaW5nIGFuIGFycmF5IHR1cGxlLlxuICB2YXIgZGlkUmVuZGVySWRIb29rID0gbG9jYWxJZENvdW50ZXIgIT09IDA7XG4gIGxvY2FsSWRDb3VudGVyID0gMDtcbiAgcmV0dXJuIGRpZFJlbmRlcklkSG9vaztcbn1cbmZ1bmN0aW9uIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbGFuZXMpIHtcbiAgd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWUgPSBjdXJyZW50LnVwZGF0ZVF1ZXVlOyAvLyBUT0RPOiBEb24ndCBuZWVkIHRvIHJlc2V0IHRoZSBmbGFncyBoZXJlLCBiZWNhdXNlIHRoZXkncmUgcmVzZXQgaW4gdGhlXG4gIC8vIGNvbXBsZXRlIHBoYXNlIChidWJibGVQcm9wZXJ0aWVzKS5cblxuICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RFZmZlY3RzTW9kZSkgIT09IE5vTW9kZSkge1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IH4oTW91bnRQYXNzaXZlRGV2IHwgTW91bnRMYXlvdXREZXYgfCBQYXNzaXZlJDEgfCBVcGRhdGUpO1xuICB9IGVsc2Uge1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IH4oUGFzc2l2ZSQxIHwgVXBkYXRlKTtcbiAgfVxuXG4gIGN1cnJlbnQubGFuZXMgPSByZW1vdmVMYW5lcyhjdXJyZW50LmxhbmVzLCBsYW5lcyk7XG59XG5mdW5jdGlvbiByZXNldEhvb2tzQWZ0ZXJUaHJvdygpIHtcbiAgLy8gVGhpcyBpcyBjYWxsZWQgaW1tZWRpYWV0bHkgYWZ0ZXIgYSB0aHJvdy4gSXQgc2hvdWxkbid0IHJlc2V0IHRoZSBlbnRpcmVcbiAgLy8gbW9kdWxlIHN0YXRlLCBiZWNhdXNlIHRoZSB3b3JrIGxvb3AgbWlnaHQgZGVjaWRlIHRvIHJlcGxheSB0aGUgY29tcG9uZW50XG4gIC8vIGFnYWluIHdpdGhvdXQgcmV3aW5kaW5nLlxuICAvL1xuICAvLyBJdCBzaG91bGQgb25seSByZXNldCB0aGluZ3MgbGlrZSB0aGUgY3VycmVudCBkaXNwYXRjaGVyLCB0byBwcmV2ZW50IGhvb2tzXG4gIC8vIGZyb20gYmVpbmcgY2FsbGVkIG91dHNpZGUgb2YgYSBjb21wb25lbnQuXG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgPSBudWxsOyAvLyBXZSBjYW4gYXNzdW1lIHRoZSBwcmV2aW91cyBkaXNwYXRjaGVyIGlzIGFsd2F5cyB0aGlzIG9uZSwgc2luY2Ugd2Ugc2V0IGl0XG4gIC8vIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJlbmRlciBwaGFzZSBhbmQgdGhlcmUncyBubyByZS1lbnRyYW5jZS5cblxuICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xufVxuZnVuY3Rpb24gcmVzZXRIb29rc09uVW53aW5kKHdvcmtJblByb2dyZXNzKSB7XG4gIGlmIChkaWRTY2hlZHVsZVJlbmRlclBoYXNlVXBkYXRlKSB7XG4gICAgLy8gVGhlcmUgd2VyZSByZW5kZXIgcGhhc2UgdXBkYXRlcy4gVGhlc2UgYXJlIG9ubHkgdmFsaWQgZm9yIHRoaXMgcmVuZGVyXG4gICAgLy8gcGhhc2UsIHdoaWNoIHdlIGFyZSBub3cgYWJvcnRpbmcuIFJlbW92ZSB0aGUgdXBkYXRlcyBmcm9tIHRoZSBxdWV1ZXMgc29cbiAgICAvLyB0aGV5IGRvIG5vdCBwZXJzaXN0IHRvIHRoZSBuZXh0IHJlbmRlci4gRG8gbm90IHJlbW92ZSB1cGRhdGVzIGZyb20gaG9va3NcbiAgICAvLyB0aGF0IHdlcmVuJ3QgcHJvY2Vzc2VkLlxuICAgIC8vXG4gICAgLy8gT25seSByZXNldCB0aGUgdXBkYXRlcyBmcm9tIHRoZSBxdWV1ZSBpZiBpdCBoYXMgYSBjbG9uZS4gSWYgaXQgZG9lc1xuICAgIC8vIG5vdCBoYXZlIGEgY2xvbmUsIHRoYXQgbWVhbnMgaXQgd2Fzbid0IHByb2Nlc3NlZCwgYW5kIHRoZSB1cGRhdGVzIHdlcmVcbiAgICAvLyBzY2hlZHVsZWQgYmVmb3JlIHdlIGVudGVyZWQgdGhlIHJlbmRlciBwaGFzZS5cbiAgICB2YXIgaG9vayA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgICB3aGlsZSAoaG9vayAhPT0gbnVsbCkge1xuICAgICAgdmFyIHF1ZXVlID0gaG9vay5xdWV1ZTtcblxuICAgICAgaWYgKHF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgIHF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICBob29rID0gaG9vay5uZXh0O1xuICAgIH1cblxuICAgIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSBmYWxzZTtcbiAgfVxuXG4gIHJlbmRlckxhbmVzID0gTm9MYW5lcztcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSA9IG51bGw7XG4gIGN1cnJlbnRIb29rID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NIb29rID0gbnVsbDtcblxuICB7XG4gICAgaG9va1R5cGVzRGV2ID0gbnVsbDtcbiAgICBob29rVHlwZXNVcGRhdGVJbmRleERldiA9IC0xO1xuICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gbnVsbDtcbiAgfVxuXG4gIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9IGZhbHNlO1xuICBsb2NhbElkQ291bnRlciA9IDA7XG4gIHRoZW5hYmxlSW5kZXhDb3VudGVyID0gMDtcbiAgdGhlbmFibGVTdGF0ZSA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCkge1xuICB2YXIgaG9vayA9IHtcbiAgICBtZW1vaXplZFN0YXRlOiBudWxsLFxuICAgIGJhc2VTdGF0ZTogbnVsbCxcbiAgICBiYXNlUXVldWU6IG51bGwsXG4gICAgcXVldWU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc0hvb2sgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBob29rIGluIHRoZSBsaXN0XG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rID0gaG9vaztcbiAgfSBlbHNlIHtcbiAgICAvLyBBcHBlbmQgdG8gdGhlIGVuZCBvZiB0aGUgbGlzdFxuICAgIHdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID0gaG9vaztcbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc0hvb2s7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJvdGggZm9yIHVwZGF0ZXMgYW5kIGZvciByZS1yZW5kZXJzIHRyaWdnZXJlZCBieSBhXG4gIC8vIHJlbmRlciBwaGFzZSB1cGRhdGUuIEl0IGFzc3VtZXMgdGhlcmUgaXMgZWl0aGVyIGEgY3VycmVudCBob29rIHdlIGNhblxuICAvLyBjbG9uZSwgb3IgYSB3b3JrLWluLXByb2dyZXNzIGhvb2sgZnJvbSBhIHByZXZpb3VzIHJlbmRlciBwYXNzIHRoYXQgd2UgY2FuXG4gIC8vIHVzZSBhcyBhIGJhc2UuXG4gIHZhciBuZXh0Q3VycmVudEhvb2s7XG5cbiAgaWYgKGN1cnJlbnRIb29rID09PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmFsdGVybmF0ZTtcblxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICBuZXh0Q3VycmVudEhvb2sgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5leHRDdXJyZW50SG9vayA9IG51bGw7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5leHRDdXJyZW50SG9vayA9IGN1cnJlbnRIb29rLm5leHQ7XG4gIH1cblxuICB2YXIgbmV4dFdvcmtJblByb2dyZXNzSG9vaztcblxuICBpZiAod29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgbmV4dFdvcmtJblByb2dyZXNzSG9vayA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZTtcbiAgfSBlbHNlIHtcbiAgICBuZXh0V29ya0luUHJvZ3Jlc3NIb29rID0gd29ya0luUHJvZ3Jlc3NIb29rLm5leHQ7XG4gIH1cblxuICBpZiAobmV4dFdvcmtJblByb2dyZXNzSG9vayAhPT0gbnVsbCkge1xuICAgIC8vIFRoZXJlJ3MgYWxyZWFkeSBhIHdvcmstaW4tcHJvZ3Jlc3MuIFJldXNlIGl0LlxuICAgIHdvcmtJblByb2dyZXNzSG9vayA9IG5leHRXb3JrSW5Qcm9ncmVzc0hvb2s7XG4gICAgbmV4dFdvcmtJblByb2dyZXNzSG9vayA9IHdvcmtJblByb2dyZXNzSG9vay5uZXh0O1xuICAgIGN1cnJlbnRIb29rID0gbmV4dEN1cnJlbnRIb29rO1xuICB9IGVsc2Uge1xuICAgIC8vIENsb25lIGZyb20gdGhlIGN1cnJlbnQgaG9vay5cbiAgICBpZiAobmV4dEN1cnJlbnRIb29rID09PSBudWxsKSB7XG4gICAgICB2YXIgY3VycmVudEZpYmVyID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5hbHRlcm5hdGU7XG5cbiAgICAgIGlmIChjdXJyZW50RmliZXIgPT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhpcyBpcyB0aGUgaW5pdGlhbCByZW5kZXIuIFRoaXMgYnJhbmNoIGlzIHJlYWNoZWQgd2hlbiB0aGUgY29tcG9uZW50XG4gICAgICAgIC8vIHN1c3BlbmRzLCByZXN1bWVzLCB0aGVuIHJlbmRlcnMgYW4gYWRkaXRpb25hbCBob29rLlxuICAgICAgICAvLyBTaG91bGQgbmV2ZXIgYmUgcmVhY2hlZCBiZWNhdXNlIHdlIHNob3VsZCBzd2l0Y2ggdG8gdGhlIG1vdW50IGRpc3BhdGNoZXIgZmlyc3QuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVXBkYXRlIGhvb2sgY2FsbGVkIG9uIGluaXRpYWwgcmVuZGVyLiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGlzIGlzIGFuIHVwZGF0ZS4gV2Ugc2hvdWxkIGFsd2F5cyBoYXZlIGEgY3VycmVudCBob29rLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlbmRlcmVkIG1vcmUgaG9va3MgdGhhbiBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlci4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdXJyZW50SG9vayA9IG5leHRDdXJyZW50SG9vaztcbiAgICB2YXIgbmV3SG9vayA9IHtcbiAgICAgIG1lbW9pemVkU3RhdGU6IGN1cnJlbnRIb29rLm1lbW9pemVkU3RhdGUsXG4gICAgICBiYXNlU3RhdGU6IGN1cnJlbnRIb29rLmJhc2VTdGF0ZSxcbiAgICAgIGJhc2VRdWV1ZTogY3VycmVudEhvb2suYmFzZVF1ZXVlLFxuICAgICAgcXVldWU6IGN1cnJlbnRIb29rLnF1ZXVlLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3NIb29rID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCBob29rIGluIHRoZSBsaXN0LlxuICAgICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5tZW1vaXplZFN0YXRlID0gd29ya0luUHJvZ3Jlc3NIb29rID0gbmV3SG9vaztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQXBwZW5kIHRvIHRoZSBlbmQgb2YgdGhlIGxpc3QuXG4gICAgICB3b3JrSW5Qcm9ncmVzc0hvb2sgPSB3b3JrSW5Qcm9ncmVzc0hvb2submV4dCA9IG5ld0hvb2s7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzSG9vaztcbn0gLy8gTk9URTogZGVmaW5pbmcgdHdvIHZlcnNpb25zIG9mIHRoaXMgZnVuY3Rpb24gdG8gYXZvaWQgc2l6ZSBpbXBhY3Qgd2hlbiB0aGlzIGZlYXR1cmUgaXMgZGlzYWJsZWQuXG4vLyBQcmV2aW91c2x5IHRoaXMgZnVuY3Rpb24gd2FzIGlubGluZWQsIHRoZSBhZGRpdGlvbmFsIGBtZW1vQ2FjaGVgIHByb3BlcnR5IG1ha2VzIGl0IG5vdCBpbmxpbmVkLlxuXG5cbnZhciBjcmVhdGVGdW5jdGlvbkNvbXBvbmVudFVwZGF0ZVF1ZXVlO1xuXG57XG4gIGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGxhc3RFZmZlY3Q6IG51bGwsXG4gICAgICBldmVudHM6IG51bGwsXG4gICAgICBzdG9yZXM6IG51bGwsXG4gICAgICBtZW1vQ2FjaGU6IG51bGxcbiAgICB9O1xuICB9O1xufVxuXG5mdW5jdGlvbiB1c2VUaGVuYWJsZSh0aGVuYWJsZSkge1xuICAvLyBUcmFjayB0aGUgcG9zaXRpb24gb2YgdGhlIHRoZW5hYmxlIHdpdGhpbiB0aGlzIGZpYmVyLlxuICB2YXIgaW5kZXggPSB0aGVuYWJsZUluZGV4Q291bnRlcjtcbiAgdGhlbmFibGVJbmRleENvdW50ZXIgKz0gMTtcblxuICBpZiAodGhlbmFibGVTdGF0ZSA9PT0gbnVsbCkge1xuICAgIHRoZW5hYmxlU3RhdGUgPSBjcmVhdGVUaGVuYWJsZVN0YXRlKCk7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0gdHJhY2tVc2VkVGhlbmFibGUodGhlbmFibGVTdGF0ZSwgdGhlbmFibGUsIGluZGV4KTtcblxuICBpZiAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5hbHRlcm5hdGUgPT09IG51bGwgJiYgKHdvcmtJblByb2dyZXNzSG9vayA9PT0gbnVsbCA/IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubWVtb2l6ZWRTdGF0ZSA9PT0gbnVsbCA6IHdvcmtJblByb2dyZXNzSG9vay5uZXh0ID09PSBudWxsKSkge1xuICAgIC8vIEluaXRpYWwgcmVuZGVyLCBhbmQgZWl0aGVyIHRoaXMgaXMgdGhlIGZpcnN0IHRpbWUgdGhlIGNvbXBvbmVudCBpc1xuICAgIC8vIGNhbGxlZCwgb3IgdGhlcmUgd2VyZSBubyBIb29rcyBjYWxsZWQgYWZ0ZXIgdGhpcyB1c2UoKSB0aGUgcHJldmlvdXNcbiAgICAvLyB0aW1lIChwZXJoYXBzIGJlY2F1c2UgaXQgdGhyZXcpLiBTdWJzZXF1ZW50IEhvb2sgY2FsbHMgc2hvdWxkIHVzZSB0aGVcbiAgICAvLyBtb3VudCBkaXNwYXRjaGVyLlxuICAgIHtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gdXNlKHVzYWJsZSkge1xuICBpZiAodXNhYmxlICE9PSBudWxsICYmIHR5cGVvZiB1c2FibGUgPT09ICdvYmplY3QnKSB7XG4gICAgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICAgIGlmICh0eXBlb2YgdXNhYmxlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB0aGVuYWJsZS5cbiAgICAgIHZhciB0aGVuYWJsZSA9IHVzYWJsZTtcbiAgICAgIHJldHVybiB1c2VUaGVuYWJsZSh0aGVuYWJsZSk7XG4gICAgfSBlbHNlIGlmICh1c2FibGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSkge1xuICAgICAgdmFyIGNvbnRleHQgPSB1c2FibGU7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfVxuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgdGhyb3cgbmV3IEVycm9yKCdBbiB1bnN1cHBvcnRlZCB0eXBlIHdhcyBwYXNzZWQgdG8gdXNlKCk6ICcgKyBTdHJpbmcodXNhYmxlKSk7XG59XG5cbmZ1bmN0aW9uIHVzZU1lbW9DYWNoZShzaXplKSB7XG4gIHZhciBtZW1vQ2FjaGUgPSBudWxsOyAvLyBGYXN0LXBhdGgsIGxvYWQgbWVtbyBjYWNoZSBmcm9tIHdpcCBmaWJlciBpZiBhbHJlYWR5IHByZXBhcmVkXG5cbiAgdmFyIHVwZGF0ZVF1ZXVlID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZTtcblxuICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICBtZW1vQ2FjaGUgPSB1cGRhdGVRdWV1ZS5tZW1vQ2FjaGU7XG4gIH0gLy8gT3RoZXJ3aXNlIGNsb25lIGZyb20gdGhlIGN1cnJlbnQgZmliZXJcblxuXG4gIGlmIChtZW1vQ2FjaGUgPT0gbnVsbCkge1xuICAgIHZhciBjdXJyZW50ID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5hbHRlcm5hdGU7XG5cbiAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgdmFyIGN1cnJlbnRVcGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7XG5cbiAgICAgIGlmIChjdXJyZW50VXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRNZW1vQ2FjaGUgPSBjdXJyZW50VXBkYXRlUXVldWUubWVtb0NhY2hlO1xuXG4gICAgICAgIGlmIChjdXJyZW50TWVtb0NhY2hlICE9IG51bGwpIHtcbiAgICAgICAgICBtZW1vQ2FjaGUgPSB7XG4gICAgICAgICAgICAvLyBXaGVuIGVuYWJsZU5vQ2xvbmluZ01lbW9DYWNoZSBpcyBlbmFibGVkLCBpbnN0ZWFkIG9mIHRyZWF0aW5nIHRoZVxuICAgICAgICAgICAgLy8gY2FjaGUgYXMgY29weS1vbi13cml0ZSwgbGlrZSB3ZSBkbyB3aXRoIGZpYmVycywgd2Ugc2hhcmUgdGhlIHNhbWVcbiAgICAgICAgICAgIC8vIGNhY2hlIGluc3RhbmNlIGFjcm9zcyBhbGwgcmVuZGVyIGF0dGVtcHRzLCBldmVuIGlmIHRoZSBjb21wb25lbnRcbiAgICAgICAgICAgIC8vIGlzIGludGVycnVwdGVkIGJlZm9yZSBpdCBjb21taXRzLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIElmIGFuIHVwZGF0ZSBpcyBpbnRlcnJ1cHRlZCwgZWl0aGVyIGJlY2F1c2UgaXQgc3VzcGVuZGVkIG9yXG4gICAgICAgICAgICAvLyBiZWNhdXNlIG9mIGFub3RoZXIgdXBkYXRlLCB3ZSBjYW4gcmV1c2UgdGhlIG1lbW9pemVkIGNvbXB1dGF0aW9uc1xuICAgICAgICAgICAgLy8gZnJvbSB0aGUgcHJldmlvdXMgYXR0ZW1wdC4gV2UgY2FuIGRvIHRoaXMgYmVjYXVzZSB0aGUgUmVhY3RcbiAgICAgICAgICAgIC8vIENvbXBpbGVyIHBlcmZvcm1zIGF0b21pYyB3cml0ZXMgdG8gdGhlIG1lbW8gY2FjaGUsIGkuZS4gaXQgd2lsbFxuICAgICAgICAgICAgLy8gbm90IHJlY29yZCB0aGUgaW5wdXRzIHRvIGEgbWVtb2l6YXRpb24gd2l0aG91dCBhbHNvIHJlY29yZGluZyBpdHNcbiAgICAgICAgICAgIC8vIG91dHB1dC5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGlzIGdpdmVzIHVzIGEgZm9ybSBvZiBcInJlc3VtaW5nXCIgd2l0aGluIGNvbXBvbmVudHMgYW5kIGhvb2tzLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIFRoaXMgb25seSB3b3JrcyB3aGVuIHVwZGF0aW5nIGEgY29tcG9uZW50IHRoYXQgYWxyZWFkeSBtb3VudGVkLlxuICAgICAgICAgICAgLy8gSXQgaGFzIG5vIGltcGFjdCBkdXJpbmcgaW5pdGlhbCByZW5kZXIsIGJlY2F1c2UgdGhlIG1lbW8gY2FjaGUgaXNcbiAgICAgICAgICAgIC8vIHN0b3JlZCBvbiB0aGUgZmliZXIsIGFuZCBzaW5jZSB3ZSBoYXZlIG5vdCBpbXBsZW1lbnRlZCByZXN1bWluZ1xuICAgICAgICAgICAgLy8gZm9yIGZpYmVycywgaXQncyBhbHdheXMgYSBmcmVzaCBtZW1vIGNhY2hlLCBhbnl3YXkuXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gSG93ZXZlciwgdGhpcyBhbG9uZSBpcyBwcmV0dHkgdXNlZnVsIOKAlCBpdCBoYXBwZW5zIHdoZW5ldmVyIHlvdVxuICAgICAgICAgICAgLy8gdXBkYXRlIHRoZSBVSSB3aXRoIGZyZXNoIGRhdGEgYWZ0ZXIgYSBtdXRhdGlvbi9hY3Rpb24sIHdoaWNoIGlzXG4gICAgICAgICAgICAvLyBleHRyZW1lbHkgY29tbW9uIGluIGEgU3VzcGVuc2UtZHJpdmVuIChlLmcuIFJTQyBvciBSZWxheSkgYXBwLlxuICAgICAgICAgICAgZGF0YTogLy8gQ2xvbmUgdGhlIG1lbW8gY2FjaGUgYmVmb3JlIGVhY2ggcmVuZGVyIChjb3B5LW9uLXdyaXRlKVxuICAgICAgICAgICAgY3VycmVudE1lbW9DYWNoZS5kYXRhLm1hcChmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGFycmF5LnNsaWNlKCk7XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIGluZGV4OiAwXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBGaW5hbGx5IGZhbGwgYmFjayB0byBhbGxvY2F0aW5nIGEgZnJlc2ggaW5zdGFuY2Ugb2YgdGhlIGNhY2hlXG5cblxuICBpZiAobWVtb0NhY2hlID09IG51bGwpIHtcbiAgICBtZW1vQ2FjaGUgPSB7XG4gICAgICBkYXRhOiBbXSxcbiAgICAgIGluZGV4OiAwXG4gICAgfTtcbiAgfVxuXG4gIGlmICh1cGRhdGVRdWV1ZSA9PT0gbnVsbCkge1xuICAgIHVwZGF0ZVF1ZXVlID0gY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSgpO1xuICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWUgPSB1cGRhdGVRdWV1ZTtcbiAgfVxuXG4gIHVwZGF0ZVF1ZXVlLm1lbW9DYWNoZSA9IG1lbW9DYWNoZTtcbiAgdmFyIGRhdGEgPSBtZW1vQ2FjaGUuZGF0YVttZW1vQ2FjaGUuaW5kZXhdO1xuXG4gIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICBkYXRhID0gbWVtb0NhY2hlLmRhdGFbbWVtb0NhY2hlLmluZGV4XSA9IG5ldyBBcnJheShzaXplKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2l6ZTsgaSsrKSB7XG4gICAgICBkYXRhW2ldID0gUkVBQ1RfTUVNT19DQUNIRV9TRU5USU5FTDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGF0YS5sZW5ndGggIT09IHNpemUpIHtcbiAgICAvLyBUT0RPOiBjb25zaWRlciB3YXJuaW5nIG9yIHRocm93aW5nIGhlcmVcbiAgICB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgYSBjb25zdGFudCBzaXplIGFyZ3VtZW50IGZvciBlYWNoIGludm9jYXRpb24gb2YgdXNlTWVtb0NhY2hlLiAnICsgJ1RoZSBwcmV2aW91cyBjYWNoZSB3YXMgYWxsb2NhdGVkIHdpdGggc2l6ZSAlcyBidXQgc2l6ZSAlcyB3YXMgcmVxdWVzdGVkLicsIGRhdGEubGVuZ3RoLCBzaXplKTtcbiAgICB9XG4gIH1cblxuICBtZW1vQ2FjaGUuaW5kZXgrKztcbiAgcmV0dXJuIGRhdGE7XG59XG5cbmZ1bmN0aW9uIGJhc2ljU3RhdGVSZWR1Y2VyKHN0YXRlLCBhY3Rpb24pIHtcbiAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXTogRmxvdyBkb2Vzbid0IGxpa2UgbWl4ZWQgdHlwZXNcbiAgcmV0dXJuIHR5cGVvZiBhY3Rpb24gPT09ICdmdW5jdGlvbicgPyBhY3Rpb24oc3RhdGUpIDogYWN0aW9uO1xufVxuXG5mdW5jdGlvbiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBpbml0aWFsU3RhdGU7XG5cbiAgaWYgKGluaXQgIT09IHVuZGVmaW5lZCkge1xuICAgIGluaXRpYWxTdGF0ZSA9IGluaXQoaW5pdGlhbEFyZyk7XG5cbiAgICBpZiAoc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYpIHtcbiAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuICAgICAgaW5pdChpbml0aWFsQXJnKTtcbiAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaW5pdGlhbFN0YXRlID0gaW5pdGlhbEFyZztcbiAgfVxuXG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IGhvb2suYmFzZVN0YXRlID0gaW5pdGlhbFN0YXRlO1xuICB2YXIgcXVldWUgPSB7XG4gICAgcGVuZGluZzogbnVsbCxcbiAgICBsYW5lczogTm9MYW5lcyxcbiAgICBkaXNwYXRjaDogbnVsbCxcbiAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiByZWR1Y2VyLFxuICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBpbml0aWFsU3RhdGVcbiAgfTtcbiAgaG9vay5xdWV1ZSA9IHF1ZXVlO1xuICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaCA9IGRpc3BhdGNoUmVkdWNlckFjdGlvbi5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsIHF1ZXVlKTtcbiAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlUmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHJldHVybiB1cGRhdGVSZWR1Y2VySW1wbChob29rLCBjdXJyZW50SG9vaywgcmVkdWNlcik7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVJlZHVjZXJJbXBsKGhvb2ssIGN1cnJlbnQsIHJlZHVjZXIpIHtcbiAgdmFyIHF1ZXVlID0gaG9vay5xdWV1ZTtcblxuICBpZiAocXVldWUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBoYXZlIGEgcXVldWUuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHF1ZXVlLmxhc3RSZW5kZXJlZFJlZHVjZXIgPSByZWR1Y2VyOyAvLyBUaGUgbGFzdCByZWJhc2UgdXBkYXRlIHRoYXQgaXMgTk9UIHBhcnQgb2YgdGhlIGJhc2Ugc3RhdGUuXG5cbiAgdmFyIGJhc2VRdWV1ZSA9IGhvb2suYmFzZVF1ZXVlOyAvLyBUaGUgbGFzdCBwZW5kaW5nIHVwZGF0ZSB0aGF0IGhhc24ndCBiZWVuIHByb2Nlc3NlZCB5ZXQuXG5cbiAgdmFyIHBlbmRpbmdRdWV1ZSA9IHF1ZXVlLnBlbmRpbmc7XG5cbiAgaWYgKHBlbmRpbmdRdWV1ZSAhPT0gbnVsbCkge1xuICAgIC8vIFdlIGhhdmUgbmV3IHVwZGF0ZXMgdGhhdCBoYXZlbid0IGJlZW4gcHJvY2Vzc2VkIHlldC5cbiAgICAvLyBXZSdsbCBhZGQgdGhlbSB0byB0aGUgYmFzZSBxdWV1ZS5cbiAgICBpZiAoYmFzZVF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAvLyBNZXJnZSB0aGUgcGVuZGluZyBxdWV1ZSBhbmQgdGhlIGJhc2UgcXVldWUuXG4gICAgICB2YXIgYmFzZUZpcnN0ID0gYmFzZVF1ZXVlLm5leHQ7XG4gICAgICB2YXIgcGVuZGluZ0ZpcnN0ID0gcGVuZGluZ1F1ZXVlLm5leHQ7XG4gICAgICBiYXNlUXVldWUubmV4dCA9IHBlbmRpbmdGaXJzdDtcbiAgICAgIHBlbmRpbmdRdWV1ZS5uZXh0ID0gYmFzZUZpcnN0O1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChjdXJyZW50LmJhc2VRdWV1ZSAhPT0gYmFzZVF1ZXVlKSB7XG4gICAgICAgIC8vIEludGVybmFsIGludmFyaWFudCB0aGF0IHNob3VsZCBuZXZlciBoYXBwZW4sIGJ1dCBmZWFzaWJseSBjb3VsZCBpblxuICAgICAgICAvLyB0aGUgZnV0dXJlIGlmIHdlIGltcGxlbWVudCByZXN1bWluZywgb3Igc29tZSBmb3JtIG9mIHRoYXQuXG4gICAgICAgIGVycm9yKCdJbnRlcm5hbCBlcnJvcjogRXhwZWN0ZWQgd29yay1pbi1wcm9ncmVzcyBxdWV1ZSB0byBiZSBhIGNsb25lLiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3VycmVudC5iYXNlUXVldWUgPSBiYXNlUXVldWUgPSBwZW5kaW5nUXVldWU7XG4gICAgcXVldWUucGVuZGluZyA9IG51bGw7XG4gIH1cblxuICB2YXIgYmFzZVN0YXRlID0gaG9vay5iYXNlU3RhdGU7XG5cbiAgaWYgKGJhc2VRdWV1ZSA9PT0gbnVsbCkge1xuICAgIC8vIElmIHRoZXJlIGFyZSBubyBwZW5kaW5nIHVwZGF0ZXMsIHRoZW4gdGhlIG1lbW9pemVkIHN0YXRlIHNob3VsZCBiZSB0aGVcbiAgICAvLyBzYW1lIGFzIHRoZSBiYXNlIHN0YXRlLiBDdXJyZW50bHkgdGhlc2Ugb25seSBkaXZlcmdlIGluIHRoZSBjYXNlIG9mXG4gICAgLy8gdXNlT3B0aW1pc3RpYywgYmVjYXVzZSB1c2VPcHRpbWlzdGljIGFjY2VwdHMgYSBuZXcgYmFzZVN0YXRlIG9uXG4gICAgLy8gZXZlcnkgcmVuZGVyLlxuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IGJhc2VTdGF0ZTsgLy8gV2UgZG9uJ3QgbmVlZCB0byBjYWxsIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlIGJlY2F1c2VcbiAgICAvLyBiYXNlU3RhdGUgaXMgZGVyaXZlZCBmcm9tIG90aGVyIHJlYWN0aXZlIHZhbHVlcy5cbiAgfSBlbHNlIHtcbiAgICAvLyBXZSBoYXZlIGEgcXVldWUgdG8gcHJvY2Vzcy5cbiAgICB2YXIgZmlyc3QgPSBiYXNlUXVldWUubmV4dDtcbiAgICB2YXIgbmV3U3RhdGUgPSBiYXNlU3RhdGU7XG4gICAgdmFyIG5ld0Jhc2VTdGF0ZSA9IG51bGw7XG4gICAgdmFyIG5ld0Jhc2VRdWV1ZUZpcnN0ID0gbnVsbDtcbiAgICB2YXIgbmV3QmFzZVF1ZXVlTGFzdCA9IG51bGw7XG4gICAgdmFyIHVwZGF0ZSA9IGZpcnN0O1xuICAgIHZhciBkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uID0gZmFsc2U7XG5cbiAgICBkbyB7XG4gICAgICAvLyBBbiBleHRyYSBPZmZzY3JlZW5MYW5lIGJpdCBpcyBhZGRlZCB0byB1cGRhdGVzIHRoYXQgd2VyZSBtYWRlIHRvXG4gICAgICAvLyBhIGhpZGRlbiB0cmVlLCBzbyB0aGF0IHdlIGNhbiBkaXN0aW5ndWlzaCB0aGVtIGZyb20gdXBkYXRlcyB0aGF0IHdlcmVcbiAgICAgIC8vIGFscmVhZHkgdGhlcmUgd2hlbiB0aGUgdHJlZSB3YXMgaGlkZGVuLlxuICAgICAgdmFyIHVwZGF0ZUxhbmUgPSByZW1vdmVMYW5lcyh1cGRhdGUubGFuZSwgT2Zmc2NyZWVuTGFuZSk7XG4gICAgICB2YXIgaXNIaWRkZW5VcGRhdGUgPSB1cGRhdGVMYW5lICE9PSB1cGRhdGUubGFuZTsgLy8gQ2hlY2sgaWYgdGhpcyB1cGRhdGUgd2FzIG1hZGUgd2hpbGUgdGhlIHRyZWUgd2FzIGhpZGRlbi4gSWYgc28sIHRoZW5cbiAgICAgIC8vIGl0J3Mgbm90IGEgXCJiYXNlXCIgdXBkYXRlIGFuZCB3ZSBzaG91bGQgZGlzcmVnYXJkIHRoZSBleHRyYSBiYXNlIGxhbmVzXG4gICAgICAvLyB0aGF0IHdlcmUgYWRkZWQgdG8gcmVuZGVyTGFuZXMgd2hlbiB3ZSBlbnRlcmVkIHRoZSBPZmZzY3JlZW4gdHJlZS5cblxuICAgICAgdmFyIHNob3VsZFNraXBVcGRhdGUgPSBpc0hpZGRlblVwZGF0ZSA/ICFpc1N1YnNldE9mTGFuZXMoZ2V0V29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMoKSwgdXBkYXRlTGFuZSkgOiAhaXNTdWJzZXRPZkxhbmVzKHJlbmRlckxhbmVzLCB1cGRhdGVMYW5lKTtcblxuICAgICAgaWYgKHNob3VsZFNraXBVcGRhdGUpIHtcbiAgICAgICAgLy8gUHJpb3JpdHkgaXMgaW5zdWZmaWNpZW50LiBTa2lwIHRoaXMgdXBkYXRlLiBJZiB0aGlzIGlzIHRoZSBmaXJzdFxuICAgICAgICAvLyBza2lwcGVkIHVwZGF0ZSwgdGhlIHByZXZpb3VzIHVwZGF0ZS9zdGF0ZSBpcyB0aGUgbmV3IGJhc2VcbiAgICAgICAgLy8gdXBkYXRlL3N0YXRlLlxuICAgICAgICB2YXIgY2xvbmUgPSB7XG4gICAgICAgICAgbGFuZTogdXBkYXRlTGFuZSxcbiAgICAgICAgICByZXZlcnRMYW5lOiB1cGRhdGUucmV2ZXJ0TGFuZSxcbiAgICAgICAgICBhY3Rpb246IHVwZGF0ZS5hY3Rpb24sXG4gICAgICAgICAgaGFzRWFnZXJTdGF0ZTogdXBkYXRlLmhhc0VhZ2VyU3RhdGUsXG4gICAgICAgICAgZWFnZXJTdGF0ZTogdXBkYXRlLmVhZ2VyU3RhdGUsXG4gICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChuZXdCYXNlUXVldWVMYXN0ID09PSBudWxsKSB7XG4gICAgICAgICAgbmV3QmFzZVF1ZXVlRmlyc3QgPSBuZXdCYXNlUXVldWVMYXN0ID0gY2xvbmU7XG4gICAgICAgICAgbmV3QmFzZVN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV3QmFzZVF1ZXVlTGFzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IGNsb25lO1xuICAgICAgICB9IC8vIFVwZGF0ZSB0aGUgcmVtYWluaW5nIHByaW9yaXR5IGluIHRoZSBxdWV1ZS5cbiAgICAgICAgLy8gVE9ETzogRG9uJ3QgbmVlZCB0byBhY2N1bXVsYXRlIHRoaXMuIEluc3RlYWQsIHdlIGNhbiByZW1vdmVcbiAgICAgICAgLy8gcmVuZGVyTGFuZXMgZnJvbSB0aGUgb3JpZ2luYWwgbGFuZXMuXG5cblxuICAgICAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzID0gbWVyZ2VMYW5lcyhjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLmxhbmVzLCB1cGRhdGVMYW5lKTtcbiAgICAgICAgbWFya1NraXBwZWRVcGRhdGVMYW5lcyh1cGRhdGVMYW5lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgdXBkYXRlIGRvZXMgaGF2ZSBzdWZmaWNpZW50IHByaW9yaXR5LlxuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGFuIG9wdGltaXN0aWMgdXBkYXRlLlxuICAgICAgICB2YXIgcmV2ZXJ0TGFuZSA9IHVwZGF0ZS5yZXZlcnRMYW5lO1xuXG4gICAgICAgIGlmIChyZXZlcnRMYW5lID09PSBOb0xhbmUpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIG5vdCBhbiBvcHRpbWlzdGljIHVwZGF0ZSwgYW5kIHdlJ3JlIGdvaW5nIHRvIGFwcGx5IGl0IG5vdy5cbiAgICAgICAgICAvLyBCdXQsIGlmIHRoZXJlIHdlcmUgZWFybGllciB1cGRhdGVzIHRoYXQgd2VyZSBza2lwcGVkLCB3ZSBuZWVkIHRvXG4gICAgICAgICAgLy8gbGVhdmUgdGhpcyB1cGRhdGUgaW4gdGhlIHF1ZXVlIHNvIGl0IGNhbiBiZSByZWJhc2VkIGxhdGVyLlxuICAgICAgICAgIGlmIChuZXdCYXNlUXVldWVMYXN0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX2Nsb25lID0ge1xuICAgICAgICAgICAgICAvLyBUaGlzIHVwZGF0ZSBpcyBnb2luZyB0byBiZSBjb21taXR0ZWQgc28gd2UgbmV2ZXIgd2FudCB1bmNvbW1pdFxuICAgICAgICAgICAgICAvLyBpdC4gVXNpbmcgTm9MYW5lIHdvcmtzIGJlY2F1c2UgMCBpcyBhIHN1YnNldCBvZiBhbGwgYml0bWFza3MsIHNvXG4gICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBuZXZlciBiZSBza2lwcGVkIGJ5IHRoZSBjaGVjayBhYm92ZS5cbiAgICAgICAgICAgICAgbGFuZTogTm9MYW5lLFxuICAgICAgICAgICAgICByZXZlcnRMYW5lOiBOb0xhbmUsXG4gICAgICAgICAgICAgIGFjdGlvbjogdXBkYXRlLmFjdGlvbixcbiAgICAgICAgICAgICAgaGFzRWFnZXJTdGF0ZTogdXBkYXRlLmhhc0VhZ2VyU3RhdGUsXG4gICAgICAgICAgICAgIGVhZ2VyU3RhdGU6IHVwZGF0ZS5lYWdlclN0YXRlLFxuICAgICAgICAgICAgICBuZXh0OiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbmV3QmFzZVF1ZXVlTGFzdCA9IG5ld0Jhc2VRdWV1ZUxhc3QubmV4dCA9IF9jbG9uZTtcbiAgICAgICAgICB9IC8vIENoZWNrIGlmIHRoaXMgdXBkYXRlIGlzIHBhcnQgb2YgYSBwZW5kaW5nIGFzeW5jIGFjdGlvbi4gSWYgc28sXG4gICAgICAgICAgLy8gd2UnbGwgbmVlZCB0byBzdXNwZW5kIHVudGlsIHRoZSBhY3Rpb24gaGFzIGZpbmlzaGVkLCBzbyB0aGF0IGl0J3NcbiAgICAgICAgICAvLyBiYXRjaGVkIHRvZ2V0aGVyIHdpdGggZnV0dXJlIHVwZGF0ZXMgaW4gdGhlIHNhbWUgYWN0aW9uLlxuXG5cbiAgICAgICAgICBpZiAodXBkYXRlTGFuZSA9PT0gcGVla0VudGFuZ2xlZEFjdGlvbkxhbmUoKSkge1xuICAgICAgICAgICAgZGlkUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYW4gb3B0aW1pc3RpYyB1cGRhdGUuIElmIHRoZSBcInJldmVydFwiIHByaW9yaXR5IGlzXG4gICAgICAgICAgLy8gc3VmZmljaWVudCwgZG9uJ3QgYXBwbHkgdGhlIHVwZGF0ZS4gT3RoZXJ3aXNlLCBhcHBseSB0aGUgdXBkYXRlLFxuICAgICAgICAgIC8vIGJ1dCBsZWF2ZSBpdCBpbiB0aGUgcXVldWUgc28gaXQgY2FuIGJlIGVpdGhlciByZXZlcnRlZCBvclxuICAgICAgICAgIC8vIHJlYmFzZWQgaW4gYSBzdWJzZXF1ZW50IHJlbmRlci5cbiAgICAgICAgICBpZiAoaXNTdWJzZXRPZkxhbmVzKHJlbmRlckxhbmVzLCByZXZlcnRMYW5lKSkge1xuICAgICAgICAgICAgLy8gVGhlIHRyYW5zaXRpb24gdGhhdCB0aGlzIG9wdGltaXN0aWMgdXBkYXRlIGlzIGFzc29jaWF0ZWQgd2l0aFxuICAgICAgICAgICAgLy8gaGFzIGZpbmlzaGVkLiBQcmV0ZW5kIHRoZSB1cGRhdGUgZG9lc24ndCBleGlzdCBieSBza2lwcGluZ1xuICAgICAgICAgICAgLy8gb3ZlciBpdC5cbiAgICAgICAgICAgIHVwZGF0ZSA9IHVwZGF0ZS5uZXh0OyAvLyBDaGVjayBpZiB0aGlzIHVwZGF0ZSBpcyBwYXJ0IG9mIGEgcGVuZGluZyBhc3luYyBhY3Rpb24uIElmIHNvLFxuICAgICAgICAgICAgLy8gd2UnbGwgbmVlZCB0byBzdXNwZW5kIHVudGlsIHRoZSBhY3Rpb24gaGFzIGZpbmlzaGVkLCBzbyB0aGF0IGl0J3NcbiAgICAgICAgICAgIC8vIGJhdGNoZWQgdG9nZXRoZXIgd2l0aCBmdXR1cmUgdXBkYXRlcyBpbiB0aGUgc2FtZSBhY3Rpb24uXG5cbiAgICAgICAgICAgIGlmIChyZXZlcnRMYW5lID09PSBwZWVrRW50YW5nbGVkQWN0aW9uTGFuZSgpKSB7XG4gICAgICAgICAgICAgIGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIF9jbG9uZTIgPSB7XG4gICAgICAgICAgICAgIC8vIE9uY2Ugd2UgY29tbWl0IGFuIG9wdGltaXN0aWMgdXBkYXRlLCB3ZSBzaG91bGRuJ3QgdW5jb21taXQgaXRcbiAgICAgICAgICAgICAgLy8gdW50aWwgdGhlIHRyYW5zaXRpb24gaXQgaXMgYXNzb2NpYXRlZCB3aXRoIGhhcyBmaW5pc2hlZFxuICAgICAgICAgICAgICAvLyAocmVwcmVzZW50ZWQgYnkgcmV2ZXJ0TGFuZSkuIFVzaW5nIE5vTGFuZSBoZXJlIHdvcmtzIGJlY2F1c2UgMFxuICAgICAgICAgICAgICAvLyBpcyBhIHN1YnNldCBvZiBhbGwgYml0bWFza3MsIHNvIHRoaXMgd2lsbCBuZXZlciBiZSBza2lwcGVkIGJ5XG4gICAgICAgICAgICAgIC8vIHRoZSBjaGVjayBhYm92ZS5cbiAgICAgICAgICAgICAgbGFuZTogTm9MYW5lLFxuICAgICAgICAgICAgICAvLyBSZXVzZSB0aGUgc2FtZSByZXZlcnRMYW5lIHNvIHdlIGtub3cgd2hlbiB0aGUgdHJhbnNpdGlvblxuICAgICAgICAgICAgICAvLyBoYXMgZmluaXNoZWQuXG4gICAgICAgICAgICAgIHJldmVydExhbmU6IHVwZGF0ZS5yZXZlcnRMYW5lLFxuICAgICAgICAgICAgICBhY3Rpb246IHVwZGF0ZS5hY3Rpb24sXG4gICAgICAgICAgICAgIGhhc0VhZ2VyU3RhdGU6IHVwZGF0ZS5oYXNFYWdlclN0YXRlLFxuICAgICAgICAgICAgICBlYWdlclN0YXRlOiB1cGRhdGUuZWFnZXJTdGF0ZSxcbiAgICAgICAgICAgICAgbmV4dDogbnVsbFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKG5ld0Jhc2VRdWV1ZUxhc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgbmV3QmFzZVF1ZXVlRmlyc3QgPSBuZXdCYXNlUXVldWVMYXN0ID0gX2Nsb25lMjtcbiAgICAgICAgICAgICAgbmV3QmFzZVN0YXRlID0gbmV3U3RhdGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdCYXNlUXVldWVMYXN0ID0gbmV3QmFzZVF1ZXVlTGFzdC5uZXh0ID0gX2Nsb25lMjtcbiAgICAgICAgICAgIH0gLy8gVXBkYXRlIHRoZSByZW1haW5pbmcgcHJpb3JpdHkgaW4gdGhlIHF1ZXVlLlxuICAgICAgICAgICAgLy8gVE9ETzogRG9uJ3QgbmVlZCB0byBhY2N1bXVsYXRlIHRoaXMuIEluc3RlYWQsIHdlIGNhbiByZW1vdmVcbiAgICAgICAgICAgIC8vIHJlbmRlckxhbmVzIGZyb20gdGhlIG9yaWdpbmFsIGxhbmVzLlxuXG5cbiAgICAgICAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMgPSBtZXJnZUxhbmVzKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMsIHJldmVydExhbmUpO1xuICAgICAgICAgICAgbWFya1NraXBwZWRVcGRhdGVMYW5lcyhyZXZlcnRMYW5lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gUHJvY2VzcyB0aGlzIHVwZGF0ZS5cblxuXG4gICAgICAgIHZhciBhY3Rpb24gPSB1cGRhdGUuYWN0aW9uO1xuXG4gICAgICAgIGlmIChzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFVikge1xuICAgICAgICAgIHJlZHVjZXIobmV3U3RhdGUsIGFjdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXBkYXRlLmhhc0VhZ2VyU3RhdGUpIHtcbiAgICAgICAgICAvLyBJZiB0aGlzIHVwZGF0ZSBpcyBhIHN0YXRlIHVwZGF0ZSAobm90IGEgcmVkdWNlcikgYW5kIHdhcyBwcm9jZXNzZWQgZWFnZXJseSxcbiAgICAgICAgICAvLyB3ZSBjYW4gdXNlIHRoZSBlYWdlcmx5IGNvbXB1dGVkIHN0YXRlXG4gICAgICAgICAgbmV3U3RhdGUgPSB1cGRhdGUuZWFnZXJTdGF0ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXdTdGF0ZSA9IHJlZHVjZXIobmV3U3RhdGUsIGFjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdXBkYXRlID0gdXBkYXRlLm5leHQ7XG4gICAgfSB3aGlsZSAodXBkYXRlICE9PSBudWxsICYmIHVwZGF0ZSAhPT0gZmlyc3QpO1xuXG4gICAgaWYgKG5ld0Jhc2VRdWV1ZUxhc3QgPT09IG51bGwpIHtcbiAgICAgIG5ld0Jhc2VTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdCYXNlUXVldWVMYXN0Lm5leHQgPSBuZXdCYXNlUXVldWVGaXJzdDtcbiAgICB9IC8vIE1hcmsgdGhhdCB0aGUgZmliZXIgcGVyZm9ybWVkIHdvcmssIGJ1dCBvbmx5IGlmIHRoZSBuZXcgc3RhdGUgaXNcbiAgICAvLyBkaWZmZXJlbnQgZnJvbSB0aGUgY3VycmVudCBzdGF0ZS5cblxuXG4gICAgaWYgKCFvYmplY3RJcyhuZXdTdGF0ZSwgaG9vay5tZW1vaXplZFN0YXRlKSkge1xuICAgICAgbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKTsgLy8gQ2hlY2sgaWYgdGhpcyB1cGRhdGUgaXMgcGFydCBvZiBhIHBlbmRpbmcgYXN5bmMgYWN0aW9uLiBJZiBzbywgd2UnbGxcbiAgICAgIC8vIG5lZWQgdG8gc3VzcGVuZCB1bnRpbCB0aGUgYWN0aW9uIGhhcyBmaW5pc2hlZCwgc28gdGhhdCBpdCdzIGJhdGNoZWRcbiAgICAgIC8vIHRvZ2V0aGVyIHdpdGggZnV0dXJlIHVwZGF0ZXMgaW4gdGhlIHNhbWUgYWN0aW9uLlxuICAgICAgLy8gVE9ETzogT25jZSB3ZSBzdXBwb3J0IGhvb2tzIGluc2lkZSB1c2VNZW1vIChvciBhbiBlcXVpdmFsZW50XG4gICAgICAvLyBtZW1vaXphdGlvbiBib3VuZGFyeSBsaWtlIEZvcmdldCksIGhvaXN0IHRoaXMgbG9naWMgc28gdGhhdCBpdCBvbmx5XG4gICAgICAvLyBzdXNwZW5kcyBpZiB0aGUgbWVtbyBib3VuZGFyeSBwcm9kdWNlcyBhIG5ldyB2YWx1ZS5cblxuICAgICAgaWYgKGRpZFJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24pIHtcbiAgICAgICAgdmFyIGVudGFuZ2xlZEFjdGlvblRoZW5hYmxlID0gcGVla0VudGFuZ2xlZEFjdGlvblRoZW5hYmxlKCk7XG5cbiAgICAgICAgaWYgKGVudGFuZ2xlZEFjdGlvblRoZW5hYmxlICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gVE9ETzogSW5zdGVhZCBvZiB0aGUgdGhyb3dpbmcgdGhlIHRoZW5hYmxlIGRpcmVjdGx5LCB0aHJvdyBhXG4gICAgICAgICAgLy8gc3BlY2lhbCBvYmplY3QgbGlrZSBgdXNlYCBkb2VzIHNvIHdlIGNhbiBkZXRlY3QgaWYgaXQncyBjYXB0dXJlZFxuICAgICAgICAgIC8vIGJ5IHVzZXJzcGFjZS5cbiAgICAgICAgICB0aHJvdyBlbnRhbmdsZWRBY3Rpb25UaGVuYWJsZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgIGhvb2suYmFzZVN0YXRlID0gbmV3QmFzZVN0YXRlO1xuICAgIGhvb2suYmFzZVF1ZXVlID0gbmV3QmFzZVF1ZXVlTGFzdDtcbiAgICBxdWV1ZS5sYXN0UmVuZGVyZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICB9XG5cbiAgaWYgKGJhc2VRdWV1ZSA9PT0gbnVsbCkge1xuICAgIC8vIGBxdWV1ZS5sYW5lc2AgaXMgdXNlZCBmb3IgZW50YW5nbGluZyB0cmFuc2l0aW9ucy4gV2UgY2FuIHNldCBpdCBiYWNrIHRvXG4gICAgLy8gemVybyBvbmNlIHRoZSBxdWV1ZSBpcyBlbXB0eS5cbiAgICBxdWV1ZS5sYW5lcyA9IE5vTGFuZXM7XG4gIH1cblxuICB2YXIgZGlzcGF0Y2ggPSBxdWV1ZS5kaXNwYXRjaDtcbiAgcmV0dXJuIFtob29rLm1lbW9pemVkU3RhdGUsIGRpc3BhdGNoXTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIHF1ZXVlID0gaG9vay5xdWV1ZTtcblxuICBpZiAocXVldWUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBoYXZlIGEgcXVldWUuIFRoaXMgaXMgbGlrZWx5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHF1ZXVlLmxhc3RSZW5kZXJlZFJlZHVjZXIgPSByZWR1Y2VyOyAvLyBUaGlzIGlzIGEgcmUtcmVuZGVyLiBBcHBseSB0aGUgbmV3IHJlbmRlciBwaGFzZSB1cGRhdGVzIHRvIHRoZSBwcmV2aW91c1xuICAvLyB3b3JrLWluLXByb2dyZXNzIGhvb2suXG5cbiAgdmFyIGRpc3BhdGNoID0gcXVldWUuZGlzcGF0Y2g7XG4gIHZhciBsYXN0UmVuZGVyUGhhc2VVcGRhdGUgPSBxdWV1ZS5wZW5kaW5nO1xuICB2YXIgbmV3U3RhdGUgPSBob29rLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKGxhc3RSZW5kZXJQaGFzZVVwZGF0ZSAhPT0gbnVsbCkge1xuICAgIC8vIFRoZSBxdWV1ZSBkb2Vzbid0IHBlcnNpc3QgcGFzdCB0aGlzIHJlbmRlciBwYXNzLlxuICAgIHF1ZXVlLnBlbmRpbmcgPSBudWxsO1xuICAgIHZhciBmaXJzdFJlbmRlclBoYXNlVXBkYXRlID0gbGFzdFJlbmRlclBoYXNlVXBkYXRlLm5leHQ7XG4gICAgdmFyIHVwZGF0ZSA9IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGU7XG5cbiAgICBkbyB7XG4gICAgICAvLyBQcm9jZXNzIHRoaXMgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gV2UgZG9uJ3QgaGF2ZSB0byBjaGVjayB0aGVcbiAgICAgIC8vIHByaW9yaXR5IGJlY2F1c2UgaXQgd2lsbCBhbHdheXMgYmUgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnRcbiAgICAgIC8vIHJlbmRlcidzLlxuICAgICAgdmFyIGFjdGlvbiA9IHVwZGF0ZS5hY3Rpb247XG4gICAgICBuZXdTdGF0ZSA9IHJlZHVjZXIobmV3U3RhdGUsIGFjdGlvbik7XG4gICAgICB1cGRhdGUgPSB1cGRhdGUubmV4dDtcbiAgICB9IHdoaWxlICh1cGRhdGUgIT09IGZpcnN0UmVuZGVyUGhhc2VVcGRhdGUpOyAvLyBNYXJrIHRoYXQgdGhlIGZpYmVyIHBlcmZvcm1lZCB3b3JrLCBidXQgb25seSBpZiB0aGUgbmV3IHN0YXRlIGlzXG4gICAgLy8gZGlmZmVyZW50IGZyb20gdGhlIGN1cnJlbnQgc3RhdGUuXG5cblxuICAgIGlmICghb2JqZWN0SXMobmV3U3RhdGUsIGhvb2subWVtb2l6ZWRTdGF0ZSkpIHtcbiAgICAgIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCk7XG4gICAgfVxuXG4gICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7IC8vIERvbid0IHBlcnNpc3QgdGhlIHN0YXRlIGFjY3VtdWxhdGVkIGZyb20gdGhlIHJlbmRlciBwaGFzZSB1cGRhdGVzIHRvXG4gICAgLy8gdGhlIGJhc2Ugc3RhdGUgdW5sZXNzIHRoZSBxdWV1ZSBpcyBlbXB0eS5cbiAgICAvLyBUT0RPOiBOb3Qgc3VyZSBpZiB0aGlzIGlzIHRoZSBkZXNpcmVkIHNlbWFudGljcywgYnV0IGl0J3Mgd2hhdCB3ZVxuICAgIC8vIGRvIGZvciBnRFNGUC4gSSBjYW4ndCByZW1lbWJlciB3aHkuXG5cbiAgICBpZiAoaG9vay5iYXNlUXVldWUgPT09IG51bGwpIHtcbiAgICAgIGhvb2suYmFzZVN0YXRlID0gbmV3U3RhdGU7XG4gICAgfVxuXG4gICAgcXVldWUubGFzdFJlbmRlcmVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgfVxuXG4gIHJldHVybiBbbmV3U3RhdGUsIGRpc3BhdGNoXTtcbn1cblxuZnVuY3Rpb24gbW91bnRTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICB2YXIgZmliZXIgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxO1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0U25hcHNob3Q7XG4gIHZhciBpc0h5ZHJhdGluZyA9IGdldElzSHlkcmF0aW5nKCk7XG5cbiAgaWYgKGlzSHlkcmF0aW5nKSB7XG4gICAgaWYgKGdldFNlcnZlclNuYXBzaG90ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyBnZXRTZXJ2ZXJTbmFwc2hvdCwgd2hpY2ggaXMgcmVxdWlyZWQgZm9yICcgKyAnc2VydmVyLXJlbmRlcmVkIGNvbnRlbnQuIFdpbGwgcmV2ZXJ0IHRvIGNsaWVudCByZW5kZXJpbmcuJyk7XG4gICAgfVxuXG4gICAgbmV4dFNuYXBzaG90ID0gZ2V0U2VydmVyU25hcHNob3QoKTtcblxuICAgIHtcbiAgICAgIGlmICghZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QpIHtcbiAgICAgICAgaWYgKG5leHRTbmFwc2hvdCAhPT0gZ2V0U2VydmVyU25hcHNob3QoKSkge1xuICAgICAgICAgIGVycm9yKCdUaGUgcmVzdWx0IG9mIGdldFNlcnZlclNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCcpO1xuXG4gICAgICAgICAgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5leHRTbmFwc2hvdCA9IGdldFNuYXBzaG90KCk7XG5cbiAgICB7XG4gICAgICBpZiAoIWRpZFdhcm5VbmNhY2hlZEdldFNuYXBzaG90KSB7XG4gICAgICAgIHZhciBjYWNoZWRTbmFwc2hvdCA9IGdldFNuYXBzaG90KCk7XG5cbiAgICAgICAgaWYgKCFvYmplY3RJcyhuZXh0U25hcHNob3QsIGNhY2hlZFNuYXBzaG90KSkge1xuICAgICAgICAgIGVycm9yKCdUaGUgcmVzdWx0IG9mIGdldFNuYXBzaG90IHNob3VsZCBiZSBjYWNoZWQgdG8gYXZvaWQgYW4gaW5maW5pdGUgbG9vcCcpO1xuXG4gICAgICAgICAgZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSAvLyBVbmxlc3Mgd2UncmUgcmVuZGVyaW5nIGEgYmxvY2tpbmcgbGFuZSwgc2NoZWR1bGUgYSBjb25zaXN0ZW5jeSBjaGVjay5cbiAgICAvLyBSaWdodCBiZWZvcmUgY29tbWl0dGluZywgd2Ugd2lsbCB3YWxrIHRoZSB0cmVlIGFuZCBjaGVjayBpZiBhbnkgb2YgdGhlXG4gICAgLy8gc3RvcmVzIHdlcmUgbXV0YXRlZC5cbiAgICAvL1xuICAgIC8vIFdlIHdvbid0IGRvIHRoaXMgaWYgd2UncmUgaHlkcmF0aW5nIHNlcnZlci1yZW5kZXJlZCBjb250ZW50LCBiZWNhdXNlIGlmXG4gICAgLy8gdGhlIGNvbnRlbnQgaXMgc3RhbGUsIGl0J3MgYWxyZWFkeSB2aXNpYmxlIGFueXdheS4gSW5zdGVhZCB3ZSdsbCBwYXRjaFxuICAgIC8vIGl0IHVwIGluIGEgcGFzc2l2ZSBlZmZlY3QuXG5cblxuICAgIHZhciByb290ID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCk7XG5cbiAgICBpZiAocm9vdCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBhIHdvcmstaW4tcHJvZ3Jlc3Mgcm9vdC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuXG4gICAgdmFyIHJvb3RSZW5kZXJMYW5lcyA9IGdldFdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKCk7XG5cbiAgICBpZiAoIWluY2x1ZGVzQmxvY2tpbmdMYW5lKHJvb3QsIHJvb3RSZW5kZXJMYW5lcykpIHtcbiAgICAgIHB1c2hTdG9yZUNvbnNpc3RlbmN5Q2hlY2soZmliZXIsIGdldFNuYXBzaG90LCBuZXh0U25hcHNob3QpO1xuICAgIH1cbiAgfSAvLyBSZWFkIHRoZSBjdXJyZW50IHNuYXBzaG90IGZyb20gdGhlIHN0b3JlIG9uIGV2ZXJ5IHJlbmRlci4gVGhpcyBicmVha3MgdGhlXG4gIC8vIG5vcm1hbCBydWxlcyBvZiBSZWFjdCwgYW5kIG9ubHkgd29ya3MgYmVjYXVzZSBzdG9yZSB1cGRhdGVzIGFyZVxuICAvLyBhbHdheXMgc3luY2hyb25vdXMuXG5cblxuICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXh0U25hcHNob3Q7XG4gIHZhciBpbnN0ID0ge1xuICAgIHZhbHVlOiBuZXh0U25hcHNob3QsXG4gICAgZ2V0U25hcHNob3Q6IGdldFNuYXBzaG90XG4gIH07XG4gIGhvb2sucXVldWUgPSBpbnN0OyAvLyBTY2hlZHVsZSBhbiBlZmZlY3QgdG8gc3Vic2NyaWJlIHRvIHRoZSBzdG9yZS5cblxuICBtb3VudEVmZmVjdChzdWJzY3JpYmVUb1N0b3JlLmJpbmQobnVsbCwgZmliZXIsIGluc3QsIHN1YnNjcmliZSksIFtzdWJzY3JpYmVdKTsgLy8gU2NoZWR1bGUgYW4gZWZmZWN0IHRvIHVwZGF0ZSB0aGUgbXV0YWJsZSBpbnN0YW5jZSBmaWVsZHMuIFdlIHdpbGwgdXBkYXRlXG4gIC8vIHRoaXMgd2hlbmV2ZXIgc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgb3IgdmFsdWUgY2hhbmdlcy4gQmVjYXVzZSB0aGVyZSdzIG5vXG4gIC8vIGNsZWFuLXVwIGZ1bmN0aW9uLCBhbmQgd2UgdHJhY2sgdGhlIGRlcHMgY29ycmVjdGx5LCB3ZSBjYW4gY2FsbCBwdXNoRWZmZWN0XG4gIC8vIGRpcmVjdGx5LCB3aXRob3V0IHN0b3JpbmcgYW55IGFkZGl0aW9uYWwgc3RhdGUuIEZvciB0aGUgc2FtZSByZWFzb24sIHdlXG4gIC8vIGRvbid0IG5lZWQgdG8gc2V0IGEgc3RhdGljIGZsYWcsIGVpdGhlci5cblxuICBmaWJlci5mbGFncyB8PSBQYXNzaXZlJDE7XG4gIHB1c2hFZmZlY3QoSGFzRWZmZWN0IHwgUGFzc2l2ZSwgdXBkYXRlU3RvcmVJbnN0YW5jZS5iaW5kKG51bGwsIGZpYmVyLCBpbnN0LCBuZXh0U25hcHNob3QsIGdldFNuYXBzaG90KSwgY3JlYXRlRWZmZWN0SW5zdGFuY2UoKSwgbnVsbCk7XG4gIHJldHVybiBuZXh0U25hcHNob3Q7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gIHZhciBmaWJlciA9IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDE7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7IC8vIFJlYWQgdGhlIGN1cnJlbnQgc25hcHNob3QgZnJvbSB0aGUgc3RvcmUgb24gZXZlcnkgcmVuZGVyLiBUaGlzIGJyZWFrcyB0aGVcbiAgLy8gbm9ybWFsIHJ1bGVzIG9mIFJlYWN0LCBhbmQgb25seSB3b3JrcyBiZWNhdXNlIHN0b3JlIHVwZGF0ZXMgYXJlXG4gIC8vIGFsd2F5cyBzeW5jaHJvbm91cy5cblxuICB2YXIgbmV4dFNuYXBzaG90O1xuICB2YXIgaXNIeWRyYXRpbmcgPSBnZXRJc0h5ZHJhdGluZygpO1xuXG4gIGlmIChpc0h5ZHJhdGluZykge1xuICAgIC8vIE5lZWRlZCBmb3Igc3RyaWN0IG1vZGUgZG91YmxlIHJlbmRlclxuICAgIGlmIChnZXRTZXJ2ZXJTbmFwc2hvdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ01pc3NpbmcgZ2V0U2VydmVyU25hcHNob3QsIHdoaWNoIGlzIHJlcXVpcmVkIGZvciAnICsgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBXaWxsIHJldmVydCB0byBjbGllbnQgcmVuZGVyaW5nLicpO1xuICAgIH1cblxuICAgIG5leHRTbmFwc2hvdCA9IGdldFNlcnZlclNuYXBzaG90KCk7XG4gIH0gZWxzZSB7XG4gICAgbmV4dFNuYXBzaG90ID0gZ2V0U25hcHNob3QoKTtcblxuICAgIHtcbiAgICAgIGlmICghZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QpIHtcbiAgICAgICAgdmFyIGNhY2hlZFNuYXBzaG90ID0gZ2V0U25hcHNob3QoKTtcblxuICAgICAgICBpZiAoIW9iamVjdElzKG5leHRTbmFwc2hvdCwgY2FjaGVkU25hcHNob3QpKSB7XG4gICAgICAgICAgZXJyb3IoJ1RoZSByZXN1bHQgb2YgZ2V0U25hcHNob3Qgc2hvdWxkIGJlIGNhY2hlZCB0byBhdm9pZCBhbiBpbmZpbml0ZSBsb29wJyk7XG5cbiAgICAgICAgICBkaWRXYXJuVW5jYWNoZWRHZXRTbmFwc2hvdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgcHJldlNuYXBzaG90ID0gKGN1cnJlbnRIb29rIHx8IGhvb2spLm1lbW9pemVkU3RhdGU7XG4gIHZhciBzbmFwc2hvdENoYW5nZWQgPSAhb2JqZWN0SXMocHJldlNuYXBzaG90LCBuZXh0U25hcHNob3QpO1xuXG4gIGlmIChzbmFwc2hvdENoYW5nZWQpIHtcbiAgICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXh0U25hcHNob3Q7XG4gICAgbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKTtcbiAgfVxuXG4gIHZhciBpbnN0ID0gaG9vay5xdWV1ZTtcbiAgdXBkYXRlRWZmZWN0KHN1YnNjcmliZVRvU3RvcmUuYmluZChudWxsLCBmaWJlciwgaW5zdCwgc3Vic2NyaWJlKSwgW3N1YnNjcmliZV0pOyAvLyBXaGVuZXZlciBnZXRTbmFwc2hvdCBvciBzdWJzY3JpYmUgY2hhbmdlcywgd2UgbmVlZCB0byBjaGVjayBpbiB0aGVcbiAgLy8gY29tbWl0IHBoYXNlIGlmIHRoZXJlIHdhcyBhbiBpbnRlcmxlYXZlZCBtdXRhdGlvbi4gSW4gY29uY3VycmVudCBtb2RlXG4gIC8vIHRoaXMgY2FuIGhhcHBlbiBhbGwgdGhlIHRpbWUsIGJ1dCBldmVuIGluIHN5bmNocm9ub3VzIG1vZGUsIGFuIGVhcmxpZXJcbiAgLy8gZWZmZWN0IG1heSBoYXZlIG11dGF0ZWQgdGhlIHN0b3JlLlxuXG4gIGlmIChpbnN0LmdldFNuYXBzaG90ICE9PSBnZXRTbmFwc2hvdCB8fCBzbmFwc2hvdENoYW5nZWQgfHwgLy8gQ2hlY2sgaWYgdGhlIHN1YnNjcmliZSBmdW5jdGlvbiBjaGFuZ2VkLiBXZSBjYW4gc2F2ZSBzb21lIG1lbW9yeSBieVxuICAvLyBjaGVja2luZyB3aGV0aGVyIHdlIHNjaGVkdWxlZCBhIHN1YnNjcmlwdGlvbiBlZmZlY3QgYWJvdmUuXG4gIHdvcmtJblByb2dyZXNzSG9vayAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzc0hvb2subWVtb2l6ZWRTdGF0ZS50YWcgJiBIYXNFZmZlY3QpIHtcbiAgICBmaWJlci5mbGFncyB8PSBQYXNzaXZlJDE7XG4gICAgcHVzaEVmZmVjdChIYXNFZmZlY3QgfCBQYXNzaXZlLCB1cGRhdGVTdG9yZUluc3RhbmNlLmJpbmQobnVsbCwgZmliZXIsIGluc3QsIG5leHRTbmFwc2hvdCwgZ2V0U25hcHNob3QpLCBjcmVhdGVFZmZlY3RJbnN0YW5jZSgpLCBudWxsKTsgLy8gVW5sZXNzIHdlJ3JlIHJlbmRlcmluZyBhIGJsb2NraW5nIGxhbmUsIHNjaGVkdWxlIGEgY29uc2lzdGVuY3kgY2hlY2suXG4gICAgLy8gUmlnaHQgYmVmb3JlIGNvbW1pdHRpbmcsIHdlIHdpbGwgd2FsayB0aGUgdHJlZSBhbmQgY2hlY2sgaWYgYW55IG9mIHRoZVxuICAgIC8vIHN0b3JlcyB3ZXJlIG11dGF0ZWQuXG5cbiAgICB2YXIgcm9vdCA9IGdldFdvcmtJblByb2dyZXNzUm9vdCgpO1xuXG4gICAgaWYgKHJvb3QgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYSB3b3JrLWluLXByb2dyZXNzIHJvb3QuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cblxuICAgIGlmICghaXNIeWRyYXRpbmcgJiYgIWluY2x1ZGVzQmxvY2tpbmdMYW5lKHJvb3QsIHJlbmRlckxhbmVzKSkge1xuICAgICAgcHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayhmaWJlciwgZ2V0U25hcHNob3QsIG5leHRTbmFwc2hvdCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5leHRTbmFwc2hvdDtcbn1cblxuZnVuY3Rpb24gcHVzaFN0b3JlQ29uc2lzdGVuY3lDaGVjayhmaWJlciwgZ2V0U25hcHNob3QsIHJlbmRlcmVkU25hcHNob3QpIHtcbiAgZmliZXIuZmxhZ3MgfD0gU3RvcmVDb25zaXN0ZW5jeTtcbiAgdmFyIGNoZWNrID0ge1xuICAgIGdldFNuYXBzaG90OiBnZXRTbmFwc2hvdCxcbiAgICB2YWx1ZTogcmVuZGVyZWRTbmFwc2hvdFxuICB9O1xuICB2YXIgY29tcG9uZW50VXBkYXRlUXVldWUgPSBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlO1xuXG4gIGlmIChjb21wb25lbnRVcGRhdGVRdWV1ZSA9PT0gbnVsbCkge1xuICAgIGNvbXBvbmVudFVwZGF0ZVF1ZXVlID0gY3JlYXRlRnVuY3Rpb25Db21wb25lbnRVcGRhdGVRdWV1ZSgpO1xuICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEudXBkYXRlUXVldWUgPSBjb21wb25lbnRVcGRhdGVRdWV1ZTtcbiAgICBjb21wb25lbnRVcGRhdGVRdWV1ZS5zdG9yZXMgPSBbY2hlY2tdO1xuICB9IGVsc2Uge1xuICAgIHZhciBzdG9yZXMgPSBjb21wb25lbnRVcGRhdGVRdWV1ZS5zdG9yZXM7XG5cbiAgICBpZiAoc3RvcmVzID09PSBudWxsKSB7XG4gICAgICBjb21wb25lbnRVcGRhdGVRdWV1ZS5zdG9yZXMgPSBbY2hlY2tdO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdG9yZXMucHVzaChjaGVjayk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0b3JlSW5zdGFuY2UoZmliZXIsIGluc3QsIG5leHRTbmFwc2hvdCwgZ2V0U25hcHNob3QpIHtcbiAgLy8gVGhlc2UgYXJlIHVwZGF0ZWQgaW4gdGhlIHBhc3NpdmUgcGhhc2VcbiAgaW5zdC52YWx1ZSA9IG5leHRTbmFwc2hvdDtcbiAgaW5zdC5nZXRTbmFwc2hvdCA9IGdldFNuYXBzaG90OyAvLyBTb21ldGhpbmcgbWF5IGhhdmUgYmVlbiBtdXRhdGVkIGluIGJldHdlZW4gcmVuZGVyIGFuZCBjb21taXQuIFRoaXMgY291bGRcbiAgLy8gaGF2ZSBiZWVuIGluIGFuIGV2ZW50IHRoYXQgZmlyZWQgYmVmb3JlIHRoZSBwYXNzaXZlIGVmZmVjdHMsIG9yIGl0IGNvdWxkXG4gIC8vIGhhdmUgYmVlbiBpbiBhIGxheW91dCBlZmZlY3QuIEluIHRoYXQgY2FzZSwgd2Ugd291bGQgaGF2ZSB1c2VkIHRoZSBvbGRcbiAgLy8gc25hcHNobyBhbmQgZ2V0U25hcHNob3QgdmFsdWVzIHRvIGJhaWwgb3V0LiBXZSBuZWVkIHRvIGNoZWNrIG9uZSBtb3JlIHRpbWUuXG5cbiAgaWYgKGNoZWNrSWZTbmFwc2hvdENoYW5nZWQoaW5zdCkpIHtcbiAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cbiAgICBmb3JjZVN0b3JlUmVyZW5kZXIoZmliZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN1YnNjcmliZVRvU3RvcmUoZmliZXIsIGluc3QsIHN1YnNjcmliZSkge1xuICB2YXIgaGFuZGxlU3RvcmVDaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gVGhlIHN0b3JlIGNoYW5nZWQuIENoZWNrIGlmIHRoZSBzbmFwc2hvdCBjaGFuZ2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgd2VcbiAgICAvLyByZWFkIGZyb20gdGhlIHN0b3JlLlxuICAgIGlmIChjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpKSB7XG4gICAgICAvLyBGb3JjZSBhIHJlLXJlbmRlci5cbiAgICAgIGZvcmNlU3RvcmVSZXJlbmRlcihmaWJlcik7XG4gICAgfVxuICB9OyAvLyBTdWJzY3JpYmUgdG8gdGhlIHN0b3JlIGFuZCByZXR1cm4gYSBjbGVhbi11cCBmdW5jdGlvbi5cblxuXG4gIHJldHVybiBzdWJzY3JpYmUoaGFuZGxlU3RvcmVDaGFuZ2UpO1xufVxuXG5mdW5jdGlvbiBjaGVja0lmU25hcHNob3RDaGFuZ2VkKGluc3QpIHtcbiAgdmFyIGxhdGVzdEdldFNuYXBzaG90ID0gaW5zdC5nZXRTbmFwc2hvdDtcbiAgdmFyIHByZXZWYWx1ZSA9IGluc3QudmFsdWU7XG5cbiAgdHJ5IHtcbiAgICB2YXIgbmV4dFZhbHVlID0gbGF0ZXN0R2V0U25hcHNob3QoKTtcbiAgICByZXR1cm4gIW9iamVjdElzKHByZXZWYWx1ZSwgbmV4dFZhbHVlKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JjZVN0b3JlUmVyZW5kZXIoZmliZXIpIHtcbiAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIFN5bmNMYW5lKTtcblxuICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgU3luY0xhbmUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50U3RhdGVJbXBsKGluaXRpYWxTdGF0ZSkge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG5cbiAgaWYgKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgaW5pdGlhbFN0YXRlSW5pdGlhbGl6ZXIgPSBpbml0aWFsU3RhdGU7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV06IEZsb3cgZG9lc24ndCBsaWtlIG1peGVkIHR5cGVzXG5cbiAgICBpbml0aWFsU3RhdGUgPSBpbml0aWFsU3RhdGVJbml0aWFsaXplcigpO1xuXG4gICAgaWYgKHNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWKSB7XG4gICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXTogRmxvdyBkb2Vzbid0IGxpa2UgbWl4ZWQgdHlwZXNcblxuICAgICAgaW5pdGlhbFN0YXRlSW5pdGlhbGl6ZXIoKTtcbiAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBob29rLm1lbW9pemVkU3RhdGUgPSBob29rLmJhc2VTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgdmFyIHF1ZXVlID0ge1xuICAgIHBlbmRpbmc6IG51bGwsXG4gICAgbGFuZXM6IE5vTGFuZXMsXG4gICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogYmFzaWNTdGF0ZVJlZHVjZXIsXG4gICAgbGFzdFJlbmRlcmVkU3RhdGU6IGluaXRpYWxTdGF0ZVxuICB9O1xuICBob29rLnF1ZXVlID0gcXVldWU7XG4gIHJldHVybiBob29rO1xufVxuXG5mdW5jdGlvbiBtb3VudFN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICB2YXIgaG9vayA9IG1vdW50U3RhdGVJbXBsKGluaXRpYWxTdGF0ZSk7XG4gIHZhciBxdWV1ZSA9IGhvb2sucXVldWU7XG4gIHZhciBkaXNwYXRjaCA9IGRpc3BhdGNoU2V0U3RhdGUuYmluZChudWxsLCBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLCBxdWV1ZSk7XG4gIHF1ZXVlLmRpc3BhdGNoID0gZGlzcGF0Y2g7XG4gIHJldHVybiBbaG9vay5tZW1vaXplZFN0YXRlLCBkaXNwYXRjaF07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN0YXRlKGluaXRpYWxTdGF0ZSkge1xuICByZXR1cm4gdXBkYXRlUmVkdWNlcihiYXNpY1N0YXRlUmVkdWNlcik7XG59XG5cbmZ1bmN0aW9uIHJlcmVuZGVyU3RhdGUoaW5pdGlhbFN0YXRlKSB7XG4gIHJldHVybiByZXJlbmRlclJlZHVjZXIoYmFzaWNTdGF0ZVJlZHVjZXIpO1xufVxuXG5mdW5jdGlvbiBtb3VudE9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBob29rLmJhc2VTdGF0ZSA9IHBhc3N0aHJvdWdoO1xuICB2YXIgcXVldWUgPSB7XG4gICAgcGVuZGluZzogbnVsbCxcbiAgICBsYW5lczogTm9MYW5lcyxcbiAgICBkaXNwYXRjaDogbnVsbCxcbiAgICAvLyBPcHRpbWlzdGljIHN0YXRlIGRvZXMgbm90IHVzZSB0aGUgZWFnZXIgdXBkYXRlIG9wdGltaXphdGlvbi5cbiAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBudWxsLFxuICAgIGxhc3RSZW5kZXJlZFN0YXRlOiBudWxsXG4gIH07XG4gIGhvb2sucXVldWUgPSBxdWV1ZTsgLy8gVGhpcyBpcyBkaWZmZXJlbnQgdGhhbiB0aGUgbm9ybWFsIHNldFN0YXRlIGZ1bmN0aW9uLlxuXG4gIHZhciBkaXNwYXRjaCA9IGRpc3BhdGNoT3B0aW1pc3RpY1NldFN0YXRlLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSwgdHJ1ZSwgcXVldWUpO1xuICBxdWV1ZS5kaXNwYXRjaCA9IGRpc3BhdGNoO1xuICByZXR1cm4gW3Bhc3N0aHJvdWdoLCBkaXNwYXRjaF07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgcmV0dXJuIHVwZGF0ZU9wdGltaXN0aWNJbXBsKGhvb2ssIGN1cnJlbnRIb29rLCBwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU9wdGltaXN0aWNJbXBsKGhvb2ssIGN1cnJlbnQsIHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gIC8vIE9wdGltaXN0aWMgdXBkYXRlcyBhcmUgYWx3YXlzIHJlYmFzZWQgb24gdG9wIG9mIHRoZSBsYXRlc3QgdmFsdWUgcGFzc2VkIGluXG4gIC8vIGFzIGFuIGFyZ3VtZW50LiBJdCdzIGNhbGxlZCBhIHBhc3N0aHJvdWdoIGJlY2F1c2UgaWYgdGhlcmUgYXJlIG5vIHBlbmRpbmdcbiAgLy8gdXBkYXRlcywgaXQgd2lsbCBiZSByZXR1cm5lZCBhcy1pcy5cbiAgLy9cbiAgLy8gUmVzZXQgdGhlIGJhc2Ugc3RhdGUgdG8gdGhlIHBhc3N0aHJvdWdoLiBGdXR1cmUgdXBkYXRlcyB3aWxsIGJlIGFwcGxpZWRcbiAgLy8gb24gdG9wIG9mIHRoaXMuXG4gIGhvb2suYmFzZVN0YXRlID0gcGFzc3Rocm91Z2g7IC8vIElmIGEgcmVkdWNlciBpcyBub3QgcHJvdmlkZWQsIGRlZmF1bHQgdG8gdGhlIHNhbWUgb25lIHVzZWQgYnkgdXNlU3RhdGUuXG5cbiAgdmFyIHJlc29sdmVkUmVkdWNlciA9IHR5cGVvZiByZWR1Y2VyID09PSAnZnVuY3Rpb24nID8gcmVkdWNlciA6IGJhc2ljU3RhdGVSZWR1Y2VyO1xuICByZXR1cm4gdXBkYXRlUmVkdWNlckltcGwoaG9vaywgY3VycmVudEhvb2ssIHJlc29sdmVkUmVkdWNlcik7XG59XG5cbmZ1bmN0aW9uIHJlcmVuZGVyT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICAvLyBVbmxpa2UgdXNlU3RhdGUsIHVzZU9wdGltaXN0aWMgZG9lc24ndCBzdXBwb3J0IHJlbmRlciBwaGFzZSB1cGRhdGVzLlxuICAvLyBBbHNvIHVubGlrZSB1c2VTdGF0ZSwgd2UgbmVlZCB0byByZXBsYXkgYWxsIHBlbmRpbmcgdXBkYXRlcyBhZ2FpbiBpbiBjYXNlXG4gIC8vIHRoZSBwYXNzdGhyb3VnaCB2YWx1ZSBjaGFuZ2VkLlxuICAvL1xuICAvLyBTbyBpbnN0ZWFkIG9mIGEgZm9ya2VkIHJlLXJlbmRlciBpbXBsZW1lbnRhdGlvbiB0aGF0IGtub3dzIGhvdyB0byBoYW5kbGVcbiAgLy8gcmVuZGVyIHBoYXNlIHVkcGF0ZXMsIHdlIGNhbiB1c2UgdGhlIHNhbWUgaW1wbGVtZW50YXRpb24gYXMgZHVyaW5nIGFcbiAgLy8gcmVndWxhciBtb3VudCBvciB1cGRhdGUuXG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG5cbiAgaWYgKGN1cnJlbnRIb29rICE9PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyBhbiB1cGRhdGUuIFByb2Nlc3MgdGhlIHVwZGF0ZSBxdWV1ZS5cbiAgICByZXR1cm4gdXBkYXRlT3B0aW1pc3RpY0ltcGwoaG9vaywgY3VycmVudEhvb2ssIHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbiAgfSAvLyBUaGlzIGlzIGEgbW91bnQuIE5vIHVwZGF0ZXMgdG8gcHJvY2Vzcy5cbiAgLy8gUmVzZXQgdGhlIGJhc2Ugc3RhdGUgdG8gdGhlIHBhc3N0aHJvdWdoLiBGdXR1cmUgdXBkYXRlcyB3aWxsIGJlIGFwcGxpZWRcbiAgLy8gb24gdG9wIG9mIHRoaXMuXG5cblxuICBob29rLmJhc2VTdGF0ZSA9IHBhc3N0aHJvdWdoO1xuICB2YXIgZGlzcGF0Y2ggPSBob29rLnF1ZXVlLmRpc3BhdGNoO1xuICByZXR1cm4gW3Bhc3N0aHJvdWdoLCBkaXNwYXRjaF07XG59IC8vIHVzZUFjdGlvblN0YXRlIGFjdGlvbnMgcnVuIHNlcXVlbnRpYWxseSwgYmVjYXVzZSBlYWNoIGFjdGlvbiByZWNlaXZlcyB0aGVcbi8vIHByZXZpb3VzIHN0YXRlIGFzIGFuIGFyZ3VtZW50LiBXZSBzdG9yZSBwZW5kaW5nIGFjdGlvbnMgb24gYSBxdWV1ZS5cblxuXG5mdW5jdGlvbiBkaXNwYXRjaEFjdGlvblN0YXRlKGZpYmVyLCBhY3Rpb25RdWV1ZSwgc2V0UGVuZGluZ1N0YXRlLCBzZXRTdGF0ZSwgcGF5bG9hZCkge1xuICBpZiAoaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1cGRhdGUgZm9ybSBzdGF0ZSB3aGlsZSByZW5kZXJpbmcuJyk7XG4gIH1cblxuICB2YXIgbGFzdCA9IGFjdGlvblF1ZXVlLnBlbmRpbmc7XG5cbiAgaWYgKGxhc3QgPT09IG51bGwpIHtcbiAgICAvLyBUaGVyZSBhcmUgbm8gcGVuZGluZyBhY3Rpb25zOyB0aGlzIGlzIHRoZSBmaXJzdCBvbmUuIFdlIGNhbiBydW5cbiAgICAvLyBpdCBpbW1lZGlhdGVseS5cbiAgICB2YXIgbmV3TGFzdCA9IHtcbiAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICBuZXh0OiBudWxsIC8vIGNpcmN1bGFyXG5cbiAgICB9O1xuICAgIG5ld0xhc3QubmV4dCA9IGFjdGlvblF1ZXVlLnBlbmRpbmcgPSBuZXdMYXN0O1xuICAgIHJ1bkFjdGlvblN0YXRlQWN0aW9uKGFjdGlvblF1ZXVlLCBzZXRQZW5kaW5nU3RhdGUsIHNldFN0YXRlLCBwYXlsb2FkKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGVyZSdzIGFscmVhZHkgYW4gYWN0aW9uIHJ1bm5pbmcuIEFkZCB0byB0aGUgcXVldWUuXG4gICAgdmFyIGZpcnN0ID0gbGFzdC5uZXh0O1xuICAgIHZhciBfbmV3TGFzdCA9IHtcbiAgICAgIHBheWxvYWQ6IHBheWxvYWQsXG4gICAgICBuZXh0OiBmaXJzdFxuICAgIH07XG4gICAgYWN0aW9uUXVldWUucGVuZGluZyA9IGxhc3QubmV4dCA9IF9uZXdMYXN0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJ1bkFjdGlvblN0YXRlQWN0aW9uKGFjdGlvblF1ZXVlLCBzZXRQZW5kaW5nU3RhdGUsIHNldFN0YXRlLCBwYXlsb2FkKSB7XG4gIHZhciBhY3Rpb24gPSBhY3Rpb25RdWV1ZS5hY3Rpb247XG4gIHZhciBwcmV2U3RhdGUgPSBhY3Rpb25RdWV1ZS5zdGF0ZTsgLy8gVGhpcyBpcyBhIGZvcmsgb2Ygc3RhcnRUcmFuc2l0aW9uXG5cbiAgdmFyIHByZXZUcmFuc2l0aW9uID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuVDtcbiAgdmFyIGN1cnJlbnRUcmFuc2l0aW9uID0ge307XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBjdXJyZW50VHJhbnNpdGlvbjtcblxuICB7XG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVC5fdXBkYXRlZEZpYmVycyA9IG5ldyBTZXQoKTtcbiAgfSAvLyBPcHRpbWlzdGljYWxseSB1cGRhdGUgdGhlIHBlbmRpbmcgc3RhdGUsIHNpbWlsYXIgdG8gdXNlVHJhbnNpdGlvbi5cbiAgLy8gVGhpcyB3aWxsIGJlIHJldmVydGVkIGF1dG9tYXRpY2FsbHkgd2hlbiBhbGwgYWN0aW9ucyBhcmUgZmluaXNoZWQuXG5cblxuICBzZXRQZW5kaW5nU3RhdGUodHJ1ZSk7XG5cbiAgdHJ5IHtcbiAgICB2YXIgcmV0dXJuVmFsdWUgPSBhY3Rpb24ocHJldlN0YXRlLCBwYXlsb2FkKTtcbiAgICB2YXIgb25TdGFydFRyYW5zaXRpb25GaW5pc2ggPSBSZWFjdFNoYXJlZEludGVybmFscy5TO1xuXG4gICAgaWYgKG9uU3RhcnRUcmFuc2l0aW9uRmluaXNoICE9PSBudWxsKSB7XG4gICAgICBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaChjdXJyZW50VHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpO1xuICAgIH1cblxuICAgIGlmIChyZXR1cm5WYWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgcmV0dXJuVmFsdWUgPT09ICdvYmplY3QnICYmIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgICB0eXBlb2YgcmV0dXJuVmFsdWUudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdmFyIHRoZW5hYmxlID0gcmV0dXJuVmFsdWU7IC8vIEF0dGFjaCBhIGxpc3RlbmVyIHRvIHJlYWQgdGhlIHJldHVybiBzdGF0ZSBvZiB0aGUgYWN0aW9uLiBBcyBzb29uIGFzXG4gICAgICAvLyB0aGlzIHJlc29sdmVzLCB3ZSBjYW4gcnVuIHRoZSBuZXh0IGFjdGlvbiBpbiB0aGUgc2VxdWVuY2UuXG5cbiAgICAgIHRoZW5hYmxlLnRoZW4oZnVuY3Rpb24gKG5leHRTdGF0ZSkge1xuICAgICAgICBhY3Rpb25RdWV1ZS5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICAgICAgZmluaXNoUnVubmluZ0FjdGlvblN0YXRlQWN0aW9uKGFjdGlvblF1ZXVlLCBzZXRQZW5kaW5nU3RhdGUsIHNldFN0YXRlKTtcbiAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGZpbmlzaFJ1bm5pbmdBY3Rpb25TdGF0ZUFjdGlvbihhY3Rpb25RdWV1ZSwgc2V0UGVuZGluZ1N0YXRlLCBzZXRTdGF0ZSk7XG4gICAgICB9KTtcbiAgICAgIHNldFN0YXRlKHRoZW5hYmxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0U3RhdGUocmV0dXJuVmFsdWUpO1xuICAgICAgdmFyIG5leHRTdGF0ZSA9IHJldHVyblZhbHVlO1xuICAgICAgYWN0aW9uUXVldWUuc3RhdGUgPSBuZXh0U3RhdGU7XG4gICAgICBmaW5pc2hSdW5uaW5nQWN0aW9uU3RhdGVBY3Rpb24oYWN0aW9uUXVldWUsIHNldFBlbmRpbmdTdGF0ZSwgc2V0U3RhdGUpO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBUaGlzIGlzIGEgdHJpY2sgdG8gZ2V0IHRoZSBgdXNlQWN0aW9uU3RhdGVgIGhvb2sgdG8gcmV0aHJvdyB0aGUgZXJyb3IuXG4gICAgLy8gV2hlbiBpdCB1bndyYXBzIHRoZSB0aGVuYWJsZSB3aXRoIHRoZSBgdXNlYCBhbGdvcml0aG0sIHRoZSBlcnJvclxuICAgIC8vIHdpbGwgYmUgdGhyb3duLlxuICAgIHZhciByZWplY3RlZFRoZW5hYmxlID0ge1xuICAgICAgdGhlbjogZnVuY3Rpb24gKCkge30sXG4gICAgICBzdGF0dXM6ICdyZWplY3RlZCcsXG4gICAgICByZWFzb246IGVycm9yIC8vICRGbG93Rml4TWU6IE5vdCBzdXJlIHdoeSB0aGlzIGRvZXNuJ3Qgd29ya1xuXG4gICAgfTtcbiAgICBzZXRTdGF0ZShyZWplY3RlZFRoZW5hYmxlKTtcbiAgICBmaW5pc2hSdW5uaW5nQWN0aW9uU3RhdGVBY3Rpb24oYWN0aW9uUXVldWUsIHNldFBlbmRpbmdTdGF0ZSwgc2V0U3RhdGUpO1xuICB9IGZpbmFsbHkge1xuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbjtcblxuICAgIHtcbiAgICAgIGlmIChwcmV2VHJhbnNpdGlvbiA9PT0gbnVsbCAmJiBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycykge1xuICAgICAgICB2YXIgdXBkYXRlZEZpYmVyc0NvdW50ID0gY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMuc2l6ZTtcblxuICAgICAgICBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5jbGVhcigpO1xuXG4gICAgICAgIGlmICh1cGRhdGVkRmliZXJzQ291bnQgPiAxMCkge1xuICAgICAgICAgIHdhcm4oJ0RldGVjdGVkIGEgbGFyZ2UgbnVtYmVyIG9mIHVwZGF0ZXMgaW5zaWRlIHN0YXJ0VHJhbnNpdGlvbi4gJyArICdJZiB0aGlzIGlzIGR1ZSB0byBhIHN1YnNjcmlwdGlvbiBwbGVhc2UgcmUtd3JpdGUgaXQgdG8gdXNlIFJlYWN0IHByb3ZpZGVkIGhvb2tzLiAnICsgJ090aGVyd2lzZSBjb25jdXJyZW50IG1vZGUgZ3VhcmFudGVlcyBhcmUgb2ZmIHRoZSB0YWJsZS4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmaW5pc2hSdW5uaW5nQWN0aW9uU3RhdGVBY3Rpb24oYWN0aW9uUXVldWUsIHNldFBlbmRpbmdTdGF0ZSwgc2V0U3RhdGUpIHtcbiAgLy8gVGhlIGFjdGlvbiBmaW5pc2hlZCBydW5uaW5nLiBQb3AgaXQgZnJvbSB0aGUgcXVldWUgYW5kIHJ1biB0aGUgbmV4dCBwZW5kaW5nXG4gIC8vIGFjdGlvbiwgaWYgdGhlcmUgYXJlIGFueS5cbiAgdmFyIGxhc3QgPSBhY3Rpb25RdWV1ZS5wZW5kaW5nO1xuXG4gIGlmIChsYXN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpcnN0ID0gbGFzdC5uZXh0O1xuXG4gICAgaWYgKGZpcnN0ID09PSBsYXN0KSB7XG4gICAgICAvLyBUaGlzIHdhcyB0aGUgbGFzdCBhY3Rpb24gaW4gdGhlIHF1ZXVlLlxuICAgICAgYWN0aW9uUXVldWUucGVuZGluZyA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlbW92ZSB0aGUgZmlyc3Qgbm9kZSBmcm9tIHRoZSBjaXJjdWxhciBxdWV1ZS5cbiAgICAgIHZhciBuZXh0ID0gZmlyc3QubmV4dDtcbiAgICAgIGxhc3QubmV4dCA9IG5leHQ7IC8vIFJ1biB0aGUgbmV4dCBhY3Rpb24uXG5cbiAgICAgIHJ1bkFjdGlvblN0YXRlQWN0aW9uKGFjdGlvblF1ZXVlLCBzZXRQZW5kaW5nU3RhdGUsIHNldFN0YXRlLCBuZXh0LnBheWxvYWQpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhY3Rpb25TdGF0ZVJlZHVjZXIob2xkU3RhdGUsIG5ld1N0YXRlKSB7XG4gIHJldHVybiBuZXdTdGF0ZTtcbn1cblxuZnVuY3Rpb24gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZVByb3AsIHBlcm1hbGluaykge1xuICB2YXIgaW5pdGlhbFN0YXRlID0gaW5pdGlhbFN0YXRlUHJvcDtcblxuICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgIHZhciByb290ID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCk7XG4gICAgdmFyIHNzckZvcm1TdGF0ZSA9IHJvb3QuZm9ybVN0YXRlOyAvLyBJZiBhIGZvcm1TdGF0ZSBvcHRpb24gd2FzIHBhc3NlZCB0byB0aGUgcm9vdCwgdGhlcmUgYXJlIGZvcm0gc3RhdGVcbiAgICAvLyBtYXJrZXJzIHRoYXQgd2UgbmVlZCB0byBoeWRyYXRlLiBUaGVzZSBpbmRpY2F0ZSB3aGV0aGVyIHRoZSBmb3JtIHN0YXRlXG4gICAgLy8gbWF0Y2hlcyB0aGlzIGhvb2sgaW5zdGFuY2UuXG5cbiAgICBpZiAoc3NyRm9ybVN0YXRlICE9PSBudWxsKSB7XG4gICAgICB2YXIgaXNNYXRjaGluZyA9IHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUZvcm1NYXJrZXJJbnN0YW5jZShjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxKTtcblxuICAgICAgaWYgKGlzTWF0Y2hpbmcpIHtcbiAgICAgICAgaW5pdGlhbFN0YXRlID0gc3NyRm9ybVN0YXRlWzBdO1xuICAgICAgfVxuICAgIH1cbiAgfSAvLyBTdGF0ZSBob29rLiBUaGUgc3RhdGUgaXMgc3RvcmVkIGluIGEgdGhlbmFibGUgd2hpY2ggaXMgdGhlbiB1bndyYXBwZWQgYnlcbiAgLy8gdGhlIGB1c2VgIGFsZ29yaXRobSBkdXJpbmcgcmVuZGVyLlxuXG5cbiAgdmFyIHN0YXRlSG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHN0YXRlSG9vay5tZW1vaXplZFN0YXRlID0gc3RhdGVIb29rLmJhc2VTdGF0ZSA9IGluaXRpYWxTdGF0ZTsgLy8gVE9ETzogVHlwaW5nIHRoaXMgXCJjb3JyZWN0bHlcIiByZXN1bHRzIGluIHJlY3Vyc2lvbiBsaW1pdCBlcnJvcnNcbiAgLy8gY29uc3Qgc3RhdGVRdWV1ZTogVXBkYXRlUXVldWU8UyB8IEF3YWl0ZWQ8Uz4sIFMgfCBBd2FpdGVkPFM+PiA9IHtcblxuICB2YXIgc3RhdGVRdWV1ZSA9IHtcbiAgICBwZW5kaW5nOiBudWxsLFxuICAgIGxhbmVzOiBOb0xhbmVzLFxuICAgIGRpc3BhdGNoOiBudWxsLFxuICAgIGxhc3RSZW5kZXJlZFJlZHVjZXI6IGFjdGlvblN0YXRlUmVkdWNlcixcbiAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFN0YXRlXG4gIH07XG4gIHN0YXRlSG9vay5xdWV1ZSA9IHN0YXRlUXVldWU7XG4gIHZhciBzZXRTdGF0ZSA9IGRpc3BhdGNoU2V0U3RhdGUuYmluZChudWxsLCBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLCBzdGF0ZVF1ZXVlKTtcbiAgc3RhdGVRdWV1ZS5kaXNwYXRjaCA9IHNldFN0YXRlOyAvLyBQZW5kaW5nIHN0YXRlLiBUaGlzIGlzIHVzZWQgdG8gc3RvcmUgdGhlIHBlbmRpbmcgc3RhdGUgb2YgdGhlIGFjdGlvbi5cbiAgLy8gVHJhY2tlZCBvcHRpbWlzdGljYWxseSwgbGlrZSBhIHRyYW5zaXRpb24gcGVuZGluZyBzdGF0ZS5cblxuICB2YXIgcGVuZGluZ1N0YXRlSG9vayA9IG1vdW50U3RhdGVJbXBsKGZhbHNlKTtcbiAgdmFyIHNldFBlbmRpbmdTdGF0ZSA9IGRpc3BhdGNoT3B0aW1pc3RpY1NldFN0YXRlLmJpbmQobnVsbCwgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSwgZmFsc2UsIHBlbmRpbmdTdGF0ZUhvb2sucXVldWUpOyAvLyBBY3Rpb24gcXVldWUgaG9vay4gVGhpcyBpcyB1c2VkIHRvIHF1ZXVlIHBlbmRpbmcgYWN0aW9ucy4gVGhlIHF1ZXVlIGlzXG4gIC8vIHNoYXJlZCBiZXR3ZWVuIGFsbCBpbnN0YW5jZXMgb2YgdGhlIGhvb2suIFNpbWlsYXIgdG8gYSByZWd1bGFyIHN0YXRlIHF1ZXVlLFxuICAvLyBidXQgZGlmZmVyZW50IGJlY2F1c2UgdGhlIGFjdGlvbnMgYXJlIHJ1biBzZXF1ZW50aWFsbHksIGFuZCB0aGV5IHJ1biBpblxuICAvLyBhbiBldmVudCBpbnN0ZWFkIG9mIGR1cmluZyByZW5kZXIuXG5cbiAgdmFyIGFjdGlvblF1ZXVlSG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBhY3Rpb25RdWV1ZSA9IHtcbiAgICBzdGF0ZTogaW5pdGlhbFN0YXRlLFxuICAgIGRpc3BhdGNoOiBudWxsLFxuICAgIC8vIGNpcmN1bGFyXG4gICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgcGVuZGluZzogbnVsbFxuICB9O1xuICBhY3Rpb25RdWV1ZUhvb2sucXVldWUgPSBhY3Rpb25RdWV1ZTtcbiAgdmFyIGRpc3BhdGNoID0gZGlzcGF0Y2hBY3Rpb25TdGF0ZS5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsIGFjdGlvblF1ZXVlLCBzZXRQZW5kaW5nU3RhdGUsIHNldFN0YXRlKTtcbiAgYWN0aW9uUXVldWUuZGlzcGF0Y2ggPSBkaXNwYXRjaDsgLy8gU3Rhc2ggdGhlIGFjdGlvbiBmdW5jdGlvbiBvbiB0aGUgbWVtb2l6ZWQgc3RhdGUgb2YgdGhlIGhvb2suIFdlJ2xsIHVzZSB0aGlzXG4gIC8vIHRvIGRldGVjdCB3aGVuIHRoZSBhY3Rpb24gZnVuY3Rpb24gY2hhbmdlcyBzbyB3ZSBjYW4gdXBkYXRlIGl0IGluXG4gIC8vIGFuIGVmZmVjdC5cblxuICBhY3Rpb25RdWV1ZUhvb2subWVtb2l6ZWRTdGF0ZSA9IGFjdGlvbjtcbiAgcmV0dXJuIFtpbml0aWFsU3RhdGUsIGRpc3BhdGNoLCBmYWxzZV07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgdmFyIHN0YXRlSG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgY3VycmVudFN0YXRlSG9vayA9IGN1cnJlbnRIb29rO1xuICByZXR1cm4gdXBkYXRlQWN0aW9uU3RhdGVJbXBsKHN0YXRlSG9vaywgY3VycmVudFN0YXRlSG9vaywgYWN0aW9uKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQWN0aW9uU3RhdGVJbXBsKHN0YXRlSG9vaywgY3VycmVudFN0YXRlSG9vaywgYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluaykge1xuICB2YXIgX3VwZGF0ZVJlZHVjZXJJbXBsID0gdXBkYXRlUmVkdWNlckltcGwoc3RhdGVIb29rLCBjdXJyZW50U3RhdGVIb29rLCBhY3Rpb25TdGF0ZVJlZHVjZXIpLFxuICAgICAgYWN0aW9uUmVzdWx0ID0gX3VwZGF0ZVJlZHVjZXJJbXBsWzBdO1xuXG4gIHZhciBfdXBkYXRlU3RhdGUgPSB1cGRhdGVTdGF0ZSgpLFxuICAgICAgaXNQZW5kaW5nID0gX3VwZGF0ZVN0YXRlWzBdOyAvLyBUaGlzIHdpbGwgc3VzcGVuZCB1bnRpbCB0aGUgYWN0aW9uIGZpbmlzaGVzLlxuXG5cbiAgdmFyIHN0YXRlID0gdHlwZW9mIGFjdGlvblJlc3VsdCA9PT0gJ29iamVjdCcgJiYgYWN0aW9uUmVzdWx0ICE9PSBudWxsICYmIC8vICRGbG93Rml4TWVbbWV0aG9kLXVuYmluZGluZ11cbiAgdHlwZW9mIGFjdGlvblJlc3VsdC50aGVuID09PSAnZnVuY3Rpb24nID8gdXNlVGhlbmFibGUoYWN0aW9uUmVzdWx0KSA6IGFjdGlvblJlc3VsdDtcbiAgdmFyIGFjdGlvblF1ZXVlSG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgYWN0aW9uUXVldWUgPSBhY3Rpb25RdWV1ZUhvb2sucXVldWU7XG4gIHZhciBkaXNwYXRjaCA9IGFjdGlvblF1ZXVlLmRpc3BhdGNoOyAvLyBDaGVjayBpZiBhIG5ldyBhY3Rpb24gd2FzIHBhc3NlZC4gSWYgc28sIHVwZGF0ZSBpdCBpbiBhbiBlZmZlY3QuXG5cbiAgdmFyIHByZXZBY3Rpb24gPSBhY3Rpb25RdWV1ZUhvb2subWVtb2l6ZWRTdGF0ZTtcblxuICBpZiAoYWN0aW9uICE9PSBwcmV2QWN0aW9uKSB7XG4gICAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSBQYXNzaXZlJDE7XG4gICAgcHVzaEVmZmVjdChIYXNFZmZlY3QgfCBQYXNzaXZlLCBhY3Rpb25TdGF0ZUFjdGlvbkVmZmVjdC5iaW5kKG51bGwsIGFjdGlvblF1ZXVlLCBhY3Rpb24pLCBjcmVhdGVFZmZlY3RJbnN0YW5jZSgpLCBudWxsKTtcbiAgfVxuXG4gIHJldHVybiBbc3RhdGUsIGRpc3BhdGNoLCBpc1BlbmRpbmddO1xufVxuXG5mdW5jdGlvbiBhY3Rpb25TdGF0ZUFjdGlvbkVmZmVjdChhY3Rpb25RdWV1ZSwgYWN0aW9uKSB7XG4gIGFjdGlvblF1ZXVlLmFjdGlvbiA9IGFjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gIC8vIFVubGlrZSB1c2VTdGF0ZSwgdXNlQWN0aW9uU3RhdGUgZG9lc24ndCBzdXBwb3J0IHJlbmRlciBwaGFzZSB1cGRhdGVzLlxuICAvLyBBbHNvIHVubGlrZSB1c2VTdGF0ZSwgd2UgbmVlZCB0byByZXBsYXkgYWxsIHBlbmRpbmcgdXBkYXRlcyBhZ2FpbiBpbiBjYXNlXG4gIC8vIHRoZSBwYXNzdGhyb3VnaCB2YWx1ZSBjaGFuZ2VkLlxuICAvL1xuICAvLyBTbyBpbnN0ZWFkIG9mIGEgZm9ya2VkIHJlLXJlbmRlciBpbXBsZW1lbnRhdGlvbiB0aGF0IGtub3dzIGhvdyB0byBoYW5kbGVcbiAgLy8gcmVuZGVyIHBoYXNlIHVkcGF0ZXMsIHdlIGNhbiB1c2UgdGhlIHNhbWUgaW1wbGVtZW50YXRpb24gYXMgZHVyaW5nIGFcbiAgLy8gcmVndWxhciBtb3VudCBvciB1cGRhdGUuXG4gIHZhciBzdGF0ZUhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIGN1cnJlbnRTdGF0ZUhvb2sgPSBjdXJyZW50SG9vaztcblxuICBpZiAoY3VycmVudFN0YXRlSG9vayAhPT0gbnVsbCkge1xuICAgIC8vIFRoaXMgaXMgYW4gdXBkYXRlLiBQcm9jZXNzIHRoZSB1cGRhdGUgcXVldWUuXG4gICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlSW1wbChzdGF0ZUhvb2ssIGN1cnJlbnRTdGF0ZUhvb2ssIGFjdGlvbik7XG4gIH1cblxuICB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTsgLy8gU3RhdGVcbiAgLy8gVGhpcyBpcyBhIG1vdW50LiBObyB1cGRhdGVzIHRvIHByb2Nlc3MuXG5cbiAgdmFyIHN0YXRlID0gc3RhdGVIb29rLm1lbW9pemVkU3RhdGU7XG4gIHZhciBhY3Rpb25RdWV1ZUhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIGFjdGlvblF1ZXVlID0gYWN0aW9uUXVldWVIb29rLnF1ZXVlO1xuICB2YXIgZGlzcGF0Y2ggPSBhY3Rpb25RdWV1ZS5kaXNwYXRjaDsgLy8gVGhpcyBtYXkgaGF2ZSBjaGFuZ2VkIGR1cmluZyB0aGUgcmVyZW5kZXIuXG5cbiAgYWN0aW9uUXVldWVIb29rLm1lbW9pemVkU3RhdGUgPSBhY3Rpb247IC8vIEZvciBtb3VudCwgcGVuZGluZyBpcyBhbHdheXMgZmFsc2UuXG5cbiAgcmV0dXJuIFtzdGF0ZSwgZGlzcGF0Y2gsIGZhbHNlXTtcbn1cblxuZnVuY3Rpb24gcHVzaEVmZmVjdCh0YWcsIGNyZWF0ZSwgaW5zdCwgZGVwcykge1xuICB2YXIgZWZmZWN0ID0ge1xuICAgIHRhZzogdGFnLFxuICAgIGNyZWF0ZTogY3JlYXRlLFxuICAgIGluc3Q6IGluc3QsXG4gICAgZGVwczogZGVwcyxcbiAgICAvLyBDaXJjdWxhclxuICAgIG5leHQ6IG51bGxcbiAgfTtcbiAgdmFyIGNvbXBvbmVudFVwZGF0ZVF1ZXVlID0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS51cGRhdGVRdWV1ZTtcblxuICBpZiAoY29tcG9uZW50VXBkYXRlUXVldWUgPT09IG51bGwpIHtcbiAgICBjb21wb25lbnRVcGRhdGVRdWV1ZSA9IGNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUoKTtcbiAgICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLnVwZGF0ZVF1ZXVlID0gY29tcG9uZW50VXBkYXRlUXVldWU7XG4gICAgY29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdCA9IGVmZmVjdC5uZXh0ID0gZWZmZWN0O1xuICB9IGVsc2Uge1xuICAgIHZhciBsYXN0RWZmZWN0ID0gY29tcG9uZW50VXBkYXRlUXVldWUubGFzdEVmZmVjdDtcblxuICAgIGlmIChsYXN0RWZmZWN0ID09PSBudWxsKSB7XG4gICAgICBjb21wb25lbnRVcGRhdGVRdWV1ZS5sYXN0RWZmZWN0ID0gZWZmZWN0Lm5leHQgPSBlZmZlY3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICAgIGxhc3RFZmZlY3QubmV4dCA9IGVmZmVjdDtcbiAgICAgIGVmZmVjdC5uZXh0ID0gZmlyc3RFZmZlY3Q7XG4gICAgICBjb21wb25lbnRVcGRhdGVRdWV1ZS5sYXN0RWZmZWN0ID0gZWZmZWN0O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlZmZlY3Q7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVmZmVjdEluc3RhbmNlKCkge1xuICByZXR1cm4ge1xuICAgIGRlc3Ryb3k6IHVuZGVmaW5lZFxuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudFJlZihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGhvb2sgPSBtb3VudFdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgcmVmID0ge1xuICAgIGN1cnJlbnQ6IGluaXRpYWxWYWx1ZVxuICB9O1xuICBob29rLm1lbW9pemVkU3RhdGUgPSByZWY7XG4gIHJldHVybiByZWY7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVJlZihpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgcmV0dXJuIGhvb2subWVtb2l6ZWRTdGF0ZTtcbn1cblxuZnVuY3Rpb24gbW91bnRFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIGhvb2tGbGFncywgY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEuZmxhZ3MgfD0gZmliZXJGbGFncztcbiAgaG9vay5tZW1vaXplZFN0YXRlID0gcHVzaEVmZmVjdChIYXNFZmZlY3QgfCBob29rRmxhZ3MsIGNyZWF0ZSwgY3JlYXRlRWZmZWN0SW5zdGFuY2UoKSwgbmV4dERlcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVFZmZlY3RJbXBsKGZpYmVyRmxhZ3MsIGhvb2tGbGFncywgY3JlYXRlLCBkZXBzKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICB2YXIgZWZmZWN0ID0gaG9vay5tZW1vaXplZFN0YXRlO1xuICB2YXIgaW5zdCA9IGVmZmVjdC5pbnN0OyAvLyBjdXJyZW50SG9vayBpcyBudWxsIG9uIGluaXRpYWwgbW91bnQgd2hlbiByZXJlbmRlcmluZyBhZnRlciBhIHJlbmRlciBwaGFzZVxuICAvLyBzdGF0ZSB1cGRhdGUgb3IgZm9yIHN0cmljdCBtb2RlLlxuXG4gIGlmIChjdXJyZW50SG9vayAhPT0gbnVsbCkge1xuICAgIGlmIChuZXh0RGVwcyAhPT0gbnVsbCkge1xuICAgICAgdmFyIHByZXZFZmZlY3QgPSBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlO1xuICAgICAgdmFyIHByZXZEZXBzID0gcHJldkVmZmVjdC5kZXBzO1xuXG4gICAgICBpZiAoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykpIHtcbiAgICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gcHVzaEVmZmVjdChob29rRmxhZ3MsIGNyZWF0ZSwgaW5zdCwgbmV4dERlcHMpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMS5mbGFncyB8PSBmaWJlckZsYWdzO1xuICBob29rLm1lbW9pemVkU3RhdGUgPSBwdXNoRWZmZWN0KEhhc0VmZmVjdCB8IGhvb2tGbGFncywgY3JlYXRlLCBpbnN0LCBuZXh0RGVwcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICBpZiAoKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubW9kZSAmIFN0cmljdEVmZmVjdHNNb2RlKSAhPT0gTm9Nb2RlICYmIChjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxLm1vZGUgJiBOb1N0cmljdFBhc3NpdmVFZmZlY3RzTW9kZSkgPT09IE5vTW9kZSkge1xuICAgIG1vdW50RWZmZWN0SW1wbChNb3VudFBhc3NpdmVEZXYgfCBQYXNzaXZlJDEgfCBQYXNzaXZlU3RhdGljLCBQYXNzaXZlLCBjcmVhdGUsIGRlcHMpO1xuICB9IGVsc2Uge1xuICAgIG1vdW50RWZmZWN0SW1wbChQYXNzaXZlJDEgfCBQYXNzaXZlU3RhdGljLCBQYXNzaXZlLCBjcmVhdGUsIGRlcHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgdXBkYXRlRWZmZWN0SW1wbChQYXNzaXZlJDEsIFBhc3NpdmUsIGNyZWF0ZSwgZGVwcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50SW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICBtb3VudEVmZmVjdEltcGwoVXBkYXRlLCBJbnNlcnRpb24sIGNyZWF0ZSwgZGVwcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpIHtcbiAgcmV0dXJuIHVwZGF0ZUVmZmVjdEltcGwoVXBkYXRlLCBJbnNlcnRpb24sIGNyZWF0ZSwgZGVwcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcykge1xuICB2YXIgZmliZXJGbGFncyA9IFVwZGF0ZSB8IExheW91dFN0YXRpYztcblxuICBpZiAoKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubW9kZSAmIFN0cmljdEVmZmVjdHNNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgZmliZXJGbGFncyB8PSBNb3VudExheW91dERldjtcbiAgfVxuXG4gIHJldHVybiBtb3VudEVmZmVjdEltcGwoZmliZXJGbGFncywgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKSB7XG4gIHJldHVybiB1cGRhdGVFZmZlY3RJbXBsKFVwZGF0ZSwgTGF5b3V0LCBjcmVhdGUsIGRlcHMpO1xufVxuXG5mdW5jdGlvbiBpbXBlcmF0aXZlSGFuZGxlRWZmZWN0KGNyZWF0ZSwgcmVmKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdmFyIHJlZkNhbGxiYWNrID0gcmVmO1xuICAgIHZhciBpbnN0ID0gY3JlYXRlKCk7XG4gICAgdmFyIHJlZkNsZWFudXAgPSByZWZDYWxsYmFjayhpbnN0KTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHR5cGVvZiByZWZDbGVhbnVwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gd2UgbmVlZCB0byBhc3N1bWUgbm8gcGFyYW1ldGVyc1xuICAgICAgICByZWZDbGVhbnVwKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZWZDYWxsYmFjayhudWxsKTtcbiAgICAgIH1cbiAgICB9O1xuICB9IGVsc2UgaWYgKHJlZiAhPT0gbnVsbCAmJiByZWYgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhciByZWZPYmplY3QgPSByZWY7XG5cbiAgICB7XG4gICAgICBpZiAoIXJlZk9iamVjdC5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudCcpKSB7XG4gICAgICAgIGVycm9yKCdFeHBlY3RlZCB1c2VJbXBlcmF0aXZlSGFuZGxlKCkgZmlyc3QgYXJndW1lbnQgdG8gZWl0aGVyIGJlIGEgJyArICdyZWYgY2FsbGJhY2sgb3IgUmVhY3QuY3JlYXRlUmVmKCkgb2JqZWN0LiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCAnYW4gb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKHJlZk9iamVjdCkuam9pbignLCAnKSArICd9Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIF9pbnN0ID0gY3JlYXRlKCk7XG5cbiAgICByZWZPYmplY3QuY3VycmVudCA9IF9pbnN0O1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICByZWZPYmplY3QuY3VycmVudCA9IG51bGw7XG4gICAgfTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtb3VudEltcGVyYXRpdmVIYW5kbGUocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY3JlYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgdXNlSW1wZXJhdGl2ZUhhbmRsZSgpIHNlY29uZCBhcmd1bWVudCB0byBiZSBhIGZ1bmN0aW9uICcgKyAndGhhdCBjcmVhdGVzIGEgaGFuZGxlLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjcmVhdGUgIT09IG51bGwgPyB0eXBlb2YgY3JlYXRlIDogJ251bGwnKTtcbiAgICB9XG4gIH0gLy8gVE9ETzogSWYgZGVwcyBhcmUgcHJvdmlkZWQsIHNob3VsZCB3ZSBza2lwIGNvbXBhcmluZyB0aGUgcmVmIGl0c2VsZj9cblxuXG4gIHZhciBlZmZlY3REZXBzID0gZGVwcyAhPT0gbnVsbCAmJiBkZXBzICE9PSB1bmRlZmluZWQgPyBkZXBzLmNvbmNhdChbcmVmXSkgOiBudWxsO1xuICB2YXIgZmliZXJGbGFncyA9IFVwZGF0ZSB8IExheW91dFN0YXRpYztcblxuICBpZiAoKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubW9kZSAmIFN0cmljdEVmZmVjdHNNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgZmliZXJGbGFncyB8PSBNb3VudExheW91dERldjtcbiAgfVxuXG4gIG1vdW50RWZmZWN0SW1wbChmaWJlckZsYWdzLCBMYXlvdXQsIGltcGVyYXRpdmVIYW5kbGVFZmZlY3QuYmluZChudWxsLCBjcmVhdGUsIHJlZiksIGVmZmVjdERlcHMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNyZWF0ZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJ0V4cGVjdGVkIHVzZUltcGVyYXRpdmVIYW5kbGUoKSBzZWNvbmQgYXJndW1lbnQgdG8gYmUgYSBmdW5jdGlvbiAnICsgJ3RoYXQgY3JlYXRlcyBhIGhhbmRsZS4gSW5zdGVhZCByZWNlaXZlZDogJXMuJywgY3JlYXRlICE9PSBudWxsID8gdHlwZW9mIGNyZWF0ZSA6ICdudWxsJyk7XG4gICAgfVxuICB9IC8vIFRPRE86IElmIGRlcHMgYXJlIHByb3ZpZGVkLCBzaG91bGQgd2Ugc2tpcCBjb21wYXJpbmcgdGhlIHJlZiBpdHNlbGY/XG5cblxuICB2YXIgZWZmZWN0RGVwcyA9IGRlcHMgIT09IG51bGwgJiYgZGVwcyAhPT0gdW5kZWZpbmVkID8gZGVwcy5jb25jYXQoW3JlZl0pIDogbnVsbDtcbiAgdXBkYXRlRWZmZWN0SW1wbChVcGRhdGUsIExheW91dCwgaW1wZXJhdGl2ZUhhbmRsZUVmZmVjdC5iaW5kKG51bGwsIGNyZWF0ZSwgcmVmKSwgZWZmZWN0RGVwcyk7XG59XG5cbmZ1bmN0aW9uIG1vdW50RGVidWdWYWx1ZSh2YWx1ZSwgZm9ybWF0dGVyRm4pIHsvLyBUaGlzIGhvb2sgaXMgbm9ybWFsbHkgYSBuby1vcC5cbiAgLy8gVGhlIHJlYWN0LWRlYnVnLWhvb2tzIHBhY2thZ2UgaW5qZWN0cyBpdHMgb3duIGltcGxlbWVudGF0aW9uXG4gIC8vIHNvIHRoYXQgZS5nLiBEZXZUb29scyBjYW4gZGlzcGxheSBjdXN0b20gaG9vayB2YWx1ZXMuXG59XG5cbnZhciB1cGRhdGVEZWJ1Z1ZhbHVlID0gbW91bnREZWJ1Z1ZhbHVlO1xuXG5mdW5jdGlvbiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIG5leHREZXBzID0gZGVwcyA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGRlcHM7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IFtjYWxsYmFjaywgbmV4dERlcHNdO1xuICByZXR1cm4gY2FsbGJhY2s7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICB2YXIgcHJldlN0YXRlID0gaG9vay5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChuZXh0RGVwcyAhPT0gbnVsbCkge1xuICAgIHZhciBwcmV2RGVwcyA9IHByZXZTdGF0ZVsxXTtcblxuICAgIGlmIChhcmVIb29rSW5wdXRzRXF1YWwobmV4dERlcHMsIHByZXZEZXBzKSkge1xuICAgICAgcmV0dXJuIHByZXZTdGF0ZVswXTtcbiAgICB9XG4gIH1cblxuICBob29rLm1lbW9pemVkU3RhdGUgPSBbY2FsbGJhY2ssIG5leHREZXBzXTtcbiAgcmV0dXJuIGNhbGxiYWNrO1xufVxuXG5mdW5jdGlvbiBtb3VudE1lbW8obmV4dENyZWF0ZSwgZGVwcykge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBuZXh0RGVwcyA9IGRlcHMgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBkZXBzO1xuICB2YXIgbmV4dFZhbHVlID0gbmV4dENyZWF0ZSgpO1xuXG4gIGlmIChzaG91bGREb3VibGVJbnZva2VVc2VyRm5zSW5Ib29rc0RFVikge1xuICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuICAgIG5leHRDcmVhdGUoKTtcbiAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7XG4gIH1cblxuICBob29rLm1lbW9pemVkU3RhdGUgPSBbbmV4dFZhbHVlLCBuZXh0RGVwc107XG4gIHJldHVybiBuZXh0VmFsdWU7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU1lbW8obmV4dENyZWF0ZSwgZGVwcykge1xuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgbmV4dERlcHMgPSBkZXBzID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVwcztcbiAgdmFyIHByZXZTdGF0ZSA9IGhvb2subWVtb2l6ZWRTdGF0ZTsgLy8gQXNzdW1lIHRoZXNlIGFyZSBkZWZpbmVkLiBJZiB0aGV5J3JlIG5vdCwgYXJlSG9va0lucHV0c0VxdWFsIHdpbGwgd2Fybi5cblxuICBpZiAobmV4dERlcHMgIT09IG51bGwpIHtcbiAgICB2YXIgcHJldkRlcHMgPSBwcmV2U3RhdGVbMV07XG5cbiAgICBpZiAoYXJlSG9va0lucHV0c0VxdWFsKG5leHREZXBzLCBwcmV2RGVwcykpIHtcbiAgICAgIHJldHVybiBwcmV2U3RhdGVbMF07XG4gICAgfVxuICB9XG5cbiAgdmFyIG5leHRWYWx1ZSA9IG5leHRDcmVhdGUoKTtcblxuICBpZiAoc2hvdWxkRG91YmxlSW52b2tlVXNlckZuc0luSG9va3NERVYpIHtcbiAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTtcbiAgICBuZXh0Q3JlYXRlKCk7XG4gICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICB9XG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gW25leHRWYWx1ZSwgbmV4dERlcHNdO1xuICByZXR1cm4gbmV4dFZhbHVlO1xufVxuXG5mdW5jdGlvbiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHJldHVybiBtb3VudERlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHZhbHVlLCBpbml0aWFsVmFsdWUpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVEZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgdmFyIGhvb2sgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIHJlc29sdmVkQ3VycmVudEhvb2sgPSBjdXJyZW50SG9vaztcbiAgdmFyIHByZXZWYWx1ZSA9IHJlc29sdmVkQ3VycmVudEhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgcmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHByZXZWYWx1ZSwgdmFsdWUsIGluaXRpYWxWYWx1ZSk7XG59XG5cbmZ1bmN0aW9uIHJlcmVuZGVyRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG5cbiAgaWYgKGN1cnJlbnRIb29rID09PSBudWxsKSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlcmVuZGVyIGR1cmluZyBhIG1vdW50LlxuICAgIHJldHVybiBtb3VudERlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgYSByZXJlbmRlciBkdXJpbmcgYW4gdXBkYXRlLlxuICAgIHZhciBwcmV2VmFsdWUgPSBjdXJyZW50SG9vay5tZW1vaXplZFN0YXRlO1xuICAgIHJldHVybiB1cGRhdGVEZWZlcnJlZFZhbHVlSW1wbChob29rLCBwcmV2VmFsdWUsIHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50RGVmZXJyZWRWYWx1ZUltcGwoaG9vaywgdmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICBpZiAoLy8gV2hlbiBgaW5pdGlhbFZhbHVlYCBpcyBwcm92aWRlZCwgd2UgZGVmZXIgdGhlIGluaXRpYWwgcmVuZGVyIGV2ZW4gaWYgdGhlXG4gIC8vIGN1cnJlbnQgcmVuZGVyIGlzIG5vdCBzeW5jaHJvbm91cy5cbiAgaW5pdGlhbFZhbHVlICE9PSB1bmRlZmluZWQgJiYgLy8gSG93ZXZlciwgdG8gYXZvaWQgd2F0ZXJmYWxscywgd2UgZG8gbm90IGRlZmVyIGlmIHRoaXMgcmVuZGVyXG4gIC8vIHdhcyBpdHNlbGYgc3Bhd25lZCBieSBhbiBlYXJsaWVyIHVzZURlZmVycmVkVmFsdWUuIENoZWNrIGlmIERlZmVycmVkTGFuZVxuICAvLyBpcyBwYXJ0IG9mIHRoZSByZW5kZXIgbGFuZXMuXG4gICFpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCBEZWZlcnJlZExhbmUpKSB7XG4gICAgLy8gUmVuZGVyIHdpdGggdGhlIGluaXRpYWwgdmFsdWVcbiAgICBob29rLm1lbW9pemVkU3RhdGUgPSBpbml0aWFsVmFsdWU7IC8vIFNjaGVkdWxlIGEgZGVmZXJyZWQgcmVuZGVyIHRvIHN3aXRjaCB0byB0aGUgZmluYWwgdmFsdWUuXG5cbiAgICB2YXIgZGVmZXJyZWRMYW5lID0gcmVxdWVzdERlZmVycmVkTGFuZSgpO1xuICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMgPSBtZXJnZUxhbmVzKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMsIGRlZmVycmVkTGFuZSk7XG4gICAgbWFya1NraXBwZWRVcGRhdGVMYW5lcyhkZWZlcnJlZExhbmUpO1xuICAgIHJldHVybiBpbml0aWFsVmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgaG9vay5tZW1vaXplZFN0YXRlID0gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZURlZmVycmVkVmFsdWVJbXBsKGhvb2ssIHByZXZWYWx1ZSwgdmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICBpZiAob2JqZWN0SXModmFsdWUsIHByZXZWYWx1ZSkpIHtcbiAgICAvLyBUaGUgaW5jb21pbmcgdmFsdWUgaXMgcmVmZXJlbnRpYWxseSBpZGVudGljYWwgdG8gdGhlIGN1cnJlbnRseSByZW5kZXJlZFxuICAgIC8vIHZhbHVlLCBzbyB3ZSBjYW4gYmFpbCBvdXQgcXVpY2tseS5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gZWxzZSB7XG4gICAgLy8gUmVjZWl2ZWQgYSBuZXcgdmFsdWUgdGhhdCdzIGRpZmZlcmVudCBmcm9tIHRoZSBjdXJyZW50IHZhbHVlLlxuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGluc2lkZSBhIGhpZGRlbiB0cmVlXG4gICAgaWYgKGlzQ3VycmVudFRyZWVIaWRkZW4oKSkge1xuICAgICAgLy8gUmV2ZWFsaW5nIGEgcHJlcmVuZGVyZWQgdHJlZSBpcyBjb25zaWRlcmVkIHRoZSBzYW1lIGFzIG1vdW50aW5nIG5ld1xuICAgICAgLy8gb25lLCBzbyB3ZSByZXVzZSB0aGUgXCJtb3VudFwiIHBhdGggaW4gdGhpcyBjYXNlLlxuICAgICAgdmFyIHJlc3VsdFZhbHVlID0gbW91bnREZWZlcnJlZFZhbHVlSW1wbChob29rLCB2YWx1ZSwgaW5pdGlhbFZhbHVlKTsgLy8gVW5saWtlIGR1cmluZyBhbiBhY3R1YWwgbW91bnQsIHdlIG5lZWQgdG8gbWFyayB0aGlzIGFzIGFuIHVwZGF0ZSBpZlxuICAgICAgLy8gdGhlIHZhbHVlIGNoYW5nZWQuXG5cbiAgICAgIGlmICghb2JqZWN0SXMocmVzdWx0VmFsdWUsIHByZXZWYWx1ZSkpIHtcbiAgICAgICAgbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdFZhbHVlO1xuICAgIH1cblxuICAgIHZhciBzaG91bGREZWZlclZhbHVlID0gIWluY2x1ZGVzT25seU5vblVyZ2VudExhbmVzKHJlbmRlckxhbmVzKTtcblxuICAgIGlmIChzaG91bGREZWZlclZhbHVlKSB7XG4gICAgICAvLyBUaGlzIGlzIGFuIHVyZ2VudCB1cGRhdGUuIFNpbmNlIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZCwga2VlcCB1c2luZyB0aGVcbiAgICAgIC8vIHByZXZpb3VzIHZhbHVlIGFuZCBzcGF3biBhIGRlZmVycmVkIHJlbmRlciB0byB1cGRhdGUgaXQgbGF0ZXIuXG4gICAgICAvLyBTY2hlZHVsZSBhIGRlZmVycmVkIHJlbmRlclxuICAgICAgdmFyIGRlZmVycmVkTGFuZSA9IHJlcXVlc3REZWZlcnJlZExhbmUoKTtcbiAgICAgIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMgPSBtZXJnZUxhbmVzKGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEubGFuZXMsIGRlZmVycmVkTGFuZSk7XG4gICAgICBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKGRlZmVycmVkTGFuZSk7IC8vIFJldXNlIHRoZSBwcmV2aW91cyB2YWx1ZS4gV2UgZG8gbm90IG5lZWQgdG8gbWFyayB0aGlzIGFzIGFuIHVwZGF0ZSxcbiAgICAgIC8vIGJlY2F1c2Ugd2UgZGlkIG5vdCByZW5kZXIgYSBuZXcgdmFsdWUuXG5cbiAgICAgIHJldHVybiBwcmV2VmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgbm90IGFuIHVyZ2VudCB1cGRhdGUsIHNvIHdlIGNhbiB1c2UgdGhlIGxhdGVzdCB2YWx1ZSByZWdhcmRsZXNzXG4gICAgICAvLyBvZiB3aGF0IGl0IGlzLiBObyBuZWVkIHRvIGRlZmVyIGl0LlxuICAgICAgLy8gTWFyayB0aGlzIGFzIGFuIHVwZGF0ZSB0byBwcmV2ZW50IHRoZSBmaWJlciBmcm9tIGJhaWxpbmcgb3V0LlxuICAgICAgbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKTtcbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHZhbHVlO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzdGFydFRyYW5zaXRpb24oZmliZXIsIHF1ZXVlLCBwZW5kaW5nU3RhdGUsIGZpbmlzaGVkU3RhdGUsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG4gIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShoaWdoZXJFdmVudFByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHksIENvbnRpbnVvdXNFdmVudFByaW9yaXR5KSk7XG4gIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQ7XG4gIHZhciBjdXJyZW50VHJhbnNpdGlvbiA9IHt9O1xuXG4gIHtcbiAgICAvLyBXZSBkb24ndCByZWFsbHkgbmVlZCB0byB1c2UgYW4gb3B0aW1pc3RpYyB1cGRhdGUgaGVyZSwgYmVjYXVzZSB3ZVxuICAgIC8vIHNjaGVkdWxlIGEgc2Vjb25kIFwicmV2ZXJ0XCIgdXBkYXRlIGJlbG93ICh3aGljaCB3ZSB1c2UgdG8gc3VzcGVuZCB0aGVcbiAgICAvLyB0cmFuc2l0aW9uIHVudGlsIHRoZSBhc3luYyBhY3Rpb24gc2NvcGUgaGFzIGZpbmlzaGVkKS4gQnV0IHdlJ2xsIHVzZSBhblxuICAgIC8vIG9wdGltaXN0aWMgdXBkYXRlIGFueXdheSB0byBtYWtlIGl0IGxlc3MgbGlrZWx5IHRoZSBiZWhhdmlvciBhY2NpZGVudGFsbHlcbiAgICAvLyBkaXZlcmdlczsgZm9yIGV4YW1wbGUsIGJvdGggYW4gb3B0aW1pc3RpYyB1cGRhdGUgYW5kIHRoaXMgb25lIHNob3VsZFxuICAgIC8vIHNoYXJlIHRoZSBzYW1lIGxhbmUuXG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IGN1cnJlbnRUcmFuc2l0aW9uO1xuICAgIGRpc3BhdGNoT3B0aW1pc3RpY1NldFN0YXRlKGZpYmVyLCBmYWxzZSwgcXVldWUsIHBlbmRpbmdTdGF0ZSk7XG4gIH1cblxuICB7XG4gICAgY3VycmVudFRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMgPSBuZXcgU2V0KCk7XG4gIH1cblxuICB0cnkge1xuICAgIGlmIChlbmFibGVBc3luY0FjdGlvbnMpIHtcbiAgICAgIHZhciByZXR1cm5WYWx1ZSA9IGNhbGxiYWNrKCk7XG4gICAgICB2YXIgb25TdGFydFRyYW5zaXRpb25GaW5pc2ggPSBSZWFjdFNoYXJlZEludGVybmFscy5TO1xuXG4gICAgICBpZiAob25TdGFydFRyYW5zaXRpb25GaW5pc2ggIT09IG51bGwpIHtcbiAgICAgICAgb25TdGFydFRyYW5zaXRpb25GaW5pc2goY3VycmVudFRyYW5zaXRpb24sIHJldHVyblZhbHVlKTtcbiAgICAgIH0gLy8gQ2hlY2sgaWYgd2UncmUgaW5zaWRlIGFuIGFzeW5jIGFjdGlvbiBzY29wZS4gSWYgc28sIHdlJ2xsIGVudGFuZ2xlXG4gICAgICAvLyB0aGlzIG5ldyBhY3Rpb24gd2l0aCB0aGUgZXhpc3Rpbmcgc2NvcGUuXG4gICAgICAvL1xuICAgICAgLy8gSWYgd2UncmUgbm90IGFscmVhZHkgaW5zaWRlIGFuIGFzeW5jIGFjdGlvbiBzY29wZSwgYW5kIHRoaXMgYWN0aW9uIGlzXG4gICAgICAvLyBhc3luYywgdGhlbiB3ZSdsbCBjcmVhdGUgYSBuZXcgYXN5bmMgc2NvcGUuXG4gICAgICAvL1xuICAgICAgLy8gSW4gdGhlIGFzeW5jIGNhc2UsIHRoZSByZXN1bHRpbmcgcmVuZGVyIHdpbGwgc3VzcGVuZCB1bnRpbCB0aGUgYXN5bmNcbiAgICAgIC8vIGFjdGlvbiBzY29wZSBoYXMgZmluaXNoZWQuXG5cblxuICAgICAgaWYgKHJldHVyblZhbHVlICE9PSBudWxsICYmIHR5cGVvZiByZXR1cm5WYWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHJldHVyblZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFyIHRoZW5hYmxlID0gcmV0dXJuVmFsdWU7IC8vIENyZWF0ZSBhIHRoZW5hYmxlIHRoYXQgcmVzb2x2ZXMgdG8gYGZpbmlzaGVkU3RhdGVgIG9uY2UgdGhlIGFzeW5jXG4gICAgICAgIC8vIGFjdGlvbiBoYXMgY29tcGxldGVkLlxuXG4gICAgICAgIHZhciB0aGVuYWJsZUZvckZpbmlzaGVkU3RhdGUgPSBjaGFpblRoZW5hYmxlVmFsdWUodGhlbmFibGUsIGZpbmlzaGVkU3RhdGUpO1xuICAgICAgICBkaXNwYXRjaFNldFN0YXRlKGZpYmVyLCBxdWV1ZSwgdGhlbmFibGVGb3JGaW5pc2hlZFN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpc3BhdGNoU2V0U3RhdGUoZmliZXIsIHF1ZXVlLCBmaW5pc2hlZFN0YXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAge1xuICAgICAgLy8gVGhpcyBpcyBhIHRyaWNrIHRvIGdldCB0aGUgYHVzZVRyYW5zaXRpb25gIGhvb2sgdG8gcmV0aHJvdyB0aGUgZXJyb3IuXG4gICAgICAvLyBXaGVuIGl0IHVud3JhcHMgdGhlIHRoZW5hYmxlIHdpdGggdGhlIGB1c2VgIGFsZ29yaXRobSwgdGhlIGVycm9yXG4gICAgICAvLyB3aWxsIGJlIHRocm93bi5cbiAgICAgIHZhciByZWplY3RlZFRoZW5hYmxlID0ge1xuICAgICAgICB0aGVuOiBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgc3RhdHVzOiAncmVqZWN0ZWQnLFxuICAgICAgICByZWFzb246IGVycm9yXG4gICAgICB9O1xuICAgICAgZGlzcGF0Y2hTZXRTdGF0ZShmaWJlciwgcXVldWUsIHJlamVjdGVkVGhlbmFibGUpO1xuICAgIH1cbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJldmlvdXNQcmlvcml0eSk7XG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZUcmFuc2l0aW9uO1xuXG4gICAge1xuICAgICAgaWYgKHByZXZUcmFuc2l0aW9uID09PSBudWxsICYmIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzKSB7XG4gICAgICAgIHZhciB1cGRhdGVkRmliZXJzQ291bnQgPSBjdXJyZW50VHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5zaXplO1xuXG4gICAgICAgIGN1cnJlbnRUcmFuc2l0aW9uLl91cGRhdGVkRmliZXJzLmNsZWFyKCk7XG5cbiAgICAgICAgaWYgKHVwZGF0ZWRGaWJlcnNDb3VudCA+IDEwKSB7XG4gICAgICAgICAgd2FybignRGV0ZWN0ZWQgYSBsYXJnZSBudW1iZXIgb2YgdXBkYXRlcyBpbnNpZGUgc3RhcnRUcmFuc2l0aW9uLiAnICsgJ0lmIHRoaXMgaXMgZHVlIHRvIGEgc3Vic2NyaXB0aW9uIHBsZWFzZSByZS13cml0ZSBpdCB0byB1c2UgUmVhY3QgcHJvdmlkZWQgaG9va3MuICcgKyAnT3RoZXJ3aXNlIGNvbmN1cnJlbnQgbW9kZSBndWFyYW50ZWVzIGFyZSBvZmYgdGhlIHRhYmxlLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBub29wID0gZnVuY3Rpb24gKCkge307XG5cbmZ1bmN0aW9uIHN0YXJ0SG9zdFRyYW5zaXRpb24oZm9ybUZpYmVyLCBwZW5kaW5nU3RhdGUsIGFjdGlvbiwgZm9ybURhdGEpIHtcblxuICBpZiAoZm9ybUZpYmVyLnRhZyAhPT0gSG9zdENvbXBvbmVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgdGhlIGZvcm0gaW5zdGFuY2UgdG8gYmUgYSBIb3N0Q29tcG9uZW50LiBUaGlzICcgKyAnaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gIH1cblxuICB2YXIgc3RhdGVIb29rID0gZW5zdXJlRm9ybUNvbXBvbmVudElzU3RhdGVmdWwoZm9ybUZpYmVyKTtcbiAgdmFyIHF1ZXVlID0gc3RhdGVIb29rLnF1ZXVlO1xuICBzdGFydFRyYW5zaXRpb24oZm9ybUZpYmVyLCBxdWV1ZSwgcGVuZGluZ1N0YXRlLCBOb3RQZW5kaW5nVHJhbnNpdGlvbiwgLy8gVE9ETzogYHN0YXJ0VHJhbnNpdGlvbmAgYm90aCBzZXRzIHRoZSBwZW5kaW5nIHN0YXRlIGFuZCBkaXNwYXRjaGVzXG4gIC8vIHRoZSBhY3Rpb24sIGlmIG9uZSBpcyBwcm92aWRlZC4gQ29uc2lkZXIgcmVmYWN0b3JpbmcgdGhlc2UgdHdvXG4gIC8vIGNvbmNlcm5zIHRvIGF2b2lkIHRoZSBleHRyYSBsYW1iZGEuXG4gIGFjdGlvbiA9PT0gbnVsbCA/IC8vIE5vIGFjdGlvbiB3YXMgcHJvdmlkZWQsIGJ1dCB3ZSBzdGlsbCBjYWxsIGBzdGFydFRyYW5zaXRpb25gIHRvXG4gIC8vIHNldCB0aGUgcGVuZGluZyBmb3JtIHN0YXR1cy5cbiAgbm9vcCA6IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBBdXRvbWF0aWNhbGx5IHJlc2V0IHRoZSBmb3JtIHdoZW4gdGhlIGFjdGlvbiBjb21wbGV0ZXMuXG4gICAgcmVxdWVzdEZvcm1SZXNldChmb3JtRmliZXIpO1xuICAgIHJldHVybiBhY3Rpb24oZm9ybURhdGEpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZW5zdXJlRm9ybUNvbXBvbmVudElzU3RhdGVmdWwoZm9ybUZpYmVyKSB7XG4gIHZhciBleGlzdGluZ1N0YXRlSG9vayA9IGZvcm1GaWJlci5tZW1vaXplZFN0YXRlO1xuXG4gIGlmIChleGlzdGluZ1N0YXRlSG9vayAhPT0gbnVsbCkge1xuICAgIC8vIFRoaXMgZmliZXIgd2FzIGFscmVhZHkgdXBncmFkZWQgdG8gYmUgc3RhdGVmdWwuXG4gICAgcmV0dXJuIGV4aXN0aW5nU3RhdGVIb29rO1xuICB9IC8vIFVwZ3JhZGUgdGhpcyBob3N0IGNvbXBvbmVudCBmaWJlciB0byBiZSBzdGF0ZWZ1bC4gV2UncmUgZ29pbmcgdG8gcHJldGVuZFxuICAvLyBpdCB3YXMgc3RhdGVmdWwgYWxsIGFsb25nIHNvIHdlIGNhbiByZXVzZSBtb3N0IG9mIHRoZSBpbXBsZW1lbnRhdGlvblxuICAvLyBmb3IgZnVuY3Rpb24gY29tcG9uZW50cyBhbmQgdXNlVHJhbnNpdGlvbi5cbiAgLy9cbiAgLy8gQ3JlYXRlIHRoZSBzdGF0ZSBob29rIHVzZWQgYnkgVHJhbnNpdGlvbkF3YXJlSG9zdENvbXBvbmVudC4gVGhpcyBpc1xuICAvLyBlc3NlbnRpYWxseSBhbiBpbmxpbmVkIHZlcnNpb24gb2YgbW91bnRTdGF0ZS5cblxuXG4gIHZhciBuZXdRdWV1ZSA9IHtcbiAgICBwZW5kaW5nOiBudWxsLFxuICAgIGxhbmVzOiBOb0xhbmVzLFxuICAgIC8vIFdlJ3JlIGdvaW5nIHRvIGNoZWF0IGFuZCBpbnRlbnRpb25hbGx5IG5vdCBjcmVhdGUgYSBib3VuZCBkaXNwYXRjaFxuICAgIC8vIG1ldGhvZCwgYmVjYXVzZSB3ZSBjYW4gY2FsbCBpdCBkaXJlY3RseSBpbiBzdGFydFRyYW5zaXRpb24uXG4gICAgZGlzcGF0Y2g6IG51bGwsXG4gICAgbGFzdFJlbmRlcmVkUmVkdWNlcjogYmFzaWNTdGF0ZVJlZHVjZXIsXG4gICAgbGFzdFJlbmRlcmVkU3RhdGU6IE5vdFBlbmRpbmdUcmFuc2l0aW9uXG4gIH07XG4gIHZhciBzdGF0ZUhvb2sgPSB7XG4gICAgbWVtb2l6ZWRTdGF0ZTogTm90UGVuZGluZ1RyYW5zaXRpb24sXG4gICAgYmFzZVN0YXRlOiBOb3RQZW5kaW5nVHJhbnNpdGlvbixcbiAgICBiYXNlUXVldWU6IG51bGwsXG4gICAgcXVldWU6IG5ld1F1ZXVlLFxuICAgIG5leHQ6IG51bGxcbiAgfTsgLy8gV2UgdXNlIGFub3RoZXIgc3RhdGUgaG9vayB0byB0cmFjayB3aGV0aGVyIHRoZSBmb3JtIG5lZWRzIHRvIGJlIHJlc2V0LlxuICAvLyBUaGUgc3RhdGUgaXMgYW4gZW1wdHkgb2JqZWN0LiBUbyB0cmlnZ2VyIGEgcmVzZXQsIHdlIHVwZGF0ZSB0aGUgc3RhdGVcbiAgLy8gdG8gYSBuZXcgb2JqZWN0LiBUaGVuIGR1cmluZyByZW5kZXJpbmcsIHdlIGRldGVjdCB0aGF0IHRoZSBzdGF0ZSBoYXNcbiAgLy8gY2hhbmdlZCBhbmQgc2NoZWR1bGUgYSBjb21taXQgZWZmZWN0LlxuXG4gIHZhciBpbml0aWFsUmVzZXRTdGF0ZSA9IHt9O1xuICB2YXIgbmV3UmVzZXRTdGF0ZVF1ZXVlID0ge1xuICAgIHBlbmRpbmc6IG51bGwsXG4gICAgbGFuZXM6IE5vTGFuZXMsXG4gICAgLy8gV2UncmUgZ29pbmcgdG8gY2hlYXQgYW5kIGludGVudGlvbmFsbHkgbm90IGNyZWF0ZSBhIGJvdW5kIGRpc3BhdGNoXG4gICAgLy8gbWV0aG9kLCBiZWNhdXNlIHdlIGNhbiBjYWxsIGl0IGRpcmVjdGx5IGluIHN0YXJ0VHJhbnNpdGlvbi5cbiAgICBkaXNwYXRjaDogbnVsbCxcbiAgICBsYXN0UmVuZGVyZWRSZWR1Y2VyOiBiYXNpY1N0YXRlUmVkdWNlcixcbiAgICBsYXN0UmVuZGVyZWRTdGF0ZTogaW5pdGlhbFJlc2V0U3RhdGVcbiAgfTtcbiAgdmFyIHJlc2V0U3RhdGVIb29rID0ge1xuICAgIG1lbW9pemVkU3RhdGU6IGluaXRpYWxSZXNldFN0YXRlLFxuICAgIGJhc2VTdGF0ZTogaW5pdGlhbFJlc2V0U3RhdGUsXG4gICAgYmFzZVF1ZXVlOiBudWxsLFxuICAgIHF1ZXVlOiBuZXdSZXNldFN0YXRlUXVldWUsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuICBzdGF0ZUhvb2submV4dCA9IHJlc2V0U3RhdGVIb29rOyAvLyBBZGQgdGhlIGhvb2sgbGlzdCB0byBib3RoIGZpYmVyIGFsdGVybmF0ZXMuIFRoZSBpZGVhIGlzIHRoYXQgdGhlIGZpYmVyXG4gIC8vIGhhZCB0aGlzIGhvb2sgYWxsIGFsb25nLlxuXG4gIGZvcm1GaWJlci5tZW1vaXplZFN0YXRlID0gc3RhdGVIb29rO1xuICB2YXIgYWx0ZXJuYXRlID0gZm9ybUZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUgPSBzdGF0ZUhvb2s7XG4gIH1cblxuICByZXR1cm4gc3RhdGVIb29rO1xufVxuXG5mdW5jdGlvbiByZXF1ZXN0Rm9ybVJlc2V0KGZvcm1GaWJlcikge1xuICB2YXIgdHJhbnNpdGlvbiA9IHJlcXVlc3RDdXJyZW50VHJhbnNpdGlvbigpO1xuXG4gIHtcbiAgICBpZiAodHJhbnNpdGlvbiA9PT0gbnVsbCkge1xuICAgICAgLy8gQW4gb3B0aW1pc3RpYyB1cGRhdGUgb2NjdXJyZWQsIGJ1dCBzdGFydFRyYW5zaXRpb24gaXMgbm90IG9uIHRoZSBzdGFjay5cbiAgICAgIC8vIFRoZSBmb3JtIHJlc2V0IHdpbGwgYmUgc2NoZWR1bGVkIGF0IGRlZmF1bHQgKHN5bmMpIHByaW9yaXR5LCB3aGljaFxuICAgICAgLy8gaXMgcHJvYmFibHkgbm90IHdoYXQgdGhlIHVzZXIgaW50ZW5kZWQuIE1vc3QgbGlrZWx5IGJlY2F1c2UgdGhlXG4gICAgICAvLyByZXF1ZXN0Rm9ybVJlc2V0IGNhbGwgaGFwcGVuZWQgYWZ0ZXIgYW4gYGF3YWl0YC5cbiAgICAgIC8vIFRPRE86IFRoZW9yZXRpY2FsbHksIHJlcXVlc3RGb3JtUmVzZXQgaXMgc3RpbGwgdXNlZnVsIGV2ZW4gZm9yXG4gICAgICAvLyBub24tdHJhbnNpdGlvbiB1cGRhdGVzIGJlY2F1c2UgaXQgYWxsb3dzIHlvdSB0byB1cGRhdGUgZGVmYXVsdFZhbHVlXG4gICAgICAvLyBzeW5jaHJvbm91c2x5IGFuZCB0aGVuIHdhaXQgdG8gcmVzZXQgdW50aWwgYWZ0ZXIgdGhlIHVwZGF0ZSBjb21taXRzLlxuICAgICAgLy8gSSd2ZSBjaG9zZW4gdG8gd2FybiBhbnl3YXkgYmVjYXVzZSBpdCdzIG1vcmUgbGlrZWx5IHRoZSBgYXdhaXRgIG1pc3Rha2VcbiAgICAgIC8vIGRlc2NyaWJlZCBhYm92ZS4gQnV0IGFyZ3VhYmx5IHdlIHNob3VsZG4ndC5cbiAgICAgIGVycm9yKCdyZXF1ZXN0Rm9ybVJlc2V0IHdhcyBjYWxsZWQgb3V0c2lkZSBhIHRyYW5zaXRpb24gb3IgYWN0aW9uLiBUbyAnICsgJ2ZpeCwgbW92ZSB0byBhbiBhY3Rpb24sIG9yIHdyYXAgd2l0aCBzdGFydFRyYW5zaXRpb24uJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIHN0YXRlSG9vayA9IGVuc3VyZUZvcm1Db21wb25lbnRJc1N0YXRlZnVsKGZvcm1GaWJlcik7XG4gIHZhciBuZXdSZXNldFN0YXRlID0ge307XG4gIHZhciByZXNldFN0YXRlSG9vayA9IHN0YXRlSG9vay5uZXh0O1xuICB2YXIgcmVzZXRTdGF0ZVF1ZXVlID0gcmVzZXRTdGF0ZUhvb2sucXVldWU7XG4gIGRpc3BhdGNoU2V0U3RhdGUoZm9ybUZpYmVyLCByZXNldFN0YXRlUXVldWUsIG5ld1Jlc2V0U3RhdGUpO1xufVxuXG5mdW5jdGlvbiBtb3VudFRyYW5zaXRpb24oKSB7XG4gIHZhciBzdGF0ZUhvb2sgPSBtb3VudFN0YXRlSW1wbChmYWxzZSk7IC8vIFRoZSBgc3RhcnRgIG1ldGhvZCBuZXZlciBjaGFuZ2VzLlxuXG4gIHZhciBzdGFydCA9IHN0YXJ0VHJhbnNpdGlvbi5iaW5kKG51bGwsIGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEsIHN0YXRlSG9vay5xdWV1ZSwgdHJ1ZSwgZmFsc2UpO1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIGhvb2subWVtb2l6ZWRTdGF0ZSA9IHN0YXJ0O1xuICByZXR1cm4gW2ZhbHNlLCBzdGFydF07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVRyYW5zaXRpb24oKSB7XG4gIHZhciBfdXBkYXRlU3RhdGUyID0gdXBkYXRlU3RhdGUoKSxcbiAgICAgIGJvb2xlYW5PclRoZW5hYmxlID0gX3VwZGF0ZVN0YXRlMlswXTtcblxuICB2YXIgaG9vayA9IHVwZGF0ZVdvcmtJblByb2dyZXNzSG9vaygpO1xuICB2YXIgc3RhcnQgPSBob29rLm1lbW9pemVkU3RhdGU7XG4gIHZhciBpc1BlbmRpbmcgPSB0eXBlb2YgYm9vbGVhbk9yVGhlbmFibGUgPT09ICdib29sZWFuJyA/IGJvb2xlYW5PclRoZW5hYmxlIDogLy8gVGhpcyB3aWxsIHN1c3BlbmQgdW50aWwgdGhlIGFzeW5jIGFjdGlvbiBzY29wZSBoYXMgZmluaXNoZWQuXG4gIHVzZVRoZW5hYmxlKGJvb2xlYW5PclRoZW5hYmxlKTtcbiAgcmV0dXJuIFtpc1BlbmRpbmcsIHN0YXJ0XTtcbn1cblxuZnVuY3Rpb24gcmVyZW5kZXJUcmFuc2l0aW9uKCkge1xuICB2YXIgX3JlcmVuZGVyU3RhdGUgPSByZXJlbmRlclN0YXRlKCksXG4gICAgICBib29sZWFuT3JUaGVuYWJsZSA9IF9yZXJlbmRlclN0YXRlWzBdO1xuXG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBzdGFydCA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIGlzUGVuZGluZyA9IHR5cGVvZiBib29sZWFuT3JUaGVuYWJsZSA9PT0gJ2Jvb2xlYW4nID8gYm9vbGVhbk9yVGhlbmFibGUgOiAvLyBUaGlzIHdpbGwgc3VzcGVuZCB1bnRpbCB0aGUgYXN5bmMgYWN0aW9uIHNjb3BlIGhhcyBmaW5pc2hlZC5cbiAgdXNlVGhlbmFibGUoYm9vbGVhbk9yVGhlbmFibGUpO1xuICByZXR1cm4gW2lzUGVuZGluZywgc3RhcnRdO1xufVxuXG5mdW5jdGlvbiB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cygpIHtcblxuICB2YXIgc3RhdHVzID0gcmVhZENvbnRleHQoSG9zdFRyYW5zaXRpb25Db250ZXh0KTtcbiAgcmV0dXJuIHN0YXR1cyAhPT0gbnVsbCA/IHN0YXR1cyA6IE5vdFBlbmRpbmdUcmFuc2l0aW9uO1xufVxuXG5mdW5jdGlvbiBtb3VudElkKCkge1xuICB2YXIgaG9vayA9IG1vdW50V29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciByb290ID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCk7IC8vIFRPRE86IEluIEZpenosIGlkIGdlbmVyYXRpb24gaXMgc3BlY2lmaWMgdG8gZWFjaCBzZXJ2ZXIgY29uZmlnLiBNYXliZSB3ZVxuICAvLyBzaG91bGQgZG8gdGhpcyBpbiBGaWJlciwgdG9vPyBEZWZlcnJpbmcgdGhpcyBkZWNpc2lvbiBmb3Igbm93IGJlY2F1c2VcbiAgLy8gdGhlcmUncyBubyBvdGhlciBwbGFjZSB0byBzdG9yZSB0aGUgcHJlZml4IGV4Y2VwdCBmb3IgYW4gaW50ZXJuYWwgZmllbGQgb25cbiAgLy8gdGhlIHB1YmxpYyBjcmVhdGVSb290IG9iamVjdCwgd2hpY2ggdGhlIGZpYmVyIHRyZWUgZG9lcyBub3QgY3VycmVudGx5IGhhdmVcbiAgLy8gYSByZWZlcmVuY2UgdG8uXG5cbiAgdmFyIGlkZW50aWZpZXJQcmVmaXggPSByb290LmlkZW50aWZpZXJQcmVmaXg7XG4gIHZhciBpZDtcblxuICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgIHZhciB0cmVlSWQgPSBnZXRUcmVlSWQoKTsgLy8gVXNlIGEgY2FwdGlhbCBSIHByZWZpeCBmb3Igc2VydmVyLWdlbmVyYXRlZCBpZHMuXG5cbiAgICBpZCA9ICc6JyArIGlkZW50aWZpZXJQcmVmaXggKyAnUicgKyB0cmVlSWQ7IC8vIFVubGVzcyB0aGlzIGlzIHRoZSBmaXJzdCBpZCBhdCB0aGlzIGxldmVsLCBhcHBlbmQgYSBudW1iZXIgYXQgdGhlIGVuZFxuICAgIC8vIHRoYXQgcmVwcmVzZW50cyB0aGUgcG9zaXRpb24gb2YgdGhpcyB1c2VJZCBob29rIGFtb25nIGFsbCB0aGUgdXNlSWRcbiAgICAvLyBob29rcyBmb3IgdGhpcyBmaWJlci5cblxuICAgIHZhciBsb2NhbElkID0gbG9jYWxJZENvdW50ZXIrKztcblxuICAgIGlmIChsb2NhbElkID4gMCkge1xuICAgICAgaWQgKz0gJ0gnICsgbG9jYWxJZC50b1N0cmluZygzMik7XG4gICAgfVxuXG4gICAgaWQgKz0gJzonO1xuICB9IGVsc2Uge1xuICAgIC8vIFVzZSBhIGxvd2VyY2FzZSByIHByZWZpeCBmb3IgY2xpZW50LWdlbmVyYXRlZCBpZHMuXG4gICAgdmFyIGdsb2JhbENsaWVudElkID0gZ2xvYmFsQ2xpZW50SWRDb3VudGVyKys7XG4gICAgaWQgPSAnOicgKyBpZGVudGlmaWVyUHJlZml4ICsgJ3InICsgZ2xvYmFsQ2xpZW50SWQudG9TdHJpbmcoMzIpICsgJzonO1xuICB9XG5cbiAgaG9vay5tZW1vaXplZFN0YXRlID0gaWQ7XG4gIHJldHVybiBpZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSWQoKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHZhciBpZCA9IGhvb2subWVtb2l6ZWRTdGF0ZTtcbiAgcmV0dXJuIGlkO1xufVxuXG5mdW5jdGlvbiBtb3VudFJlZnJlc2goKSB7XG4gIHZhciBob29rID0gbW91bnRXb3JrSW5Qcm9ncmVzc0hvb2soKTtcbiAgdmFyIHJlZnJlc2ggPSBob29rLm1lbW9pemVkU3RhdGUgPSByZWZyZXNoQ2FjaGUuYmluZChudWxsLCBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciQxKTtcbiAgcmV0dXJuIHJlZnJlc2g7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVJlZnJlc2goKSB7XG4gIHZhciBob29rID0gdXBkYXRlV29ya0luUHJvZ3Jlc3NIb29rKCk7XG4gIHJldHVybiBob29rLm1lbW9pemVkU3RhdGU7XG59XG5cbmZ1bmN0aW9uIHJlZnJlc2hDYWNoZShmaWJlciwgc2VlZEtleSwgc2VlZFZhbHVlKSB7XG4gIC8vIFRPRE86IENvbnNpZGVyIHdhcm5pbmcgaWYgdGhlIHJlZnJlc2ggaXMgYXQgZGlzY3JldGUgcHJpb3JpdHksIG9yIGlmIHdlXG4gIC8vIG90aGVyd2lzZSBzdXNwZWN0IHRoYXQgaXQgd2Fzbid0IGJhdGNoZWQgcHJvcGVybHkuXG5cblxuICB2YXIgcHJvdmlkZXIgPSBmaWJlci5yZXR1cm47XG5cbiAgd2hpbGUgKHByb3ZpZGVyICE9PSBudWxsKSB7XG4gICAgc3dpdGNoIChwcm92aWRlci50YWcpIHtcbiAgICAgIGNhc2UgQ2FjaGVDb21wb25lbnQ6XG4gICAgICBjYXNlIEhvc3RSb290OlxuICAgICAgICB7XG4gICAgICAgICAgLy8gU2NoZWR1bGUgYW4gdXBkYXRlIG9uIHRoZSBjYWNoZSBib3VuZGFyeSB0byB0cmlnZ2VyIGEgcmVmcmVzaC5cbiAgICAgICAgICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKHByb3ZpZGVyKTtcbiAgICAgICAgICB2YXIgcmVmcmVzaFVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShsYW5lKTtcbiAgICAgICAgICB2YXIgcm9vdCA9IGVucXVldWVVcGRhdGUocHJvdmlkZXIsIHJlZnJlc2hVcGRhdGUsIGxhbmUpO1xuXG4gICAgICAgICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBwcm92aWRlciwgbGFuZSk7XG4gICAgICAgICAgICBlbnRhbmdsZVRyYW5zaXRpb25zKHJvb3QsIHByb3ZpZGVyLCBsYW5lKTtcbiAgICAgICAgICB9IC8vIFRPRE86IElmIGEgcmVmcmVzaCBuZXZlciBjb21taXRzLCB0aGUgbmV3IGNhY2hlIGNyZWF0ZWQgaGVyZSBtdXN0IGJlXG4gICAgICAgICAgLy8gcmVsZWFzZWQuIEEgc2ltcGxlIGNhc2UgaXMgc3RhcnQgcmVmcmVzaGluZyBhIGNhY2hlIGJvdW5kYXJ5LCBidXQgdGhlblxuICAgICAgICAgIC8vIHVubW91bnQgdGhhdCBib3VuZGFyeSBiZWZvcmUgdGhlIHJlZnJlc2ggY29tcGxldGVzLlxuXG5cbiAgICAgICAgICB2YXIgc2VlZGVkQ2FjaGUgPSBjcmVhdGVDYWNoZSgpO1xuXG4gICAgICAgICAgaWYgKHNlZWRLZXkgIT09IG51bGwgJiYgc2VlZEtleSAhPT0gdW5kZWZpbmVkICYmIHJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGVycm9yKCdUaGUgc2VlZCBhcmd1bWVudCBpcyBub3QgZW5hYmxlZCBvdXRzaWRlIGV4cGVyaW1lbnRhbCBjaGFubmVscy4nKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBwYXlsb2FkID0ge1xuICAgICAgICAgICAgY2FjaGU6IHNlZWRlZENhY2hlXG4gICAgICAgICAgfTtcbiAgICAgICAgICByZWZyZXNoVXBkYXRlLnBheWxvYWQgPSBwYXlsb2FkO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByb3ZpZGVyID0gcHJvdmlkZXIucmV0dXJuO1xuICB9IC8vIFRPRE86IFdhcm4gaWYgdW5tb3VudGVkP1xuXG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoUmVkdWNlckFjdGlvbihmaWJlciwgcXVldWUsIGFjdGlvbikge1xuICB7XG4gICAgaWYgKHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKFwiU3RhdGUgdXBkYXRlcyBmcm9tIHRoZSB1c2VTdGF0ZSgpIGFuZCB1c2VSZWR1Y2VyKCkgSG9va3MgZG9uJ3Qgc3VwcG9ydCB0aGUgXCIgKyAnc2Vjb25kIGNhbGxiYWNrIGFyZ3VtZW50LiBUbyBleGVjdXRlIGEgc2lkZSBlZmZlY3QgYWZ0ZXIgJyArICdyZW5kZXJpbmcsIGRlY2xhcmUgaXQgaW4gdGhlIGNvbXBvbmVudCBib2R5IHdpdGggdXNlRWZmZWN0KCkuJyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gIHZhciB1cGRhdGUgPSB7XG4gICAgbGFuZTogbGFuZSxcbiAgICByZXZlcnRMYW5lOiBOb0xhbmUsXG4gICAgYWN0aW9uOiBhY3Rpb24sXG4gICAgaGFzRWFnZXJTdGF0ZTogZmFsc2UsXG4gICAgZWFnZXJTdGF0ZTogbnVsbCxcbiAgICBuZXh0OiBudWxsXG4gIH07XG5cbiAgaWYgKGlzUmVuZGVyUGhhc2VVcGRhdGUoZmliZXIpKSB7XG4gICAgZW5xdWV1ZVJlbmRlclBoYXNlVXBkYXRlKHF1ZXVlLCB1cGRhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlKGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCBsYW5lKTtcblxuICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIGxhbmUpO1xuICAgICAgZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlKHJvb3QsIHF1ZXVlLCBsYW5lKTtcbiAgICB9XG4gIH1cblxuICBtYXJrVXBkYXRlSW5EZXZUb29scyhmaWJlciwgbGFuZSk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoU2V0U3RhdGUoZmliZXIsIHF1ZXVlLCBhY3Rpb24pIHtcbiAge1xuICAgIGlmICh0eXBlb2YgYXJndW1lbnRzWzNdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcihcIlN0YXRlIHVwZGF0ZXMgZnJvbSB0aGUgdXNlU3RhdGUoKSBhbmQgdXNlUmVkdWNlcigpIEhvb2tzIGRvbid0IHN1cHBvcnQgdGhlIFwiICsgJ3NlY29uZCBjYWxsYmFjayBhcmd1bWVudC4gVG8gZXhlY3V0ZSBhIHNpZGUgZWZmZWN0IGFmdGVyICcgKyAncmVuZGVyaW5nLCBkZWNsYXJlIGl0IGluIHRoZSBjb21wb25lbnQgYm9keSB3aXRoIHVzZUVmZmVjdCgpLicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICB2YXIgdXBkYXRlID0ge1xuICAgIGxhbmU6IGxhbmUsXG4gICAgcmV2ZXJ0TGFuZTogTm9MYW5lLFxuICAgIGFjdGlvbjogYWN0aW9uLFxuICAgIGhhc0VhZ2VyU3RhdGU6IGZhbHNlLFxuICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuXG4gIGlmIChpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSkge1xuICAgIGVucXVldWVSZW5kZXJQaGFzZVVwZGF0ZShxdWV1ZSwgdXBkYXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGZpYmVyLmxhbmVzID09PSBOb0xhbmVzICYmIChhbHRlcm5hdGUgPT09IG51bGwgfHwgYWx0ZXJuYXRlLmxhbmVzID09PSBOb0xhbmVzKSkge1xuICAgICAgLy8gVGhlIHF1ZXVlIGlzIGN1cnJlbnRseSBlbXB0eSwgd2hpY2ggbWVhbnMgd2UgY2FuIGVhZ2VybHkgY29tcHV0ZSB0aGVcbiAgICAgIC8vIG5leHQgc3RhdGUgYmVmb3JlIGVudGVyaW5nIHRoZSByZW5kZXIgcGhhc2UuIElmIHRoZSBuZXcgc3RhdGUgaXMgdGhlXG4gICAgICAvLyBzYW1lIGFzIHRoZSBjdXJyZW50IHN0YXRlLCB3ZSBtYXkgYmUgYWJsZSB0byBiYWlsIG91dCBlbnRpcmVseS5cbiAgICAgIHZhciBsYXN0UmVuZGVyZWRSZWR1Y2VyID0gcXVldWUubGFzdFJlbmRlcmVkUmVkdWNlcjtcblxuICAgICAgaWYgKGxhc3RSZW5kZXJlZFJlZHVjZXIgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gbnVsbDtcblxuICAgICAgICB7XG4gICAgICAgICAgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRTdGF0ZSA9IHF1ZXVlLmxhc3RSZW5kZXJlZFN0YXRlO1xuICAgICAgICAgIHZhciBlYWdlclN0YXRlID0gbGFzdFJlbmRlcmVkUmVkdWNlcihjdXJyZW50U3RhdGUsIGFjdGlvbik7IC8vIFN0YXNoIHRoZSBlYWdlcmx5IGNvbXB1dGVkIHN0YXRlLCBhbmQgdGhlIHJlZHVjZXIgdXNlZCB0byBjb21wdXRlXG4gICAgICAgICAgLy8gaXQsIG9uIHRoZSB1cGRhdGUgb2JqZWN0LiBJZiB0aGUgcmVkdWNlciBoYXNuJ3QgY2hhbmdlZCBieSB0aGVcbiAgICAgICAgICAvLyB0aW1lIHdlIGVudGVyIHRoZSByZW5kZXIgcGhhc2UsIHRoZW4gdGhlIGVhZ2VyIHN0YXRlIGNhbiBiZSB1c2VkXG4gICAgICAgICAgLy8gd2l0aG91dCBjYWxsaW5nIHRoZSByZWR1Y2VyIGFnYWluLlxuXG4gICAgICAgICAgdXBkYXRlLmhhc0VhZ2VyU3RhdGUgPSB0cnVlO1xuICAgICAgICAgIHVwZGF0ZS5lYWdlclN0YXRlID0gZWFnZXJTdGF0ZTtcblxuICAgICAgICAgIGlmIChvYmplY3RJcyhlYWdlclN0YXRlLCBjdXJyZW50U3RhdGUpKSB7XG4gICAgICAgICAgICAvLyBGYXN0IHBhdGguIFdlIGNhbiBiYWlsIG91dCB3aXRob3V0IHNjaGVkdWxpbmcgUmVhY3QgdG8gcmUtcmVuZGVyLlxuICAgICAgICAgICAgLy8gSXQncyBzdGlsbCBwb3NzaWJsZSB0aGF0IHdlJ2xsIG5lZWQgdG8gcmViYXNlIHRoaXMgdXBkYXRlIGxhdGVyLFxuICAgICAgICAgICAgLy8gaWYgdGhlIGNvbXBvbmVudCByZS1yZW5kZXJzIGZvciBhIGRpZmZlcmVudCByZWFzb24gYW5kIGJ5IHRoYXRcbiAgICAgICAgICAgIC8vIHRpbWUgdGhlIHJlZHVjZXIgaGFzIGNoYW5nZWQuXG4gICAgICAgICAgICAvLyBUT0RPOiBEbyB3ZSBzdGlsbCBuZWVkIHRvIGVudGFuZ2xlIHRyYW5zaXRpb25zIGluIHRoaXMgY2FzZT9cbiAgICAgICAgICAgIGVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZUFuZEVhZ2VybHlCYWlsb3V0KGZpYmVyLCBxdWV1ZSwgdXBkYXRlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7Ly8gU3VwcHJlc3MgdGhlIGVycm9yLiBJdCB3aWxsIHRocm93IGFnYWluIGluIHRoZSByZW5kZXIgcGhhc2UuXG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAge1xuICAgICAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRIb29rVXBkYXRlKGZpYmVyLCBxdWV1ZSwgdXBkYXRlLCBsYW5lKTtcblxuICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIGxhbmUpO1xuICAgICAgZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlKHJvb3QsIHF1ZXVlLCBsYW5lKTtcbiAgICB9XG4gIH1cblxuICBtYXJrVXBkYXRlSW5EZXZUb29scyhmaWJlciwgbGFuZSk7XG59XG5cbmZ1bmN0aW9uIGRpc3BhdGNoT3B0aW1pc3RpY1NldFN0YXRlKGZpYmVyLCB0aHJvd0lmRHVyaW5nUmVuZGVyLCBxdWV1ZSwgYWN0aW9uKSB7XG4gIHZhciB0cmFuc2l0aW9uID0gcmVxdWVzdEN1cnJlbnRUcmFuc2l0aW9uKCk7XG5cbiAge1xuICAgIGlmICh0cmFuc2l0aW9uID09PSBudWxsKSB7XG4gICAgICAvLyBBbiBvcHRpbWlzdGljIHVwZGF0ZSBvY2N1cnJlZCwgYnV0IHN0YXJ0VHJhbnNpdGlvbiBpcyBub3Qgb24gdGhlIHN0YWNrLlxuICAgICAgLy8gVGhlcmUgYXJlIHR3byBsaWtlbHkgc2NlbmFyaW9zLlxuICAgICAgLy8gT25lIHBvc3NpYmlsaXR5IGlzIHRoYXQgdGhlIG9wdGltaXN0aWMgdXBkYXRlIGlzIHRyaWdnZXJlZCBieSBhIHJlZ3VsYXJcbiAgICAgIC8vIGV2ZW50IGhhbmRsZXIgKGUuZy4gYG9uU3VibWl0YCkgaW5zdGVhZCBvZiBhbiBhY3Rpb24uIFRoaXMgaXMgYSBtaXN0YWtlXG4gICAgICAvLyBhbmQgd2Ugd2lsbCB3YXJuLlxuICAgICAgLy8gVGhlIG90aGVyIHBvc3NpYmlsaXR5IGlzIHRoZSBvcHRpbWlzdGljIHVwZGF0ZSBpcyBpbnNpZGUgYW4gYXN5bmNcbiAgICAgIC8vIGFjdGlvbiwgYnV0IGFmdGVyIGFuIGBhd2FpdGAuIEluIHRoaXMgY2FzZSwgd2UgY2FuIG1ha2UgaXQgXCJqdXN0IHdvcmtcIlxuICAgICAgLy8gYnkgYXNzb2NpYXRpbmcgdGhlIG9wdGltaXN0aWMgdXBkYXRlIHdpdGggdGhlIHBlbmRpbmcgYXN5bmMgYWN0aW9uLlxuICAgICAgLy8gVGVjaG5pY2FsbHkgaXQncyBwb3NzaWJsZSB0aGF0IHRoZSBvcHRpbWlzdGljIHVwZGF0ZSBpcyB1bnJlbGF0ZWQgdG9cbiAgICAgIC8vIHRoZSBwZW5kaW5nIGFjdGlvbiwgYnV0IHdlIGRvbid0IGhhdmUgYSB3YXkgb2Yga25vd2luZyB0aGlzIGZvciBzdXJlXG4gICAgICAvLyBiZWNhdXNlIGJyb3dzZXJzIGN1cnJlbnRseSBkbyBub3QgcHJvdmlkZSBhIHdheSB0byB0cmFjayBhc3luYyBzY29wZS5cbiAgICAgIC8vIChUaGUgQXN5bmNDb250ZXh0IHByb3Bvc2FsLCBpZiBpdCBsYW5kcywgd2lsbCBzb2x2ZSB0aGlzIGluIHRoZVxuICAgICAgLy8gZnV0dXJlLikgSG93ZXZlciwgdGhpcyBpcyBubyBkaWZmZXJlbnQgdGhhbiB0aGUgcHJvYmxlbSBvZiB1bnJlbGF0ZWRcbiAgICAgIC8vIHRyYW5zaXRpb25zIGJlaW5nIGdyb3VwZWQgdG9nZXRoZXIg4oCUIGl0J3Mgbm90IHdyb25nIHBlciBzZSwgYnV0IGl0J3NcbiAgICAgIC8vIG5vdCBpZGVhbC5cbiAgICAgIC8vIE9uY2UgQXN5bmNDb250ZXh0IHN0YXJ0cyBsYW5kaW5nIGluIGJyb3dzZXJzLCB3ZSB3aWxsIHByb3ZpZGUgYmV0dGVyXG4gICAgICAvLyB3YXJuaW5ncyBpbiBkZXZlbG9wbWVudCBmb3IgdGhlc2UgY2FzZXMuXG4gICAgICBpZiAocGVla0VudGFuZ2xlZEFjdGlvbkxhbmUoKSAhPT0gTm9MYW5lKSA7IGVsc2Uge1xuICAgICAgICAvLyBUaGVyZSdzIG5vIHBlbmRpbmcgYXN5bmMgYWN0aW9uLiBUaGUgbW9zdCBsaWtlbHkgY2F1c2UgaXMgdGhhdCB3ZSdyZVxuICAgICAgICAvLyBpbnNpZGUgYSByZWd1bGFyIGV2ZW50IGhhbmRsZXIgKGUuZy4gb25TdWJtaXQpIGluc3RlYWQgb2YgYW4gYWN0aW9uLlxuICAgICAgICBlcnJvcignQW4gb3B0aW1pc3RpYyBzdGF0ZSB1cGRhdGUgb2NjdXJyZWQgb3V0c2lkZSBhIHRyYW5zaXRpb24gb3IgJyArICdhY3Rpb24uIFRvIGZpeCwgbW92ZSB0aGUgdXBkYXRlIHRvIGFuIGFjdGlvbiwgb3Igd3JhcCAnICsgJ3dpdGggc3RhcnRUcmFuc2l0aW9uLicpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciB1cGRhdGUgPSB7XG4gICAgLy8gQW4gb3B0aW1pc3RpYyB1cGRhdGUgY29tbWl0cyBzeW5jaHJvbm91c2x5LlxuICAgIGxhbmU6IFN5bmNMYW5lLFxuICAgIC8vIEFmdGVyIGNvbW1pdHRpbmcsIHRoZSBvcHRpbWlzdGljIHVwZGF0ZSBpcyBcInJldmVydGVkXCIgdXNpbmcgdGhlIHNhbWVcbiAgICAvLyBsYW5lIGFzIHRoZSB0cmFuc2l0aW9uIGl0J3MgYXNzb2NpYXRlZCB3aXRoLlxuICAgIHJldmVydExhbmU6IHJlcXVlc3RUcmFuc2l0aW9uTGFuZSgpLFxuICAgIGFjdGlvbjogYWN0aW9uLFxuICAgIGhhc0VhZ2VyU3RhdGU6IGZhbHNlLFxuICAgIGVhZ2VyU3RhdGU6IG51bGwsXG4gICAgbmV4dDogbnVsbFxuICB9O1xuXG4gIGlmIChpc1JlbmRlclBoYXNlVXBkYXRlKGZpYmVyKSkge1xuICAgIC8vIFdoZW4gY2FsbGluZyBzdGFydFRyYW5zaXRpb24gZHVyaW5nIHJlbmRlciwgdGhpcyB3YXJucyBpbnN0ZWFkIG9mXG4gICAgLy8gdGhyb3dpbmcgYmVjYXVzZSB0aHJvd2luZyB3b3VsZCBiZSBhIGJyZWFraW5nIGNoYW5nZS4gc2V0T3B0aW1pc3RpY1N0YXRlXG4gICAgLy8gaXMgYSBuZXcgQVBJIHNvIGl0J3MgT0sgdG8gdGhyb3cuXG4gICAgaWYgKHRocm93SWZEdXJpbmdSZW5kZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVwZGF0ZSBvcHRpbWlzdGljIHN0YXRlIHdoaWxlIHJlbmRlcmluZy4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc3RhcnRUcmFuc2l0aW9uIHdhcyBjYWxsZWQgZHVyaW5nIHJlbmRlci4gV2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZ1xuICAgICAgLy8gYmVzaWRlcyB3YXJuIGhlcmUgYmVjYXVzZSB0aGUgcmVuZGVyIHBoYXNlIHVwZGF0ZSB3b3VsZCBiZSBvdmVyaWRkZW4gYnlcbiAgICAgIC8vIHRoZSBzZWNvbmQgdXBkYXRlLCBhbnl3YXkuIFdlIGNhbiByZW1vdmUgdGhpcyBicmFuY2ggYW5kIG1ha2UgaXQgdGhyb3dcbiAgICAgIC8vIGluIGEgZnV0dXJlIHJlbGVhc2UuXG4gICAgICB7XG4gICAgICAgIGVycm9yKCdDYW5ub3QgY2FsbCBzdGFydFRyYW5zaXRpb24gd2hpbGUgcmVuZGVyaW5nLicpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZShmaWJlciwgcXVldWUsIHVwZGF0ZSwgU3luY0xhbmUpO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIC8vIE5PVEU6IFRoZSBvcHRpbWlzdGljIHVwZGF0ZSBpbXBsZW1lbnRhdGlvbiBhc3N1bWVzIHRoYXQgdGhlIHRyYW5zaXRpb25cbiAgICAgIC8vIHdpbGwgbmV2ZXIgYmUgYXR0ZW1wdGVkIGJlZm9yZSB0aGUgb3B0aW1pc3RpYyB1cGRhdGUuIFRoaXMgY3VycmVudGx5XG4gICAgICAvLyBob2xkcyBiZWNhdXNlIHRoZSBvcHRpbWlzdGljIHVwZGF0ZSBpcyBhbHdheXMgc3luY2hyb25vdXMuIElmIHdlIGV2ZXJcbiAgICAgIC8vIGNoYW5nZSB0aGF0LCB3ZSdsbCBuZWVkIHRvIGFjY291bnQgZm9yIHRoaXMuXG4gICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lKTsgLy8gT3B0aW1pc3RpYyB1cGRhdGVzIGFyZSBhbHdheXMgc3luY2hyb25vdXMsIHNvIHdlIGRvbid0IG5lZWQgdG8gY2FsbFxuICAgICAgLy8gZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlIGhlcmUuXG4gICAgfVxuICB9XG5cbiAgbWFya1VwZGF0ZUluRGV2VG9vbHMoZmliZXIsIFN5bmNMYW5lKTtcbn1cblxuZnVuY3Rpb24gaXNSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikge1xuICB2YXIgYWx0ZXJuYXRlID0gZmliZXIuYWx0ZXJuYXRlO1xuICByZXR1cm4gZmliZXIgPT09IGN1cnJlbnRseVJlbmRlcmluZ0ZpYmVyJDEgfHwgYWx0ZXJuYXRlICE9PSBudWxsICYmIGFsdGVybmF0ZSA9PT0gY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMTtcbn1cblxuZnVuY3Rpb24gZW5xdWV1ZVJlbmRlclBoYXNlVXBkYXRlKHF1ZXVlLCB1cGRhdGUpIHtcbiAgLy8gVGhpcyBpcyBhIHJlbmRlciBwaGFzZSB1cGRhdGUuIFN0YXNoIGl0IGluIGEgbGF6aWx5LWNyZWF0ZWQgbWFwIG9mXG4gIC8vIHF1ZXVlIC0+IGxpbmtlZCBsaXN0IG9mIHVwZGF0ZXMuIEFmdGVyIHRoaXMgcmVuZGVyIHBhc3MsIHdlJ2xsIHJlc3RhcnRcbiAgLy8gYW5kIGFwcGx5IHRoZSBzdGFzaGVkIHVwZGF0ZXMgb24gdG9wIG9mIHRoZSB3b3JrLWluLXByb2dyZXNzIGhvb2suXG4gIGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyA9IGRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGUgPSB0cnVlO1xuICB2YXIgcGVuZGluZyA9IHF1ZXVlLnBlbmRpbmc7XG5cbiAgaWYgKHBlbmRpbmcgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIHRoZSBmaXJzdCB1cGRhdGUuIENyZWF0ZSBhIGNpcmN1bGFyIGxpc3QuXG4gICAgdXBkYXRlLm5leHQgPSB1cGRhdGU7XG4gIH0gZWxzZSB7XG4gICAgdXBkYXRlLm5leHQgPSBwZW5kaW5nLm5leHQ7XG4gICAgcGVuZGluZy5uZXh0ID0gdXBkYXRlO1xuICB9XG5cbiAgcXVldWUucGVuZGluZyA9IHVwZGF0ZTtcbn0gLy8gVE9ETzogTW92ZSB0byBSZWFjdEZpYmVyQ29uY3VycmVudFVwZGF0ZXM/XG5cblxuZnVuY3Rpb24gZW50YW5nbGVUcmFuc2l0aW9uVXBkYXRlKHJvb3QsIHF1ZXVlLCBsYW5lKSB7XG4gIGlmIChpc1RyYW5zaXRpb25MYW5lKGxhbmUpKSB7XG4gICAgdmFyIHF1ZXVlTGFuZXMgPSBxdWV1ZS5sYW5lczsgLy8gSWYgYW55IGVudGFuZ2xlZCBsYW5lcyBhcmUgbm8gbG9uZ2VyIHBlbmRpbmcgb24gdGhlIHJvb3QsIHRoZW4gdGhleVxuICAgIC8vIG11c3QgaGF2ZSBmaW5pc2hlZC4gV2UgY2FuIHJlbW92ZSB0aGVtIGZyb20gdGhlIHNoYXJlZCBxdWV1ZSwgd2hpY2hcbiAgICAvLyByZXByZXNlbnRzIGEgc3VwZXJzZXQgb2YgdGhlIGFjdHVhbGx5IHBlbmRpbmcgbGFuZXMuIEluIHNvbWUgY2FzZXMgd2VcbiAgICAvLyBtYXkgZW50YW5nbGUgbW9yZSB0aGFuIHdlIG5lZWQgdG8sIGJ1dCB0aGF0J3MgT0suIEluIGZhY3QgaXQncyB3b3JzZSBpZlxuICAgIC8vIHdlICpkb24ndCogZW50YW5nbGUgd2hlbiB3ZSBzaG91bGQuXG5cbiAgICBxdWV1ZUxhbmVzID0gaW50ZXJzZWN0TGFuZXMocXVldWVMYW5lcywgcm9vdC5wZW5kaW5nTGFuZXMpOyAvLyBFbnRhbmdsZSB0aGUgbmV3IHRyYW5zaXRpb24gbGFuZSB3aXRoIHRoZSBvdGhlciB0cmFuc2l0aW9uIGxhbmVzLlxuXG4gICAgdmFyIG5ld1F1ZXVlTGFuZXMgPSBtZXJnZUxhbmVzKHF1ZXVlTGFuZXMsIGxhbmUpO1xuICAgIHF1ZXVlLmxhbmVzID0gbmV3UXVldWVMYW5lczsgLy8gRXZlbiBpZiBxdWV1ZS5sYW5lcyBhbHJlYWR5IGluY2x1ZGUgbGFuZSwgd2UgZG9uJ3Qga25vdyBmb3IgY2VydGFpbiBpZlxuICAgIC8vIHRoZSBsYW5lIGZpbmlzaGVkIHNpbmNlIHRoZSBsYXN0IHRpbWUgd2UgZW50YW5nbGVkIGl0LiBTbyB3ZSBuZWVkIHRvXG4gICAgLy8gZW50YW5nbGUgaXQgYWdhaW4sIGp1c3QgdG8gYmUgc3VyZS5cblxuICAgIG1hcmtSb290RW50YW5nbGVkKHJvb3QsIG5ld1F1ZXVlTGFuZXMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtVcGRhdGVJbkRldlRvb2xzKGZpYmVyLCBsYW5lLCBhY3Rpb24pIHtcblxuICB7XG4gICAgbWFya1N0YXRlVXBkYXRlU2NoZWR1bGVkKGZpYmVyLCBsYW5lKTtcbiAgfVxufVxuXG52YXIgQ29udGV4dE9ubHlEaXNwYXRjaGVyID0ge1xuICByZWFkQ29udGV4dDogcmVhZENvbnRleHQsXG4gIHVzZTogdXNlLFxuICB1c2VDYWxsYmFjazogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VDb250ZXh0OiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VJbXBlcmF0aXZlSGFuZGxlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZUxheW91dEVmZmVjdDogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VJbnNlcnRpb25FZmZlY3Q6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlTWVtbzogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VSZWR1Y2VyOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZVJlZjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VTdGF0ZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VEZWJ1Z1ZhbHVlOiB0aHJvd0ludmFsaWRIb29rRXJyb3IsXG4gIHVzZURlZmVycmVkVmFsdWU6IHRocm93SW52YWxpZEhvb2tFcnJvcixcbiAgdXNlVHJhbnNpdGlvbjogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogdGhyb3dJbnZhbGlkSG9va0Vycm9yLFxuICB1c2VJZDogdGhyb3dJbnZhbGlkSG9va0Vycm9yXG59O1xuXG57XG4gIENvbnRleHRPbmx5RGlzcGF0Y2hlci51c2VDYWNoZVJlZnJlc2ggPSB0aHJvd0ludmFsaWRIb29rRXJyb3I7XG59XG5cbntcbiAgQ29udGV4dE9ubHlEaXNwYXRjaGVyLnVzZU1lbW9DYWNoZSA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbn1cblxue1xuICBDb250ZXh0T25seURpc3BhdGNoZXIudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPSB0aHJvd0ludmFsaWRIb29rRXJyb3I7XG4gIENvbnRleHRPbmx5RGlzcGF0Y2hlci51c2VGb3JtU3RhdGUgPSB0aHJvd0ludmFsaWRIb29rRXJyb3I7XG4gIENvbnRleHRPbmx5RGlzcGF0Y2hlci51c2VBY3Rpb25TdGF0ZSA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbn1cblxue1xuICBDb250ZXh0T25seURpc3BhdGNoZXIudXNlT3B0aW1pc3RpYyA9IHRocm93SW52YWxpZEhvb2tFcnJvcjtcbn1cblxudmFyIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IG51bGw7XG52YXIgSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFViA9IG51bGw7XG52YXIgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IG51bGw7XG52YXIgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0gbnVsbDtcbnZhciBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWID0gbnVsbDtcbnZhciBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IG51bGw7XG52YXIgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IG51bGw7XG5cbntcbiAgdmFyIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBlcnJvcignQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gJyArICdJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnICsgJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnICsgJ2luc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuJyk7XG4gIH07XG5cbiAgdmFyIHdhcm5JbnZhbGlkSG9va0FjY2VzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICBlcnJvcignRG8gbm90IGNhbGwgSG9va3MgaW5zaWRlIHVzZUVmZmVjdCguLi4pLCB1c2VNZW1vKC4uLiksIG9yIG90aGVyIGJ1aWx0LWluIEhvb2tzLiAnICsgJ1lvdSBjYW4gb25seSBjYWxsIEhvb2tzIGF0IHRoZSB0b3AgbGV2ZWwgb2YgeW91ciBSZWFjdCBmdW5jdGlvbi4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlICcgKyAnaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9ydWxlcy1vZi1ob29rcycpO1xuICB9O1xuXG4gIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZTogdXNlLFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHJldHVybiBtb3VudENhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgY2hlY2tEZXBzQXJlQXJyYXlEZXYoZGVwcyk7XG4gICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0JztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHJldHVybiBtb3VudEluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIGNoZWNrRGVwc0FyZUFycmF5RGV2KGRlcHMpO1xuICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICBjaGVja0RlcHNBcmVBcnJheURldihkZXBzKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50UmVkdWNlcihyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZjogZnVuY3Rpb24gKGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVmJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRSZWYoaW5pdGlhbFZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudERlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50U3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xuICAgIH0sXG4gICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUlkJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRJZCgpO1xuICAgIH1cbiAgfTtcblxuICB7XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZUNhY2hlUmVmcmVzaCA9IGZ1bmN0aW9uIHVzZUNhY2hlUmVmcmVzaCgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhY2hlUmVmcmVzaCc7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50UmVmcmVzaCgpO1xuICAgIH07XG4gIH1cblxuICB7XG4gICAgSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZU1lbW9DYWNoZSA9IHVzZU1lbW9DYWNoZTtcbiAgfVxuXG4gIHtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPSB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcblxuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VGb3JtU3RhdGUgPSBmdW5jdGlvbiB1c2VGb3JtU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluaykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRm9ybVN0YXRlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSk7XG4gICAgfTtcblxuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VBY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uIHVzZUFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUFjdGlvblN0YXRlJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSk7XG4gICAgfTtcbiAgfVxuXG4gIHtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIHVzZU9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU9wdGltaXN0aWMnO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudE9wdGltaXN0aWMocGFzc3Rocm91Z2gpO1xuICAgIH07XG4gIH1cblxuICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlOiB1c2UsXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50SW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudExheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBtb3VudFJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFJlZihpbml0aWFsVmFsdWUpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudERlYnVnVmFsdWUoKTtcbiAgICB9LFxuICAgIHVzZURlZmVycmVkVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VEZWZlcnJlZFZhbHVlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50RGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgICB9LFxuICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJZCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudElkKCk7XG4gICAgfVxuICB9O1xuXG4gIHtcbiAgICBIb29rc0Rpc3BhdGNoZXJPbk1vdW50V2l0aEhvb2tUeXBlc0luREVWLnVzZUNhY2hlUmVmcmVzaCA9IGZ1bmN0aW9uIHVzZUNhY2hlUmVmcmVzaCgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhY2hlUmVmcmVzaCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudFJlZnJlc2goKTtcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYudXNlTWVtb0NhY2hlID0gdXNlTWVtb0NhY2hlO1xuICB9XG5cbiAge1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPSB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcblxuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gdXNlRm9ybVN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUZvcm1TdGF0ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHdhcm5PblVzZUZvcm1TdGF0ZUluRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSk7XG4gICAgfTtcblxuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYudXNlQWN0aW9uU3RhdGUgPSBmdW5jdGlvbiB1c2VBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VBY3Rpb25TdGF0ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlKTtcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uTW91bnRXaXRoSG9va1R5cGVzSW5ERVYudXNlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIHVzZU9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU9wdGltaXN0aWMnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRPcHRpbWlzdGljKHBhc3N0aHJvdWdoKTtcbiAgICB9O1xuICB9XG5cbiAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZTogdXNlLFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlRWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VFZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUluc2VydGlvbkVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbnNlcnRpb25FZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUxheW91dEVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTGF5b3V0RWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlUmVmKCk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlVHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3luY0V4dGVybmFsU3RvcmUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xuICAgIH0sXG4gICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUlkJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUlkKCk7XG4gICAgfVxuICB9O1xuXG4gIHtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZUNhY2hlUmVmcmVzaCA9IGZ1bmN0aW9uIHVzZUNhY2hlUmVmcmVzaCgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhY2hlUmVmcmVzaCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWZyZXNoKCk7XG4gICAgfTtcbiAgfVxuXG4gIHtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZU1lbW9DYWNoZSA9IHVzZU1lbW9DYWNoZTtcbiAgfVxuXG4gIHtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID0gdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM7XG5cbiAgICBIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZUZvcm1TdGF0ZSA9IGZ1bmN0aW9uIHVzZUZvcm1TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VGb3JtU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB3YXJuT25Vc2VGb3JtU3RhdGVJbkRldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcblxuICAgIEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlQWN0aW9uU3RhdGUgPSBmdW5jdGlvbiB1c2VBY3Rpb25TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VBY3Rpb25TdGF0ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG4gIH1cblxuICB7XG4gICAgSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gdXNlT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3B0aW1pc3RpYyc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbiAgICB9O1xuICB9XG5cbiAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWID0ge1xuICAgIHJlYWRDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlOiB1c2UsXG4gICAgdXNlQ2FsbGJhY2s6IGZ1bmN0aW9uIChjYWxsYmFjaywgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FsbGJhY2snO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0JztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlTGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlTWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiByZXJlbmRlclJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWYoKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRGVidWdWYWx1ZSgpO1xuICAgIH0sXG4gICAgdXNlRGVmZXJyZWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlZmVycmVkVmFsdWUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJEZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlclRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN5bmNFeHRlcm5hbFN0b3JlJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVN5bmNFeHRlcm5hbFN0b3JlKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KTtcbiAgICB9LFxuICAgIHVzZUlkOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJZCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJZCgpO1xuICAgIH1cbiAgfTtcblxuICB7XG4gICAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZUNhY2hlUmVmcmVzaCA9IGZ1bmN0aW9uIHVzZUNhY2hlUmVmcmVzaCgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhY2hlUmVmcmVzaCc7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWZyZXNoKCk7XG4gICAgfTtcbiAgfVxuXG4gIHtcbiAgICBIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlTWVtb0NhY2hlID0gdXNlTWVtb0NhY2hlO1xuICB9XG5cbiAge1xuICAgIEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9IHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuXG4gICAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZUZvcm1TdGF0ZSA9IGZ1bmN0aW9uIHVzZUZvcm1TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VGb3JtU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB3YXJuT25Vc2VGb3JtU3RhdGVJbkRldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyQWN0aW9uU3RhdGUoYWN0aW9uKTtcbiAgICB9O1xuXG4gICAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gdXNlQWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluaykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQWN0aW9uU3RhdGUnO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG4gIH1cblxuICB7XG4gICAgSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWLnVzZU9wdGltaXN0aWMgPSBmdW5jdGlvbiB1c2VPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VPcHRpbWlzdGljJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG4gICAgfTtcbiAgfVxuXG4gIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZTogZnVuY3Rpb24gKHVzYWJsZSkge1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICByZXR1cm4gdXNlKHVzYWJsZSk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRDYWxsYmFjayhjYWxsYmFjaywgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ29udGV4dCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUltcGVyYXRpdmVIYW5kbGU6IGZ1bmN0aW9uIChyZWYsIGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW1wZXJhdGl2ZUhhbmRsZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiBtb3VudEluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50TGF5b3V0RWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VNZW1vOiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VNZW1vJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgbW91bnRIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIG1vdW50TWVtbyhjcmVhdGUsIGRlcHMpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVkdWNlcjogZnVuY3Rpb24gKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZHVjZXInO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50UmVmKGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VTdGF0ZTogZnVuY3Rpb24gKGluaXRpYWxTdGF0ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3RhdGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gbW91bnRTdGF0ZShpbml0aWFsU3RhdGUpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlRGVidWdWYWx1ZTogZnVuY3Rpb24gKHZhbHVlLCBmb3JtYXR0ZXJGbikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVidWdWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnREZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnREZWZlcnJlZFZhbHVlKHZhbHVlLCBpbml0aWFsVmFsdWUpO1xuICAgIH0sXG4gICAgdXNlVHJhbnNpdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlVHJhbnNpdGlvbic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRUcmFuc2l0aW9uKCk7XG4gICAgfSxcbiAgICB1c2VTeW5jRXh0ZXJuYWxTdG9yZTogZnVuY3Rpb24gKHN1YnNjcmliZSwgZ2V0U25hcHNob3QsIGdldFNlcnZlclNuYXBzaG90KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTeW5jRXh0ZXJuYWxTdG9yZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG4gICAgfSxcbiAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSWQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50SWQoKTtcbiAgICB9XG4gIH07XG5cbiAge1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPbk1vdW50SW5ERVYudXNlQ2FjaGVSZWZyZXNoID0gZnVuY3Rpb24gdXNlQ2FjaGVSZWZyZXNoKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FjaGVSZWZyZXNoJztcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRSZWZyZXNoKCk7XG4gICAgfTtcbiAgfVxuXG4gIHtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZU1lbW9DYWNoZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHJldHVybiB1c2VNZW1vQ2FjaGUoc2l6ZSk7XG4gICAgfTtcbiAgfVxuXG4gIHtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzID0gdXNlSG9zdFRyYW5zaXRpb25TdGF0dXM7XG5cbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZUZvcm1TdGF0ZSA9IGZ1bmN0aW9uIHVzZUZvcm1TdGF0ZShhY3Rpb24sIGluaXRpYWxTdGF0ZSwgcGVybWFsaW5rKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VGb3JtU3RhdGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUpO1xuICAgIH07XG5cbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25Nb3VudEluREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gdXNlQWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluaykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQWN0aW9uU3RhdGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICBtb3VudEhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIG1vdW50QWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUpO1xuICAgIH07XG4gIH1cblxuICB7XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gdXNlT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3B0aW1pc3RpYyc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIG1vdW50SG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gbW91bnRPcHRpbWlzdGljKHBhc3N0aHJvdWdoKTtcbiAgICB9O1xuICB9XG5cbiAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYgPSB7XG4gICAgcmVhZENvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICB3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZTogZnVuY3Rpb24gKHVzYWJsZSkge1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICByZXR1cm4gdXNlKHVzYWJsZSk7XG4gICAgfSxcbiAgICB1c2VDYWxsYmFjazogZnVuY3Rpb24gKGNhbGxiYWNrLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDYWxsYmFjayc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUNhbGxiYWNrKGNhbGxiYWNrLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUNvbnRleHQ6IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VDb250ZXh0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVhZENvbnRleHQoY29udGV4dCk7XG4gICAgfSxcbiAgICB1c2VFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlSW1wZXJhdGl2ZUhhbmRsZTogZnVuY3Rpb24gKHJlZiwgY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VJbXBlcmF0aXZlSGFuZGxlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW1wZXJhdGl2ZUhhbmRsZShyZWYsIGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbnNlcnRpb25FZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUluc2VydGlvbkVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUluc2VydGlvbkVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTGF5b3V0RWZmZWN0OiBmdW5jdGlvbiAoY3JlYXRlLCBkZXBzKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVMYXlvdXRFZmZlY3QoY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZU1lbW86IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU1lbW8nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVNZW1vKGNyZWF0ZSwgZGVwcyk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWR1Y2VyOiBmdW5jdGlvbiAocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlUmVkdWNlcic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVJlZHVjZXIocmVkdWNlciwgaW5pdGlhbEFyZywgaW5pdCk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBSZWFjdFNoYXJlZEludGVybmFscy5IID0gcHJldkRpc3BhdGNoZXI7XG4gICAgICB9XG4gICAgfSxcbiAgICB1c2VSZWY6IGZ1bmN0aW9uIChpbml0aWFsVmFsdWUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVJlZic7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZigpO1xuICAgIH0sXG4gICAgdXNlU3RhdGU6IGZ1bmN0aW9uIChpbml0aWFsU3RhdGUpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN0YXRlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gdXBkYXRlU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZURlZmVycmVkVmFsdWUodmFsdWUsIGluaXRpYWxWYWx1ZSk7XG4gICAgfSxcbiAgICB1c2VUcmFuc2l0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VUcmFuc2l0aW9uJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlVHJhbnNpdGlvbigpO1xuICAgIH0sXG4gICAgdXNlU3luY0V4dGVybmFsU3RvcmU6IGZ1bmN0aW9uIChzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlU3luY0V4dGVybmFsU3RvcmUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZShzdWJzY3JpYmUsIGdldFNuYXBzaG90LCBnZXRTZXJ2ZXJTbmFwc2hvdCk7XG4gICAgfSxcbiAgICB1c2VJZDogZnVuY3Rpb24gKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSWQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJZCgpO1xuICAgIH1cbiAgfTtcblxuICB7XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlQ2FjaGVSZWZyZXNoID0gZnVuY3Rpb24gdXNlQ2FjaGVSZWZyZXNoKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FjaGVSZWZyZXNoJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZnJlc2goKTtcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZU1lbW9DYWNoZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHJldHVybiB1c2VNZW1vQ2FjaGUoc2l6ZSk7XG4gICAgfTtcbiAgfVxuXG4gIHtcbiAgICBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVi51c2VIb3N0VHJhbnNpdGlvblN0YXR1cyA9IHVzZUhvc3RUcmFuc2l0aW9uU3RhdHVzO1xuXG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gdXNlRm9ybVN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUZvcm1TdGF0ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUFjdGlvblN0YXRlKGFjdGlvbik7XG4gICAgfTtcblxuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWLnVzZUFjdGlvblN0YXRlID0gZnVuY3Rpb24gdXNlQWN0aW9uU3RhdGUoYWN0aW9uLCBpbml0aWFsU3RhdGUsIHBlcm1hbGluaykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQWN0aW9uU3RhdGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG4gIH1cblxuICB7XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uVXBkYXRlSW5ERVYudXNlT3B0aW1pc3RpYyA9IGZ1bmN0aW9uIHVzZU9wdGltaXN0aWMocGFzc3Rocm91Z2gsIHJlZHVjZXIpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZU9wdGltaXN0aWMnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVPcHRpbWlzdGljKHBhc3N0aHJvdWdoLCByZWR1Y2VyKTtcbiAgICB9O1xuICB9XG5cbiAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFViA9IHtcbiAgICByZWFkQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIHdhcm5JbnZhbGlkQ29udGV4dEFjY2VzcygpO1xuICAgICAgcmV0dXJuIHJlYWRDb250ZXh0KGNvbnRleHQpO1xuICAgIH0sXG4gICAgdXNlOiBmdW5jdGlvbiAodXNhYmxlKSB7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHJldHVybiB1c2UodXNhYmxlKTtcbiAgICB9LFxuICAgIHVzZUNhbGxiYWNrOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNhbGxiYWNrJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlQ2FsbGJhY2soY2FsbGJhY2ssIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlQ29udGV4dDogZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUNvbnRleHQnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZWFkQ29udGV4dChjb250ZXh0KTtcbiAgICB9LFxuICAgIHVzZUVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VJbXBlcmF0aXZlSGFuZGxlOiBmdW5jdGlvbiAocmVmLCBjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUltcGVyYXRpdmVIYW5kbGUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVJbXBlcmF0aXZlSGFuZGxlKHJlZiwgY3JlYXRlLCBkZXBzKTtcbiAgICB9LFxuICAgIHVzZUluc2VydGlvbkVmZmVjdDogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlSW5zZXJ0aW9uRWZmZWN0JztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSW5zZXJ0aW9uRWZmZWN0KGNyZWF0ZSwgZGVwcyk7XG4gICAgfSxcbiAgICB1c2VMYXlvdXRFZmZlY3Q6IGZ1bmN0aW9uIChjcmVhdGUsIGRlcHMpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUxheW91dEVmZmVjdCc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZUxheW91dEVmZmVjdChjcmVhdGUsIGRlcHMpO1xuICAgIH0sXG4gICAgdXNlTWVtbzogZnVuY3Rpb24gKGNyZWF0ZSwgZGVwcykge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlTWVtbyc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW8oY3JlYXRlLCBkZXBzKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZVJlZHVjZXI6IGZ1bmN0aW9uIChyZWR1Y2VyLCBpbml0aWFsQXJnLCBpbml0KSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWR1Y2VyJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICB2YXIgcHJldkRpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5IO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWO1xuXG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gcmVyZW5kZXJSZWR1Y2VyKHJlZHVjZXIsIGluaXRpYWxBcmcsIGluaXQpO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuSCA9IHByZXZEaXNwYXRjaGVyO1xuICAgICAgfVxuICAgIH0sXG4gICAgdXNlUmVmOiBmdW5jdGlvbiAoaW5pdGlhbFZhbHVlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VSZWYnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVSZWYoKTtcbiAgICB9LFxuICAgIHVzZVN0YXRlOiBmdW5jdGlvbiAoaW5pdGlhbFN0YXRlKSB7XG4gICAgICBjdXJyZW50SG9va05hbWVJbkRldiA9ICd1c2VTdGF0ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgdmFyIHByZXZEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuSDtcbiAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFVjtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIHJlcmVuZGVyU3RhdGUoaW5pdGlhbFN0YXRlKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbiAgICAgIH1cbiAgICB9LFxuICAgIHVzZURlYnVnVmFsdWU6IGZ1bmN0aW9uICh2YWx1ZSwgZm9ybWF0dGVyRm4pIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZURlYnVnVmFsdWUnO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiB1cGRhdGVEZWJ1Z1ZhbHVlKCk7XG4gICAgfSxcbiAgICB1c2VEZWZlcnJlZFZhbHVlOiBmdW5jdGlvbiAodmFsdWUsIGluaXRpYWxWYWx1ZSkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlRGVmZXJyZWRWYWx1ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyRGVmZXJyZWRWYWx1ZSh2YWx1ZSwgaW5pdGlhbFZhbHVlKTtcbiAgICB9LFxuICAgIHVzZVRyYW5zaXRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVRyYW5zaXRpb24nO1xuICAgICAgd2FybkludmFsaWRIb29rQWNjZXNzKCk7XG4gICAgICB1cGRhdGVIb29rVHlwZXNEZXYoKTtcbiAgICAgIHJldHVybiByZXJlbmRlclRyYW5zaXRpb24oKTtcbiAgICB9LFxuICAgIHVzZVN5bmNFeHRlcm5hbFN0b3JlOiBmdW5jdGlvbiAoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZVN5bmNFeHRlcm5hbFN0b3JlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlU3luY0V4dGVybmFsU3RvcmUoc3Vic2NyaWJlLCBnZXRTbmFwc2hvdCwgZ2V0U2VydmVyU25hcHNob3QpO1xuICAgIH0sXG4gICAgdXNlSWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUlkJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gdXBkYXRlSWQoKTtcbiAgICB9XG4gIH07XG5cbiAge1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlQ2FjaGVSZWZyZXNoID0gZnVuY3Rpb24gdXNlQ2FjaGVSZWZyZXNoKCkge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlQ2FjaGVSZWZyZXNoJztcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHVwZGF0ZVJlZnJlc2goKTtcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlTWVtb0NhY2hlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgcmV0dXJuIHVzZU1lbW9DYWNoZShzaXplKTtcbiAgICB9O1xuICB9XG5cbiAge1xuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlSG9zdFRyYW5zaXRpb25TdGF0dXMgPSB1c2VIb3N0VHJhbnNpdGlvblN0YXR1cztcblxuICAgIEludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYudXNlRm9ybVN0YXRlID0gZnVuY3Rpb24gdXNlRm9ybVN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUZvcm1TdGF0ZSc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyQWN0aW9uU3RhdGUoYWN0aW9uKTtcbiAgICB9O1xuXG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VBY3Rpb25TdGF0ZSA9IGZ1bmN0aW9uIHVzZUFjdGlvblN0YXRlKGFjdGlvbiwgaW5pdGlhbFN0YXRlLCBwZXJtYWxpbmspIHtcbiAgICAgIGN1cnJlbnRIb29rTmFtZUluRGV2ID0gJ3VzZUFjdGlvblN0YXRlJztcbiAgICAgIHdhcm5JbnZhbGlkSG9va0FjY2VzcygpO1xuICAgICAgdXBkYXRlSG9va1R5cGVzRGV2KCk7XG4gICAgICByZXR1cm4gcmVyZW5kZXJBY3Rpb25TdGF0ZShhY3Rpb24pO1xuICAgIH07XG4gIH1cblxuICB7XG4gICAgSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uUmVyZW5kZXJJbkRFVi51c2VPcHRpbWlzdGljID0gZnVuY3Rpb24gdXNlT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcikge1xuICAgICAgY3VycmVudEhvb2tOYW1lSW5EZXYgPSAndXNlT3B0aW1pc3RpYyc7XG4gICAgICB3YXJuSW52YWxpZEhvb2tBY2Nlc3MoKTtcbiAgICAgIHVwZGF0ZUhvb2tUeXBlc0RldigpO1xuICAgICAgcmV0dXJuIHJlcmVuZGVyT3B0aW1pc3RpYyhwYXNzdGhyb3VnaCwgcmVkdWNlcik7XG4gICAgfTtcbiAgfVxufVxuXG52YXIgbm93ID0gU2NoZWR1bGVyLnVuc3RhYmxlX25vdztcbnZhciBjb21taXRUaW1lID0gMDtcbnZhciBsYXlvdXRFZmZlY3RTdGFydFRpbWUgPSAtMTtcbnZhciBwcm9maWxlclN0YXJ0VGltZSA9IC0xO1xudmFyIHBhc3NpdmVFZmZlY3RTdGFydFRpbWUgPSAtMTtcbi8qKlxuICogVHJhY2tzIHdoZXRoZXIgdGhlIGN1cnJlbnQgdXBkYXRlIHdhcyBhIG5lc3RlZC9jYXNjYWRpbmcgdXBkYXRlIChzY2hlZHVsZWQgZnJvbSBhIGxheW91dCBlZmZlY3QpLlxuICpcbiAqIFRoZSBvdmVyYWxsIHNlcXVlbmNlIGlzOlxuICogICAxLiByZW5kZXJcbiAqICAgMi4gY29tbWl0IChhbmQgY2FsbCBgb25SZW5kZXJgLCBgb25Db21taXRgKVxuICogICAzLiBjaGVjayBmb3IgbmVzdGVkIHVwZGF0ZXNcbiAqICAgNC4gZmx1c2ggcGFzc2l2ZSBlZmZlY3RzIChhbmQgY2FsbCBgb25Qb3N0Q29tbWl0YClcbiAqXG4gKiBOZXN0ZWQgdXBkYXRlcyBhcmUgaWRlbnRpZmllZCBpbiBzdGVwIDMgYWJvdmUsXG4gKiBidXQgc3RlcCA0IHN0aWxsIGFwcGxpZXMgdG8gdGhlIHdvcmsgdGhhdCB3YXMganVzdCBjb21taXR0ZWQuXG4gKiBXZSB1c2UgdHdvIGZsYWdzIHRvIHRyYWNrIG5lc3RlZCB1cGRhdGVzIHRoZW46XG4gKiBvbmUgdHJhY2tzIHdoZXRoZXIgdGhlIHVwY29taW5nIHVwZGF0ZSBpcyBhIG5lc3RlZCB1cGRhdGUsXG4gKiBhbmQgdGhlIG90aGVyIHRyYWNrcyB3aGV0aGVyIHRoZSBjdXJyZW50IHVwZGF0ZSB3YXMgYSBuZXN0ZWQgdXBkYXRlLlxuICogVGhlIGZpcnN0IHZhbHVlIGdldHMgc3luY2VkIHRvIHRoZSBzZWNvbmQgYXQgdGhlIHN0YXJ0IG9mIHRoZSByZW5kZXIgcGhhc2UuXG4gKi9cblxudmFyIGN1cnJlbnRVcGRhdGVJc05lc3RlZCA9IGZhbHNlO1xudmFyIG5lc3RlZFVwZGF0ZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpc0N1cnJlbnRVcGRhdGVOZXN0ZWQoKSB7XG4gIHJldHVybiBjdXJyZW50VXBkYXRlSXNOZXN0ZWQ7XG59XG5cbmZ1bmN0aW9uIG1hcmtOZXN0ZWRVcGRhdGVTY2hlZHVsZWQoKSB7XG4gIHtcbiAgICBuZXN0ZWRVcGRhdGVTY2hlZHVsZWQgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc2V0TmVzdGVkVXBkYXRlRmxhZygpIHtcbiAge1xuICAgIGN1cnJlbnRVcGRhdGVJc05lc3RlZCA9IGZhbHNlO1xuICAgIG5lc3RlZFVwZGF0ZVNjaGVkdWxlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN5bmNOZXN0ZWRVcGRhdGVGbGFnKCkge1xuICB7XG4gICAgY3VycmVudFVwZGF0ZUlzTmVzdGVkID0gbmVzdGVkVXBkYXRlU2NoZWR1bGVkO1xuICAgIG5lc3RlZFVwZGF0ZVNjaGVkdWxlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldENvbW1pdFRpbWUoKSB7XG4gIHJldHVybiBjb21taXRUaW1lO1xufVxuXG5mdW5jdGlvbiByZWNvcmRDb21taXRUaW1lKCkge1xuXG4gIGNvbW1pdFRpbWUgPSBub3coKTtcbn1cblxuZnVuY3Rpb24gc3RhcnRQcm9maWxlclRpbWVyKGZpYmVyKSB7XG5cbiAgcHJvZmlsZXJTdGFydFRpbWUgPSBub3coKTtcblxuICBpZiAoZmliZXIuYWN0dWFsU3RhcnRUaW1lIDwgMCkge1xuICAgIGZpYmVyLmFjdHVhbFN0YXJ0VGltZSA9IG5vdygpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKGZpYmVyKSB7XG5cbiAgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcbn1cblxuZnVuY3Rpb24gc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmdBbmRSZWNvcmREZWx0YShmaWJlciwgb3ZlcnJpZGVCYXNlVGltZSkge1xuXG4gIGlmIChwcm9maWxlclN0YXJ0VGltZSA+PSAwKSB7XG4gICAgdmFyIGVsYXBzZWRUaW1lID0gbm93KCkgLSBwcm9maWxlclN0YXJ0VGltZTtcbiAgICBmaWJlci5hY3R1YWxEdXJhdGlvbiArPSBlbGFwc2VkVGltZTtcblxuICAgIGlmIChvdmVycmlkZUJhc2VUaW1lKSB7XG4gICAgICBmaWJlci5zZWxmQmFzZUR1cmF0aW9uID0gZWxhcHNlZFRpbWU7XG4gICAgfVxuXG4gICAgcHJvZmlsZXJTdGFydFRpbWUgPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaWJlcikge1xuXG4gIGlmIChsYXlvdXRFZmZlY3RTdGFydFRpbWUgPj0gMCkge1xuICAgIHZhciBlbGFwc2VkVGltZSA9IG5vdygpIC0gbGF5b3V0RWZmZWN0U3RhcnRUaW1lO1xuICAgIGxheW91dEVmZmVjdFN0YXJ0VGltZSA9IC0xOyAvLyBTdG9yZSBkdXJhdGlvbiBvbiB0aGUgbmV4dCBuZWFyZXN0IFByb2ZpbGVyIGFuY2VzdG9yXG4gICAgLy8gT3IgdGhlIHJvb3QgKGZvciB0aGUgRGV2VG9vbHMgUHJvZmlsZXIgdG8gcmVhZClcblxuICAgIHZhciBwYXJlbnRGaWJlciA9IGZpYmVyLnJldHVybjtcblxuICAgIHdoaWxlIChwYXJlbnRGaWJlciAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChwYXJlbnRGaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICB2YXIgcm9vdCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICByb290LmVmZmVjdER1cmF0aW9uICs9IGVsYXBzZWRUaW1lO1xuICAgICAgICAgIHJldHVybjtcblxuICAgICAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgICAgIHZhciBwYXJlbnRTdGF0ZU5vZGUgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgcGFyZW50U3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uICs9IGVsYXBzZWRUaW1lO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcGFyZW50RmliZXIgPSBwYXJlbnRGaWJlci5yZXR1cm47XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlY29yZFBhc3NpdmVFZmZlY3REdXJhdGlvbihmaWJlcikge1xuXG4gIGlmIChwYXNzaXZlRWZmZWN0U3RhcnRUaW1lID49IDApIHtcbiAgICB2YXIgZWxhcHNlZFRpbWUgPSBub3coKSAtIHBhc3NpdmVFZmZlY3RTdGFydFRpbWU7XG4gICAgcGFzc2l2ZUVmZmVjdFN0YXJ0VGltZSA9IC0xOyAvLyBTdG9yZSBkdXJhdGlvbiBvbiB0aGUgbmV4dCBuZWFyZXN0IFByb2ZpbGVyIGFuY2VzdG9yXG4gICAgLy8gT3IgdGhlIHJvb3QgKGZvciB0aGUgRGV2VG9vbHMgUHJvZmlsZXIgdG8gcmVhZClcblxuICAgIHZhciBwYXJlbnRGaWJlciA9IGZpYmVyLnJldHVybjtcblxuICAgIHdoaWxlIChwYXJlbnRGaWJlciAhPT0gbnVsbCkge1xuICAgICAgc3dpdGNoIChwYXJlbnRGaWJlci50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICB2YXIgcm9vdCA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcblxuICAgICAgICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByb290LnBhc3NpdmVFZmZlY3REdXJhdGlvbiArPSBlbGFwc2VkVGltZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgY2FzZSBQcm9maWxlcjpcbiAgICAgICAgICB2YXIgcGFyZW50U3RhdGVOb2RlID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgaWYgKHBhcmVudFN0YXRlTm9kZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gRGV0YWNoZWQgZmliZXJzIGhhdmUgdGhlaXIgc3RhdGUgbm9kZSBjbGVhcmVkIG91dC5cbiAgICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSwgdGhlIHJldHVybiBwb2ludGVyIGlzIGFsc28gY2xlYXJlZCBvdXQsXG4gICAgICAgICAgICAvLyBzbyB3ZSB3b24ndCBiZSBhYmxlIHRvIHJlcG9ydCB0aGUgdGltZSBzcGVudCBpbiB0aGlzIFByb2ZpbGVyJ3Mgc3VidHJlZS5cbiAgICAgICAgICAgIHBhcmVudFN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gKz0gZWxhcHNlZFRpbWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpIHtcblxuICBsYXlvdXRFZmZlY3RTdGFydFRpbWUgPSBub3coKTtcbn1cblxuZnVuY3Rpb24gc3RhcnRQYXNzaXZlRWZmZWN0VGltZXIoKSB7XG5cbiAgcGFzc2l2ZUVmZmVjdFN0YXJ0VGltZSA9IG5vdygpO1xufVxuXG5mdW5jdGlvbiB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKGZpYmVyKSB7XG4gIC8vIFRyYW5zZmVyIHRpbWUgc3BlbnQgcmVuZGVyaW5nIHRoZXNlIGNoaWxkcmVuIHNvIHdlIGRvbid0IGxvc2UgaXRcbiAgLy8gYWZ0ZXIgd2UgcmVyZW5kZXIuIFRoaXMgaXMgdXNlZCBhcyBhIGhlbHBlciBpbiBzcGVjaWFsIGNhc2VzXG4gIC8vIHdoZXJlIHdlIHNob3VsZCBjb3VudCB0aGUgd29yayBvZiBtdWx0aXBsZSBwYXNzZXMuXG4gIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCkge1xuICAgIC8vICRGbG93Rml4TWVbdW5zYWZlLWFkZGl0aW9uXSBhZGRpdGlvbiB3aXRoIHBvc3NpYmxlIG51bGwvdW5kZWZpbmVkIHZhbHVlXG4gICAgZmliZXIuYWN0dWFsRHVyYXRpb24gKz0gY2hpbGQuYWN0dWFsRHVyYXRpb247XG4gICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICB9XG59XG5cbnZhciBmYWtlSW50ZXJuYWxJbnN0YW5jZSA9IHt9O1xudmFyIGRpZFdhcm5BYm91dFN0YXRlQXNzaWdubWVudEZvckNvbXBvbmVudDtcbnZhciBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGU7XG52YXIgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlO1xudmFyIGRpZFdhcm5BYm91dExlZ2FjeUxpZmVjeWNsZXNBbmREZXJpdmVkU3RhdGU7XG52YXIgZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlO1xudmFyIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlO1xudmFyIGRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZTtcbnZhciBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2s7XG5cbntcbiAgZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50ID0gbmV3IFNldCgpO1xuICBkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dEdldFNuYXBzaG90QmVmb3JlVXBkYXRlV2l0aG91dERpZFVwZGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUgPSBuZXcgU2V0KCk7XG4gIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZSA9IG5ldyBTZXQoKTtcbiAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlID0gbmV3IFNldCgpO1xuICBkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2sgPSBuZXcgU2V0KCk7IC8vIFRoaXMgaXMgc28gZ3Jvc3MgYnV0IGl0J3MgYXQgbGVhc3Qgbm9uLWNyaXRpY2FsIGFuZCBjYW4gYmUgcmVtb3ZlZCBpZlxuICAvLyBpdCBjYXVzZXMgcHJvYmxlbXMuIFRoaXMgaXMgbWVhbnQgdG8gZ2l2ZSBhIG5pY2VyIGVycm9yIG1lc3NhZ2UgZm9yXG4gIC8vIFJlYWN0RE9NMTUudW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIocmVhY3RET00xNkNvbXBvbmVudCxcbiAgLy8gLi4uKSkgd2hpY2ggb3RoZXJ3aXNlIHRocm93cyBhIFwiX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGEgZnVuY3Rpb25cIlxuICAvLyBleGNlcHRpb24uXG5cbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGZha2VJbnRlcm5hbEluc3RhbmNlLCAnX3Byb2Nlc3NDaGlsZENvbnRleHQnLCB7XG4gICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgdmFsdWU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignX3Byb2Nlc3NDaGlsZENvbnRleHQgaXMgbm90IGF2YWlsYWJsZSBpbiBSZWFjdCAxNisuIFRoaXMgbGlrZWx5ICcgKyAnbWVhbnMgeW91IGhhdmUgbXVsdGlwbGUgY29waWVzIG9mIFJlYWN0IGFuZCBhcmUgYXR0ZW1wdGluZyB0byBuZXN0ICcgKyAnYSBSZWFjdCAxNSB0cmVlIGluc2lkZSBhIFJlYWN0IDE2IHRyZWUgdXNpbmcgJyArIFwidW5zdGFibGVfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIsIHdoaWNoIGlzbid0IHN1cHBvcnRlZC4gVHJ5IFwiICsgJ3RvIG1ha2Ugc3VyZSB5b3UgaGF2ZSBvbmx5IG9uZSBjb3B5IG9mIFJlYWN0IChhbmQgaWRlYWxseSwgc3dpdGNoICcgKyAndG8gUmVhY3RET00uY3JlYXRlUG9ydGFsKS4nKTtcbiAgICB9XG4gIH0pO1xuICBPYmplY3QuZnJlZXplKGZha2VJbnRlcm5hbEluc3RhbmNlKTtcbn1cblxuZnVuY3Rpb24gd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gIHtcbiAgICBpZiAoY2FsbGJhY2sgPT09IG51bGwgfHwgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGtleSA9IFN0cmluZyhjYWxsYmFjayk7XG5cbiAgICBpZiAoIWRpZFdhcm5PbkludmFsaWRDYWxsYmFjay5oYXMoa2V5KSkge1xuICAgICAgZGlkV2Fybk9uSW52YWxpZENhbGxiYWNrLmFkZChrZXkpO1xuXG4gICAgICBlcnJvcignRXhwZWN0ZWQgdGhlIGxhc3Qgb3B0aW9uYWwgYGNhbGxiYWNrYCBhcmd1bWVudCB0byBiZSBhICcgKyAnZnVuY3Rpb24uIEluc3RlYWQgcmVjZWl2ZWQ6ICVzLicsIGNhbGxiYWNrKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gd2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlKHR5cGUsIHBhcnRpYWxTdGF0ZSkge1xuICB7XG4gICAgaWYgKHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVbmRlZmluZWREZXJpdmVkU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuZGVmaW5lZERlcml2ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZXJyb3IoJyVzLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcygpOiBBIHZhbGlkIHN0YXRlIG9iamVjdCAob3IgbnVsbCkgbXVzdCBiZSByZXR1cm5lZC4gJyArICdZb3UgaGF2ZSByZXR1cm5lZCB1bmRlZmluZWQuJywgY29tcG9uZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5RGVyaXZlZFN0YXRlRnJvbVByb3BzKHdvcmtJblByb2dyZXNzLCBjdG9yLCBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMsIG5leHRQcm9wcykge1xuICB2YXIgcHJldlN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIHBhcnRpYWxTdGF0ZSA9IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG5cbiAge1xuICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHModHJ1ZSk7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIEludm9rZSB0aGUgZnVuY3Rpb24gYW4gZXh0cmEgdGltZSB0byBoZWxwIGRldGVjdCBzaWRlLWVmZmVjdHMuXG4gICAgICAgIHBhcnRpYWxTdGF0ZSA9IGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyhuZXh0UHJvcHMsIHByZXZTdGF0ZSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2Fybk9uVW5kZWZpbmVkRGVyaXZlZFN0YXRlKGN0b3IsIHBhcnRpYWxTdGF0ZSk7XG4gIH0gLy8gTWVyZ2UgdGhlIHBhcnRpYWwgc3RhdGUgYW5kIHRoZSBwcmV2aW91cyBzdGF0ZS5cblxuXG4gIHZhciBtZW1vaXplZFN0YXRlID0gcGFydGlhbFN0YXRlID09PSBudWxsIHx8IHBhcnRpYWxTdGF0ZSA9PT0gdW5kZWZpbmVkID8gcHJldlN0YXRlIDogYXNzaWduKHt9LCBwcmV2U3RhdGUsIHBhcnRpYWxTdGF0ZSk7XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBtZW1vaXplZFN0YXRlOyAvLyBPbmNlIHRoZSB1cGRhdGUgcXVldWUgaXMgZW1wdHksIHBlcnNpc3QgdGhlIGRlcml2ZWQgc3RhdGUgb250byB0aGVcbiAgLy8gYmFzZSBzdGF0ZS5cblxuICBpZiAod29ya0luUHJvZ3Jlc3MubGFuZXMgPT09IE5vTGFuZXMpIHtcbiAgICAvLyBRdWV1ZSBpcyBhbHdheXMgbm9uLW51bGwgZm9yIGNsYXNzZXNcbiAgICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICB1cGRhdGVRdWV1ZS5iYXNlU3RhdGUgPSBtZW1vaXplZFN0YXRlO1xuICB9XG59XG5cbnZhciBjbGFzc0NvbXBvbmVudFVwZGF0ZXIgPSB7XG4gIGlzTW91bnRlZDogaXNNb3VudGVkLFxuICAvLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZpYmVyID0gZ2V0KGluc3QpO1xuICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgdXBkYXRlLnBheWxvYWQgPSBwYXlsb2FkO1xuXG4gICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUsIGxhbmUpO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgbGFuZSk7XG4gICAgICBlbnRhbmdsZVRyYW5zaXRpb25zKHJvb3QsIGZpYmVyLCBsYW5lKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBtYXJrU3RhdGVVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpO1xuICAgIH1cbiAgfSxcbiAgZW5xdWV1ZVJlcGxhY2VTdGF0ZTogZnVuY3Rpb24gKGluc3QsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZpYmVyID0gZ2V0KGluc3QpO1xuICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgdXBkYXRlLnRhZyA9IFJlcGxhY2VTdGF0ZTtcbiAgICB1cGRhdGUucGF5bG9hZCA9IHBheWxvYWQ7XG5cbiAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgICAge1xuICAgICAgICB3YXJuT25JbnZhbGlkQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgICB1cGRhdGUuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB9XG5cbiAgICB2YXIgcm9vdCA9IGVucXVldWVVcGRhdGUoZmliZXIsIHVwZGF0ZSwgbGFuZSk7XG5cbiAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBsYW5lKTtcbiAgICAgIGVudGFuZ2xlVHJhbnNpdGlvbnMocm9vdCwgZmliZXIsIGxhbmUpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIG1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZChmaWJlciwgbGFuZSk7XG4gICAgfVxuICB9LFxuICAvLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG4gIGVucXVldWVGb3JjZVVwZGF0ZTogZnVuY3Rpb24gKGluc3QsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGZpYmVyID0gZ2V0KGluc3QpO1xuICAgIHZhciBsYW5lID0gcmVxdWVzdFVwZGF0ZUxhbmUoZmliZXIpO1xuICAgIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7XG4gICAgdXBkYXRlLnRhZyA9IEZvcmNlVXBkYXRlO1xuXG4gICAgaWYgKGNhbGxiYWNrICE9PSB1bmRlZmluZWQgJiYgY2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICAgIHtcbiAgICAgICAgd2Fybk9uSW52YWxpZENhbGxiYWNrKGNhbGxiYWNrKTtcbiAgICAgIH1cblxuICAgICAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgfVxuXG4gICAgdmFyIHJvb3QgPSBlbnF1ZXVlVXBkYXRlKGZpYmVyLCB1cGRhdGUsIGxhbmUpO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgbGFuZSk7XG4gICAgICBlbnRhbmdsZVRyYW5zaXRpb25zKHJvb3QsIGZpYmVyLCBsYW5lKTtcbiAgICB9XG5cbiAgICB7XG4gICAgICBtYXJrRm9yY2VVcGRhdGVTY2hlZHVsZWQoZmliZXIsIGxhbmUpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCkge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB2YXIgc2hvdWxkVXBkYXRlID0gaW5zdGFuY2Uuc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5ld1Byb3BzLCBuZXdTdGF0ZSwgbmV4dENvbnRleHQpO1xuXG4gICAge1xuICAgICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKHRydWUpO1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gSW52b2tlIHRoZSBmdW5jdGlvbiBhbiBleHRyYSB0aW1lIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cbiAgICAgICAgICBzaG91bGRVcGRhdGUgPSBpbnN0YW5jZS5zaG91bGRDb21wb25lbnRVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzaG91bGRVcGRhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBlcnJvcignJXMuc2hvdWxkQ29tcG9uZW50VXBkYXRlKCk6IFJldHVybmVkIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIGEgJyArICdib29sZWFuIHZhbHVlLiBNYWtlIHN1cmUgdG8gcmV0dXJuIHRydWUgb3IgZmFsc2UuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc2hvdWxkVXBkYXRlO1xuICB9XG5cbiAgaWYgKGN0b3IucHJvdG90eXBlICYmIGN0b3IucHJvdG90eXBlLmlzUHVyZVJlYWN0Q29tcG9uZW50KSB7XG4gICAgcmV0dXJuICFzaGFsbG93RXF1YWwob2xkUHJvcHMsIG5ld1Byb3BzKSB8fCAhc2hhbGxvd0VxdWFsKG9sZFN0YXRlLCBuZXdTdGF0ZSk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBuZXdQcm9wcykge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAge1xuICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpIHx8ICdDb21wb25lbnQnO1xuICAgIHZhciByZW5kZXJQcmVzZW50ID0gaW5zdGFuY2UucmVuZGVyO1xuXG4gICAgaWYgKCFyZW5kZXJQcmVzZW50KSB7XG4gICAgICBpZiAoY3Rvci5wcm90b3R5cGUgJiYgdHlwZW9mIGN0b3IucHJvdG90eXBlLnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBlcnJvcignTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSAlcyAnICsgJ2luc3RhbmNlOiBkaWQgeW91IGFjY2lkZW50YWxseSByZXR1cm4gYW4gb2JqZWN0IGZyb20gdGhlIGNvbnN0cnVjdG9yPycsIG5hbWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXJyb3IoJ05vIGByZW5kZXJgIG1ldGhvZCBmb3VuZCBvbiB0aGUgJXMgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAuJywgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmdldEluaXRpYWxTdGF0ZSAmJiAhaW5zdGFuY2UuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkICYmICFpbnN0YW5jZS5zdGF0ZSkge1xuICAgICAgZXJyb3IoJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UuZ2V0RGVmYXVsdFByb3BzICYmICFpbnN0YW5jZS5nZXREZWZhdWx0UHJvcHMuaXNSZWFjdENsYXNzQXBwcm92ZWQpIHtcbiAgICAgIGVycm9yKCdnZXREZWZhdWx0UHJvcHMgd2FzIGRlZmluZWQgb24gJXMsIGEgcGxhaW4gSmF2YVNjcmlwdCBjbGFzcy4gJyArICdUaGlzIGlzIG9ubHkgc3VwcG9ydGVkIGZvciBjbGFzc2VzIGNyZWF0ZWQgdXNpbmcgUmVhY3QuY3JlYXRlQ2xhc3MuICcgKyAnVXNlIGEgc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBkZWZhdWx0UHJvcHMgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcFR5cGVzKSB7XG4gICAgICBlcnJvcigncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmNvbnRleHRUeXBlKSB7XG4gICAgICBlcnJvcignY29udGV4dFR5cGUgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhIHN0YXRpYyAnICsgJ3Byb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZSBpbnN0ZWFkLicsIG5hbWUpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChjdG9yLmNoaWxkQ29udGV4dFR5cGVzKSB7XG4gICAgICAgIGVycm9yKCclcyB1c2VzIHRoZSBsZWdhY3kgY2hpbGRDb250ZXh0VHlwZXMgQVBJIHdoaWNoIHdhcyByZW1vdmVkIGluIFJlYWN0IDE5LiAnICsgJ1VzZSBSZWFjdC5jcmVhdGVDb250ZXh0KCkgaW5zdGVhZC4nLCBuYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGN0b3IuY29udGV4dFR5cGVzKSB7XG4gICAgICAgIGVycm9yKCclcyB1c2VzIHRoZSBsZWdhY3kgY29udGV4dFR5cGVzIEFQSSB3aGljaCB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gJyArICdVc2UgUmVhY3QuY3JlYXRlQ29udGV4dCgpIHdpdGggc3RhdGljIGNvbnRleHRUeXBlIGluc3RlYWQuJywgbmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRTaG91bGRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAoY3Rvci5wcm90b3R5cGUgJiYgY3Rvci5wcm90b3R5cGUuaXNQdXJlUmVhY3RDb21wb25lbnQgJiYgdHlwZW9mIGluc3RhbmNlLnNob3VsZENvbXBvbmVudFVwZGF0ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpLiAnICsgJ3Nob3VsZENvbXBvbmVudFVwZGF0ZSBzaG91bGQgbm90IGJlIHVzZWQgd2hlbiBleHRlbmRpbmcgUmVhY3QuUHVyZUNvbXBvbmVudC4gJyArICdQbGVhc2UgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgaXMgdXNlZC4nLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0EgcHVyZSBjb21wb25lbnQnKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGVycm9yKCclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50RGlkVW5tb3VudCgpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0RpZCB5b3UgbWVhbiBjb21wb25lbnRXaWxsVW5tb3VudCgpPycsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudERpZFJlY2VpdmVQcm9wcygpLiBCdXQgdGhlcmUgaXMgbm8gc3VjaCBsaWZlY3ljbGUgbWV0aG9kLiAnICsgJ0lmIHlvdSBtZWFudCB0byB1cGRhdGUgdGhlIHN0YXRlIGluIHJlc3BvbnNlIHRvIGNoYW5naW5nIHByb3BzLCAnICsgJ3VzZSBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCkuIElmIHlvdSBtZWFudCB0byBmZXRjaCBkYXRhIG9yICcgKyAncnVuIHNpZGUtZWZmZWN0cyBvciBtdXRhdGlvbnMgYWZ0ZXIgUmVhY3QgaGFzIHVwZGF0ZWQgdGhlIFVJLCB1c2UgY29tcG9uZW50RGlkVXBkYXRlKCkuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ1VOU0FGRV9jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzKCkuIERpZCB5b3UgbWVhbiBVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcygpPycsIG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBoYXNNdXRhdGVkUHJvcHMgPSBpbnN0YW5jZS5wcm9wcyAhPT0gbmV3UHJvcHM7XG5cbiAgICBpZiAoaW5zdGFuY2UucHJvcHMgIT09IHVuZGVmaW5lZCAmJiBoYXNNdXRhdGVkUHJvcHMpIHtcbiAgICAgIGVycm9yKCdXaGVuIGNhbGxpbmcgc3VwZXIoKSBpbiBgJXNgLCBtYWtlIHN1cmUgdG8gcGFzcyAnICsgXCJ1cCB0aGUgc2FtZSBwcm9wcyB0aGF0IHlvdXIgY29tcG9uZW50J3MgY29uc3RydWN0b3Igd2FzIHBhc3NlZC5cIiwgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKGluc3RhbmNlLmRlZmF1bHRQcm9wcykge1xuICAgICAgZXJyb3IoJ1NldHRpbmcgZGVmYXVsdFByb3BzIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzIGlzIG5vdCBzdXBwb3J0ZWQgYW5kIHdpbGwgYmUgaWdub3JlZC4nICsgJyBJbnN0ZWFkLCBkZWZpbmUgZGVmYXVsdFByb3BzIGFzIGEgc3RhdGljIHByb3BlcnR5IG9uICVzLicsIG5hbWUsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJyAmJiAhZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmhhcyhjdG9yKSkge1xuICAgICAgZGlkV2FybkFib3V0R2V0U25hcHNob3RCZWZvcmVVcGRhdGVXaXRob3V0RGlkVXBkYXRlLmFkZChjdG9yKTtcblxuICAgICAgZXJyb3IoJyVzOiBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIHNob3VsZCBiZSB1c2VkIHdpdGggY29tcG9uZW50RGlkVXBkYXRlKCkuICcgKyAnVGhpcyBjb21wb25lbnQgZGVmaW5lcyBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSgpIG9ubHkuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGN0b3IpKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXJyb3IoJyVzOiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMoKSBpcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIG1ldGhvZCAnICsgJ2FuZCB3aWxsIGJlIGlnbm9yZWQuIEluc3RlYWQsIGRlY2xhcmUgaXQgYXMgYSBzdGF0aWMgbWV0aG9kLicsIG5hbWUpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXM6IGdldERlcml2ZWRTdGF0ZUZyb21FcnJvcigpIGlzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgbWV0aG9kICcgKyAnYW5kIHdpbGwgYmUgaWdub3JlZC4gSW5zdGVhZCwgZGVjbGFyZSBpdCBhcyBhIHN0YXRpYyBtZXRob2QuJywgbmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBjdG9yLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignJXM6IGdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCkgaXMgZGVmaW5lZCBhcyBhIHN0YXRpYyBtZXRob2QgJyArICdhbmQgd2lsbCBiZSBpZ25vcmVkLiBJbnN0ZWFkLCBkZWNsYXJlIGl0IGFzIGFuIGluc3RhbmNlIG1ldGhvZC4nLCBuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgc3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTtcblxuICAgIGlmIChzdGF0ZSAmJiAodHlwZW9mIHN0YXRlICE9PSAnb2JqZWN0JyB8fCBpc0FycmF5KHN0YXRlKSkpIHtcbiAgICAgIGVycm9yKCclcy5zdGF0ZTogbXVzdCBiZSBzZXQgdG8gYW4gb2JqZWN0IG9yIG51bGwnLCBuYW1lKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldENoaWxkQ29udGV4dCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgY3Rvci5jaGlsZENvbnRleHRUeXBlcyAhPT0gJ29iamVjdCcpIHtcbiAgICAgIGVycm9yKCclcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvICcgKyAndXNlIGdldENoaWxkQ29udGV4dCgpLicsIG5hbWUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb25zdHJ1Y3RDbGFzc0luc3RhbmNlKHdvcmtJblByb2dyZXNzLCBjdG9yLCBwcm9wcykge1xuICB2YXIgY29udGV4dCA9IGVtcHR5Q29udGV4dE9iamVjdDtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcblxuICB7XG4gICAgaWYgKCdjb250ZXh0VHlwZScgaW4gY3Rvcikge1xuICAgICAgdmFyIGlzVmFsaWQgPSAvLyBBbGxvdyBudWxsIGZvciBjb25kaXRpb25hbCBkZWNsYXJhdGlvblxuICAgICAgY29udGV4dFR5cGUgPT09IG51bGwgfHwgY29udGV4dFR5cGUgIT09IHVuZGVmaW5lZCAmJiBjb250ZXh0VHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFO1xuXG4gICAgICBpZiAoIWlzVmFsaWQgJiYgIWRpZFdhcm5BYm91dEludmFsaWRhdGVDb250ZXh0VHlwZS5oYXMoY3RvcikpIHtcbiAgICAgICAgZGlkV2FybkFib3V0SW52YWxpZGF0ZUNvbnRleHRUeXBlLmFkZChjdG9yKTtcbiAgICAgICAgdmFyIGFkZGVuZHVtID0gJyc7XG5cbiAgICAgICAgaWYgKGNvbnRleHRUeXBlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBhZGRlbmR1bSA9ICcgSG93ZXZlciwgaXQgaXMgc2V0IHRvIHVuZGVmaW5lZC4gJyArICdUaGlzIGNhbiBiZSBjYXVzZWQgYnkgYSB0eXBvIG9yIGJ5IG1peGluZyB1cCBuYW1lZCBhbmQgZGVmYXVsdCBpbXBvcnRzLiAnICsgJ1RoaXMgY2FuIGFsc28gaGFwcGVuIGR1ZSB0byBhIGNpcmN1bGFyIGRlcGVuZGVuY3ksIHNvICcgKyAndHJ5IG1vdmluZyB0aGUgY3JlYXRlQ29udGV4dCgpIGNhbGwgdG8gYSBzZXBhcmF0ZSBmaWxlLic7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvbnRleHRUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYSAnICsgdHlwZW9mIGNvbnRleHRUeXBlICsgJy4nO1xuICAgICAgICB9IGVsc2UgaWYgKGNvbnRleHRUeXBlLiQkdHlwZW9mID09PSBSRUFDVF9DT05TVU1FUl9UWVBFKSB7XG4gICAgICAgICAgYWRkZW5kdW0gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IHBhc3MgdGhlIENvbnRleHQuQ29uc3VtZXIgaW5zdGVhZD8nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBIb3dldmVyLCBpdCBpcyBzZXQgdG8gYW4gb2JqZWN0IHdpdGgga2V5cyB7JyArIE9iamVjdC5rZXlzKGNvbnRleHRUeXBlKS5qb2luKCcsICcpICsgJ30uJztcbiAgICAgICAgfVxuXG4gICAgICAgIGVycm9yKCclcyBkZWZpbmVzIGFuIGludmFsaWQgY29udGV4dFR5cGUuICcgKyAnY29udGV4dFR5cGUgc2hvdWxkIHBvaW50IHRvIHRoZSBDb250ZXh0IG9iamVjdCByZXR1cm5lZCBieSBSZWFjdC5jcmVhdGVDb250ZXh0KCkuJXMnLCBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0NvbXBvbmVudCcsIGFkZGVuZHVtKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIGNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgIGNvbnRleHQgPSByZWFkQ29udGV4dChjb250ZXh0VHlwZSk7XG4gIH1cblxuICB2YXIgaW5zdGFuY2UgPSBuZXcgY3Rvcihwcm9wcywgY29udGV4dCk7IC8vIEluc3RhbnRpYXRlIHR3aWNlIHRvIGhlbHAgZGV0ZWN0IHNpZGUtZWZmZWN0cy5cblxuICB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzLm1vZGUgJiBTdHJpY3RMZWdhY3lNb2RlKSB7XG4gICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgaW5zdGFuY2UgPSBuZXcgY3Rvcihwcm9wcywgY29udGV4dCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyhmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlICE9PSBudWxsICYmIGluc3RhbmNlLnN0YXRlICE9PSB1bmRlZmluZWQgPyBpbnN0YW5jZS5zdGF0ZSA6IG51bGw7XG4gIGluc3RhbmNlLnVwZGF0ZXIgPSBjbGFzc0NvbXBvbmVudFVwZGF0ZXI7XG4gIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGluc3RhbmNlOyAvLyBUaGUgaW5zdGFuY2UgbmVlZHMgYWNjZXNzIHRvIHRoZSBmaWJlciBzbyB0aGF0IGl0IGNhbiBzY2hlZHVsZSB1cGRhdGVzXG5cbiAgc2V0KGluc3RhbmNlLCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAge1xuICAgIGluc3RhbmNlLl9yZWFjdEludGVybmFsSW5zdGFuY2UgPSBmYWtlSW50ZXJuYWxJbnN0YW5jZTtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nICYmIHN0YXRlID09PSBudWxsKSB7XG4gICAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShjdG9yKSB8fCAnQ29tcG9uZW50JztcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dFVuaW5pdGlhbGl6ZWRTdGF0ZS5hZGQoY29tcG9uZW50TmFtZSk7XG5cbiAgICAgICAgZXJyb3IoJ2Alc2AgdXNlcyBgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzYCBidXQgaXRzIGluaXRpYWwgc3RhdGUgaXMgJyArICclcy4gVGhpcyBpcyBub3QgcmVjb21tZW5kZWQuIEluc3RlYWQsIGRlZmluZSB0aGUgaW5pdGlhbCBzdGF0ZSBieSAnICsgJ2Fzc2lnbmluZyBhbiBvYmplY3QgdG8gYHRoaXMuc3RhdGVgIGluIHRoZSBjb25zdHJ1Y3RvciBvZiBgJXNgLiAnICsgJ1RoaXMgZW5zdXJlcyB0aGF0IGBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHNgIGFyZ3VtZW50cyBoYXZlIGEgY29uc2lzdGVudCBzaGFwZS4nLCBjb21wb25lbnROYW1lLCBpbnN0YW5jZS5zdGF0ZSA9PT0gbnVsbCA/ICdudWxsJyA6ICd1bmRlZmluZWQnLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9IC8vIElmIG5ldyBjb21wb25lbnQgQVBJcyBhcmUgZGVmaW5lZCwgXCJ1bnNhZmVcIiBsaWZlY3ljbGVzIHdvbid0IGJlIGNhbGxlZC5cbiAgICAvLyBXYXJuIGFib3V0IHRoZXNlIGxpZmVjeWNsZXMgaWYgdGhleSBhcmUgcHJlc2VudC5cbiAgICAvLyBEb24ndCB3YXJuIGFib3V0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgbWV0aG9kcyB0aG91Z2guXG5cblxuICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgZm91bmRXaWxsTW91bnROYW1lID0gbnVsbDtcbiAgICAgIHZhciBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gbnVsbDtcbiAgICAgIHZhciBmb3VuZFdpbGxVcGRhdGVOYW1lID0gbnVsbDtcblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicgJiYgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50Ll9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgZm91bmRXaWxsTW91bnROYW1lID0gJ2NvbXBvbmVudFdpbGxNb3VudCc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvdW5kV2lsbE1vdW50TmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50JztcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID09PSAnZnVuY3Rpb24nICYmIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMuX19zdXBwcmVzc0RlcHJlY2F0aW9uV2FybmluZyAhPT0gdHJ1ZSkge1xuICAgICAgICBmb3VuZFdpbGxSZWNlaXZlUHJvcHNOYW1lID0gJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSA9ICdVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyc7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlLl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmcgIT09IHRydWUpIHtcbiAgICAgICAgZm91bmRXaWxsVXBkYXRlTmFtZSA9ICdjb21wb25lbnRXaWxsVXBkYXRlJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZvdW5kV2lsbFVwZGF0ZU5hbWUgPSAnVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUnO1xuICAgICAgfVxuXG4gICAgICBpZiAoZm91bmRXaWxsTW91bnROYW1lICE9PSBudWxsIHx8IGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgIT09IG51bGwgfHwgZm91bmRXaWxsVXBkYXRlTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgX2NvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgICAgdmFyIG5ld0FwaU5hbWUgPSB0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgPyAnZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzKCknIDogJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlKCknO1xuXG4gICAgICAgIGlmICghZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5oYXMoX2NvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgICAgZGlkV2FybkFib3V0TGVnYWN5TGlmZWN5Y2xlc0FuZERlcml2ZWRTdGF0ZS5hZGQoX2NvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgICAgZXJyb3IoJ1Vuc2FmZSBsZWdhY3kgbGlmZWN5Y2xlcyB3aWxsIG5vdCBiZSBjYWxsZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgbmV3IGNvbXBvbmVudCBBUElzLlxcblxcbicgKyAnJXMgdXNlcyAlcyBidXQgYWxzbyBjb250YWlucyB0aGUgZm9sbG93aW5nIGxlZ2FjeSBsaWZlY3ljbGVzOiVzJXMlc1xcblxcbicgKyAnVGhlIGFib3ZlIGxpZmVjeWNsZXMgc2hvdWxkIGJlIHJlbW92ZWQuIExlYXJuIG1vcmUgYWJvdXQgdGhpcyB3YXJuaW5nIGhlcmU6XFxuJyArICdodHRwczovL3JlYWN0LmRldi9saW5rL3Vuc2FmZS1jb21wb25lbnQtbGlmZWN5Y2xlcycsIF9jb21wb25lbnROYW1lLCBuZXdBcGlOYW1lLCBmb3VuZFdpbGxNb3VudE5hbWUgIT09IG51bGwgPyBcIlxcbiAgXCIgKyBmb3VuZFdpbGxNb3VudE5hbWUgOiAnJywgZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSAhPT0gbnVsbCA/IFwiXFxuICBcIiArIGZvdW5kV2lsbFJlY2VpdmVQcm9wc05hbWUgOiAnJywgZm91bmRXaWxsVXBkYXRlTmFtZSAhPT0gbnVsbCA/IFwiXFxuICBcIiArIGZvdW5kV2lsbFVwZGF0ZU5hbWUgOiAnJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gLy8gQ2FjaGUgdW5tYXNrZWQgY29udGV4dCBzbyB3ZSBjYW4gYXZvaWQgcmVjcmVhdGluZyBtYXNrZWQgY29udGV4dCB1bmxlc3MgbmVjZXNzYXJ5LlxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gY2FsbENvbXBvbmVudFdpbGxNb3VudCh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UpIHtcbiAgdmFyIG9sZFN0YXRlID0gaW5zdGFuY2Uuc3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsTW91bnQoKTtcbiAgfVxuXG4gIGlmIChvbGRTdGF0ZSAhPT0gaW5zdGFuY2Uuc3RhdGUpIHtcbiAgICB7XG4gICAgICBlcnJvcignJXMuY29tcG9uZW50V2lsbE1vdW50KCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byB0aGlzLnN0YXRlIGlzICcgKyBcImRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpIHx8ICdDb21wb25lbnQnKTtcbiAgICB9XG5cbiAgICBjbGFzc0NvbXBvbmVudFVwZGF0ZXIuZW5xdWV1ZVJlcGxhY2VTdGF0ZShpbnN0YW5jZSwgaW5zdGFuY2Uuc3RhdGUsIG51bGwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSwgbmV3UHJvcHMsIG5leHRDb250ZXh0KSB7XG4gIHZhciBvbGRTdGF0ZSA9IGluc3RhbmNlLnN0YXRlO1xuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV3UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXdQcm9wcywgbmV4dENvbnRleHQpO1xuICB9XG5cbiAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBvbGRTdGF0ZSkge1xuICAgIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RhdGVBc3NpZ25tZW50Rm9yQ29tcG9uZW50Lmhhcyhjb21wb25lbnROYW1lKSkge1xuICAgICAgICBkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQuYWRkKGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGVycm9yKCclcy5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKCk6IEFzc2lnbmluZyBkaXJlY3RseSB0byAnICsgXCJ0aGlzLnN0YXRlIGlzIGRlcHJlY2F0ZWQgKGV4Y2VwdCBpbnNpZGUgYSBjb21wb25lbnQncyBcIiArICdjb25zdHJ1Y3RvcikuIFVzZSBzZXRTdGF0ZSBpbnN0ZWFkLicsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNsYXNzQ29tcG9uZW50VXBkYXRlci5lbnF1ZXVlUmVwbGFjZVN0YXRlKGluc3RhbmNlLCBpbnN0YW5jZS5zdGF0ZSwgbnVsbCk7XG4gIH1cbn0gLy8gSW52b2tlcyB0aGUgbW91bnQgbGlmZS1jeWNsZXMgb24gYSBwcmV2aW91c2x5IG5ldmVyIHJlbmRlcmVkIGluc3RhbmNlLlxuXG5cbmZ1bmN0aW9uIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3RvciwgbmV3UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBjaGVja0NsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzKTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgaW5zdGFuY2UucHJvcHMgPSBuZXdQcm9wcztcbiAgaW5zdGFuY2Uuc3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICBpbnN0YW5jZS5yZWZzID0ge307XG4gIGluaXRpYWxpemVVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gIHZhciBjb250ZXh0VHlwZSA9IGN0b3IuY29udGV4dFR5cGU7XG5cbiAgaWYgKHR5cGVvZiBjb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgY29udGV4dFR5cGUgIT09IG51bGwpIHtcbiAgICBpbnN0YW5jZS5jb250ZXh0ID0gcmVhZENvbnRleHQoY29udGV4dFR5cGUpO1xuICB9IGVsc2Uge1xuICAgIGluc3RhbmNlLmNvbnRleHQgPSBlbXB0eUNvbnRleHRPYmplY3Q7XG4gIH1cblxuICB7XG4gICAgaWYgKGluc3RhbmNlLnN0YXRlID09PSBuZXdQcm9wcykge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoY3RvcikgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIGRpZFdhcm5BYm91dERpcmVjdGx5QXNzaWduaW5nUHJvcHNUb1N0YXRlLmFkZChjb21wb25lbnROYW1lKTtcblxuICAgICAgICBlcnJvcignJXM6IEl0IGlzIG5vdCByZWNvbW1lbmRlZCB0byBhc3NpZ24gcHJvcHMgZGlyZWN0bHkgdG8gc3RhdGUgJyArIFwiYmVjYXVzZSB1cGRhdGVzIHRvIHByb3BzIHdvbid0IGJlIHJlZmxlY3RlZCBpbiBzdGF0ZS4gXCIgKyAnSW4gbW9zdCBjYXNlcywgaXQgaXMgYmV0dGVyIHRvIHVzZSBwcm9wcyBkaXJlY3RseS4nLCBjb21wb25lbnROYW1lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nKHdvcmtJblByb2dyZXNzLCBpbnN0YW5jZSk7XG4gICAgfVxuXG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MucmVjb3JkVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3Mod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTtcbiAgfVxuXG4gIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV3UHJvcHMpO1xuICAgIGluc3RhbmNlLnN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfSAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgLy8gVW5zYWZlIGxpZmVjeWNsZXMgc2hvdWxkIG5vdCBiZSBpbnZva2VkIGZvciBjb21wb25lbnRzIHVzaW5nIHRoZSBuZXcgQVBJcy5cblxuXG4gIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgIT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlICE9PSAnZnVuY3Rpb24nICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSkge1xuICAgIGNhbGxDb21wb25lbnRXaWxsTW91bnQod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlKTsgLy8gSWYgd2UgaGFkIGFkZGl0aW9uYWwgc3RhdGUgdXBkYXRlcyBkdXJpbmcgdGhpcyBsaWZlLWN5Y2xlLCBsZXQnc1xuICAgIC8vIHByb2Nlc3MgdGhlbSBub3cuXG5cbiAgICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5ld1Byb3BzLCBpbnN0YW5jZSwgcmVuZGVyTGFuZXMpO1xuICAgIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKTtcbiAgICBpbnN0YW5jZS5zdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIH1cblxuICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlIHwgTGF5b3V0U3RhdGljO1xuICB9XG5cbiAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBNb3VudExheW91dERldjtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVNb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG5ld1Byb3BzLCByZW5kZXJMYW5lcykge1xuICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gIHZhciB1bnJlc29sdmVkT2xkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzO1xuICB2YXIgb2xkUHJvcHMgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhjdG9yLCB1bnJlc29sdmVkT2xkUHJvcHMpO1xuICBpbnN0YW5jZS5wcm9wcyA9IG9sZFByb3BzO1xuICB2YXIgb2xkQ29udGV4dCA9IGluc3RhbmNlLmNvbnRleHQ7XG4gIHZhciBjb250ZXh0VHlwZSA9IGN0b3IuY29udGV4dFR5cGU7XG4gIHZhciBuZXh0Q29udGV4dCA9IGVtcHR5Q29udGV4dE9iamVjdDtcblxuICBpZiAodHlwZW9mIGNvbnRleHRUeXBlID09PSAnb2JqZWN0JyAmJiBjb250ZXh0VHlwZSAhPT0gbnVsbCkge1xuICAgIG5leHRDb250ZXh0ID0gcmVhZENvbnRleHQoY29udGV4dFR5cGUpO1xuICB9XG5cbiAgdmFyIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9IGN0b3IuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzO1xuICB2YXIgaGFzTmV3TGlmZWN5Y2xlcyA9IHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nOyAvLyBXaGVuIGNvbXBhcmluZyB3aGV0aGVyIHByb3BzIGNoYW5nZWQsIHdlIHNob3VsZCBjb21wYXJlIHVzaW5nIHRoZVxuICAvLyB1bnJlc29sdmVkIHByb3BzIG9iamVjdCB0aGF0IGlzIHN0b3JlZCBvbiB0aGUgZmliZXIsIHJhdGhlciB0aGFuIHRoZVxuICAvLyBvbmUgdGhhdCBnZXRzIGFzc2lnbmVkIHRvIHRoZSBpbnN0YW5jZSwgYmVjYXVzZSB0aGF0IG9iamVjdCBtYXkgaGF2ZSBiZWVuXG4gIC8vIGNsb25lZCB0byByZXNvbHZlIGRlZmF1bHQgcHJvcHMgYW5kL29yIHJlbW92ZSBgcmVmYC5cblxuICB2YXIgdW5yZXNvbHZlZE5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgZGlkUmVjZWl2ZU5ld1Byb3BzID0gdW5yZXNvbHZlZE5ld1Byb3BzICE9PSB1bnJlc29sdmVkT2xkUHJvcHM7IC8vIE5vdGU6IER1cmluZyB0aGVzZSBsaWZlLWN5Y2xlcywgaW5zdGFuY2UucHJvcHMvaW5zdGFuY2Uuc3RhdGUgYXJlIHdoYXRcbiAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgLy8gZHVyaW5nIGNvbXBvbmVudERpZFVwZGF0ZSB3ZSBwYXNzIHRoZSBcImN1cnJlbnRcIiBwcm9wcy5cbiAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG5cbiAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgaWYgKGRpZFJlY2VpdmVOZXdQcm9wcyB8fCBvbGRDb250ZXh0ICE9PSBuZXh0Q29udGV4dCkge1xuICAgICAgY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMod29ya0luUHJvZ3Jlc3MsIGluc3RhbmNlLCBuZXdQcm9wcywgbmV4dENvbnRleHQpO1xuICAgIH1cbiAgfVxuXG4gIHJlc2V0SGFzRm9yY2VVcGRhdGVCZWZvcmVQcm9jZXNzaW5nKCk7XG4gIHZhciBvbGRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gIHZhciBuZXdTdGF0ZSA9IGluc3RhbmNlLnN0YXRlID0gb2xkU3RhdGU7XG4gIHByb2Nlc3NVcGRhdGVRdWV1ZSh3b3JrSW5Qcm9ncmVzcywgbmV3UHJvcHMsIGluc3RhbmNlLCByZW5kZXJMYW5lcyk7XG4gIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKTtcbiAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gIGlmICghZGlkUmVjZWl2ZU5ld1Byb3BzICYmIG9sZFN0YXRlID09PSBuZXdTdGF0ZSAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSAmJiAhY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpKSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGUgfCBMYXlvdXRTdGF0aWM7XG4gICAgfVxuXG4gICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IE1vdW50TGF5b3V0RGV2O1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgYXBwbHlEZXJpdmVkU3RhdGVGcm9tUHJvcHMod29ya0luUHJvZ3Jlc3MsIGN0b3IsIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcywgbmV3UHJvcHMpO1xuICAgIG5ld1N0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgfVxuXG4gIHZhciBzaG91bGRVcGRhdGUgPSBjaGVja0hhc0ZvcmNlVXBkYXRlQWZ0ZXJQcm9jZXNzaW5nKCkgfHwgY2hlY2tTaG91bGRDb21wb25lbnRVcGRhdGUod29ya0luUHJvZ3Jlc3MsIGN0b3IsIG9sZFByb3BzLCBuZXdQcm9wcywgb2xkU3RhdGUsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG5cbiAgaWYgKHNob3VsZFVwZGF0ZSkge1xuICAgIC8vIEluIG9yZGVyIHRvIHN1cHBvcnQgcmVhY3QtbGlmZWN5Y2xlcy1jb21wYXQgcG9seWZpbGxlZCBjb21wb25lbnRzLFxuICAgIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG4gICAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50ID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsTW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBpbnN0YW5jZS5VTlNBRkVfY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlIHwgTGF5b3V0U3RhdGljO1xuICAgIH1cblxuICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdEVmZmVjdHNNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBNb3VudExheW91dERldjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZE1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGUgfCBMYXlvdXRTdGF0aWM7XG4gICAgfVxuXG4gICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0RWZmZWN0c01vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IE1vdW50TGF5b3V0RGV2O1xuICAgIH0gLy8gSWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybmVkIGZhbHNlLCB3ZSBzaG91bGQgc3RpbGwgdXBkYXRlIHRoZVxuICAgIC8vIG1lbW9pemVkIHN0YXRlIHRvIGluZGljYXRlIHRoYXQgdGhpcyB3b3JrIGNhbiBiZSByZXVzZWQuXG5cblxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXdQcm9wcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gIH0gLy8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuICAvLyBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZS5cblxuXG4gIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG4gIGluc3RhbmNlLmNvbnRleHQgPSBuZXh0Q29udGV4dDtcbiAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbn0gLy8gSW52b2tlcyB0aGUgdXBkYXRlIGxpZmUtY3ljbGVzIGFuZCByZXR1cm5zIGZhbHNlIGlmIGl0IHNob3VsZG4ndCByZXJlbmRlci5cblxuXG5mdW5jdGlvbiB1cGRhdGVDbGFzc0luc3RhbmNlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBjdG9yLCBuZXdQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICBjbG9uZVVwZGF0ZVF1ZXVlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgdmFyIHVucmVzb2x2ZWRPbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gIHZhciBvbGRQcm9wcyA9IHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKGN0b3IsIHVucmVzb2x2ZWRPbGRQcm9wcyk7XG4gIGluc3RhbmNlLnByb3BzID0gb2xkUHJvcHM7XG4gIHZhciB1bnJlc29sdmVkTmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBvbGRDb250ZXh0ID0gaW5zdGFuY2UuY29udGV4dDtcbiAgdmFyIGNvbnRleHRUeXBlID0gY3Rvci5jb250ZXh0VHlwZTtcbiAgdmFyIG5leHRDb250ZXh0ID0gZW1wdHlDb250ZXh0T2JqZWN0O1xuXG4gIGlmICh0eXBlb2YgY29udGV4dFR5cGUgPT09ICdvYmplY3QnICYmIGNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgbmV4dENvbnRleHQgPSByZWFkQ29udGV4dChjb250ZXh0VHlwZSk7XG4gIH1cblxuICB2YXIgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID0gY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tUHJvcHM7XG4gIHZhciBoYXNOZXdMaWZlY3ljbGVzID0gdHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbic7IC8vIE5vdGU6IER1cmluZyB0aGVzZSBsaWZlLWN5Y2xlcywgaW5zdGFuY2UucHJvcHMvaW5zdGFuY2Uuc3RhdGUgYXJlIHdoYXRcbiAgLy8gZXZlciB0aGUgcHJldmlvdXNseSBhdHRlbXB0ZWQgdG8gcmVuZGVyIC0gbm90IHRoZSBcImN1cnJlbnRcIi4gSG93ZXZlcixcbiAgLy8gZHVyaW5nIGNvbXBvbmVudERpZFVwZGF0ZSB3ZSBwYXNzIHRoZSBcImN1cnJlbnRcIiBwcm9wcy5cbiAgLy8gSW4gb3JkZXIgdG8gc3VwcG9ydCByZWFjdC1saWZlY3ljbGVzLWNvbXBhdCBwb2x5ZmlsbGVkIGNvbXBvbmVudHMsXG4gIC8vIFVuc2FmZSBsaWZlY3ljbGVzIHNob3VsZCBub3QgYmUgaW52b2tlZCBmb3IgY29tcG9uZW50cyB1c2luZyB0aGUgbmV3IEFQSXMuXG5cbiAgaWYgKCFoYXNOZXdMaWZlY3ljbGVzICYmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gdW5yZXNvbHZlZE5ld1Byb3BzIHx8IG9sZENvbnRleHQgIT09IG5leHRDb250ZXh0KSB7XG4gICAgICBjYWxsQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyh3b3JrSW5Qcm9ncmVzcywgaW5zdGFuY2UsIG5ld1Byb3BzLCBuZXh0Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmVzZXRIYXNGb3JjZVVwZGF0ZUJlZm9yZVByb2Nlc3NpbmcoKTtcbiAgdmFyIG9sZFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIG5ld1N0YXRlID0gaW5zdGFuY2Uuc3RhdGUgPSBvbGRTdGF0ZTtcbiAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBuZXdQcm9wcywgaW5zdGFuY2UsIHJlbmRlckxhbmVzKTtcbiAgc3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbigpO1xuICBuZXdTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyA9PT0gdW5yZXNvbHZlZE5ld1Byb3BzICYmIG9sZFN0YXRlID09PSBuZXdTdGF0ZSAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSAmJiAhY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZygpICYmICEoZW5hYmxlTGF6eUNvbnRleHRQcm9wYWdhdGlvbiAgICkpIHtcbiAgICAvLyBJZiBhbiB1cGRhdGUgd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MsIHdlIHNob3VsZCBzY2hlZHVsZSBhbiBVcGRhdGVcbiAgICAvLyBlZmZlY3QgZXZlbiB0aG91Z2ggd2UncmUgYmFpbGluZyBvdXQsIHNvIHRoYXQgY1dVL2NEVSBhcmUgY2FsbGVkLlxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAodW5yZXNvbHZlZE9sZFByb3BzICE9PSBjdXJyZW50Lm1lbW9pemVkUHJvcHMgfHwgb2xkU3RhdGUgIT09IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBVcGRhdGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5nZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU25hcHNob3Q7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyh3b3JrSW5Qcm9ncmVzcywgY3RvciwgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLCBuZXdQcm9wcyk7XG4gICAgbmV3U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB9XG5cbiAgdmFyIHNob3VsZFVwZGF0ZSA9IGNoZWNrSGFzRm9yY2VVcGRhdGVBZnRlclByb2Nlc3NpbmcoKSB8fCBjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgY3Rvciwgb2xkUHJvcHMsIG5ld1Byb3BzLCBvbGRTdGF0ZSwgbmV3U3RhdGUsIG5leHRDb250ZXh0KSB8fCAvLyBUT0RPOiBJbiBzb21lIGNhc2VzLCB3ZSdsbCBlbmQgdXAgY2hlY2tpbmcgaWYgY29udGV4dCBoYXMgY2hhbmdlZCB0d2ljZSxcbiAgLy8gYm90aCBiZWZvcmUgYW5kIGFmdGVyIGBzaG91bGRDb21wb25lbnRVcGRhdGVgIGhhcyBiZWVuIGNhbGxlZC4gTm90IGlkZWFsLFxuICAvLyBidXQgSSdtIGxvYXRoIHRvIHJlZmFjdG9yIHRoaXMgZnVuY3Rpb24uIFRoaXMgb25seSBoYXBwZW5zIGZvciBtZW1vaXplZFxuICAvLyBjb21wb25lbnRzIHNvIGl0J3Mgbm90IHRoYXQgY29tbW9uLlxuICBlbmFibGVMYXp5Q29udGV4dFByb3BhZ2F0aW9uICAgO1xuXG4gIGlmIChzaG91bGRVcGRhdGUpIHtcbiAgICAvLyBJbiBvcmRlciB0byBzdXBwb3J0IHJlYWN0LWxpZmVjeWNsZXMtY29tcGF0IHBvbHlmaWxsZWQgY29tcG9uZW50cyxcbiAgICAvLyBVbnNhZmUgbGlmZWN5Y2xlcyBzaG91bGQgbm90IGJlIGludm9rZWQgZm9yIGNvbXBvbmVudHMgdXNpbmcgdGhlIG5ldyBBUElzLlxuICAgIGlmICghaGFzTmV3TGlmZWN5Y2xlcyAmJiAodHlwZW9mIGluc3RhbmNlLlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSkge1xuICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnRXaWxsVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaW5zdGFuY2UuVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGUobmV3UHJvcHMsIG5ld1N0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTbmFwc2hvdDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgYW4gdXBkYXRlIHdhcyBhbHJlYWR5IGluIHByb2dyZXNzLCB3ZSBzaG91bGQgc2NoZWR1bGUgYW4gVXBkYXRlXG4gICAgLy8gZWZmZWN0IGV2ZW4gdGhvdWdoIHdlJ3JlIGJhaWxpbmcgb3V0LCBzbyB0aGF0IGNXVS9jRFUgYXJlIGNhbGxlZC5cbiAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZFVwZGF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHVucmVzb2x2ZWRPbGRQcm9wcyAhPT0gY3VycmVudC5tZW1vaXplZFByb3BzIHx8IG9sZFN0YXRlICE9PSBjdXJyZW50Lm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmICh1bnJlc29sdmVkT2xkUHJvcHMgIT09IGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB8fCBvbGRTdGF0ZSAhPT0gY3VycmVudC5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNuYXBzaG90O1xuICAgICAgfVxuICAgIH0gLy8gSWYgc2hvdWxkQ29tcG9uZW50VXBkYXRlIHJldHVybmVkIGZhbHNlLCB3ZSBzaG91bGQgc3RpbGwgdXBkYXRlIHRoZVxuICAgIC8vIG1lbW9pemVkIHByb3BzL3N0YXRlIHRvIGluZGljYXRlIHRoYXQgdGhpcyB3b3JrIGNhbiBiZSByZXVzZWQuXG5cblxuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBuZXdQcm9wcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gIH0gLy8gVXBkYXRlIHRoZSBleGlzdGluZyBpbnN0YW5jZSdzIHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgcG9pbnRlcnMgZXZlblxuICAvLyBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZS5cblxuXG4gIGluc3RhbmNlLnByb3BzID0gbmV3UHJvcHM7XG4gIGluc3RhbmNlLnN0YXRlID0gbmV3U3RhdGU7XG4gIGluc3RhbmNlLmNvbnRleHQgPSBuZXh0Q29udGV4dDtcbiAgcmV0dXJuIHNob3VsZFVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoQ29tcG9uZW50LCBiYXNlUHJvcHMsIC8vIE9ubHkgcmVzb2x2ZSBkZWZhdWx0IHByb3BzIGlmIHRoaXMgaXMgYSBsYXp5IGNvbXBvbmVudC4gT3RoZXJ3aXNlLCB0aGV5XG4vLyB3b3VsZCBoYXZlIGFscmVhZHkgYmVlbiByZXNvbHZlZCBieSB0aGUgSlNYIHJ1bnRpbWUuXG4vLyBUT0RPOiBXZSdyZSBnb2luZyB0byByZW1vdmUgZGVmYXVsdCBwcm9wIHJlc29sdXRpb24gZnJvbSB0aGUgSlNYIHJ1bnRpbWVcbi8vIGFuZCBrZWVwIGl0IG9ubHkgZm9yIGNsYXNzIGNvbXBvbmVudHMuIEFzIHBhcnQgb2YgdGhhdCBjaGFuZ2UsIHdlIHNob3VsZFxuLy8gcmVtb3ZlIHRoaXMgZXh0cmEgY2hlY2suXG5hbHJlYWR5UmVzb2x2ZWREZWZhdWx0UHJvcHMpIHtcbiAgdmFyIG5ld1Byb3BzID0gYmFzZVByb3BzO1xuXG4gIHtcbiAgICAvLyBSZW1vdmUgcmVmIGZyb20gdGhlIHByb3BzIG9iamVjdCwgaWYgaXQgZXhpc3RzLlxuICAgIGlmICgncmVmJyBpbiBiYXNlUHJvcHMpIHtcbiAgICAgIG5ld1Byb3BzID0ge307XG5cbiAgICAgIGZvciAodmFyIHByb3BOYW1lIGluIGJhc2VQcm9wcykge1xuICAgICAgICBpZiAocHJvcE5hbWUgIT09ICdyZWYnKSB7XG4gICAgICAgICAgbmV3UHJvcHNbcHJvcE5hbWVdID0gYmFzZVByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHMuXG5cblxuICB2YXIgZGVmYXVsdFByb3BzID0gQ29tcG9uZW50LmRlZmF1bHRQcm9wcztcblxuICBpZiAoZGVmYXVsdFByb3BzICYmICggLy8gSWYgZGlzYWJsZURlZmF1bHRQcm9wc0V4Y2VwdEZvckNsYXNzZXMgaXMgdHJ1ZSwgd2UgYWx3YXlzIHJlc29sdmVcbiAgLy8gZGVmYXVsdCBwcm9wcyBoZXJlIGluIHRoZSByZWNvbmNpbGVyLCByYXRoZXIgdGhhbiBpbiB0aGUgSlNYIHJ1bnRpbWUuXG4gIGRpc2FibGVEZWZhdWx0UHJvcHNFeGNlcHRGb3JDbGFzc2VzICkpIHtcbiAgICAvLyBXZSBtYXkgaGF2ZSBhbHJlYWR5IGNvcGllZCB0aGUgcHJvcHMgb2JqZWN0IGFib3ZlIHRvIHJlbW92ZSByZWYuIElmIHNvLFxuICAgIC8vIHdlIGNhbiBtb2RpZnkgdGhhdC4gT3RoZXJ3aXNlLCBjb3B5IHRoZSBwcm9wcyBvYmplY3Qgd2l0aCBPYmplY3QuYXNzaWduLlxuICAgIGlmIChuZXdQcm9wcyA9PT0gYmFzZVByb3BzKSB7XG4gICAgICBuZXdQcm9wcyA9IGFzc2lnbih7fSwgbmV3UHJvcHMpO1xuICAgIH0gLy8gVGFrZW4gZnJvbSBvbGQgSlNYIHJ1bnRpbWUsIHdoZXJlIHRoaXMgdXNlZCB0byBsaXZlLlxuXG5cbiAgICBmb3IgKHZhciBfcHJvcE5hbWUgaW4gZGVmYXVsdFByb3BzKSB7XG4gICAgICBpZiAobmV3UHJvcHNbX3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5ld1Byb3BzW19wcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbX3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmV3UHJvcHM7XG59XG5cbnZhciByZXBvcnRHbG9iYWxFcnJvciA9IHR5cGVvZiByZXBvcnRFcnJvciA9PT0gJ2Z1bmN0aW9uJyA/IC8vIEluIG1vZGVybiBicm93c2VycywgcmVwb3J0RXJyb3Igd2lsbCBkaXNwYXRjaCBhbiBlcnJvciBldmVudCxcbi8vIGVtdWxhdGluZyBhbiB1bmNhdWdodCBKYXZhU2NyaXB0IGVycm9yLlxucmVwb3J0RXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgaWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnICYmIHR5cGVvZiB3aW5kb3cuRXJyb3JFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEJyb3dzZXIgUG9seWZpbGxcbiAgICB2YXIgbWVzc2FnZSA9IHR5cGVvZiBlcnJvciA9PT0gJ29iamVjdCcgJiYgZXJyb3IgIT09IG51bGwgJiYgdHlwZW9mIGVycm9yLm1lc3NhZ2UgPT09ICdzdHJpbmcnID8gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgU3RyaW5nKGVycm9yLm1lc3NhZ2UpIDogLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gICAgU3RyaW5nKGVycm9yKTtcbiAgICB2YXIgZXZlbnQgPSBuZXcgd2luZG93LkVycm9yRXZlbnQoJ2Vycm9yJywge1xuICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgZXJyb3I6IGVycm9yXG4gICAgfSk7XG4gICAgdmFyIHNob3VsZExvZyA9IHdpbmRvdy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcblxuICAgIGlmICghc2hvdWxkTG9nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiAvLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG4gIHR5cGVvZiBwcm9jZXNzLmVtaXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBOb2RlIFBvbHlmaWxsXG4gICAgcHJvY2Vzcy5lbWl0KCd1bmNhdWdodEV4Y2VwdGlvbicsIGVycm9yKTtcbiAgICByZXR1cm47XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG5cbiAgY29uc29sZVsnZXJyb3InXShlcnJvcik7XG59O1xuXG52YXIgY29tcG9uZW50TmFtZSA9IG51bGw7XG52YXIgZXJyb3JCb3VuZGFyeU5hbWUgPSBudWxsO1xuZnVuY3Rpb24gZGVmYXVsdE9uVW5jYXVnaHRFcnJvcihlcnJvciwgZXJyb3JJbmZvKSB7XG4gIC8vIE92ZXJyaWRpbmcgdGhpcyBjYW4gc2lsZW5jZSB0aGVzZSB3YXJuaW5ncyBlLmcuIGZvciB0ZXN0cy5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9wdWxsLzEzMzg0XG4gIC8vIEZvciB1bmNhdWdodCByb290IGVycm9ycyB3ZSByZXBvcnQgdGhlbSBhcyB1bmNhdWdodCB0byB0aGUgYnJvd3NlcidzXG4gIC8vIG9uZXJyb3IgY2FsbGJhY2suIFRoaXMgd29uJ3QgaGF2ZSBjb21wb25lbnQgc3RhY2tzIGFuZCB0aGUgZXJyb3IgYWRkZW5kdW0uXG4gIC8vIFNvIHdlIGFkZCB0aG9zZSBpbnRvIGEgc2VwYXJhdGUgY29uc29sZS53YXJuLlxuICByZXBvcnRHbG9iYWxFcnJvcihlcnJvcik7XG5cbiAge1xuICAgIHZhciBjb21wb25lbnROYW1lTWVzc2FnZSA9IGNvbXBvbmVudE5hbWUgPyBcIkFuIGVycm9yIG9jY3VycmVkIGluIHRoZSA8XCIgKyBjb21wb25lbnROYW1lICsgXCI+IGNvbXBvbmVudC5cIiA6ICdBbiBlcnJvciBvY2N1cnJlZCBpbiBvbmUgb2YgeW91ciBSZWFjdCBjb21wb25lbnRzLic7XG4gICAgdmFyIGVycm9yQm91bmRhcnlNZXNzYWdlID0gJ0NvbnNpZGVyIGFkZGluZyBhbiBlcnJvciBib3VuZGFyeSB0byB5b3VyIHRyZWUgdG8gY3VzdG9taXplIGVycm9yIGhhbmRsaW5nIGJlaGF2aW9yLlxcbicgKyAnVmlzaXQgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay9lcnJvci1ib3VuZGFyaWVzIHRvIGxlYXJuIG1vcmUgYWJvdXQgZXJyb3IgYm91bmRhcmllcy4nO1xuXG4gICAge1xuICAgICAgLy8gVGhlIGN1cnJlbnQgRmliZXIgaXMgZGlzY29ubmVjdGVkIGF0IHRoaXMgcG9pbnQgd2hpY2ggbWVhbnMgdGhhdCBjb25zb2xlIHByaW50aW5nXG4gICAgICAvLyBjYW5ub3QgYWRkIGEgY29tcG9uZW50IHN0YWNrIHNpbmNlIGl0IHRlcm1pbmF0ZXMgYXQgdGhlIGRlbGV0aW9uIG5vZGUuIFRoaXMgaXMgbm90XG4gICAgICAvLyBhIHByb2JsZW0gZm9yIG93bmVyIHN0YWNrcyB3aGljaCBhcmUgbm90IGRpc2Nvbm5lY3RlZCBidXQgZm9yIHRoZSBwYXJlbnQgY29tcG9uZW50XG4gICAgICAvLyBzdGFja3Mgd2UgbmVlZCB0byB1c2UgdGhlIHNuYXBzaG90IHdlJ3ZlIHByZXZpb3VzbHkgZXh0cmFjdGVkLlxuICAgICAgdmFyIGNvbXBvbmVudFN0YWNrID0gZXJyb3JJbmZvLmNvbXBvbmVudFN0YWNrICE9IG51bGwgPyBlcnJvckluZm8uY29tcG9uZW50U3RhY2sgOiAnJzsgLy8gRG9uJ3QgdHJhbnNmb3JtIHRvIG91ciB3cmFwcGVyXG5cbiAgICAgIGNvbnNvbGVbJ3dhcm4nXSgnJXNcXG5cXG4lc1xcbiVzJywgY29tcG9uZW50TmFtZU1lc3NhZ2UsIGVycm9yQm91bmRhcnlNZXNzYWdlLCBjb21wb25lbnRTdGFjayk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkZWZhdWx0T25DYXVnaHRFcnJvcihlcnJvciQxLCBlcnJvckluZm8pIHtcbiAgLy8gT3ZlcnJpZGluZyB0aGlzIGNhbiBzaWxlbmNlIHRoZXNlIHdhcm5pbmdzIGUuZy4gZm9yIHRlc3RzLlxuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMTMzODRcbiAgLy8gQ2F1Z2h0IGJ5IGVycm9yIGJvdW5kYXJ5XG4gIHtcbiAgICB2YXIgY29tcG9uZW50TmFtZU1lc3NhZ2UgPSBjb21wb25lbnROYW1lID8gXCJUaGUgYWJvdmUgZXJyb3Igb2NjdXJyZWQgaW4gdGhlIDxcIiArIGNvbXBvbmVudE5hbWUgKyBcIj4gY29tcG9uZW50LlwiIDogJ1RoZSBhYm92ZSBlcnJvciBvY2N1cnJlZCBpbiBvbmUgb2YgeW91ciBSZWFjdCBjb21wb25lbnRzLic7IC8vIEluIGRldmVsb3BtZW50LCB3ZSBwcm92aWRlIG91ciBvd24gbWVzc2FnZSB3aGljaCBpbmNsdWRlcyB0aGUgY29tcG9uZW50IHN0YWNrXG4gICAgLy8gaW4gYWRkaXRpb24gdG8gdGhlIGVycm9yLlxuXG4gICAgdmFyIHJlY3JlYXRlTWVzc2FnZSA9IFwiUmVhY3Qgd2lsbCB0cnkgdG8gcmVjcmVhdGUgdGhpcyBjb21wb25lbnQgdHJlZSBmcm9tIHNjcmF0Y2ggXCIgKyAoXCJ1c2luZyB0aGUgZXJyb3IgYm91bmRhcnkgeW91IHByb3ZpZGVkLCBcIiArIChlcnJvckJvdW5kYXJ5TmFtZSB8fCAnQW5vbnltb3VzJykgKyBcIi5cIik7XG5cbiAgICB7XG4gICAgICAvLyBUaGUgY3VycmVudCBGaWJlciBpcyBkaXNjb25uZWN0ZWQgYXQgdGhpcyBwb2ludCB3aGljaCBtZWFucyB0aGF0IGNvbnNvbGUgcHJpbnRpbmdcbiAgICAgIC8vIGNhbm5vdCBhZGQgYSBjb21wb25lbnQgc3RhY2sgc2luY2UgaXQgdGVybWluYXRlcyBhdCB0aGUgZGVsZXRpb24gbm9kZS4gVGhpcyBpcyBub3RcbiAgICAgIC8vIGEgcHJvYmxlbSBmb3Igb3duZXIgc3RhY2tzIHdoaWNoIGFyZSBub3QgZGlzY29ubmVjdGVkIGJ1dCBmb3IgdGhlIHBhcmVudCBjb21wb25lbnRcbiAgICAgIC8vIHN0YWNrcyB3ZSBuZWVkIHRvIHVzZSB0aGUgc25hcHNob3Qgd2UndmUgcHJldmlvdXNseSBleHRyYWN0ZWQuXG4gICAgICB2YXIgY29tcG9uZW50U3RhY2sgPSBlcnJvckluZm8uY29tcG9uZW50U3RhY2sgIT0gbnVsbCA/IGVycm9ySW5mby5jb21wb25lbnRTdGFjayA6ICcnOyAvLyBEb24ndCB0cmFuc2Zvcm0gdG8gb3VyIHdyYXBwZXJcblxuICAgICAgY29uc29sZVsnZXJyb3InXSgnJW9cXG5cXG4lc1xcblxcbiVzXFxuJXMnLCBlcnJvciQxLCBjb21wb25lbnROYW1lTWVzc2FnZSwgcmVjcmVhdGVNZXNzYWdlLCBjb21wb25lbnRTdGFjayk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkZWZhdWx0T25SZWNvdmVyYWJsZUVycm9yKGVycm9yLCBlcnJvckluZm8pIHtcbiAgcmVwb3J0R2xvYmFsRXJyb3IoZXJyb3IpO1xufVxuZnVuY3Rpb24gbG9nVW5jYXVnaHRFcnJvcihyb290LCBlcnJvckluZm8pIHtcbiAgdHJ5IHtcbiAgICBpZiAodHJ1ZSkge1xuICAgICAgY29tcG9uZW50TmFtZSA9IGVycm9ySW5mby5zb3VyY2UgPyBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGVycm9ySW5mby5zb3VyY2UpIDogbnVsbDtcbiAgICAgIGVycm9yQm91bmRhcnlOYW1lID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgZXJyb3IgPSBlcnJvckluZm8udmFsdWU7XG5cbiAgICBpZiAodHJ1ZSAmJiBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgLy8gRm9yIHVuY2F1Z2h0IGVycm9ycyBpbnNpZGUgYWN0LCB3ZSB0cmFjayB0aGVtIG9uIHRoZSBhY3QgYW5kIHRoZW5cbiAgICAgIC8vIHJldGhyb3cgdGhlbSBpbnRvIHRoZSB0ZXN0LlxuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMudGhyb3duRXJyb3JzLnB1c2goZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBvblVuY2F1Z2h0RXJyb3IgPSByb290Lm9uVW5jYXVnaHRFcnJvcjtcbiAgICBvblVuY2F1Z2h0RXJyb3IoZXJyb3IsIHtcbiAgICAgIGNvbXBvbmVudFN0YWNrOiBlcnJvckluZm8uc3RhY2tcbiAgICB9KTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIFRoaXMgbWV0aG9kIG11c3Qgbm90IHRocm93LCBvciBSZWFjdCBpbnRlcm5hbCBzdGF0ZSB3aWxsIGdldCBtZXNzZWQgdXAuXG4gICAgLy8gSWYgY29uc29sZS5lcnJvciBpcyBvdmVycmlkZGVuLCBvciBsb2dDYXB0dXJlZEVycm9yKCkgc2hvd3MgYSBkaWFsb2cgdGhhdCB0aHJvd3MsXG4gICAgLy8gd2Ugd2FudCB0byByZXBvcnQgdGhpcyBlcnJvciBvdXRzaWRlIG9mIHRoZSBub3JtYWwgc3RhY2sgYXMgYSBsYXN0IHJlc29ydC5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzMTg4XG4gICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICB0aHJvdyBlO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBsb2dDYXVnaHRFcnJvcihyb290LCBib3VuZGFyeSwgZXJyb3JJbmZvKSB7XG4gIHRyeSB7XG4gICAgaWYgKHRydWUpIHtcbiAgICAgIGNvbXBvbmVudE5hbWUgPSBlcnJvckluZm8uc291cmNlID8gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihlcnJvckluZm8uc291cmNlKSA6IG51bGw7XG4gICAgICBlcnJvckJvdW5kYXJ5TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoYm91bmRhcnkpO1xuICAgIH1cblxuICAgIHZhciBlcnJvciA9IGVycm9ySW5mby52YWx1ZTtcbiAgICB2YXIgb25DYXVnaHRFcnJvciA9IHJvb3Qub25DYXVnaHRFcnJvcjtcbiAgICBvbkNhdWdodEVycm9yKGVycm9yLCB7XG4gICAgICBjb21wb25lbnRTdGFjazogZXJyb3JJbmZvLnN0YWNrLFxuICAgICAgZXJyb3JCb3VuZGFyeTogYm91bmRhcnkudGFnID09PSBDbGFzc0NvbXBvbmVudCA/IGJvdW5kYXJ5LnN0YXRlTm9kZSAvLyBUaGlzIHNob3VsZCBhbHdheXMgYmUgdGhlIGNhc2UgYXMgbG9uZyBhcyB3ZSBvbmx5IGhhdmUgY2xhc3MgYm91bmRhcmllc1xuICAgICAgOiBudWxsXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICAvLyBUaGlzIG1ldGhvZCBtdXN0IG5vdCB0aHJvdywgb3IgUmVhY3QgaW50ZXJuYWwgc3RhdGUgd2lsbCBnZXQgbWVzc2VkIHVwLlxuICAgIC8vIElmIGNvbnNvbGUuZXJyb3IgaXMgb3ZlcnJpZGRlbiwgb3IgbG9nQ2FwdHVyZWRFcnJvcigpIHNob3dzIGEgZGlhbG9nIHRoYXQgdGhyb3dzLFxuICAgIC8vIHdlIHdhbnQgdG8gcmVwb3J0IHRoaXMgZXJyb3Igb3V0c2lkZSBvZiB0aGUgbm9ybWFsIHN0YWNrIGFzIGEgbGFzdCByZXNvcnQuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzE4OFxuICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgdGhyb3cgZTtcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVSb290RXJyb3JVcGRhdGUocm9vdCwgZXJyb3JJbmZvLCBsYW5lKSB7XG4gIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7IC8vIFVubW91bnQgdGhlIHJvb3QgYnkgcmVuZGVyaW5nIG51bGwuXG5cbiAgdXBkYXRlLnRhZyA9IENhcHR1cmVVcGRhdGU7IC8vIENhdXRpb246IFJlYWN0IERldlRvb2xzIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJvcGVydHlcbiAgLy8gYmVpbmcgY2FsbGVkIFwiZWxlbWVudFwiLlxuXG4gIHVwZGF0ZS5wYXlsb2FkID0ge1xuICAgIGVsZW1lbnQ6IG51bGxcbiAgfTtcblxuICB1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHByZXZGaWJlciA9IGdldEN1cnJlbnRGaWJlcigpOyAvLyBzaG91bGQganVzdCBiZSB0aGUgcm9vdFxuXG4gICAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihlcnJvckluZm8uc291cmNlKTtcbiAgICBsb2dVbmNhdWdodEVycm9yKHJvb3QsIGVycm9ySW5mbyk7XG4gICAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihwcmV2RmliZXIpO1xuICB9O1xuXG4gIHJldHVybiB1cGRhdGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUobGFuZSkge1xuICB2YXIgdXBkYXRlID0gY3JlYXRlVXBkYXRlKGxhbmUpO1xuICB1cGRhdGUudGFnID0gQ2FwdHVyZVVwZGF0ZTtcbiAgcmV0dXJuIHVwZGF0ZTtcbn1cblxuZnVuY3Rpb24gaW5pdGlhbGl6ZUNsYXNzRXJyb3JVcGRhdGUodXBkYXRlLCByb290LCBmaWJlciwgZXJyb3JJbmZvKSB7XG4gIHZhciBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPSBmaWJlci50eXBlLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvcjtcblxuICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBlcnJvciQxID0gZXJyb3JJbmZvLnZhbHVlO1xuXG4gICAgdXBkYXRlLnBheWxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKGVycm9yJDEpO1xuICAgIH07XG5cbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB7XG4gICAgICAgIG1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHByZXZGaWJlciA9IGdldEN1cnJlbnRGaWJlcigpOyAvLyBzaG91bGQgYmUgdGhlIGVycm9yIGJvdW5kYXJ5XG5cbiAgICAgIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoZXJyb3JJbmZvLnNvdXJjZSk7XG4gICAgICBsb2dDYXVnaHRFcnJvcihyb290LCBmaWJlciwgZXJyb3JJbmZvKTtcbiAgICAgIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYocHJldkZpYmVyKTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGluc3QgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgaWYgKGluc3QgIT09IG51bGwgJiYgdHlwZW9mIGluc3QuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyAkRmxvd0ZpeE1lW21pc3NpbmctdGhpcy1hbm5vdF1cbiAgICB1cGRhdGUuY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjaygpIHtcbiAgICAgIHtcbiAgICAgICAgbWFya0ZhaWxlZEVycm9yQm91bmRhcnlGb3JIb3RSZWxvYWRpbmcoZmliZXIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgcHJldkZpYmVyID0gZ2V0Q3VycmVudEZpYmVyKCk7IC8vIHNob3VsZCBiZSB0aGUgZXJyb3IgYm91bmRhcnlcblxuICAgICAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihlcnJvckluZm8uc291cmNlKTtcbiAgICAgIGxvZ0NhdWdodEVycm9yKHJvb3QsIGZpYmVyLCBlcnJvckluZm8pO1xuICAgICAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihwcmV2RmliZXIpO1xuXG4gICAgICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBUbyBwcmVzZXJ2ZSB0aGUgcHJlZXhpc3RpbmcgcmV0cnkgYmVoYXZpb3Igb2YgZXJyb3IgYm91bmRhcmllcyxcbiAgICAgICAgLy8gd2Uga2VlcCB0cmFjayBvZiB3aGljaCBvbmVzIGFscmVhZHkgZmFpbGVkIGR1cmluZyB0aGlzIGJhdGNoLlxuICAgICAgICAvLyBUaGlzIGdldHMgcmVzZXQgYmVmb3JlIHdlIHlpZWxkIGJhY2sgdG8gdGhlIGJyb3dzZXIuXG4gICAgICAgIC8vIFRPRE86IFdhcm4gaW4gc3RyaWN0IG1vZGUgaWYgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIGlzXG4gICAgICAgIC8vIG5vdCBkZWZpbmVkLlxuICAgICAgICBtYXJrTGVnYWN5RXJyb3JCb3VuZGFyeUFzRmFpbGVkKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZXJyb3IkMSA9IGVycm9ySW5mby52YWx1ZTtcbiAgICAgIHZhciBzdGFjayA9IGVycm9ySW5mby5zdGFjaztcbiAgICAgIHRoaXMuY29tcG9uZW50RGlkQ2F0Y2goZXJyb3IkMSwge1xuICAgICAgICBjb21wb25lbnRTdGFjazogc3RhY2sgIT09IG51bGwgPyBzdGFjayA6ICcnXG4gICAgICB9KTtcblxuICAgICAge1xuICAgICAgICBpZiAodHlwZW9mIGdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIC8vIElmIGNvbXBvbmVudERpZENhdGNoIGlzIHRoZSBvbmx5IGVycm9yIGJvdW5kYXJ5IG1ldGhvZCBkZWZpbmVkLFxuICAgICAgICAgIC8vIHRoZW4gaXQgbmVlZHMgdG8gY2FsbCBzZXRTdGF0ZSB0byByZWNvdmVyIGZyb20gZXJyb3JzLlxuICAgICAgICAgIC8vIElmIG5vIHN0YXRlIHVwZGF0ZSBpcyBzY2hlZHVsZWQgdGhlbiB0aGUgYm91bmRhcnkgd2lsbCBzd2FsbG93IHRoZSBlcnJvci5cbiAgICAgICAgICBpZiAoIWluY2x1ZGVzU29tZUxhbmUoZmliZXIubGFuZXMsIFN5bmNMYW5lKSkge1xuICAgICAgICAgICAgZXJyb3IoJyVzOiBFcnJvciBib3VuZGFyaWVzIHNob3VsZCBpbXBsZW1lbnQgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yKCkuICcgKyAnSW4gdGhhdCBtZXRob2QsIHJldHVybiBhIHN0YXRlIHVwZGF0ZSB0byBkaXNwbGF5IGFuIGVycm9yIG1lc3NhZ2Ugb3IgZmFsbGJhY2sgVUkuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ1Vua25vd24nKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdXNwZW5zZUJvdW5kYXJ5U2hvdWxkQ2FwdHVyZShzdXNwZW5zZUJvdW5kYXJ5LCByZXR1cm5GaWJlciwgc291cmNlRmliZXIsIHJvb3QsIHJvb3RSZW5kZXJMYW5lcykge1xuICAvLyB3aXRoIHRoZSBub3JtYWwgc3VzcGVuZCBwYXRoLlxuICAvL1xuICAvLyBBZnRlciB0aGlzIHdlJ2xsIHVzZSBhIHNldCBvZiBoZXVyaXN0aWNzIHRvIGRldGVybWluZSB3aGV0aGVyIHRoaXNcbiAgLy8gcmVuZGVyIHBhc3Mgd2lsbCBydW4gdG8gY29tcGxldGlvbiBvciByZXN0YXJ0IG9yIFwic3VzcGVuZFwiIHRoZSBjb21taXQuXG4gIC8vIFRoZSBhY3R1YWwgbG9naWMgZm9yIHRoaXMgaXMgc3ByZWFkIG91dCBpbiBkaWZmZXJlbnQgcGxhY2VzLlxuICAvL1xuICAvLyBUaGlzIGZpcnN0IHByaW5jaXBsZSBpcyB0aGF0IGlmIHdlJ3JlIGdvaW5nIHRvIHN1c3BlbmQgd2hlbiB3ZSBjb21wbGV0ZVxuICAvLyBhIHJvb3QsIHRoZW4gd2Ugc2hvdWxkIGFsc28gcmVzdGFydCBpZiB3ZSBnZXQgYW4gdXBkYXRlIG9yIHBpbmcgdGhhdFxuICAvLyBtaWdodCB1bnN1c3BlbmQgaXQsIGFuZCB2aWNlIHZlcnNhLiBUaGUgb25seSByZWFzb24gdG8gc3VzcGVuZCBpc1xuICAvLyBiZWNhdXNlIHlvdSB0aGluayB5b3UgbWlnaHQgd2FudCB0byByZXN0YXJ0IGJlZm9yZSBjb21taXR0aW5nLiBIb3dldmVyLFxuICAvLyBpdCBkb2Vzbid0IG1ha2Ugc2Vuc2UgdG8gcmVzdGFydCBvbmx5IHdoaWxlIGluIHRoZSBwZXJpb2Qgd2UncmUgc3VzcGVuZGVkLlxuICAvL1xuICAvLyBSZXN0YXJ0aW5nIHRvbyBhZ2dyZXNzaXZlbHkgaXMgYWxzbyBub3QgZ29vZCBiZWNhdXNlIGl0IHN0YXJ2ZXMgb3V0IGFueVxuICAvLyBpbnRlcm1lZGlhdGUgbG9hZGluZyBzdGF0ZS4gU28gd2UgdXNlIGhldXJpc3RpY3MgdG8gZGV0ZXJtaW5lIHdoZW4uXG4gIC8vIFN1c3BlbnNlIEhldXJpc3RpY3NcbiAgLy9cbiAgLy8gSWYgbm90aGluZyB0aHJldyBhIFByb21pc2Ugb3IgYWxsIHRoZSBzYW1lIGZhbGxiYWNrcyBhcmUgYWxyZWFkeSBzaG93aW5nLFxuICAvLyB0aGVuIGRvbid0IHN1c3BlbmQvcmVzdGFydC5cbiAgLy9cbiAgLy8gSWYgdGhpcyBpcyBhbiBpbml0aWFsIHJlbmRlciBvZiBhIG5ldyB0cmVlIG9mIFN1c3BlbnNlIGJvdW5kYXJpZXMgYW5kXG4gIC8vIHRob3NlIHRyaWdnZXIgYSBmYWxsYmFjaywgdGhlbiBkb24ndCBzdXNwZW5kL3Jlc3RhcnQuIFdlIHdhbnQgdG8gZW5zdXJlXG4gIC8vIHRoYXQgd2UgY2FuIHNob3cgdGhlIGluaXRpYWwgbG9hZGluZyBzdGF0ZSBhcyBxdWlja2x5IGFzIHBvc3NpYmxlLlxuICAvL1xuICAvLyBJZiB3ZSBoaXQgYSBcIkRlbGF5ZWRcIiBjYXNlLCBzdWNoIGFzIHdoZW4gd2UnZCBzd2l0Y2ggZnJvbSBjb250ZW50IGJhY2sgaW50b1xuICAvLyBhIGZhbGxiYWNrLCB0aGVuIHdlIHNob3VsZCBhbHdheXMgc3VzcGVuZC9yZXN0YXJ0LiBUcmFuc2l0aW9ucyBhcHBseVxuICAvLyB0byB0aGlzIGNhc2UuIElmIG5vbmUgaXMgZGVmaW5lZCwgSk5EIGlzIHVzZWQgaW5zdGVhZC5cbiAgLy9cbiAgLy8gSWYgd2UncmUgYWxyZWFkeSBzaG93aW5nIGEgZmFsbGJhY2sgYW5kIGl0IGdldHMgXCJyZXRyaWVkXCIsIGFsbG93aW5nIHVzIHRvIHNob3dcbiAgLy8gYW5vdGhlciBsZXZlbCwgYnV0IHRoZXJlJ3Mgc3RpbGwgYW4gaW5uZXIgYm91bmRhcnkgdGhhdCB3b3VsZCBzaG93IGEgZmFsbGJhY2ssXG4gIC8vIHRoZW4gd2Ugc3VzcGVuZC9yZXN0YXJ0IGZvciA1MDBtcyBzaW5jZSB0aGUgbGFzdCB0aW1lIHdlIHNob3dlZCBhIGZhbGxiYWNrXG4gIC8vIGFueXdoZXJlIGluIHRoZSB0cmVlLiBUaGlzIGVmZmVjdGl2ZWx5IHRocm90dGxlcyBwcm9ncmVzc2l2ZSBsb2FkaW5nIGludG8gYVxuICAvLyBjb25zaXN0ZW50IHRyYWluIG9mIGNvbW1pdHMuIFRoaXMgYWxzbyBnaXZlcyB1cyBhbiBvcHBvcnR1bml0eSB0byByZXN0YXJ0IHRvXG4gIC8vIGdldCB0byB0aGUgY29tcGxldGVkIHN0YXRlIHNsaWdodGx5IGVhcmxpZXIuXG4gIC8vXG4gIC8vIElmIHRoZXJlJ3MgYW1iaWd1aXR5IGR1ZSB0byBiYXRjaGluZyBpdCdzIHJlc29sdmVkIGluIHByZWZlcmVuY2Ugb2Y6XG4gIC8vIDEpIFwiZGVsYXllZFwiLCAyKSBcImluaXRpYWwgcmVuZGVyXCIsIDMpIFwicmV0cnlcIi5cbiAgLy9cbiAgLy8gV2Ugd2FudCB0byBlbnN1cmUgdGhhdCBhIFwiYnVzeVwiIHN0YXRlIGRvZXNuJ3QgZ2V0IGZvcmNlIGNvbW1pdHRlZC4gV2Ugd2FudCB0b1xuICAvLyBlbnN1cmUgdGhhdCBuZXcgaW5pdGlhbCBsb2FkaW5nIHN0YXRlcyBjYW4gY29tbWl0IGFzIHNvb24gYXMgcG9zc2libGUuXG5cblxuICBzdXNwZW5zZUJvdW5kYXJ5LmZsYWdzIHw9IFNob3VsZENhcHR1cmU7IC8vIFRPRE86IEkgdGhpbmsgd2UgY2FuIHJlbW92ZSB0aGlzLCBzaW5jZSB3ZSBub3cgdXNlIGBEaWRDYXB0dXJlYCBpblxuICAvLyB0aGUgYmVnaW4gcGhhc2UgdG8gcHJldmVudCBhbiBlYXJseSBiYWlsb3V0LlxuXG4gIHN1c3BlbnNlQm91bmRhcnkubGFuZXMgPSByb290UmVuZGVyTGFuZXM7XG4gIHJldHVybiBzdXNwZW5zZUJvdW5kYXJ5O1xufVxuXG5mdW5jdGlvbiB0aHJvd0V4Y2VwdGlvbihyb290LCByZXR1cm5GaWJlciwgc291cmNlRmliZXIsIHZhbHVlLCByb290UmVuZGVyTGFuZXMpIHtcbiAgLy8gVGhlIHNvdXJjZSBmaWJlciBkaWQgbm90IGNvbXBsZXRlLlxuICBzb3VyY2VGaWJlci5mbGFncyB8PSBJbmNvbXBsZXRlO1xuXG4gIHtcbiAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgIC8vIElmIHdlIGhhdmUgcGVuZGluZyB3b3JrIHN0aWxsLCByZXN0b3JlIHRoZSBvcmlnaW5hbCB1cGRhdGVyc1xuICAgICAgcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LCByb290UmVuZGVyTGFuZXMpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIFRoaXMgaXMgYSB3YWtlYWJsZS4gVGhlIGNvbXBvbmVudCBzdXNwZW5kZWQuXG4gICAgICB2YXIgd2FrZWFibGUgPSB2YWx1ZTtcblxuICAgICAge1xuICAgICAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSAmJiAoZGlzYWJsZUxlZ2FjeU1vZGUgKSkge1xuICAgICAgICAgIG1hcmtEaWRUaHJvd1doaWxlSHlkcmF0aW5nREVWKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuXG4gICAgICB2YXIgc3VzcGVuc2VCb3VuZGFyeSA9IGdldFN1c3BlbnNlSGFuZGxlcigpO1xuXG4gICAgICBpZiAoc3VzcGVuc2VCb3VuZGFyeSAhPT0gbnVsbCkge1xuICAgICAgICBzd2l0Y2ggKHN1c3BlbnNlQm91bmRhcnkudGFnKSB7XG4gICAgICAgICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhpcyBzdXNwZW5zZSBib3VuZGFyeSBpcyBub3QgYWxyZWFkeSBzaG93aW5nIGEgZmFsbGJhY2ssIG1hcmtcbiAgICAgICAgICAgICAgLy8gdGhlIGluLXByb2dyZXNzIHJlbmRlciBhcyBzdXNwZW5kZWQuIFdlIHRyeSB0byBwZXJmb3JtIHRoaXMgbG9naWNcbiAgICAgICAgICAgICAgLy8gYXMgc29vbiBhcyBzb29uIGFzIHBvc3NpYmxlIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLCBzbyB0aGUgd29ya1xuICAgICAgICAgICAgICAvLyBsb29wIGNhbiBrbm93IHRoaW5ncyBsaWtlIHdoZXRoZXIgaXQncyBPSyB0byBzd2l0Y2ggdG8gb3RoZXIgdGFza3MsXG4gICAgICAgICAgICAgIC8vIG9yIHdoZXRoZXIgaXQgY2FuIHdhaXQgZm9yIGRhdGEgdG8gcmVzb2x2ZSBiZWZvcmUgY29udGludWluZy5cbiAgICAgICAgICAgICAgLy8gVE9ETzogTW9zdCBvZiB0aGVzZSBjaGVja3MgYXJlIGFscmVhZHkgcGVyZm9ybWVkIHdoZW4gZW50ZXJpbmcgYVxuICAgICAgICAgICAgICAvLyBTdXNwZW5zZSBib3VuZGFyeS4gV2Ugc2hvdWxkIHRyYWNrIHRoZSBpbmZvcm1hdGlvbiBvbiB0aGUgc3RhY2sgc29cbiAgICAgICAgICAgICAgLy8gd2UgZG9uJ3QgaGF2ZSB0byByZWNvbXB1dGUgaXQgb24gZGVtYW5kLiBUaGlzIHdvdWxkIGFsc28gYWxsb3cgdXNcbiAgICAgICAgICAgICAgLy8gdG8gdW5pZnkgd2l0aCBgdXNlYCB3aGljaCBuZWVkcyB0byBwZXJmb3JtIHRoaXMgbG9naWMgZXZlbiBzb29uZXIsXG4gICAgICAgICAgICAgIC8vIGJlZm9yZSBgdGhyb3dFeGNlcHRpb25gIGlzIGNhbGxlZC5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGlmIChnZXRTaGVsbEJvdW5kYXJ5KCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIC8vIFN1c3BlbmRlZCBpbiB0aGUgXCJzaGVsbFwiIG9mIHRoZSBhcHAuIFRoaXMgaXMgYW4gdW5kZXNpcmFibGVcbiAgICAgICAgICAgICAgICAgIC8vIGxvYWRpbmcgc3RhdGUuIFdlIHNob3VsZCBhdm9pZCBjb21taXR0aW5nIHRoaXMgdHJlZS5cbiAgICAgICAgICAgICAgICAgIHJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgLy8gSWYgd2Ugc3VzcGVuZGVkIGRlZXBlciB0aGFuIHRoZSBzaGVsbCwgd2UgZG9uJ3QgbmVlZCB0byBkZWxheVxuICAgICAgICAgICAgICAgICAgLy8gdGhlIGNvbW1taXQuIEhvd2V2ZXIsIHdlIHN0aWxsIGNhbGwgcmVuZGVyRGlkU3VzcGVuZCBpZiB0aGlzIGlzXG4gICAgICAgICAgICAgICAgICAvLyBhIG5ldyBib3VuZGFyeSwgdG8gdGVsbCB0aGUgd29yayBsb29wIHRoYXQgYSBuZXcgZmFsbGJhY2sgaGFzXG4gICAgICAgICAgICAgICAgICAvLyBhcHBlYXJlZCBkdXJpbmcgdGhpcyByZW5kZXIuXG4gICAgICAgICAgICAgICAgICAvLyBUT0RPOiBUaGVvcmV0aWNhbGx5IHdlIHNob3VsZCBiZSBhYmxlIHRvIGRlbGV0ZSB0aGlzIGJyYW5jaC5cbiAgICAgICAgICAgICAgICAgIC8vIEl0J3MgY3VycmVudGx5IHVzZWQgZm9yIHR3byB0aGluZ3M6IDEpIHRvIHRocm90dGxlIHRoZVxuICAgICAgICAgICAgICAgICAgLy8gYXBwZWFyYW5jZSBvZiBzdWNjZXNzaXZlIGxvYWRpbmcgc3RhdGVzLCBhbmQgMikgaW5cbiAgICAgICAgICAgICAgICAgIC8vIFN1c3BlbnNlTGlzdCwgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGNoaWxkcmVuIGluY2x1ZGUgYW55XG4gICAgICAgICAgICAgICAgICAvLyBwZW5kaW5nIGZhbGxiYWNrcy4gRm9yIDEsIHdlIHNob3VsZCBhcHBseSB0aHJvdHRsaW5nIHRvIGFsbFxuICAgICAgICAgICAgICAgICAgLy8gcmV0cmllcywgbm90IGp1c3Qgb25lcyB0aGF0IHJlbmRlciBhbiBhZGRpdGlvbmFsIGZhbGxiYWNrLiBGb3JcbiAgICAgICAgICAgICAgICAgIC8vIDIsIHdlIHNob3VsZCBjaGVjayBzdWJ0cmVlRmxhZ3MgaW5zdGVhZC4gVGhlbiB3ZSBjYW4gZGVsZXRlXG4gICAgICAgICAgICAgICAgICAvLyB0aGlzIGJyYW5jaC5cbiAgICAgICAgICAgICAgICAgIHZhciBjdXJyZW50ID0gc3VzcGVuc2VCb3VuZGFyeS5hbHRlcm5hdGU7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlbmRlckRpZFN1c3BlbmQoKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzdXNwZW5zZUJvdW5kYXJ5LmZsYWdzICY9IH5Gb3JjZUNsaWVudFJlbmRlcjtcbiAgICAgICAgICAgICAgbWFya1N1c3BlbnNlQm91bmRhcnlTaG91bGRDYXB0dXJlKHN1c3BlbnNlQm91bmRhcnksIHJldHVybkZpYmVyLCBzb3VyY2VGaWJlciwgcm9vdCwgcm9vdFJlbmRlckxhbmVzKTsgLy8gUmV0cnkgbGlzdGVuZXJcbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgLy8gSWYgdGhlIGZhbGxiYWNrIGRvZXMgY29tbWl0LCB3ZSBuZWVkIHRvIGF0dGFjaCBhIGRpZmZlcmVudCB0eXBlIG9mXG4gICAgICAgICAgICAgIC8vIGxpc3RlbmVyLiBUaGlzIG9uZSBzY2hlZHVsZXMgYW4gdXBkYXRlIG9uIHRoZSBTdXNwZW5zZSBib3VuZGFyeSB0b1xuICAgICAgICAgICAgICAvLyB0dXJuIHRoZSBmYWxsYmFjayBzdGF0ZSBvZmYuXG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIC8vIFN0YXNoIHRoZSB3YWtlYWJsZSBvbiB0aGUgYm91bmRhcnkgZmliZXIgc28gd2UgY2FuIGFjY2VzcyBpdCBpbiB0aGVcbiAgICAgICAgICAgICAgLy8gY29tbWl0IHBoYXNlLlxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvLyBXaGVuIHRoZSB3YWtlYWJsZSByZXNvbHZlcywgd2UnbGwgYXR0ZW1wdCB0byByZW5kZXIgdGhlIGJvdW5kYXJ5XG4gICAgICAgICAgICAgIC8vIGFnYWluIChcInJldHJ5XCIpLlxuICAgICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgU3VzcGVuc2V5IHJlc291cmNlLiBXZSBkbyBub3QgYXR0YWNoIHJldHJ5XG4gICAgICAgICAgICAgIC8vIGxpc3RlbmVycyB0byB0aGVzZSwgYmVjYXVzZSB3ZSBkb24ndCBhY3R1YWxseSBuZWVkIHRoZW0gZm9yXG4gICAgICAgICAgICAgIC8vIHJlbmRlcmluZy4gT25seSBmb3IgY29tbWl0dGluZy4gSW5zdGVhZCwgaWYgYSBmYWxsYmFjayBjb21taXRzXG4gICAgICAgICAgICAgIC8vIGFuZCB0aGUgb25seSB0aGluZyB0aGF0IHN1c3BlbmRlZCB3YXMgYSBTdXNwZW5zZXkgcmVzb3VyY2UsIHdlXG4gICAgICAgICAgICAgIC8vIHJldHJ5IGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgICAvLyBUT0RPOiBSZWZhY3RvciB0aHJvd0V4Y2VwdGlvbiBzbyB0aGF0IHdlIGRvbid0IGhhdmUgdG8gZG8gdGhpcyB0eXBlXG4gICAgICAgICAgICAgIC8vIGNoZWNrLiBUaGUgY2FsbGVyIGFscmVhZHkga25vd3Mgd2hhdCB0aGUgY2F1c2Ugd2FzLlxuXG4gICAgICAgICAgICAgIHZhciBpc1N1c3BlbnNleVJlc291cmNlID0gd2FrZWFibGUgPT09IG5vb3BTdXNwZW5zZXlDb21taXRUaGVuYWJsZTtcblxuICAgICAgICAgICAgICBpZiAoaXNTdXNwZW5zZXlSZXNvdXJjZSkge1xuICAgICAgICAgICAgICAgIHN1c3BlbnNlQm91bmRhcnkuZmxhZ3MgfD0gU2NoZWR1bGVSZXRyeTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0cnlRdWV1ZSA9IHN1c3BlbnNlQm91bmRhcnkudXBkYXRlUXVldWU7XG5cbiAgICAgICAgICAgICAgICBpZiAocmV0cnlRdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgc3VzcGVuc2VCb3VuZGFyeS51cGRhdGVRdWV1ZSA9IG5ldyBTZXQoW3dha2VhYmxlXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJldHJ5UXVldWUuYWRkKHdha2VhYmxlKTtcbiAgICAgICAgICAgICAgICB9IC8vIFdlIG9ubHkgYXR0YWNoIHBpbmcgbGlzdGVuZXJzIGluIGNvbmN1cnJlbnQgbW9kZS4gTGVnYWN5XG4gICAgICAgICAgICAgICAgLy8gU3VzcGVuc2UgYWx3YXlzIGNvbW1pdHMgZmFsbGJhY2tzIHN5bmNocm9ub3VzbHksIHNvIHRoZXJlIGFyZVxuICAgICAgICAgICAgICAgIC8vIG5vIHBpbmdzLlxuXG5cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBhdHRhY2hQaW5nTGlzdGVuZXIocm9vdCwgd2FrZWFibGUsIHJvb3RSZW5kZXJMYW5lcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBzdXNwZW5zZUJvdW5kYXJ5LmZsYWdzIHw9IFNob3VsZENhcHR1cmU7XG5cbiAgICAgICAgICAgICAgICB2YXIgX2lzU3VzcGVuc2V5UmVzb3VyY2UgPSB3YWtlYWJsZSA9PT0gbm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlO1xuXG4gICAgICAgICAgICAgICAgaWYgKF9pc1N1c3BlbnNleVJlc291cmNlKSB7XG4gICAgICAgICAgICAgICAgICBzdXNwZW5zZUJvdW5kYXJ5LmZsYWdzIHw9IFNjaGVkdWxlUmV0cnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHZhciBvZmZzY3JlZW5RdWV1ZSA9IHN1c3BlbnNlQm91bmRhcnkudXBkYXRlUXVldWU7XG5cbiAgICAgICAgICAgICAgICAgIGlmIChvZmZzY3JlZW5RdWV1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV3T2Zmc2NyZWVuUXVldWUgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbnM6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgbWFya2VySW5zdGFuY2VzOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgIHJldHJ5UXVldWU6IG5ldyBTZXQoW3dha2VhYmxlXSlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgc3VzcGVuc2VCb3VuZGFyeS51cGRhdGVRdWV1ZSA9IG5ld09mZnNjcmVlblF1ZXVlO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIF9yZXRyeVF1ZXVlID0gb2Zmc2NyZWVuUXVldWUucmV0cnlRdWV1ZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoX3JldHJ5UXVldWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBvZmZzY3JlZW5RdWV1ZS5yZXRyeVF1ZXVlID0gbmV3IFNldChbd2FrZWFibGVdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBfcmV0cnlRdWV1ZS5hZGQod2FrZWFibGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB3YWtlYWJsZSwgcm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgU3VzcGVuc2UgaGFuZGxlciB0YWcgKFwiICsgc3VzcGVuc2VCb3VuZGFyeS50YWcgKyBcIikuIFRoaXMgXCIgKyAnaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBObyBib3VuZGFyeSB3YXMgZm91bmQuIFVubGVzcyB0aGlzIGlzIGEgc3luYyB1cGRhdGUsIHRoaXMgaXMgT0suXG4gICAgICAgIC8vIFdlIGNhbiBzdXNwZW5kIGFuZCB3YWl0IGZvciBtb3JlIGRhdGEgdG8gYXJyaXZlLlxuICAgICAgICB7XG4gICAgICAgICAgLy8gSW4gYSBjb25jdXJyZW50IHJvb3QsIHN1c3BlbmRpbmcgd2l0aG91dCBhIFN1c3BlbnNlIGJvdW5kYXJ5IGlzXG4gICAgICAgICAgLy8gYWxsb3dlZC4gSXQgd2lsbCBzdXNwZW5kIGluZGVmaW5pdGVseSB3aXRob3V0IGNvbW1pdHRpbmcuXG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBUT0RPOiBTaG91bGQgd2UgaGF2ZSBkaWZmZXJlbnQgYmVoYXZpb3IgZm9yIGRpc2NyZXRlIHVwZGF0ZXM/IFdoYXRcbiAgICAgICAgICAvLyBhYm91dCBmbHVzaFN5bmM/IE1heWJlIGl0IHNob3VsZCBwdXQgdGhlIHRyZWUgaW50byBhbiBpbmVydCBzdGF0ZSxcbiAgICAgICAgICAvLyBhbmQgcG90ZW50aWFsbHkgbG9nIGEgd2FybmluZy4gUmV2aXNpdCB0aGlzIGZvciBhIGZ1dHVyZSByZWxlYXNlLlxuICAgICAgICAgIGF0dGFjaFBpbmdMaXN0ZW5lcihyb290LCB3YWtlYWJsZSwgcm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgICByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IC8vIFRoaXMgaXMgYSByZWd1bGFyIGVycm9yLCBub3QgYSBTdXNwZW5zZSB3YWtlYWJsZS5cblxuXG4gIGlmIChnZXRJc0h5ZHJhdGluZygpICYmIChkaXNhYmxlTGVnYWN5TW9kZSApKSB7XG4gICAgbWFya0RpZFRocm93V2hpbGVIeWRyYXRpbmdERVYoKTtcblxuICAgIHZhciBfc3VzcGVuc2VCb3VuZGFyeSA9IGdldFN1c3BlbnNlSGFuZGxlcigpOyAvLyBJZiB0aGUgZXJyb3Igd2FzIHRocm93biBkdXJpbmcgaHlkcmF0aW9uLCB3ZSBtYXkgYmUgYWJsZSB0byByZWNvdmVyIGJ5XG4gICAgLy8gZGlzY2FyZGluZyB0aGUgZGVoeWRyYXRlZCBjb250ZW50IGFuZCBzd2l0Y2hpbmcgdG8gYSBjbGllbnQgcmVuZGVyLlxuICAgIC8vIEluc3RlYWQgb2Ygc3VyZmFjaW5nIHRoZSBlcnJvciwgZmluZCB0aGUgbmVhcmVzdCBTdXNwZW5zZSBib3VuZGFyeVxuICAgIC8vIGFuZCByZW5kZXIgaXQgYWdhaW4gd2l0aG91dCBoeWRyYXRpb24uXG5cblxuICAgIGlmIChfc3VzcGVuc2VCb3VuZGFyeSAhPT0gbnVsbCkge1xuICAgICAgaWYgKChfc3VzcGVuc2VCb3VuZGFyeS5mbGFncyAmIFNob3VsZENhcHR1cmUpID09PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgLy8gU2V0IGEgZmxhZyB0byBpbmRpY2F0ZSB0aGF0IHdlIHNob3VsZCB0cnkgcmVuZGVyaW5nIHRoZSBub3JtYWxcbiAgICAgICAgLy8gY2hpbGRyZW4gYWdhaW4sIG5vdCB0aGUgZmFsbGJhY2suXG4gICAgICAgIF9zdXNwZW5zZUJvdW5kYXJ5LmZsYWdzIHw9IEZvcmNlQ2xpZW50UmVuZGVyO1xuICAgICAgfVxuXG4gICAgICBtYXJrU3VzcGVuc2VCb3VuZGFyeVNob3VsZENhcHR1cmUoX3N1c3BlbnNlQm91bmRhcnksIHJldHVybkZpYmVyLCBzb3VyY2VGaWJlciwgcm9vdCwgcm9vdFJlbmRlckxhbmVzKTsgLy8gRXZlbiB0aG91Z2ggdGhlIHVzZXIgbWF5IG5vdCBiZSBhZmZlY3RlZCBieSB0aGlzIGVycm9yLCB3ZSBzaG91bGRcbiAgICAgIC8vIHN0aWxsIGxvZyBpdCBzbyBpdCBjYW4gYmUgZml4ZWQuXG5cbiAgICAgIGlmICh2YWx1ZSAhPT0gSHlkcmF0aW9uTWlzbWF0Y2hFeGNlcHRpb24pIHtcbiAgICAgICAgdmFyIF93cmFwcGVyRXJyb3IgPSBuZXcgRXJyb3IoJ1RoZXJlIHdhcyBhbiBlcnJvciB3aGlsZSBoeWRyYXRpbmcgYnV0IFJlYWN0IHdhcyBhYmxlIHRvIHJlY292ZXIgYnkgJyArICdpbnN0ZWFkIGNsaWVudCByZW5kZXJpbmcgZnJvbSB0aGUgbmVhcmVzdCBTdXNwZW5zZSBib3VuZGFyeS4nLCB7XG4gICAgICAgICAgY2F1c2U6IHZhbHVlXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHF1ZXVlSHlkcmF0aW9uRXJyb3IoY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoX3dyYXBwZXJFcnJvciwgc291cmNlRmliZXIpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodmFsdWUgIT09IEh5ZHJhdGlvbk1pc21hdGNoRXhjZXB0aW9uKSB7XG4gICAgICAgIHZhciBfd3JhcHBlckVycm9yMiA9IG5ldyBFcnJvcignVGhlcmUgd2FzIGFuIGVycm9yIHdoaWxlIGh5ZHJhdGluZyBidXQgUmVhY3Qgd2FzIGFibGUgdG8gcmVjb3ZlciBieSAnICsgJ2luc3RlYWQgY2xpZW50IHJlbmRlcmluZyB0aGUgZW50aXJlIHJvb3QuJywge1xuICAgICAgICAgIGNhdXNlOiB2YWx1ZVxuICAgICAgICB9KTtcblxuICAgICAgICBxdWV1ZUh5ZHJhdGlvbkVycm9yKGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKF93cmFwcGVyRXJyb3IyLCBzb3VyY2VGaWJlcikpO1xuICAgICAgfVxuXG4gICAgICB2YXIgX3dvcmtJblByb2dyZXNzID0gcm9vdC5jdXJyZW50LmFsdGVybmF0ZTsgLy8gU2NoZWR1bGUgYW4gdXBkYXRlIGF0IHRoZSByb290IHRvIGxvZyB0aGUgZXJyb3IgYnV0IHRoaXMgc2hvdWxkbid0XG4gICAgICAvLyBhY3R1YWxseSBoYXBwZW4gYmVjYXVzZSB3ZSBzaG91bGQgcmVjb3Zlci5cblxuICAgICAgX3dvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNob3VsZENhcHR1cmU7XG4gICAgICB2YXIgbGFuZSA9IHBpY2tBcmJpdHJhcnlMYW5lKHJvb3RSZW5kZXJMYW5lcyk7XG4gICAgICBfd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBtZXJnZUxhbmVzKF93b3JrSW5Qcm9ncmVzcy5sYW5lcywgbGFuZSk7XG4gICAgICB2YXIgcm9vdEVycm9ySW5mbyA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHZhbHVlLCBzb3VyY2VGaWJlcik7XG4gICAgICB2YXIgdXBkYXRlID0gY3JlYXRlUm9vdEVycm9yVXBkYXRlKF93b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUsIHJvb3RFcnJvckluZm8sIC8vIFRoaXMgc2hvdWxkIG5ldmVyIGFjdHVhbGx5IGdldCBsb2dnZWQgZHVlIHRvIHRoZSByZWNvdmVyeS5cbiAgICAgIGxhbmUpO1xuICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKF93b3JrSW5Qcm9ncmVzcywgdXBkYXRlKTtcbiAgICAgIHJlbmRlckRpZEVycm9yKCk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgdmFyIHdyYXBwZXJFcnJvciA9IG5ldyBFcnJvcignVGhlcmUgd2FzIGFuIGVycm9yIGR1cmluZyBjb25jdXJyZW50IHJlbmRlcmluZyBidXQgUmVhY3Qgd2FzIGFibGUgdG8gcmVjb3ZlciBieSAnICsgJ2luc3RlYWQgc3luY2hyb25vdXNseSByZW5kZXJpbmcgdGhlIGVudGlyZSByb290LicsIHtcbiAgICBjYXVzZTogdmFsdWVcbiAgfSk7XG4gIHF1ZXVlQ29uY3VycmVudEVycm9yKGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHdyYXBwZXJFcnJvciwgc291cmNlRmliZXIpKTtcbiAgcmVuZGVyRGlkRXJyb3IoKTsgLy8gV2UgZGlkbid0IGZpbmQgYSBib3VuZGFyeSB0aGF0IGNvdWxkIGhhbmRsZSB0aGlzIHR5cGUgb2YgZXhjZXB0aW9uLiBTdGFydFxuICAvLyBvdmVyIGFuZCB0cmF2ZXJzZSBwYXJlbnQgcGF0aCBhZ2FpbiwgdGhpcyB0aW1lIHRyZWF0aW5nIHRoZSBleGNlcHRpb25cbiAgLy8gYXMgYW4gZXJyb3IuXG5cbiAgaWYgKHJldHVybkZpYmVyID09PSBudWxsKSB7XG4gICAgLy8gVGhlcmUncyBubyByZXR1cm4gZmliZXIsIHdoaWNoIG1lYW5zIHRoZSByb290IGVycm9yZWQuIFRoaXMgc2hvdWxkIG5ldmVyXG4gICAgLy8gaGFwcGVuLiBSZXR1cm4gYHRydWVgIHRvIHRyaWdnZXIgYSBmYXRhbCBlcnJvciAocGFuaWMpLlxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgdmFyIGVycm9ySW5mbyA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHZhbHVlLCBzb3VyY2VGaWJlcik7XG4gIHZhciB3b3JrSW5Qcm9ncmVzcyA9IHJldHVybkZpYmVyO1xuXG4gIGRvIHtcbiAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNob3VsZENhcHR1cmU7XG5cbiAgICAgICAgICB2YXIgX2xhbmUgPSBwaWNrQXJiaXRyYXJ5TGFuZShyb290UmVuZGVyTGFuZXMpO1xuXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBtZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzLmxhbmVzLCBfbGFuZSk7XG5cbiAgICAgICAgICB2YXIgX3VwZGF0ZSA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZSh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUsIGVycm9ySW5mbywgX2xhbmUpO1xuXG4gICAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLCBfdXBkYXRlKTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgLy8gQ2FwdHVyZSBhbmQgcmV0cnlcbiAgICAgICAgdmFyIGN0b3IgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpID09PSBOb0ZsYWdzJDEgJiYgKHR5cGVvZiBjdG9yLmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciA9PT0gJ2Z1bmN0aW9uJyB8fCBpbnN0YW5jZSAhPT0gbnVsbCAmJiB0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2ggPT09ICdmdW5jdGlvbicgJiYgIWlzQWxyZWFkeUZhaWxlZExlZ2FjeUVycm9yQm91bmRhcnkoaW5zdGFuY2UpKSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFNob3VsZENhcHR1cmU7XG5cbiAgICAgICAgICB2YXIgX2xhbmUyID0gcGlja0FyYml0cmFyeUxhbmUocm9vdFJlbmRlckxhbmVzKTtcblxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzcy5sYW5lcywgX2xhbmUyKTsgLy8gU2NoZWR1bGUgdGhlIGVycm9yIGJvdW5kYXJ5IHRvIHJlLXJlbmRlciB1c2luZyB1cGRhdGVkIHN0YXRlXG5cbiAgICAgICAgICB2YXIgX3VwZGF0ZTIgPSBjcmVhdGVDbGFzc0Vycm9yVXBkYXRlKF9sYW5lMik7XG5cbiAgICAgICAgICBpbml0aWFsaXplQ2xhc3NFcnJvclVwZGF0ZShfdXBkYXRlMiwgcm9vdCwgd29ya0luUHJvZ3Jlc3MsIGVycm9ySW5mbyk7XG4gICAgICAgICAgZW5xdWV1ZUNhcHR1cmVkVXBkYXRlKHdvcmtJblByb2dyZXNzLCBfdXBkYXRlMik7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSB3ZSBiYWlsIG91dCB3aGVuIHdlIGdldCBhIG51bGxcblxuXG4gICAgd29ya0luUHJvZ3Jlc3MgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gIH0gd2hpbGUgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKTtcblxuICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGludG8gYSBkZWh5ZHJhdGVkIGJvdW5kYXJ5LlxuXG52YXIgU2VsZWN0aXZlSHlkcmF0aW9uRXhjZXB0aW9uID0gbmV3IEVycm9yKFwiVGhpcyBpcyBub3QgYSByZWFsIGVycm9yLiBJdCdzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbCBvZiBSZWFjdCdzIFwiICsgXCJzZWxlY3RpdmUgaHlkcmF0aW9uIGZlYXR1cmUuIElmIHRoaXMgbGVha3MgaW50byB1c2Vyc3BhY2UsIGl0J3MgYSBidWcgaW4gXCIgKyAnUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xudmFyIGRpZFJlY2VpdmVVcGRhdGUgPSBmYWxzZTtcbnZhciBkaWRXYXJuQWJvdXRCYWRDbGFzcztcbnZhciBkaWRXYXJuQWJvdXRDb250ZXh0VHlwZU9uRnVuY3Rpb25Db21wb25lbnQ7XG52YXIgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudDtcbnZhciBkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzO1xudmFyIGRpZFdhcm5BYm91dFJldmVhbE9yZGVyO1xudmFyIGRpZFdhcm5BYm91dFRhaWxPcHRpb25zO1xuXG57XG4gIGRpZFdhcm5BYm91dEJhZENsYXNzID0ge307XG4gIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudCA9IHt9O1xuICBkaWRXYXJuQWJvdXRHZXREZXJpdmVkU3RhdGVPbkZ1bmN0aW9uQ29tcG9uZW50ID0ge307XG4gIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSBmYWxzZTtcbiAgZGlkV2FybkFib3V0UmV2ZWFsT3JkZXIgPSB7fTtcbiAgZGlkV2FybkFib3V0VGFpbE9wdGlvbnMgPSB7fTtcbn1cblxuZnVuY3Rpb24gcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBJZiB0aGlzIGlzIGEgZnJlc2ggbmV3IGNvbXBvbmVudCB0aGF0IGhhc24ndCBiZWVuIHJlbmRlcmVkIHlldCwgd2VcbiAgICAvLyB3b24ndCB1cGRhdGUgaXRzIGNoaWxkIHNldCBieSBhcHBseWluZyBtaW5pbWFsIHNpZGUtZWZmZWN0cy4gSW5zdGVhZCxcbiAgICAvLyB3ZSB3aWxsIGFkZCB0aGVtIGFsbCB0byB0aGUgY2hpbGQgYmVmb3JlIGl0IGdldHMgcmVuZGVyZWQuIFRoYXQgbWVhbnNcbiAgICAvLyB3ZSBjYW4gb3B0aW1pemUgdGhpcyByZWNvbmNpbGlhdGlvbiBwYXNzIGJ5IG5vdCB0cmFja2luZyBzaWRlLWVmZmVjdHMuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBtb3VudENoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBJZiB0aGUgY3VycmVudCBjaGlsZCBpcyB0aGUgc2FtZSBhcyB0aGUgd29yayBpbiBwcm9ncmVzcywgaXQgbWVhbnMgdGhhdFxuICAgIC8vIHdlIGhhdmVuJ3QgeWV0IHN0YXJ0ZWQgYW55IHdvcmsgb24gdGhlc2UgY2hpbGRyZW4uIFRoZXJlZm9yZSwgd2UgdXNlXG4gICAgLy8gdGhlIGNsb25lIGFsZ29yaXRobSB0byBjcmVhdGUgYSBjb3B5IG9mIGFsbCB0aGUgY3VycmVudCBjaGlsZHJlbi5cbiAgICAvLyBJZiB3ZSBoYWQgYW55IHByb2dyZXNzZWQgd29yayBhbHJlYWR5LCB0aGF0IGlzIGludmFsaWQgYXQgdGhpcyBwb2ludCBzb1xuICAgIC8vIGxldCdzIHRocm93IGl0IG91dC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LmNoaWxkLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JjZVVubW91bnRDdXJyZW50QW5kUmVjb25jaWxlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgZm9yayBvZiByZWNvbmNpbGVDaGlsZHJlbi4gSXQncyB1c2VkIGluIGNhc2VzIHdoZXJlIHdlXG4gIC8vIHdhbnQgdG8gcmVjb25jaWxlIHdpdGhvdXQgbWF0Y2hpbmcgYWdhaW5zdCB0aGUgZXhpc3Rpbmcgc2V0LiBUaGlzIGhhcyB0aGVcbiAgLy8gZWZmZWN0IG9mIGFsbCBjdXJyZW50IGNoaWxkcmVuIGJlaW5nIHVubW91bnRlZDsgZXZlbiBpZiB0aGUgdHlwZSBhbmQga2V5XG4gIC8vIGFyZSB0aGUgc2FtZSwgdGhlIG9sZCBjaGlsZCBpcyB1bm1vdW50ZWQgYW5kIGEgbmV3IGNoaWxkIGlzIGNyZWF0ZWQuXG4gIC8vXG4gIC8vIFRvIGRvIHRoaXMsIHdlJ3JlIGdvaW5nIHRvIGdvIHRocm91Z2ggdGhlIHJlY29uY2lsZSBhbGdvcml0aG0gdHdpY2UuIEluXG4gIC8vIHRoZSBmaXJzdCBwYXNzLCB3ZSBzY2hlZHVsZSBhIGRlbGV0aW9uIGZvciBhbGwgdGhlIGN1cnJlbnQgY2hpbGRyZW4gYnlcbiAgLy8gcGFzc2luZyBudWxsLlxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBjdXJyZW50LmNoaWxkLCBudWxsLCByZW5kZXJMYW5lcyk7IC8vIEluIHRoZSBzZWNvbmQgcGFzcywgd2UgbW91bnQgdGhlIG5ldyBjaGlsZHJlbi4gVGhlIHRyaWNrIGhlcmUgaXMgdGhhdCB3ZVxuICAvLyBwYXNzIG51bGwgaW4gcGxhY2Ugb2Ygd2hlcmUgd2UgdXN1YWxseSBwYXNzIHRoZSBjdXJyZW50IGNoaWxkIHNldC4gVGhpcyBoYXNcbiAgLy8gdGhlIGVmZmVjdCBvZiByZW1vdW50aW5nIGFsbCBjaGlsZHJlbiByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlaXJcbiAgLy8gaWRlbnRpdGllcyBtYXRjaC5cblxuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHJlY29uY2lsZUNoaWxkRmliZXJzKHdvcmtJblByb2dyZXNzLCBudWxsLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlRm9yd2FyZFJlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRPRE86IGN1cnJlbnQgY2FuIGJlIG5vbi1udWxsIGhlcmUgZXZlbiBpZiB0aGUgY29tcG9uZW50XG4gIC8vIGhhc24ndCB5ZXQgbW91bnRlZC4gVGhpcyBoYXBwZW5zIGFmdGVyIHRoZSBmaXJzdCByZW5kZXIgc3VzcGVuZHMuXG4gIC8vIFdlJ2xsIG5lZWQgdG8gZmlndXJlIG91dCBpZiB0aGlzIGlzIGZpbmUgb3IgY2FuIGNhdXNlIGlzc3Vlcy5cbiAgdmFyIHJlbmRlciA9IENvbXBvbmVudC5yZW5kZXI7XG4gIHZhciByZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gIHZhciBwcm9wc1dpdGhvdXRSZWY7XG5cbiAgaWYgKCdyZWYnIGluIG5leHRQcm9wcykge1xuICAgIC8vIGByZWZgIGlzIGp1c3QgYSBwcm9wIG5vdywgYnV0IGBmb3J3YXJkUmVmYCBleHBlY3RzIGl0IHRvIG5vdCBhcHBlYXIgaW5cbiAgICAvLyB0aGUgcHJvcHMgb2JqZWN0LiBUaGlzIHVzZWQgdG8gaGFwcGVuIGluIHRoZSBKU1ggcnVudGltZSwgYnV0IG5vdyB3ZSBkb1xuICAgIC8vIGl0IGhlcmUuXG4gICAgcHJvcHNXaXRob3V0UmVmID0ge307XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gbmV4dFByb3BzKSB7XG4gICAgICAvLyBTaW5jZSBgcmVmYCBzaG91bGQgb25seSBhcHBlYXIgaW4gcHJvcHMgdmlhIHRoZSBKU1ggdHJhbnNmb3JtLCB3ZSBjYW5cbiAgICAgIC8vIGFzc3VtZSB0aGF0IHRoaXMgaXMgYSBwbGFpbiBvYmplY3QuIFNvIHdlIGRvbid0IG5lZWQgYVxuICAgICAgLy8gaGFzT3duUHJvcGVydHkgY2hlY2suXG4gICAgICBpZiAoa2V5ICE9PSAncmVmJykge1xuICAgICAgICBwcm9wc1dpdGhvdXRSZWZba2V5XSA9IG5leHRQcm9wc1trZXldO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwcm9wc1dpdGhvdXRSZWYgPSBuZXh0UHJvcHM7XG4gIH0gLy8gVGhlIHJlc3QgaXMgYSBmb3JrIG9mIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50XG5cblxuICB2YXIgbmV4dENoaWxkcmVuO1xuICB2YXIgaGFzSWQ7XG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAge1xuICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIHtcbiAgICBzZXRJc1JlbmRlcmluZyh0cnVlKTtcbiAgICBuZXh0Q2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlciwgcHJvcHNXaXRob3V0UmVmLCByZWYsIHJlbmRlckxhbmVzKTtcbiAgICBoYXNJZCA9IGNoZWNrRGlkUmVuZGVySWRIb29rKCk7XG4gICAgc2V0SXNSZW5kZXJpbmcoZmFsc2UpO1xuICB9XG5cbiAge1xuICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gIH1cblxuICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiAhZGlkUmVjZWl2ZVVwZGF0ZSkge1xuICAgIGJhaWxvdXRIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gIH1cblxuICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSAmJiBoYXNJZCkge1xuICAgIHB1c2hNYXRlcmlhbGl6ZWRUcmVlSWQod29ya0luUHJvZ3Jlc3MpO1xuICB9IC8vIFJlYWN0IERldlRvb2xzIHJlYWRzIHRoaXMgZmxhZy5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBlcmZvcm1lZFdvcms7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVNZW1vQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICB2YXIgdHlwZSA9IENvbXBvbmVudC50eXBlO1xuXG4gICAgaWYgKGlzU2ltcGxlRnVuY3Rpb25Db21wb25lbnQodHlwZSkgJiYgQ29tcG9uZW50LmNvbXBhcmUgPT09IG51bGwgJiYgKCAvLyBTaW1wbGVNZW1vQ29tcG9uZW50IGNvZGVwYXRoIGRvZXNuJ3QgcmVzb2x2ZSBvdXRlciBwcm9wcyBlaXRoZXIuXG4gICAgZGlzYWJsZURlZmF1bHRQcm9wc0V4Y2VwdEZvckNsYXNzZXMgKSkge1xuICAgICAgdmFyIHJlc29sdmVkVHlwZSA9IHR5cGU7XG5cbiAgICAgIHtcbiAgICAgICAgcmVzb2x2ZWRUeXBlID0gcmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nKHR5cGUpO1xuICAgICAgfSAvLyBJZiB0aGlzIGlzIGEgcGxhaW4gZnVuY3Rpb24gY29tcG9uZW50IHdpdGhvdXQgZGVmYXVsdCBwcm9wcyxcbiAgICAgIC8vIGFuZCB3aXRoIG9ubHkgdGhlIGRlZmF1bHQgc2hhbGxvdyBjb21wYXJpc29uLCB3ZSB1cGdyYWRlIGl0XG4gICAgICAvLyB0byBhIFNpbXBsZU1lbW9Db21wb25lbnQgdG8gYWxsb3cgZmFzdCBwYXRoIHVwZGF0ZXMuXG5cblxuICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gU2ltcGxlTWVtb0NvbXBvbmVudDtcbiAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSByZXNvbHZlZFR5cGU7XG5cbiAgICAgIHtcbiAgICAgICAgdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCB0eXBlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlc29sdmVkVHlwZSwgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gY3JlYXRlRmliZXJGcm9tVHlwZUFuZFByb3BzKENvbXBvbmVudC50eXBlLCBudWxsLCBuZXh0UHJvcHMsIHdvcmtJblByb2dyZXNzLCB3b3JrSW5Qcm9ncmVzcy5tb2RlLCByZW5kZXJMYW5lcyk7XG4gICAgY2hpbGQucmVmID0gd29ya0luUHJvZ3Jlc3MucmVmO1xuICAgIGNoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gY2hpbGQ7XG4gICAgcmV0dXJuIGNoaWxkO1xuICB9XG5cbiAgdmFyIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnQuY2hpbGQ7IC8vIFRoaXMgaXMgYWx3YXlzIGV4YWN0bHkgb25lIGNoaWxkXG5cbiAgdmFyIGhhc1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCA9IGNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKTtcblxuICBpZiAoIWhhc1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCkge1xuICAgIC8vIFRoaXMgd2lsbCBiZSB0aGUgcHJvcHMgd2l0aCByZXNvbHZlZCBkZWZhdWx0UHJvcHMsXG4gICAgLy8gdW5saWtlIGN1cnJlbnQubWVtb2l6ZWRQcm9wcyB3aGljaCB3aWxsIGJlIHRoZSB1bnJlc29sdmVkIG9uZXMuXG4gICAgdmFyIHByZXZQcm9wcyA9IGN1cnJlbnRDaGlsZC5tZW1vaXplZFByb3BzOyAvLyBEZWZhdWx0IHRvIHNoYWxsb3cgY29tcGFyaXNvblxuXG4gICAgdmFyIGNvbXBhcmUgPSBDb21wb25lbnQuY29tcGFyZTtcbiAgICBjb21wYXJlID0gY29tcGFyZSAhPT0gbnVsbCA/IGNvbXBhcmUgOiBzaGFsbG93RXF1YWw7XG5cbiAgICBpZiAoY29tcGFyZShwcmV2UHJvcHMsIG5leHRQcm9wcykgJiYgY3VycmVudC5yZWYgPT09IHdvcmtJblByb2dyZXNzLnJlZikge1xuICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICB9XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcbiAgdmFyIG5ld0NoaWxkID0gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudENoaWxkLCBuZXh0UHJvcHMpO1xuICBuZXdDaGlsZC5yZWYgPSB3b3JrSW5Qcm9ncmVzcy5yZWY7XG4gIG5ld0NoaWxkLnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG5ld0NoaWxkO1xuICByZXR1cm4gbmV3Q2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuICAvLyBUT0RPOiBjdXJyZW50IGNhbiBiZSBub24tbnVsbCBoZXJlIGV2ZW4gaWYgdGhlIGNvbXBvbmVudFxuICAvLyBoYXNuJ3QgeWV0IG1vdW50ZWQuIFRoaXMgaGFwcGVucyB3aGVuIHRoZSBpbm5lciByZW5kZXIgc3VzcGVuZHMuXG4gIC8vIFdlJ2xsIG5lZWQgdG8gZmlndXJlIG91dCBpZiB0aGlzIGlzIGZpbmUgb3IgY2FuIGNhdXNlIGlzc3Vlcy5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuXG4gICAgaWYgKHNoYWxsb3dFcXVhbChwcmV2UHJvcHMsIG5leHRQcm9wcykgJiYgY3VycmVudC5yZWYgPT09IHdvcmtJblByb2dyZXNzLnJlZiAmJiAoIC8vIFByZXZlbnQgYmFpbG91dCBpZiB0aGUgaW1wbGVtZW50YXRpb24gY2hhbmdlZCBkdWUgdG8gaG90IHJlbG9hZC5cbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID09PSBjdXJyZW50LnR5cGUgKSkge1xuICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IGZhbHNlOyAvLyBUaGUgcHJvcHMgYXJlIHNoYWxsb3dseSBlcXVhbC4gUmV1c2UgdGhlIHByZXZpb3VzIHByb3BzIG9iamVjdCwgbGlrZSB3ZVxuICAgICAgLy8gd291bGQgZHVyaW5nIGEgbm9ybWFsIGZpYmVyIGJhaWxvdXQuXG4gICAgICAvL1xuICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSBzdHJvbmcgZ3VhcmFudGVlcyB0aGF0IHRoZSBwcm9wcyBvYmplY3QgaXMgcmVmZXJlbnRpYWxseVxuICAgICAgLy8gZXF1YWwgZHVyaW5nIHVwZGF0ZXMgd2hlcmUgd2UgY2FuJ3QgYmFpbCBvdXQgYW55d2F5IOKAlCBsaWtlIGlmIHRoZSBwcm9wc1xuICAgICAgLy8gYXJlIHNoYWxsb3dseSBlcXVhbCwgYnV0IHRoZXJlJ3MgYSBsb2NhbCBzdGF0ZSBvciBjb250ZXh0IHVwZGF0ZSBpbiB0aGVcbiAgICAgIC8vIHNhbWUgYmF0Y2guXG4gICAgICAvL1xuICAgICAgLy8gSG93ZXZlciwgYXMgYSBwcmluY2lwbGUsIHdlIHNob3VsZCBhaW0gdG8gbWFrZSB0aGUgYmVoYXZpb3IgY29uc2lzdGVudFxuICAgICAgLy8gYWNyb3NzIGRpZmZlcmVudCB3YXlzIG9mIG1lbW9pemluZyBhIGNvbXBvbmVudC4gRm9yIGV4YW1wbGUsIFJlYWN0Lm1lbW9cbiAgICAgIC8vIGhhcyBhIGRpZmZlcmVudCBpbnRlcm5hbCBGaWJlciBsYXlvdXQgaWYgeW91IHBhc3MgYSBub3JtYWwgZnVuY3Rpb25cbiAgICAgIC8vIGNvbXBvbmVudCAoU2ltcGxlTWVtb0NvbXBvbmVudCkgdmVyc3VzIGlmIHlvdSBwYXNzIGEgZGlmZmVyZW50IHR5cGVcbiAgICAgIC8vIGxpa2UgZm9yd2FyZFJlZiAoTWVtb0NvbXBvbmVudCkuIEJ1dCB0aGlzIGlzIGFuIGltcGxlbWVudGF0aW9uIGRldGFpbC5cbiAgICAgIC8vIFdyYXBwaW5nIGEgY29tcG9uZW50IGluIGZvcndhcmRSZWYgKG9yIFJlYWN0LmxhenksIGV0Yykgc2hvdWxkbid0XG4gICAgICAvLyBhZmZlY3Qgd2hldGhlciB0aGUgcHJvcHMgb2JqZWN0IGlzIHJldXNlZCBkdXJpbmcgYSBiYWlsb3V0LlxuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBuZXh0UHJvcHMgPSBwcmV2UHJvcHM7XG5cbiAgICAgIGlmICghY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCwgcmVuZGVyTGFuZXMpKSB7XG4gICAgICAgIC8vIFRoZSBwZW5kaW5nIGxhbmVzIHdlcmUgY2xlYXJlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIGJlZ2luV29yay4gV2UncmVcbiAgICAgICAgLy8gYWJvdXQgdG8gYmFpbCBvdXQsIGJ1dCB0aGVyZSBtaWdodCBiZSBvdGhlciBsYW5lcyB0aGF0IHdlcmVuJ3RcbiAgICAgICAgLy8gaW5jbHVkZWQgaW4gdGhlIGN1cnJlbnQgcmVuZGVyLiBVc3VhbGx5LCB0aGUgcHJpb3JpdHkgbGV2ZWwgb2YgdGhlXG4gICAgICAgIC8vIHJlbWFpbmluZyB1cGRhdGVzIGlzIGFjY3VtdWxhdGVkIGR1cmluZyB0aGUgZXZhbHVhdGlvbiBvZiB0aGVcbiAgICAgICAgLy8gY29tcG9uZW50IChpLmUuIHdoZW4gcHJvY2Vzc2luZyB0aGUgdXBkYXRlIHF1ZXVlKS4gQnV0IHNpbmNlIHNpbmNlXG4gICAgICAgIC8vIHdlJ3JlIGJhaWxpbmcgb3V0IGVhcmx5ICp3aXRob3V0KiBldmFsdWF0aW5nIHRoZSBjb21wb25lbnQsIHdlIG5lZWRcbiAgICAgICAgLy8gdG8gYWNjb3VudCBmb3IgaXQgaGVyZSwgdG9vLiBSZXNldCB0byB0aGUgdmFsdWUgb2YgdGhlIGN1cnJlbnQgZmliZXIuXG4gICAgICAgIC8vIE5PVEU6IFRoaXMgb25seSBhcHBsaWVzIHRvIFNpbXBsZU1lbW9Db21wb25lbnQsIG5vdCBNZW1vQ29tcG9uZW50LFxuICAgICAgICAvLyBiZWNhdXNlIGEgTWVtb0NvbXBvbmVudCBmaWJlciBkb2VzIG5vdCBoYXZlIGhvb2tzIG9yIGFuIHVwZGF0ZSBxdWV1ZTtcbiAgICAgICAgLy8gcmF0aGVyLCBpdCB3cmFwcyBhcm91bmQgYW4gaW5uZXIgY29tcG9uZW50LCB3aGljaCBtYXkgb3IgbWF5IG5vdFxuICAgICAgICAvLyBjb250YWlucyBob29rcy5cbiAgICAgICAgLy8gVE9ETzogTW92ZSB0aGUgcmVzZXQgYXQgaW4gYmVnaW5Xb3JrIG91dCBvZiB0aGUgY29tbW9uIHBhdGggc28gdGhhdFxuICAgICAgICAvLyB0aGlzIGlzIG5vIGxvbmdlciBuZWNlc3NhcnkuXG4gICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gY3VycmVudC5sYW5lcztcbiAgICAgICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgIH0gZWxzZSBpZiAoKGN1cnJlbnQuZmxhZ3MgJiBGb3JjZVVwZGF0ZUZvckxlZ2FjeVN1c3BlbnNlKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBvbmx5IGV4aXN0cyBmb3IgbGVnYWN5IG1vZGUuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xOTIxNi5cbiAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIG5leHRQcm9wcywgcmVuZGVyTGFuZXMpO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHZhciBuZXh0SXNEZXRhY2hlZCA9ICh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuX3BlbmRpbmdWaXNpYmlsaXR5ICYgT2Zmc2NyZWVuRGV0YWNoZWQpICE9PSAwO1xuICB2YXIgcHJldlN0YXRlID0gY3VycmVudCAhPT0gbnVsbCA/IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSA6IG51bGw7XG4gIG1hcmtSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuXG4gIGlmIChuZXh0UHJvcHMubW9kZSA9PT0gJ2hpZGRlbicgfHwgZW5hYmxlTGVnYWN5SGlkZGVuICB8fCBuZXh0SXNEZXRhY2hlZCkge1xuICAgIC8vIFJlbmRlcmluZyBhIGhpZGRlbiB0cmVlLlxuICAgIHZhciBkaWRTdXNwZW5kID0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3MkMTtcblxuICAgIGlmIChkaWRTdXNwZW5kKSB7XG4gICAgICAvLyBTb21ldGhpbmcgc3VzcGVuZGVkIGluc2lkZSBhIGhpZGRlbiB0cmVlXG4gICAgICAvLyBJbmNsdWRlIHRoZSBiYXNlIGxhbmVzIGZyb20gdGhlIGxhc3QgcmVuZGVyXG4gICAgICB2YXIgbmV4dEJhc2VMYW5lcyA9IHByZXZTdGF0ZSAhPT0gbnVsbCA/IG1lcmdlTGFuZXMocHJldlN0YXRlLmJhc2VMYW5lcywgcmVuZGVyTGFuZXMpIDogcmVuZGVyTGFuZXM7XG5cbiAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgIC8vIFJlc2V0IHRvIHRoZSBjdXJyZW50IGNoaWxkcmVuXG4gICAgICAgIHZhciBjdXJyZW50Q2hpbGQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7IC8vIFRoZSBjdXJyZW50IHJlbmRlciBzdXNwZW5kZWQsIGJ1dCB0aGVyZSBtYXkgYmUgb3RoZXIgbGFuZXMgd2l0aFxuICAgICAgICAvLyBwZW5kaW5nIHdvcmsuIFdlIGNhbid0IHJlYWQgYGNoaWxkTGFuZXNgIGZyb20gdGhlIGN1cnJlbnQgT2Zmc2NyZWVuXG4gICAgICAgIC8vIGZpYmVyIGJlY2F1c2Ugd2UgcmVzZXQgaXQgd2hlbiBpdCB3YXMgZGVmZXJyZWQ7IGhvd2V2ZXIsIHdlIGNhbiByZWFkXG4gICAgICAgIC8vIHRoZSBwZW5kaW5nIGxhbmVzIGZyb20gdGhlIGNoaWxkIGZpYmVycy5cblxuICAgICAgICB2YXIgY3VycmVudENoaWxkTGFuZXMgPSBOb0xhbmVzO1xuXG4gICAgICAgIHdoaWxlIChjdXJyZW50Q2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICBjdXJyZW50Q2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMobWVyZ2VMYW5lcyhjdXJyZW50Q2hpbGRMYW5lcywgY3VycmVudENoaWxkLmxhbmVzKSwgY3VycmVudENoaWxkLmNoaWxkTGFuZXMpO1xuICAgICAgICAgIGN1cnJlbnRDaGlsZCA9IGN1cnJlbnRDaGlsZC5zaWJsaW5nO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhbmVzV2VKdXN0QXR0ZW1wdGVkID0gbmV4dEJhc2VMYW5lcztcbiAgICAgICAgdmFyIHJlbWFpbmluZ0NoaWxkTGFuZXMgPSByZW1vdmVMYW5lcyhjdXJyZW50Q2hpbGRMYW5lcywgbGFuZXNXZUp1c3RBdHRlbXB0ZWQpO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzID0gcmVtYWluaW5nQ2hpbGRMYW5lcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBOb0xhbmVzO1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZWZlckhpZGRlbk9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dEJhc2VMYW5lcyk7XG4gICAgfVxuXG4gICAgaWYgKCFpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCBPZmZzY3JlZW5MYW5lKSkge1xuICAgICAgLy8gV2UncmUgaGlkZGVuLCBhbmQgd2UncmUgbm90IHJlbmRlcmluZyBhdCBPZmZzY3JlZW4uIFdlIHdpbGwgYmFpbCBvdXRcbiAgICAgIC8vIGFuZCByZXN1bWUgdGhpcyB0cmVlIGxhdGVyLlxuICAgICAgLy8gU2NoZWR1bGUgdGhpcyBmaWJlciB0byByZS1yZW5kZXIgYXQgT2Zmc2NyZWVuIHByaW9yaXR5XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBsYW5lVG9MYW5lcyhPZmZzY3JlZW5MYW5lKTsgLy8gSW5jbHVkZSB0aGUgYmFzZSBsYW5lcyBmcm9tIHRoZSBsYXN0IHJlbmRlclxuXG4gICAgICB2YXIgX25leHRCYXNlTGFuZXMgPSBwcmV2U3RhdGUgIT09IG51bGwgPyBtZXJnZUxhbmVzKHByZXZTdGF0ZS5iYXNlTGFuZXMsIHJlbmRlckxhbmVzKSA6IHJlbmRlckxhbmVzO1xuXG4gICAgICByZXR1cm4gZGVmZXJIaWRkZW5PZmZzY3JlZW5Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIF9uZXh0QmFzZUxhbmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhpcyBpcyB0aGUgc2Vjb25kIHJlbmRlci4gVGhlIHN1cnJvdW5kaW5nIHZpc2libGUgY29udGVudCBoYXMgYWxyZWFkeVxuICAgICAgLy8gY29tbWl0dGVkLiBOb3cgd2UgcmVzdW1lIHJlbmRlcmluZyB0aGUgaGlkZGVuIHRyZWUuXG4gICAgICAvLyBSZW5kZXJpbmcgYXQgb2Zmc2NyZWVuLCBzbyB3ZSBjYW4gY2xlYXIgdGhlIGJhc2UgbGFuZXMuXG4gICAgICB2YXIgX25leHRTdGF0ZSA9IHtcbiAgICAgICAgYmFzZUxhbmVzOiBOb0xhbmVzLFxuICAgICAgICBjYWNoZVBvb2w6IG51bGxcbiAgICAgIH07XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gX25leHRTdGF0ZTtcblxuICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSWYgdGhlIHJlbmRlciB0aGF0IHNwYXduZWQgdGhpcyBvbmUgYWNjZXNzZWQgdGhlIGNhY2hlIHBvb2wsIHJlc3VtZVxuICAgICAgICAvLyB1c2luZyB0aGUgc2FtZSBjYWNoZS4gVW5sZXNzIHRoZSBwYXJlbnQgY2hhbmdlZCwgc2luY2UgdGhhdCBtZWFuc1xuICAgICAgICAvLyB0aGVyZSB3YXMgYSByZWZyZXNoLlxuICAgICAgICB2YXIgcHJldkNhY2hlUG9vbCA9IHByZXZTdGF0ZSAhPT0gbnVsbCA/IHByZXZTdGF0ZS5jYWNoZVBvb2wgOiBudWxsOyAvLyBUT0RPOiBDb25zaWRlciBpZiBhbmQgaG93IE9mZnNjcmVlbiBwcmUtcmVuZGVyaW5nIHNob3VsZFxuICAgICAgICAvLyBiZSBhdHRyaWJ1dGVkIHRvIHRoZSB0cmFuc2l0aW9uIHRoYXQgc3Bhd25lZCBpdFxuXG4gICAgICAgIHB1c2hUcmFuc2l0aW9uKHdvcmtJblByb2dyZXNzLCBwcmV2Q2FjaGVQb29sKTtcbiAgICAgIH0gLy8gUHVzaCB0aGUgbGFuZXMgdGhhdCB3ZXJlIHNraXBwZWQgd2hlbiB3ZSBiYWlsZWQgb3V0LlxuXG5cbiAgICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgcHVzaEhpZGRlbkNvbnRleHQod29ya0luUHJvZ3Jlc3MsIHByZXZTdGF0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXVzZUhpZGRlbkNvbnRleHRPblN0YWNrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cblxuICAgICAgcHVzaE9mZnNjcmVlblN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFJlbmRlcmluZyBhIHZpc2libGUgdHJlZS5cbiAgICBpZiAocHJldlN0YXRlICE9PSBudWxsKSB7XG4gICAgICAvLyBXZSdyZSBnb2luZyBmcm9tIGhpZGRlbiAtPiB2aXNpYmxlLlxuICAgICAgdmFyIF9wcmV2Q2FjaGVQb29sID0gbnVsbDtcblxuICAgICAge1xuICAgICAgICAvLyBJZiB0aGUgcmVuZGVyIHRoYXQgc3Bhd25lZCB0aGlzIG9uZSBhY2Nlc3NlZCB0aGUgY2FjaGUgcG9vbCwgcmVzdW1lXG4gICAgICAgIC8vIHVzaW5nIHRoZSBzYW1lIGNhY2hlLiBVbmxlc3MgdGhlIHBhcmVudCBjaGFuZ2VkLCBzaW5jZSB0aGF0IG1lYW5zXG4gICAgICAgIC8vIHRoZXJlIHdhcyBhIHJlZnJlc2guXG4gICAgICAgIF9wcmV2Q2FjaGVQb29sID0gcHJldlN0YXRlLmNhY2hlUG9vbDtcbiAgICAgIH1cblxuICAgICAgcHVzaFRyYW5zaXRpb24od29ya0luUHJvZ3Jlc3MsIF9wcmV2Q2FjaGVQb29sKTsgLy8gUHVzaCB0aGUgbGFuZXMgdGhhdCB3ZXJlIHNraXBwZWQgd2hlbiB3ZSBiYWlsZWQgb3V0LlxuXG4gICAgICBwdXNoSGlkZGVuQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcHJldlN0YXRlKTtcbiAgICAgIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyk7IC8vIFNpbmNlIHdlJ3JlIG5vdCBoaWRkZW4gYW55bW9yZSwgcmVzZXQgdGhlIHN0YXRlXG5cbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSB3ZXJlbid0IHByZXZpb3VzbHkgaGlkZGVuLCBhbmQgd2Ugc3RpbGwgYXJlbid0LCBzbyB0aGVyZSdzIG5vdGhpbmdcbiAgICAgIC8vIHNwZWNpYWwgdG8gZG8uIE5lZWQgdG8gcHVzaCB0byB0aGUgc3RhY2sgcmVnYXJkbGVzcywgdGhvdWdoLCB0byBhdm9pZFxuICAgICAgLy8gYSBwdXNoL3BvcCBtaXNhbGlnbm1lbnQuXG4gICAgICB7XG4gICAgICAgIC8vIElmIHRoZSByZW5kZXIgdGhhdCBzcGF3bmVkIHRoaXMgb25lIGFjY2Vzc2VkIHRoZSBjYWNoZSBwb29sLCByZXN1bWVcbiAgICAgICAgLy8gdXNpbmcgdGhlIHNhbWUgY2FjaGUuIFVubGVzcyB0aGUgcGFyZW50IGNoYW5nZWQsIHNpbmNlIHRoYXQgbWVhbnNcbiAgICAgICAgLy8gdGhlcmUgd2FzIGEgcmVmcmVzaC5cbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICBwdXNoVHJhbnNpdGlvbih3b3JrSW5Qcm9ncmVzcywgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gV2UncmUgYWJvdXQgdG8gYmFpbCBvdXQsIGJ1dCB3ZSBuZWVkIHRvIHB1c2ggdGhpcyB0byB0aGUgc3RhY2sgYW55d2F5XG4gICAgICAvLyB0byBhdm9pZCBhIHB1c2gvcG9wIG1pc2FsaWdubWVudC5cblxuXG4gICAgICByZXVzZUhpZGRlbkNvbnRleHRPblN0YWNrKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICB9XG5cbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIGRlZmVySGlkZGVuT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0QmFzZUxhbmVzLCByZW5kZXJMYW5lcykge1xuICB2YXIgbmV4dFN0YXRlID0ge1xuICAgIGJhc2VMYW5lczogbmV4dEJhc2VMYW5lcyxcbiAgICAvLyBTYXZlIHRoZSBjYWNoZSBwb29sIHNvIHdlIGNhbiByZXN1bWUgbGF0ZXIuXG4gICAgY2FjaGVQb29sOiBnZXRPZmZzY3JlZW5EZWZlcnJlZENhY2hlKCkgXG4gIH07XG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBuZXh0U3RhdGU7XG5cbiAge1xuICAgIC8vIHB1c2ggdGhlIGNhY2hlIHBvb2wgZXZlbiB0aG91Z2ggd2UncmUgZ29pbmcgdG8gYmFpbCBvdXRcbiAgICAvLyBiZWNhdXNlIG90aGVyd2lzZSB0aGVyZSdkIGJlIGEgY29udGV4dCBtaXNtYXRjaFxuICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICBwdXNoVHJhbnNpdGlvbih3b3JrSW5Qcm9ncmVzcywgbnVsbCk7XG4gICAgfVxuICB9IC8vIFdlJ3JlIGFib3V0IHRvIGJhaWwgb3V0LCBidXQgd2UgbmVlZCB0byBwdXNoIHRoaXMgdG8gdGhlIHN0YWNrIGFueXdheVxuICAvLyB0byBhdm9pZCBhIHB1c2gvcG9wIG1pc2FsaWdubWVudC5cblxuXG4gIHJldXNlSGlkZGVuQ29udGV4dE9uU3RhY2sod29ya0luUHJvZ3Jlc3MpO1xuICBwdXNoT2Zmc2NyZWVuU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcblxuICByZXR1cm4gbnVsbDtcbn0gLy8gTm90ZTogVGhlc2UgaGFwcGVuIHRvIGhhdmUgaWRlbnRpY2FsIGJlZ2luIHBoYXNlcywgZm9yIG5vdy4gV2Ugc2hvdWxkbid0IGhvbGRcblxuZnVuY3Rpb24gdXBkYXRlQ2FjaGVDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG5cbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgdmFyIHBhcmVudENhY2hlID0gcmVhZENvbnRleHQoQ2FjaGVDb250ZXh0KTtcblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIC8vIEluaXRpYWwgbW91bnQuIFJlcXVlc3QgYSBmcmVzaCBjYWNoZSBmcm9tIHRoZSBwb29sLlxuICAgIHZhciBmcmVzaENhY2hlID0gcmVxdWVzdENhY2hlRnJvbVBvb2wocmVuZGVyTGFuZXMpO1xuICAgIHZhciBpbml0aWFsU3RhdGUgPSB7XG4gICAgICBwYXJlbnQ6IHBhcmVudENhY2hlLFxuICAgICAgY2FjaGU6IGZyZXNoQ2FjaGVcbiAgICB9O1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzKTtcbiAgICBwdXNoQ2FjaGVQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgZnJlc2hDYWNoZSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2hlY2sgZm9yIHVwZGF0ZXNcbiAgICBpZiAoaW5jbHVkZXNTb21lTGFuZShjdXJyZW50LmxhbmVzLCByZW5kZXJMYW5lcykpIHtcbiAgICAgIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcHJvY2Vzc1VwZGF0ZVF1ZXVlKHdvcmtJblByb2dyZXNzLCBudWxsLCBudWxsLCByZW5kZXJMYW5lcyk7XG4gICAgICBzdXNwZW5kSWZVcGRhdGVSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uKCk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICB2YXIgbmV4dFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTsgLy8gQ29tcGFyZSB0aGUgbmV3IHBhcmVudCBjYWNoZSB0byB0aGUgcHJldmlvdXMgdG8gc2VlIGRldGVjdCB0aGVyZSB3YXNcbiAgICAvLyBhIHJlZnJlc2guXG5cbiAgICBpZiAocHJldlN0YXRlLnBhcmVudCAhPT0gcGFyZW50Q2FjaGUpIHtcbiAgICAgIC8vIFJlZnJlc2ggaW4gcGFyZW50LiBVcGRhdGUgdGhlIHBhcmVudC5cbiAgICAgIHZhciBkZXJpdmVkU3RhdGUgPSB7XG4gICAgICAgIHBhcmVudDogcGFyZW50Q2FjaGUsXG4gICAgICAgIGNhY2hlOiBwYXJlbnRDYWNoZVxuICAgICAgfTsgLy8gQ29waWVkIGZyb20gZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzIGltcGxlbWVudGF0aW9uLiBPbmNlIHRoZSB1cGRhdGVcbiAgICAgIC8vIHF1ZXVlIGlzIGVtcHR5LCBwZXJzaXN0IHRoZSBkZXJpdmVkIHN0YXRlIG9udG8gdGhlIGJhc2Ugc3RhdGUuXG5cbiAgICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBkZXJpdmVkU3RhdGU7XG5cbiAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9PT0gTm9MYW5lcykge1xuICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZTtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHVwZGF0ZVF1ZXVlLmJhc2VTdGF0ZSA9IGRlcml2ZWRTdGF0ZTtcbiAgICAgIH1cblxuICAgICAgcHVzaENhY2hlUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIHBhcmVudENhY2hlKTsgLy8gTm8gbmVlZCB0byBwcm9wYWdhdGUgYSBjb250ZXh0IGNoYW5nZSBiZWNhdXNlIHRoZSByZWZyZXNoZWQgcGFyZW50XG4gICAgICAvLyBhbHJlYWR5IGRpZC5cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVGhlIHBhcmVudCBkaWRuJ3QgcmVmcmVzaC4gTm93IGNoZWNrIGlmIHRoaXMgY2FjaGUgZGlkLlxuICAgICAgdmFyIG5leHRDYWNoZSA9IG5leHRTdGF0ZS5jYWNoZTtcbiAgICAgIHB1c2hDYWNoZVByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBuZXh0Q2FjaGUpO1xuXG4gICAgICBpZiAobmV4dENhY2hlICE9PSBwcmV2U3RhdGUuY2FjaGUpIHtcbiAgICAgICAgLy8gVGhpcyBjYWNoZSByZWZyZXNoZWQuIFByb3BhZ2F0ZSBhIGNvbnRleHQgY2hhbmdlLlxuICAgICAgICBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBDYWNoZUNvbnRleHQsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgbmV4dENoaWxkcmVuID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLmNoaWxkcmVuO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn0gLy8gVGhpcyBzaG91bGQgb25seSBiZSBjYWxsZWQgaWYgdGhlIG5hbWUgY2hhbmdlc1xuXG5mdW5jdGlvbiB1cGRhdGVGcmFnbWVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZU1vZGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMuY2hpbGRyZW47XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVQcm9maWxlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAge1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcblxuICAgIHtcbiAgICAgIC8vIFJlc2V0IGVmZmVjdCBkdXJhdGlvbnMgZm9yIHRoZSBuZXh0IGV2ZW50dWFsIGVmZmVjdCBwaGFzZS5cbiAgICAgIC8vIFRoZXNlIGFyZSByZXNldCBkdXJpbmcgcmVuZGVyIHRvIGFsbG93IHRoZSBEZXZUb29scyBjb21taXQgaG9vayBhIGNoYW5jZSB0byByZWFkIHRoZW0sXG4gICAgICB2YXIgc3RhdGVOb2RlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uID0gMDtcbiAgICAgIHN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSAwO1xuICAgIH1cbiAgfVxuXG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSB7XG4gIC8vIFRPRE86IENoZWNrIHByb3BzLnJlZiBpbnN0ZWFkIG9mIGZpYmVyLnJlZiB3aGVuIGVuYWJsZVJlZkFzUHJvcCBpcyBvbi5cbiAgdmFyIHJlZiA9IHdvcmtJblByb2dyZXNzLnJlZjtcblxuICBpZiAocmVmID09PSBudWxsKSB7XG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIC8vIFNjaGVkdWxlIGEgUmVmIGVmZmVjdFxuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUmVmIHwgUmVmU3RhdGljO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAodHlwZW9mIHJlZiAhPT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgcmVmICE9PSAnb2JqZWN0Jykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCByZWYgdG8gYmUgYSBmdW5jdGlvbiwgYW4gb2JqZWN0IHJldHVybmVkIGJ5IFJlYWN0LmNyZWF0ZVJlZigpLCBvciB1bmRlZmluZWQvbnVsbC4nKTtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50LnJlZiAhPT0gcmVmKSB7XG5cblxuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUmVmIHwgUmVmU3RhdGljO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVGdW5jdGlvbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKSB7XG4gIHtcbiAgICBpZiAoQ29tcG9uZW50LnByb3RvdHlwZSAmJiB0eXBlb2YgQ29tcG9uZW50LnByb3RvdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKFwiVGhlIDwlcyAvPiBjb21wb25lbnQgYXBwZWFycyB0byBoYXZlIGEgcmVuZGVyIG1ldGhvZCwgYnV0IGRvZXNuJ3QgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudC4gXCIgKyAnVGhpcyBpcyBsaWtlbHkgdG8gY2F1c2UgZXJyb3JzLiBDaGFuZ2UgJXMgdG8gZXh0ZW5kIFJlYWN0LkNvbXBvbmVudCBpbnN0ZWFkLicsIGNvbXBvbmVudE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEJhZENsYXNzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgIFJlYWN0U3RyaWN0TW9kZVdhcm5pbmdzLnJlY29yZExlZ2FjeUNvbnRleHRXYXJuaW5nKHdvcmtJblByb2dyZXNzLCBudWxsKTtcbiAgICB9XG5cbiAgICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgLy8gU29tZSB2YWxpZGF0aW9ucyB3ZXJlIHByZXZpb3VzbHkgZG9uZSBpbiBtb3VudEluZGV0ZXJtaW5hdGVDb21wb25lbnQgaG93ZXZlciBhbmQgYXJlIG5vdyBydW5cbiAgICAgIC8vIGluIHVwZGF0ZUZ1bnRpb25Db21wb25lbnQgYnV0IG9ubHkgb24gbW91bnRcbiAgICAgIHZhbGlkYXRlRnVuY3Rpb25Db21wb25lbnRJbkRldih3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudHlwZSk7XG5cbiAgICAgIGlmIChDb21wb25lbnQuY29udGV4dFR5cGVzKSB7XG4gICAgICAgIGVycm9yKCclcyB1c2VzIHRoZSBsZWdhY3kgY29udGV4dFR5cGVzIEFQSSB3aGljaCB3YXMgcmVtb3ZlZCBpbiBSZWFjdCAxOS4gJyArICdVc2UgUmVhY3QuY3JlYXRlQ29udGV4dCgpIHdpdGggUmVhY3QudXNlQ29udGV4dCgpIGluc3RlYWQuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgJ1Vua25vd24nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgY29udGV4dDtcblxuICB2YXIgbmV4dENoaWxkcmVuO1xuICB2YXIgaGFzSWQ7XG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAge1xuICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIHtcbiAgICBzZXRJc1JlbmRlcmluZyh0cnVlKTtcbiAgICBuZXh0Q2hpbGRyZW4gPSByZW5kZXJXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCBjb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gICAgaGFzSWQgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuICAgIHNldElzUmVuZGVyaW5nKGZhbHNlKTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICB9XG5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFJlY2VpdmVVcGRhdGUpIHtcbiAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgaWYgKGdldElzSHlkcmF0aW5nKCkgJiYgaGFzSWQpIHtcbiAgICBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTtcbiAgfSAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG5cblxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQZXJmb3JtZWRXb3JrO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gcmVwbGF5RnVuY3Rpb25Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgQ29tcG9uZW50LCBzZWNvbmRBcmcsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byByZXBsYXkgYSBjb21wb25lbnQgdGhhdCBwcmV2aW91c2x5IHN1c3BlbmRlZCxcbiAgLy8gYWZ0ZXIgaXRzIGRhdGEgcmVzb2x2ZXMuIEl0J3MgYSBzaW1wbGlmaWVkIHZlcnNpb24gb2ZcbiAgLy8gdXBkYXRlRnVuY3Rpb25Db21wb25lbnQgdGhhdCByZXVzZXMgdGhlIGhvb2tzIGZyb20gdGhlIHByZXZpb3VzIGF0dGVtcHQuXG4gIHByZXBhcmVUb1JlYWRDb250ZXh0KHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAge1xuICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdGFydGVkKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIHZhciBuZXh0Q2hpbGRyZW4gPSByZXBsYXlTdXNwZW5kZWRDb21wb25lbnRXaXRoSG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCBzZWNvbmRBcmcpO1xuICB2YXIgaGFzSWQgPSBjaGVja0RpZFJlbmRlcklkSG9vaygpO1xuXG4gIHtcbiAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuICB9XG5cbiAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgIWRpZFJlY2VpdmVVcGRhdGUpIHtcbiAgICBiYWlsb3V0SG9va3MoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICByZXR1cm4gYmFpbG91dE9uQWxyZWFkeUZpbmlzaGVkV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgaWYgKGdldElzSHlkcmF0aW5nKCkgJiYgaGFzSWQpIHtcbiAgICBwdXNoTWF0ZXJpYWxpemVkVHJlZUlkKHdvcmtJblByb2dyZXNzKTtcbiAgfSAvLyBSZWFjdCBEZXZUb29scyByZWFkcyB0aGlzIGZsYWcuXG5cblxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBQZXJmb3JtZWRXb3JrO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcykge1xuICB7XG4gICAgLy8gVGhpcyBpcyB1c2VkIGJ5IERldlRvb2xzIHRvIGZvcmNlIGEgYm91bmRhcnkgdG8gZXJyb3IuXG4gICAgc3dpdGNoIChzaG91bGRFcnJvcih3b3JrSW5Qcm9ncmVzcykpIHtcbiAgICAgIGNhc2UgZmFsc2U6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2luc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICAgICAgICAgIHZhciBjdG9yID0gd29ya0luUHJvZ3Jlc3MudHlwZTsgLy8gVE9ETyBUaGlzIHdheSBvZiByZXNldHRpbmcgdGhlIGVycm9yIGJvdW5kYXJ5IHN0YXRlIGlzIGEgaGFjay5cbiAgICAgICAgICAvLyBJcyB0aGVyZSBhIGJldHRlciB3YXkgdG8gZG8gdGhpcz9cblxuICAgICAgICAgIHZhciB0ZW1wSW5zdGFuY2UgPSBuZXcgY3Rvcih3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzLCBfaW5zdGFuY2UuY29udGV4dCk7XG4gICAgICAgICAgdmFyIHN0YXRlID0gdGVtcEluc3RhbmNlLnN0YXRlO1xuXG4gICAgICAgICAgX2luc3RhbmNlLnVwZGF0ZXIuZW5xdWV1ZVNldFN0YXRlKF9pbnN0YW5jZSwgc3RhdGUsIG51bGwpO1xuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSB0cnVlOlxuICAgICAgICB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTaG91bGRDYXB0dXJlOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuXG4gICAgICAgICAgdmFyIGVycm9yJDEgPSBuZXcgRXJyb3IoJ1NpbXVsYXRlZCBlcnJvciBjb21pbmcgZnJvbSBEZXZUb29scycpO1xuICAgICAgICAgIHZhciBsYW5lID0gcGlja0FyYml0cmFyeUxhbmUocmVuZGVyTGFuZXMpO1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gbWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzcy5sYW5lcywgbGFuZSk7IC8vIFNjaGVkdWxlIHRoZSBlcnJvciBib3VuZGFyeSB0byByZS1yZW5kZXIgdXNpbmcgdXBkYXRlZCBzdGF0ZVxuXG4gICAgICAgICAgdmFyIHJvb3QgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTtcblxuICAgICAgICAgIGlmIChyb290ID09PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIGEgd29yay1pbi1wcm9ncmVzcyByb290LiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShsYW5lKTtcbiAgICAgICAgICBpbml0aWFsaXplQ2xhc3NFcnJvclVwZGF0ZSh1cGRhdGUsIHJvb3QsIHdvcmtJblByb2dyZXNzLCBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihlcnJvciQxLCB3b3JrSW5Qcm9ncmVzcykpO1xuICAgICAgICAgIGVucXVldWVDYXB0dXJlZFVwZGF0ZSh3b3JrSW5Qcm9ncmVzcywgdXBkYXRlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgfSAvLyBQdXNoIGNvbnRleHQgcHJvdmlkZXJzIGVhcmx5IHRvIHByZXZlbnQgY29udGV4dCBzdGFjayBtaXNtYXRjaGVzLlxuICAvLyBEdXJpbmcgbW91bnRpbmcgd2UgZG9uJ3Qga25vdyB0aGUgY2hpbGQgY29udGV4dCB5ZXQgYXMgdGhlIGluc3RhbmNlIGRvZXNuJ3QgZXhpc3QuXG4gIC8vIFdlIHdpbGwgaW52YWxpZGF0ZSB0aGUgY2hpbGQgY29udGV4dCBpbiBmaW5pc2hDbGFzc0NvbXBvbmVudCgpIHJpZ2h0IGFmdGVyIHJlbmRlcmluZy5cblxuXG4gIHZhciBoYXNDb250ZXh0O1xuXG4gIGlmIChpc0NvbnRleHRQcm92aWRlcigpKSB7XG4gICAgaGFzQ29udGV4dCA9IHRydWU7XG4gIH0gZWxzZSB7XG4gICAgaGFzQ29udGV4dCA9IGZhbHNlO1xuICB9XG5cbiAgcHJlcGFyZVRvUmVhZENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgdmFyIGluc3RhbmNlID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuICB2YXIgc2hvdWxkVXBkYXRlO1xuXG4gIGlmIChpbnN0YW5jZSA9PT0gbnVsbCkge1xuXG4gICAgY29uc3RydWN0Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMpO1xuICAgIG1vdW50Q2xhc3NJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICBzaG91bGRVcGRhdGUgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBJbiBhIHJlc3VtZSwgd2UnbGwgYWxyZWFkeSBoYXZlIGFuIGluc3RhbmNlIHdlIGNhbiByZXVzZS5cbiAgICBzaG91bGRVcGRhdGUgPSByZXN1bWVNb3VudENsYXNzSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgbmV4dFByb3BzLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgc2hvdWxkVXBkYXRlID0gdXBkYXRlQ2xhc3NJbnN0YW5jZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgQ29tcG9uZW50LCBuZXh0UHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHZhciBuZXh0VW5pdE9mV29yayA9IGZpbmlzaENsYXNzQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHNob3VsZFVwZGF0ZSwgaGFzQ29udGV4dCwgcmVuZGVyTGFuZXMpO1xuXG4gIHtcbiAgICB2YXIgaW5zdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcblxuICAgIGlmIChzaG91bGRVcGRhdGUgJiYgaW5zdC5wcm9wcyAhPT0gbmV4dFByb3BzKSB7XG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgZXJyb3IoJ0l0IGxvb2tzIGxpa2UgJXMgaXMgcmVhc3NpZ25pbmcgaXRzIG93biBgdGhpcy5wcm9wc2Agd2hpbGUgcmVuZGVyaW5nLiAnICsgJ1RoaXMgaXMgbm90IHN1cHBvcnRlZCBhbmQgY2FuIGxlYWQgdG8gY29uZnVzaW5nIGJ1Z3MuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcih3b3JrSW5Qcm9ncmVzcykgfHwgJ2EgY29tcG9uZW50Jyk7XG4gICAgICB9XG5cbiAgICAgIGRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXh0VW5pdE9mV29yaztcbn1cblxuZnVuY3Rpb24gZmluaXNoQ2xhc3NDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgc2hvdWxkVXBkYXRlLCBoYXNDb250ZXh0LCByZW5kZXJMYW5lcykge1xuICAvLyBSZWZzIHNob3VsZCB1cGRhdGUgZXZlbiBpZiBzaG91bGRDb21wb25lbnRVcGRhdGUgcmV0dXJucyBmYWxzZVxuICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgdmFyIGRpZENhcHR1cmVFcnJvciA9ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzJDE7XG5cbiAgaWYgKCFzaG91bGRVcGRhdGUgJiYgIWRpZENhcHR1cmVFcnJvcikge1xuXG4gICAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHZhciBpbnN0YW5jZSA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTsgLy8gUmVyZW5kZXJcblxuICB7XG4gICAgc2V0Q3VycmVudEZpYmVyKHdvcmtJblByb2dyZXNzKTtcbiAgfVxuXG4gIHZhciBuZXh0Q2hpbGRyZW47XG5cbiAgaWYgKGRpZENhcHR1cmVFcnJvciAmJiB0eXBlb2YgQ29tcG9uZW50LmdldERlcml2ZWRTdGF0ZUZyb21FcnJvciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIElmIHdlIGNhcHR1cmVkIGFuIGVycm9yLCBidXQgZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIGlzIG5vdCBkZWZpbmVkLFxuICAgIC8vIHVubW91bnQgYWxsIHRoZSBjaGlsZHJlbi4gY29tcG9uZW50RGlkQ2F0Y2ggd2lsbCBzY2hlZHVsZSBhbiB1cGRhdGUgdG9cbiAgICAvLyByZS1yZW5kZXIgYSBmYWxsYmFjay4gVGhpcyBpcyB0ZW1wb3JhcnkgdW50aWwgd2UgbWlncmF0ZSBldmVyeW9uZSB0b1xuICAgIC8vIHRoZSBuZXcgQVBJLlxuICAgIC8vIFRPRE86IFdhcm4gaW4gYSBmdXR1cmUgcmVsZWFzZS5cbiAgICBuZXh0Q2hpbGRyZW4gPSBudWxsO1xuXG4gICAge1xuICAgICAgc3RvcFByb2ZpbGVyVGltZXJJZlJ1bm5pbmcoKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAge1xuICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHtcbiAgICAgIHNldElzUmVuZGVyaW5nKHRydWUpO1xuICAgICAgbmV4dENoaWxkcmVuID0gaW5zdGFuY2UucmVuZGVyKCk7XG5cbiAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgU3RyaWN0TGVnYWN5TW9kZSkge1xuICAgICAgICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGluc3RhbmNlLnJlbmRlcigpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIHNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzKGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBzZXRJc1JlbmRlcmluZyhmYWxzZSk7XG4gICAgfVxuXG4gICAge1xuICAgICAgbWFya0NvbXBvbmVudFJlbmRlclN0b3BwZWQoKTtcbiAgICB9XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcblxuICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBkaWRDYXB0dXJlRXJyb3IpIHtcbiAgICAvLyBJZiB3ZSdyZSByZWNvdmVyaW5nIGZyb20gYW4gZXJyb3IsIHJlY29uY2lsZSB3aXRob3V0IHJldXNpbmcgYW55IG9mXG4gICAgLy8gdGhlIGV4aXN0aW5nIGNoaWxkcmVuLiBDb25jZXB0dWFsbHksIHRoZSBub3JtYWwgY2hpbGRyZW4gYW5kIHRoZSBjaGlsZHJlblxuICAgIC8vIHRoYXQgYXJlIHNob3duIG9uIGVycm9yIGFyZSB0d28gZGlmZmVyZW50IHNldHMsIHNvIHdlIHNob3VsZG4ndCByZXVzZVxuICAgIC8vIG5vcm1hbCBjaGlsZHJlbiBldmVuIGlmIHRoZWlyIGlkZW50aXRpZXMgbWF0Y2guXG4gICAgZm9yY2VVbm1vdW50Q3VycmVudEFuZFJlY29uY2lsZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICB9IC8vIE1lbW9pemUgc3RhdGUgdXNpbmcgdGhlIHZhbHVlcyB3ZSBqdXN0IHVzZWQgdG8gcmVuZGVyLlxuICAvLyBUT0RPOiBSZXN0cnVjdHVyZSBzbyB3ZSBuZXZlciByZWFkIHZhbHVlcyBmcm9tIHRoZSBpbnN0YW5jZS5cblxuXG4gIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBpbnN0YW5jZS5zdGF0ZTsgLy8gVGhlIGNvbnRleHQgbWlnaHQgaGF2ZSBjaGFuZ2VkIHNvIHdlIG5lZWQgdG8gcmVjYWxjdWxhdGUgaXQuXG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKSB7XG4gIHZhciByb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gIHB1c2hIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzLCByb290LmNvbnRhaW5lckluZm8pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVIb3N0Um9vdChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgcHVzaEhvc3RSb290Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nob3VsZCBoYXZlIGEgY3VycmVudCBmaWJlci4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgfVxuXG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBwcmV2U3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuICB2YXIgcHJldkNoaWxkcmVuID0gcHJldlN0YXRlLmVsZW1lbnQ7XG4gIGNsb25lVXBkYXRlUXVldWUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICBwcm9jZXNzVXBkYXRlUXVldWUod29ya0luUHJvZ3Jlc3MsIG5leHRQcm9wcywgbnVsbCwgcmVuZGVyTGFuZXMpO1xuICB2YXIgbmV4dFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICB7XG4gICAgdmFyIG5leHRDYWNoZSA9IG5leHRTdGF0ZS5jYWNoZTtcbiAgICBwdXNoQ2FjaGVQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgbmV4dENhY2hlKTtcblxuICAgIGlmIChuZXh0Q2FjaGUgIT09IHByZXZTdGF0ZS5jYWNoZSkge1xuICAgICAgLy8gVGhlIHJvb3QgY2FjaGUgcmVmcmVzaGVkLlxuICAgICAgcHJvcGFnYXRlQ29udGV4dENoYW5nZSh3b3JrSW5Qcm9ncmVzcywgQ2FjaGVDb250ZXh0LCByZW5kZXJMYW5lcyk7XG4gICAgfVxuICB9IC8vIFRoaXMgd291bGQgaWRlYWxseSBnbyBpbnNpZGUgcHJvY2Vzc1VwZGF0ZVF1ZXVlLCBidXQgYmVjYXVzZSBpdCBzdXNwZW5kcyxcbiAgLy8gaXQgbmVlZHMgdG8gaGFwcGVuIGFmdGVyIHRoZSBgcHVzaENhY2hlUHJvdmlkZXJgIGNhbGwgYWJvdmUgdG8gYXZvaWQgYVxuICAvLyBjb250ZXh0IHN0YWNrIG1pc21hdGNoLiBBIGJpdCB1bmZvcnR1bmF0ZS5cblxuXG4gIHN1c3BlbmRJZlVwZGF0ZVJlYWRGcm9tRW50YW5nbGVkQXN5bmNBY3Rpb24oKTsgLy8gQ2F1dGlvbjogUmVhY3QgRGV2VG9vbHMgY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcm9wZXJ0eVxuICAvLyBiZWluZyBjYWxsZWQgXCJlbGVtZW50XCIuXG5cbiAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRTdGF0ZS5lbGVtZW50O1xuXG4gIGlmIChzdXBwb3J0c0h5ZHJhdGlvbiAmJiBwcmV2U3RhdGUuaXNEZWh5ZHJhdGVkKSB7XG4gICAgLy8gVGhpcyBpcyBhIGh5ZHJhdGlvbiByb290IHdob3NlIHNoZWxsIGhhcyBub3QgeWV0IGh5ZHJhdGVkLiBXZSBzaG91bGRcbiAgICAvLyBhdHRlbXB0IHRvIGh5ZHJhdGUuXG4gICAgLy8gRmxpcCBpc0RlaHlkcmF0ZWQgdG8gZmFsc2UgdG8gaW5kaWNhdGUgdGhhdCB3aGVuIHRoaXMgcmVuZGVyXG4gICAgLy8gZmluaXNoZXMsIHRoZSByb290IHdpbGwgbm8gbG9uZ2VyIGJlIGRlaHlkcmF0ZWQuXG4gICAgdmFyIG92ZXJyaWRlU3RhdGUgPSB7XG4gICAgICBlbGVtZW50OiBuZXh0Q2hpbGRyZW4sXG4gICAgICBpc0RlaHlkcmF0ZWQ6IGZhbHNlLFxuICAgICAgY2FjaGU6IG5leHRTdGF0ZS5jYWNoZVxuICAgIH07XG4gICAgdmFyIHVwZGF0ZVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7IC8vIGBiYXNlU3RhdGVgIGNhbiBhbHdheXMgYmUgdGhlIGxhc3Qgc3RhdGUgYmVjYXVzZSB0aGUgcm9vdCBkb2Vzbid0XG4gICAgLy8gaGF2ZSByZWR1Y2VyIGZ1bmN0aW9ucyBzbyBpdCBkb2Vzbid0IG5lZWQgcmViYXNpbmcuXG5cbiAgICB1cGRhdGVRdWV1ZS5iYXNlU3RhdGUgPSBvdmVycmlkZVN0YXRlO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUgPSBvdmVycmlkZVN0YXRlO1xuXG4gICAgaWYgKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRm9yY2VDbGllbnRSZW5kZXIpIHtcbiAgICAgIC8vIFNvbWV0aGluZyBlcnJvcmVkIGR1cmluZyBhIHByZXZpb3VzIGF0dGVtcHQgdG8gaHlkcmF0ZSB0aGUgc2hlbGwsIHNvIHdlXG4gICAgICAvLyBmb3JjZWQgYSBjbGllbnQgcmVuZGVyLiBXZSBzaG91bGQgaGF2ZSBhIHJlY292ZXJhYmxlIGVycm9yIGFscmVhZHkgc2NoZWR1bGVkLlxuICAgICAgcmV0dXJuIG1vdW50SG9zdFJvb3RXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICB9IGVsc2UgaWYgKG5leHRDaGlsZHJlbiAhPT0gcHJldkNoaWxkcmVuKSB7XG4gICAgICB2YXIgcmVjb3ZlcmFibGVFcnJvciA9IGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKG5ldyBFcnJvcignVGhpcyByb290IHJlY2VpdmVkIGFuIGVhcmx5IHVwZGF0ZSwgYmVmb3JlIGFueXRoaW5nIHdhcyBhYmxlICcgKyAnaHlkcmF0ZS4gU3dpdGNoZWQgdGhlIGVudGlyZSByb290IHRvIGNsaWVudCByZW5kZXJpbmcuJyksIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHF1ZXVlSHlkcmF0aW9uRXJyb3IocmVjb3ZlcmFibGVFcnJvcik7XG4gICAgICByZXR1cm4gbW91bnRIb3N0Um9vdFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaGUgb3V0ZXJtb3N0IHNoZWxsIGhhcyBub3QgaHlkcmF0ZWQgeWV0LiBTdGFydCBoeWRyYXRpbmcuXG4gICAgICBlbnRlckh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHZhciBjaGlsZCA9IG1vdW50Q2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIG51bGwsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjaGlsZDtcbiAgICAgIHZhciBub2RlID0gY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgIC8vIE1hcmsgZWFjaCBjaGlsZCBhcyBoeWRyYXRpbmcuIFRoaXMgaXMgYSBmYXN0IHBhdGggdG8ga25vdyB3aGV0aGVyIHRoaXNcbiAgICAgICAgLy8gdHJlZSBpcyBwYXJ0IG9mIGEgaHlkcmF0aW5nIHRyZWUuIFRoaXMgaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgYSBjaGlsZFxuICAgICAgICAvLyBub2RlIGhhcyBmdWxseSBtb3VudGVkIHlldCwgYW5kIGZvciBzY2hlZHVsaW5nIGV2ZW50IHJlcGxheWluZy5cbiAgICAgICAgLy8gQ29uY2VwdHVhbGx5IHRoaXMgaXMgc2ltaWxhciB0byBQbGFjZW1lbnQgaW4gdGhhdCBhIG5ldyBzdWJ0cmVlIGlzXG4gICAgICAgIC8vIGluc2VydGVkIGludG8gdGhlIFJlYWN0IHRyZWUgaGVyZS4gSXQganVzdCBoYXBwZW5zIHRvIG5vdCBuZWVkIERPTVxuICAgICAgICAvLyBtdXRhdGlvbnMgYmVjYXVzZSBpdCBhbHJlYWR5IGV4aXN0cy5cbiAgICAgICAgbm9kZS5mbGFncyA9IG5vZGUuZmxhZ3MgJiB+UGxhY2VtZW50IHwgSHlkcmF0aW5nO1xuICAgICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBSb290IGlzIG5vdCBkZWh5ZHJhdGVkLiBFaXRoZXIgdGhpcyBpcyBhIGNsaWVudC1vbmx5IHJvb3QsIG9yIGl0XG4gICAgLy8gYWxyZWFkeSBoeWRyYXRlZC5cbiAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG5cbiAgICBpZiAobmV4dENoaWxkcmVuID09PSBwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgfVxuXG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiBtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICAvLyBSZXZlcnQgdG8gY2xpZW50IHJlbmRlcmluZy5cbiAgcmVzZXRIeWRyYXRpb25TdGF0ZSgpO1xuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBGb3JjZUNsaWVudFJlbmRlcjtcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RDb21wb25lbnQkMShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICB0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cblxuICBwdXNoSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICB2YXIgdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIHZhciBuZXh0UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBwcmV2UHJvcHMgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbnVsbDtcbiAgdmFyIG5leHRDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgdmFyIGlzRGlyZWN0VGV4dENoaWxkID0gc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgbmV4dFByb3BzKTtcblxuICBpZiAoaXNEaXJlY3RUZXh0Q2hpbGQpIHtcbiAgICAvLyBXZSBzcGVjaWFsIGNhc2UgYSBkaXJlY3QgdGV4dCBjaGlsZCBvZiBhIGhvc3Qgbm9kZS4gVGhpcyBpcyBhIGNvbW1vblxuICAgIC8vIGNhc2UuIFdlIHdvbid0IGhhbmRsZSBpdCBhcyBhIHJlaWZpZWQgY2hpbGQuIFdlIHdpbGwgaW5zdGVhZCBoYW5kbGVcbiAgICAvLyB0aGlzIGluIHRoZSBob3N0IGVudmlyb25tZW50IHRoYXQgYWxzbyBoYXMgYWNjZXNzIHRvIHRoaXMgcHJvcC4gVGhhdFxuICAgIC8vIGF2b2lkcyBhbGxvY2F0aW5nIGFub3RoZXIgSG9zdFRleHQgZmliZXIgYW5kIHRyYXZlcnNpbmcgaXQuXG4gICAgbmV4dENoaWxkcmVuID0gbnVsbDtcbiAgfSBlbHNlIGlmIChwcmV2UHJvcHMgIT09IG51bGwgJiYgc2hvdWxkU2V0VGV4dENvbnRlbnQodHlwZSwgcHJldlByb3BzKSkge1xuICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGEgZGlyZWN0IHRleHQgY2hpbGQgdG8gYSBub3JtYWwgY2hpbGQsIG9yIHRvXG4gICAgLy8gZW1wdHksIHdlIG5lZWQgdG8gc2NoZWR1bGUgdGhlIHRleHQgY29udGVudCB0byBiZSByZXNldC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBDb250ZW50UmVzZXQ7XG4gIH1cblxuICB7XG4gICAgdmFyIG1lbW9pemVkU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgaWYgKG1lbW9pemVkU3RhdGUgIT09IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgZmliZXIgaGFzIGJlZW4gdXBncmFkZWQgdG8gYSBzdGF0ZWZ1bCBjb21wb25lbnQuIFRoZSBvbmx5IHdheVxuICAgICAgLy8gaGFwcGVucyBjdXJyZW50bHkgaXMgZm9yIGZvcm0gYWN0aW9ucy4gV2UgdXNlIGhvb2tzIHRvIHRyYWNrIHRoZVxuICAgICAgLy8gcGVuZGluZyBhbmQgZXJyb3Igc3RhdGUgb2YgdGhlIGZvcm0uXG4gICAgICAvL1xuICAgICAgLy8gT25jZSBhIGZpYmVyIGlzIHVwZ3JhZGVkIHRvIGJlIHN0YXRlZnVsLCBpdCByZW1haW5zIHN0YXRlZnVsIGZvciB0aGVcbiAgICAgIC8vIHJlc3Qgb2YgaXRzIGxpZmV0aW1lLlxuICAgICAgdmFyIG5ld1N0YXRlID0gcmVuZGVyVHJhbnNpdGlvbkF3YXJlSG9zdENvbXBvbmVudFdpdGhIb29rcyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpOyAvLyBJZiB0aGUgdHJhbnNpdGlvbiBzdGF0ZSBjaGFuZ2VkLCBwcm9wYWdhdGUgdGhlIGNoYW5nZSB0byBhbGwgdGhlXG4gICAgICAvLyBkZXNjZW5kZW50cy4gV2UgdXNlIENvbnRleHQgYXMgYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsIGZvciB0aGlzLlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBzZXQgaGVyZSBpbnN0ZWFkIG9mIHB1c2hIb3N0Q29udGV4dCBiZWNhdXNlXG4gICAgICAvLyBwdXNoSG9zdENvbnRleHQgZ2V0cyBjYWxsZWQgYmVmb3JlIHdlIHByb2Nlc3MgdGhlIHN0YXRlIGhvb2ssIHRvIGF2b2lkXG4gICAgICAvLyBhIHN0YXRlIG1pc21hdGNoIGluIHRoZSBldmVudCB0aGF0IHNvbWV0aGluZyBzdXNwZW5kcy5cbiAgICAgIC8vXG4gICAgICAvLyBOT1RFOiBUaGlzIGFzc3VtZXMgdGhhdCB0aGVyZSBjYW5ub3QgYmUgbmVzdGVkIHRyYW5zaXRpb24gcHJvdmlkZXJzLFxuICAgICAgLy8gYmVjYXVzZSB0aGUgb25seSByZW5kZXJlciB0aGF0IGltcGxlbWVudHMgdGhpcyBmZWF0dXJlIGlzIFJlYWN0IERPTSxcbiAgICAgIC8vIGFuZCBmb3JtcyBjYW5ub3QgYmUgbmVzdGVkLiBJZiB3ZSBkaWQgc3VwcG9ydCBuZXN0ZWQgcHJvdmlkZXJzLCB0aGVuXG4gICAgICAvLyB3ZSB3b3VsZCBuZWVkIHRvIHB1c2ggYSBjb250ZXh0IHZhbHVlIGV2ZW4gZm9yIGhvc3QgZmliZXJzIHRoYXRcbiAgICAgIC8vIGhhdmVuJ3QgYmVlbiB1cGdyYWRlZCB5ZXQuXG5cbiAgICAgIGlmIChpc1ByaW1hcnlSZW5kZXJlcikge1xuICAgICAgICBIb3N0VHJhbnNpdGlvbkNvbnRleHQuX2N1cnJlbnRWYWx1ZSA9IG5ld1N0YXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgSG9zdFRyYW5zaXRpb25Db250ZXh0Ll9jdXJyZW50VmFsdWUyID0gbmV3U3RhdGU7XG4gICAgICB9XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKGRpZFJlY2VpdmVVcGRhdGUpIHtcbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIG9sZFN0YXRlSG9vayA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIHZhciBvbGRTdGF0ZSA9IG9sZFN0YXRlSG9vay5tZW1vaXplZFN0YXRlOyAvLyBUaGlzIHVzZXMgcmVndWxhciBlcXVhbGl0eSBpbnN0ZWFkIG9mIE9iamVjdC5pcyBiZWNhdXNlIHdlIGFzc3VtZVxuICAgICAgICAgICAgLy8gdGhhdCBob3N0IHRyYW5zaXRpb24gc3RhdGUgZG9lc24ndCBpbmNsdWRlIE5hTiBhcyBhIHZhbGlkIHR5cGUuXG5cbiAgICAgICAgICAgIGlmIChvbGRTdGF0ZSAhPT0gbmV3U3RhdGUpIHtcbiAgICAgICAgICAgICAgcHJvcGFnYXRlQ29udGV4dENoYW5nZSh3b3JrSW5Qcm9ncmVzcywgSG9zdFRyYW5zaXRpb25Db250ZXh0LCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVIb3N0SG9pc3RhYmxlKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBtYXJrUmVmKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKTtcbiAgdmFyIGN1cnJlbnRQcm9wcyA9IGN1cnJlbnQgPT09IG51bGwgPyBudWxsIDogY3VycmVudC5tZW1vaXplZFByb3BzO1xuICB2YXIgcmVzb3VyY2UgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gZ2V0UmVzb3VyY2Uod29ya0luUHJvZ3Jlc3MudHlwZSwgY3VycmVudFByb3BzLCB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMpO1xuXG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgaWYgKCFnZXRJc0h5ZHJhdGluZygpICYmIHJlc291cmNlID09PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIGlzIG5vdCBhIFJlc291cmNlIEhvaXN0YWJsZSBhbmQgd2UgYXJlbid0IGh5ZHJhdGluZyBzbyB3ZSBjb25zdHJ1Y3QgdGhlIGluc3RhbmNlLlxuICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3JlYXRlSG9pc3RhYmxlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MudHlwZSwgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzLCBnZXRSb290SG9zdENvbnRhaW5lcigpLCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgfVxuICB9IC8vIFJlc291cmNlcyBuZXZlciBoYXZlIHJlY29uY2lsZXIgbWFuYWdlZCBjaGlsZHJlbi4gSXQgaXMgcG9zc2libGUgZm9yXG4gIC8vIHRoZSBob3N0IGltcGxlbWVudGF0aW9uIG9mIGdldFJlc291cmNlIHRvIGNvbnNpZGVyIGNoaWxkcmVuIGluIHRoZVxuICAvLyByZXNvdXJjZSBjb25zdHJ1Y3Rpb24gYnV0IHRoZXkgd2lsbCBvdGhlcndpc2UgYmUgZGlzY2FyZGVkLiBJbiBwcmFjdGljZVxuICAvLyB0aGlzIHByZWNsdWRlcyBhbGwgYnV0IHRoZSBzaW1wbGVzdCBjaGlsZHJlbiBhbmQgSG9zdCBzcGVjaWZpYyB3YXJuaW5nc1xuICAvLyBzaG91bGQgYmUgaW1wbGVtZW50ZWQgdG8gd2FybiB3aGVuIGNoaWxkcmVuIGFyZSBwYXNzc2VkIHdoZW4gb3RoZXJ3aXNlIG5vdFxuICAvLyBleHBlY3RlZFxuXG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUhvc3RTaW5nbGV0b24oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICBjbGFpbUh5ZHJhdGFibGVTaW5nbGV0b24od29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcy5jaGlsZHJlbjtcblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCAmJiAhZ2V0SXNIeWRyYXRpbmcoKSkge1xuICAgIC8vIFNpbWlsYXIgdG8gUG9ydGFscyB3ZSBhcHBlbmQgU2luZ2xldG9uIGNoaWxkcmVuIGluIHRoZSBjb21taXQgcGhhc2UuIFNvIHdlXG4gICAgLy8gVHJhY2sgaW5zZXJ0aW9ucyBldmVuIG9uIG1vdW50LlxuICAgIC8vIFRPRE86IENvbnNpZGVyIHVuaWZ5aW5nIHRoaXMgd2l0aCBob3cgdGhlIHJvb3Qgd29ya3MuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgbWFya1JlZihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdFRleHQkMShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIHRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZVRleHRJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gIH0gLy8gTm90aGluZyB0byBkbyBoZXJlLiBUaGlzIGlzIHRlcm1pbmFsLiBXZSdsbCBkbyB0aGUgY29tcGxldGlvbiBzdGVwXG4gIC8vIGltbWVkaWF0ZWx5IGFmdGVyLlxuXG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIG1vdW50TGF6eUNvbXBvbmVudChfY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGVsZW1lbnRUeXBlLCByZW5kZXJMYW5lcykge1xuICB2YXIgcHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBsYXp5Q29tcG9uZW50ID0gZWxlbWVudFR5cGU7XG4gIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuICB2YXIgQ29tcG9uZW50ID0gaW5pdChwYXlsb2FkKTsgLy8gU3RvcmUgdGhlIHVud3JhcHBlZCBjb21wb25lbnQgaW4gdGhlIHR5cGUuXG5cbiAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IENvbXBvbmVudDtcblxuICBpZiAodHlwZW9mIENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChpc0Z1bmN0aW9uQ2xhc3NDb21wb25lbnQoQ29tcG9uZW50KSkge1xuICAgICAgdmFyIHJlc29sdmVkUHJvcHMgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhDb21wb25lbnQsIHByb3BzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLnRhZyA9IENsYXNzQ29tcG9uZW50O1xuXG4gICAgICB7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBDb21wb25lbnQgPSByZXNvbHZlQ2xhc3NGb3JIb3RSZWxvYWRpbmcoQ29tcG9uZW50KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVwZGF0ZUNsYXNzQ29tcG9uZW50KG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlc29sdmVkUHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIF9yZXNvbHZlZFByb3BzID0gcHJvcHMgO1xuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBGdW5jdGlvbkNvbXBvbmVudDtcblxuICAgICAge1xuICAgICAgICB2YWxpZGF0ZUZ1bmN0aW9uQ29tcG9uZW50SW5EZXYod29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCk7XG4gICAgICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBDb21wb25lbnQgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcoQ29tcG9uZW50KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KG51bGwsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIF9yZXNvbHZlZFByb3BzLCByZW5kZXJMYW5lcyk7XG4gICAgfVxuICB9IGVsc2UgaWYgKENvbXBvbmVudCAhPT0gdW5kZWZpbmVkICYmIENvbXBvbmVudCAhPT0gbnVsbCkge1xuICAgIHZhciAkJHR5cGVvZiA9IENvbXBvbmVudC4kJHR5cGVvZjtcblxuICAgIGlmICgkJHR5cGVvZiA9PT0gUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRSkge1xuICAgICAgdmFyIF9yZXNvbHZlZFByb3BzMiA9IHByb3BzIDtcblxuICAgICAgd29ya0luUHJvZ3Jlc3MudGFnID0gRm9yd2FyZFJlZjtcblxuICAgICAge1xuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gQ29tcG9uZW50ID0gcmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmcoQ29tcG9uZW50KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVwZGF0ZUZvcndhcmRSZWYobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgX3Jlc29sdmVkUHJvcHMyLCByZW5kZXJMYW5lcyk7XG4gICAgfSBlbHNlIGlmICgkJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFKSB7XG4gICAgICB2YXIgX3Jlc29sdmVkUHJvcHMzID0gcHJvcHMgO1xuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy50YWcgPSBNZW1vQ29tcG9uZW50O1xuICAgICAgcmV0dXJuIHVwZGF0ZU1lbW9Db21wb25lbnQobnVsbCwgd29ya0luUHJvZ3Jlc3MsIENvbXBvbmVudCwgX3Jlc29sdmVkUHJvcHMzICwgLy8gVGhlIGlubmVyIHR5cGUgY2FuIGhhdmUgZGVmYXVsdHMgdG9vXG4gICAgICByZW5kZXJMYW5lcyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGhpbnQgPSAnJztcblxuICB7XG4gICAgaWYgKENvbXBvbmVudCAhPT0gbnVsbCAmJiB0eXBlb2YgQ29tcG9uZW50ID09PSAnb2JqZWN0JyAmJiBDb21wb25lbnQuJCR0eXBlb2YgPT09IFJFQUNUX0xBWllfVFlQRSkge1xuICAgICAgaGludCA9ICcgRGlkIHlvdSB3cmFwIGEgY29tcG9uZW50IGluIFJlYWN0LmxhenkoKSBtb3JlIHRoYW4gb25jZT8nO1xuICAgIH1cbiAgfSAvLyBUaGlzIG1lc3NhZ2UgaW50ZW50aW9uYWxseSBkb2Vzbid0IG1lbnRpb24gRm9yd2FyZFJlZiBvciBNZW1vQ29tcG9uZW50XG4gIC8vIGJlY2F1c2UgdGhlIGZhY3QgdGhhdCBpdCdzIGEgc2VwYXJhdGUgdHlwZSBvZiB3b3JrIGlzIGFuXG4gIC8vIGltcGxlbWVudGF0aW9uIGRldGFpbC5cblxuXG4gIHRocm93IG5ldyBFcnJvcihcIkVsZW1lbnQgdHlwZSBpcyBpbnZhbGlkLiBSZWNlaXZlZCBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0bzogXCIgKyBDb21wb25lbnQgKyBcIi4gXCIgKyAoXCJMYXp5IGVsZW1lbnQgdHlwZSBtdXN0IHJlc29sdmUgdG8gYSBjbGFzcyBvciBmdW5jdGlvbi5cIiArIGhpbnQpKTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2KHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQpIHtcbiAge1xuICAgIGlmIChDb21wb25lbnQpIHtcbiAgICAgIGlmIChDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMpIHtcbiAgICAgICAgZXJyb3IoJ2NoaWxkQ29udGV4dFR5cGVzIGNhbm5vdCBiZSBkZWZpbmVkIG9uIGEgZnVuY3Rpb24gY29tcG9uZW50LlxcbicgKyAnICAlcy5jaGlsZENvbnRleHRUeXBlcyA9IC4uLicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50Jyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBDb21wb25lbnQuZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgX2NvbXBvbmVudE5hbWUyID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEdldERlcml2ZWRTdGF0ZU9uRnVuY3Rpb25Db21wb25lbnRbX2NvbXBvbmVudE5hbWUyXSkge1xuICAgICAgICBlcnJvcignJXM6IEZ1bmN0aW9uIGNvbXBvbmVudHMgZG8gbm90IHN1cHBvcnQgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLicsIF9jb21wb25lbnROYW1lMik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTJdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIENvbXBvbmVudC5jb250ZXh0VHlwZSA9PT0gJ29iamVjdCcgJiYgQ29tcG9uZW50LmNvbnRleHRUeXBlICE9PSBudWxsKSB7XG4gICAgICB2YXIgX2NvbXBvbmVudE5hbWUzID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKENvbXBvbmVudCkgfHwgJ1Vua25vd24nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTNdKSB7XG4gICAgICAgIGVycm9yKCclczogRnVuY3Rpb24gY29tcG9uZW50cyBkbyBub3Qgc3VwcG9ydCBjb250ZXh0VHlwZS4nLCBfY29tcG9uZW50TmFtZTMpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dENvbnRleHRUeXBlT25GdW5jdGlvbkNvbXBvbmVudFtfY29tcG9uZW50TmFtZTNdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIFNVU1BFTkRFRF9NQVJLRVIgPSB7XG4gIGRlaHlkcmF0ZWQ6IG51bGwsXG4gIHRyZWVDb250ZXh0OiBudWxsLFxuICByZXRyeUxhbmU6IE5vTGFuZVxufTtcblxuZnVuY3Rpb24gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSB7XG4gIHJldHVybiB7XG4gICAgYmFzZUxhbmVzOiByZW5kZXJMYW5lcyxcbiAgICBjYWNoZVBvb2w6IGdldFN1c3BlbmRlZENhY2hlKClcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlU3VzcGVuc2VPZmZzY3JlZW5TdGF0ZShwcmV2T2Zmc2NyZWVuU3RhdGUsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBjYWNoZVBvb2wgPSBudWxsO1xuXG4gIHtcbiAgICB2YXIgcHJldkNhY2hlUG9vbCA9IHByZXZPZmZzY3JlZW5TdGF0ZS5jYWNoZVBvb2w7XG5cbiAgICBpZiAocHJldkNhY2hlUG9vbCAhPT0gbnVsbCkge1xuICAgICAgdmFyIHBhcmVudENhY2hlID0gaXNQcmltYXJ5UmVuZGVyZXIgPyBDYWNoZUNvbnRleHQuX2N1cnJlbnRWYWx1ZSA6IENhY2hlQ29udGV4dC5fY3VycmVudFZhbHVlMjtcblxuICAgICAgaWYgKHByZXZDYWNoZVBvb2wucGFyZW50ICE9PSBwYXJlbnRDYWNoZSkge1xuICAgICAgICAvLyBEZXRlY3RlZCBhIHJlZnJlc2ggaW4gdGhlIHBhcmVudC4gVGhpcyBvdmVycmlkZXMgYW55IHByZXZpb3VzbHlcbiAgICAgICAgLy8gc3VzcGVuZGVkIGNhY2hlLlxuICAgICAgICBjYWNoZVBvb2wgPSB7XG4gICAgICAgICAgcGFyZW50OiBwYXJlbnRDYWNoZSxcbiAgICAgICAgICBwb29sOiBwYXJlbnRDYWNoZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gV2UgY2FuIHJldXNlIHRoZSBjYWNoZSBmcm9tIGxhc3QgdGltZS4gVGhlIG9ubHkgdGhpbmcgdGhhdCB3b3VsZCBoYXZlXG4gICAgICAgIC8vIG92ZXJyaWRkZW4gaXQgaXMgYSBwYXJlbnQgcmVmcmVzaCwgd2hpY2ggd2UgY2hlY2tlZCBmb3IgYWJvdmUuXG4gICAgICAgIGNhY2hlUG9vbCA9IHByZXZDYWNoZVBvb2w7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gcHJldmlvdXMgY2FjaGUgcG9vbCwgZ3JhYiB0aGUgY3VycmVudCBvbmUuXG4gICAgICBjYWNoZVBvb2wgPSBnZXRTdXNwZW5kZWRDYWNoZSgpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgYmFzZUxhbmVzOiBtZXJnZUxhbmVzKHByZXZPZmZzY3JlZW5TdGF0ZS5iYXNlTGFuZXMsIHJlbmRlckxhbmVzKSxcbiAgICBjYWNoZVBvb2w6IGNhY2hlUG9vbFxuICB9O1xufSAvLyBUT0RPOiBQcm9iYWJseSBzaG91bGQgaW5saW5lIHRoaXMgYmFja1xuXG5cbmZ1bmN0aW9uIHNob3VsZFJlbWFpbk9uRmFsbGJhY2soY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIC8vIElmIHdlJ3JlIGFscmVhZHkgc2hvd2luZyBhIGZhbGxiYWNrLCB0aGVyZSBhcmUgY2FzZXMgd2hlcmUgd2UgbmVlZCB0b1xuICAvLyByZW1haW4gb24gdGhhdCBmYWxsYmFjayByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlIGNvbnRlbnQgaGFzIHJlc29sdmVkLlxuICAvLyBGb3IgZXhhbXBsZSwgU3VzcGVuc2VMaXN0IGNvb3JkaW5hdGVzIHdoZW4gbmVzdGVkIGNvbnRlbnQgYXBwZWFycy5cbiAgLy8gVE9ETzogRm9yIGNvbXBhdGliaWxpdHkgd2l0aCBvZmZzY3JlZW4gcHJlcmVuZGVyaW5nLCB0aGlzIHNob3VsZCBhbHNvIGNoZWNrXG4gIC8vIHdoZXRoZXIgdGhlIGN1cnJlbnQgZmliZXIgKGlmIGl0IGV4aXN0cykgd2FzIHZpc2libGUgaW4gdGhlIHByZXZpb3VzIHRyZWUuXG4gIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgdmFyIHN1c3BlbnNlU3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICBpZiAoc3VzcGVuc2VTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgLy8gQ3VycmVudGx5IHNob3dpbmcgY29udGVudC4gRG9uJ3QgaGlkZSBpdCwgZXZlbiBpZiBGb3JjZVN1c3BlbnNlRmFsbGJhY2tcbiAgICAgIC8vIGlzIHRydWUuIE1vcmUgcHJlY2lzZSBuYW1lIG1pZ2h0IGJlIFwiRm9yY2VSZW1haW5TdXNwZW5zZUZhbGxiYWNrXCIuXG4gICAgICAvLyBOb3RlOiBUaGlzIGlzIGEgZmFjdG9yaW5nIHNtZWxsLiBDYW4ndCByZW1haW4gb24gYSBmYWxsYmFjayBpZiB0aGVyZSdzXG4gICAgICAvLyBubyBmYWxsYmFjayB0byByZW1haW4gb24uXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IC8vIE5vdCBjdXJyZW50bHkgc2hvd2luZyBjb250ZW50LiBDb25zdWx0IHRoZSBTdXNwZW5zZSBjb250ZXh0LlxuXG5cbiAgdmFyIHN1c3BlbnNlQ29udGV4dCA9IHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudDtcbiAgcmV0dXJuIGhhc1N1c3BlbnNlTGlzdENvbnRleHQoc3VzcGVuc2VDb250ZXh0LCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spO1xufVxuXG5mdW5jdGlvbiBnZXRSZW1haW5pbmdXb3JrSW5QcmltYXJ5VHJlZShjdXJyZW50LCBwcmltYXJ5VHJlZURpZERlZmVyLCByZW5kZXJMYW5lcykge1xuICB2YXIgcmVtYWluaW5nTGFuZXMgPSBjdXJyZW50ICE9PSBudWxsID8gcmVtb3ZlTGFuZXMoY3VycmVudC5jaGlsZExhbmVzLCByZW5kZXJMYW5lcykgOiBOb0xhbmVzO1xuXG4gIGlmIChwcmltYXJ5VHJlZURpZERlZmVyKSB7XG4gICAgLy8gQSB1c2VEZWZlcnJlZFZhbHVlIGhvb2sgc3Bhd25lZCBhIGRlZmVycmVkIHRhc2sgaW5zaWRlIHRoZSBwcmltYXJ5IHRyZWUuXG4gICAgLy8gRW5zdXJlIHRoYXQgd2UgcmV0cnkgdGhpcyBjb21wb25lbnQgYXQgdGhlIGRlZmVycmVkIHByaW9yaXR5LlxuICAgIC8vIFRPRE86IFdlIGNvdWxkIG1ha2UgdGhpcyBhIHBlci1zdWJ0cmVlIHZhbHVlIGluc3RlYWQgb2YgYSBnbG9iYWwgb25lLlxuICAgIC8vIFdvdWxkIG5lZWQgdG8gdHJhY2sgaXQgb24gdGhlIGNvbnRleHQgc3RhY2sgc29tZWhvdywgc2ltaWxhciB0byB3aGF0XG4gICAgLy8gd2UnZCBoYXZlIHRvIGRvIGZvciByZXN1bWFibGUgY29udGV4dHMuXG4gICAgcmVtYWluaW5nTGFuZXMgPSBtZXJnZUxhbmVzKHJlbWFpbmluZ0xhbmVzLCBwZWVrRGVmZXJyZWRMYW5lKCkpO1xuICB9XG5cbiAgcmV0dXJuIHJlbWFpbmluZ0xhbmVzO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wczsgLy8gVGhpcyBpcyB1c2VkIGJ5IERldlRvb2xzIHRvIGZvcmNlIGEgYm91bmRhcnkgdG8gc3VzcGVuZC5cblxuICB7XG4gICAgaWYgKHNob3VsZFN1c3BlbmQod29ya0luUHJvZ3Jlc3MpKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzaG93RmFsbGJhY2sgPSBmYWxzZTtcbiAgdmFyIGRpZFN1c3BlbmQgPSAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncyQxO1xuXG4gIGlmIChkaWRTdXNwZW5kIHx8IHNob3VsZFJlbWFpbk9uRmFsbGJhY2soY3VycmVudCkpIHtcbiAgICAvLyBTb21ldGhpbmcgaW4gdGhpcyBib3VuZGFyeSdzIHN1YnRyZWUgYWxyZWFkeSBzdXNwZW5kZWQuIFN3aXRjaCB0b1xuICAgIC8vIHJlbmRlcmluZyB0aGUgZmFsbGJhY2sgY2hpbGRyZW4uXG4gICAgc2hvd0ZhbGxiYWNrID0gdHJ1ZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSB+RGlkQ2FwdHVyZTtcbiAgfSAvLyBDaGVjayBpZiB0aGUgcHJpbWFyeSBjaGlsZHJlbiBzcGF3bmVkIGEgZGVmZXJyZWQgdGFzayAodXNlRGVmZXJyZWRWYWx1ZSlcbiAgLy8gZHVyaW5nIHRoZSBmaXJzdCBwYXNzLlxuXG5cbiAgdmFyIGRpZFByaW1hcnlDaGlsZHJlbkRlZmVyID0gKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkRGVmZXIpICE9PSBOb0ZsYWdzJDE7XG4gIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IH5EaWREZWZlcjsgLy8gT0ssIHRoZSBuZXh0IHBhcnQgaXMgY29uZnVzaW5nLiBXZSdyZSBhYm91dCB0byByZWNvbmNpbGUgdGhlIFN1c3BlbnNlXG4gIC8vIGJvdW5kYXJ5J3MgY2hpbGRyZW4uIFRoaXMgaW52b2x2ZXMgc29tZSBjdXN0b20gcmVjb25jaWxpYXRpb24gbG9naWMuIFR3b1xuICAvLyBtYWluIHJlYXNvbnMgdGhpcyBpcyBzbyBjb21wbGljYXRlZC5cbiAgLy9cbiAgLy8gRmlyc3QsIExlZ2FjeSBNb2RlIGhhcyBkaWZmZXJlbnQgc2VtYW50aWNzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS4gVGhlXG4gIC8vIHByaW1hcnkgdHJlZSB3aWxsIGNvbW1pdCBpbiBhbiBpbmNvbnNpc3RlbnQgc3RhdGUsIHNvIHdoZW4gd2UgZG8gdGhlXG4gIC8vIHNlY29uZCBwYXNzIHRvIHJlbmRlciB0aGUgZmFsbGJhY2ssIHdlIGRvIHNvbWUgZXhjZWVkaW5nbHksIHVoLCBjbGV2ZXJcbiAgLy8gaGFja3MgdG8gbWFrZSB0aGF0IG5vdCB0b3RhbGx5IGJyZWFrLiBMaWtlIHRyYW5zZmVycmluZyBlZmZlY3RzIGFuZFxuICAvLyBkZWxldGlvbnMgZnJvbSBoaWRkZW4gdHJlZS4gSW4gQ29uY3VycmVudCBNb2RlLCBpdCdzIG11Y2ggc2ltcGxlcixcbiAgLy8gYmVjYXVzZSB3ZSBiYWlsb3V0IG9uIHRoZSBwcmltYXJ5IHRyZWUgY29tcGxldGVseSBhbmQgbGVhdmUgaXQgaW4gaXRzIG9sZFxuICAvLyBzdGF0ZSwgbm8gZWZmZWN0cy4gU2FtZSBhcyB3aGF0IHdlIGRvIGZvciBPZmZzY3JlZW4gKGV4Y2VwdCB0aGF0XG4gIC8vIE9mZnNjcmVlbiBkb2Vzbid0IGhhdmUgdGhlIGZpcnN0IHJlbmRlciBwYXNzKS5cbiAgLy9cbiAgLy8gU2Vjb25kIGlzIGh5ZHJhdGlvbi4gRHVyaW5nIGh5ZHJhdGlvbiwgdGhlIFN1c3BlbnNlIGZpYmVyIGhhcyBhIHNsaWdodGx5XG4gIC8vIGRpZmZlcmVudCBsYXlvdXQsIHdoZXJlIHRoZSBjaGlsZCBwb2ludHMgdG8gYSBkZWh5ZHJhdGVkIGZyYWdtZW50LCB3aGljaFxuICAvLyBjb250YWlucyB0aGUgRE9NIHJlbmRlcmVkIGJ5IHRoZSBzZXJ2ZXIuXG4gIC8vXG4gIC8vIFRoaXJkLCBldmVuIGlmIHlvdSBzZXQgYWxsIHRoYXQgYXNpZGUsIFN1c3BlbnNlIGlzIGxpa2UgZXJyb3IgYm91bmRhcmllcyBpblxuICAvLyB0aGF0IHdlIGZpcnN0IHdlIHRyeSB0byByZW5kZXIgb25lIHRyZWUsIGFuZCBpZiB0aGF0IGZhaWxzLCB3ZSByZW5kZXIgYWdhaW5cbiAgLy8gYW5kIHN3aXRjaCB0byBhIGRpZmZlcmVudCB0cmVlLiBMaWtlIGEgdHJ5L2NhdGNoIGJsb2NrLiBTbyB3ZSBoYXZlIHRvIHRyYWNrXG4gIC8vIHdoaWNoIGJyYW5jaCB3ZSdyZSBjdXJyZW50bHkgcmVuZGVyaW5nLiBJZGVhbGx5IHdlIHdvdWxkIG1vZGVsIHRoaXMgdXNpbmdcbiAgLy8gYSBzdGFjay5cblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIC8vIEluaXRpYWwgbW91bnRcbiAgICAvLyBTcGVjaWFsIHBhdGggZm9yIGh5ZHJhdGlvblxuICAgIC8vIElmIHdlJ3JlIGN1cnJlbnRseSBoeWRyYXRpbmcsIHRyeSB0byBoeWRyYXRlIHRoaXMgYm91bmRhcnkuXG4gICAgaWYgKGdldElzSHlkcmF0aW5nKCkpIHtcbiAgICAgIC8vIFdlIG11c3QgcHVzaCB0aGUgc3VzcGVuc2UgaGFuZGxlciBjb250ZXh0ICpiZWZvcmUqIGF0dGVtcHRpbmcgdG9cbiAgICAgIC8vIGh5ZHJhdGUsIHRvIGF2b2lkIGEgbWlzbWF0Y2ggaW4gY2FzZSBpdCBlcnJvcnMuXG4gICAgICBpZiAoc2hvd0ZhbGxiYWNrKSB7XG4gICAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdXNoRmFsbGJhY2tUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIH1cblxuICAgICAgdHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7IC8vIFRoaXMgY291bGQndmUgYmVlbiBhIGRlaHlkcmF0ZWQgc3VzcGVuc2UgY29tcG9uZW50LlxuXG4gICAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgIGlmIChzdXNwZW5zZVN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIHZhciBkZWh5ZHJhdGVkID0gc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkO1xuXG4gICAgICAgIGlmIChkZWh5ZHJhdGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG1vdW50RGVoeWRyYXRlZFN1c3BlbnNlQ29tcG9uZW50KHdvcmtJblByb2dyZXNzLCBkZWh5ZHJhdGVkKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBJZiBoeWRyYXRpb24gZGlkbid0IHN1Y2NlZWQsIGZhbGwgdGhyb3VnaCB0byB0aGUgbm9ybWFsIFN1c3BlbnNlIHBhdGguXG4gICAgICAvLyBUbyBhdm9pZCBhIHN0YWNrIG1pc21hdGNoIHdlIG5lZWQgdG8gcG9wIHRoZSBTdXNwZW5zZSBoYW5kbGVyIHRoYXQgd2VcbiAgICAgIC8vIHB1c2hlZCBhYm92ZS4gVGhpcyB3aWxsIGJlY29tZSBsZXNzIGF3a3dhcmQgd2hlbiBtb3ZlIHRoZSBoeWRyYXRpb25cbiAgICAgIC8vIGxvZ2ljIHRvIGl0cyBvd24gZmliZXIuXG5cblxuICAgICAgcG9wU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dFByaW1hcnlDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICB2YXIgbmV4dEZhbGxiYWNrQ2hpbGRyZW4gPSBuZXh0UHJvcHMuZmFsbGJhY2s7XG5cbiAgICBpZiAoc2hvd0ZhbGxiYWNrKSB7XG4gICAgICBwdXNoRmFsbGJhY2tUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHZhciBmYWxsYmFja0ZyYWdtZW50ID0gbW91bnRTdXNwZW5zZUZhbGxiYWNrQ2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIG5leHRQcmltYXJ5Q2hpbGRyZW4sIG5leHRGYWxsYmFja0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gICAgICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50Lm1lbW9pemVkU3RhdGUgPSBtb3VudFN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocmVuZGVyTGFuZXMpO1xuICAgICAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIGRpZFByaW1hcnlDaGlsZHJlbkRlZmVyLCByZW5kZXJMYW5lcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUjtcblxuICAgICAgcmV0dXJuIGZhbGxiYWNrRnJhZ21lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgbmV4dFByaW1hcnlDaGlsZHJlbik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgYW4gdXBkYXRlLlxuICAgIC8vIFNwZWNpYWwgcGF0aCBmb3IgaHlkcmF0aW9uXG4gICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBfZGVoeWRyYXRlZCA9IHByZXZTdGF0ZS5kZWh5ZHJhdGVkO1xuXG4gICAgICBpZiAoX2RlaHlkcmF0ZWQgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZURlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgZGlkU3VzcGVuZCwgZGlkUHJpbWFyeUNoaWxkcmVuRGVmZXIsIG5leHRQcm9wcywgX2RlaHlkcmF0ZWQsIHByZXZTdGF0ZSwgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG93RmFsbGJhY2spIHtcbiAgICAgIHB1c2hGYWxsYmFja1RyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgdmFyIF9uZXh0RmFsbGJhY2tDaGlsZHJlbiA9IG5leHRQcm9wcy5mYWxsYmFjaztcbiAgICAgIHZhciBfbmV4dFByaW1hcnlDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSB1cGRhdGVTdXNwZW5zZUZhbGxiYWNrQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIF9uZXh0UHJpbWFyeUNoaWxkcmVuLCBfbmV4dEZhbGxiYWNrQ2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgICAgIHZhciBfcHJpbWFyeUNoaWxkRnJhZ21lbnQyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICB2YXIgcHJldk9mZnNjcmVlblN0YXRlID0gY3VycmVudC5jaGlsZC5tZW1vaXplZFN0YXRlO1xuICAgICAgX3ByaW1hcnlDaGlsZEZyYWdtZW50Mi5tZW1vaXplZFN0YXRlID0gcHJldk9mZnNjcmVlblN0YXRlID09PSBudWxsID8gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKSA6IHVwZGF0ZVN1c3BlbnNlT2Zmc2NyZWVuU3RhdGUocHJldk9mZnNjcmVlblN0YXRlLCByZW5kZXJMYW5lcyk7XG5cbiAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDIuY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIGRpZFByaW1hcnlDaGlsZHJlbkRlZmVyLCByZW5kZXJMYW5lcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUjtcbiAgICAgIHJldHVybiBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB2YXIgX25leHRQcmltYXJ5Q2hpbGRyZW4yID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuXG4gICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50MyA9IHVwZGF0ZVN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfbmV4dFByaW1hcnlDaGlsZHJlbjIpO1xuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgIHJldHVybiBfcHJpbWFyeUNoaWxkRnJhZ21lbnQzO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIHZhciBtb2RlID0gd29ya0luUHJvZ3Jlc3MubW9kZTtcbiAgdmFyIHByaW1hcnlDaGlsZFByb3BzID0ge1xuICAgIG1vZGU6ICd2aXNpYmxlJyxcbiAgICBjaGlsZHJlbjogcHJpbWFyeUNoaWxkcmVuXG4gIH07XG4gIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihwcmltYXJ5Q2hpbGRQcm9wcywgbW9kZSk7XG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICByZXR1cm4gcHJpbWFyeUNoaWxkRnJhZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIG1vdW50U3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuKHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4sIGZhbGxiYWNrQ2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIHZhciBtb2RlID0gd29ya0luUHJvZ3Jlc3MubW9kZTtcbiAgdmFyIHByaW1hcnlDaGlsZFByb3BzID0ge1xuICAgIG1vZGU6ICdoaWRkZW4nLFxuICAgIGNoaWxkcmVuOiBwcmltYXJ5Q2hpbGRyZW5cbiAgfTtcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50O1xuICB2YXIgZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuXG4gIHtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihwcmltYXJ5Q2hpbGRQcm9wcywgbW9kZSk7XG4gICAgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gY3JlYXRlRmliZXJGcm9tRnJhZ21lbnQoZmFsbGJhY2tDaGlsZHJlbiwgbW9kZSwgcmVuZGVyTGFuZXMsIG51bGwpO1xuICB9XG5cbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIGZhbGxiYWNrQ2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZyA9IGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbiAgcmV0dXJuIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gbW91bnRXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKG9mZnNjcmVlblByb3BzLCBtb2RlLCByZW5kZXJMYW5lcykge1xuICAvLyBUaGUgcHJvcHMgYXJndW1lbnQgdG8gYGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbmAgaXMgYGFueWAgdHlwZWQsIHNvIHdlIHVzZVxuICAvLyB0aGlzIHdyYXBwZXIgZnVuY3Rpb24gdG8gY29uc3RyYWluIGl0LlxuICByZXR1cm4gY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuKG9mZnNjcmVlblByb3BzLCBtb2RlLCBOb0xhbmVzLCBudWxsKTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlV29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihjdXJyZW50LCBvZmZzY3JlZW5Qcm9wcykge1xuICAvLyBUaGUgcHJvcHMgYXJndW1lbnQgdG8gYGNyZWF0ZVdvcmtJblByb2dyZXNzYCBpcyBgYW55YCB0eXBlZCwgc28gd2UgdXNlIHRoaXNcbiAgLy8gd3JhcHBlciBmdW5jdGlvbiB0byBjb25zdHJhaW4gaXQuXG4gIHJldHVybiBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50LCBvZmZzY3JlZW5Qcm9wcyk7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBwcmltYXJ5Q2hpbGRyZW4sIHJlbmRlckxhbmVzKSB7XG4gIHZhciBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQgPSBjdXJyZW50LmNoaWxkO1xuICB2YXIgY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nO1xuICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSB1cGRhdGVXb3JrSW5Qcm9ncmVzc09mZnNjcmVlbkZpYmVyKGN1cnJlbnRQcmltYXJ5Q2hpbGRGcmFnbWVudCwge1xuICAgIG1vZGU6ICd2aXNpYmxlJyxcbiAgICBjaGlsZHJlbjogcHJpbWFyeUNoaWxkcmVuXG4gIH0pO1xuXG4gIHByaW1hcnlDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nID0gbnVsbDtcblxuICBpZiAoY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCAhPT0gbnVsbCkge1xuICAgIC8vIERlbGV0ZSB0aGUgZmFsbGJhY2sgY2hpbGQgZnJhZ21lbnRcbiAgICB2YXIgZGVsZXRpb25zID0gd29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zO1xuXG4gICAgaWYgKGRlbGV0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zID0gW2N1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnRdO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gQ2hpbGREZWxldGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRpb25zLnB1c2goY3VycmVudEZhbGxiYWNrQ2hpbGRGcmFnbWVudCk7XG4gICAgfVxuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbiAgcmV0dXJuIHByaW1hcnlDaGlsZEZyYWdtZW50O1xufVxuXG5mdW5jdGlvbiB1cGRhdGVTdXNwZW5zZUZhbGxiYWNrQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbiwgZmFsbGJhY2tDaGlsZHJlbiwgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG1vZGUgPSB3b3JrSW5Qcm9ncmVzcy5tb2RlO1xuICB2YXIgY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50ID0gY3VycmVudC5jaGlsZDtcbiAgdmFyIGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZztcbiAgdmFyIHByaW1hcnlDaGlsZFByb3BzID0ge1xuICAgIG1vZGU6ICdoaWRkZW4nLFxuICAgIGNoaWxkcmVuOiBwcmltYXJ5Q2hpbGRyZW5cbiAgfTtcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50O1xuXG4gIHtcbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IHVwZGF0ZVdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIoY3VycmVudFByaW1hcnlDaGlsZEZyYWdtZW50LCBwcmltYXJ5Q2hpbGRQcm9wcyk7IC8vIFNpbmNlIHdlJ3JlIHJldXNpbmcgYSBjdXJyZW50IHRyZWUsIHdlIG5lZWQgdG8gcmV1c2UgdGhlIGZsYWdzLCB0b28uXG4gICAgLy8gKFdlIGRvbid0IGRvIHRoaXMgaW4gbGVnYWN5IG1vZGUsIGJlY2F1c2UgaW4gbGVnYWN5IG1vZGUgd2UgZG9uJ3QgcmUtdXNlXG4gICAgLy8gdGhlIGN1cnJlbnQgdHJlZTsgc2VlIHByZXZpb3VzIGJyYW5jaC4pXG5cbiAgICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zdWJ0cmVlRmxhZ3MgPSBjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQuc3VidHJlZUZsYWdzICYgU3RhdGljTWFzaztcbiAgfVxuXG4gIHZhciBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG5cbiAgaWYgKGN1cnJlbnRGYWxsYmFja0NoaWxkRnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjcmVhdGVXb3JrSW5Qcm9ncmVzcyhjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50LCBmYWxsYmFja0NoaWxkcmVuKTtcbiAgfSBlbHNlIHtcbiAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQgPSBjcmVhdGVGaWJlckZyb21GcmFnbWVudChmYWxsYmFja0NoaWxkcmVuLCBtb2RlLCByZW5kZXJMYW5lcywgbnVsbCk7IC8vIE5lZWRzIGEgcGxhY2VtZW50IGVmZmVjdCBiZWNhdXNlIHRoZSBwYXJlbnQgKHRoZSBTdXNwZW5zZSBib3VuZGFyeSkgYWxyZWFkeVxuICAgIC8vIG1vdW50ZWQgYnV0IHRoaXMgaXMgYSBuZXcgZmliZXIuXG5cbiAgICBmYWxsYmFja0NoaWxkRnJhZ21lbnQuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICB9XG5cbiAgZmFsbGJhY2tDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuc2libGluZyA9IGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbiAgcmV0dXJuIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gcmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIC8vIEZhbGxpbmcgYmFjayB0byBjbGllbnQgcmVuZGVyaW5nLiBCZWNhdXNlIHRoaXMgaGFzIHBlcmZvcm1hbmNlXG4gIC8vIGltcGxpY2F0aW9ucywgaXQncyBjb25zaWRlcmVkIGEgcmVjb3ZlcmFibGUgZXJyb3IsIGV2ZW4gdGhvdWdoIHRoZSB1c2VyXG4gIC8vIGxpa2VseSB3b24ndCBvYnNlcnZlIGFueXRoaW5nIHdyb25nIHdpdGggdGhlIFVJLlxuICAvLyBUaGlzIHdpbGwgYWRkIHRoZSBvbGQgZmliZXIgdG8gdGhlIGRlbGV0aW9uIGxpc3RcbiAgcmVjb25jaWxlQ2hpbGRGaWJlcnMod29ya0luUHJvZ3Jlc3MsIGN1cnJlbnQuY2hpbGQsIG51bGwsIHJlbmRlckxhbmVzKTsgLy8gV2UncmUgbm93IG5vdCBzdXNwZW5kZWQgbm9yIGRlaHlkcmF0ZWQuXG5cbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIHByaW1hcnlDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gbW91bnRTdXNwZW5zZVByaW1hcnlDaGlsZHJlbih3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuKTsgLy8gTmVlZHMgYSBwbGFjZW1lbnQgZWZmZWN0IGJlY2F1c2UgdGhlIHBhcmVudCAodGhlIFN1c3BlbnNlIGJvdW5kYXJ5KSBhbHJlYWR5XG4gIC8vIG1vdW50ZWQgYnV0IHRoaXMgaXMgYSBuZXcgZmliZXIuXG5cbiAgcHJpbWFyeUNoaWxkRnJhZ21lbnQuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgcmV0dXJuIHByaW1hcnlDaGlsZEZyYWdtZW50O1xufVxuXG5mdW5jdGlvbiBtb3VudFN1c3BlbnNlRmFsbGJhY2tBZnRlclJldHJ5V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcHJpbWFyeUNoaWxkcmVuLCBmYWxsYmFja0NoaWxkcmVuLCByZW5kZXJMYW5lcykge1xuICB2YXIgZmliZXJNb2RlID0gd29ya0luUHJvZ3Jlc3MubW9kZTtcbiAgdmFyIHByaW1hcnlDaGlsZFByb3BzID0ge1xuICAgIG1vZGU6ICd2aXNpYmxlJyxcbiAgICBjaGlsZHJlbjogcHJpbWFyeUNoaWxkcmVuXG4gIH07XG4gIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IG1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlcihwcmltYXJ5Q2hpbGRQcm9wcywgZmliZXJNb2RlKTtcbiAgdmFyIGZhbGxiYWNrQ2hpbGRGcmFnbWVudCA9IGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KGZhbGxiYWNrQ2hpbGRyZW4sIGZpYmVyTW9kZSwgcmVuZGVyTGFuZXMsIG51bGwpOyAvLyBOZWVkcyBhIHBsYWNlbWVudCBlZmZlY3QgYmVjYXVzZSB0aGUgcGFyZW50ICh0aGUgU3VzcGVuc2VcbiAgLy8gYm91bmRhcnkpIGFscmVhZHkgbW91bnRlZCBidXQgdGhpcyBpcyBhIG5ldyBmaWJlci5cblxuICBmYWxsYmFja0NoaWxkRnJhZ21lbnQuZmxhZ3MgfD0gUGxhY2VtZW50O1xuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5yZXR1cm4gPSB3b3JrSW5Qcm9ncmVzcztcbiAgZmFsbGJhY2tDaGlsZEZyYWdtZW50LnJldHVybiA9IHdvcmtJblByb2dyZXNzO1xuICBwcmltYXJ5Q2hpbGRGcmFnbWVudC5zaWJsaW5nID0gZmFsbGJhY2tDaGlsZEZyYWdtZW50O1xuICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IHByaW1hcnlDaGlsZEZyYWdtZW50O1xuXG4gIHtcbiAgICAvLyBXZSB3aWxsIGhhdmUgZHJvcHBlZCB0aGUgZWZmZWN0IGxpc3Qgd2hpY2ggY29udGFpbnMgdGhlXG4gICAgLy8gZGVsZXRpb24uIFdlIG5lZWQgdG8gcmVjb25jaWxlIHRvIGRlbGV0ZSB0aGUgY3VycmVudCBjaGlsZC5cbiAgICByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgY3VycmVudC5jaGlsZCwgbnVsbCwgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgcmV0dXJuIGZhbGxiYWNrQ2hpbGRGcmFnbWVudDtcbn1cblxuZnVuY3Rpb24gbW91bnREZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQod29ya0luUHJvZ3Jlc3MsIHN1c3BlbnNlSW5zdGFuY2UsIHJlbmRlckxhbmVzKSB7XG4gIC8vIER1cmluZyB0aGUgZmlyc3QgcGFzcywgd2UnbGwgYmFpbCBvdXQgYW5kIG5vdCBkcmlsbCBpbnRvIHRoZSBjaGlsZHJlbi5cbiAgLy8gSW5zdGVhZCwgd2UnbGwgbGVhdmUgdGhlIGNvbnRlbnQgaW4gcGxhY2UgYW5kIHRyeSB0byBoeWRyYXRlIGl0IGxhdGVyLlxuICBpZiAoaXNTdXNwZW5zZUluc3RhbmNlRmFsbGJhY2soc3VzcGVuc2VJbnN0YW5jZSkpIHtcbiAgICAvLyBUaGlzIGlzIGEgY2xpZW50LW9ubHkgYm91bmRhcnkuIFNpbmNlIHdlIHdvbid0IGdldCBhbnkgY29udGVudCBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAvLyBmb3IgdGhpcywgd2UgbmVlZCB0byBzY2hlZHVsZSB0aGF0IGF0IGEgaGlnaGVyIHByaW9yaXR5IGJhc2VkIG9uIHdoZW4gaXQgd291bGRcbiAgICAvLyBoYXZlIHRpbWVkIG91dC4gSW4gdGhlb3J5IHdlIGNvdWxkIHJlbmRlciBpdCBpbiB0aGlzIHBhc3MgYnV0IGl0IHdvdWxkIGhhdmUgdGhlXG4gICAgLy8gd3JvbmcgcHJpb3JpdHkgYXNzb2NpYXRlZCB3aXRoIGl0IGFuZCB3aWxsIHByZXZlbnQgaHlkcmF0aW9uIG9mIHBhcmVudCBwYXRoLlxuICAgIC8vIEluc3RlYWQsIHdlJ2xsIGxlYXZlIHdvcmsgbGVmdCBvbiBpdCB0byByZW5kZXIgaXQgaW4gYSBzZXBhcmF0ZSBjb21taXQuXG4gICAgLy8gVE9ETyBUaGlzIHRpbWUgc2hvdWxkIGJlIHRoZSB0aW1lIGF0IHdoaWNoIHRoZSBzZXJ2ZXIgcmVuZGVyZWQgcmVzcG9uc2UgdGhhdCBpc1xuICAgIC8vIGEgcGFyZW50IHRvIHRoaXMgYm91bmRhcnkgd2FzIGRpc3BsYXllZC4gSG93ZXZlciwgc2luY2Ugd2UgY3VycmVudGx5IGRvbid0IGhhdmVcbiAgICAvLyBhIHByb3RvY29sIHRvIHRyYW5zZmVyIHRoYXQgdGltZSwgd2UnbGwganVzdCBlc3RpbWF0ZSBpdCBieSB1c2luZyB0aGUgY3VycmVudFxuICAgIC8vIHRpbWUuIFRoaXMgd2lsbCBtZWFuIHRoYXQgU3VzcGVuc2UgdGltZW91dHMgYXJlIHNsaWdodGx5IHNoaWZ0ZWQgdG8gbGF0ZXIgdGhhblxuICAgIC8vIHRoZXkgc2hvdWxkIGJlLlxuICAgIC8vIFNjaGVkdWxlIGEgbm9ybWFsIHByaSB1cGRhdGUgdG8gcmVuZGVyIHRoaXMgY29udGVudC5cbiAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGxhbmVUb0xhbmVzKERlZmF1bHRIeWRyYXRpb25MYW5lKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBXZSdsbCBjb250aW51ZSBoeWRyYXRpbmcgdGhlIHJlc3QgYXQgb2Zmc2NyZWVuIHByaW9yaXR5IHNpbmNlIHdlJ2xsIGFscmVhZHlcbiAgICAvLyBiZSBzaG93aW5nIHRoZSByaWdodCBjb250ZW50IGNvbWluZyBmcm9tIHRoZSBzZXJ2ZXIsIGl0IGlzIG5vIHJ1c2guXG4gICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBsYW5lVG9MYW5lcyhPZmZzY3JlZW5MYW5lKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGRpZFN1c3BlbmQsIGRpZFByaW1hcnlDaGlsZHJlbkRlZmVyLCBuZXh0UHJvcHMsIHN1c3BlbnNlSW5zdGFuY2UsIHN1c3BlbnNlU3RhdGUsIHJlbmRlckxhbmVzKSB7XG4gIGlmICghZGlkU3VzcGVuZCkge1xuICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHJlbmRlciBwYXNzLiBBdHRlbXB0IHRvIGh5ZHJhdGUuXG4gICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTsgLy8gV2Ugc2hvdWxkIG5ldmVyIGJlIGh5ZHJhdGluZyBhdCB0aGlzIHBvaW50IGJlY2F1c2UgaXQgaXMgdGhlIGZpcnN0IHBhc3MsXG4gICAgLy8gYnV0IGFmdGVyIHdlJ3ZlIGFscmVhZHkgY29tbWl0dGVkIG9uY2UuXG5cbiAgICB3YXJuSWZIeWRyYXRpbmcoKTtcblxuICAgIGlmIChpc1N1c3BlbnNlSW5zdGFuY2VGYWxsYmFjayhzdXNwZW5zZUluc3RhbmNlKSkge1xuICAgICAgLy8gVGhpcyBib3VuZGFyeSBpcyBpbiBhIHBlcm1hbmVudCBmYWxsYmFjayBzdGF0ZS4gSW4gdGhpcyBjYXNlLCB3ZSdsbCBuZXZlclxuICAgICAgLy8gZ2V0IGFuIHVwZGF0ZSBhbmQgd2UnbGwgbmV2ZXIgYmUgYWJsZSB0byBoeWRyYXRlIHRoZSBmaW5hbCBjb250ZW50LiBMZXQncyBqdXN0IHRyeSB0aGVcbiAgICAgIC8vIGNsaWVudCBzaWRlIHJlbmRlciBpbnN0ZWFkLlxuICAgICAgdmFyIGRpZ2VzdDtcbiAgICAgIHZhciBtZXNzYWdlO1xuICAgICAgdmFyIHN0YWNrID0gbnVsbDtcbiAgICAgIHZhciBjb21wb25lbnRTdGFjayA9IG51bGw7XG5cbiAgICAgIHtcbiAgICAgICAgdmFyIF9nZXRTdXNwZW5zZUluc3RhbmNlRiA9IGdldFN1c3BlbnNlSW5zdGFuY2VGYWxsYmFja0Vycm9yRGV0YWlscyhzdXNwZW5zZUluc3RhbmNlKTtcblxuICAgICAgICBkaWdlc3QgPSBfZ2V0U3VzcGVuc2VJbnN0YW5jZUYuZGlnZXN0O1xuICAgICAgICBtZXNzYWdlID0gX2dldFN1c3BlbnNlSW5zdGFuY2VGLm1lc3NhZ2U7XG4gICAgICAgIHN0YWNrID0gX2dldFN1c3BlbnNlSW5zdGFuY2VGLnN0YWNrO1xuICAgICAgICBjb21wb25lbnRTdGFjayA9IF9nZXRTdXNwZW5zZUluc3RhbmNlRi5jb21wb25lbnRTdGFjaztcbiAgICAgIH0gLy8gVE9ETzogRmlndXJlIG91dCBhIGJldHRlciBzaWduYWwgdGhhbiBlbmNvZGluZyBhIG1hZ2ljIGRpZ2VzdCB2YWx1ZS5cblxuXG4gICAgICB7XG4gICAgICAgIHZhciBlcnJvcjtcblxuICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXJyb3IgPSBuZXcgRXJyb3IoJ1RoZSBzZXJ2ZXIgY291bGQgbm90IGZpbmlzaCB0aGlzIFN1c3BlbnNlIGJvdW5kYXJ5LCBsaWtlbHkgJyArICdkdWUgdG8gYW4gZXJyb3IgZHVyaW5nIHNlcnZlciByZW5kZXJpbmcuICcgKyAnU3dpdGNoZWQgdG8gY2xpZW50IHJlbmRlcmluZy4nKTtcbiAgICAgICAgfSAvLyBSZXBsYWNlIHRoZSBzdGFjayB3aXRoIHRoZSBzZXJ2ZXIgc3RhY2tcblxuXG4gICAgICAgIGVycm9yLnN0YWNrID0gc3RhY2sgfHwgJyc7XG4gICAgICAgIGVycm9yLmRpZ2VzdCA9IGRpZ2VzdDtcbiAgICAgICAgdmFyIGNhcHR1cmVkVmFsdWUgPSBjcmVhdGVDYXB0dXJlZFZhbHVlRnJvbUVycm9yKGVycm9yLCBjb21wb25lbnRTdGFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbXBvbmVudFN0YWNrKTtcbiAgICAgICAgcXVldWVIeWRyYXRpb25FcnJvcihjYXB0dXJlZFZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldHJ5U3VzcGVuc2VDb21wb25lbnRXaXRob3V0SHlkcmF0aW5nKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgfVxuICAgIC8vIGFueSBjb250ZXh0IGhhcyBjaGFuZ2VkLCB3ZSBuZWVkIHRvIHRyZWF0IGlzIGFzIGlmIHRoZSBpbnB1dCBtaWdodCBoYXZlIGNoYW5nZWQuXG5cblxuICAgIHZhciBoYXNDb250ZXh0Q2hhbmdlZCA9IGluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIGN1cnJlbnQuY2hpbGRMYW5lcyk7XG5cbiAgICBpZiAoZGlkUmVjZWl2ZVVwZGF0ZSB8fCBoYXNDb250ZXh0Q2hhbmdlZCkge1xuICAgICAgLy8gVGhpcyBib3VuZGFyeSBoYXMgY2hhbmdlZCBzaW5jZSB0aGUgZmlyc3QgcmVuZGVyLiBUaGlzIG1lYW5zIHRoYXQgd2UgYXJlIG5vdyB1bmFibGUgdG9cbiAgICAgIC8vIGh5ZHJhdGUgaXQuIFdlIG1pZ2h0IHN0aWxsIGJlIGFibGUgdG8gaHlkcmF0ZSBpdCB1c2luZyBhIGhpZ2hlciBwcmlvcml0eSBsYW5lLlxuICAgICAgdmFyIHJvb3QgPSBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKTtcblxuICAgICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGF0dGVtcHRIeWRyYXRpb25BdExhbmUgPSBnZXRCdW1wZWRMYW5lRm9ySHlkcmF0aW9uKHJvb3QsIHJlbmRlckxhbmVzKTtcblxuICAgICAgICBpZiAoYXR0ZW1wdEh5ZHJhdGlvbkF0TGFuZSAhPT0gTm9MYW5lICYmIGF0dGVtcHRIeWRyYXRpb25BdExhbmUgIT09IHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lKSB7XG4gICAgICAgICAgLy8gSW50ZW50aW9uYWxseSBtdXRhdGluZyBzaW5jZSB0aGlzIHJlbmRlciB3aWxsIGdldCBpbnRlcnJ1cHRlZC4gVGhpc1xuICAgICAgICAgIC8vIGlzIG9uZSBvZiB0aGUgdmVyeSByYXJlIHRpbWVzIHdoZXJlIHdlIG11dGF0ZSB0aGUgY3VycmVudCB0cmVlXG4gICAgICAgICAgLy8gZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UuXG4gICAgICAgICAgc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUgPSBhdHRlbXB0SHlkcmF0aW9uQXRMYW5lO1xuICAgICAgICAgIGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShjdXJyZW50LCBhdHRlbXB0SHlkcmF0aW9uQXRMYW5lKTtcbiAgICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgY3VycmVudCwgYXR0ZW1wdEh5ZHJhdGlvbkF0TGFuZSk7IC8vIFRocm93IGEgc3BlY2lhbCBvYmplY3QgdGhhdCBzaWduYWxzIHRvIHRoZSB3b3JrIGxvb3AgdGhhdCBpdCBzaG91bGRcbiAgICAgICAgICAvLyBpbnRlcnJ1cHQgdGhlIGN1cnJlbnQgcmVuZGVyLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gQmVjYXVzZSB3ZSdyZSBpbnNpZGUgYSBSZWFjdC1vbmx5IGV4ZWN1dGlvbiBzdGFjaywgd2UgZG9uJ3RcbiAgICAgICAgICAvLyBzdHJpY3RseSBuZWVkIHRvIHRocm93IGhlcmUg4oCUIHdlIGNvdWxkIGluc3RlYWQgbW9kaWZ5IHNvbWUgaW50ZXJuYWxcbiAgICAgICAgICAvLyB3b3JrIGxvb3Agc3RhdGUuIEJ1dCB1c2luZyBhbiBleGNlcHRpb24gbWVhbnMgd2UgZG9uJ3QgbmVlZCB0b1xuICAgICAgICAgIC8vIGNoZWNrIGZvciB0aGlzIGNhc2Ugb24gZXZlcnkgaXRlcmF0aW9uIG9mIHRoZSB3b3JrIGxvb3AuIFNvIGRvaW5nXG4gICAgICAgICAgLy8gaXQgdGhpcyB3YXkgbW92ZXMgdGhlIGNoZWNrIG91dCBvZiB0aGUgZmFzdCBwYXRoLlxuXG4gICAgICAgICAgdGhyb3cgU2VsZWN0aXZlSHlkcmF0aW9uRXhjZXB0aW9uO1xuICAgICAgICB9XG4gICAgICB9IC8vIElmIHdlIGRpZCBub3Qgc2VsZWN0aXZlbHkgaHlkcmF0ZSwgd2UnbGwgY29udGludWUgcmVuZGVyaW5nIHdpdGhvdXRcbiAgICAgIC8vIGh5ZHJhdGluZy4gTWFyayB0aGlzIHRyZWUgYXMgc3VzcGVuZGVkIHRvIHByZXZlbnQgaXQgZnJvbSBjb21taXR0aW5nXG4gICAgICAvLyBvdXRzaWRlIGEgdHJhbnNpdGlvbi5cbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIHBhdGggc2hvdWxkIG9ubHkgaGFwcGVuIGlmIHRoZSBoeWRyYXRpb24gbGFuZSBhbHJlYWR5IHN1c3BlbmRlZC5cbiAgICAgIC8vIEN1cnJlbnRseSwgaXQgYWxzbyBoYXBwZW5zIGR1cmluZyBzeW5jIHVwZGF0ZXMgYmVjYXVzZSB0aGVyZSBpcyBub1xuICAgICAgLy8gaHlkcmF0aW9uIGxhbmUgZm9yIHN5bmMgdXBkYXRlcy5cbiAgICAgIC8vIFRPRE86IFdlIHNob3VsZCBpZGVhbGx5IGhhdmUgYSBzeW5jIGh5ZHJhdGlvbiBsYW5lIHRoYXQgd2UgY2FuIGFwcGx5IHRvIGRvXG4gICAgICAvLyBhIHBhc3Mgd2hlcmUgd2UgaHlkcmF0ZSB0aGlzIHN1YnRyZWUgaW4gcGxhY2UgdXNpbmcgdGhlIHByZXZpb3VzIENvbnRleHQgYW5kIHRoZW5cbiAgICAgIC8vIHJlYXBwbHkgdGhlIHVwZGF0ZSBhZnRlcndhcmRzLlxuXG5cbiAgICAgIGlmIChpc1N1c3BlbnNlSW5zdGFuY2VQZW5kaW5nKHN1c3BlbnNlSW5zdGFuY2UpKSA7IGVsc2Uge1xuICAgICAgICByZW5kZXJEaWRTdXNwZW5kRGVsYXlJZlBvc3NpYmxlKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIH0gZWxzZSBpZiAoaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyhzdXNwZW5zZUluc3RhbmNlKSkge1xuICAgICAgLy8gVGhpcyBjb21wb25lbnQgaXMgc3RpbGwgcGVuZGluZyBtb3JlIGRhdGEgZnJvbSB0aGUgc2VydmVyLCBzbyB3ZSBjYW4ndCBoeWRyYXRlIGl0c1xuICAgICAgLy8gY29udGVudC4gV2UgdHJlYXQgaXQgYXMgaWYgdGhpcyBjb21wb25lbnQgc3VzcGVuZGVkIGl0c2VsZi4gSXQgbWlnaHQgc2VlbSBhcyBpZlxuICAgICAgLy8gd2UgY291bGQganVzdCB0cnkgdG8gcmVuZGVyIGl0IGNsaWVudC1zaWRlIGluc3RlYWQuIEhvd2V2ZXIsIHRoaXMgd2lsbCBwZXJmb3JtIGFcbiAgICAgIC8vIGxvdCBvZiB1bm5lY2Vzc2FyeSB3b3JrIGFuZCBpcyB1bmxpa2VseSB0byBjb21wbGV0ZSBzaW5jZSBpdCBvZnRlbiB3aWxsIHN1c3BlbmRcbiAgICAgIC8vIG9uIG1pc3NpbmcgZGF0YSBhbnl3YXkuIEFkZGl0aW9uYWxseSwgdGhlIHNlcnZlciBtaWdodCBiZSBhYmxlIHRvIHJlbmRlciBtb3JlXG4gICAgICAvLyB0aGFuIHdlIGNhbiBvbiB0aGUgY2xpZW50IHlldC4gSW4gdGhhdCBjYXNlIHdlJ2QgZW5kIHVwIHdpdGggbW9yZSBmYWxsYmFjayBzdGF0ZXNcbiAgICAgIC8vIG9uIHRoZSBjbGllbnQgdGhhbiBpZiB3ZSBqdXN0IGxlYXZlIGl0IGFsb25lLiBJZiB0aGUgc2VydmVyIHRpbWVzIG91dCBvciBlcnJvcnNcbiAgICAgIC8vIHRoZXNlIHNob3VsZCB1cGRhdGUgdGhpcyBib3VuZGFyeSB0byB0aGUgcGVybWFuZW50IEZhbGxiYWNrIHN0YXRlIGluc3RlYWQuXG4gICAgICAvLyBNYXJrIGl0IGFzIGhhdmluZyBjYXB0dXJlZCAoaS5lLiBzdXNwZW5kZWQpLlxuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTsgLy8gTGVhdmUgdGhlIGNoaWxkIGluIHBsYWNlLiBJLmUuIHRoZSBkZWh5ZHJhdGVkIGZyYWdtZW50LlxuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7IC8vIFJlZ2lzdGVyIGEgY2FsbGJhY2sgdG8gcmV0cnkgdGhpcyBib3VuZGFyeSBvbmNlIHRoZSBzZXJ2ZXIgaGFzIHNlbnQgdGhlIHJlc3VsdC5cblxuICAgICAgdmFyIHJldHJ5ID0gcmV0cnlEZWh5ZHJhdGVkU3VzcGVuc2VCb3VuZGFyeS5iaW5kKG51bGwsIGN1cnJlbnQpO1xuICAgICAgcmVnaXN0ZXJTdXNwZW5zZUluc3RhbmNlUmV0cnkoc3VzcGVuc2VJbnN0YW5jZSwgcmV0cnkpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IGF0dGVtcHQuXG4gICAgICByZWVudGVySHlkcmF0aW9uU3RhdGVGcm9tRGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2Uod29ya0luUHJvZ3Jlc3MsIHN1c3BlbnNlSW5zdGFuY2UsIHN1c3BlbnNlU3RhdGUudHJlZUNvbnRleHQpO1xuICAgICAgdmFyIHByaW1hcnlDaGlsZHJlbiA9IG5leHRQcm9wcy5jaGlsZHJlbjtcbiAgICAgIHZhciBwcmltYXJ5Q2hpbGRGcmFnbWVudCA9IG1vdW50U3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4od29ya0luUHJvZ3Jlc3MsIHByaW1hcnlDaGlsZHJlbik7IC8vIE1hcmsgdGhlIGNoaWxkcmVuIGFzIGh5ZHJhdGluZy4gVGhpcyBpcyBhIGZhc3QgcGF0aCB0byBrbm93IHdoZXRoZXIgdGhpc1xuICAgICAgLy8gdHJlZSBpcyBwYXJ0IG9mIGEgaHlkcmF0aW5nIHRyZWUuIFRoaXMgaXMgdXNlZCB0byBkZXRlcm1pbmUgaWYgYSBjaGlsZFxuICAgICAgLy8gbm9kZSBoYXMgZnVsbHkgbW91bnRlZCB5ZXQsIGFuZCBmb3Igc2NoZWR1bGluZyBldmVudCByZXBsYXlpbmcuXG4gICAgICAvLyBDb25jZXB0dWFsbHkgdGhpcyBpcyBzaW1pbGFyIHRvIFBsYWNlbWVudCBpbiB0aGF0IGEgbmV3IHN1YnRyZWUgaXNcbiAgICAgIC8vIGluc2VydGVkIGludG8gdGhlIFJlYWN0IHRyZWUgaGVyZS4gSXQganVzdCBoYXBwZW5zIHRvIG5vdCBuZWVkIERPTVxuICAgICAgLy8gbXV0YXRpb25zIGJlY2F1c2UgaXQgYWxyZWFkeSBleGlzdHMuXG5cbiAgICAgIHByaW1hcnlDaGlsZEZyYWdtZW50LmZsYWdzIHw9IEh5ZHJhdGluZztcbiAgICAgIHJldHVybiBwcmltYXJ5Q2hpbGRGcmFnbWVudDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgc2Vjb25kIHJlbmRlciBwYXNzLiBXZSBhbHJlYWR5IGF0dGVtcHRlZCB0byBoeWRyYXRlZCwgYnV0XG4gICAgLy8gc29tZXRoaW5nIGVpdGhlciBzdXNwZW5kZWQgb3IgZXJyb3JlZC5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBGb3JjZUNsaWVudFJlbmRlcikge1xuICAgICAgLy8gU29tZXRoaW5nIGVycm9yZWQgZHVyaW5nIGh5ZHJhdGlvbi4gVHJ5IGFnYWluIHdpdGhvdXQgaHlkcmF0aW5nLlxuICAgICAgLy8gVGhlIGVycm9yIHNob3VsZCd2ZSBhbHJlYWR5IGJlZW4gbG9nZ2VkIGluIHRocm93RXhjZXB0aW9uLlxuICAgICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IH5Gb3JjZUNsaWVudFJlbmRlcjtcbiAgICAgIHJldHVybiByZXRyeVN1c3BlbnNlQ29tcG9uZW50V2l0aG91dEh5ZHJhdGluZyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgIH0gZWxzZSBpZiAod29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgLy8gU29tZXRoaW5nIHN1c3BlbmRlZCBhbmQgd2Ugc2hvdWxkIHN0aWxsIGJlIGluIGRlaHlkcmF0ZWQgbW9kZS5cbiAgICAgIC8vIExlYXZlIHRoZSBleGlzdGluZyBjaGlsZCBpbiBwbGFjZS5cbiAgICAgIC8vIFB1c2ggdG8gYXZvaWQgYSBtaXNtYXRjaFxuICAgICAgcHVzaEZhbGxiYWNrVHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IGN1cnJlbnQuY2hpbGQ7IC8vIFRoZSBkZWh5ZHJhdGVkIGNvbXBsZXRpb24gcGFzcyBleHBlY3RzIHRoaXMgZmxhZyB0byBiZSB0aGVyZVxuICAgICAgLy8gYnV0IHRoZSBub3JtYWwgc3VzcGVuc2UgcGFzcyBkb2Vzbid0LlxuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFN1c3BlbmRlZCBidXQgd2Ugc2hvdWxkIG5vIGxvbmdlciBiZSBpbiBkZWh5ZHJhdGVkIG1vZGUuXG4gICAgICAvLyBUaGVyZWZvcmUgd2Ugbm93IGhhdmUgdG8gcmVuZGVyIHRoZSBmYWxsYmFjay5cbiAgICAgIHB1c2hGYWxsYmFja1RyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgdmFyIG5leHRQcmltYXJ5Q2hpbGRyZW4gPSBuZXh0UHJvcHMuY2hpbGRyZW47XG4gICAgICB2YXIgbmV4dEZhbGxiYWNrQ2hpbGRyZW4gPSBuZXh0UHJvcHMuZmFsbGJhY2s7XG4gICAgICB2YXIgZmFsbGJhY2tDaGlsZEZyYWdtZW50ID0gbW91bnRTdXNwZW5zZUZhbGxiYWNrQWZ0ZXJSZXRyeVdpdGhvdXRIeWRyYXRpbmcoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRQcmltYXJ5Q2hpbGRyZW4sIG5leHRGYWxsYmFja0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gICAgICB2YXIgX3ByaW1hcnlDaGlsZEZyYWdtZW50NCA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgX3ByaW1hcnlDaGlsZEZyYWdtZW50NC5tZW1vaXplZFN0YXRlID0gbW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlKHJlbmRlckxhbmVzKTtcbiAgICAgIF9wcmltYXJ5Q2hpbGRGcmFnbWVudDQuY2hpbGRMYW5lcyA9IGdldFJlbWFpbmluZ1dvcmtJblByaW1hcnlUcmVlKGN1cnJlbnQsIGRpZFByaW1hcnlDaGlsZHJlbkRlZmVyLCByZW5kZXJMYW5lcyk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gU1VTUEVOREVEX01BUktFUjtcbiAgICAgIHJldHVybiBmYWxsYmFja0NoaWxkRnJhZ21lbnQ7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihmaWJlciwgcmVuZGVyTGFuZXMsIHByb3BhZ2F0aW9uUm9vdCkge1xuICBmaWJlci5sYW5lcyA9IG1lcmdlTGFuZXMoZmliZXIubGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgYWx0ZXJuYXRlLmxhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUubGFuZXMsIHJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgoZmliZXIucmV0dXJuLCByZW5kZXJMYW5lcywgcHJvcGFnYXRpb25Sb290KTtcbn1cblxuZnVuY3Rpb24gcHJvcGFnYXRlU3VzcGVuc2VDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBmaXJzdENoaWxkLCByZW5kZXJMYW5lcykge1xuICAvLyBNYXJrIGFueSBTdXNwZW5zZSBib3VuZGFyaWVzIHdpdGggZmFsbGJhY2tzIGFzIGhhdmluZyB3b3JrIHRvIGRvLlxuICAvLyBJZiB0aGV5IHdlcmUgcHJldmlvdXNseSBmb3JjZWQgaW50byBmYWxsYmFja3MsIHRoZXkgbWF5IG5vdyBiZSBhYmxlXG4gIC8vIHRvIHVuYmxvY2suXG4gIHZhciBub2RlID0gZmlyc3RDaGlsZDtcblxuICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgIGlmIChub2RlLnRhZyA9PT0gU3VzcGVuc2VDb21wb25lbnQpIHtcbiAgICAgIHZhciBzdGF0ZSA9IG5vZGUubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgaWYgKHN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgIHNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlcihub2RlLCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobm9kZS50YWcgPT09IFN1c3BlbnNlTGlzdENvbXBvbmVudCkge1xuICAgICAgLy8gSWYgdGhlIHRhaWwgaXMgaGlkZGVuIHRoZXJlIG1pZ2h0IG5vdCBiZSBhbiBTdXNwZW5zZSBib3VuZGFyaWVzXG4gICAgICAvLyB0byBzY2hlZHVsZSB3b3JrIG9uLiBJbiB0aGlzIGNhc2Ugd2UgaGF2ZSB0byBzY2hlZHVsZSBpdCBvbiB0aGVcbiAgICAgIC8vIGxpc3QgaXRzZWxmLlxuICAgICAgLy8gV2UgZG9uJ3QgaGF2ZSB0byB0cmF2ZXJzZSB0byB0aGUgY2hpbGRyZW4gb2YgdGhlIGxpc3Qgc2luY2VcbiAgICAgIC8vIHRoZSBsaXN0IHdpbGwgcHJvcGFnYXRlIHRoZSBjaGFuZ2Ugd2hlbiBpdCByZXJlbmRlcnMuXG4gICAgICBzY2hlZHVsZVN1c3BlbnNlV29ya09uRmliZXIobm9kZSwgcmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzKTtcbiAgICB9IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRMYXN0Q29udGVudFJvdyhmaXJzdENoaWxkKSB7XG4gIC8vIFRoaXMgaXMgZ29pbmcgdG8gZmluZCB0aGUgbGFzdCByb3cgYW1vbmcgdGhlc2UgY2hpbGRyZW4gdGhhdCBpcyBhbHJlYWR5XG4gIC8vIHNob3dpbmcgY29udGVudCBvbiB0aGUgc2NyZWVuLCBhcyBvcHBvc2VkIHRvIGJlaW5nIGluIGZhbGxiYWNrIHN0YXRlIG9yXG4gIC8vIG5ldy4gSWYgYSByb3cgaGFzIG11bHRpcGxlIFN1c3BlbnNlIGJvdW5kYXJpZXMsIGFueSBvZiB0aGVtIGJlaW5nIGluIHRoZVxuICAvLyBmYWxsYmFjayBzdGF0ZSwgY291bnRzIGFzIHRoZSB3aG9sZSByb3cgYmVpbmcgaW4gYSBmYWxsYmFjayBzdGF0ZS5cbiAgLy8gTm90ZSB0aGF0IHRoZSBcInJvd3NcIiB3aWxsIGJlIHdvcmtJblByb2dyZXNzLCBidXQgYW55IG5lc3RlZCBjaGlsZHJlblxuICAvLyB3aWxsIHN0aWxsIGJlIGN1cnJlbnQgc2luY2Ugd2UgaGF2ZW4ndCByZW5kZXJlZCB0aGVtIHlldC4gVGhlIG1vdW50ZWRcbiAgLy8gb3JkZXIgbWF5IG5vdCBiZSB0aGUgc2FtZSBhcyB0aGUgbmV3IG9yZGVyLiBXZSB1c2UgdGhlIG5ldyBvcmRlci5cbiAgdmFyIHJvdyA9IGZpcnN0Q2hpbGQ7XG4gIHZhciBsYXN0Q29udGVudFJvdyA9IG51bGw7XG5cbiAgd2hpbGUgKHJvdyAhPT0gbnVsbCkge1xuICAgIHZhciBjdXJyZW50Um93ID0gcm93LmFsdGVybmF0ZTsgLy8gTmV3IHJvd3MgY2FuJ3QgYmUgY29udGVudCByb3dzLlxuXG4gICAgaWYgKGN1cnJlbnRSb3cgIT09IG51bGwgJiYgZmluZEZpcnN0U3VzcGVuZGVkKGN1cnJlbnRSb3cpID09PSBudWxsKSB7XG4gICAgICBsYXN0Q29udGVudFJvdyA9IHJvdztcbiAgICB9XG5cbiAgICByb3cgPSByb3cuc2libGluZztcbiAgfVxuXG4gIHJldHVybiBsYXN0Q29udGVudFJvdztcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVSZXZlYWxPcmRlcihyZXZlYWxPcmRlcikge1xuICB7XG4gICAgaWYgKHJldmVhbE9yZGVyICE9PSB1bmRlZmluZWQgJiYgcmV2ZWFsT3JkZXIgIT09ICdmb3J3YXJkcycgJiYgcmV2ZWFsT3JkZXIgIT09ICdiYWNrd2FyZHMnICYmIHJldmVhbE9yZGVyICE9PSAndG9nZXRoZXInICYmICFkaWRXYXJuQWJvdXRSZXZlYWxPcmRlcltyZXZlYWxPcmRlcl0pIHtcbiAgICAgIGRpZFdhcm5BYm91dFJldmVhbE9yZGVyW3JldmVhbE9yZGVyXSA9IHRydWU7XG5cbiAgICAgIGlmICh0eXBlb2YgcmV2ZWFsT3JkZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHN3aXRjaCAocmV2ZWFsT3JkZXIudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIGNhc2UgJ3RvZ2V0aGVyJzpcbiAgICAgICAgICBjYXNlICdmb3J3YXJkcyc6XG4gICAgICAgICAgY2FzZSAnYmFja3dhcmRzJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ1wiJXNcIiBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gJyArICdVc2UgbG93ZXJjYXNlIFwiJXNcIiBpbnN0ZWFkLicsIHJldmVhbE9yZGVyLCByZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpKTtcblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgJ2ZvcndhcmQnOlxuICAgICAgICAgIGNhc2UgJ2JhY2t3YXJkJzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ1wiJXNcIiBpcyBub3QgYSB2YWxpZCB2YWx1ZSBmb3IgcmV2ZWFsT3JkZXIgb24gPFN1c3BlbnNlTGlzdCAvPi4gJyArICdSZWFjdCB1c2VzIHRoZSAtcyBzdWZmaXggaW4gdGhlIHNwZWxsaW5nLiBVc2UgXCIlc3NcIiBpbnN0ZWFkLicsIHJldmVhbE9yZGVyLCByZXZlYWxPcmRlci50b0xvd2VyQ2FzZSgpKTtcblxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBlcnJvcignXCIlc1wiIGlzIG5vdCBhIHN1cHBvcnRlZCByZXZlYWxPcmRlciBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnICsgJ0RpZCB5b3UgbWVhbiBcInRvZ2V0aGVyXCIsIFwiZm9yd2FyZHNcIiBvciBcImJhY2t3YXJkc1wiPycsIHJldmVhbE9yZGVyKTtcblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVycm9yKCclcyBpcyBub3QgYSBzdXBwb3J0ZWQgdmFsdWUgZm9yIHJldmVhbE9yZGVyIG9uIDxTdXNwZW5zZUxpc3QgLz4uICcgKyAnRGlkIHlvdSBtZWFuIFwidG9nZXRoZXJcIiwgXCJmb3J3YXJkc1wiIG9yIFwiYmFja3dhcmRzXCI/JywgcmV2ZWFsT3JkZXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVRhaWxPcHRpb25zKHRhaWxNb2RlLCByZXZlYWxPcmRlcikge1xuICB7XG4gICAgaWYgKHRhaWxNb2RlICE9PSB1bmRlZmluZWQgJiYgIWRpZFdhcm5BYm91dFRhaWxPcHRpb25zW3RhaWxNb2RlXSkge1xuICAgICAgaWYgKHRhaWxNb2RlICE9PSAnY29sbGFwc2VkJyAmJiB0YWlsTW9kZSAhPT0gJ2hpZGRlbicpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignXCIlc1wiIGlzIG5vdCBhIHN1cHBvcnRlZCB2YWx1ZSBmb3IgdGFpbCBvbiA8U3VzcGVuc2VMaXN0IC8+LiAnICsgJ0RpZCB5b3UgbWVhbiBcImNvbGxhcHNlZFwiIG9yIFwiaGlkZGVuXCI/JywgdGFpbE1vZGUpO1xuICAgICAgfSBlbHNlIGlmIChyZXZlYWxPcmRlciAhPT0gJ2ZvcndhcmRzJyAmJiByZXZlYWxPcmRlciAhPT0gJ2JhY2t3YXJkcycpIHtcbiAgICAgICAgZGlkV2FybkFib3V0VGFpbE9wdGlvbnNbdGFpbE1vZGVdID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignPFN1c3BlbnNlTGlzdCB0YWlsPVwiJXNcIiAvPiBpcyBvbmx5IHZhbGlkIGlmIHJldmVhbE9yZGVyIGlzICcgKyAnXCJmb3J3YXJkc1wiIG9yIFwiYmFja3dhcmRzXCIuICcgKyAnRGlkIHlvdSBtZWFuIHRvIHNwZWNpZnkgcmV2ZWFsT3JkZXI9XCJmb3J3YXJkc1wiPycsIHRhaWxNb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZChjaGlsZFNsb3QsIGluZGV4KSB7XG4gIHtcbiAgICB2YXIgaXNBbkFycmF5ID0gaXNBcnJheShjaGlsZFNsb3QpO1xuICAgIHZhciBpc0l0ZXJhYmxlID0gIWlzQW5BcnJheSAmJiB0eXBlb2YgZ2V0SXRlcmF0b3JGbihjaGlsZFNsb3QpID09PSAnZnVuY3Rpb24nO1xuXG4gICAgaWYgKGlzQW5BcnJheSB8fCBpc0l0ZXJhYmxlKSB7XG4gICAgICB2YXIgdHlwZSA9IGlzQW5BcnJheSA/ICdhcnJheScgOiAnaXRlcmFibGUnO1xuXG4gICAgICBlcnJvcignQSBuZXN0ZWQgJXMgd2FzIHBhc3NlZCB0byByb3cgIyVzIGluIDxTdXNwZW5zZUxpc3QgLz4uIFdyYXAgaXQgaW4gJyArICdhbiBhZGRpdGlvbmFsIFN1c3BlbnNlTGlzdCB0byBjb25maWd1cmUgaXRzIHJldmVhbE9yZGVyOiAnICsgJzxTdXNwZW5zZUxpc3QgcmV2ZWFsT3JkZXI9Li4uPiAuLi4gJyArICc8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPS4uLj57JXN9PC9TdXNwZW5zZUxpc3Q+IC4uLiAnICsgJzwvU3VzcGVuc2VMaXN0PicsIHR5cGUsIGluZGV4LCB0eXBlKTtcblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVN1c3BlbnNlTGlzdENoaWxkcmVuKGNoaWxkcmVuLCByZXZlYWxPcmRlcikge1xuICB7XG4gICAgaWYgKChyZXZlYWxPcmRlciA9PT0gJ2ZvcndhcmRzJyB8fCByZXZlYWxPcmRlciA9PT0gJ2JhY2t3YXJkcycpICYmIGNoaWxkcmVuICE9PSB1bmRlZmluZWQgJiYgY2hpbGRyZW4gIT09IG51bGwgJiYgY2hpbGRyZW4gIT09IGZhbHNlKSB7XG4gICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmICghdmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZChjaGlsZHJlbltpXSwgaSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihjaGlsZHJlbik7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdmFyIGNoaWxkcmVuSXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO1xuXG4gICAgICAgICAgaWYgKGNoaWxkcmVuSXRlcmF0b3IpIHtcbiAgICAgICAgICAgIHZhciBzdGVwID0gY2hpbGRyZW5JdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICB2YXIgX2kgPSAwO1xuXG4gICAgICAgICAgICBmb3IgKDsgIXN0ZXAuZG9uZTsgc3RlcCA9IGNoaWxkcmVuSXRlcmF0b3IubmV4dCgpKSB7XG4gICAgICAgICAgICAgIGlmICghdmFsaWRhdGVTdXNwZW5zZUxpc3ROZXN0ZWRDaGlsZChzdGVwLnZhbHVlLCBfaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBfaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlcnJvcignQSBzaW5nbGUgcm93IHdhcyBwYXNzZWQgdG8gYSA8U3VzcGVuc2VMaXN0IHJldmVhbE9yZGVyPVwiJXNcIiAvPi4gJyArICdUaGlzIGlzIG5vdCB1c2VmdWwgc2luY2UgaXQgbmVlZHMgbXVsdGlwbGUgcm93cy4gJyArICdEaWQgeW91IG1lYW4gdG8gcGFzcyBtdWx0aXBsZSBjaGlsZHJlbiBvciBhbiBhcnJheT8nLCByZXZlYWxPcmRlcik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKHdvcmtJblByb2dyZXNzLCBpc0JhY2t3YXJkcywgdGFpbCwgbGFzdENvbnRlbnRSb3csIHRhaWxNb2RlKSB7XG4gIHZhciByZW5kZXJTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKHJlbmRlclN0YXRlID09PSBudWxsKSB7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IHtcbiAgICAgIGlzQmFja3dhcmRzOiBpc0JhY2t3YXJkcyxcbiAgICAgIHJlbmRlcmluZzogbnVsbCxcbiAgICAgIHJlbmRlcmluZ1N0YXJ0VGltZTogMCxcbiAgICAgIGxhc3Q6IGxhc3RDb250ZW50Um93LFxuICAgICAgdGFpbDogdGFpbCxcbiAgICAgIHRhaWxNb2RlOiB0YWlsTW9kZVxuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgLy8gV2UgY2FuIHJldXNlIHRoZSBleGlzdGluZyBvYmplY3QgZnJvbSBwcmV2aW91cyByZW5kZXJzLlxuICAgIHJlbmRlclN0YXRlLmlzQmFja3dhcmRzID0gaXNCYWNrd2FyZHM7XG4gICAgcmVuZGVyU3RhdGUucmVuZGVyaW5nID0gbnVsbDtcbiAgICByZW5kZXJTdGF0ZS5yZW5kZXJpbmdTdGFydFRpbWUgPSAwO1xuICAgIHJlbmRlclN0YXRlLmxhc3QgPSBsYXN0Q29udGVudFJvdztcbiAgICByZW5kZXJTdGF0ZS50YWlsID0gdGFpbDtcbiAgICByZW5kZXJTdGF0ZS50YWlsTW9kZSA9IHRhaWxNb2RlO1xuICB9XG59IC8vIFRoaXMgY2FuIGVuZCB1cCByZW5kZXJpbmcgdGhpcyBjb21wb25lbnQgbXVsdGlwbGUgcGFzc2VzLlxuLy8gVGhlIGZpcnN0IHBhc3Mgc3BsaXRzIHRoZSBjaGlsZHJlbiBmaWJlcnMgaW50byB0d28gc2V0cy4gQSBoZWFkIGFuZCB0YWlsLlxuLy8gV2UgZmlyc3QgcmVuZGVyIHRoZSBoZWFkLiBJZiBhbnl0aGluZyBpcyBpbiBmYWxsYmFjayBzdGF0ZSwgd2UgZG8gYW5vdGhlclxuLy8gcGFzcyB0aHJvdWdoIGJlZ2luV29yayB0byByZXJlbmRlciBhbGwgY2hpbGRyZW4gKGluY2x1ZGluZyB0aGUgdGFpbCkgd2l0aFxuLy8gdGhlIGZvcmNlIHN1c3BlbmQgY29udGV4dC4gSWYgdGhlIGZpcnN0IHJlbmRlciBkaWRuJ3QgaGF2ZSBhbnl0aGluZyBpblxuLy8gaW4gZmFsbGJhY2sgc3RhdGUuIFRoZW4gd2UgcmVuZGVyIGVhY2ggcm93IGluIHRoZSB0YWlsIG9uZS1ieS1vbmUuXG4vLyBUaGF0IGhhcHBlbnMgaW4gdGhlIGNvbXBsZXRlV29yayBwaGFzZSB3aXRob3V0IGdvaW5nIGJhY2sgdG8gYmVnaW5Xb3JrLlxuXG5cbmZ1bmN0aW9uIHVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG5leHRQcm9wcyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcbiAgdmFyIHJldmVhbE9yZGVyID0gbmV4dFByb3BzLnJldmVhbE9yZGVyO1xuICB2YXIgdGFpbE1vZGUgPSBuZXh0UHJvcHMudGFpbDtcbiAgdmFyIG5ld0NoaWxkcmVuID0gbmV4dFByb3BzLmNoaWxkcmVuO1xuICB2YWxpZGF0ZVJldmVhbE9yZGVyKHJldmVhbE9yZGVyKTtcbiAgdmFsaWRhdGVUYWlsT3B0aW9ucyh0YWlsTW9kZSwgcmV2ZWFsT3JkZXIpO1xuICB2YWxpZGF0ZVN1c3BlbnNlTGlzdENoaWxkcmVuKG5ld0NoaWxkcmVuLCByZXZlYWxPcmRlcik7XG4gIHJlY29uY2lsZUNoaWxkcmVuKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXdDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICB2YXIgc3VzcGVuc2VDb250ZXh0ID0gc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50O1xuICB2YXIgc2hvdWxkRm9yY2VGYWxsYmFjayA9IGhhc1N1c3BlbnNlTGlzdENvbnRleHQoc3VzcGVuc2VDb250ZXh0LCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spO1xuXG4gIGlmIChzaG91bGRGb3JjZUZhbGxiYWNrKSB7XG4gICAgc3VzcGVuc2VDb250ZXh0ID0gc2V0U2hhbGxvd1N1c3BlbnNlTGlzdENvbnRleHQoc3VzcGVuc2VDb250ZXh0LCBGb3JjZVN1c3BlbnNlRmFsbGJhY2spO1xuICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRpZFN1c3BlbmRCZWZvcmUgPSBjdXJyZW50ICE9PSBudWxsICYmIChjdXJyZW50LmZsYWdzICYgRGlkQ2FwdHVyZSkgIT09IE5vRmxhZ3MkMTtcblxuICAgIGlmIChkaWRTdXNwZW5kQmVmb3JlKSB7XG4gICAgICAvLyBJZiB3ZSBwcmV2aW91c2x5IGZvcmNlZCBhIGZhbGxiYWNrLCB3ZSBuZWVkIHRvIHNjaGVkdWxlIHdvcmtcbiAgICAgIC8vIG9uIGFueSBuZXN0ZWQgYm91bmRhcmllcyB0byBsZXQgdGhlbSBrbm93IHRvIHRyeSB0byByZW5kZXJcbiAgICAgIC8vIGFnYWluLiBUaGlzIGlzIHRoZSBzYW1lIGFzIGNvbnRleHQgdXBkYXRpbmcuXG4gICAgICBwcm9wYWdhdGVTdXNwZW5zZUNvbnRleHRDaGFuZ2Uod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLmNoaWxkLCByZW5kZXJMYW5lcyk7XG4gICAgfVxuXG4gICAgc3VzcGVuc2VDb250ZXh0ID0gc2V0RGVmYXVsdFNoYWxsb3dTdXNwZW5zZUxpc3RDb250ZXh0KHN1c3BlbnNlQ29udGV4dCk7XG4gIH1cblxuICBwdXNoU3VzcGVuc2VMaXN0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VDb250ZXh0KTtcblxuICB7XG4gICAgc3dpdGNoIChyZXZlYWxPcmRlcikge1xuICAgICAgY2FzZSAnZm9yd2FyZHMnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhc3RDb250ZW50Um93ID0gZmluZExhc3RDb250ZW50Um93KHdvcmtJblByb2dyZXNzLmNoaWxkKTtcbiAgICAgICAgICB2YXIgdGFpbDtcblxuICAgICAgICAgIGlmIChsYXN0Q29udGVudFJvdyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gVGhlIHdob2xlIGxpc3QgaXMgcGFydCBvZiB0aGUgdGFpbC5cbiAgICAgICAgICAgIC8vIFRPRE86IFdlIGNvdWxkIGZhc3QgcGF0aCBieSBqdXN0IHJlbmRlcmluZyB0aGUgdGFpbCBub3cuXG4gICAgICAgICAgICB0YWlsID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5jaGlsZCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIERpc2Nvbm5lY3QgdGhlIHRhaWwgcm93cyBhZnRlciB0aGUgY29udGVudCByb3cuXG4gICAgICAgICAgICAvLyBXZSdyZSBnb2luZyB0byByZW5kZXIgdGhlbSBzZXBhcmF0ZWx5IGxhdGVyLlxuICAgICAgICAgICAgdGFpbCA9IGxhc3RDb250ZW50Um93LnNpYmxpbmc7XG4gICAgICAgICAgICBsYXN0Q29udGVudFJvdy5zaWJsaW5nID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUod29ya0luUHJvZ3Jlc3MsIGZhbHNlLCAvLyBpc0JhY2t3YXJkc1xuICAgICAgICAgIHRhaWwsIGxhc3RDb250ZW50Um93LCB0YWlsTW9kZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnYmFja3dhcmRzJzpcbiAgICAgICAge1xuICAgICAgICAgIC8vIFdlJ3JlIGdvaW5nIHRvIGZpbmQgdGhlIGZpcnN0IHJvdyB0aGF0IGhhcyBleGlzdGluZyBjb250ZW50LlxuICAgICAgICAgIC8vIEF0IHRoZSBzYW1lIHRpbWUgd2UncmUgZ29pbmcgdG8gcmV2ZXJzZSB0aGUgbGlzdCBvZiBldmVyeXRoaW5nXG4gICAgICAgICAgLy8gd2UgcGFzcyBpbiB0aGUgbWVhbnRpbWUuIFRoYXQncyBnb2luZyB0byBiZSBvdXIgdGFpbCBpbiByZXZlcnNlXG4gICAgICAgICAgLy8gb3JkZXIuXG4gICAgICAgICAgdmFyIF90YWlsID0gbnVsbDtcbiAgICAgICAgICB2YXIgcm93ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuXG4gICAgICAgICAgd2hpbGUgKHJvdyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRSb3cgPSByb3cuYWx0ZXJuYXRlOyAvLyBOZXcgcm93cyBjYW4ndCBiZSBjb250ZW50IHJvd3MuXG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50Um93ICE9PSBudWxsICYmIGZpbmRGaXJzdFN1c3BlbmRlZChjdXJyZW50Um93KSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBiZWdpbm5pbmcgb2YgdGhlIG1haW4gY29udGVudC5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByb3c7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmV4dFJvdyA9IHJvdy5zaWJsaW5nO1xuICAgICAgICAgICAgcm93LnNpYmxpbmcgPSBfdGFpbDtcbiAgICAgICAgICAgIF90YWlsID0gcm93O1xuICAgICAgICAgICAgcm93ID0gbmV4dFJvdztcbiAgICAgICAgICB9IC8vIFRPRE86IElmIHdvcmtJblByb2dyZXNzLmNoaWxkIGlzIG51bGwsIHdlIGNhbiBjb250aW51ZSBvbiB0aGUgdGFpbCBpbW1lZGlhdGVseS5cblxuXG4gICAgICAgICAgaW5pdFN1c3BlbnNlTGlzdFJlbmRlclN0YXRlKHdvcmtJblByb2dyZXNzLCB0cnVlLCAvLyBpc0JhY2t3YXJkc1xuICAgICAgICAgIF90YWlsLCBudWxsLCAvLyBsYXN0XG4gICAgICAgICAgdGFpbE1vZGUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3RvZ2V0aGVyJzpcbiAgICAgICAge1xuICAgICAgICAgIGluaXRTdXNwZW5zZUxpc3RSZW5kZXJTdGF0ZSh3b3JrSW5Qcm9ncmVzcywgZmFsc2UsIC8vIGlzQmFja3dhcmRzXG4gICAgICAgICAgbnVsbCwgLy8gdGFpbFxuICAgICAgICAgIG51bGwsIC8vIGxhc3RcbiAgICAgICAgICB1bmRlZmluZWQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICAvLyBUaGUgZGVmYXVsdCByZXZlYWwgb3JkZXIgaXMgdGhlIHNhbWUgYXMgbm90IGhhdmluZ1xuICAgICAgICAgIC8vIGEgYm91bmRhcnkuXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVBvcnRhbENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgcHVzaEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgdmFyIG5leHRDaGlsZHJlbiA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcztcblxuICBpZiAoY3VycmVudCA9PT0gbnVsbCkge1xuICAgIC8vIFBvcnRhbHMgYXJlIHNwZWNpYWwgYmVjYXVzZSB3ZSBkb24ndCBhcHBlbmQgdGhlIGNoaWxkcmVuIGR1cmluZyBtb3VudFxuICAgIC8vIGJ1dCBhdCBjb21taXQuIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIHRyYWNrIGluc2VydGlvbnMgd2hpY2ggdGhlIG5vcm1hbFxuICAgIC8vIGZsb3cgZG9lc24ndCBkbyBkdXJpbmcgbW91bnQuIFRoaXMgZG9lc24ndCBoYXBwZW4gYXQgdGhlIHJvb3QgYmVjYXVzZVxuICAgIC8vIHRoZSByb290IGFsd2F5cyBzdGFydHMgd2l0aCBhIFwiY3VycmVudFwiIHdpdGggYSBudWxsIGNoaWxkLlxuICAgIC8vIFRPRE86IENvbnNpZGVyIHVuaWZ5aW5nIHRoaXMgd2l0aCBob3cgdGhlIHJvb3Qgd29ya3MuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSByZWNvbmNpbGVDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgbnVsbCwgbmV4dENoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIH0gZWxzZSB7XG4gICAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRDaGlsZHJlbiwgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG52YXIgaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIgPSBmYWxzZTtcblxuZnVuY3Rpb24gdXBkYXRlQ29udGV4dFByb3ZpZGVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB2YXIgY29udGV4dDtcblxuICB7XG4gICAgY29udGV4dCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gIH1cblxuICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gIHZhciBvbGRQcm9wcyA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHM7XG4gIHZhciBuZXdWYWx1ZSA9IG5ld1Byb3BzLnZhbHVlO1xuXG4gIHtcbiAgICBpZiAoISgndmFsdWUnIGluIG5ld1Byb3BzKSkge1xuICAgICAgaWYgKCFoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlcikge1xuICAgICAgICBoYXNXYXJuZWRBYm91dFVzaW5nTm9WYWx1ZVByb3BPbkNvbnRleHRQcm92aWRlciA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJ1RoZSBgdmFsdWVgIHByb3AgaXMgcmVxdWlyZWQgZm9yIHRoZSBgPENvbnRleHQuUHJvdmlkZXI+YC4gRGlkIHlvdSBtaXNzcGVsbCBpdCBvciBmb3JnZXQgdG8gcGFzcyBpdD8nKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIGNvbnRleHQsIG5ld1ZhbHVlKTtcblxuICB7XG4gICAgaWYgKG9sZFByb3BzICE9PSBudWxsKSB7XG4gICAgICB2YXIgb2xkVmFsdWUgPSBvbGRQcm9wcy52YWx1ZTtcblxuICAgICAgaWYgKG9iamVjdElzKG9sZFZhbHVlLCBuZXdWYWx1ZSkpIHtcbiAgICAgICAgLy8gTm8gY2hhbmdlLiBCYWlsb3V0IGVhcmx5IGlmIGNoaWxkcmVuIGFyZSB0aGUgc2FtZS5cbiAgICAgICAgaWYgKG9sZFByb3BzLmNoaWxkcmVuID09PSBuZXdQcm9wcy5jaGlsZHJlbiAmJiAhaGFzQ29udGV4dENoYW5nZWQoKSkge1xuICAgICAgICAgIHJldHVybiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSBjb250ZXh0IHZhbHVlIGNoYW5nZWQuIFNlYXJjaCBmb3IgbWF0Y2hpbmcgY29uc3VtZXJzIGFuZCBzY2hlZHVsZVxuICAgICAgICAvLyB0aGVtIHRvIHVwZGF0ZS5cbiAgICAgICAgcHJvcGFnYXRlQ29udGV4dENoYW5nZSh3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBuZXdDaGlsZHJlbiA9IG5ld1Byb3BzLmNoaWxkcmVuO1xuICByZWNvbmNpbGVDaGlsZHJlbihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgbmV3Q2hpbGRyZW4sIHJlbmRlckxhbmVzKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb250ZXh0Q29uc3VtZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIHZhciBjb250ZXh0O1xuXG4gIHtcbiAgICB2YXIgY29uc3VtZXJUeXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICBjb250ZXh0ID0gY29uc3VtZXJUeXBlLl9jb250ZXh0O1xuICB9XG5cbiAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuICB2YXIgcmVuZGVyID0gbmV3UHJvcHMuY2hpbGRyZW47XG5cbiAge1xuICAgIGlmICh0eXBlb2YgcmVuZGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICBlcnJvcignQSBjb250ZXh0IGNvbnN1bWVyIHdhcyByZW5kZXJlZCB3aXRoIG11bHRpcGxlIGNoaWxkcmVuLCBvciBhIGNoaWxkICcgKyBcInRoYXQgaXNuJ3QgYSBmdW5jdGlvbi4gQSBjb250ZXh0IGNvbnN1bWVyIGV4cGVjdHMgYSBzaW5nbGUgY2hpbGQgXCIgKyAndGhhdCBpcyBhIGZ1bmN0aW9uLiBJZiB5b3UgZGlkIHBhc3MgYSBmdW5jdGlvbiwgbWFrZSBzdXJlIHRoZXJlICcgKyAnaXMgbm8gdHJhaWxpbmcgb3IgbGVhZGluZyB3aGl0ZXNwYWNlIGFyb3VuZCBpdC4nKTtcbiAgICB9XG4gIH1cblxuICBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICB2YXIgbmV3VmFsdWUgPSByZWFkQ29udGV4dChjb250ZXh0KTtcblxuICB7XG4gICAgbWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQod29ya0luUHJvZ3Jlc3MpO1xuICB9XG5cbiAgdmFyIG5ld0NoaWxkcmVuO1xuXG4gIHtcbiAgICBzZXRJc1JlbmRlcmluZyh0cnVlKTtcbiAgICBuZXdDaGlsZHJlbiA9IHJlbmRlcihuZXdWYWx1ZSk7XG4gICAgc2V0SXNSZW5kZXJpbmcoZmFsc2UpO1xuICB9XG5cbiAge1xuICAgIG1hcmtDb21wb25lbnRSZW5kZXJTdG9wcGVkKCk7XG4gIH0gLy8gUmVhY3QgRGV2VG9vbHMgcmVhZHMgdGhpcyBmbGFnLlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGVyZm9ybWVkV29yaztcbiAgcmVjb25jaWxlQ2hpbGRyZW4oY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5ld0NoaWxkcmVuLCByZW5kZXJMYW5lcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gbWFya1dvcmtJblByb2dyZXNzUmVjZWl2ZWRVcGRhdGUoKSB7XG4gIGRpZFJlY2VpdmVVcGRhdGUgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIC8vIFJldXNlIHByZXZpb3VzIGRlcGVuZGVuY2llc1xuICAgIHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzO1xuICB9XG5cbiAge1xuICAgIC8vIERvbid0IHVwZGF0ZSBcImJhc2VcIiByZW5kZXIgdGltZXMgZm9yIGJhaWxvdXRzLlxuICAgIHN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nKCk7XG4gIH1cblxuICBtYXJrU2tpcHBlZFVwZGF0ZUxhbmVzKHdvcmtJblByb2dyZXNzLmxhbmVzKTsgLy8gQ2hlY2sgaWYgdGhlIGNoaWxkcmVuIGhhdmUgYW55IHBlbmRpbmcgd29yay5cblxuICBpZiAoIWluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMpKSB7XG4gICAgLy8gVGhlIGNoaWxkcmVuIGRvbid0IGhhdmUgYW55IHdvcmsgZWl0aGVyLiBXZSBjYW4gc2tpcCB0aGVtLlxuICAgIC8vIFRPRE86IE9uY2Ugd2UgYWRkIGJhY2sgcmVzdW1pbmcsIHdlIHNob3VsZCBjaGVjayBpZiB0aGUgY2hpbGRyZW4gYXJlXG4gICAgLy8gYSB3b3JrLWluLXByb2dyZXNzIHNldC4gSWYgc28sIHdlIG5lZWQgdG8gdHJhbnNmZXIgdGhlaXIgZWZmZWN0cy5cbiAgICB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH0gLy8gVGhpcyBmaWJlciBkb2Vzbid0IGhhdmUgd29yaywgYnV0IGl0cyBzdWJ0cmVlIGRvZXMuIENsb25lIHRoZSBjaGlsZFxuICAvLyBmaWJlcnMgYW5kIGNvbnRpbnVlLlxuXG5cbiAgY2xvbmVDaGlsZEZpYmVycyhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbn1cblxuZnVuY3Rpb24gcmVtb3VudEZpYmVyKGN1cnJlbnQsIG9sZFdvcmtJblByb2dyZXNzLCBuZXdXb3JrSW5Qcm9ncmVzcykge1xuICB7XG4gICAgdmFyIHJldHVybkZpYmVyID0gb2xkV29ya0luUHJvZ3Jlc3MucmV0dXJuO1xuXG4gICAgaWYgKHJldHVybkZpYmVyID09PSBudWxsKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3Qgc3dhcCB0aGUgcm9vdCBmaWJlci4nKTtcbiAgICB9IC8vIERpc2Nvbm5lY3QgZnJvbSB0aGUgb2xkIGN1cnJlbnQuXG4gICAgLy8gSXQgd2lsbCBnZXQgZGVsZXRlZC5cblxuXG4gICAgY3VycmVudC5hbHRlcm5hdGUgPSBudWxsO1xuICAgIG9sZFdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IG51bGw7IC8vIENvbm5lY3QgdG8gdGhlIG5ldyB0cmVlLlxuXG4gICAgbmV3V29ya0luUHJvZ3Jlc3MuaW5kZXggPSBvbGRXb3JrSW5Qcm9ncmVzcy5pbmRleDtcbiAgICBuZXdXb3JrSW5Qcm9ncmVzcy5zaWJsaW5nID0gb2xkV29ya0luUHJvZ3Jlc3Muc2libGluZztcbiAgICBuZXdXb3JrSW5Qcm9ncmVzcy5yZXR1cm4gPSBvbGRXb3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gICAgbmV3V29ya0luUHJvZ3Jlc3MucmVmID0gb2xkV29ya0luUHJvZ3Jlc3MucmVmO1xuXG4gICAge1xuICAgICAgbmV3V29ya0luUHJvZ3Jlc3MuX2RlYnVnSW5mbyA9IG9sZFdvcmtJblByb2dyZXNzLl9kZWJ1Z0luZm87XG4gICAgfSAvLyBSZXBsYWNlIHRoZSBjaGlsZC9zaWJsaW5nIHBvaW50ZXJzIGFib3ZlIGl0LlxuXG5cbiAgICBpZiAob2xkV29ya0luUHJvZ3Jlc3MgPT09IHJldHVybkZpYmVyLmNoaWxkKSB7XG4gICAgICByZXR1cm5GaWJlci5jaGlsZCA9IG5ld1dvcmtJblByb2dyZXNzO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJldlNpYmxpbmcgPSByZXR1cm5GaWJlci5jaGlsZDtcblxuICAgICAgaWYgKHByZXZTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcGFyZW50IHRvIGhhdmUgYSBjaGlsZC4nKTtcbiAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgd2hpbGUgKHByZXZTaWJsaW5nLnNpYmxpbmcgIT09IG9sZFdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgICBwcmV2U2libGluZyA9IHByZXZTaWJsaW5nLnNpYmxpbmc7XG5cbiAgICAgICAgaWYgKHByZXZTaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3Byb2QtZXJyb3ItY29kZXNcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgdGhlIHByZXZpb3VzIHNpYmxpbmcuJyk7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgcHJldlNpYmxpbmcuc2libGluZyA9IG5ld1dvcmtJblByb2dyZXNzO1xuICAgIH0gLy8gRGVsZXRlIHRoZSBvbGQgZmliZXIgYW5kIHBsYWNlIHRoZSBuZXcgb25lLlxuICAgIC8vIFNpbmNlIHRoZSBvbGQgZmliZXIgaXMgZGlzY29ubmVjdGVkLCB3ZSBoYXZlIHRvIHNjaGVkdWxlIGl0IG1hbnVhbGx5LlxuXG5cbiAgICB2YXIgZGVsZXRpb25zID0gcmV0dXJuRmliZXIuZGVsZXRpb25zO1xuXG4gICAgaWYgKGRlbGV0aW9ucyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuRmliZXIuZGVsZXRpb25zID0gW2N1cnJlbnRdO1xuICAgICAgcmV0dXJuRmliZXIuZmxhZ3MgfD0gQ2hpbGREZWxldGlvbjtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRpb25zLnB1c2goY3VycmVudCk7XG4gICAgfVxuXG4gICAgbmV3V29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGxhY2VtZW50OyAvLyBSZXN0YXJ0IHdvcmsgZnJvbSB0aGUgbmV3IGZpYmVyLlxuXG4gICAgcmV0dXJuIG5ld1dvcmtJblByb2dyZXNzO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0KGN1cnJlbnQsIHJlbmRlckxhbmVzKSB7XG4gIC8vIEJlZm9yZSBwZXJmb3JtaW5nIGFuIGVhcmx5IGJhaWxvdXQsIHdlIG11c3QgY2hlY2sgaWYgdGhlcmUgYXJlIHBlbmRpbmdcbiAgLy8gdXBkYXRlcyBvciBjb250ZXh0LlxuICB2YXIgdXBkYXRlTGFuZXMgPSBjdXJyZW50LmxhbmVzO1xuXG4gIGlmIChpbmNsdWRlc1NvbWVMYW5lKHVwZGF0ZUxhbmVzLCByZW5kZXJMYW5lcykpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBObyBwZW5kaW5nIHVwZGF0ZSwgYnV0IGJlY2F1c2UgY29udGV4dCBpcyBwcm9wYWdhdGVkIGxhemlseSwgd2UgbmVlZFxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gYXR0ZW1wdEVhcmx5QmFpbG91dElmTm9TY2hlZHVsZWRVcGRhdGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRoaXMgZmliZXIgZG9lcyBub3QgaGF2ZSBhbnkgcGVuZGluZyB3b3JrLiBCYWlsb3V0IHdpdGhvdXQgZW50ZXJpbmdcbiAgLy8gdGhlIGJlZ2luIHBoYXNlLiBUaGVyZSdzIHN0aWxsIHNvbWUgYm9va2tlZXBpbmcgd2UgdGhhdCBuZWVkcyB0byBiZSBkb25lXG4gIC8vIGluIHRoaXMgb3B0aW1pemVkIHBhdGgsIG1vc3RseSBwdXNoaW5nIHN0dWZmIG9udG8gdGhlIHN0YWNrLlxuICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICBwdXNoSG9zdFJvb3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcblxuICAgICAge1xuICAgICAgICB2YXIgY2FjaGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGU7XG4gICAgICAgIHB1c2hDYWNoZVByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBjYWNoZSk7XG4gICAgICB9XG5cbiAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHB1c2hIb3N0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBwdXNoSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlLmNvbnRhaW5lckluZm8pO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIHtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRQcm9wcy52YWx1ZTtcbiAgICAgICAgdmFyIGNvbnRleHQ7XG5cbiAgICAgICAge1xuICAgICAgICAgIGNvbnRleHQgPSB3b3JrSW5Qcm9ncmVzcy50eXBlO1xuICAgICAgICB9XG5cbiAgICAgICAgcHVzaFByb3ZpZGVyKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCBuZXdWYWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBQcm9maWxlcjpcbiAgICAgIHtcbiAgICAgICAgLy8gUHJvZmlsZXIgc2hvdWxkIG9ubHkgY2FsbCBvblJlbmRlciB3aGVuIG9uZSBvZiBpdHMgZGVzY2VuZGFudHMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gICAgICAgIHZhciBoYXNDaGlsZFdvcmsgPSBpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCB3b3JrSW5Qcm9ncmVzcy5jaGlsZExhbmVzKTtcblxuICAgICAgICBpZiAoaGFzQ2hpbGRXb3JrKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgICAgICB9XG5cbiAgICAgICAge1xuICAgICAgICAgIC8vIFJlc2V0IGVmZmVjdCBkdXJhdGlvbnMgZm9yIHRoZSBuZXh0IGV2ZW50dWFsIGVmZmVjdCBwaGFzZS5cbiAgICAgICAgICAvLyBUaGVzZSBhcmUgcmVzZXQgZHVyaW5nIHJlbmRlciB0byBhbGxvdyB0aGUgRGV2VG9vbHMgY29tbWl0IGhvb2sgYSBjaGFuY2UgdG8gcmVhZCB0aGVtLFxuICAgICAgICAgIHZhciBzdGF0ZU5vZGUgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uID0gMDtcbiAgICAgICAgICBzdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBicmVhaztcblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgaWYgKHN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHN0YXRlLmRlaHlkcmF0ZWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFdlJ3JlIG5vdCBnb2luZyB0byByZW5kZXIgdGhlIGNoaWxkcmVuLCBzbyB0aGlzIGlzIGp1c3QgdG8gbWFpbnRhaW5cbiAgICAgICAgICAgIC8vIHB1c2gvcG9wIHN5bW1ldHJ5XG4gICAgICAgICAgICBwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpOyAvLyBXZSBrbm93IHRoYXQgdGhpcyBjb21wb25lbnQgd2lsbCBzdXNwZW5kIGFnYWluIGJlY2F1c2UgaWYgaXQgaGFzXG4gICAgICAgICAgICAvLyBiZWVuIHVuc3VzcGVuZGVkIGl0IGhhcyBjb21taXR0ZWQgYXMgYSByZXNvbHZlZCBTdXNwZW5zZSBjb21wb25lbnQuXG4gICAgICAgICAgICAvLyBJZiBpdCBuZWVkcyB0byBiZSByZXRyaWVkLCBpdCBzaG91bGQgaGF2ZSB3b3JrIHNjaGVkdWxlZCBvbiBpdC5cblxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTsgLy8gV2Ugc2hvdWxkIG5ldmVyIHJlbmRlciB0aGUgY2hpbGRyZW4gb2YgYSBkZWh5ZHJhdGVkIGJvdW5kYXJ5IHVudGlsIHdlXG4gICAgICAgICAgICAvLyB1cGdyYWRlIGl0LiBXZSByZXR1cm4gbnVsbCBpbnN0ZWFkIG9mIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsuXG5cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH0gLy8gSWYgdGhpcyBib3VuZGFyeSBpcyBjdXJyZW50bHkgdGltZWQgb3V0LCB3ZSBuZWVkIHRvIGRlY2lkZVxuICAgICAgICAgIC8vIHdoZXRoZXIgdG8gcmV0cnkgdGhlIHByaW1hcnkgY2hpbGRyZW4sIG9yIHRvIHNraXAgb3ZlciBpdCBhbmRcbiAgICAgICAgICAvLyBnbyBzdHJhaWdodCB0byB0aGUgZmFsbGJhY2suIENoZWNrIHRoZSBwcmlvcml0eSBvZiB0aGUgcHJpbWFyeVxuICAgICAgICAgIC8vIGNoaWxkIGZyYWdtZW50LlxuXG5cbiAgICAgICAgICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICB2YXIgcHJpbWFyeUNoaWxkTGFuZXMgPSBwcmltYXJ5Q2hpbGRGcmFnbWVudC5jaGlsZExhbmVzO1xuXG4gICAgICAgICAgaWYgKGluY2x1ZGVzU29tZUxhbmUocmVuZGVyTGFuZXMsIHByaW1hcnlDaGlsZExhbmVzKSkge1xuICAgICAgICAgICAgLy8gVGhlIHByaW1hcnkgY2hpbGRyZW4gaGF2ZSBwZW5kaW5nIHdvcmsuIFVzZSB0aGUgbm9ybWFsIHBhdGhcbiAgICAgICAgICAgIC8vIHRvIGF0dGVtcHQgdG8gcmVuZGVyIHRoZSBwcmltYXJ5IGNoaWxkcmVuIGFnYWluLlxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZSBwcmltYXJ5IGNoaWxkIGZyYWdtZW50IGRvZXMgbm90IGhhdmUgcGVuZGluZyB3b3JrIG1hcmtlZFxuICAgICAgICAgICAgLy8gb24gaXRcbiAgICAgICAgICAgIHB1c2hQcmltYXJ5VHJlZVN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7IC8vIFRoZSBwcmltYXJ5IGNoaWxkcmVuIGRvIG5vdCBoYXZlIHBlbmRpbmcgd29yayB3aXRoIHN1ZmZpY2llbnRcbiAgICAgICAgICAgIC8vIHByaW9yaXR5LiBCYWlsb3V0LlxuXG4gICAgICAgICAgICB2YXIgY2hpbGQgPSBiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICAgICAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBUaGUgZmFsbGJhY2sgY2hpbGRyZW4gaGF2ZSBwZW5kaW5nIHdvcmsuIFNraXAgb3ZlciB0aGVcbiAgICAgICAgICAgICAgLy8gcHJpbWFyeSBjaGlsZHJlbiBhbmQgd29yayBvbiB0aGUgZmFsbGJhY2suXG4gICAgICAgICAgICAgIHJldHVybiBjaGlsZC5zaWJsaW5nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gTm90ZTogV2UgY2FuIHJldHVybiBgbnVsbGAgaGVyZSBiZWNhdXNlIHdlIGFscmVhZHkgY2hlY2tlZFxuICAgICAgICAgICAgICAvLyB3aGV0aGVyIHRoZXJlIHdlcmUgbmVzdGVkIGNvbnRleHQgY29uc3VtZXJzLCB2aWEgdGhlIGNhbGwgdG9cbiAgICAgICAgICAgICAgLy8gYGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmtgIGFib3ZlLlxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHVzaFByaW1hcnlUcmVlU3VzcGVuc2VIYW5kbGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBkaWRTdXNwZW5kQmVmb3JlID0gKGN1cnJlbnQuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncyQxO1xuXG4gICAgICAgIHZhciBfaGFzQ2hpbGRXb3JrID0gaW5jbHVkZXNTb21lTGFuZShyZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyk7XG5cbiAgICAgICAgaWYgKGRpZFN1c3BlbmRCZWZvcmUpIHtcbiAgICAgICAgICBpZiAoX2hhc0NoaWxkV29yaykge1xuICAgICAgICAgICAgLy8gSWYgc29tZXRoaW5nIHdhcyBpbiBmYWxsYmFjayBzdGF0ZSBsYXN0IHRpbWUsIGFuZCB3ZSBoYXZlIGFsbCB0aGVcbiAgICAgICAgICAgIC8vIHNhbWUgY2hpbGRyZW4gdGhlbiB3ZSdyZSBzdGlsbCBpbiBwcm9ncmVzc2l2ZSBsb2FkaW5nIHN0YXRlLlxuICAgICAgICAgICAgLy8gU29tZXRoaW5nIG1pZ2h0IGdldCB1bmJsb2NrZWQgYnkgc3RhdGUgdXBkYXRlcyBvciByZXRyaWVzIGluIHRoZVxuICAgICAgICAgICAgLy8gdHJlZSB3aGljaCB3aWxsIGFmZmVjdCB0aGUgdGFpbC4gU28gd2UgbmVlZCB0byB1c2UgdGhlIG5vcm1hbFxuICAgICAgICAgICAgLy8gcGF0aCB0byBjb21wdXRlIHRoZSBjb3JyZWN0IHRhaWwuXG4gICAgICAgICAgICByZXR1cm4gdXBkYXRlU3VzcGVuc2VMaXN0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgICAgfSAvLyBJZiBub25lIG9mIHRoZSBjaGlsZHJlbiBoYWQgYW55IHdvcmssIHRoYXQgbWVhbnMgdGhhdCBub25lIG9mXG4gICAgICAgICAgLy8gdGhlbSBnb3QgcmV0cmllZCBzbyB0aGV5J2xsIHN0aWxsIGJlIGJsb2NrZWQgaW4gdGhlIHNhbWUgd2F5XG4gICAgICAgICAgLy8gYXMgYmVmb3JlLiBXZSBjYW4gZmFzdCBiYWlsIG91dC5cblxuXG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgfSAvLyBJZiBub3RoaW5nIHN1c3BlbmRlZCBiZWZvcmUgYW5kIHdlJ3JlIHJlbmRlcmluZyB0aGUgc2FtZSBjaGlsZHJlbixcbiAgICAgICAgLy8gdGhlbiB0aGUgdGFpbCBkb2Vzbid0IG1hdHRlci4gQW55dGhpbmcgbmV3IHRoYXQgc3VzcGVuZHMgd2lsbCB3b3JrXG4gICAgICAgIC8vIGluIHRoZSBcInRvZ2V0aGVyXCIgbW9kZSwgc28gd2UgY2FuIGNvbnRpbnVlIGZyb20gdGhlIHN0YXRlIHdlIGhhZC5cblxuXG4gICAgICAgIHZhciByZW5kZXJTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgaWYgKHJlbmRlclN0YXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gUmVzZXQgdG8gdGhlIFwidG9nZXRoZXJcIiBtb2RlIGluIGNhc2Ugd2UndmUgc3RhcnRlZCBhIGRpZmZlcmVudFxuICAgICAgICAgIC8vIHVwZGF0ZSBpbiB0aGUgcGFzdCBidXQgZGlkbid0IGNvbXBsZXRlIGl0LlxuICAgICAgICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZyA9IG51bGw7XG4gICAgICAgICAgcmVuZGVyU3RhdGUudGFpbCA9IG51bGw7XG4gICAgICAgICAgcmVuZGVyU3RhdGUubGFzdEVmZmVjdCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBwdXNoU3VzcGVuc2VMaXN0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcywgc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50KTtcblxuICAgICAgICBpZiAoX2hhc0NoaWxkV29yaykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIG5vbmUgb2YgdGhlIGNoaWxkcmVuIGhhZCBhbnkgd29yaywgdGhhdCBtZWFucyB0aGF0IG5vbmUgb2ZcbiAgICAgICAgICAvLyB0aGVtIGdvdCByZXRyaWVkIHNvIHRoZXknbGwgc3RpbGwgYmUgYmxvY2tlZCBpbiB0aGUgc2FtZSB3YXlcbiAgICAgICAgICAvLyBhcyBiZWZvcmUuIFdlIGNhbiBmYXN0IGJhaWwgb3V0LlxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gTmVlZCB0byBjaGVjayBpZiB0aGUgdHJlZSBzdGlsbCBuZWVkcyB0byBiZSBkZWZlcnJlZC4gVGhpcyBpc1xuICAgICAgICAvLyBhbG1vc3QgaWRlbnRpY2FsIHRvIHRoZSBsb2dpYyB1c2VkIGluIHRoZSBub3JtYWwgdXBkYXRlIHBhdGgsXG4gICAgICAgIC8vIHNvIHdlJ2xsIGp1c3QgZW50ZXIgdGhhdC4gVGhlIG9ubHkgZGlmZmVyZW5jZSBpcyB3ZSdsbCBiYWlsIG91dFxuICAgICAgICAvLyBhdCB0aGUgbmV4dCBsZXZlbCBpbnN0ZWFkIG9mIHRoaXMgb25lLCBiZWNhdXNlIHRoZSBjaGlsZCBwcm9wc1xuICAgICAgICAvLyBoYXZlIG5vdCBjaGFuZ2VkLiBXaGljaCBpcyBmaW5lLlxuICAgICAgICAvLyBUT0RPOiBQcm9iYWJseSBzaG91bGQgcmVmYWN0b3IgYGJlZ2luV29ya2AgdG8gc3BsaXQgdGhlIGJhaWxvdXRcbiAgICAgICAgLy8gcGF0aCBmcm9tIHRoZSBub3JtYWwgcGF0aC4gSSdtIHRlbXB0ZWQgdG8gZG8gYSBsYWJlbGVkIGJyZWFrIGhlcmVcbiAgICAgICAgLy8gYnV0IEkgd29uJ3QgOilcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBOb0xhbmVzO1xuICAgICAgICByZXR1cm4gdXBkYXRlT2Zmc2NyZWVuQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIENhY2hlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9jYWNoZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZTtcbiAgICAgICAgICBwdXNoQ2FjaGVQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgX2NhY2hlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG5cbiAgcmV0dXJuIGJhaWxvdXRPbkFscmVhZHlGaW5pc2hlZFdvcmsoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbn1cblxuZnVuY3Rpb24gYmVnaW5Xb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICB7XG4gICAgaWYgKHdvcmtJblByb2dyZXNzLl9kZWJ1Z05lZWRzUmVtb3VudCAmJiBjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgcmVzdGFydCB0aGUgYmVnaW4gcGhhc2Ugd2l0aCBhIG5ldyBmaWJlci5cbiAgICAgIHJldHVybiByZW1vdW50RmliZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyh3b3JrSW5Qcm9ncmVzcy50eXBlLCB3b3JrSW5Qcm9ncmVzcy5rZXksIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcywgd29ya0luUHJvZ3Jlc3MuX2RlYnVnT3duZXIgfHwgbnVsbCwgd29ya0luUHJvZ3Jlc3MubW9kZSwgd29ya0luUHJvZ3Jlc3MubGFuZXMpKTtcbiAgICB9XG4gIH1cblxuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQubWVtb2l6ZWRQcm9wcztcbiAgICB2YXIgbmV3UHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgICBpZiAob2xkUHJvcHMgIT09IG5ld1Byb3BzIHx8IGhhc0NvbnRleHRDaGFuZ2VkKCkgfHwgKCAvLyBGb3JjZSBhIHJlLXJlbmRlciBpZiB0aGUgaW1wbGVtZW50YXRpb24gY2hhbmdlZCBkdWUgdG8gaG90IHJlbG9hZDpcbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlICE9PSBjdXJyZW50LnR5cGUgKSkge1xuICAgICAgLy8gSWYgcHJvcHMgb3IgY29udGV4dCBjaGFuZ2VkLCBtYXJrIHRoZSBmaWJlciBhcyBoYXZpbmcgcGVyZm9ybWVkIHdvcmsuXG4gICAgICAvLyBUaGlzIG1heSBiZSB1bnNldCBpZiB0aGUgcHJvcHMgYXJlIGRldGVybWluZWQgdG8gYmUgZXF1YWwgbGF0ZXIgKG1lbW8pLlxuICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5laXRoZXIgcHJvcHMgbm9yIGxlZ2FjeSBjb250ZXh0IGNoYW5nZXMuIENoZWNrIGlmIHRoZXJlJ3MgYSBwZW5kaW5nXG4gICAgICAvLyB1cGRhdGUgb3IgY29udGV4dCBjaGFuZ2UuXG4gICAgICB2YXIgaGFzU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0ID0gY2hlY2tTY2hlZHVsZWRVcGRhdGVPckNvbnRleHQoY3VycmVudCwgcmVuZGVyTGFuZXMpO1xuXG4gICAgICBpZiAoIWhhc1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCAmJiAvLyBJZiB0aGlzIGlzIHRoZSBzZWNvbmQgcGFzcyBvZiBhbiBlcnJvciBvciBzdXNwZW5zZSBib3VuZGFyeSwgdGhlcmVcbiAgICAgIC8vIG1heSBub3QgYmUgd29yayBzY2hlZHVsZWQgb24gYGN1cnJlbnRgLCBzbyB3ZSBjaGVjayBmb3IgdGhpcyBmbGFnLlxuICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAvLyBObyBwZW5kaW5nIHVwZGF0ZXMgb3IgY29udGV4dC4gQmFpbCBvdXQgbm93LlxuICAgICAgICBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBhdHRlbXB0RWFybHlCYWlsb3V0SWZOb1NjaGVkdWxlZFVwZGF0ZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoKGN1cnJlbnQuZmxhZ3MgJiBGb3JjZVVwZGF0ZUZvckxlZ2FjeVN1c3BlbnNlKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIGNhc2UgdGhhdCBvbmx5IGV4aXN0cyBmb3IgbGVnYWN5IG1vZGUuXG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8xOTIxNi5cbiAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBbiB1cGRhdGUgd2FzIHNjaGVkdWxlZCBvbiB0aGlzIGZpYmVyLCBidXQgdGhlcmUgYXJlIG5vIG5ldyBwcm9wc1xuICAgICAgICAvLyBub3IgbGVnYWN5IGNvbnRleHQuIFNldCB0aGlzIHRvIGZhbHNlLiBJZiBhbiB1cGRhdGUgcXVldWUgb3IgY29udGV4dFxuICAgICAgICAvLyBjb25zdW1lciBwcm9kdWNlcyBhIGNoYW5nZWQgdmFsdWUsIGl0IHdpbGwgc2V0IHRoaXMgdG8gdHJ1ZS4gT3RoZXJ3aXNlLFxuICAgICAgICAvLyB0aGUgY29tcG9uZW50IHdpbGwgYXNzdW1lIHRoZSBjaGlsZHJlbiBoYXZlIG5vdCBjaGFuZ2VkIGFuZCBiYWlsIG91dC5cbiAgICAgICAgZGlkUmVjZWl2ZVVwZGF0ZSA9IGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBkaWRSZWNlaXZlVXBkYXRlID0gZmFsc2U7XG5cbiAgICBpZiAoZ2V0SXNIeWRyYXRpbmcoKSAmJiBpc0ZvcmtlZENoaWxkKHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBjaGlsZCBiZWxvbmdzIHRvIGEgbGlzdCBvZiBtdWxpcGxlIGNoaWxkcmVuIGluXG4gICAgICAvLyBpdHMgcGFyZW50LlxuICAgICAgLy9cbiAgICAgIC8vIEluIGEgdHJ1ZSBtdWx0aS10aHJlYWRlZCBpbXBsZW1lbnRhdGlvbiwgd2Ugd291bGQgcmVuZGVyIGNoaWxkcmVuIG9uXG4gICAgICAvLyBwYXJhbGxlbCB0aHJlYWRzLiBUaGlzIHdvdWxkIHJlcHJlc2VudCB0aGUgYmVnaW5uaW5nIG9mIGEgbmV3IHJlbmRlclxuICAgICAgLy8gdGhyZWFkIGZvciB0aGlzIHN1YnRyZWUuXG4gICAgICAvL1xuICAgICAgLy8gV2Ugb25seSB1c2UgdGhpcyBmb3IgaWQgZ2VuZXJhdGlvbiBkdXJpbmcgaHlkcmF0aW9uLCB3aGljaCBpcyB3aHkgdGhlXG4gICAgICAvLyBsb2dpYyBpcyBsb2NhdGVkIGluIHRoaXMgc3BlY2lhbCBicmFuY2guXG4gICAgICB2YXIgc2xvdEluZGV4ID0gd29ya0luUHJvZ3Jlc3MuaW5kZXg7XG4gICAgICB2YXIgbnVtYmVyT2ZGb3JrcyA9IGdldEZvcmtzQXRMZXZlbCgpO1xuICAgICAgcHVzaFRyZWVJZCh3b3JrSW5Qcm9ncmVzcywgbnVtYmVyT2ZGb3Jrcywgc2xvdEluZGV4KTtcbiAgICB9XG4gIH0gLy8gQmVmb3JlIGVudGVyaW5nIHRoZSBiZWdpbiBwaGFzZSwgY2xlYXIgcGVuZGluZyB1cGRhdGUgcHJpb3JpdHkuXG4gIC8vIFRPRE86IFRoaXMgYXNzdW1lcyB0aGF0IHdlJ3JlIGFib3V0IHRvIGV2YWx1YXRlIHRoZSBjb21wb25lbnQgYW5kIHByb2Nlc3NcbiAgLy8gdGhlIHVwZGF0ZSBxdWV1ZS4gSG93ZXZlciwgdGhlcmUncyBhbiBleGNlcHRpb246IFNpbXBsZU1lbW9Db21wb25lbnRcbiAgLy8gc29tZXRpbWVzIGJhaWxzIG91dCBsYXRlciBpbiB0aGUgYmVnaW4gcGhhc2UuIFRoaXMgaW5kaWNhdGVzIHRoYXQgd2Ugc2hvdWxkXG4gIC8vIG1vdmUgdGhpcyBhc3NpZ25tZW50IG91dCBvZiB0aGUgY29tbW9uIHBhdGggYW5kIGludG8gZWFjaCBicmFuY2guXG5cblxuICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IE5vTGFuZXM7XG5cbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIExhenlDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBlbGVtZW50VHlwZSA9IHdvcmtJblByb2dyZXNzLmVsZW1lbnRUeXBlO1xuICAgICAgICByZXR1cm4gbW91bnRMYXp5Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBlbGVtZW50VHlwZSwgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIENvbXBvbmVudCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciB1bnJlc29sdmVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG4gICAgICAgIHZhciByZXNvbHZlZFByb3BzID0gdW5yZXNvbHZlZFByb3BzIDtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZ1bmN0aW9uQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBDb21wb25lbnQsIHJlc29sdmVkUHJvcHMsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfQ29tcG9uZW50ID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHMgPSB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHM7XG5cbiAgICAgICAgdmFyIF9yZXNvbHZlZFByb3BzNCA9IHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKF9Db21wb25lbnQsIF91bnJlc29sdmVkUHJvcHMpO1xuXG4gICAgICAgIHJldHVybiB1cGRhdGVDbGFzc0NvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgX0NvbXBvbmVudCwgX3Jlc29sdmVkUHJvcHM0LCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RSb290KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIEhvc3RIb2lzdGFibGU6XG4gICAgICBpZiAoc3VwcG9ydHNSZXNvdXJjZXMpIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZUhvc3RIb2lzdGFibGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgfVxuXG4gICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICBjYXNlIEhvc3RTaW5nbGV0b246XG4gICAgICBpZiAoc3VwcG9ydHNTaW5nbGV0b25zKSB7XG4gICAgICAgIHJldHVybiB1cGRhdGVIb3N0U2luZ2xldG9uKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICB9XG5cbiAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHJldHVybiB1cGRhdGVIb3N0Q29tcG9uZW50JDEoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgSG9zdFRleHQ6XG4gICAgICByZXR1cm4gdXBkYXRlSG9zdFRleHQkMShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAgcmV0dXJuIHVwZGF0ZVN1c3BlbnNlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICByZXR1cm4gdXBkYXRlUG9ydGFsQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICB7XG4gICAgICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHMyID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzO1xuXG4gICAgICAgIHZhciBfcmVzb2x2ZWRQcm9wczUgPSBfdW5yZXNvbHZlZFByb3BzMiA7XG5cbiAgICAgICAgcmV0dXJuIHVwZGF0ZUZvcndhcmRSZWYoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHR5cGUsIF9yZXNvbHZlZFByb3BzNSwgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBGcmFnbWVudDpcbiAgICAgIHJldHVybiB1cGRhdGVGcmFnbWVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBNb2RlOlxuICAgICAgcmV0dXJuIHVwZGF0ZU1vZGUoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICByZXR1cm4gdXBkYXRlUHJvZmlsZXIoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgcmV0dXJuIHVwZGF0ZUNvbnRleHRQcm92aWRlcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgY2FzZSBDb250ZXh0Q29uc3VtZXI6XG4gICAgICByZXR1cm4gdXBkYXRlQ29udGV4dENvbnN1bWVyKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG5cbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICAgIHZhciBfdW5yZXNvbHZlZFByb3BzMyA9IHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wczsgLy8gUmVzb2x2ZSBvdXRlciBwcm9wcyBmaXJzdCwgdGhlbiByZXNvbHZlIGlubmVyIHByb3BzLlxuXG4gICAgICAgIHZhciBfcmVzb2x2ZWRQcm9wczYgPSBfdW5yZXNvbHZlZFByb3BzMyA7XG5cbiAgICAgICAgX3Jlc29sdmVkUHJvcHM2ID0gX3Jlc29sdmVkUHJvcHM2IDtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU1lbW9Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIF90eXBlLCBfcmVzb2x2ZWRQcm9wczYsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZVNpbXBsZU1lbW9Db21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHdvcmtJblByb2dyZXNzLnR5cGUsIHdvcmtJblByb2dyZXNzLnBlbmRpbmdQcm9wcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgY2FzZSBJbmNvbXBsZXRlRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiB1cGRhdGVTdXNwZW5zZUxpc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKTtcbiAgICAgIH1cblxuICAgIGNhc2UgU2NvcGVDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuIHVwZGF0ZU9mZnNjcmVlbkNvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuXG4gICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIENhY2hlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZUNhY2hlQ29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdW5pdCBvZiB3b3JrIHRhZyAoXCIgKyB3b3JrSW5Qcm9ncmVzcy50YWcgKyBcIikuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBcIiArICdSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG59XG5cbnZhciB2YWx1ZUN1cnNvciA9IGNyZWF0ZUN1cnNvcihudWxsKTtcbnZhciByZW5kZXJlckN1cnNvckRFVjtcblxue1xuICByZW5kZXJlckN1cnNvckRFViA9IGNyZWF0ZUN1cnNvcihudWxsKTtcbn1cblxudmFyIHJlbmRlcmVyMkN1cnNvckRFVjtcblxue1xuICByZW5kZXJlcjJDdXJzb3JERVYgPSBjcmVhdGVDdXJzb3IobnVsbCk7XG59XG5cbnZhciByZW5kZXJlclNpZ2lsO1xuXG57XG4gIC8vIFVzZSB0aGlzIHRvIGRldGVjdCBtdWx0aXBsZSByZW5kZXJlcnMgdXNpbmcgdGhlIHNhbWUgY29udGV4dFxuICByZW5kZXJlclNpZ2lsID0ge307XG59XG5cbnZhciBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGw7XG52YXIgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbnVsbDtcbnZhciBsYXN0RnVsbHlPYnNlcnZlZENvbnRleHQgPSBudWxsO1xudmFyIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSBmYWxzZTtcbmZ1bmN0aW9uIHJlc2V0Q29udGV4dERlcGVuZGVuY2llcygpIHtcbiAgLy8gVGhpcyBpcyBjYWxsZWQgcmlnaHQgYmVmb3JlIFJlYWN0IHlpZWxkcyBleGVjdXRpb24sIHRvIGVuc3VyZSBgcmVhZENvbnRleHRgXG4gIC8vIGNhbm5vdCBiZSBjYWxsZWQgb3V0c2lkZSB0aGUgcmVuZGVyIHBoYXNlLlxuICBjdXJyZW50bHlSZW5kZXJpbmdGaWJlciA9IG51bGw7XG4gIGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9IG51bGw7XG4gIGxhc3RGdWxseU9ic2VydmVkQ29udGV4dCA9IG51bGw7XG5cbiAge1xuICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gZW50ZXJEaXNhbGxvd2VkQ29udGV4dFJlYWRJbkRFVigpIHtcbiAge1xuICAgIGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYgPSB0cnVlO1xuICB9XG59XG5mdW5jdGlvbiBleGl0RGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYoKSB7XG4gIHtcbiAgICBpc0Rpc2FsbG93ZWRDb250ZXh0UmVhZEluREVWID0gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIHB1c2hQcm92aWRlcihwcm92aWRlckZpYmVyLCBjb250ZXh0LCBuZXh0VmFsdWUpIHtcbiAgaWYgKGlzUHJpbWFyeVJlbmRlcmVyKSB7XG4gICAgcHVzaCh2YWx1ZUN1cnNvciwgY29udGV4dC5fY3VycmVudFZhbHVlLCBwcm92aWRlckZpYmVyKTtcbiAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBuZXh0VmFsdWU7XG5cbiAgICB7XG4gICAgICBwdXNoKHJlbmRlcmVyQ3Vyc29yREVWLCBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIsIHByb3ZpZGVyRmliZXIpO1xuXG4gICAgICBpZiAoY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSB1bmRlZmluZWQgJiYgY29udGV4dC5fY3VycmVudFJlbmRlcmVyICE9PSBudWxsICYmIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlciAhPT0gcmVuZGVyZXJTaWdpbCkge1xuICAgICAgICBlcnJvcignRGV0ZWN0ZWQgbXVsdGlwbGUgcmVuZGVyZXJzIGNvbmN1cnJlbnRseSByZW5kZXJpbmcgdGhlICcgKyAnc2FtZSBjb250ZXh0IHByb3ZpZGVyLiBUaGlzIGlzIGN1cnJlbnRseSB1bnN1cHBvcnRlZC4nKTtcbiAgICAgIH1cblxuICAgICAgY29udGV4dC5fY3VycmVudFJlbmRlcmVyID0gcmVuZGVyZXJTaWdpbDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcHVzaCh2YWx1ZUN1cnNvciwgY29udGV4dC5fY3VycmVudFZhbHVlMiwgcHJvdmlkZXJGaWJlcik7XG4gICAgY29udGV4dC5fY3VycmVudFZhbHVlMiA9IG5leHRWYWx1ZTtcblxuICAgIHtcbiAgICAgIHB1c2gocmVuZGVyZXIyQ3Vyc29yREVWLCBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyLCBwcm92aWRlckZpYmVyKTtcblxuICAgICAgaWYgKGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgIT09IHVuZGVmaW5lZCAmJiBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyICE9PSBudWxsICYmIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgIT09IHJlbmRlcmVyU2lnaWwpIHtcbiAgICAgICAgZXJyb3IoJ0RldGVjdGVkIG11bHRpcGxlIHJlbmRlcmVycyBjb25jdXJyZW50bHkgcmVuZGVyaW5nIHRoZSAnICsgJ3NhbWUgY29udGV4dCBwcm92aWRlci4gVGhpcyBpcyBjdXJyZW50bHkgdW5zdXBwb3J0ZWQuJyk7XG4gICAgICB9XG5cbiAgICAgIGNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPSByZW5kZXJlclNpZ2lsO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcG9wUHJvdmlkZXIoY29udGV4dCwgcHJvdmlkZXJGaWJlcikge1xuICB2YXIgY3VycmVudFZhbHVlID0gdmFsdWVDdXJzb3IuY3VycmVudDtcblxuICBpZiAoaXNQcmltYXJ5UmVuZGVyZXIpIHtcbiAgICBjb250ZXh0Ll9jdXJyZW50VmFsdWUgPSBjdXJyZW50VmFsdWU7XG5cbiAgICB7XG4gICAgICB2YXIgY3VycmVudFJlbmRlcmVyID0gcmVuZGVyZXJDdXJzb3JERVYuY3VycmVudDtcbiAgICAgIHBvcChyZW5kZXJlckN1cnNvckRFViwgcHJvdmlkZXJGaWJlcik7XG4gICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSBjdXJyZW50UmVuZGVyZXI7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNvbnRleHQuX2N1cnJlbnRWYWx1ZTIgPSBjdXJyZW50VmFsdWU7XG5cbiAgICB7XG4gICAgICB2YXIgY3VycmVudFJlbmRlcmVyMiA9IHJlbmRlcmVyMkN1cnNvckRFVi5jdXJyZW50O1xuICAgICAgcG9wKHJlbmRlcmVyMkN1cnNvckRFViwgcHJvdmlkZXJGaWJlcik7XG4gICAgICBjb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIyID0gY3VycmVudFJlbmRlcmVyMjtcbiAgICB9XG4gIH1cblxuICBwb3AodmFsdWVDdXJzb3IsIHByb3ZpZGVyRmliZXIpO1xufVxuZnVuY3Rpb24gc2NoZWR1bGVDb250ZXh0V29ya09uUGFyZW50UGF0aChwYXJlbnQsIHJlbmRlckxhbmVzLCBwcm9wYWdhdGlvblJvb3QpIHtcbiAgLy8gVXBkYXRlIHRoZSBjaGlsZCBsYW5lcyBvZiBhbGwgdGhlIGFuY2VzdG9ycywgaW5jbHVkaW5nIHRoZSBhbHRlcm5hdGVzLlxuICB2YXIgbm9kZSA9IHBhcmVudDtcblxuICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgIHZhciBhbHRlcm5hdGUgPSBub2RlLmFsdGVybmF0ZTtcblxuICAgIGlmICghaXNTdWJzZXRPZkxhbmVzKG5vZGUuY2hpbGRMYW5lcywgcmVuZGVyTGFuZXMpKSB7XG4gICAgICBub2RlLmNoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKG5vZGUuY2hpbGRMYW5lcywgcmVuZGVyTGFuZXMpO1xuXG4gICAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgIGFsdGVybmF0ZS5jaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhhbHRlcm5hdGUuY2hpbGRMYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoYWx0ZXJuYXRlICE9PSBudWxsICYmICFpc1N1YnNldE9mTGFuZXMoYWx0ZXJuYXRlLmNoaWxkTGFuZXMsIHJlbmRlckxhbmVzKSkge1xuICAgICAgYWx0ZXJuYXRlLmNoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5jaGlsZExhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgfSBlbHNlIDtcblxuICAgIGlmIChub2RlID09PSBwcm9wYWdhdGlvblJvb3QpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgfVxuXG4gIHtcbiAgICBpZiAobm9kZSAhPT0gcHJvcGFnYXRpb25Sb290KSB7XG4gICAgICBlcnJvcignRXhwZWN0ZWQgdG8gZmluZCB0aGUgcHJvcGFnYXRpb24gcm9vdCB3aGVuIHNjaGVkdWxpbmcgY29udGV4dCB3b3JrLiAnICsgJ1RoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBwcm9wYWdhdGVDb250ZXh0Q2hhbmdlKHdvcmtJblByb2dyZXNzLCBjb250ZXh0LCByZW5kZXJMYW5lcykge1xuICB7XG4gICAgcHJvcGFnYXRlQ29udGV4dENoYW5nZV9lYWdlcih3b3JrSW5Qcm9ncmVzcywgY29udGV4dCwgcmVuZGVyTGFuZXMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb3BhZ2F0ZUNvbnRleHRDaGFuZ2VfZWFnZXIod29ya0luUHJvZ3Jlc3MsIGNvbnRleHQsIHJlbmRlckxhbmVzKSB7XG5cbiAgdmFyIGZpYmVyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgaWYgKGZpYmVyICE9PSBudWxsKSB7XG4gICAgLy8gU2V0IHRoZSByZXR1cm4gcG9pbnRlciBvZiB0aGUgY2hpbGQgdG8gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuXG4gICAgZmliZXIucmV0dXJuID0gd29ya0luUHJvZ3Jlc3M7XG4gIH1cblxuICB3aGlsZSAoZmliZXIgIT09IG51bGwpIHtcbiAgICB2YXIgbmV4dEZpYmVyID0gdm9pZCAwOyAvLyBWaXNpdCB0aGlzIGZpYmVyLlxuXG4gICAgdmFyIGxpc3QgPSBmaWJlci5kZXBlbmRlbmNpZXM7XG5cbiAgICBpZiAobGlzdCAhPT0gbnVsbCkge1xuICAgICAgbmV4dEZpYmVyID0gZmliZXIuY2hpbGQ7XG4gICAgICB2YXIgZGVwZW5kZW5jeSA9IGxpc3QuZmlyc3RDb250ZXh0O1xuXG4gICAgICB3aGlsZSAoZGVwZW5kZW5jeSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBDaGVjayBpZiB0aGUgY29udGV4dCBtYXRjaGVzLlxuICAgICAgICBpZiAoZGVwZW5kZW5jeS5jb250ZXh0ID09PSBjb250ZXh0KSB7XG4gICAgICAgICAgLy8gTWF0Y2ghIFNjaGVkdWxlIGFuIHVwZGF0ZSBvbiB0aGlzIGZpYmVyLlxuICAgICAgICAgIGlmIChmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICAvLyBTY2hlZHVsZSBhIGZvcmNlIHVwZGF0ZSBvbiB0aGUgd29yay1pbi1wcm9ncmVzcy5cbiAgICAgICAgICAgIHZhciBsYW5lID0gcGlja0FyYml0cmFyeUxhbmUocmVuZGVyTGFuZXMpO1xuICAgICAgICAgICAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShsYW5lKTtcbiAgICAgICAgICAgIHVwZGF0ZS50YWcgPSBGb3JjZVVwZGF0ZTsgLy8gVE9ETzogQmVjYXVzZSB3ZSBkb24ndCBoYXZlIGEgd29yay1pbi1wcm9ncmVzcywgdGhpcyB3aWxsIGFkZCB0aGVcbiAgICAgICAgICAgIC8vIHVwZGF0ZSB0byB0aGUgY3VycmVudCBmaWJlciwgdG9vLCB3aGljaCBtZWFucyBpdCB3aWxsIHBlcnNpc3QgZXZlbiBpZlxuICAgICAgICAgICAgLy8gdGhpcyByZW5kZXIgaXMgdGhyb3duIGF3YXkuIFNpbmNlIGl0J3MgYSByYWNlIGNvbmRpdGlvbiwgbm90IHN1cmUgaXQnc1xuICAgICAgICAgICAgLy8gd29ydGggZml4aW5nLlxuICAgICAgICAgICAgLy8gSW5saW5lZCBgZW5xdWV1ZVVwZGF0ZWAgdG8gcmVtb3ZlIGludGVybGVhdmVkIHVwZGF0ZSBjaGVja1xuXG4gICAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaWJlci51cGRhdGVRdWV1ZTtcblxuICAgICAgICAgICAgaWYgKHVwZGF0ZVF1ZXVlID09PSBudWxsKSA7IGVsc2Uge1xuICAgICAgICAgICAgICB2YXIgc2hhcmVkUXVldWUgPSB1cGRhdGVRdWV1ZS5zaGFyZWQ7XG4gICAgICAgICAgICAgIHZhciBwZW5kaW5nID0gc2hhcmVkUXVldWUucGVuZGluZztcblxuICAgICAgICAgICAgICBpZiAocGVuZGluZyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IHVwZGF0ZS4gQ3JlYXRlIGEgY2lyY3VsYXIgbGlzdC5cbiAgICAgICAgICAgICAgICB1cGRhdGUubmV4dCA9IHVwZGF0ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB1cGRhdGUubmV4dCA9IHBlbmRpbmcubmV4dDtcbiAgICAgICAgICAgICAgICBwZW5kaW5nLm5leHQgPSB1cGRhdGU7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzaGFyZWRRdWV1ZS5wZW5kaW5nID0gdXBkYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGZpYmVyLmxhbmVzID0gbWVyZ2VMYW5lcyhmaWJlci5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgICAgICAgICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBhbHRlcm5hdGUubGFuZXMgPSBtZXJnZUxhbmVzKGFsdGVybmF0ZS5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgoZmliZXIucmV0dXJuLCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpOyAvLyBNYXJrIHRoZSB1cGRhdGVkIGxhbmVzIG9uIHRoZSBsaXN0LCB0b28uXG5cbiAgICAgICAgICBsaXN0LmxhbmVzID0gbWVyZ2VMYW5lcyhsaXN0LmxhbmVzLCByZW5kZXJMYW5lcyk7IC8vIFNpbmNlIHdlIGFscmVhZHkgZm91bmQgYSBtYXRjaCwgd2UgY2FuIHN0b3AgdHJhdmVyc2luZyB0aGVcbiAgICAgICAgICAvLyBkZXBlbmRlbmN5IGxpc3QuXG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGRlcGVuZGVuY3kgPSBkZXBlbmRlbmN5Lm5leHQ7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmaWJlci50YWcgPT09IENvbnRleHRQcm92aWRlcikge1xuICAgICAgLy8gRG9uJ3Qgc2NhbiBkZWVwZXIgaWYgdGhpcyBpcyBhIG1hdGNoaW5nIHByb3ZpZGVyXG4gICAgICBuZXh0RmliZXIgPSBmaWJlci50eXBlID09PSB3b3JrSW5Qcm9ncmVzcy50eXBlID8gbnVsbCA6IGZpYmVyLmNoaWxkO1xuICAgIH0gZWxzZSBpZiAoZmliZXIudGFnID09PSBEZWh5ZHJhdGVkRnJhZ21lbnQpIHtcbiAgICAgIC8vIElmIGEgZGVoeWRyYXRlZCBzdXNwZW5zZSBib3VuZGFyeSBpcyBpbiB0aGlzIHN1YnRyZWUsIHdlIGRvbid0IGtub3dcbiAgICAgIC8vIGlmIGl0IHdpbGwgaGF2ZSBhbnkgY29udGV4dCBjb25zdW1lcnMgaW4gaXQuIFRoZSBiZXN0IHdlIGNhbiBkbyBpc1xuICAgICAgLy8gbWFyayBpdCBhcyBoYXZpbmcgdXBkYXRlcy5cbiAgICAgIHZhciBwYXJlbnRTdXNwZW5zZSA9IGZpYmVyLnJldHVybjtcblxuICAgICAgaWYgKHBhcmVudFN1c3BlbnNlID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV2UganVzdCBjYW1lIGZyb20gYSBwYXJlbnQgc28gd2UgbXVzdCBoYXZlIGhhZCBhIHBhcmVudC4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cblxuICAgICAgcGFyZW50U3VzcGVuc2UubGFuZXMgPSBtZXJnZUxhbmVzKHBhcmVudFN1c3BlbnNlLmxhbmVzLCByZW5kZXJMYW5lcyk7XG4gICAgICB2YXIgX2FsdGVybmF0ZSA9IHBhcmVudFN1c3BlbnNlLmFsdGVybmF0ZTtcblxuICAgICAgaWYgKF9hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgX2FsdGVybmF0ZS5sYW5lcyA9IG1lcmdlTGFuZXMoX2FsdGVybmF0ZS5sYW5lcywgcmVuZGVyTGFuZXMpO1xuICAgICAgfSAvLyBUaGlzIGlzIGludGVudGlvbmFsbHkgcGFzc2luZyB0aGlzIGZpYmVyIGFzIHRoZSBwYXJlbnRcbiAgICAgIC8vIGJlY2F1c2Ugd2Ugd2FudCB0byBzY2hlZHVsZSB0aGlzIGZpYmVyIGFzIGhhdmluZyB3b3JrXG4gICAgICAvLyBvbiBpdHMgY2hpbGRyZW4uIFdlJ2xsIHVzZSB0aGUgY2hpbGRMYW5lcyBvblxuICAgICAgLy8gdGhpcyBmaWJlciB0byBpbmRpY2F0ZSB0aGF0IGEgY29udGV4dCBoYXMgY2hhbmdlZC5cblxuXG4gICAgICBzY2hlZHVsZUNvbnRleHRXb3JrT25QYXJlbnRQYXRoKHBhcmVudFN1c3BlbnNlLCByZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3MpO1xuICAgICAgbmV4dEZpYmVyID0gZmliZXIuc2libGluZztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVHJhdmVyc2UgZG93bi5cbiAgICAgIG5leHRGaWJlciA9IGZpYmVyLmNoaWxkO1xuICAgIH1cblxuICAgIGlmIChuZXh0RmliZXIgIT09IG51bGwpIHtcbiAgICAgIC8vIFNldCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgdGhlIGNoaWxkIHRvIHRoZSB3b3JrLWluLXByb2dyZXNzIGZpYmVyLlxuICAgICAgbmV4dEZpYmVyLnJldHVybiA9IGZpYmVyO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBObyBjaGlsZC4gVHJhdmVyc2UgdG8gbmV4dCBzaWJsaW5nLlxuICAgICAgbmV4dEZpYmVyID0gZmliZXI7XG5cbiAgICAgIHdoaWxlIChuZXh0RmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5leHRGaWJlciA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAvLyBXZSdyZSBiYWNrIHRvIHRoZSByb290IG9mIHRoaXMgc3VidHJlZS4gRXhpdC5cbiAgICAgICAgICBuZXh0RmliZXIgPSBudWxsO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNpYmxpbmcgPSBuZXh0RmliZXIuc2libGluZztcblxuICAgICAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgIC8vIFNldCB0aGUgcmV0dXJuIHBvaW50ZXIgb2YgdGhlIHNpYmxpbmcgdG8gdGhlIHdvcmstaW4tcHJvZ3Jlc3MgZmliZXIuXG4gICAgICAgICAgc2libGluZy5yZXR1cm4gPSBuZXh0RmliZXIucmV0dXJuO1xuICAgICAgICAgIG5leHRGaWJlciA9IHNpYmxpbmc7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gLy8gTm8gbW9yZSBzaWJsaW5ncy4gVHJhdmVyc2UgdXAuXG5cblxuICAgICAgICBuZXh0RmliZXIgPSBuZXh0RmliZXIucmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZpYmVyID0gbmV4dEZpYmVyO1xuICB9XG59XG5mdW5jdGlvbiBwcmVwYXJlVG9SZWFkQ29udGV4dCh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgbGFzdENvbnRleHREZXBlbmRlbmN5ID0gbnVsbDtcbiAgbGFzdEZ1bGx5T2JzZXJ2ZWRDb250ZXh0ID0gbnVsbDtcbiAgdmFyIGRlcGVuZGVuY2llcyA9IHdvcmtJblByb2dyZXNzLmRlcGVuZGVuY2llcztcblxuICBpZiAoZGVwZW5kZW5jaWVzICE9PSBudWxsKSB7XG4gICAge1xuICAgICAgdmFyIGZpcnN0Q29udGV4dCA9IGRlcGVuZGVuY2llcy5maXJzdENvbnRleHQ7XG5cbiAgICAgIGlmIChmaXJzdENvbnRleHQgIT09IG51bGwpIHtcbiAgICAgICAgaWYgKGluY2x1ZGVzU29tZUxhbmUoZGVwZW5kZW5jaWVzLmxhbmVzLCByZW5kZXJMYW5lcykpIHtcbiAgICAgICAgICAvLyBDb250ZXh0IGxpc3QgaGFzIGEgcGVuZGluZyB1cGRhdGUuIE1hcmsgdGhhdCB0aGlzIGZpYmVyIHBlcmZvcm1lZCB3b3JrLlxuICAgICAgICAgIG1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlKCk7XG4gICAgICAgIH0gLy8gUmVzZXQgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgbGlzdFxuXG5cbiAgICAgICAgZGVwZW5kZW5jaWVzLmZpcnN0Q29udGV4dCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiByZWFkQ29udGV4dChjb250ZXh0KSB7XG4gIHtcbiAgICAvLyBUaGlzIHdhcm5pbmcgd291bGQgZmlyZSBpZiB5b3UgcmVhZCBjb250ZXh0IGluc2lkZSBhIEhvb2sgbGlrZSB1c2VNZW1vLlxuICAgIC8vIFVubGlrZSB0aGUgY2xhc3MgY2hlY2sgYmVsb3csIGl0J3Mgbm90IGVuZm9yY2VkIGluIHByb2R1Y3Rpb24gZm9yIHBlcmYuXG4gICAgaWYgKGlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYpIHtcbiAgICAgIGVycm9yKCdDb250ZXh0IGNhbiBvbmx5IGJlIHJlYWQgd2hpbGUgUmVhY3QgaXMgcmVuZGVyaW5nLiAnICsgJ0luIGNsYXNzZXMsIHlvdSBjYW4gcmVhZCBpdCBpbiB0aGUgcmVuZGVyIG1ldGhvZCBvciBnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMuICcgKyAnSW4gZnVuY3Rpb24gY29tcG9uZW50cywgeW91IGNhbiByZWFkIGl0IGRpcmVjdGx5IGluIHRoZSBmdW5jdGlvbiBib2R5LCBidXQgbm90ICcgKyAnaW5zaWRlIEhvb2tzIGxpa2UgdXNlUmVkdWNlcigpIG9yIHVzZU1lbW8oKS4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVhZENvbnRleHRGb3JDb25zdW1lcihjdXJyZW50bHlSZW5kZXJpbmdGaWJlciwgY29udGV4dCk7XG59XG5mdW5jdGlvbiByZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uKGNvbnN1bWVyLCBjb250ZXh0LCByZW5kZXJMYW5lcykge1xuICBpZiAoY3VycmVudGx5UmVuZGVyaW5nRmliZXIgPT09IG51bGwpIHtcbiAgICBwcmVwYXJlVG9SZWFkQ29udGV4dChjb25zdW1lciwgcmVuZGVyTGFuZXMpO1xuICB9XG5cbiAgcmV0dXJuIHJlYWRDb250ZXh0Rm9yQ29uc3VtZXIoY29uc3VtZXIsIGNvbnRleHQpO1xufVxuXG5mdW5jdGlvbiByZWFkQ29udGV4dEZvckNvbnN1bWVyKGNvbnN1bWVyLCBjb250ZXh0KSB7XG4gIHZhciB2YWx1ZSA9IGlzUHJpbWFyeVJlbmRlcmVyID8gY29udGV4dC5fY3VycmVudFZhbHVlIDogY29udGV4dC5fY3VycmVudFZhbHVlMjtcblxuICBpZiAobGFzdEZ1bGx5T2JzZXJ2ZWRDb250ZXh0ID09PSBjb250ZXh0KSA7IGVsc2Uge1xuICAgIHZhciBjb250ZXh0SXRlbSA9IHtcbiAgICAgIGNvbnRleHQ6IGNvbnRleHQsXG4gICAgICBtZW1vaXplZFZhbHVlOiB2YWx1ZSxcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuXG4gICAgaWYgKGxhc3RDb250ZXh0RGVwZW5kZW5jeSA9PT0gbnVsbCkge1xuICAgICAgaWYgKGNvbnN1bWVyID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGV4dCBjYW4gb25seSBiZSByZWFkIHdoaWxlIFJlYWN0IGlzIHJlbmRlcmluZy4gJyArICdJbiBjbGFzc2VzLCB5b3UgY2FuIHJlYWQgaXQgaW4gdGhlIHJlbmRlciBtZXRob2Qgb3IgZ2V0RGVyaXZlZFN0YXRlRnJvbVByb3BzLiAnICsgJ0luIGZ1bmN0aW9uIGNvbXBvbmVudHMsIHlvdSBjYW4gcmVhZCBpdCBkaXJlY3RseSBpbiB0aGUgZnVuY3Rpb24gYm9keSwgYnV0IG5vdCAnICsgJ2luc2lkZSBIb29rcyBsaWtlIHVzZVJlZHVjZXIoKSBvciB1c2VNZW1vKCkuJyk7XG4gICAgICB9IC8vIFRoaXMgaXMgdGhlIGZpcnN0IGRlcGVuZGVuY3kgZm9yIHRoaXMgY29tcG9uZW50LiBDcmVhdGUgYSBuZXcgbGlzdC5cblxuXG4gICAgICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBjb250ZXh0SXRlbTtcbiAgICAgIGNvbnN1bWVyLmRlcGVuZGVuY2llcyA9IHtcbiAgICAgICAgbGFuZXM6IE5vTGFuZXMsXG4gICAgICAgIGZpcnN0Q29udGV4dDogY29udGV4dEl0ZW1cbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFwcGVuZCBhIG5ldyBjb250ZXh0IGl0ZW0uXG4gICAgICBsYXN0Q29udGV4dERlcGVuZGVuY3kgPSBsYXN0Q29udGV4dERlcGVuZGVuY3kubmV4dCA9IGNvbnRleHRJdGVtO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB2YWx1ZTtcbn1cblxuLy8gcmVwbGFjZSBpdCB3aXRoIGEgbGlnaHR3ZWlnaHQgc2hpbSB0aGF0IG9ubHkgaGFzIHRoZSBmZWF0dXJlcyB3ZSB1c2UuXG5cbnZhciBBYm9ydENvbnRyb2xsZXJMb2NhbCA9IHR5cGVvZiBBYm9ydENvbnRyb2xsZXIgIT09ICd1bmRlZmluZWQnID8gQWJvcnRDb250cm9sbGVyIDogLy8gJEZsb3dGaXhNZVttaXNzaW5nLXRoaXMtYW5ub3RdXG4vLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbmZ1bmN0aW9uIEFib3J0Q29udHJvbGxlclNoaW0oKSB7XG4gIHZhciBsaXN0ZW5lcnMgPSBbXTtcbiAgdmFyIHNpZ25hbCA9IHRoaXMuc2lnbmFsID0ge1xuICAgIGFib3J0ZWQ6IGZhbHNlLFxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICh0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbiAgfTtcblxuICB0aGlzLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgIHNpZ25hbC5hYm9ydGVkID0gdHJ1ZTtcbiAgICBsaXN0ZW5lcnMuZm9yRWFjaChmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBsaXN0ZW5lcigpO1xuICAgIH0pO1xuICB9O1xufSA7IC8vIEludGVudGlvbmFsbHkgbm90IG5hbWVkIGltcG9ydHMgYmVjYXVzZSBSb2xsdXAgd291bGRcbi8vIHVzZSBkeW5hbWljIGRpc3BhdGNoIGZvciBDb21tb25KUyBpbnRlcm9wIG5hbWVkIGltcG9ydHMuXG5cbnZhciBzY2hlZHVsZUNhbGxiYWNrJDEgPSBTY2hlZHVsZXIudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayxcbiAgICBOb3JtYWxQcmlvcml0eSA9IFNjaGVkdWxlci51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eTtcbnZhciBDYWNoZUNvbnRleHQgPSB7XG4gICQkdHlwZW9mOiBSRUFDVF9DT05URVhUX1RZUEUsXG4gIC8vIFdlIGRvbid0IHVzZSBDb25zdW1lci9Qcm92aWRlciBmb3IgQ2FjaGUgY29tcG9uZW50cy4gU28gd2UnbGwgY2hlYXQuXG4gIENvbnN1bWVyOiBudWxsLFxuICBQcm92aWRlcjogbnVsbCxcbiAgLy8gV2UnbGwgaW5pdGlhbGl6ZSB0aGVzZSBhdCB0aGUgcm9vdC5cbiAgX2N1cnJlbnRWYWx1ZTogbnVsbCxcbiAgX2N1cnJlbnRWYWx1ZTI6IG51bGwsXG4gIF90aHJlYWRDb3VudDogMFxufSA7XG5cbntcbiAgQ2FjaGVDb250ZXh0Ll9jdXJyZW50UmVuZGVyZXIgPSBudWxsO1xuICBDYWNoZUNvbnRleHQuX2N1cnJlbnRSZW5kZXJlcjIgPSBudWxsO1xufSAvLyBDcmVhdGVzIGEgbmV3IGVtcHR5IENhY2hlIGluc3RhbmNlIHdpdGggYSByZWYtY291bnQgb2YgMC4gVGhlIGNhbGxlciBpcyByZXNwb25zaWJsZVxuLy8gZm9yIHJldGFpbmluZyB0aGUgY2FjaGUgb25jZSBpdCBpcyBpbiB1c2UgKHJldGFpbkNhY2hlKSwgYW5kIHJlbGVhc2luZyB0aGUgY2FjaGVcbi8vIG9uY2UgaXQgaXMgbm8gbG9uZ2VyIG5lZWRlZCAocmVsZWFzZUNhY2hlKS5cblxuXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcblxuICB2YXIgY2FjaGUgPSB7XG4gICAgY29udHJvbGxlcjogbmV3IEFib3J0Q29udHJvbGxlckxvY2FsKCksXG4gICAgZGF0YTogbmV3IE1hcCgpLFxuICAgIHJlZkNvdW50OiAwXG4gIH07XG4gIHJldHVybiBjYWNoZTtcbn1cbmZ1bmN0aW9uIHJldGFpbkNhY2hlKGNhY2hlKSB7XG5cbiAge1xuICAgIGlmIChjYWNoZS5jb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICB3YXJuKCdBIGNhY2hlIGluc3RhbmNlIHdhcyByZXRhaW5lZCBhZnRlciBpdCB3YXMgYWxyZWFkeSBmcmVlZC4gJyArICdUaGlzIGxpa2VseSBpbmRpY2F0ZXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgfVxuICB9XG5cbiAgY2FjaGUucmVmQ291bnQrKztcbn0gLy8gQ2xlYW51cCBhIGNhY2hlIGluc3RhbmNlLCBwb3RlbnRpYWxseSBmcmVlaW5nIGl0IGlmIHRoZXJlIGFyZSBubyBtb3JlIHJlZmVyZW5jZXNcblxuZnVuY3Rpb24gcmVsZWFzZUNhY2hlKGNhY2hlKSB7XG5cbiAgY2FjaGUucmVmQ291bnQtLTtcblxuICB7XG4gICAgaWYgKGNhY2hlLnJlZkNvdW50IDwgMCkge1xuICAgICAgd2FybignQSBjYWNoZSBpbnN0YW5jZSB3YXMgcmVsZWFzZWQgYWZ0ZXIgaXQgd2FzIGFscmVhZHkgZnJlZWQuICcgKyAnVGhpcyBsaWtlbHkgaW5kaWNhdGVzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChjYWNoZS5yZWZDb3VudCA9PT0gMCkge1xuICAgIHNjaGVkdWxlQ2FsbGJhY2skMShOb3JtYWxQcmlvcml0eSwgZnVuY3Rpb24gKCkge1xuICAgICAgY2FjaGUuY29udHJvbGxlci5hYm9ydCgpO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBwdXNoQ2FjaGVQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgY2FjaGUpIHtcblxuICBwdXNoUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MsIENhY2hlQ29udGV4dCwgY2FjaGUpO1xufVxuZnVuY3Rpb24gcG9wQ2FjaGVQcm92aWRlcih3b3JrSW5Qcm9ncmVzcywgY2FjaGUpIHtcblxuICBwb3BQcm92aWRlcihDYWNoZUNvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbn1cblxuLy8gdGhlIHNoYXJlZCBpbnRlcm5hbHMgb2JqZWN0LiBUaGlzIGlzIHVzZWQgYnkgdGhlIGlzb21vcnBoaWMgaW1wbGVtZW50YXRpb24gb2Zcbi8vIHN0YXJ0VHJhbnNpdGlvbiB0byBjb21wb3NlIGFsbCB0aGUgc3RhcnRUcmFuc2l0aW9ucyB0b2dldGhlci5cbi8vXG4vLyAgIGZ1bmN0aW9uIHN0YXJ0VHJhbnNpdGlvbihmbikge1xuLy8gICAgIHJldHVybiBzdGFydFRyYW5zaXRpb25ET00oKCkgPT4ge1xuLy8gICAgICAgcmV0dXJuIHN0YXJ0VHJhbnNpdGlvbkFSVCgoKSA9PiB7XG4vLyAgICAgICAgIHJldHVybiBzdGFydFRyYW5zaXRpb25UaHJlZUZpYmVyKCgpID0+IHtcbi8vICAgICAgICAgICAvLyBhbmQgc28gb24uLi5cbi8vICAgICAgICAgICByZXR1cm4gZm4oKTtcbi8vICAgICAgICAgfSk7XG4vLyAgICAgICB9KTtcbi8vICAgICB9KTtcbi8vICAgfVxuLy9cbi8vIEN1cnJlbnRseSB3ZSBvbmx5IGNvbXBvc2UgdG9nZXRoZXIgdGhlIGNvZGUgdGhhdCBydW5zIGF0IHRoZSBlbmQgb2YgZWFjaFxuLy8gc3RhcnRUcmFuc2l0aW9uLCBiZWNhdXNlIGZvciBub3cgdGhhdCdzIHN1ZmZpY2llbnQg4oCUIHRoZSBwYXJ0IHRoYXQgc2V0c1xuLy8gaXNUcmFuc2l0aW9uPXRydWUgb24gdGhlIHN0YWNrIHVzZXMgYSBzZXBhcmF0ZSBzaGFyZWQgaW50ZXJuYWwgZmllbGQuIEJ1dFxuLy8gcmVhbGx5IHdlIHNob3VsZCBkZWxldGUgdGhlIHNoYXJlZCBmaWVsZCBhbmQgdHJhY2sgaXNUcmFuc2l0aW9uIHBlclxuLy8gcmVjb25jaWxlci4gTGVhdmluZyB0aGlzIGZvciBhIGZ1dHVyZSBQUi5cblxudmFyIHByZXZPblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlM7XG5cblJlYWN0U2hhcmVkSW50ZXJuYWxzLlMgPSBmdW5jdGlvbiBvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaEZvclJlY29uY2lsZXIodHJhbnNpdGlvbiwgcmV0dXJuVmFsdWUpIHtcbiAgaWYgKHR5cGVvZiByZXR1cm5WYWx1ZSA9PT0gJ29iamVjdCcgJiYgcmV0dXJuVmFsdWUgIT09IG51bGwgJiYgdHlwZW9mIHJldHVyblZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBUaGlzIGlzIGFuIGFzeW5jIGFjdGlvblxuICAgIHZhciB0aGVuYWJsZSA9IHJldHVyblZhbHVlO1xuICAgIGVudGFuZ2xlQXN5bmNBY3Rpb24odHJhbnNpdGlvbiwgdGhlbmFibGUpO1xuICB9XG5cbiAgaWYgKHByZXZPblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCAhPT0gbnVsbCkge1xuICAgIHByZXZPblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCh0cmFuc2l0aW9uLCByZXR1cm5WYWx1ZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlcXVlc3RDdXJyZW50VHJhbnNpdGlvbigpIHtcbiAgcmV0dXJuIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQ7XG59IC8vIFdoZW4gcmV0cnlpbmcgYSBTdXNwZW5zZS9PZmZzY3JlZW4gYm91bmRhcnksIHdlIHJlc3RvcmUgdGhlIGNhY2hlIHRoYXQgd2FzXG4vLyB1c2VkIGR1cmluZyB0aGUgcHJldmlvdXMgcmVuZGVyIGJ5IHBsYWNpbmcgaXQgaGVyZSwgb24gdGhlIHN0YWNrLlxuXG52YXIgcmVzdW1lZENhY2hlID0gY3JlYXRlQ3Vyc29yKG51bGwpOyAvLyBEdXJpbmcgdGhlIHJlbmRlci9zeW5jaHJvbm91cyBjb21taXQgcGhhc2UsIHdlIGRvbid0IGFjdHVhbGx5IHByb2Nlc3MgdGhlXG5cbmZ1bmN0aW9uIHBlZWtDYWNoZUZyb21Qb29sKCkge1xuICAvLyBJZiB3ZSdyZSByZW5kZXJpbmcgaW5zaWRlIGEgU3VzcGVuc2UgYm91bmRhcnkgdGhhdCBpcyBjdXJyZW50bHkgaGlkZGVuLFxuICAvLyB3ZSBzaG91bGQgdXNlIHRoZSBzYW1lIGNhY2hlIHRoYXQgd2UgdXNlZCBkdXJpbmcgdGhlIHByZXZpb3VzIHJlbmRlciwgaWZcbiAgLy8gb25lIGV4aXN0cy5cblxuXG4gIHZhciBjYWNoZVJlc3VtZWRGcm9tUHJldmlvdXNSZW5kZXIgPSByZXN1bWVkQ2FjaGUuY3VycmVudDtcblxuICBpZiAoY2FjaGVSZXN1bWVkRnJvbVByZXZpb3VzUmVuZGVyICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNhY2hlUmVzdW1lZEZyb21QcmV2aW91c1JlbmRlcjtcbiAgfSAvLyBPdGhlcndpc2UsIGNoZWNrIHRoZSByb290J3MgY2FjaGUgcG9vbC5cblxuXG4gIHZhciByb290ID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCk7XG4gIHZhciBjYWNoZUZyb21Sb290Q2FjaGVQb29sID0gcm9vdC5wb29sZWRDYWNoZTtcbiAgcmV0dXJuIGNhY2hlRnJvbVJvb3RDYWNoZVBvb2w7XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RDYWNoZUZyb21Qb29sKHJlbmRlckxhbmVzKSB7XG4gIC8vIFNpbWlsYXIgdG8gcHJldmlvdXMgZnVuY3Rpb24sIGV4Y2VwdCBpZiB0aGVyZSdzIG5vdCBhbHJlYWR5IGEgY2FjaGUgaW4gdGhlXG4gIC8vIHBvb2wsIHdlIGFsbG9jYXRlIGEgbmV3IG9uZS5cbiAgdmFyIGNhY2hlRnJvbVBvb2wgPSBwZWVrQ2FjaGVGcm9tUG9vbCgpO1xuXG4gIGlmIChjYWNoZUZyb21Qb29sICE9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNhY2hlRnJvbVBvb2w7XG4gIH0gLy8gQ3JlYXRlIGEgZnJlc2ggY2FjaGUgYW5kIGFkZCBpdCB0byB0aGUgcm9vdCBjYWNoZSBwb29sLiBBIGNhY2hlIGNhbiBoYXZlXG4gIC8vIG11bHRpcGxlIG93bmVyczpcbiAgLy8gLSBBIGNhY2hlIHBvb2wgdGhhdCBsaXZlcyBvbiB0aGUgRmliZXJSb290LiBUaGlzIGlzIHdoZXJlIGFsbCBmcmVzaCBjYWNoZXNcbiAgLy8gICBhcmUgb3JpZ2luYWxseSBjcmVhdGVkIChUT0RPOiBleGNlcHQgZHVyaW5nIHJlZnJlc2hlcywgdW50aWwgd2UgaW1wbGVtZW50XG4gIC8vICAgdGhpcyBjb3JyZWN0bHkpLiBUaGUgcm9vdCB0YWtlcyBvd25lcnNoaXAgaW1tZWRpYXRlbHkgd2hlbiB0aGUgY2FjaGUgaXNcbiAgLy8gICBjcmVhdGVkLiBDb25jZXB0dWFsbHksIHJvb3QucG9vbGVkQ2FjaGUgaXMgYW4gT3B0aW9uPEFyYzxDYWNoZT4+IChvd25lZCksXG4gIC8vICAgYW5kIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBmdW5jdGlvbiBpcyBhICZBcmM8Q2FjaGU+IChib3Jyb3dlZCkuXG4gIC8vIC0gT25lIG9mIHNldmVyYWwgZmliZXIgdHlwZXM6IGhvc3Qgcm9vdCwgY2FjaGUgYm91bmRhcnksIHN1c3BlbnNlXG4gIC8vICAgY29tcG9uZW50LiBUaGVzZSByZXRhaW4gYW5kIHJlbGVhc2UgaW4gdGhlIGNvbW1pdCBwaGFzZS5cblxuXG4gIHZhciByb290ID0gZ2V0V29ya0luUHJvZ3Jlc3NSb290KCk7XG4gIHZhciBmcmVzaENhY2hlID0gY3JlYXRlQ2FjaGUoKTtcbiAgcm9vdC5wb29sZWRDYWNoZSA9IGZyZXNoQ2FjaGU7XG4gIHJldGFpbkNhY2hlKGZyZXNoQ2FjaGUpO1xuXG4gIGlmIChmcmVzaENhY2hlICE9PSBudWxsKSB7XG4gICAgcm9vdC5wb29sZWRDYWNoZUxhbmVzIHw9IHJlbmRlckxhbmVzO1xuICB9XG5cbiAgcmV0dXJuIGZyZXNoQ2FjaGU7XG59XG5mdW5jdGlvbiBwdXNoVHJhbnNpdGlvbihvZmZzY3JlZW5Xb3JrSW5Qcm9ncmVzcywgcHJldkNhY2hlUG9vbCwgbmV3VHJhbnNpdGlvbnMpIHtcbiAge1xuICAgIGlmIChwcmV2Q2FjaGVQb29sID09PSBudWxsKSB7XG4gICAgICBwdXNoKHJlc3VtZWRDYWNoZSwgcmVzdW1lZENhY2hlLmN1cnJlbnQsIG9mZnNjcmVlbldvcmtJblByb2dyZXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHVzaChyZXN1bWVkQ2FjaGUsIHByZXZDYWNoZVBvb2wucG9vbCwgb2Zmc2NyZWVuV29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcG9wVHJhbnNpdGlvbih3b3JrSW5Qcm9ncmVzcywgY3VycmVudCkge1xuICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuXG4gICAge1xuICAgICAgcG9wKHJlc3VtZWRDYWNoZSwgd29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZ2V0U3VzcGVuZGVkQ2FjaGUoKSB7XG4gIC8vIGNhY2hlIHRoYXQgd291bGQgaGF2ZSBiZWVuIHVzZWQgdG8gcmVuZGVyIGZyZXNoIGRhdGEgZHVyaW5nIHRoaXMgcmVuZGVyLFxuICAvLyBpZiB0aGVyZSB3YXMgYW55LCBzbyB0aGF0IHdlIGNhbiByZXN1bWUgcmVuZGVyaW5nIHdpdGggdGhlIHNhbWUgY2FjaGUgd2hlblxuICAvLyB3ZSByZWNlaXZlIG1vcmUgZGF0YS5cblxuXG4gIHZhciBjYWNoZUZyb21Qb29sID0gcGVla0NhY2hlRnJvbVBvb2woKTtcblxuICBpZiAoY2FjaGVGcm9tUG9vbCA9PT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBXZSBtdXN0IGFsc28gc2F2ZSB0aGUgcGFyZW50LCBzbyB0aGF0IHdoZW4gd2UgcmVzdW1lIHdlIGNhbiBkZXRlY3RcbiAgICAvLyBhIHJlZnJlc2guXG4gICAgcGFyZW50OiBpc1ByaW1hcnlSZW5kZXJlciA/IENhY2hlQ29udGV4dC5fY3VycmVudFZhbHVlIDogQ2FjaGVDb250ZXh0Ll9jdXJyZW50VmFsdWUyLFxuICAgIHBvb2w6IGNhY2hlRnJvbVBvb2xcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldE9mZnNjcmVlbkRlZmVycmVkQ2FjaGUoKSB7XG5cbiAgdmFyIGNhY2hlRnJvbVBvb2wgPSBwZWVrQ2FjaGVGcm9tUG9vbCgpO1xuXG4gIGlmIChjYWNoZUZyb21Qb29sID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8vIFdlIG11c3QgYWxzbyBzdG9yZSB0aGUgcGFyZW50LCBzbyB0aGF0IHdoZW4gd2UgcmVzdW1lIHdlIGNhbiBkZXRlY3RcbiAgICAvLyBhIHJlZnJlc2guXG4gICAgcGFyZW50OiBpc1ByaW1hcnlSZW5kZXJlciA/IENhY2hlQ29udGV4dC5fY3VycmVudFZhbHVlIDogQ2FjaGVDb250ZXh0Ll9jdXJyZW50VmFsdWUyLFxuICAgIHBvb2w6IGNhY2hlRnJvbVBvb2xcbiAgfTtcbn1cblxuLyoqXG4gKiBUYWcgdGhlIGZpYmVyIHdpdGggYW4gdXBkYXRlIGVmZmVjdC4gVGhpcyB0dXJucyBhIFBsYWNlbWVudCBpbnRvXG4gKiBhIFBsYWNlbWVudEFuZFVwZGF0ZS5cbiAqL1xuXG5mdW5jdGlvbiBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKSB7XG4gIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFVwZGF0ZTtcbn1cbi8qKlxuICogSW4gcGVyc2lzdGVudCBtb2RlLCByZXR1cm4gd2hldGhlciB0aGlzIHVwZGF0ZSBuZWVkcyB0byBjbG9uZSB0aGUgc3VidHJlZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIGRvZXNSZXF1aXJlQ2xvbmUoY3VycmVudCwgY29tcGxldGVkV29yaykge1xuICB2YXIgZGlkQmFpbG91dCA9IGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5jaGlsZCA9PT0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICBpZiAoZGlkQmFpbG91dCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGlmICgoY29tcGxldGVkV29yay5mbGFncyAmIENoaWxkRGVsZXRpb24pICE9PSBOb0ZsYWdzJDEpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBUT0RPOiBJZiB3ZSBtb3ZlIHRoZSBgZG9lc1JlcXVpcmVDbG9uZWAgY2FsbCBhZnRlciBgYnViYmxlUHJvcGVydGllc2BcbiAgLy8gdGhlbiB3ZSBvbmx5IGhhdmUgdG8gY2hlY2sgdGhlIGBjb21wbGV0ZWRXb3JrLnN1YnRyZWVGbGFnc2AuXG5cblxuICB2YXIgY2hpbGQgPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgIGlmICgoY2hpbGQuZmxhZ3MgJiBNdXRhdGlvbk1hc2spICE9PSBOb0ZsYWdzJDEgfHwgKGNoaWxkLnN1YnRyZWVGbGFncyAmIE11dGF0aW9uTWFzaykgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRBbGxDaGlsZHJlbihwYXJlbnQsIHdvcmtJblByb2dyZXNzLCBuZWVkc1Zpc2liaWxpdHlUb2dnbGUsIGlzSGlkZGVuKSB7XG4gIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICBhcHBlbmRJbml0aWFsQ2hpbGQocGFyZW50LCBub2RlLnN0YXRlTm9kZSk7XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0UG9ydGFsIHx8IChzdXBwb3J0c1NpbmdsZXRvbnMgPyBub2RlLnRhZyA9PT0gSG9zdFNpbmdsZXRvbiA6IGZhbHNlKSkgOyBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZSA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICBub2RlLnNpYmxpbmcucmV0dXJuID0gbm9kZS5yZXR1cm47XG4gICAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICAgIH1cbiAgfSBlbHNlIGlmIChzdXBwb3J0c1BlcnNpc3RlbmNlKSB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBfbm9kZSA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG4gICAgd2hpbGUgKF9ub2RlICE9PSBudWxsKSB7XG4gICAgICBpZiAoX25vZGUudGFnID09PSBIb3N0Q29tcG9uZW50KSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IF9ub2RlLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAobmVlZHNWaXNpYmlsaXR5VG9nZ2xlICYmIGlzSGlkZGVuKSB7XG4gICAgICAgICAgLy8gVGhpcyBjaGlsZCBpcyBpbnNpZGUgYSB0aW1lZCBvdXQgdHJlZS4gSGlkZSBpdC5cbiAgICAgICAgICB2YXIgcHJvcHMgPSBfbm9kZS5tZW1vaXplZFByb3BzO1xuICAgICAgICAgIHZhciB0eXBlID0gX25vZGUudHlwZTtcbiAgICAgICAgICBpbnN0YW5jZSA9IGNsb25lSGlkZGVuSW5zdGFuY2UoaW5zdGFuY2UsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGVuZEluaXRpYWxDaGlsZChwYXJlbnQsIGluc3RhbmNlKTtcbiAgICAgIH0gZWxzZSBpZiAoX25vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICB2YXIgX2luc3RhbmNlID0gX25vZGUuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChuZWVkc1Zpc2liaWxpdHlUb2dnbGUgJiYgaXNIaWRkZW4pIHtcbiAgICAgICAgICAvLyBUaGlzIGNoaWxkIGlzIGluc2lkZSBhIHRpbWVkIG91dCB0cmVlLiBIaWRlIGl0LlxuICAgICAgICAgIHZhciB0ZXh0ID0gX25vZGUubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICBfaW5zdGFuY2UgPSBjbG9uZUhpZGRlblRleHRJbnN0YW5jZShfaW5zdGFuY2UsIHRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYXBwZW5kSW5pdGlhbENoaWxkKHBhcmVudCwgX2luc3RhbmNlKTtcbiAgICAgIH0gZWxzZSBpZiAoX25vZGUudGFnID09PSBIb3N0UG9ydGFsKSA7IGVsc2UgaWYgKF9ub2RlLnRhZyA9PT0gT2Zmc2NyZWVuQ29tcG9uZW50ICYmIF9ub2RlLm1lbW9pemVkU3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhlIGNoaWxkcmVuIGluIHRoaXMgYm91bmRhcnkgYXJlIGhpZGRlbi4gVG9nZ2xlIHRoZWlyIHZpc2liaWxpdHlcbiAgICAgICAgLy8gYmVmb3JlIGFwcGVuZGluZy5cbiAgICAgICAgdmFyIGNoaWxkID0gX25vZGUuY2hpbGQ7XG5cbiAgICAgICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgICAgY2hpbGQucmV0dXJuID0gX25vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBhcHBlbmRBbGxDaGlsZHJlbihwYXJlbnQsIF9ub2RlLFxuICAgICAgICAvKiBuZWVkc1Zpc2liaWxpdHlUb2dnbGUgKi9cbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgLyogaXNIaWRkZW4gKi9cbiAgICAgICAgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKF9ub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIF9ub2RlLmNoaWxkLnJldHVybiA9IF9ub2RlO1xuICAgICAgICBfbm9kZSA9IF9ub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKF9ub2RlID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG5cbiAgICAgIHdoaWxlIChfbm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuICAgICAgICBpZiAoX25vZGUucmV0dXJuID09PSBudWxsIHx8IF9ub2RlLnJldHVybiA9PT0gd29ya0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBfbm9kZSA9IF9ub2RlLnJldHVybjtcbiAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgX25vZGUuc2libGluZy5yZXR1cm4gPSBfbm9kZS5yZXR1cm47XG4gICAgICBfbm9kZSA9IF9ub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG59IC8vIEFuIHVuZm9ydHVuYXRlIGZvcmsgb2YgYXBwZW5kQWxsQ2hpbGRyZW4gYmVjYXVzZSB3ZSBoYXZlIHR3byBkaWZmZXJlbnQgcGFyZW50IHR5cGVzLlxuXG5cbmZ1bmN0aW9uIGFwcGVuZEFsbENoaWxkcmVuVG9Db250YWluZXIoY29udGFpbmVyQ2hpbGRTZXQsIHdvcmtJblByb2dyZXNzLCBuZWVkc1Zpc2liaWxpdHlUb2dnbGUsIGlzSGlkZGVuKSB7XG4gIGlmIChzdXBwb3J0c1BlcnNpc3RlbmNlKSB7XG4gICAgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgY3JlYXRlZCBidXQgd2UgbmVlZCByZWN1cnNlIGRvd24gaXRzXG4gICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuICAgIHZhciBub2RlID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICB3aGlsZSAobm9kZSAhPT0gbnVsbCkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50KSB7XG4gICAgICAgIHZhciBpbnN0YW5jZSA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChuZWVkc1Zpc2liaWxpdHlUb2dnbGUgJiYgaXNIaWRkZW4pIHtcbiAgICAgICAgICAvLyBUaGlzIGNoaWxkIGlzIGluc2lkZSBhIHRpbWVkIG91dCB0cmVlLiBIaWRlIGl0LlxuICAgICAgICAgIHZhciBwcm9wcyA9IG5vZGUubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICB2YXIgdHlwZSA9IG5vZGUudHlwZTtcbiAgICAgICAgICBpbnN0YW5jZSA9IGNsb25lSGlkZGVuSW5zdGFuY2UoaW5zdGFuY2UsIHR5cGUsIHByb3BzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXJDaGlsZFNldChjb250YWluZXJDaGlsZFNldCwgaW5zdGFuY2UpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFRleHQpIHtcbiAgICAgICAgdmFyIF9pbnN0YW5jZTIgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAobmVlZHNWaXNpYmlsaXR5VG9nZ2xlICYmIGlzSGlkZGVuKSB7XG4gICAgICAgICAgLy8gVGhpcyBjaGlsZCBpcyBpbnNpZGUgYSB0aW1lZCBvdXQgdHJlZS4gSGlkZSBpdC5cbiAgICAgICAgICB2YXIgdGV4dCA9IG5vZGUubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICBfaW5zdGFuY2UyID0gY2xvbmVIaWRkZW5UZXh0SW5zdGFuY2UoX2luc3RhbmNlMiwgdGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICBhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQoY29udGFpbmVyQ2hpbGRTZXQsIF9pbnN0YW5jZTIpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkgOyBlbHNlIGlmIChub2RlLnRhZyA9PT0gT2Zmc2NyZWVuQ29tcG9uZW50ICYmIG5vZGUubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGUgY2hpbGRyZW4gaW4gdGhpcyBib3VuZGFyeSBhcmUgaGlkZGVuLiBUb2dnbGUgdGhlaXIgdmlzaWJpbGl0eVxuICAgICAgICAvLyBiZWZvcmUgYXBwZW5kaW5nLlxuICAgICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkO1xuXG4gICAgICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAgIGNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgIH0gLy8gSWYgT2Zmc2NyZWVuIGlzIG5vdCBpbiBtYW51YWwgbW9kZSwgZGV0YWNoZWQgdHJlZSBpcyBoaWRkZW4gZnJvbSB1c2VyIHNwYWNlLlxuXG5cbiAgICAgICAgdmFyIF9uZWVkc1Zpc2liaWxpdHlUb2dnbGUgPSAhaXNPZmZzY3JlZW5NYW51YWwobm9kZSk7XG5cbiAgICAgICAgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lcihjb250YWluZXJDaGlsZFNldCwgbm9kZSxcbiAgICAgICAgLyogbmVlZHNWaXNpYmlsaXR5VG9nZ2xlICovXG4gICAgICAgIF9uZWVkc1Zpc2liaWxpdHlUb2dnbGUsXG4gICAgICAgIC8qIGlzSGlkZGVuICovXG4gICAgICAgIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChub2RlLmNoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBub2RlID0gbm9kZTtcblxuICAgICAgaWYgKG5vZGUgPT09IHdvcmtJblByb2dyZXNzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgd2hpbGUgKG5vZGUuc2libGluZyA9PT0gbnVsbCkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSB3b3JrSW5Qcm9ncmVzcykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlSG9zdENvbnRhaW5lcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcykge1xuICBpZiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAgIGlmIChkb2VzUmVxdWlyZUNsb25lKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzKSkge1xuICAgICAgdmFyIHBvcnRhbE9yUm9vdCA9IHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZTtcbiAgICAgIHZhciBjb250YWluZXIgPSBwb3J0YWxPclJvb3QuY29udGFpbmVySW5mbztcbiAgICAgIHZhciBuZXdDaGlsZFNldCA9IGNyZWF0ZUNvbnRhaW5lckNoaWxkU2V0KCk7IC8vIElmIGNoaWxkcmVuIG1pZ2h0IGhhdmUgY2hhbmdlZCwgd2UgaGF2ZSB0byBhZGQgdGhlbSBhbGwgdG8gdGhlIHNldC5cblxuICAgICAgYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lcihuZXdDaGlsZFNldCwgd29ya0luUHJvZ3Jlc3MsXG4gICAgICAvKiBuZWVkc1Zpc2liaWxpdHlUb2dnbGUgKi9cbiAgICAgIGZhbHNlLFxuICAgICAgLyogaXNIaWRkZW4gKi9cbiAgICAgIGZhbHNlKTtcbiAgICAgIHBvcnRhbE9yUm9vdC5wZW5kaW5nQ2hpbGRyZW4gPSBuZXdDaGlsZFNldDsgLy8gU2NoZWR1bGUgYW4gdXBkYXRlIG9uIHRoZSBjb250YWluZXIgdG8gc3dhcCBvdXQgdGhlIGNvbnRhaW5lci5cblxuICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICBmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lciwgbmV3Q2hpbGRTZXQpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCB0eXBlLCBuZXdQcm9wcywgcmVuZGVyTGFuZXMpIHtcbiAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAvLyBJZiB3ZSBoYXZlIGFuIGFsdGVybmF0ZSwgdGhhdCBtZWFucyB0aGlzIGlzIGFuIHVwZGF0ZSBhbmQgd2UgbmVlZCB0b1xuICAgIC8vIHNjaGVkdWxlIGEgc2lkZS1lZmZlY3QgdG8gZG8gdGhlIHVwZGF0ZXMuXG4gICAgdmFyIG9sZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuXG4gICAgaWYgKG9sZFByb3BzID09PSBuZXdQcm9wcykge1xuICAgICAgLy8gSW4gbXV0YXRpb24gbW9kZSwgdGhpcyBpcyBzdWZmaWNpZW50IGZvciBhIGJhaWxvdXQgYmVjYXVzZVxuICAgICAgLy8gd2Ugd29uJ3QgdG91Y2ggdGhpcyBub2RlIGV2ZW4gaWYgY2hpbGRyZW4gY2hhbmdlZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgfSBlbHNlIGlmIChzdXBwb3J0c1BlcnNpc3RlbmNlKSB7XG4gICAgdmFyIGN1cnJlbnRJbnN0YW5jZSA9IGN1cnJlbnQuc3RhdGVOb2RlO1xuICAgIHZhciBfb2xkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7IC8vIElmIHRoZXJlIGFyZSBubyBlZmZlY3RzIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vZGUsIHRoZW4gbm9uZSBvZiBvdXIgY2hpbGRyZW4gaGFkIGFueSB1cGRhdGVzLlxuICAgIC8vIFRoaXMgZ3VhcmFudGVlcyB0aGF0IHdlIGNhbiByZXVzZSBhbGwgb2YgdGhlbS5cblxuICAgIHZhciByZXF1aXJlc0Nsb25lID0gZG9lc1JlcXVpcmVDbG9uZShjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICBpZiAoIXJlcXVpcmVzQ2xvbmUgJiYgX29sZFByb3BzID09PSBuZXdQcm9wcykge1xuICAgICAgLy8gTm8gY2hhbmdlcywganVzdCByZXVzZSB0aGUgZXhpc3RpbmcgaW5zdGFuY2UuXG4gICAgICAvLyBOb3RlIHRoYXQgdGhpcyBtaWdodCByZWxlYXNlIGEgcHJldmlvdXMgY2xvbmUuXG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjdXJyZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgdmFyIG5ld0NoaWxkU2V0ID0gbnVsbDtcblxuICAgIGlmIChyZXF1aXJlc0Nsb25lICYmIHBhc3NDaGlsZHJlbldoZW5DbG9uaW5nUGVyc2lzdGVkTm9kZXMpIHtcbiAgICAgIG5ld0NoaWxkU2V0ID0gY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQoKTsgLy8gSWYgY2hpbGRyZW4gbWlnaHQgaGF2ZSBjaGFuZ2VkLCB3ZSBoYXZlIHRvIGFkZCB0aGVtIGFsbCB0byB0aGUgc2V0LlxuXG4gICAgICBhcHBlbmRBbGxDaGlsZHJlblRvQ29udGFpbmVyKG5ld0NoaWxkU2V0LCB3b3JrSW5Qcm9ncmVzcyxcbiAgICAgIC8qIG5lZWRzVmlzaWJpbGl0eVRvZ2dsZSAqL1xuICAgICAgZmFsc2UsXG4gICAgICAvKiBpc0hpZGRlbiAqL1xuICAgICAgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciBuZXdJbnN0YW5jZSA9IGNsb25lSW5zdGFuY2UoY3VycmVudEluc3RhbmNlLCB0eXBlLCBfb2xkUHJvcHMsIG5ld1Byb3BzLCAhcmVxdWlyZXNDbG9uZSwgbmV3Q2hpbGRTZXQpO1xuXG4gICAgaWYgKG5ld0luc3RhbmNlID09PSBjdXJyZW50SW5zdGFuY2UpIHtcbiAgICAgIC8vIE5vIGNoYW5nZXMsIGp1c3QgcmV1c2UgdGhlIGV4aXN0aW5nIGluc3RhbmNlLlxuICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgbWlnaHQgcmVsZWFzZSBhIHByZXZpb3VzIGNsb25lLlxuICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudEluc3RhbmNlO1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gQ2VydGFpbiByZW5kZXJlcnMgcmVxdWlyZSBjb21taXQtdGltZSBlZmZlY3RzIGZvciBpbml0aWFsIG1vdW50LlxuICAgIC8vIChlZyBET00gcmVuZGVyZXIgc3VwcG9ydHMgYXV0by1mb2N1cyBmb3IgY2VydGFpbiBlbGVtZW50cykuXG4gICAgLy8gTWFrZSBzdXJlIHN1Y2ggcmVuZGVyZXJzIGdldCBzY2hlZHVsZWQgZm9yIGxhdGVyIHdvcmsuXG5cblxuICAgIGlmIChmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihuZXdJbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMsIGN1cnJlbnRIb3N0Q29udGV4dCkpIHtcbiAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IG5ld0luc3RhbmNlO1xuXG4gICAgaWYgKCFyZXF1aXJlc0Nsb25lKSB7XG4gICAgICAvLyBJZiB0aGVyZSBhcmUgbm8gb3RoZXIgZWZmZWN0cyBpbiB0aGlzIHRyZWUsIHdlIG5lZWQgdG8gZmxhZyB0aGlzIG5vZGUgYXMgaGF2aW5nIG9uZS5cbiAgICAgIC8vIEV2ZW4gdGhvdWdoIHdlJ3JlIG5vdCBnb2luZyB0byB1c2UgaXQgZm9yIGFueXRoaW5nLlxuICAgICAgLy8gT3RoZXJ3aXNlIHBhcmVudHMgd29uJ3Qga25vdyB0aGF0IHRoZXJlIGFyZSBuZXcgY2hpbGRyZW4gdG8gcHJvcGFnYXRlIHVwd2FyZHMuXG4gICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gSWYgY2hpbGRyZW4gbWlnaHQgaGF2ZSBjaGFuZ2VkLCB3ZSBoYXZlIHRvIGFkZCB0aGVtIGFsbCB0byB0aGUgc2V0LlxuICAgICAgYXBwZW5kQWxsQ2hpbGRyZW4obmV3SW5zdGFuY2UsIHdvcmtJblByb2dyZXNzLFxuICAgICAgLyogbmVlZHNWaXNpYmlsaXR5VG9nZ2xlICovXG4gICAgICBmYWxzZSxcbiAgICAgIC8qIGlzSGlkZGVuICovXG4gICAgICBmYWxzZSk7XG4gICAgfVxuICB9XG59IC8vIFRoaXMgZnVuY3Rpb24gbXVzdCBiZSBjYWxsZWQgYXQgdGhlIHZlcnkgZW5kIG9mIHRoZSBjb21wbGV0ZSBwaGFzZSwgYmVjYXVzZVxuLy8gaXQgbWlnaHQgdGhyb3cgdG8gc3VzcGVuZCwgYW5kIGlmIHRoZSByZXNvdXJjZSBpbW1lZGlhdGVseSBsb2FkcywgdGhlIHdvcmtcbi8vIGxvb3Agd2lsbCByZXN1bWUgcmVuZGVyaW5nIGFzIGlmIHRoZSB3b3JrLWluLXByb2dyZXNzIGNvbXBsZXRlZC4gU28gaXQgbXVzdFxuLy8gZnVsbHkgY29tcGxldGUuXG4vLyBUT0RPOiBUaGlzIHNob3VsZCBpZGVhbGx5IG1vdmUgdG8gYmVnaW4gcGhhc2UsIGJ1dCBjdXJyZW50bHkgdGhlIGluc3RhbmNlIGlzXG4vLyBub3QgY3JlYXRlZCB1bnRpbCB0aGUgY29tcGxldGUgcGhhc2UuIEZvciBvdXIgZXhpc3RpbmcgdXNlIGNhc2VzLCBob3N0IG5vZGVzXG4vLyB0aGF0IHN1c3BlbmQgZG9uJ3QgaGF2ZSBjaGlsZHJlbiwgc28gaXQgZG9lc24ndCBtYXR0ZXIuIEJ1dCB0aGF0IG1pZ2h0IG5vdFxuLy8gYWx3YXlzIGJlIHRydWUgaW4gdGhlIGZ1dHVyZS5cblxuXG5mdW5jdGlvbiBwcmVsb2FkSW5zdGFuY2VBbmRTdXNwZW5kSWZOZWVkZWQod29ya0luUHJvZ3Jlc3MsIHR5cGUsIHByb3BzLCByZW5kZXJMYW5lcykge1xuICBpZiAoIW1heVN1c3BlbmRDb21taXQodHlwZSwgcHJvcHMpKSB7XG4gICAgLy8gSWYgdGhpcyBmbGFnIHdhcyBzZXQgcHJldmlvdXNseSwgd2UgY2FuIHJlbW92ZSBpdC4gVGhlIGZsYWdcbiAgICAvLyByZXByZXNlbnRzIHdoZXRoZXIgdGhpcyBwYXJ0aWN1bGFyIHNldCBvZiBwcm9wcyBtaWdodCBldmVyIG5lZWQgdG9cbiAgICAvLyBzdXNwZW5kLiBUaGUgc2FmZXN0IHRoaW5nIHRvIGRvIGlzIGZvciBtYXlTdXNwZW5kQ29tbWl0IHRvIGFsd2F5c1xuICAgIC8vIHJldHVybiB0cnVlLCBidXQgaWYgdGhlIHJlbmRlcmVyIGlzIHJlYXNvbmFibHkgY29uZmlkZW50IHRoYXQgdGhlXG4gICAgLy8gdW5kZXJseWluZyByZXNvdXJjZSB3b24ndCBiZSBldmljdGVkLCBpdCBjYW4gcmV0dXJuIGZhbHNlIGFzIGFcbiAgICAvLyBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24uXG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgJj0gfk1heVN1c3BlbmRDb21taXQ7XG4gICAgcmV0dXJuO1xuICB9IC8vIE1hcmsgdGhpcyBmaWJlciB3aXRoIGEgZmxhZy4gVGhpcyBnZXRzIHNldCBvbiBhbGwgaG9zdCBpbnN0YW5jZXNcbiAgLy8gdGhhdCBtaWdodCBwb3NzaWJseSBzdXNwZW5kLCBldmVuIGlmIHRoZXkgZG9uJ3QgbmVlZCB0byBzdXNwZW5kXG4gIC8vIGN1cnJlbnRseS4gV2UgdXNlIHRoaXMgd2hlbiByZXZlYWxpbmcgYSBwcmVyZW5kZXJlZCB0cmVlLCBiZWNhdXNlXG4gIC8vIGV2ZW4gdGhvdWdoIHRoZSB0cmVlIGhhcyBcIm1vdW50ZWRcIiwgaXRzIHJlc291cmNlcyBtaWdodCBub3QgaGF2ZVxuICAvLyBsb2FkZWQgeWV0LlxuXG5cbiAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gTWF5U3VzcGVuZENvbW1pdDsgLy8gcHJlbG9hZCB0aGUgaW5zdGFuY2UgaWYgbmVjZXNzYXJ5LiBFdmVuIGlmIHRoaXMgaXMgYW4gdXJnZW50IHJlbmRlciB0aGVyZVxuICAvLyBjb3VsZCBiZSBiZW5lZml0cyB0byBwcmVsb2FkaW5nIGVhcmx5LlxuICAvLyBAVE9ETyB3ZSBzaG91bGQgcHJvYmFibHkgZG8gdGhlIHByZWxvYWQgaW4gYmVnaW4gd29ya1xuXG4gIHZhciBpc1JlYWR5ID0gcHJlbG9hZEluc3RhbmNlKHR5cGUsIHByb3BzKTtcblxuICBpZiAoIWlzUmVhZHkpIHtcbiAgICBpZiAoc2hvdWxkUmVtYWluT25QcmV2aW91c1NjcmVlbigpKSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTaG91bGRTdXNwZW5kQ29tbWl0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdXNwZW5kQ29tbWl0KCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByZWxvYWRSZXNvdXJjZUFuZFN1c3BlbmRJZk5lZWRlZCh3b3JrSW5Qcm9ncmVzcywgcmVzb3VyY2UsIHR5cGUsIHByb3BzLCByZW5kZXJMYW5lcykge1xuICAvLyBUaGlzIGlzIGEgZm9yayBvZiBwcmVsb2FkSW5zdGFuY2VBbmRTdXNwZW5kSWZOZWVkZWQsIGJ1dCBmb3IgcmVzb3VyY2VzLlxuICBpZiAoIW1heVJlc291cmNlU3VzcGVuZENvbW1pdChyZXNvdXJjZSkpIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSB+TWF5U3VzcGVuZENvbW1pdDtcbiAgICByZXR1cm47XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBNYXlTdXNwZW5kQ29tbWl0O1xuICB2YXIgaXNSZWFkeSA9IHByZWxvYWRSZXNvdXJjZShyZXNvdXJjZSk7XG5cbiAgaWYgKCFpc1JlYWR5KSB7XG4gICAgaWYgKHNob3VsZFJlbWFpbk9uUHJldmlvdXNTY3JlZW4oKSkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gU2hvdWxkU3VzcGVuZENvbW1pdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3VzcGVuZENvbW1pdCgpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzY2hlZHVsZVJldHJ5RWZmZWN0KHdvcmtJblByb2dyZXNzLCByZXRyeVF1ZXVlKSB7XG4gIHZhciB3YWtlYWJsZXMgPSByZXRyeVF1ZXVlO1xuXG4gIGlmICh3YWtlYWJsZXMgIT09IG51bGwpIHtcbiAgICAvLyBTY2hlZHVsZSBhbiBlZmZlY3QgdG8gYXR0YWNoIGEgcmV0cnkgbGlzdGVuZXIgdG8gdGhlIHByb21pc2UuXG4gICAgLy8gVE9ETzogTW92ZSB0byBwYXNzaXZlIHBoYXNlXG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgYm91bmRhcnkgc3VzcGVuZGVkLCBidXQgbm8gd2FrZWFibGVzIHdlcmUgYWRkZWQgdG8gdGhlIHJldHJ5XG4gICAgLy8gcXVldWUuIENoZWNrIGlmIHRoZSByZW5kZXJlciBzdXNwZW5kZWQgY29tbWl0LiBJZiBzbywgdGhpcyBtZWFuc1xuICAgIC8vIHRoYXQgb25jZSB0aGUgZmFsbGJhY2sgaXMgY29tbWl0dGVkLCB3ZSBjYW4gaW1tZWRpYXRlbHkgcmV0cnlcbiAgICAvLyByZW5kZXJpbmcgYWdhaW4sIGJlY2F1c2UgcmVuZGVyaW5nIHdhc24ndCBhY3R1YWxseSBibG9ja2VkLiBPbmx5XG4gICAgLy8gdGhlIGNvbW1pdCBwaGFzZS5cbiAgICAvLyBUT0RPOiBDb25zaWRlciBhIG1vZGVsIHdoZXJlIHdlIGFsd2F5cyBzY2hlZHVsZSBhbiBpbW1lZGlhdGUgcmV0cnksIGV2ZW5cbiAgICAvLyBmb3Igbm9ybWFsIFN1c3BlbnNlLiBUaGF0IHdheSB0aGUgcmV0cnkgY2FuIHBhcnRpYWxseSByZW5kZXIgdXAgdG8gdGhlXG4gICAgLy8gZmlyc3QgdGhpbmcgdGhhdCBzdXNwZW5kcy5cbiAgICBpZiAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBTY2hlZHVsZVJldHJ5KSB7XG4gICAgICB2YXIgcmV0cnlMYW5lID0gLy8gVE9ETzogVGhpcyBjaGVjayBzaG91bGQgcHJvYmFibHkgYmUgbW92ZWQgaW50byBjbGFpbU5leHRSZXRyeUxhbmVcbiAgICAgIC8vIEkgYWxzbyBzdXNwZWN0IHRoYXQgd2UgbmVlZCBzb21lIGZ1cnRoZXIgY29uc29saWRhdGlvbiBvZiBvZmZzY3JlZW5cbiAgICAgIC8vIGFuZCByZXRyeSBsYW5lcy5cbiAgICAgIHdvcmtJblByb2dyZXNzLnRhZyAhPT0gT2Zmc2NyZWVuQ29tcG9uZW50ID8gY2xhaW1OZXh0UmV0cnlMYW5lKCkgOiBPZmZzY3JlZW5MYW5lO1xuICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBtZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzLmxhbmVzLCByZXRyeUxhbmUpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB1cGRhdGVIb3N0VGV4dChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgb2xkVGV4dCwgbmV3VGV4dCkge1xuICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgIC8vIElmIHRoZSB0ZXh0IGRpZmZlcnMsIG1hcmsgaXQgYXMgYW4gdXBkYXRlLiBBbGwgdGhlIHdvcmsgaW4gZG9uZSBpbiBjb21taXRXb3JrLlxuICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAgIGlmIChvbGRUZXh0ICE9PSBuZXdUZXh0KSB7XG4gICAgICAvLyBJZiB0aGUgdGV4dCBjb250ZW50IGRpZmZlcnMsIHdlJ2xsIGNyZWF0ZSBhIG5ldyB0ZXh0IGluc3RhbmNlIGZvciBpdC5cbiAgICAgIHZhciByb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgdmFyIGN1cnJlbnRIb3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG4gICAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBjcmVhdGVUZXh0SW5zdGFuY2UobmV3VGV4dCwgcm9vdENvbnRhaW5lckluc3RhbmNlLCBjdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTsgLy8gV2UnbGwgaGF2ZSB0byBtYXJrIGl0IGFzIGhhdmluZyBhbiBlZmZlY3QsIGV2ZW4gdGhvdWdoIHdlIHdvbid0IHVzZSB0aGUgZWZmZWN0IGZvciBhbnl0aGluZy5cbiAgICAgIC8vIFRoaXMgbGV0cyB0aGUgcGFyZW50cyBrbm93IHRoYXQgYXQgbGVhc3Qgb25lIG9mIHRoZWlyIGNoaWxkcmVuIGhhcyBjaGFuZ2VkLlxuXG4gICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgaGFzUmVuZGVyZWRBVGFpbEZhbGxiYWNrKSB7XG4gIGlmIChnZXRJc0h5ZHJhdGluZygpKSB7XG4gICAgLy8gSWYgd2UncmUgaHlkcmF0aW5nLCB3ZSBzaG91bGQgY29uc3VtZSBhcyBtYW55IGl0ZW1zIGFzIHdlIGNhblxuICAgIC8vIHNvIHdlIGRvbid0IGxlYXZlIGFueSBiZWhpbmQuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3dpdGNoIChyZW5kZXJTdGF0ZS50YWlsTW9kZSkge1xuICAgIGNhc2UgJ2hpZGRlbic6XG4gICAgICB7XG4gICAgICAgIC8vIEFueSBpbnNlcnRpb25zIGF0IHRoZSBlbmQgb2YgdGhlIHRhaWwgbGlzdCBhZnRlciB0aGlzIHBvaW50XG4gICAgICAgIC8vIHNob3VsZCBiZSBpbnZpc2libGUuIElmIHRoZXJlIGFyZSBhbHJlYWR5IG1vdW50ZWQgYm91bmRhcmllc1xuICAgICAgICAvLyBhbnl0aGluZyBiZWZvcmUgdGhlbSBhcmUgbm90IGNvbnNpZGVyZWQgZm9yIGNvbGxhcHNpbmcuXG4gICAgICAgIC8vIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIGdvIHRocm91Z2ggdGhlIHdob2xlIHRhaWwgdG8gZmluZCBpZlxuICAgICAgICAvLyB0aGVyZSBhcmUgYW55LlxuICAgICAgICB2YXIgdGFpbE5vZGUgPSByZW5kZXJTdGF0ZS50YWlsO1xuICAgICAgICB2YXIgbGFzdFRhaWxOb2RlID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAodGFpbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAodGFpbE5vZGUuYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBsYXN0VGFpbE5vZGUgPSB0YWlsTm9kZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0YWlsTm9kZSA9IHRhaWxOb2RlLnNpYmxpbmc7XG4gICAgICAgIH0gLy8gTmV4dCB3ZSdyZSBzaW1wbHkgZ29pbmcgdG8gZGVsZXRlIGFsbCBpbnNlcnRpb25zIGFmdGVyIHRoZVxuICAgICAgICAvLyBsYXN0IHJlbmRlcmVkIGl0ZW0uXG5cblxuICAgICAgICBpZiAobGFzdFRhaWxOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gQWxsIHJlbWFpbmluZyBpdGVtcyBpbiB0aGUgdGFpbCBhcmUgaW5zZXJ0aW9ucy5cbiAgICAgICAgICByZW5kZXJTdGF0ZS50YWlsID0gbnVsbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBEZXRhY2ggdGhlIGluc2VydGlvbiBhZnRlciB0aGUgbGFzdCBub2RlIHRoYXQgd2FzIGFscmVhZHlcbiAgICAgICAgICAvLyBpbnNlcnRlZC5cbiAgICAgICAgICBsYXN0VGFpbE5vZGUuc2libGluZyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ2NvbGxhcHNlZCc6XG4gICAgICB7XG4gICAgICAgIC8vIEFueSBpbnNlcnRpb25zIGF0IHRoZSBlbmQgb2YgdGhlIHRhaWwgbGlzdCBhZnRlciB0aGlzIHBvaW50XG4gICAgICAgIC8vIHNob3VsZCBiZSBpbnZpc2libGUuIElmIHRoZXJlIGFyZSBhbHJlYWR5IG1vdW50ZWQgYm91bmRhcmllc1xuICAgICAgICAvLyBhbnl0aGluZyBiZWZvcmUgdGhlbSBhcmUgbm90IGNvbnNpZGVyZWQgZm9yIGNvbGxhcHNpbmcuXG4gICAgICAgIC8vIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIGdvIHRocm91Z2ggdGhlIHdob2xlIHRhaWwgdG8gZmluZCBpZlxuICAgICAgICAvLyB0aGVyZSBhcmUgYW55LlxuICAgICAgICB2YXIgX3RhaWxOb2RlID0gcmVuZGVyU3RhdGUudGFpbDtcbiAgICAgICAgdmFyIF9sYXN0VGFpbE5vZGUgPSBudWxsO1xuXG4gICAgICAgIHdoaWxlIChfdGFpbE5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoX3RhaWxOb2RlLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgX2xhc3RUYWlsTm9kZSA9IF90YWlsTm9kZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBfdGFpbE5vZGUgPSBfdGFpbE5vZGUuc2libGluZztcbiAgICAgICAgfSAvLyBOZXh0IHdlJ3JlIHNpbXBseSBnb2luZyB0byBkZWxldGUgYWxsIGluc2VydGlvbnMgYWZ0ZXIgdGhlXG4gICAgICAgIC8vIGxhc3QgcmVuZGVyZWQgaXRlbS5cblxuXG4gICAgICAgIGlmIChfbGFzdFRhaWxOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgLy8gQWxsIHJlbWFpbmluZyBpdGVtcyBpbiB0aGUgdGFpbCBhcmUgaW5zZXJ0aW9ucy5cbiAgICAgICAgICBpZiAoIWhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjayAmJiByZW5kZXJTdGF0ZS50YWlsICE9PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBXZSBzdXNwZW5kZWQgZHVyaW5nIHRoZSBoZWFkLiBXZSB3YW50IHRvIHNob3cgYXQgbGVhc3Qgb25lXG4gICAgICAgICAgICAvLyByb3cgYXQgdGhlIHRhaWwuIFNvIHdlJ2xsIGtlZXAgb24gYW5kIGN1dCBvZmYgdGhlIHJlc3QuXG4gICAgICAgICAgICByZW5kZXJTdGF0ZS50YWlsLnNpYmxpbmcgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZW5kZXJTdGF0ZS50YWlsID0gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRGV0YWNoIHRoZSBpbnNlcnRpb24gYWZ0ZXIgdGhlIGxhc3Qgbm9kZSB0aGF0IHdhcyBhbHJlYWR5XG4gICAgICAgICAgLy8gaW5zZXJ0ZWQuXG4gICAgICAgICAgX2xhc3RUYWlsTm9kZS5zaWJsaW5nID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGJ1YmJsZVByb3BlcnRpZXMoY29tcGxldGVkV29yaykge1xuICB2YXIgZGlkQmFpbG91dCA9IGNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlICE9PSBudWxsICYmIGNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlLmNoaWxkID09PSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuICB2YXIgbmV3Q2hpbGRMYW5lcyA9IE5vTGFuZXM7XG4gIHZhciBzdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzJDE7XG5cbiAgaWYgKCFkaWRCYWlsb3V0KSB7XG4gICAgLy8gQnViYmxlIHVwIHRoZSBlYXJsaWVzdCBleHBpcmF0aW9uIHRpbWUuXG4gICAgaWYgKChjb21wbGV0ZWRXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgLy8gSW4gcHJvZmlsaW5nIG1vZGUsIHJlc2V0Q2hpbGRFeHBpcmF0aW9uVGltZSBpcyBhbHNvIHVzZWQgdG8gcmVzZXRcbiAgICAgIC8vIHByb2ZpbGVyIGR1cmF0aW9ucy5cbiAgICAgIHZhciBhY3R1YWxEdXJhdGlvbiA9IGNvbXBsZXRlZFdvcmsuYWN0dWFsRHVyYXRpb247XG4gICAgICB2YXIgdHJlZUJhc2VEdXJhdGlvbiA9IGNvbXBsZXRlZFdvcmsuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICAgIHZhciBjaGlsZCA9IGNvbXBsZXRlZFdvcmsuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBuZXdDaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhuZXdDaGlsZExhbmVzLCBtZXJnZUxhbmVzKGNoaWxkLmxhbmVzLCBjaGlsZC5jaGlsZExhbmVzKSk7XG4gICAgICAgIHN1YnRyZWVGbGFncyB8PSBjaGlsZC5zdWJ0cmVlRmxhZ3M7XG4gICAgICAgIHN1YnRyZWVGbGFncyB8PSBjaGlsZC5mbGFnczsgLy8gV2hlbiBhIGZpYmVyIGlzIGNsb25lZCwgaXRzIGFjdHVhbER1cmF0aW9uIGlzIHJlc2V0IHRvIDAuIFRoaXMgdmFsdWUgd2lsbFxuICAgICAgICAvLyBvbmx5IGJlIHVwZGF0ZWQgaWYgd29yayBpcyBkb25lIG9uIHRoZSBmaWJlciAoaS5lLiBpdCBkb2Vzbid0IGJhaWxvdXQpLlxuICAgICAgICAvLyBXaGVuIHdvcmsgaXMgZG9uZSwgaXQgc2hvdWxkIGJ1YmJsZSB0byB0aGUgcGFyZW50J3MgYWN0dWFsRHVyYXRpb24uIElmXG4gICAgICAgIC8vIHRoZSBmaWJlciBoYXMgbm90IGJlZW4gY2xvbmVkIHRob3VnaCwgKG1lYW5pbmcgbm8gd29yayB3YXMgZG9uZSksIHRoZW5cbiAgICAgICAgLy8gdGhpcyB2YWx1ZSB3aWxsIHJlZmxlY3QgdGhlIGFtb3VudCBvZiB0aW1lIHNwZW50IHdvcmtpbmcgb24gYSBwcmV2aW91c1xuICAgICAgICAvLyByZW5kZXIuIEluIHRoYXQgY2FzZSBpdCBzaG91bGQgbm90IGJ1YmJsZS4gV2UgZGV0ZXJtaW5lIHdoZXRoZXIgaXQgd2FzXG4gICAgICAgIC8vIGNsb25lZCBieSBjb21wYXJpbmcgdGhlIGNoaWxkIHBvaW50ZXIuXG4gICAgICAgIC8vICRGbG93Rml4TWVbdW5zYWZlLWFkZGl0aW9uXSBhZGRpdGlvbiB3aXRoIHBvc3NpYmxlIG51bGwvdW5kZWZpbmVkIHZhbHVlXG5cbiAgICAgICAgYWN0dWFsRHVyYXRpb24gKz0gY2hpbGQuYWN0dWFsRHVyYXRpb247IC8vICRGbG93Rml4TWVbdW5zYWZlLWFkZGl0aW9uXSBhZGRpdGlvbiB3aXRoIHBvc3NpYmxlIG51bGwvdW5kZWZpbmVkIHZhbHVlXG5cbiAgICAgICAgdHJlZUJhc2VEdXJhdGlvbiArPSBjaGlsZC50cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgICB9XG5cbiAgICAgIGNvbXBsZXRlZFdvcmsuYWN0dWFsRHVyYXRpb24gPSBhY3R1YWxEdXJhdGlvbjtcbiAgICAgIGNvbXBsZXRlZFdvcmsudHJlZUJhc2VEdXJhdGlvbiA9IHRyZWVCYXNlRHVyYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfY2hpbGQgPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoX2NoaWxkICE9PSBudWxsKSB7XG4gICAgICAgIG5ld0NoaWxkTGFuZXMgPSBtZXJnZUxhbmVzKG5ld0NoaWxkTGFuZXMsIG1lcmdlTGFuZXMoX2NoaWxkLmxhbmVzLCBfY2hpbGQuY2hpbGRMYW5lcykpO1xuICAgICAgICBzdWJ0cmVlRmxhZ3MgfD0gX2NoaWxkLnN1YnRyZWVGbGFncztcbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IF9jaGlsZC5mbGFnczsgLy8gVXBkYXRlIHRoZSByZXR1cm4gcG9pbnRlciBzbyB0aGUgdHJlZSBpcyBjb25zaXN0ZW50LiBUaGlzIGlzIGEgY29kZVxuICAgICAgICAvLyBzbWVsbCBiZWNhdXNlIGl0IGFzc3VtZXMgdGhlIGNvbW1pdCBwaGFzZSBpcyBuZXZlciBjb25jdXJyZW50IHdpdGhcbiAgICAgICAgLy8gdGhlIHJlbmRlciBwaGFzZS4gV2lsbCBhZGRyZXNzIGR1cmluZyByZWZhY3RvciB0byBhbHRlcm5hdGUgbW9kZWwuXG5cbiAgICAgICAgX2NoaWxkLnJldHVybiA9IGNvbXBsZXRlZFdvcms7XG4gICAgICAgIF9jaGlsZCA9IF9jaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBsZXRlZFdvcmsuc3VidHJlZUZsYWdzIHw9IHN1YnRyZWVGbGFncztcbiAgfSBlbHNlIHtcbiAgICAvLyBCdWJibGUgdXAgdGhlIGVhcmxpZXN0IGV4cGlyYXRpb24gdGltZS5cbiAgICBpZiAoKGNvbXBsZXRlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAvLyBJbiBwcm9maWxpbmcgbW9kZSwgcmVzZXRDaGlsZEV4cGlyYXRpb25UaW1lIGlzIGFsc28gdXNlZCB0byByZXNldFxuICAgICAgLy8gcHJvZmlsZXIgZHVyYXRpb25zLlxuICAgICAgdmFyIF90cmVlQmFzZUR1cmF0aW9uID0gY29tcGxldGVkV29yay5zZWxmQmFzZUR1cmF0aW9uO1xuICAgICAgdmFyIF9jaGlsZDIgPSBjb21wbGV0ZWRXb3JrLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoX2NoaWxkMiAhPT0gbnVsbCkge1xuICAgICAgICBuZXdDaGlsZExhbmVzID0gbWVyZ2VMYW5lcyhuZXdDaGlsZExhbmVzLCBtZXJnZUxhbmVzKF9jaGlsZDIubGFuZXMsIF9jaGlsZDIuY2hpbGRMYW5lcykpOyAvLyBcIlN0YXRpY1wiIGZsYWdzIHNoYXJlIHRoZSBsaWZldGltZSBvZiB0aGUgZmliZXIvaG9vayB0aGV5IGJlbG9uZyB0byxcbiAgICAgICAgLy8gc28gd2Ugc2hvdWxkIGJ1YmJsZSB0aG9zZSB1cCBldmVuIGR1cmluZyBhIGJhaWxvdXQuIEFsbCB0aGUgb3RoZXJcbiAgICAgICAgLy8gZmxhZ3MgaGF2ZSBhIGxpZmV0aW1lIG9ubHkgb2YgYSBzaW5nbGUgcmVuZGVyICsgY29tbWl0LCBzbyB3ZSBzaG91bGRcbiAgICAgICAgLy8gaWdub3JlIHRoZW0uXG5cbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IF9jaGlsZDIuc3VidHJlZUZsYWdzICYgU3RhdGljTWFzaztcbiAgICAgICAgc3VidHJlZUZsYWdzIHw9IF9jaGlsZDIuZmxhZ3MgJiBTdGF0aWNNYXNrOyAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hZGRpdGlvbl0gYWRkaXRpb24gd2l0aCBwb3NzaWJsZSBudWxsL3VuZGVmaW5lZCB2YWx1ZVxuXG4gICAgICAgIF90cmVlQmFzZUR1cmF0aW9uICs9IF9jaGlsZDIudHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgICAgX2NoaWxkMiA9IF9jaGlsZDIuc2libGluZztcbiAgICAgIH1cblxuICAgICAgY29tcGxldGVkV29yay50cmVlQmFzZUR1cmF0aW9uID0gX3RyZWVCYXNlRHVyYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfY2hpbGQzID0gY29tcGxldGVkV29yay5jaGlsZDtcblxuICAgICAgd2hpbGUgKF9jaGlsZDMgIT09IG51bGwpIHtcbiAgICAgICAgbmV3Q2hpbGRMYW5lcyA9IG1lcmdlTGFuZXMobmV3Q2hpbGRMYW5lcywgbWVyZ2VMYW5lcyhfY2hpbGQzLmxhbmVzLCBfY2hpbGQzLmNoaWxkTGFuZXMpKTsgLy8gXCJTdGF0aWNcIiBmbGFncyBzaGFyZSB0aGUgbGlmZXRpbWUgb2YgdGhlIGZpYmVyL2hvb2sgdGhleSBiZWxvbmcgdG8sXG4gICAgICAgIC8vIHNvIHdlIHNob3VsZCBidWJibGUgdGhvc2UgdXAgZXZlbiBkdXJpbmcgYSBiYWlsb3V0LiBBbGwgdGhlIG90aGVyXG4gICAgICAgIC8vIGZsYWdzIGhhdmUgYSBsaWZldGltZSBvbmx5IG9mIGEgc2luZ2xlIHJlbmRlciArIGNvbW1pdCwgc28gd2Ugc2hvdWxkXG4gICAgICAgIC8vIGlnbm9yZSB0aGVtLlxuXG4gICAgICAgIHN1YnRyZWVGbGFncyB8PSBfY2hpbGQzLnN1YnRyZWVGbGFncyAmIFN0YXRpY01hc2s7XG4gICAgICAgIHN1YnRyZWVGbGFncyB8PSBfY2hpbGQzLmZsYWdzICYgU3RhdGljTWFzazsgLy8gVXBkYXRlIHRoZSByZXR1cm4gcG9pbnRlciBzbyB0aGUgdHJlZSBpcyBjb25zaXN0ZW50LiBUaGlzIGlzIGEgY29kZVxuICAgICAgICAvLyBzbWVsbCBiZWNhdXNlIGl0IGFzc3VtZXMgdGhlIGNvbW1pdCBwaGFzZSBpcyBuZXZlciBjb25jdXJyZW50IHdpdGhcbiAgICAgICAgLy8gdGhlIHJlbmRlciBwaGFzZS4gV2lsbCBhZGRyZXNzIGR1cmluZyByZWZhY3RvciB0byBhbHRlcm5hdGUgbW9kZWwuXG5cbiAgICAgICAgX2NoaWxkMy5yZXR1cm4gPSBjb21wbGV0ZWRXb3JrO1xuICAgICAgICBfY2hpbGQzID0gX2NoaWxkMy5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbXBsZXRlZFdvcmsuc3VidHJlZUZsYWdzIHw9IHN1YnRyZWVGbGFncztcbiAgfVxuXG4gIGNvbXBsZXRlZFdvcmsuY2hpbGRMYW5lcyA9IG5ld0NoaWxkTGFuZXM7XG4gIHJldHVybiBkaWRCYWlsb3V0O1xufVxuXG5mdW5jdGlvbiBjb21wbGV0ZURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBuZXh0U3RhdGUpIHtcbiAgdmFyIHdhc0h5ZHJhdGVkID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuXG4gIGlmIChuZXh0U3RhdGUgIT09IG51bGwgJiYgbmV4dFN0YXRlLmRlaHlkcmF0ZWQgIT09IG51bGwpIHtcbiAgICAvLyBXZSBtaWdodCBiZSBpbnNpZGUgYSBoeWRyYXRpb24gc3RhdGUgdGhlIGZpcnN0IHRpbWUgd2UncmUgcGlja2luZyB1cCB0aGlzXG4gICAgLy8gU3VzcGVuc2UgYm91bmRhcnksIGFuZCBhbHNvIGFmdGVyIHdlJ3ZlIHJlZW50ZXJlZCBpdCBmb3IgZnVydGhlciBoeWRyYXRpb24uXG4gICAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgIGlmICghd2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBIGRlaHlkcmF0ZWQgc3VzcGVuc2UgY29tcG9uZW50IHdhcyBjb21wbGV0ZWQgd2l0aG91dCBhIGh5ZHJhdGVkIG5vZGUuICcgKyAnVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cblxuICAgICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RTdXNwZW5zZUluc3RhbmNlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICB7XG4gICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgdmFyIGlzVGltZWRPdXRTdXNwZW5zZSA9IG5leHRTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgICAgIGlmIChpc1RpbWVkT3V0U3VzcGVuc2UpIHtcbiAgICAgICAgICAgIC8vIERvbid0IGNvdW50IHRpbWUgc3BlbnQgaW4gYSB0aW1lZCBvdXQgU3VzcGVuc2Ugc3VidHJlZSBhcyBwYXJ0IG9mIHRoZSBiYXNlIGR1cmF0aW9uLlxuICAgICAgICAgICAgdmFyIHByaW1hcnlDaGlsZEZyYWdtZW50ID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG5cbiAgICAgICAgICAgIGlmIChwcmltYXJ5Q2hpbGRGcmFnbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hcml0aG1ldGljXSBGbG93IGRvZXNuJ3Qgc3VwcG9ydCB0eXBlIGNhc3RpbmcgaW4gY29tYmluYXRpb24gd2l0aCB0aGUgLT0gb3BlcmF0b3JcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiAtPSBwcmltYXJ5Q2hpbGRGcmFnbWVudC50cmVlQmFzZUR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXRQZW5kaW5nSHlkcmF0aW9uV2FybmluZ3MoKTsgLy8gV2UgbWlnaHQgaGF2ZSByZWVudGVyZWQgdGhpcyBib3VuZGFyeSB0byBoeWRyYXRlIGl0LiBJZiBzbywgd2UgbmVlZCB0byByZXNldCB0aGUgaHlkcmF0aW9uXG4gICAgICAvLyBzdGF0ZSBzaW5jZSB3ZSdyZSBub3cgZXhpdGluZyBvdXQgb2YgaXQuIHBvcEh5ZHJhdGlvblN0YXRlIGRvZXNuJ3QgZG8gdGhhdCBmb3IgdXMuXG5cbiAgICAgIHJlc2V0SHlkcmF0aW9uU3RhdGUoKTtcblxuICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpID09PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgLy8gVGhpcyBib3VuZGFyeSBkaWQgbm90IHN1c3BlbmQgc28gaXQncyBub3cgaHlkcmF0ZWQgYW5kIHVuc3VzcGVuZGVkLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICAgIH0gLy8gSWYgbm90aGluZyBzdXNwZW5kZWQsIHdlIG5lZWQgdG8gc2NoZWR1bGUgYW4gZWZmZWN0IHRvIG1hcmsgdGhpcyBib3VuZGFyeVxuICAgICAgLy8gYXMgaGF2aW5nIGh5ZHJhdGVkIHNvIGV2ZW50cyBrbm93IHRoYXQgdGhleSdyZSBmcmVlIHRvIGJlIGludm9rZWQuXG4gICAgICAvLyBJdCdzIGFsc28gYSBzaWduYWwgdG8gcmVwbGF5IGV2ZW50cyBhbmQgdGhlIHN1c3BlbnNlIGNhbGxiYWNrLlxuICAgICAgLy8gSWYgc29tZXRoaW5nIHN1c3BlbmRlZCwgc2NoZWR1bGUgYW4gZWZmZWN0IHRvIGF0dGFjaCByZXRyeSBsaXN0ZW5lcnMuXG4gICAgICAvLyBTbyB3ZSBtaWdodCBhcyB3ZWxsIGFsd2F5cyBtYXJrIHRoaXMuXG5cblxuICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVXBkYXRlO1xuICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICB2YXIgX2lzVGltZWRPdXRTdXNwZW5zZSA9IG5leHRTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgICAgIGlmIChfaXNUaW1lZE91dFN1c3BlbnNlKSB7XG4gICAgICAgICAgICAvLyBEb24ndCBjb3VudCB0aW1lIHNwZW50IGluIGEgdGltZWQgb3V0IFN1c3BlbnNlIHN1YnRyZWUgYXMgcGFydCBvZiB0aGUgYmFzZSBkdXJhdGlvbi5cbiAgICAgICAgICAgIHZhciBfcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICAgICAgICAgICAgaWYgKF9wcmltYXJ5Q2hpbGRGcmFnbWVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hcml0aG1ldGljXSBGbG93IGRvZXNuJ3Qgc3VwcG9ydCB0eXBlIGNhc3RpbmcgaW4gY29tYmluYXRpb24gd2l0aCB0aGUgLT0gb3BlcmF0b3JcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiAtPSBfcHJpbWFyeUNoaWxkRnJhZ21lbnQudHJlZUJhc2VEdXJhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBTdWNjZXNzZnVsbHkgY29tcGxldGVkIHRoaXMgdHJlZS4gSWYgdGhpcyB3YXMgYSBmb3JjZWQgY2xpZW50IHJlbmRlcixcbiAgICAvLyB0aGVyZSBtYXkgaGF2ZSBiZWVuIHJlY292ZXJhYmxlIGVycm9ycyBkdXJpbmcgZmlyc3QgaHlkcmF0aW9uXG4gICAgLy8gYXR0ZW1wdC4gSWYgc28sIGFkZCB0aGVtIHRvIGEgcXVldWUgc28gd2UgY2FuIGxvZyB0aGVtIGluIHRoZVxuICAgIC8vIGNvbW1pdCBwaGFzZS5cbiAgICB1cGdyYWRlSHlkcmF0aW9uRXJyb3JzVG9SZWNvdmVyYWJsZSgpOyAvLyBGYWxsIHRocm91Z2ggdG8gbm9ybWFsIFN1c3BlbnNlIHBhdGhcblxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBsZXRlV29yayhjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpIHtcbiAgdmFyIG5ld1Byb3BzID0gd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzOyAvLyBOb3RlOiBUaGlzIGludGVudGlvbmFsbHkgZG9lc24ndCBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcgYmVjYXVzZSBjb21wYXJpbmdcbiAgLy8gdG8gdGhlIGN1cnJlbnQgdHJlZSBwcm92aWRlciBmaWJlciBpcyBqdXN0IGFzIGZhc3QgYW5kIGxlc3MgZXJyb3ItcHJvbmUuXG4gIC8vIElkZWFsbHkgd2Ugd291bGQgaGF2ZSBhIHNwZWNpYWwgdmVyc2lvbiBvZiB0aGUgd29yayBsb29wIG9ubHlcbiAgLy8gZm9yIGh5ZHJhdGlvbi5cblxuICBwb3BUcmVlQ29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICBjYXNlIEluY29tcGxldGVGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IC8vIEZhbGx0aHJvdWdoXG5cbiAgICAgIH1cblxuICAgIGNhc2UgTGF6eUNvbXBvbmVudDpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBGcmFnbWVudDpcbiAgICBjYXNlIE1vZGU6XG4gICAgY2FzZSBQcm9maWxlcjpcbiAgICBjYXNlIENvbnRleHRDb25zdW1lcjpcbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgICAge1xuICAgICAgICB2YXIgZmliZXJSb290ID0gd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlO1xuXG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgcHJldmlvdXNDYWNoZSA9IG51bGw7XG5cbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcHJldmlvdXNDYWNoZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgY2FjaGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlLmNhY2hlO1xuXG4gICAgICAgICAgaWYgKGNhY2hlICE9PSBwcmV2aW91c0NhY2hlKSB7XG4gICAgICAgICAgICAvLyBSdW4gcGFzc2l2ZSBlZmZlY3RzIHRvIHJldGFpbi9yZWxlYXNlIHRoZSBjYWNoZS5cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBhc3NpdmUkMTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwb3BDYWNoZVByb3ZpZGVyKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICBwb3BIb3N0Q29udGFpbmVyKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICBpZiAoZmliZXJSb290LnBlbmRpbmdDb250ZXh0KSB7XG4gICAgICAgICAgZmliZXJSb290LmNvbnRleHQgPSBmaWJlclJvb3QucGVuZGluZ0NvbnRleHQ7XG4gICAgICAgICAgZmliZXJSb290LnBlbmRpbmdDb250ZXh0ID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsIHx8IGN1cnJlbnQuY2hpbGQgPT09IG51bGwpIHtcbiAgICAgICAgICAvLyBJZiB3ZSBoeWRyYXRlZCwgcG9wIHNvIHRoYXQgd2UgY2FuIGRlbGV0ZSBhbnkgcmVtYWluaW5nIGNoaWxkcmVuXG4gICAgICAgICAgLy8gdGhhdCB3ZXJlbid0IGh5ZHJhdGVkLlxuICAgICAgICAgIHZhciB3YXNIeWRyYXRlZCA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgIGlmICh3YXNIeWRyYXRlZCkge1xuICAgICAgICAgICAgZW1pdFBlbmRpbmdIeWRyYXRpb25XYXJuaW5ncygpOyAvLyBJZiB3ZSBoeWRyYXRlZCwgdGhlbiB3ZSdsbCBuZWVkIHRvIHNjaGVkdWxlIGFuIHVwZGF0ZSBmb3JcbiAgICAgICAgICAgIC8vIHRoZSBjb21taXQgc2lkZS1lZmZlY3RzIG9uIHRoZSByb290LlxuXG4gICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICAgICAgICBpZiAoIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBjbGllbnQgcm9vdFxuICAgICAgICAgICAgICAhcHJldlN0YXRlLmlzRGVoeWRyYXRlZCB8fCAvLyBDaGVjayBpZiB3ZSByZXZlcnRlZCB0byBjbGllbnQgcmVuZGVyaW5nIChlLmcuIGR1ZSB0byBhbiBlcnJvcilcbiAgICAgICAgICAgICAgKHdvcmtJblByb2dyZXNzLmZsYWdzICYgRm9yY2VDbGllbnRSZW5kZXIpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgICAgICAgICAvLyBTY2hlZHVsZSBhbiBlZmZlY3QgdG8gY2xlYXIgdGhpcyBjb250YWluZXIgYXQgdGhlIHN0YXJ0IG9mIHRoZVxuICAgICAgICAgICAgICAgIC8vIG5leHQgY29tbWl0LiBUaGlzIGhhbmRsZXMgdGhlIGNhc2Ugb2YgUmVhY3QgcmVuZGVyaW5nIGludG8gYVxuICAgICAgICAgICAgICAgIC8vIGNvbnRhaW5lciB3aXRoIHByZXZpb3VzIGNoaWxkcmVuLiBJdCdzIGFsc28gc2FmZSB0byBkbyBmb3JcbiAgICAgICAgICAgICAgICAvLyB1cGRhdGVzIHRvbywgYmVjYXVzZSBjdXJyZW50LmNoaWxkIHdvdWxkIG9ubHkgYmUgbnVsbCBpZiB0aGVcbiAgICAgICAgICAgICAgICAvLyBwcmV2aW91cyByZW5kZXIgd2FzIG51bGwgKHNvIHRoZSBjb250YWluZXIgd291bGQgYWxyZWFkeVxuICAgICAgICAgICAgICAgIC8vIGJlIGVtcHR5KS5cbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBTbmFwc2hvdDsgLy8gSWYgdGhpcyB3YXMgYSBmb3JjZWQgY2xpZW50IHJlbmRlciwgdGhlcmUgbWF5IGhhdmUgYmVlblxuICAgICAgICAgICAgICAgIC8vIHJlY292ZXJhYmxlIGVycm9ycyBkdXJpbmcgZmlyc3QgaHlkcmF0aW9uIGF0dGVtcHQuIElmIHNvLCBhZGRcbiAgICAgICAgICAgICAgICAvLyB0aGVtIHRvIGEgcXVldWUgc28gd2UgY2FuIGxvZyB0aGVtIGluIHRoZSBjb21taXQgcGhhc2UuXG5cbiAgICAgICAgICAgICAgICB1cGdyYWRlSHlkcmF0aW9uRXJyb3JzVG9SZWNvdmVyYWJsZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdXBkYXRlSG9zdENvbnRhaW5lcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0SG9pc3RhYmxlOlxuICAgICAge1xuICAgICAgICBpZiAoc3VwcG9ydHNSZXNvdXJjZXMpIHtcbiAgICAgICAgICAvLyBUaGUgYnJhbmNoaW5nIGhlcmUgaXMgbW9yZSBjb21wbGljYXRlZCB0aGFuIHlvdSBtaWdodCBleHBlY3QgYmVjYXVzZVxuICAgICAgICAgIC8vIGEgSG9zdEhvaXN0YWJsZSBzb21ldGltZXMgY29ycmVzcG9uZHMgdG8gYSBSZXNvdXJjZSBhbmQgc29tZXRpbWVzXG4gICAgICAgICAgLy8gY29ycmVzcG9uZHMgdG8gYW4gSW5zdGFuY2UuIEl0IGNhbiBhbHNvIHN3aXRjaCBkdXJpbmcgYW4gdXBkYXRlLlxuICAgICAgICAgIHZhciB0eXBlID0gd29ya0luUHJvZ3Jlc3MudHlwZTtcbiAgICAgICAgICB2YXIgbmV4dFJlc291cmNlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAvLyBXZSBhcmUgbW91bnRpbmcgYW5kIG11c3QgVXBkYXRlIHRoaXMgSG9pc3RhYmxlIGluIHRoaXMgY29tbWl0XG4gICAgICAgICAgICAvLyBAVE9ETyByZWZhY3RvciB0aGlzIGJsb2NrIHRvIGNyZWF0ZSB0aGUgaW5zdGFuY2UgaGVyZSBpbiBjb21wbGV0ZVxuICAgICAgICAgICAgLy8gcGhhc2UgaWYgd2UgYXJlIG5vdCBoeWRyYXRpbmcuXG4gICAgICAgICAgICBtYXJrVXBkYXRlKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgaWYgKG5leHRSZXNvdXJjZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAvLyBUaGlzIGlzIGEgSG9pc3RhYmxlIFJlc291cmNlXG4gICAgICAgICAgICAgIC8vIFRoaXMgbXVzdCBjb21lIGF0IHRoZSB2ZXJ5IGVuZCBvZiB0aGUgY29tcGxldGUgcGhhc2UuXG4gICAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICBwcmVsb2FkUmVzb3VyY2VBbmRTdXNwZW5kSWZOZWVkZWQod29ya0luUHJvZ3Jlc3MsIG5leHRSZXNvdXJjZSk7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIEhvaXN0YWJsZSBJbnN0YW5jZVxuICAgICAgICAgICAgICAvLyBUaGlzIG11c3QgY29tZSBhdCB0aGUgdmVyeSBlbmQgb2YgdGhlIGNvbXBsZXRlIHBoYXNlLlxuICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgcHJlbG9hZEluc3RhbmNlQW5kU3VzcGVuZElmTmVlZGVkKHdvcmtJblByb2dyZXNzLCB0eXBlLCBuZXdQcm9wcyk7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBXZSBhcmUgdXBkYXRpbmcuXG4gICAgICAgICAgICB2YXIgY3VycmVudFJlc291cmNlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgICAgICBpZiAobmV4dFJlc291cmNlICE9PSBjdXJyZW50UmVzb3VyY2UpIHtcbiAgICAgICAgICAgICAgLy8gV2UgYXJlIHRyYW5zaXRpb25pbmcgdG8sIGZyb20sIG9yIGJldHdlZW4gSG9pc3RhYmxlIFJlc291cmNlc1xuICAgICAgICAgICAgICAvLyBhbmQgcmVxdWlyZSBhbiB1cGRhdGVcbiAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChuZXh0UmVzb3VyY2UgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgLy8gVGhpcyBpcyBhIEhvaXN0YWJsZSBSZXNvdXJjZVxuICAgICAgICAgICAgICAvLyBUaGlzIG11c3QgY29tZSBhdCB0aGUgdmVyeSBlbmQgb2YgdGhlIGNvbXBsZXRlIHBoYXNlLlxuICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgICAgICBpZiAobmV4dFJlc291cmNlID09PSBjdXJyZW50UmVzb3VyY2UpIHtcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyAmPSB+TWF5U3VzcGVuZENvbW1pdDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmVsb2FkUmVzb3VyY2VBbmRTdXNwZW5kSWZOZWVkZWQod29ya0luUHJvZ3Jlc3MsIG5leHRSZXNvdXJjZSk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgYSBIb2lzdGFibGUgSW5zdGFuY2VcbiAgICAgICAgICAgICAgLy8gV2UgbWF5IGhhdmUgcHJvcHMgdG8gdXBkYXRlIG9uIHRoZSBIb2lzdGFibGUgaW5zdGFuY2UuXG4gICAgICAgICAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9sZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuXG4gICAgICAgICAgICAgICAgaWYgKG9sZFByb3BzICE9PSBuZXdQcm9wcykge1xuICAgICAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIHVzZSB0aGUgdXBkYXRlSG9zdENvbXBvbmVudCBwYXRoIGJlY3Vhc2UgaXQgcHJvZHVjZXNcbiAgICAgICAgICAgICAgICAvLyB0aGUgdXBkYXRlIHF1ZXVlIHdlIG5lZWQgZm9yIEhvaXN0YWJsZXMuXG4gICAgICAgICAgICAgICAgdXBkYXRlSG9zdENvbXBvbmVudChjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcywgdHlwZSwgbmV3UHJvcHMpO1xuICAgICAgICAgICAgICB9IC8vIFRoaXMgbXVzdCBjb21lIGF0IHRoZSB2ZXJ5IGVuZCBvZiB0aGUgY29tcGxldGUgcGhhc2UuXG5cblxuICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgcHJlbG9hZEluc3RhbmNlQW5kU3VzcGVuZElmTmVlZGVkKHdvcmtJblByb2dyZXNzLCB0eXBlLCBuZXdQcm9wcyk7XG4gICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBGYWxsIHRocm91Z2hcblxuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgICAge1xuICAgICAgICBpZiAoc3VwcG9ydHNTaW5nbGV0b25zKSB7XG4gICAgICAgICAgcG9wSG9zdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHZhciByb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuICAgICAgICAgIHZhciBfdHlwZSA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICAgICAgdmFyIF9vbGRQcm9wczIgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG5cbiAgICAgICAgICAgICAgaWYgKF9vbGRQcm9wczIgIT09IG5ld1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHVwZGF0ZUhvc3RDb21wb25lbnQoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIF90eXBlLCBuZXdQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICghbmV3UHJvcHMpIHtcbiAgICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgJyArICdjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgICAgICB9IC8vIFRoaXMgY2FuIGhhcHBlbiB3aGVuIHdlIGFib3J0IHdvcmsuXG5cblxuICAgICAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpO1xuXG4gICAgICAgICAgICB2YXIgX3dhc0h5ZHJhdGVkID0gcG9wSHlkcmF0aW9uU3RhdGUod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgICAgICB2YXIgaW5zdGFuY2U7XG5cbiAgICAgICAgICAgIGlmIChfd2FzSHlkcmF0ZWQpIHtcbiAgICAgICAgICAgICAgLy8gV2UgaWdub3JlIHRoZSBib29sZWFuIGluZGljYXRpbmcgdGhlcmUgaXMgYW4gdXBkYXRlUXVldWUgYmVjYXVzZVxuICAgICAgICAgICAgICAvLyBpdCBpcyB1c2VkIG9ubHkgdG8gc2V0IHRleHQgY2hpbGRyZW4gYW5kIEhvc3RTaW5nbGV0b25zIGRvIG5vdFxuICAgICAgICAgICAgICAvLyB1c2UgdGhlbS5cbiAgICAgICAgICAgICAgcHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcywgY3VycmVudEhvc3RDb250ZXh0KTtcbiAgICAgICAgICAgICAgaW5zdGFuY2UgPSB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpbnN0YW5jZSA9IHJlc29sdmVTaW5nbGV0b25JbnN0YW5jZShfdHlwZSwgbmV3UHJvcHMsIHJvb3RDb250YWluZXJJbnN0YW5jZSwgY3VycmVudEhvc3RDb250ZXh0LCB0cnVlKTtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gaW5zdGFuY2U7XG4gICAgICAgICAgICAgIG1hcmtVcGRhdGUod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9IC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgdmFyIF90eXBlMiA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG5cbiAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlICE9IG51bGwpIHtcbiAgICAgICAgICB1cGRhdGVIb3N0Q29tcG9uZW50KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBfdHlwZTIsIG5ld1Byb3BzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoIW5ld1Byb3BzKSB7XG4gICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgJyArICdjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgICAgfSAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuXG5cbiAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9jdXJyZW50SG9zdENvbnRleHQgPSBnZXRIb3N0Q29udGV4dCgpOyAvLyBUT0RPOiBNb3ZlIGNyZWF0ZUluc3RhbmNlIHRvIGJlZ2luV29yayBhbmQga2VlcCBpdCBvbiBhIGNvbnRleHRcbiAgICAgICAgICAvLyBcInN0YWNrXCIgYXMgdGhlIHBhcmVudC4gVGhlbiBhcHBlbmQgY2hpbGRyZW4gYXMgd2UgZ28gaW4gYmVnaW5Xb3JrXG4gICAgICAgICAgLy8gb3IgY29tcGxldGVXb3JrIGRlcGVuZGluZyBvbiB3aGV0aGVyIHdlIHdhbnQgdG8gYWRkIHRoZW0gdG9wLT5kb3duIG9yXG4gICAgICAgICAgLy8gYm90dG9tLT51cC4gVG9wLT5kb3duIGlzIGZhc3RlciBpbiBJRTExLlxuXG5cbiAgICAgICAgICB2YXIgX3dhc0h5ZHJhdGVkMiA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgIGlmIChfd2FzSHlkcmF0ZWQyKSB7XG4gICAgICAgICAgICAvLyBUT0RPOiBNb3ZlIHRoaXMgYW5kIGNyZWF0ZUluc3RhbmNlIHN0ZXAgaW50byB0aGUgYmVnaW5QaGFzZVxuICAgICAgICAgICAgLy8gdG8gY29uc29saWRhdGUuXG4gICAgICAgICAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdEluc3RhbmNlKHdvcmtJblByb2dyZXNzLCBfY3VycmVudEhvc3RDb250ZXh0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIF9yb290Q29udGFpbmVySW5zdGFuY2UgPSBnZXRSb290SG9zdENvbnRhaW5lcigpO1xuXG4gICAgICAgICAgICB2YXIgX2luc3RhbmNlMyA9IGNyZWF0ZUluc3RhbmNlKF90eXBlMiwgbmV3UHJvcHMsIF9yb290Q29udGFpbmVySW5zdGFuY2UsIF9jdXJyZW50SG9zdENvbnRleHQsIHdvcmtJblByb2dyZXNzKTsgLy8gVE9ETzogRm9yIHBlcnNpc3RlbnQgcmVuZGVyZXJzLCB3ZSBzaG91bGQgcGFzcyBjaGlsZHJlbiBhcyBwYXJ0XG4gICAgICAgICAgICAvLyBvZiB0aGUgaW5pdGlhbCBpbnN0YW5jZSBjcmVhdGlvblxuXG5cbiAgICAgICAgICAgIGFwcGVuZEFsbENoaWxkcmVuKF9pbnN0YW5jZTMsIHdvcmtJblByb2dyZXNzLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gX2luc3RhbmNlMzsgLy8gQ2VydGFpbiByZW5kZXJlcnMgcmVxdWlyZSBjb21taXQtdGltZSBlZmZlY3RzIGZvciBpbml0aWFsIG1vdW50LlxuICAgICAgICAgICAgLy8gKGVnIERPTSByZW5kZXJlciBzdXBwb3J0cyBhdXRvLWZvY3VzIGZvciBjZXJ0YWluIGVsZW1lbnRzKS5cbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBzdWNoIHJlbmRlcmVycyBnZXQgc2NoZWR1bGVkIGZvciBsYXRlciB3b3JrLlxuXG4gICAgICAgICAgICBpZiAoZmluYWxpemVJbml0aWFsQ2hpbGRyZW4oX2luc3RhbmNlMywgX3R5cGUyLCBuZXdQcm9wcywgX2N1cnJlbnRIb3N0Q29udGV4dCkpIHtcbiAgICAgICAgICAgICAgbWFya1VwZGF0ZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7IC8vIFRoaXMgbXVzdCBjb21lIGF0IHRoZSB2ZXJ5IGVuZCBvZiB0aGUgY29tcGxldGUgcGhhc2UsIGJlY2F1c2UgaXQgbWlnaHRcbiAgICAgICAgLy8gdGhyb3cgdG8gc3VzcGVuZCwgYW5kIGlmIHRoZSByZXNvdXJjZSBpbW1lZGlhdGVseSBsb2FkcywgdGhlIHdvcmsgbG9vcFxuICAgICAgICAvLyB3aWxsIHJlc3VtZSByZW5kZXJpbmcgYXMgaWYgdGhlIHdvcmstaW4tcHJvZ3Jlc3MgY29tcGxldGVkLiBTbyBpdCBtdXN0XG4gICAgICAgIC8vIGZ1bGx5IGNvbXBsZXRlLlxuXG4gICAgICAgIHByZWxvYWRJbnN0YW5jZUFuZFN1c3BlbmRJZk5lZWRlZCh3b3JrSW5Qcm9ncmVzcywgd29ya0luUHJvZ3Jlc3MudHlwZSwgd29ya0luUHJvZ3Jlc3MucGVuZGluZ1Byb3BzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICB2YXIgbmV3VGV4dCA9IG5ld1Byb3BzO1xuXG4gICAgICAgIGlmIChjdXJyZW50ICYmIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSAhPSBudWxsKSB7XG4gICAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7IC8vIElmIHdlIGhhdmUgYW4gYWx0ZXJuYXRlLCB0aGF0IG1lYW5zIHRoaXMgaXMgYW4gdXBkYXRlIGFuZCB3ZSBuZWVkXG4gICAgICAgICAgLy8gdG8gc2NoZWR1bGUgYSBzaWRlLWVmZmVjdCB0byBkbyB0aGUgdXBkYXRlcy5cblxuICAgICAgICAgIHVwZGF0ZUhvc3RUZXh0KGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCBvbGRUZXh0LCBuZXdUZXh0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5ld1RleHQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBpZiAod29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2UgbXVzdCBoYXZlIG5ldyBwcm9wcyBmb3IgbmV3IG1vdW50cy4gVGhpcyBlcnJvciBpcyBsaWtlbHkgJyArICdjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICAgICAgfSAvLyBUaGlzIGNhbiBoYXBwZW4gd2hlbiB3ZSBhYm9ydCB3b3JrLlxuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIF9yb290Q29udGFpbmVySW5zdGFuY2UyID0gZ2V0Um9vdEhvc3RDb250YWluZXIoKTtcblxuICAgICAgICAgIHZhciBfY3VycmVudEhvc3RDb250ZXh0MiA9IGdldEhvc3RDb250ZXh0KCk7XG5cbiAgICAgICAgICB2YXIgX3dhc0h5ZHJhdGVkMyA9IHBvcEh5ZHJhdGlvblN0YXRlKHdvcmtJblByb2dyZXNzKTtcblxuICAgICAgICAgIGlmIChfd2FzSHlkcmF0ZWQzKSB7XG4gICAgICAgICAgICBwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnN0YXRlTm9kZSA9IGNyZWF0ZVRleHRJbnN0YW5jZShuZXdUZXh0LCBfcm9vdENvbnRhaW5lckluc3RhbmNlMiwgX2N1cnJlbnRIb3N0Q29udGV4dDIsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgbmV4dFN0YXRlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTsgLy8gU3BlY2lhbCBwYXRoIGZvciBkZWh5ZHJhdGVkIGJvdW5kYXJpZXMuIFdlIG1heSBldmVudHVhbGx5IG1vdmUgdGhpc1xuICAgICAgICAvLyB0byBpdHMgb3duIGZpYmVyIHR5cGUgc28gdGhhdCB3ZSBjYW4gYWRkIG90aGVyIGtpbmRzIG9mIGh5ZHJhdGlvblxuICAgICAgICAvLyBib3VuZGFyaWVzIHRoYXQgYXJlbid0IGFzc29jaWF0ZWQgd2l0aCBhIFN1c3BlbnNlIHRyZWUuIEluIGFudGljaXBhdGlvblxuICAgICAgICAvLyBvZiBzdWNoIGEgcmVmYWN0b3IsIGFsbCB0aGUgaHlkcmF0aW9uIGxvZ2ljIGlzIGNvbnRhaW5lZCBpblxuICAgICAgICAvLyB0aGlzIGJyYW5jaC5cblxuICAgICAgICBpZiAoY3VycmVudCA9PT0gbnVsbCB8fCBjdXJyZW50Lm1lbW9pemVkU3RhdGUgIT09IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlLmRlaHlkcmF0ZWQgIT09IG51bGwpIHtcbiAgICAgICAgICB2YXIgZmFsbHRocm91Z2hUb05vcm1hbFN1c3BlbnNlUGF0aCA9IGNvbXBsZXRlRGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkoY3VycmVudCwgd29ya0luUHJvZ3Jlc3MsIG5leHRTdGF0ZSk7XG5cbiAgICAgICAgICBpZiAoIWZhbGx0aHJvdWdoVG9Ob3JtYWxTdXNwZW5zZVBhdGgpIHtcbiAgICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIEZvcmNlQ2xpZW50UmVuZGVyKSB7XG4gICAgICAgICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7IC8vIFNwZWNpYWwgY2FzZS4gVGhlcmUgd2VyZSByZW1haW5pbmcgdW5oeWRyYXRlZCBub2Rlcy4gV2UgdHJlYXRcbiAgICAgICAgICAgICAgLy8gdGhpcyBhcyBhIG1pc21hdGNoLiBSZXZlcnQgdG8gY2xpZW50IHJlbmRlcmluZy5cblxuICAgICAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpOyAvLyBEaWQgbm90IGZpbmlzaCBoeWRyYXRpbmcsIGVpdGhlciBiZWNhdXNlIHRoaXMgaXMgdGhlIGluaXRpYWxcbiAgICAgICAgICAgICAgLy8gcmVuZGVyIG9yIGJlY2F1c2Ugc29tZXRoaW5nIHN1c3BlbmRlZC5cblxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IC8vIENvbnRpbnVlIHdpdGggdGhlIG5vcm1hbCBTdXNwZW5zZSBwYXRoLlxuXG4gICAgICAgIH1cblxuICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHN1c3BlbmRlZC4gUmUtcmVuZGVyIHdpdGggdGhlIGZhbGxiYWNrIGNoaWxkcmVuLlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gcmVuZGVyTGFuZXM7IC8vIERvIG5vdCByZXNldCB0aGUgZWZmZWN0IGxpc3QuXG5cbiAgICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICAgICAgdHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfSAvLyBEb24ndCBidWJibGUgcHJvcGVydGllcyBpbiB0aGlzIGNhc2UuXG5cblxuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXh0RGlkVGltZW91dCA9IG5leHRTdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgdmFyIHByZXZEaWRUaW1lb3V0ID0gY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50Lm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgaWYgKG5leHREaWRUaW1lb3V0KSB7XG4gICAgICAgICAgdmFyIG9mZnNjcmVlbkZpYmVyID0gd29ya0luUHJvZ3Jlc3MuY2hpbGQ7XG4gICAgICAgICAgdmFyIF9wcmV2aW91c0NhY2hlID0gbnVsbDtcblxuICAgICAgICAgIGlmIChvZmZzY3JlZW5GaWJlci5hbHRlcm5hdGUgIT09IG51bGwgJiYgb2Zmc2NyZWVuRmliZXIuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUgIT09IG51bGwgJiYgb2Zmc2NyZWVuRmliZXIuYWx0ZXJuYXRlLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICE9PSBudWxsKSB7XG4gICAgICAgICAgICBfcHJldmlvdXNDYWNoZSA9IG9mZnNjcmVlbkZpYmVyLmFsdGVybmF0ZS5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfY2FjaGUgPSBudWxsO1xuXG4gICAgICAgICAgaWYgKG9mZnNjcmVlbkZpYmVyLm1lbW9pemVkU3RhdGUgIT09IG51bGwgJiYgb2Zmc2NyZWVuRmliZXIubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgIT09IG51bGwpIHtcbiAgICAgICAgICAgIF9jYWNoZSA9IG9mZnNjcmVlbkZpYmVyLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2w7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKF9jYWNoZSAhPT0gX3ByZXZpb3VzQ2FjaGUpIHtcbiAgICAgICAgICAgIC8vIFJ1biBwYXNzaXZlIGVmZmVjdHMgdG8gcmV0YWluL3JlbGVhc2UgdGhlIGNhY2hlLlxuICAgICAgICAgICAgb2Zmc2NyZWVuRmliZXIuZmxhZ3MgfD0gUGFzc2l2ZSQxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBJZiB0aGUgc3VzcGVuZGVkIHN0YXRlIG9mIHRoZSBib3VuZGFyeSBjaGFuZ2VzLCB3ZSBuZWVkIHRvIHNjaGVkdWxlXG4gICAgICAgIC8vIGEgcGFzc2l2ZSBlZmZlY3QsIHdoaWNoIGlzIHdoZW4gd2UgcHJvY2VzcyB0aGUgdHJhbnNpdGlvbnNcblxuXG4gICAgICAgIGlmIChuZXh0RGlkVGltZW91dCAhPT0gcHJldkRpZFRpbWVvdXQpIHtcbiAgICAgICAgICAvLyBhbiBlZmZlY3QgdG8gdG9nZ2xlIHRoZSBzdWJ0cmVlJ3MgdmlzaWJpbGl0eS4gV2hlbiB3ZSBzd2l0Y2ggZnJvbVxuICAgICAgICAgIC8vIGZhbGxiYWNrIC0+IHByaW1hcnksIHRoZSBpbm5lciBPZmZzY3JlZW4gZmliZXIgc2NoZWR1bGVzIHRoaXMgZWZmZWN0XG4gICAgICAgICAgLy8gYXMgcGFydCBvZiBpdHMgbm9ybWFsIGNvbXBsZXRlIHBoYXNlLiBCdXQgd2hlbiB3ZSBzd2l0Y2ggZnJvbVxuICAgICAgICAgIC8vIHByaW1hcnkgLT4gZmFsbGJhY2ssIHRoZSBpbm5lciBPZmZzY3JlZW4gZmliZXIgZG9lcyBub3QgaGF2ZSBhIGNvbXBsZXRlXG4gICAgICAgICAgLy8gcGhhc2UuIFNvIHdlIG5lZWQgdG8gc2NoZWR1bGUgaXRzIGVmZmVjdCBoZXJlLlxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gV2UgYWxzbyB1c2UgdGhpcyBmbGFnIHRvIGNvbm5lY3QvZGlzY29ubmVjdCB0aGUgZWZmZWN0cywgYnV0IHRoZSBzYW1lXG4gICAgICAgICAgLy8gbG9naWMgYXBwbGllczogd2hlbiByZS1jb25uZWN0aW5nLCB0aGUgT2Zmc2NyZWVuIGZpYmVyJ3MgY29tcGxldGVcbiAgICAgICAgICAvLyBwaGFzZSB3aWxsIGhhbmRsZSBzY2hlZHVsaW5nIHRoZSBlZmZlY3QuIEl0J3Mgb25seSB3aGVuIHRoZSBmYWxsYmFja1xuICAgICAgICAgIC8vIGlzIGFjdGl2ZSB0aGF0IHdlIGhhdmUgdG8gZG8gYW55dGhpbmcgc3BlY2lhbC5cblxuXG4gICAgICAgICAgaWYgKG5leHREaWRUaW1lb3V0KSB7XG4gICAgICAgICAgICB2YXIgX29mZnNjcmVlbkZpYmVyMiA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgICAgX29mZnNjcmVlbkZpYmVyMi5mbGFncyB8PSBWaXNpYmlsaXR5O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZXRyeVF1ZXVlID0gd29ya0luUHJvZ3Jlc3MudXBkYXRlUXVldWU7XG4gICAgICAgIHNjaGVkdWxlUmV0cnlFZmZlY3Qod29ya0luUHJvZ3Jlc3MsIHJldHJ5UXVldWUpO1xuXG4gICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICAgICAgaWYgKG5leHREaWRUaW1lb3V0KSB7XG4gICAgICAgICAgICAgIC8vIERvbid0IGNvdW50IHRpbWUgc3BlbnQgaW4gYSB0aW1lZCBvdXQgU3VzcGVuc2Ugc3VidHJlZSBhcyBwYXJ0IG9mIHRoZSBiYXNlIGR1cmF0aW9uLlxuICAgICAgICAgICAgICB2YXIgcHJpbWFyeUNoaWxkRnJhZ21lbnQgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcblxuICAgICAgICAgICAgICBpZiAocHJpbWFyeUNoaWxkRnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hcml0aG1ldGljXSBGbG93IGRvZXNuJ3Qgc3VwcG9ydCB0eXBlIGNhc3RpbmcgaW4gY29tYmluYXRpb24gd2l0aCB0aGUgLT0gb3BlcmF0b3JcbiAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uIC09IHByaW1hcnlDaGlsZEZyYWdtZW50LnRyZWVCYXNlRHVyYXRpb247XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgdXBkYXRlSG9zdENvbnRhaW5lcihjdXJyZW50LCB3b3JrSW5Qcm9ncmVzcyk7XG5cbiAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIHByZXBhcmVQb3J0YWxNb3VudCh3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgICB9XG5cbiAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIENvbnRleHRQcm92aWRlcjpcbiAgICAgIC8vIFBvcCBwcm92aWRlciBmaWJlclxuICAgICAgdmFyIGNvbnRleHQ7XG5cbiAgICAgIHtcbiAgICAgICAgY29udGV4dCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICB9XG5cbiAgICAgIHBvcFByb3ZpZGVyKGNvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgcmV0dXJuIG51bGw7XG5cbiAgICBjYXNlIEluY29tcGxldGVDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IC8vIFNhbWUgYXMgY2xhc3MgY29tcG9uZW50IGNhc2UuIEkgcHV0IGl0IGRvd24gaGVyZSBzbyB0aGF0IHRoZSB0YWdzIGFyZVxuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcFN1c3BlbnNlTGlzdENvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB2YXIgcmVuZGVyU3RhdGUgPSB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgIGlmIChyZW5kZXJTdGF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlJ3JlIHJ1bm5pbmcgaW4gdGhlIGRlZmF1bHQsIFwiaW5kZXBlbmRlbnRcIiBtb2RlLlxuICAgICAgICAgIC8vIFdlIGRvbid0IGRvIGFueXRoaW5nIGluIHRoaXMgbW9kZS5cbiAgICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaWRTdXNwZW5kQWxyZWFkeSA9ICh3b3JrSW5Qcm9ncmVzcy5mbGFncyAmIERpZENhcHR1cmUpICE9PSBOb0ZsYWdzJDE7XG4gICAgICAgIHZhciByZW5kZXJlZFRhaWwgPSByZW5kZXJTdGF0ZS5yZW5kZXJpbmc7XG5cbiAgICAgICAgaWYgKHJlbmRlcmVkVGFpbCA9PT0gbnVsbCkge1xuICAgICAgICAgIC8vIFdlIGp1c3QgcmVuZGVyZWQgdGhlIGhlYWQuXG4gICAgICAgICAgaWYgKCFkaWRTdXNwZW5kQWxyZWFkeSkge1xuICAgICAgICAgICAgLy8gVGhpcyBpcyB0aGUgZmlyc3QgcGFzcy4gV2UgbmVlZCB0byBmaWd1cmUgb3V0IGlmIGFueXRoaW5nIGlzIHN0aWxsXG4gICAgICAgICAgICAvLyBzdXNwZW5kZWQgaW4gdGhlIHJlbmRlcmVkIHNldC5cbiAgICAgICAgICAgIC8vIElmIG5ldyBjb250ZW50IHVuc3VzcGVuZGVkLCBidXQgdGhlcmUncyBzdGlsbCBzb21lIGNvbnRlbnQgdGhhdFxuICAgICAgICAgICAgLy8gZGlkbid0LiBUaGVuIHdlIG5lZWQgdG8gZG8gYSBzZWNvbmQgcGFzcyB0aGF0IGZvcmNlcyBldmVyeXRoaW5nXG4gICAgICAgICAgICAvLyB0byBrZWVwIHNob3dpbmcgdGhlaXIgZmFsbGJhY2tzLlxuICAgICAgICAgICAgLy8gV2UgbWlnaHQgYmUgc3VzcGVuZGVkIGlmIHNvbWV0aGluZyBpbiB0aGlzIHJlbmRlciBwYXNzIHN1c3BlbmRlZCwgb3JcbiAgICAgICAgICAgIC8vIHNvbWV0aGluZyBpbiB0aGUgcHJldmlvdXMgY29tbWl0dGVkIHBhc3Mgc3VzcGVuZGVkLiBPdGhlcndpc2UsXG4gICAgICAgICAgICAvLyB0aGVyZSdzIG5vIGNoYW5jZSBzbyB3ZSBjYW4gc2tpcCB0aGUgZXhwZW5zaXZlIGNhbGwgdG9cbiAgICAgICAgICAgIC8vIGZpbmRGaXJzdFN1c3BlbmRlZC5cbiAgICAgICAgICAgIHZhciBjYW5ub3RCZVN1c3BlbmRlZCA9IHJlbmRlckhhc05vdFN1c3BlbmRlZFlldCgpICYmIChjdXJyZW50ID09PSBudWxsIHx8IChjdXJyZW50LmZsYWdzICYgRGlkQ2FwdHVyZSkgPT09IE5vRmxhZ3MkMSk7XG5cbiAgICAgICAgICAgIGlmICghY2Fubm90QmVTdXNwZW5kZWQpIHtcbiAgICAgICAgICAgICAgdmFyIHJvdyA9IHdvcmtJblByb2dyZXNzLmNoaWxkO1xuXG4gICAgICAgICAgICAgIHdoaWxlIChyb3cgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3VzcGVuZGVkID0gZmluZEZpcnN0U3VzcGVuZGVkKHJvdyk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3VzcGVuZGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICBkaWRTdXNwZW5kQWxyZWFkeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICAgICAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBmYWxzZSk7IC8vIElmIHRoaXMgaXMgYSBuZXdseSBzdXNwZW5kZWQgdHJlZSwgaXQgbWlnaHQgbm90IGdldCBjb21taXR0ZWQgYXNcbiAgICAgICAgICAgICAgICAgIC8vIHBhcnQgb2YgdGhlIHNlY29uZCBwYXNzLiBJbiB0aGF0IGNhc2Ugbm90aGluZyB3aWxsIHN1YnNjcmliZSB0b1xuICAgICAgICAgICAgICAgICAgLy8gaXRzIHRoZW5hYmxlcy4gSW5zdGVhZCwgd2UnbGwgdHJhbnNmZXIgaXRzIHRoZW5hYmxlcyB0byB0aGVcbiAgICAgICAgICAgICAgICAgIC8vIFN1c3BlbnNlTGlzdCBzbyB0aGF0IGl0IGNhbiByZXRyeSBpZiB0aGV5IHJlc29sdmUuXG4gICAgICAgICAgICAgICAgICAvLyBUaGVyZSBtaWdodCBiZSBtdWx0aXBsZSBvZiB0aGVzZSBpbiB0aGUgbGlzdCBidXQgc2luY2Ugd2UncmVcbiAgICAgICAgICAgICAgICAgIC8vIGdvaW5nIHRvIHdhaXQgZm9yIGFsbCBvZiB0aGVtIGFueXdheSwgaXQgZG9lc24ndCByZWFsbHkgbWF0dGVyXG4gICAgICAgICAgICAgICAgICAvLyB3aGljaCBvbmVzIGdldHMgdG8gcGluZy4gSW4gdGhlb3J5IHdlIGNvdWxkIGdldCBjbGV2ZXIgYW5kIGtlZXBcbiAgICAgICAgICAgICAgICAgIC8vIHRyYWNrIG9mIGhvdyBtYW55IGRlcGVuZGVuY2llcyByZW1haW4gYnV0IGl0IGdldHMgdHJpY2t5IGJlY2F1c2VcbiAgICAgICAgICAgICAgICAgIC8vIGluIHRoZSBtZWFudGltZSwgd2UgY2FuIGFkZC9yZW1vdmUvY2hhbmdlIGl0ZW1zIGFuZCBkZXBlbmRlbmNpZXMuXG4gICAgICAgICAgICAgICAgICAvLyBXZSBtaWdodCBiYWlsIG91dCBvZiB0aGUgbG9vcCBiZWZvcmUgZmluZGluZyBhbnkgYnV0IHRoYXRcbiAgICAgICAgICAgICAgICAgIC8vIGRvZXNuJ3QgbWF0dGVyIHNpbmNlIHRoYXQgbWVhbnMgdGhhdCB0aGUgb3RoZXIgYm91bmRhcmllcyB0aGF0XG4gICAgICAgICAgICAgICAgICAvLyB3ZSBkaWQgZmluZCBhbHJlYWR5IGhhcyB0aGVpciBsaXN0ZW5lcnMgYXR0YWNoZWQuXG5cbiAgICAgICAgICAgICAgICAgIHZhciBfcmV0cnlRdWV1ZSA9IHN1c3BlbmRlZC51cGRhdGVRdWV1ZTtcbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlID0gX3JldHJ5UXVldWU7XG4gICAgICAgICAgICAgICAgICBzY2hlZHVsZVJldHJ5RWZmZWN0KHdvcmtJblByb2dyZXNzLCBfcmV0cnlRdWV1ZSk7IC8vIFJlcmVuZGVyIHRoZSB3aG9sZSBsaXN0LCBidXQgdGhpcyB0aW1lLCB3ZSdsbCBmb3JjZSBmYWxsYmFja3NcbiAgICAgICAgICAgICAgICAgIC8vIHRvIHN0YXkgaW4gcGxhY2UuXG4gICAgICAgICAgICAgICAgICAvLyBSZXNldCB0aGUgZWZmZWN0IGZsYWdzIGJlZm9yZSBkb2luZyB0aGUgc2Vjb25kIHBhc3Mgc2luY2UgdGhhdCdzIG5vdyBpbnZhbGlkLlxuICAgICAgICAgICAgICAgICAgLy8gUmVzZXQgdGhlIGNoaWxkIGZpYmVycyB0byB0aGVpciBvcmlnaW5hbCBzdGF0ZS5cblxuICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3Muc3VidHJlZUZsYWdzID0gTm9GbGFncyQxO1xuICAgICAgICAgICAgICAgICAgcmVzZXRDaGlsZEZpYmVycyh3b3JrSW5Qcm9ncmVzcywgcmVuZGVyTGFuZXMpOyAvLyBTZXQgdXAgdGhlIFN1c3BlbnNlIExpc3QgQ29udGV4dCB0byBmb3JjZSBzdXNwZW5zZSBhbmRcbiAgICAgICAgICAgICAgICAgIC8vIGltbWVkaWF0ZWx5IHJlcmVuZGVyIHRoZSBjaGlsZHJlbi5cblxuICAgICAgICAgICAgICAgICAgcHVzaFN1c3BlbnNlTGlzdENvbnRleHQod29ya0luUHJvZ3Jlc3MsIHNldFNoYWxsb3dTdXNwZW5zZUxpc3RDb250ZXh0KHN1c3BlbnNlU3RhY2tDdXJzb3IuY3VycmVudCwgRm9yY2VTdXNwZW5zZUZhbGxiYWNrKSk7IC8vIERvbid0IGJ1YmJsZSBwcm9wZXJ0aWVzIGluIHRoaXMgY2FzZS5cblxuICAgICAgICAgICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzLmNoaWxkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJvdyA9IHJvdy5zaWJsaW5nO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZW5kZXJTdGF0ZS50YWlsICE9PSBudWxsICYmIG5vdyQxKCkgPiBnZXRSZW5kZXJUYXJnZXRUaW1lKCkpIHtcbiAgICAgICAgICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IHBhc3NlZCBvdXIgQ1BVIGRlYWRsaW5lIGJ1dCB3ZSBzdGlsbCBoYXZlIHJvd3NcbiAgICAgICAgICAgICAgLy8gbGVmdCBpbiB0aGUgdGFpbC4gV2UnbGwganVzdCBnaXZlIHVwIGZ1cnRoZXIgYXR0ZW1wdHMgdG8gcmVuZGVyXG4gICAgICAgICAgICAgIC8vIHRoZSBtYWluIGNvbnRlbnQgYW5kIG9ubHkgcmVuZGVyIGZhbGxiYWNrcy5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRGlkQ2FwdHVyZTtcbiAgICAgICAgICAgICAgZGlkU3VzcGVuZEFscmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgICBjdXRPZmZUYWlsSWZOZWVkZWQocmVuZGVyU3RhdGUsIGZhbHNlKTsgLy8gU2luY2Ugbm90aGluZyBhY3R1YWxseSBzdXNwZW5kZWQsIHRoZXJlIHdpbGwgbm90aGluZyB0byBwaW5nIHRoaXNcbiAgICAgICAgICAgICAgLy8gdG8gZ2V0IGl0IHN0YXJ0ZWQgYmFjayB1cCB0byBhdHRlbXB0IHRoZSBuZXh0IGl0ZW0uIFdoaWxlIGluIHRlcm1zXG4gICAgICAgICAgICAgIC8vIG9mIHByaW9yaXR5IHRoaXMgd29yayBoYXMgdGhlIHNhbWUgcHJpb3JpdHkgYXMgdGhpcyBjdXJyZW50IHJlbmRlcixcbiAgICAgICAgICAgICAgLy8gaXQncyBub3QgcGFydCBvZiB0aGUgc2FtZSB0cmFuc2l0aW9uIG9uY2UgdGhlIHRyYW5zaXRpb24gaGFzXG4gICAgICAgICAgICAgIC8vIGNvbW1pdHRlZC4gSWYgaXQncyBzeW5jLCB3ZSBzdGlsbCB3YW50IHRvIHlpZWxkIHNvIHRoYXQgaXQgY2FuIGJlXG4gICAgICAgICAgICAgIC8vIHBhaW50ZWQuIENvbmNlcHR1YWxseSwgdGhpcyBpcyByZWFsbHkgdGhlIHNhbWUgYXMgcGluZ2luZy5cbiAgICAgICAgICAgICAgLy8gV2UgY2FuIHVzZSBhbnkgUmV0cnlMYW5lIGV2ZW4gaWYgaXQncyB0aGUgb25lIGN1cnJlbnRseSByZW5kZXJpbmdcbiAgICAgICAgICAgICAgLy8gc2luY2Ugd2UncmUgbGVhdmluZyBpdCBiZWhpbmQgb24gdGhpcyBub2RlLlxuXG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gU29tZVJldHJ5TGFuZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCBmYWxzZSk7XG4gICAgICAgICAgfSAvLyBOZXh0IHdlJ3JlIGdvaW5nIHRvIHJlbmRlciB0aGUgdGFpbC5cblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFwcGVuZCB0aGUgcmVuZGVyZWQgcm93IHRvIHRoZSBjaGlsZCBsaXN0LlxuICAgICAgICAgIGlmICghZGlkU3VzcGVuZEFscmVhZHkpIHtcbiAgICAgICAgICAgIHZhciBfc3VzcGVuZGVkID0gZmluZEZpcnN0U3VzcGVuZGVkKHJlbmRlcmVkVGFpbCk7XG5cbiAgICAgICAgICAgIGlmIChfc3VzcGVuZGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IERpZENhcHR1cmU7XG4gICAgICAgICAgICAgIGRpZFN1c3BlbmRBbHJlYWR5ID0gdHJ1ZTsgLy8gRW5zdXJlIHdlIHRyYW5zZmVyIHRoZSB1cGRhdGUgcXVldWUgdG8gdGhlIHBhcmVudCBzbyB0aGF0IGl0IGRvZXNuJ3RcbiAgICAgICAgICAgICAgLy8gZ2V0IGxvc3QgaWYgdGhpcyByb3cgZW5kcyB1cCBkcm9wcGVkIGR1cmluZyBhIHNlY29uZCBwYXNzLlxuXG4gICAgICAgICAgICAgIHZhciBfcmV0cnlRdWV1ZTIgPSBfc3VzcGVuZGVkLnVwZGF0ZVF1ZXVlO1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IF9yZXRyeVF1ZXVlMjtcbiAgICAgICAgICAgICAgc2NoZWR1bGVSZXRyeUVmZmVjdCh3b3JrSW5Qcm9ncmVzcywgX3JldHJ5UXVldWUyKTtcbiAgICAgICAgICAgICAgY3V0T2ZmVGFpbElmTmVlZGVkKHJlbmRlclN0YXRlLCB0cnVlKTsgLy8gVGhpcyBtaWdodCBoYXZlIGJlZW4gbW9kaWZpZWQuXG5cbiAgICAgICAgICAgICAgaWYgKHJlbmRlclN0YXRlLnRhaWwgPT09IG51bGwgJiYgcmVuZGVyU3RhdGUudGFpbE1vZGUgPT09ICdoaWRkZW4nICYmICFyZW5kZXJlZFRhaWwuYWx0ZXJuYXRlICYmICFnZXRJc0h5ZHJhdGluZygpIC8vIFdlIGRvbid0IGN1dCBpdCBpZiB3ZSdyZSBoeWRyYXRpbmcuXG4gICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgLy8gV2UncmUgZG9uZS5cbiAgICAgICAgICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmICggLy8gVGhlIHRpbWUgaXQgdG9vayB0byByZW5kZXIgbGFzdCByb3cgaXMgZ3JlYXRlciB0aGFuIHRoZSByZW1haW5pbmdcbiAgICAgICAgICAgIC8vIHRpbWUgd2UgaGF2ZSB0byByZW5kZXIuIFNvIHJlbmRlcmluZyBvbmUgbW9yZSByb3cgd291bGQgbGlrZWx5XG4gICAgICAgICAgICAvLyBleGNlZWQgaXQuXG4gICAgICAgICAgICBub3ckMSgpICogMiAtIHJlbmRlclN0YXRlLnJlbmRlcmluZ1N0YXJ0VGltZSA+IGdldFJlbmRlclRhcmdldFRpbWUoKSAmJiByZW5kZXJMYW5lcyAhPT0gT2Zmc2NyZWVuTGFuZSkge1xuICAgICAgICAgICAgICAvLyBXZSBoYXZlIG5vdyBwYXNzZWQgb3VyIENQVSBkZWFkbGluZSBhbmQgd2UnbGwganVzdCBnaXZlIHVwIGZ1cnRoZXJcbiAgICAgICAgICAgICAgLy8gYXR0ZW1wdHMgdG8gcmVuZGVyIHRoZSBtYWluIGNvbnRlbnQgYW5kIG9ubHkgcmVuZGVyIGZhbGxiYWNrcy5cbiAgICAgICAgICAgICAgLy8gVGhlIGFzc3VtcHRpb24gaXMgdGhhdCB0aGlzIGlzIHVzdWFsbHkgZmFzdGVyLlxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBEaWRDYXB0dXJlO1xuICAgICAgICAgICAgICBkaWRTdXNwZW5kQWxyZWFkeSA9IHRydWU7XG4gICAgICAgICAgICAgIGN1dE9mZlRhaWxJZk5lZWRlZChyZW5kZXJTdGF0ZSwgZmFsc2UpOyAvLyBTaW5jZSBub3RoaW5nIGFjdHVhbGx5IHN1c3BlbmRlZCwgdGhlcmUgd2lsbCBub3RoaW5nIHRvIHBpbmcgdGhpc1xuICAgICAgICAgICAgICAvLyB0byBnZXQgaXQgc3RhcnRlZCBiYWNrIHVwIHRvIGF0dGVtcHQgdGhlIG5leHQgaXRlbS4gV2hpbGUgaW4gdGVybXNcbiAgICAgICAgICAgICAgLy8gb2YgcHJpb3JpdHkgdGhpcyB3b3JrIGhhcyB0aGUgc2FtZSBwcmlvcml0eSBhcyB0aGlzIGN1cnJlbnQgcmVuZGVyLFxuICAgICAgICAgICAgICAvLyBpdCdzIG5vdCBwYXJ0IG9mIHRoZSBzYW1lIHRyYW5zaXRpb24gb25jZSB0aGUgdHJhbnNpdGlvbiBoYXNcbiAgICAgICAgICAgICAgLy8gY29tbWl0dGVkLiBJZiBpdCdzIHN5bmMsIHdlIHN0aWxsIHdhbnQgdG8geWllbGQgc28gdGhhdCBpdCBjYW4gYmVcbiAgICAgICAgICAgICAgLy8gcGFpbnRlZC4gQ29uY2VwdHVhbGx5LCB0aGlzIGlzIHJlYWxseSB0aGUgc2FtZSBhcyBwaW5naW5nLlxuICAgICAgICAgICAgICAvLyBXZSBjYW4gdXNlIGFueSBSZXRyeUxhbmUgZXZlbiBpZiBpdCdzIHRoZSBvbmUgY3VycmVudGx5IHJlbmRlcmluZ1xuICAgICAgICAgICAgICAvLyBzaW5jZSB3ZSdyZSBsZWF2aW5nIGl0IGJlaGluZCBvbiB0aGlzIG5vZGUuXG5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MubGFuZXMgPSBTb21lUmV0cnlMYW5lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChyZW5kZXJTdGF0ZS5pc0JhY2t3YXJkcykge1xuICAgICAgICAgICAgLy8gVGhlIGVmZmVjdCBsaXN0IG9mIHRoZSBiYWNrd2FyZHMgdGFpbCB3aWxsIGhhdmUgYmVlbiBhZGRlZFxuICAgICAgICAgICAgLy8gdG8gdGhlIGVuZC4gVGhpcyBicmVha3MgdGhlIGd1YXJhbnRlZSB0aGF0IGxpZmUtY3ljbGVzIGZpcmUgaW5cbiAgICAgICAgICAgIC8vIHNpYmxpbmcgb3JkZXIgYnV0IHRoYXQgaXNuJ3QgYSBzdHJvbmcgZ3VhcmFudGVlIHByb21pc2VkIGJ5IFJlYWN0LlxuICAgICAgICAgICAgLy8gRXNwZWNpYWxseSBzaW5jZSB0aGVzZSBtaWdodCBhbHNvIGp1c3QgcG9wIGluIGR1cmluZyBmdXR1cmUgY29tbWl0cy5cbiAgICAgICAgICAgIC8vIEFwcGVuZCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0LlxuICAgICAgICAgICAgcmVuZGVyZWRUYWlsLnNpYmxpbmcgPSB3b3JrSW5Qcm9ncmVzcy5jaGlsZDtcbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVuZGVyZWRUYWlsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJldmlvdXNTaWJsaW5nID0gcmVuZGVyU3RhdGUubGFzdDtcblxuICAgICAgICAgICAgaWYgKHByZXZpb3VzU2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBwcmV2aW91c1NpYmxpbmcuc2libGluZyA9IHJlbmRlcmVkVGFpbDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmNoaWxkID0gcmVuZGVyZWRUYWlsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZW5kZXJTdGF0ZS5sYXN0ID0gcmVuZGVyZWRUYWlsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZW5kZXJTdGF0ZS50YWlsICE9PSBudWxsKSB7XG4gICAgICAgICAgLy8gV2Ugc3RpbGwgaGF2ZSB0YWlsIHJvd3MgdG8gcmVuZGVyLlxuICAgICAgICAgIC8vIFBvcCBhIHJvdy5cbiAgICAgICAgICB2YXIgbmV4dCA9IHJlbmRlclN0YXRlLnRhaWw7XG4gICAgICAgICAgcmVuZGVyU3RhdGUucmVuZGVyaW5nID0gbmV4dDtcbiAgICAgICAgICByZW5kZXJTdGF0ZS50YWlsID0gbmV4dC5zaWJsaW5nO1xuICAgICAgICAgIHJlbmRlclN0YXRlLnJlbmRlcmluZ1N0YXJ0VGltZSA9IG5vdyQxKCk7XG4gICAgICAgICAgbmV4dC5zaWJsaW5nID0gbnVsbDsgLy8gUmVzdG9yZSB0aGUgY29udGV4dC5cbiAgICAgICAgICAvLyBUT0RPOiBXZSBjYW4gcHJvYmFibHkganVzdCBhdm9pZCBwb3BwaW5nIGl0IGluc3RlYWQgYW5kIG9ubHlcbiAgICAgICAgICAvLyBzZXR0aW5nIGl0IHRoZSBmaXJzdCB0aW1lIHdlIGdvIGZyb20gbm90IHN1c3BlbmRlZCB0byBzdXNwZW5kZWQuXG5cbiAgICAgICAgICB2YXIgc3VzcGVuc2VDb250ZXh0ID0gc3VzcGVuc2VTdGFja0N1cnNvci5jdXJyZW50O1xuXG4gICAgICAgICAgaWYgKGRpZFN1c3BlbmRBbHJlYWR5KSB7XG4gICAgICAgICAgICBzdXNwZW5zZUNvbnRleHQgPSBzZXRTaGFsbG93U3VzcGVuc2VMaXN0Q29udGV4dChzdXNwZW5zZUNvbnRleHQsIEZvcmNlU3VzcGVuc2VGYWxsYmFjayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN1c3BlbnNlQ29udGV4dCA9IHNldERlZmF1bHRTaGFsbG93U3VzcGVuc2VMaXN0Q29udGV4dChzdXNwZW5zZUNvbnRleHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHB1c2hTdXNwZW5zZUxpc3RDb250ZXh0KHdvcmtJblByb2dyZXNzLCBzdXNwZW5zZUNvbnRleHQpOyAvLyBEbyBhIHBhc3Mgb3ZlciB0aGUgbmV4dCByb3cuXG4gICAgICAgICAgLy8gRG9uJ3QgYnViYmxlIHByb3BlcnRpZXMgaW4gdGhpcyBjYXNlLlxuXG4gICAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgICAgIH1cblxuICAgICAgICBidWJibGVQcm9wZXJ0aWVzKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIFNjb3BlQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHBvcEhpZGRlbkNvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB2YXIgX25leHRTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHZhciBuZXh0SXNIaWRkZW4gPSBfbmV4dFN0YXRlICE9PSBudWxsOyAvLyBTY2hlZHVsZSBhIFZpc2liaWxpdHkgZWZmZWN0IGlmIHRoZSB2aXNpYmlsaXR5IGhhcyBjaGFuZ2VkXG5cbiAgICAgICAge1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgX3ByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIHZhciBwcmV2SXNIaWRkZW4gPSBfcHJldlN0YXRlICE9PSBudWxsO1xuXG4gICAgICAgICAgICBpZiAocHJldklzSGlkZGVuICE9PSBuZXh0SXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVmlzaWJpbGl0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT24gaW5pdGlhbCBtb3VudCwgd2Ugb25seSBuZWVkIGEgVmlzaWJpbGl0eSBlZmZlY3QgaWYgdGhlIHRyZWVcbiAgICAgICAgICAgIC8vIGlzIGhpZGRlbi5cbiAgICAgICAgICAgIGlmIChuZXh0SXNIaWRkZW4pIHtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gVmlzaWJpbGl0eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIW5leHRJc0hpZGRlbiB8fCAhZGlzYWJsZUxlZ2FjeU1vZGUgKSB7XG4gICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gRG9uJ3QgYnViYmxlIHByb3BlcnRpZXMgZm9yIGhpZGRlbiBjaGlsZHJlbiB1bmxlc3Mgd2UncmUgcmVuZGVyaW5nXG4gICAgICAgICAgLy8gYXQgb2Zmc2NyZWVuIHByaW9yaXR5LlxuICAgICAgICAgIGlmIChpbmNsdWRlc1NvbWVMYW5lKHJlbmRlckxhbmVzLCBPZmZzY3JlZW5MYW5lKSAmJiAvLyBBbHNvIGRvbid0IGJ1YmJsZSBpZiB0aGUgdHJlZSBzdXNwZW5kZWRcbiAgICAgICAgICAod29ya0luUHJvZ3Jlc3MuZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gTm9MYW5lcykge1xuICAgICAgICAgICAgYnViYmxlUHJvcGVydGllcyh3b3JrSW5Qcm9ncmVzcyk7IC8vIENoZWNrIGlmIHRoZXJlIHdhcyBhbiBpbnNlcnRpb24gb3IgdXBkYXRlIGluIHRoZSBoaWRkZW4gc3VidHJlZS5cbiAgICAgICAgICAgIC8vIElmIHNvLCB3ZSBuZWVkIHRvIGhpZGUgdGhvc2Ugbm9kZXMgaW4gdGhlIGNvbW1pdCBwaGFzZSwgc29cbiAgICAgICAgICAgIC8vIHNjaGVkdWxlIGEgdmlzaWJpbGl0eSBlZmZlY3QuXG5cbiAgICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgJiAoUGxhY2VtZW50IHwgVXBkYXRlKSkge1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyB8PSBWaXNpYmlsaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvZmZzY3JlZW5RdWV1ZSA9IHdvcmtJblByb2dyZXNzLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgIGlmIChvZmZzY3JlZW5RdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHZhciBfcmV0cnlRdWV1ZTMgPSBvZmZzY3JlZW5RdWV1ZS5yZXRyeVF1ZXVlO1xuICAgICAgICAgIHNjaGVkdWxlUmV0cnlFZmZlY3Qod29ya0luUHJvZ3Jlc3MsIF9yZXRyeVF1ZXVlMyk7XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9wcmV2aW91c0NhY2hlMiA9IG51bGw7XG5cbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCAmJiBjdXJyZW50Lm1lbW9pemVkU3RhdGUgIT09IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgX3ByZXZpb3VzQ2FjaGUyID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlUG9vbC5wb29sO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfY2FjaGUyID0gbnVsbDtcblxuICAgICAgICAgIGlmICh3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlICE9PSBudWxsICYmIHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICE9PSBudWxsKSB7XG4gICAgICAgICAgICBfY2FjaGUyID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoX2NhY2hlMiAhPT0gX3ByZXZpb3VzQ2FjaGUyKSB7XG4gICAgICAgICAgICAvLyBSdW4gcGFzc2l2ZSBlZmZlY3RzIHRvIHJldGFpbi9yZWxlYXNlIHRoZSBjYWNoZS5cbiAgICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzIHw9IFBhc3NpdmUkMTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBwb3BUcmFuc2l0aW9uKHdvcmtJblByb2dyZXNzLCBjdXJyZW50KTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIENhY2hlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB7XG4gICAgICAgICAgdmFyIF9wcmV2aW91c0NhY2hlMyA9IG51bGw7XG5cbiAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgX3ByZXZpb3VzQ2FjaGUzID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfY2FjaGUzID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZS5jYWNoZTtcblxuICAgICAgICAgIGlmIChfY2FjaGUzICE9PSBfcHJldmlvdXNDYWNoZTMpIHtcbiAgICAgICAgICAgIC8vIFJ1biBwYXNzaXZlIGVmZmVjdHMgdG8gcmV0YWluL3JlbGVhc2UgdGhlIGNhY2hlLlxuICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gUGFzc2l2ZSQxO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBvcENhY2hlUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIGJ1YmJsZVByb3BlcnRpZXMod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIFRyYWNpbmdNYXJrZXJDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHVuaXQgb2Ygd29yayB0YWcgKFwiICsgd29ya0luUHJvZ3Jlc3MudGFnICsgXCIpLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gXCIgKyAnUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xufVxuXG5mdW5jdGlvbiB1bndpbmRXb3JrKGN1cnJlbnQsIHdvcmtJblByb2dyZXNzLCByZW5kZXJMYW5lcykge1xuICAvLyBOb3RlOiBUaGlzIGludGVudGlvbmFsbHkgZG9lc24ndCBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcgYmVjYXVzZSBjb21wYXJpbmdcbiAgLy8gdG8gdGhlIGN1cnJlbnQgdHJlZSBwcm92aWRlciBmaWJlciBpcyBqdXN0IGFzIGZhc3QgYW5kIGxlc3MgZXJyb3ItcHJvbmUuXG4gIC8vIElkZWFsbHkgd2Ugd291bGQgaGF2ZSBhIHNwZWNpYWwgdmVyc2lvbiBvZiB0aGUgd29yayBsb29wIG9ubHlcbiAgLy8gZm9yIGh5ZHJhdGlvbi5cbiAgcG9wVHJlZUNvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuXG4gIHN3aXRjaCAod29ya0luUHJvZ3Jlc3MudGFnKSB7XG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICB2YXIgZmxhZ3MgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncztcblxuICAgICAgICBpZiAoZmxhZ3MgJiBTaG91bGRDYXB0dXJlKSB7XG4gICAgICAgICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBmbGFncyAmIH5TaG91bGRDYXB0dXJlIHwgRGlkQ2FwdHVyZTtcblxuICAgICAgICAgIGlmICgod29ya0luUHJvZ3Jlc3MubW9kZSAmIFByb2ZpbGVNb2RlKSAhPT0gTm9Nb2RlKSB7XG4gICAgICAgICAgICB0cmFuc2ZlckFjdHVhbER1cmF0aW9uKHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3M7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG5cbiAgICAgICAge1xuICAgICAgICAgIHBvcENhY2hlUHJvdmlkZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICAgIHBvcEhvc3RDb250YWluZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB2YXIgX2ZsYWdzID0gd29ya0luUHJvZ3Jlc3MuZmxhZ3M7XG5cbiAgICAgICAgaWYgKChfZmxhZ3MgJiBTaG91bGRDYXB0dXJlKSAhPT0gTm9GbGFncyQxICYmIChfZmxhZ3MgJiBEaWRDYXB0dXJlKSA9PT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgLy8gVGhlcmUgd2FzIGFuIGVycm9yIGR1cmluZyByZW5kZXIgdGhhdCB3YXNuJ3QgY2FwdHVyZWQgYnkgYSBzdXNwZW5zZVxuICAgICAgICAgIC8vIGJvdW5kYXJ5LiBEbyBhIHNlY29uZCBwYXNzIG9uIHRoZSByb290IHRvIHVubW91bnQgdGhlIGNoaWxkcmVuLlxuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzID0gX2ZsYWdzICYgflNob3VsZENhcHR1cmUgfCBEaWRDYXB0dXJlO1xuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfSAvLyBXZSB1bndvdW5kIHRvIHRoZSByb290IHdpdGhvdXQgY29tcGxldGluZyBpdC4gRXhpdC5cblxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0SG9pc3RhYmxlOlxuICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIC8vIFRPRE86IHBvcEh5ZHJhdGlvblN0YXRlXG4gICAgICAgIHBvcEhvc3RDb250ZXh0KHdvcmtJblByb2dyZXNzKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BTdXNwZW5zZUhhbmRsZXIod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IHdvcmtJblByb2dyZXNzLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgaWYgKHN1c3BlbnNlU3RhdGUgIT09IG51bGwgJiYgc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG4gICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaHJldyBpbiBuZXdseSBtb3VudGVkIGRlaHlkcmF0ZWQgY29tcG9uZW50LiBUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiAnICsgJ1JlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXNldEh5ZHJhdGlvblN0YXRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2ZsYWdzMiA9IHdvcmtJblByb2dyZXNzLmZsYWdzO1xuXG4gICAgICAgIGlmIChfZmxhZ3MyICYgU2hvdWxkQ2FwdHVyZSkge1xuICAgICAgICAgIHdvcmtJblByb2dyZXNzLmZsYWdzID0gX2ZsYWdzMiAmIH5TaG91bGRDYXB0dXJlIHwgRGlkQ2FwdHVyZTsgLy8gQ2FwdHVyZWQgYSBzdXNwZW5zZSBlZmZlY3QuIFJlLXJlbmRlciB0aGUgYm91bmRhcnkuXG5cbiAgICAgICAgICBpZiAoKHdvcmtJblByb2dyZXNzLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgICAgICAgdHJhbnNmZXJBY3R1YWxEdXJhdGlvbih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wU3VzcGVuc2VMaXN0Q29udGV4dCh3b3JrSW5Qcm9ncmVzcyk7IC8vIFN1c3BlbnNlTGlzdCBkb2Vzbid0IGFjdHVhbGx5IGNhdGNoIGFueXRoaW5nLiBJdCBzaG91bGQndmUgYmVlblxuICAgICAgICAvLyBjYXVnaHQgYnkgYSBuZXN0ZWQgYm91bmRhcnkuIElmIG5vdCwgaXQgc2hvdWxkIGJ1YmJsZSB0aHJvdWdoLlxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAgcG9wSG9zdENvbnRhaW5lcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgdmFyIGNvbnRleHQ7XG5cbiAgICAgIHtcbiAgICAgICAgY29udGV4dCA9IHdvcmtJblByb2dyZXNzLnR5cGU7XG4gICAgICB9XG5cbiAgICAgIHBvcFByb3ZpZGVyKGNvbnRleHQsIHdvcmtJblByb2dyZXNzKTtcbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICAgIHBvcEhpZGRlbkNvbnRleHQod29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICBwb3BUcmFuc2l0aW9uKHdvcmtJblByb2dyZXNzLCBjdXJyZW50KTtcbiAgICAgICAgdmFyIF9mbGFnczMgPSB3b3JrSW5Qcm9ncmVzcy5mbGFncztcblxuICAgICAgICBpZiAoX2ZsYWdzMyAmIFNob3VsZENhcHR1cmUpIHtcbiAgICAgICAgICB3b3JrSW5Qcm9ncmVzcy5mbGFncyA9IF9mbGFnczMgJiB+U2hvdWxkQ2FwdHVyZSB8IERpZENhcHR1cmU7IC8vIENhcHR1cmVkIGEgc3VzcGVuc2UgZWZmZWN0LiBSZS1yZW5kZXIgdGhlIGJvdW5kYXJ5LlxuXG4gICAgICAgICAgaWYgKCh3b3JrSW5Qcm9ncmVzcy5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUpIHtcbiAgICAgICAgICAgIHRyYW5zZmVyQWN0dWFsRHVyYXRpb24od29ya0luUHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgY2FzZSBDYWNoZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wQ2FjaGVQcm92aWRlcih3b3JrSW5Qcm9ncmVzcyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuXG4gICAgY2FzZSBUcmFjaW5nTWFya2VyQ29tcG9uZW50OlxuXG4gICAgICByZXR1cm4gbnVsbDtcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bndpbmRJbnRlcnJ1cHRlZFdvcmsoY3VycmVudCwgaW50ZXJydXB0ZWRXb3JrLCByZW5kZXJMYW5lcykge1xuICAvLyBOb3RlOiBUaGlzIGludGVudGlvbmFsbHkgZG9lc24ndCBjaGVjayBpZiB3ZSdyZSBoeWRyYXRpbmcgYmVjYXVzZSBjb21wYXJpbmdcbiAgLy8gdG8gdGhlIGN1cnJlbnQgdHJlZSBwcm92aWRlciBmaWJlciBpcyBqdXN0IGFzIGZhc3QgYW5kIGxlc3MgZXJyb3ItcHJvbmUuXG4gIC8vIElkZWFsbHkgd2Ugd291bGQgaGF2ZSBhIHNwZWNpYWwgdmVyc2lvbiBvZiB0aGUgd29yayBsb29wIG9ubHlcbiAgLy8gZm9yIGh5ZHJhdGlvbi5cbiAgcG9wVHJlZUNvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcblxuICBzd2l0Y2ggKGludGVycnVwdGVkV29yay50YWcpIHtcbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcblxuICAgICAgICB7XG4gICAgICAgICAgcG9wQ2FjaGVQcm92aWRlcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgICB9XG4gICAgICAgIHBvcEhvc3RDb250YWluZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RIb2lzdGFibGU6XG4gICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcG9wSG9zdENvbnRleHQoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICBwb3BIb3N0Q29udGFpbmVyKGludGVycnVwdGVkV29yayk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICBwb3BTdXNwZW5zZUhhbmRsZXIoaW50ZXJydXB0ZWRXb3JrKTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICBwb3BTdXNwZW5zZUxpc3RDb250ZXh0KGludGVycnVwdGVkV29yayk7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgQ29udGV4dFByb3ZpZGVyOlxuICAgICAgdmFyIGNvbnRleHQ7XG5cbiAgICAgIHtcbiAgICAgICAgY29udGV4dCA9IGludGVycnVwdGVkV29yay50eXBlO1xuICAgICAgfVxuXG4gICAgICBwb3BQcm92aWRlcihjb250ZXh0LCBpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICBjYXNlIExlZ2FjeUhpZGRlbkNvbXBvbmVudDpcbiAgICAgIHBvcFN1c3BlbnNlSGFuZGxlcihpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgcG9wSGlkZGVuQ29udGV4dChpbnRlcnJ1cHRlZFdvcmspO1xuICAgICAgcG9wVHJhbnNpdGlvbihpbnRlcnJ1cHRlZFdvcmssIGN1cnJlbnQpO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIENhY2hlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBwb3BDYWNoZVByb3ZpZGVyKGludGVycnVwdGVkV29yayk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZSA9IG51bGw7XG5cbntcbiAgZGlkV2FybkFib3V0VW5kZWZpbmVkU25hcHNob3RCZWZvcmVVcGRhdGUgPSBuZXcgU2V0KCk7XG59IC8vIFVzZWQgZHVyaW5nIHRoZSBjb21taXQgcGhhc2UgdG8gdHJhY2sgdGhlIHN0YXRlIG9mIHRoZSBPZmZzY3JlZW4gY29tcG9uZW50IHN0YWNrLlxuLy8gQWxsb3dzIHVzIHRvIGF2b2lkIHRyYXZlcnNpbmcgdGhlIHJldHVybiBwYXRoIHRvIGZpbmQgdGhlIG5lYXJlc3QgT2Zmc2NyZWVuIGFuY2VzdG9yLlxuXG5cbnZhciBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBmYWxzZTtcbnZhciBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gZmFsc2U7IC8vIFVzZWQgdG8gdHJhY2sgaWYgYSBmb3JtIG5lZWRzIHRvIGJlIHJlc2V0IGF0IHRoZSBlbmQgb2YgdGhlIG11dGF0aW9uIHBoYXNlLlxuXG52YXIgbmVlZHNGb3JtUmVzZXQgPSBmYWxzZTtcbnZhciBQb3NzaWJseVdlYWtTZXQgPSB0eXBlb2YgV2Vha1NldCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtTZXQgOiBTZXQ7XG52YXIgbmV4dEVmZmVjdCA9IG51bGw7IC8vIFVzZWQgZm9yIFByb2ZpbGluZyBidWlsZHMgdG8gdHJhY2sgdXBkYXRlcnMuXG5cbnZhciBpblByb2dyZXNzTGFuZXMgPSBudWxsO1xudmFyIGluUHJvZ3Jlc3NSb290ID0gbnVsbDtcblxuZnVuY3Rpb24gc2hvdWxkUHJvZmlsZShjdXJyZW50KSB7XG4gIHJldHVybiAoY3VycmVudC5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGUgJiYgKGdldEV4ZWN1dGlvbkNvbnRleHQoKSAmIENvbW1pdENvbnRleHQpICE9PSBOb0NvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGNhbGxDb21wb25lbnRXaWxsVW5tb3VudFdpdGhUaW1lcihjdXJyZW50LCBpbnN0YW5jZSkge1xuICBpbnN0YW5jZS5wcm9wcyA9IHJlc29sdmVDbGFzc0NvbXBvbmVudFByb3BzKGN1cnJlbnQudHlwZSwgY3VycmVudC5tZW1vaXplZFByb3BzKTtcbiAgaW5zdGFuY2Uuc3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKHNob3VsZFByb2ZpbGUoY3VycmVudCkpIHtcbiAgICB0cnkge1xuICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oY3VycmVudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50KCk7XG4gIH1cbn0gLy8gQ2FwdHVyZSBlcnJvcnMgc28gdGhleSBkb24ndCBpbnRlcnJ1cHQgdW5tb3VudGluZy5cblxuXG5mdW5jdGlvbiBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgaW5zdGFuY2UpIHtcbiAgdHJ5IHtcbiAgICBjYWxsQ29tcG9uZW50V2lsbFVubW91bnRXaXRoVGltZXIoY3VycmVudCwgaW5zdGFuY2UpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgfVxufSAvLyBDYXB0dXJlIGVycm9ycyBzbyB0aGV5IGRvbid0IGludGVycnVwdCBtb3VudGluZy5cblxuXG5mdW5jdGlvbiBzYWZlbHlBdHRhY2hSZWYoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuICB0cnkge1xuICAgIGNvbW1pdEF0dGFjaFJlZihjdXJyZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2FmZWx5RGV0YWNoUmVmKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpIHtcbiAgdmFyIHJlZiA9IGN1cnJlbnQucmVmO1xuICB2YXIgcmVmQ2xlYW51cCA9IGN1cnJlbnQucmVmQ2xlYW51cDtcblxuICBpZiAocmVmICE9PSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiByZWZDbGVhbnVwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoc2hvdWxkUHJvZmlsZShjdXJyZW50KSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzdGFydExheW91dEVmZmVjdFRpbWVyKCk7XG4gICAgICAgICAgICByZWZDbGVhbnVwKCk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGN1cnJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWZDbGVhbnVwKCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIC8vIGByZWZDbGVhbnVwYCBoYXMgYmVlbiBjYWxsZWQuIE51bGxpZnkgYWxsIHJlZmVyZW5jZXMgdG8gaXQgdG8gcHJldmVudCBkb3VibGUgaW52b2NhdGlvbi5cbiAgICAgICAgY3VycmVudC5yZWZDbGVhbnVwID0gbnVsbDtcbiAgICAgICAgdmFyIGZpbmlzaGVkV29yayA9IGN1cnJlbnQuYWx0ZXJuYXRlO1xuXG4gICAgICAgIGlmIChmaW5pc2hlZFdvcmsgIT0gbnVsbCkge1xuICAgICAgICAgIGZpbmlzaGVkV29yay5yZWZDbGVhbnVwID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKHNob3VsZFByb2ZpbGUoY3VycmVudCkpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICAgICAgcmVmKG51bGwpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihjdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVmKG51bGwpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gdW5hYmxlIHRvIG5hcnJvdyB0eXBlIHRvIFJlZk9iamVjdFxuICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzYWZlbHlDYWxsRGVzdHJveShjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZXN0cm95KSB7XG4gIHRyeSB7XG4gICAgZGVzdHJveSgpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGN1cnJlbnQsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGVycm9yKTtcbiAgfVxufVxudmFyIHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1ciA9IGZhbHNlO1xuZnVuY3Rpb24gY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpcnN0Q2hpbGQpIHtcbiAgcHJlcGFyZUZvckNvbW1pdChyb290LmNvbnRhaW5lckluZm8pO1xuICBuZXh0RWZmZWN0ID0gZmlyc3RDaGlsZDtcbiAgY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzX2JlZ2luKCk7IC8vIFdlIG5vIGxvbmdlciBuZWVkIHRvIHRyYWNrIHRoZSBhY3RpdmUgaW5zdGFuY2UgZmliZXJcblxuICB2YXIgc2hvdWxkRmlyZSA9IHNob3VsZEZpcmVBZnRlckFjdGl2ZUluc3RhbmNlQmx1cjtcbiAgc2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyID0gZmFsc2U7XG4gIHJldHVybiBzaG91bGRGaXJlO1xufVxuXG5mdW5jdGlvbiBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHNfYmVnaW4oKSB7XG4gIHdoaWxlIChuZXh0RWZmZWN0ICE9PSBudWxsKSB7XG4gICAgdmFyIGZpYmVyID0gbmV4dEVmZmVjdDsgLy8gVGhpcyBwaGFzZSBpcyBvbmx5IHVzZWQgZm9yIGJlZm9yZUFjdGl2ZUluc3RhbmNlQmx1ci5cblxuICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkO1xuXG4gICAgaWYgKChmaWJlci5zdWJ0cmVlRmxhZ3MgJiBCZWZvcmVNdXRhdGlvbk1hc2spICE9PSBOb0ZsYWdzJDEgJiYgY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGNoaWxkLnJldHVybiA9IGZpYmVyO1xuICAgICAgbmV4dEVmZmVjdCA9IGNoaWxkO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb21taXRCZWZvcmVNdXRhdGlvbkVmZmVjdHNfY29tcGxldGUoKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzX2NvbXBsZXRlKCkge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7XG4gICAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihmaWJlcik7XG5cbiAgICB0cnkge1xuICAgICAgY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzT25GaWJlcihmaWJlcik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpYmVyLCBmaWJlci5yZXR1cm4sIGVycm9yKTtcbiAgICB9XG5cbiAgICByZXNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoKTtcbiAgICB2YXIgc2libGluZyA9IGZpYmVyLnNpYmxpbmc7XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgc2libGluZy5yZXR1cm4gPSBmaWJlci5yZXR1cm47XG4gICAgICBuZXh0RWZmZWN0ID0gc2libGluZztcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBuZXh0RWZmZWN0ID0gZmliZXIucmV0dXJuO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c09uRmliZXIoZmluaXNoZWRXb3JrKSB7XG4gIHZhciBjdXJyZW50ID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZTtcbiAgdmFyIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuXG4gIGlmICgoZmxhZ3MgJiBTbmFwc2hvdCkgIT09IE5vRmxhZ3MkMSkge1xuICAgIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoZmluaXNoZWRXb3JrKTtcbiAgfVxuXG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGlmICgoZmxhZ3MgJiBTbmFwc2hvdCkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgcHJldlByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgdmFyIHByZXZTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7IC8vIFdlIGNvdWxkIHVwZGF0ZSBpbnN0YW5jZSBwcm9wcyBhbmQgc3RhdGUgaGVyZSxcbiAgICAgICAgICAgIC8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuICAgICAgICAgICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmICghZmluaXNoZWRXb3JrLnR5cGUuZGVmYXVsdFByb3BzICYmICEoJ3JlZicgaW4gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMpICYmICFkaWRXYXJuQWJvdXRSZWFzc2lnbmluZ1Byb3BzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuICAgICAgICAgICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSAnICsgJ2dldFNuYXBzaG90QmVmb3JlVXBkYXRlLiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS5zdGF0ZSAhPT0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgJyArICdnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZS4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNuYXBzaG90ID0gaW5zdGFuY2UuZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUocmVzb2x2ZUNsYXNzQ29tcG9uZW50UHJvcHMoZmluaXNoZWRXb3JrLnR5cGUsIHByZXZQcm9wcyksIHByZXZTdGF0ZSk7XG5cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgdmFyIGRpZFdhcm5TZXQgPSBkaWRXYXJuQWJvdXRVbmRlZmluZWRTbmFwc2hvdEJlZm9yZVVwZGF0ZTtcblxuICAgICAgICAgICAgICBpZiAoc25hcHNob3QgPT09IHVuZGVmaW5lZCAmJiAhZGlkV2FyblNldC5oYXMoZmluaXNoZWRXb3JrLnR5cGUpKSB7XG4gICAgICAgICAgICAgICAgZGlkV2FyblNldC5hZGQoZmluaXNoZWRXb3JrLnR5cGUpO1xuXG4gICAgICAgICAgICAgICAgZXJyb3IoJyVzLmdldFNuYXBzaG90QmVmb3JlVXBkYXRlKCk6IEEgc25hcHNob3QgdmFsdWUgKG9yIG51bGwpICcgKyAnbXVzdCBiZSByZXR1cm5lZC4gWW91IGhhdmUgcmV0dXJuZWQgdW5kZWZpbmVkLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5zdGFuY2UuX19yZWFjdEludGVybmFsU25hcHNob3RCZWZvcmVVcGRhdGUgPSBzbmFwc2hvdDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIGlmICgoZmxhZ3MgJiBTbmFwc2hvdCkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgcm9vdCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBjbGVhckNvbnRhaW5lcihyb290LmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgIGNhc2UgSG9zdEhvaXN0YWJsZTpcbiAgICBjYXNlIEhvc3RTaW5nbGV0b246XG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgY2FzZSBJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQ6XG4gICAgICAvLyBOb3RoaW5nIHRvIGRvIGZvciB0aGVzZSBjb21wb25lbnQgdHlwZXNcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgaWYgKChmbGFncyAmIFNuYXBzaG90KSAhPT0gTm9GbGFncyQxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIHVuaXQgb2Ygd29yayB0YWcgc2hvdWxkIG5vdCBoYXZlIHNpZGUtZWZmZWN0cy4gVGhpcyBlcnJvciBpcyAnICsgJ2xpa2VseSBjYXVzZWQgYnkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gIH1cblxuICBpZiAoKGZsYWdzICYgU25hcHNob3QpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICByZXNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoZmxhZ3MsIGZpbmlzaGVkV29yaywgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gIHZhciBsYXN0RWZmZWN0ID0gdXBkYXRlUXVldWUgIT09IG51bGwgPyB1cGRhdGVRdWV1ZS5sYXN0RWZmZWN0IDogbnVsbDtcblxuICBpZiAobGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICB2YXIgZWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoKGVmZmVjdC50YWcgJiBmbGFncykgPT09IGZsYWdzKSB7XG4gICAgICAgIC8vIFVubW91bnRcbiAgICAgICAgdmFyIGluc3QgPSBlZmZlY3QuaW5zdDtcbiAgICAgICAgdmFyIGRlc3Ryb3kgPSBpbnN0LmRlc3Ryb3k7XG5cbiAgICAgICAgaWYgKGRlc3Ryb3kgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGluc3QuZGVzdHJveSA9IHVuZGVmaW5lZDtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICgoZmxhZ3MgJiBQYXNzaXZlKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgICAgICBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdGFydGVkKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChmbGFncyAmIExheW91dCkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICAgICAgbWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKChmbGFncyAmIEluc2VydGlvbikgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICAgICAgc2V0SXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0KHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHNhZmVseUNhbGxEZXN0cm95KGZpbmlzaGVkV29yaywgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVzdHJveSk7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoKGZsYWdzICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgICAgICBzZXRJc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICgoZmxhZ3MgJiBQYXNzaXZlKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgICAgICBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdG9wcGVkKCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKChmbGFncyAmIExheW91dCkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICAgICAgbWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdG9wcGVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGVmZmVjdCA9IGVmZmVjdC5uZXh0O1xuICAgIH0gd2hpbGUgKGVmZmVjdCAhPT0gZmlyc3RFZmZlY3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoZmxhZ3MsIGZpbmlzaGVkV29yaykge1xuICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG4gIHZhciBsYXN0RWZmZWN0ID0gdXBkYXRlUXVldWUgIT09IG51bGwgPyB1cGRhdGVRdWV1ZS5sYXN0RWZmZWN0IDogbnVsbDtcblxuICBpZiAobGFzdEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaXJzdEVmZmVjdCA9IGxhc3RFZmZlY3QubmV4dDtcbiAgICB2YXIgZWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICBkbyB7XG4gICAgICBpZiAoKGVmZmVjdC50YWcgJiBmbGFncykgPT09IGZsYWdzKSB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoKGZsYWdzICYgUGFzc2l2ZSkgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICAgIG1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfSBlbHNlIGlmICgoZmxhZ3MgJiBMYXlvdXQpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgICBtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdGFydGVkKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIE1vdW50XG5cblxuICAgICAgICB2YXIgY3JlYXRlID0gZWZmZWN0LmNyZWF0ZTtcblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKChmbGFncyAmIEluc2VydGlvbikgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICAgIHNldElzUnVubmluZ0luc2VydGlvbkVmZmVjdCh0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaW5zdCA9IGVmZmVjdC5pbnN0O1xuICAgICAgICB2YXIgZGVzdHJveSA9IGNyZWF0ZSgpO1xuICAgICAgICBpbnN0LmRlc3Ryb3kgPSBkZXN0cm95O1xuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoKGZsYWdzICYgSW5zZXJ0aW9uKSAhPT0gTm9GbGFncykge1xuICAgICAgICAgICAgc2V0SXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0KGZhbHNlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB7XG4gICAgICAgICAgaWYgKChmbGFncyAmIFBhc3NpdmUpICE9PSBOb0ZsYWdzKSB7XG4gICAgICAgICAgICBtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdE1vdW50U3RvcHBlZCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoKGZsYWdzICYgTGF5b3V0KSAhPT0gTm9GbGFncykge1xuICAgICAgICAgICAgbWFya0NvbXBvbmVudExheW91dEVmZmVjdE1vdW50U3RvcHBlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoZGVzdHJveSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBkZXN0cm95ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgaG9va05hbWUgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGlmICgoZWZmZWN0LnRhZyAmIExheW91dCkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgICAgICBob29rTmFtZSA9ICd1c2VMYXlvdXRFZmZlY3QnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICgoZWZmZWN0LnRhZyAmIEluc2VydGlvbikgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgICAgICAgICBob29rTmFtZSA9ICd1c2VJbnNlcnRpb25FZmZlY3QnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaG9va05hbWUgPSAndXNlRWZmZWN0JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGFkZGVuZHVtID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBpZiAoZGVzdHJveSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBhZGRlbmR1bSA9ICcgWW91IHJldHVybmVkIG51bGwuIElmIHlvdXIgZWZmZWN0IGRvZXMgbm90IHJlcXVpcmUgY2xlYW4gJyArICd1cCwgcmV0dXJuIHVuZGVmaW5lZCAob3Igbm90aGluZykuJztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGRlc3Ryb3kudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBhZGRlbmR1bSA9ICdcXG5cXG5JdCBsb29rcyBsaWtlIHlvdSB3cm90ZSAnICsgaG9va05hbWUgKyAnKGFzeW5jICgpID0+IC4uLikgb3IgcmV0dXJuZWQgYSBQcm9taXNlLiAnICsgJ0luc3RlYWQsIHdyaXRlIHRoZSBhc3luYyBmdW5jdGlvbiBpbnNpZGUgeW91ciBlZmZlY3QgJyArICdhbmQgY2FsbCBpdCBpbW1lZGlhdGVseTpcXG5cXG4nICsgaG9va05hbWUgKyAnKCgpID0+IHtcXG4nICsgJyAgYXN5bmMgZnVuY3Rpb24gZmV0Y2hEYXRhKCkge1xcbicgKyAnICAgIC8vIFlvdSBjYW4gYXdhaXQgaGVyZVxcbicgKyAnICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgTXlBUEkuZ2V0RGF0YShzb21lSWQpO1xcbicgKyAnICAgIC8vIC4uLlxcbicgKyAnICB9XFxuJyArICcgIGZldGNoRGF0YSgpO1xcbicgKyBcIn0sIFtzb21lSWRdKTsgLy8gT3IgW10gaWYgZWZmZWN0IGRvZXNuJ3QgbmVlZCBwcm9wcyBvciBzdGF0ZVxcblxcblwiICsgJ0xlYXJuIG1vcmUgYWJvdXQgZGF0YSBmZXRjaGluZyB3aXRoIEhvb2tzOiBodHRwczovL3JlYWN0LmRldi9saW5rL2hvb2tzLWRhdGEtZmV0Y2hpbmcnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYWRkZW5kdW0gPSAnIFlvdSByZXR1cm5lZDogJyArIGRlc3Ryb3k7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGVycm9yKCclcyBtdXN0IG5vdCByZXR1cm4gYW55dGhpbmcgYmVzaWRlcyBhIGZ1bmN0aW9uLCAnICsgJ3doaWNoIGlzIHVzZWQgZm9yIGNsZWFuLXVwLiVzJywgaG9va05hbWUsIGFkZGVuZHVtKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZWZmZWN0ID0gZWZmZWN0Lm5leHQ7XG4gICAgfSB3aGlsZSAoZWZmZWN0ICE9PSBmaXJzdEVmZmVjdCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZUVmZmVjdER1cmF0aW9ucyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaykge1xuICBpZiAoZ2V0RXhlY3V0aW9uQ29udGV4dCgpICYgQ29tbWl0Q29udGV4dCkge1xuICAgIC8vIE9ubHkgUHJvZmlsZXJzIHdpdGggd29yayBpbiB0aGVpciBzdWJ0cmVlIHdpbGwgaGF2ZSBhbiBVcGRhdGUgZWZmZWN0IHNjaGVkdWxlZC5cbiAgICBpZiAoKGZpbmlzaGVkV29yay5mbGFncyAmIFVwZGF0ZSkgIT09IE5vRmxhZ3MkMSkge1xuICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgICAgIGNhc2UgUHJvZmlsZXI6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHBhc3NpdmVFZmZlY3REdXJhdGlvbiA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uO1xuICAgICAgICAgICAgdmFyIF9maW5pc2hlZFdvcmskbWVtb2l6ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLFxuICAgICAgICAgICAgICAgIGlkID0gX2ZpbmlzaGVkV29yayRtZW1vaXplLmlkLFxuICAgICAgICAgICAgICAgIG9uUG9zdENvbW1pdCA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZS5vblBvc3RDb21taXQ7IC8vIFRoaXMgdmFsdWUgd2lsbCBzdGlsbCByZWZsZWN0IHRoZSBwcmV2aW91cyBjb21taXQgcGhhc2UuXG4gICAgICAgICAgICAvLyBJdCBkb2VzIG5vdCBnZXQgcmVzZXQgdW50aWwgdGhlIHN0YXJ0IG9mIHRoZSBuZXh0IGNvbW1pdCBwaGFzZS5cblxuICAgICAgICAgICAgdmFyIGNvbW1pdFRpbWUgPSBnZXRDb21taXRUaW1lKCk7XG4gICAgICAgICAgICB2YXIgcGhhc2UgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlID09PSBudWxsID8gJ21vdW50JyA6ICd1cGRhdGUnO1xuXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmIChpc0N1cnJlbnRVcGRhdGVOZXN0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHBoYXNlID0gJ25lc3RlZC11cGRhdGUnO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb25Qb3N0Q29tbWl0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgIG9uUG9zdENvbW1pdChpZCwgcGhhc2UsIHBhc3NpdmVFZmZlY3REdXJhdGlvbiwgY29tbWl0VGltZSk7XG4gICAgICAgICAgICB9IC8vIEJ1YmJsZSB0aW1lcyB0byB0aGUgbmV4dCBuZWFyZXN0IGFuY2VzdG9yIFByb2ZpbGVyLlxuICAgICAgICAgICAgLy8gQWZ0ZXIgd2UgcHJvY2VzcyB0aGF0IFByb2ZpbGVyLCB3ZSdsbCBidWJibGUgZnVydGhlciB1cC5cblxuXG4gICAgICAgICAgICB2YXIgcGFyZW50RmliZXIgPSBmaW5pc2hlZFdvcmsucmV0dXJuO1xuXG4gICAgICAgICAgICBvdXRlcjogd2hpbGUgKHBhcmVudEZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHN3aXRjaCAocGFyZW50RmliZXIudGFnKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICAgICAgICAgIHZhciByb290ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICAgICAgcm9vdC5wYXNzaXZlRWZmZWN0RHVyYXRpb24gKz0gcGFzc2l2ZUVmZmVjdER1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG5cbiAgICAgICAgICAgICAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudFN0YXRlTm9kZSA9IHBhcmVudEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICAgICAgICAgIHBhcmVudFN0YXRlTm9kZS5wYXNzaXZlRWZmZWN0RHVyYXRpb24gKz0gcGFzc2l2ZUVmZmVjdER1cmF0aW9uO1xuICAgICAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBwYXJlbnRGaWJlciA9IHBhcmVudEZpYmVyLnJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRIb29rTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmssIGhvb2tGbGFncykge1xuICAvLyBBdCB0aGlzIHBvaW50IGxheW91dCBlZmZlY3RzIGhhdmUgYWxyZWFkeSBiZWVuIGRlc3Ryb3llZCAoZHVyaW5nIG11dGF0aW9uIHBoYXNlKS5cbiAgLy8gVGhpcyBpcyBkb25lIHRvIHByZXZlbnQgc2libGluZyBjb21wb25lbnQgZWZmZWN0cyBmcm9tIGludGVyZmVyaW5nIHdpdGggZWFjaCBvdGhlcixcbiAgLy8gZS5nLiBhIGRlc3Ryb3kgZnVuY3Rpb24gaW4gb25lIGNvbXBvbmVudCBzaG91bGQgbmV2ZXIgb3ZlcnJpZGUgYSByZWYgc2V0XG4gIC8vIGJ5IGEgY3JlYXRlIGZ1bmN0aW9uIGluIGFub3RoZXIgY29tcG9uZW50IGR1cmluZyB0aGUgc2FtZSBjb21taXQuXG4gIGlmIChzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaykpIHtcbiAgICB0cnkge1xuICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChob29rRmxhZ3MsIGZpbmlzaGVkV29yayk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgIH1cblxuICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQoaG9va0ZsYWdzLCBmaW5pc2hlZFdvcmspO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0Q2xhc3NMYXlvdXRMaWZlY3ljbGVzKGZpbmlzaGVkV29yaywgY3VycmVudCkge1xuICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgLy8gV2UgY291bGQgdXBkYXRlIGluc3RhbmNlIHByb3BzIGFuZCBzdGF0ZSBoZXJlLFxuICAgIC8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuICAgIC8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHdlIGltcGxlbWVudCByZXN1bWluZy5cbiAgICB7XG4gICAgICBpZiAoIWZpbmlzaGVkV29yay50eXBlLmRlZmF1bHRQcm9wcyAmJiAhKCdyZWYnIGluIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKSAmJiAhZGlkV2FybkFib3V0UmVhc3NpZ25pbmdQcm9wcykge1xuICAgICAgICBpZiAoaW5zdGFuY2UucHJvcHMgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKSB7XG4gICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHByb3BzIHRvIG1hdGNoIG1lbW9pemVkIHByb3BzIGJlZm9yZSAnICsgJ2NvbXBvbmVudERpZE1vdW50LiAnICsgJ1RoaXMgbWlnaHQgZWl0aGVyIGJlIGJlY2F1c2Ugb2YgYSBidWcgaW4gUmVhY3QsIG9yIGJlY2F1c2UgJyArICdhIGNvbXBvbmVudCByZWFzc2lnbnMgaXRzIG93biBgdGhpcy5wcm9wc2AuICcgKyAnUGxlYXNlIGZpbGUgYW4gaXNzdWUuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspIHx8ICdpbnN0YW5jZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluc3RhbmNlLnN0YXRlICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZSkge1xuICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBzdGF0ZSB0byBtYXRjaCBtZW1vaXplZCBzdGF0ZSBiZWZvcmUgJyArICdjb21wb25lbnREaWRNb3VudC4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaykpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkTW91bnQoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgfVxuXG4gICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO1xuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBwcmV2UHJvcHMgPSByZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyhmaW5pc2hlZFdvcmsudHlwZSwgY3VycmVudC5tZW1vaXplZFByb3BzKTtcbiAgICB2YXIgcHJldlN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlOyAvLyBXZSBjb3VsZCB1cGRhdGUgaW5zdGFuY2UgcHJvcHMgYW5kIHN0YXRlIGhlcmUsXG4gICAgLy8gYnV0IGluc3RlYWQgd2UgcmVseSBvbiB0aGVtIGJlaW5nIHNldCBkdXJpbmcgbGFzdCByZW5kZXIuXG4gICAgLy8gVE9ETzogcmV2aXNpdCB0aGlzIHdoZW4gd2UgaW1wbGVtZW50IHJlc3VtaW5nLlxuXG4gICAge1xuICAgICAgaWYgKCFmaW5pc2hlZFdvcmsudHlwZS5kZWZhdWx0UHJvcHMgJiYgISgncmVmJyBpbiBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykgJiYgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJyArICdjb21wb25lbnREaWRVcGRhdGUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzaG91bGRQcm9maWxlKGZpbmlzaGVkV29yaykpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlLCBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgIH1cblxuICAgICAgcmVjb3JkTGF5b3V0RWZmZWN0RHVyYXRpb24oZmluaXNoZWRXb3JrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaW5zdGFuY2UuY29tcG9uZW50RGlkVXBkYXRlKHByZXZQcm9wcywgcHJldlN0YXRlLCBpbnN0YW5jZS5fX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0Q2xhc3NDYWxsYmFja3MoZmluaXNoZWRXb3JrKSB7XG4gIC8vIFRPRE86IEkgdGhpbmsgdGhpcyBpcyBub3cgYWx3YXlzIG5vbi1udWxsIGJ5IHRoZSB0aW1lIGl0IHJlYWNoZXMgdGhlXG4gIC8vIGNvbW1pdCBwaGFzZS4gQ29uc2lkZXIgcmVtb3ZpbmcgdGhlIHR5cGUgY2hlY2suXG4gIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcblxuICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gICAge1xuICAgICAgaWYgKCFmaW5pc2hlZFdvcmsudHlwZS5kZWZhdWx0UHJvcHMgJiYgISgncmVmJyBpbiBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykgJiYgIWRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMpIHtcbiAgICAgICAgaWYgKGluc3RhbmNlLnByb3BzICE9PSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcykge1xuICAgICAgICAgIGVycm9yKCdFeHBlY3RlZCAlcyBwcm9wcyB0byBtYXRjaCBtZW1vaXplZCBwcm9wcyBiZWZvcmUgJyArICdwcm9jZXNzaW5nIHRoZSB1cGRhdGUgcXVldWUuICcgKyAnVGhpcyBtaWdodCBlaXRoZXIgYmUgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBSZWFjdCwgb3IgYmVjYXVzZSAnICsgJ2EgY29tcG9uZW50IHJlYXNzaWducyBpdHMgb3duIGB0aGlzLnByb3BzYC4gJyArICdQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpbmlzaGVkV29yaykgfHwgJ2luc3RhbmNlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5zdGFuY2Uuc3RhdGUgIT09IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgZXJyb3IoJ0V4cGVjdGVkICVzIHN0YXRlIHRvIG1hdGNoIG1lbW9pemVkIHN0YXRlIGJlZm9yZSAnICsgJ3Byb2Nlc3NpbmcgdGhlIHVwZGF0ZSBxdWV1ZS4gJyArICdUaGlzIG1pZ2h0IGVpdGhlciBiZSBiZWNhdXNlIG9mIGEgYnVnIGluIFJlYWN0LCBvciBiZWNhdXNlICcgKyAnYSBjb21wb25lbnQgcmVhc3NpZ25zIGl0cyBvd24gYHRoaXMuc3RhdGVgLiAnICsgJ1BsZWFzZSBmaWxlIGFuIGlzc3VlLicsIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmluaXNoZWRXb3JrKSB8fCAnaW5zdGFuY2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gV2UgY291bGQgdXBkYXRlIGluc3RhbmNlIHByb3BzIGFuZCBzdGF0ZSBoZXJlLFxuICAgIC8vIGJ1dCBpbnN0ZWFkIHdlIHJlbHkgb24gdGhlbSBiZWluZyBzZXQgZHVyaW5nIGxhc3QgcmVuZGVyLlxuICAgIC8vIFRPRE86IHJldmlzaXQgdGhpcyB3aGVuIHdlIGltcGxlbWVudCByZXN1bWluZy5cblxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbW1pdENhbGxiYWNrcyh1cGRhdGVRdWV1ZSwgaW5zdGFuY2UpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0SG9zdENvbXBvbmVudE1vdW50KGZpbmlzaGVkV29yaykge1xuICB2YXIgdHlwZSA9IGZpbmlzaGVkV29yay50eXBlO1xuICB2YXIgcHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcztcbiAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICB0cnkge1xuICAgIGNvbW1pdE1vdW50KGluc3RhbmNlLCB0eXBlLCBwcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQcm9maWxlclVwZGF0ZShmaW5pc2hlZFdvcmssIGN1cnJlbnQpIHtcbiAgaWYgKGdldEV4ZWN1dGlvbkNvbnRleHQoKSAmIENvbW1pdENvbnRleHQpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIF9maW5pc2hlZFdvcmskbWVtb2l6ZTIgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyxcbiAgICAgICAgICBvbkNvbW1pdCA9IF9maW5pc2hlZFdvcmskbWVtb2l6ZTIub25Db21taXQsXG4gICAgICAgICAgb25SZW5kZXIgPSBfZmluaXNoZWRXb3JrJG1lbW9pemUyLm9uUmVuZGVyO1xuICAgICAgdmFyIGVmZmVjdER1cmF0aW9uID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZS5lZmZlY3REdXJhdGlvbjtcbiAgICAgIHZhciBjb21taXRUaW1lID0gZ2V0Q29tbWl0VGltZSgpO1xuICAgICAgdmFyIHBoYXNlID0gY3VycmVudCA9PT0gbnVsbCA/ICdtb3VudCcgOiAndXBkYXRlJztcblxuICAgICAgaWYgKGVuYWJsZVByb2ZpbGVyTmVzdGVkVXBkYXRlUGhhc2UpIHtcbiAgICAgICAgaWYgKGlzQ3VycmVudFVwZGF0ZU5lc3RlZCgpKSB7XG4gICAgICAgICAgcGhhc2UgPSAnbmVzdGVkLXVwZGF0ZSc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBvblJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBvblJlbmRlcihmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcy5pZCwgcGhhc2UsIGZpbmlzaGVkV29yay5hY3R1YWxEdXJhdGlvbiwgZmluaXNoZWRXb3JrLnRyZWVCYXNlRHVyYXRpb24sIGZpbmlzaGVkV29yay5hY3R1YWxTdGFydFRpbWUsIGNvbW1pdFRpbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5hYmxlUHJvZmlsZXJDb21taXRIb29rcykge1xuICAgICAgICBpZiAodHlwZW9mIG9uQ29tbWl0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgb25Db21taXQoZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHMuaWQsIHBoYXNlLCBlZmZlY3REdXJhdGlvbiwgY29tbWl0VGltZSk7XG4gICAgICAgIH0gLy8gU2NoZWR1bGUgYSBwYXNzaXZlIGVmZmVjdCBmb3IgdGhpcyBQcm9maWxlciB0byBjYWxsIG9uUG9zdENvbW1pdCBob29rcy5cbiAgICAgICAgLy8gVGhpcyBlZmZlY3Qgc2hvdWxkIGJlIHNjaGVkdWxlZCBldmVuIGlmIHRoZXJlIGlzIG5vIG9uUG9zdENvbW1pdCBjYWxsYmFjayBmb3IgdGhpcyBQcm9maWxlcixcbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgZWZmZWN0IGlzIGFsc28gd2hlcmUgdGltZXMgYnViYmxlIHRvIHBhcmVudCBQcm9maWxlcnMuXG5cblxuICAgICAgICBlbnF1ZXVlUGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdChmaW5pc2hlZFdvcmspOyAvLyBQcm9wYWdhdGUgbGF5b3V0IGVmZmVjdCBkdXJhdGlvbnMgdG8gdGhlIG5leHQgbmVhcmVzdCBQcm9maWxlciBhbmNlc3Rvci5cbiAgICAgICAgLy8gRG8gbm90IHJlc2V0IHRoZXNlIHZhbHVlcyB1bnRpbCB0aGUgbmV4dCByZW5kZXIgc28gRGV2VG9vbHMgaGFzIGEgY2hhbmNlIHRvIHJlYWQgdGhlbSBmaXJzdC5cblxuICAgICAgICB2YXIgcGFyZW50RmliZXIgPSBmaW5pc2hlZFdvcmsucmV0dXJuO1xuXG4gICAgICAgIG91dGVyOiB3aGlsZSAocGFyZW50RmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgICBzd2l0Y2ggKHBhcmVudEZpYmVyLnRhZykge1xuICAgICAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICAgICAgdmFyIHJvb3QgPSBwYXJlbnRGaWJlci5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgIHJvb3QuZWZmZWN0RHVyYXRpb24gKz0gZWZmZWN0RHVyYXRpb247XG4gICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuXG4gICAgICAgICAgICBjYXNlIFByb2ZpbGVyOlxuICAgICAgICAgICAgICB2YXIgcGFyZW50U3RhdGVOb2RlID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICBwYXJlbnRTdGF0ZU5vZGUuZWZmZWN0RHVyYXRpb24gKz0gZWZmZWN0RHVyYXRpb247XG4gICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHBhcmVudEZpYmVyID0gcGFyZW50RmliZXIucmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRMYXlvdXRFZmZlY3RPbkZpYmVyKGZpbmlzaGVkUm9vdCwgY3VycmVudCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcykge1xuICAvLyBXaGVuIHVwZGF0aW5nIHRoaXMgZnVuY3Rpb24sIGFsc28gdXBkYXRlIHJlYXBwZWFyTGF5b3V0RWZmZWN0cywgd2hpY2ggZG9lc1xuICAvLyBtb3N0IG9mIHRoZSBzYW1lIHRoaW5ncyB3aGVuIGFuIG9mZnNjcmVlbiB0cmVlIGdvZXMgZnJvbSBoaWRkZW4gLT4gdmlzaWJsZS5cbiAgdmFyIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuXG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIGNvbW1pdEhvb2tMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaywgTGF5b3V0IHwgSGFzRWZmZWN0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIGNvbW1pdENsYXNzTGF5b3V0TGlmZWN5Y2xlcyhmaW5pc2hlZFdvcmssIGN1cnJlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZsYWdzICYgQ2FsbGJhY2spIHtcbiAgICAgICAgICBjb21taXRDbGFzc0NhbGxiYWNrcyhmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZsYWdzICYgUmVmKSB7XG4gICAgICAgICAgc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcblxuICAgICAgICBpZiAoZmxhZ3MgJiBDYWxsYmFjaykge1xuICAgICAgICAgIC8vIFRPRE86IEkgdGhpbmsgdGhpcyBpcyBub3cgYWx3YXlzIG5vbi1udWxsIGJ5IHRoZSB0aW1lIGl0IHJlYWNoZXMgdGhlXG4gICAgICAgICAgLy8gY29tbWl0IHBoYXNlLiBDb25zaWRlciByZW1vdmluZyB0aGUgdHlwZSBjaGVjay5cbiAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG5cbiAgICAgICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChmaW5pc2hlZFdvcmsuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgc3dpdGNoIChmaW5pc2hlZFdvcmsuY2hpbGQudGFnKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgICAgICAgICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICAgICAgICAgIGluc3RhbmNlID0gZ2V0UHVibGljSW5zdGFuY2UoZmluaXNoZWRXb3JrLmNoaWxkLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5jaGlsZC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBjb21taXRDYWxsYmFja3ModXBkYXRlUXVldWUsIGluc3RhbmNlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0SG9pc3RhYmxlOlxuICAgICAge1xuICAgICAgICBpZiAoc3VwcG9ydHNSZXNvdXJjZXMpIHtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG5cbiAgICAgICAgICBpZiAoZmxhZ3MgJiBSZWYpIHtcbiAgICAgICAgICAgIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RTaW5nbGV0b246XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7IC8vIFJlbmRlcmVycyBtYXkgc2NoZWR1bGUgd29yayB0byBiZSBkb25lIGFmdGVyIGhvc3QgY29tcG9uZW50cyBhcmUgbW91bnRlZFxuICAgICAgICAvLyAoZWcgRE9NIHJlbmRlcmVyIG1heSBzY2hlZHVsZSBhdXRvLWZvY3VzIGZvciBpbnB1dHMgYW5kIGZvcm0gY29udHJvbHMpLlxuICAgICAgICAvLyBUaGVzZSBlZmZlY3RzIHNob3VsZCBvbmx5IGJlIGNvbW1pdHRlZCB3aGVuIGNvbXBvbmVudHMgYXJlIGZpcnN0IG1vdW50ZWQsXG4gICAgICAgIC8vIGFrYSB3aGVuIHRoZXJlIGlzIG5vIGN1cnJlbnQvYWx0ZXJuYXRlLlxuXG4gICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsICYmIGZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgY29tbWl0SG9zdENvbXBvbmVudE1vdW50KGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmxhZ3MgJiBSZWYpIHtcbiAgICAgICAgICBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBQcm9maWxlcjpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspOyAvLyBUT0RPOiBTaG91bGQgdGhpcyBmaXJlIGluc2lkZSBhbiBvZmZzY3JlZW4gdHJlZT8gT3Igc2hvdWxkIGl0IHdhaXQgdG9cbiAgICAgICAgLy8gZmlyZSB3aGVuIHRoZSB0cmVlIGJlY29tZXMgdmlzaWJsZSBhZ2Fpbi5cblxuICAgICAgICBpZiAoZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICBjb21taXRQcm9maWxlclVwZGF0ZShmaW5pc2hlZFdvcmssIGN1cnJlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgY29tbWl0U3VzcGVuc2VIeWRyYXRpb25DYWxsYmFja3MoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGlzTW9kZXJuUm9vdCA9IGRpc2FibGVMZWdhY3lNb2RlIDtcblxuICAgICAgICBpZiAoaXNNb2Rlcm5Sb290KSB7XG4gICAgICAgICAgdmFyIGlzSGlkZGVuID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG4gICAgICAgICAgdmFyIG5ld09mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IGlzSGlkZGVuIHx8IG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbjtcblxuICAgICAgICAgIGlmIChuZXdPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4pIDsgZWxzZSB7XG4gICAgICAgICAgICAvLyBUaGUgT2Zmc2NyZWVuIHRyZWUgaXMgdmlzaWJsZS5cbiAgICAgICAgICAgIHZhciB3YXNIaWRkZW4gPSBjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgICAgIHZhciBuZXdPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gd2FzSGlkZGVuIHx8IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICAgICAgICB2YXIgcHJldk9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiA9IG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbjtcbiAgICAgICAgICAgIHZhciBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW4gPSBuZXdPZmZzY3JlZW5TdWJ0cmVlSXNIaWRkZW47XG4gICAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gbmV3T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcblxuICAgICAgICAgICAgaWYgKG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gJiYgIXByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKSB7XG4gICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIHJvb3Qgb2YgYSByZWFwcGVhcmluZyBib3VuZGFyeS4gQXMgd2UgY29udGludWVcbiAgICAgICAgICAgICAgLy8gdHJhdmVyc2luZyB0aGUgbGF5b3V0IGVmZmVjdHMsIHdlIG11c3QgYWxzbyByZS1tb3VudCBsYXlvdXRcbiAgICAgICAgICAgICAgLy8gZWZmZWN0cyB0aGF0IHdlcmUgdW5tb3VudGVkIHdoZW4gdGhlIE9mZnNjcmVlbiBzdWJ0cmVlIHdhc1xuICAgICAgICAgICAgICAvLyBoaWRkZW4uIFNvIHRoaXMgaXMgYSBzdXBlcnNldCBvZiB0aGUgbm9ybWFsIGNvbW1pdExheW91dEVmZmVjdHMuXG4gICAgICAgICAgICAgIHZhciBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzID0gKGZpbmlzaGVkV29yay5zdWJ0cmVlRmxhZ3MgJiBMYXlvdXRNYXNrKSAhPT0gTm9GbGFncyQxO1xuICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gcHJldk9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbjtcbiAgICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZsYWdzICYgUmVmKSB7XG4gICAgICAgICAgdmFyIHByb3BzID0gZmluaXNoZWRXb3JrLm1lbW9pemVkUHJvcHM7XG5cbiAgICAgICAgICBpZiAocHJvcHMubW9kZSA9PT0gJ21hbnVhbCcpIHtcbiAgICAgICAgICAgIHNhZmVseUF0dGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaGlkZU9yVW5oaWRlQWxsQ2hpbGRyZW4oZmluaXNoZWRXb3JrLCBpc0hpZGRlbikge1xuICAvLyBPbmx5IGhpZGUgb3IgdW5oaWRlIHRoZSB0b3AtbW9zdCBob3N0IG5vZGVzLlxuICB2YXIgaG9zdFN1YnRyZWVSb290ID0gbnVsbDtcblxuICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGluc2VydGVkIGJ1dCB3ZSBuZWVkIHRvIHJlY3Vyc2UgZG93biBpdHNcbiAgICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG4gICAgdmFyIG5vZGUgPSBmaW5pc2hlZFdvcms7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKG5vZGUudGFnID09PSBIb3N0Q29tcG9uZW50IHx8IChzdXBwb3J0c1Jlc291cmNlcyA/IG5vZGUudGFnID09PSBIb3N0SG9pc3RhYmxlIDogZmFsc2UpIHx8IChzdXBwb3J0c1NpbmdsZXRvbnMgPyBub2RlLnRhZyA9PT0gSG9zdFNpbmdsZXRvbiA6IGZhbHNlKSkge1xuICAgICAgICBpZiAoaG9zdFN1YnRyZWVSb290ID09PSBudWxsKSB7XG4gICAgICAgICAgaG9zdFN1YnRyZWVSb290ID0gbm9kZTtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgICAgICAgICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICAgICAgICAgIGhpZGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB1bmhpZGVJbnN0YW5jZShub2RlLnN0YXRlTm9kZSwgbm9kZS5tZW1vaXplZFByb3BzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5vZGUudGFnID09PSBIb3N0VGV4dCkge1xuICAgICAgICBpZiAoaG9zdFN1YnRyZWVSb290ID09PSBudWxsKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBfaW5zdGFuY2UgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgICAgICAgICAgaWYgKGlzSGlkZGVuKSB7XG4gICAgICAgICAgICAgIGhpZGVUZXh0SW5zdGFuY2UoX2luc3RhbmNlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHVuaGlkZVRleHRJbnN0YW5jZShfaW5zdGFuY2UsIG5vZGUubWVtb2l6ZWRQcm9wcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICgobm9kZS50YWcgPT09IE9mZnNjcmVlbkNvbXBvbmVudCB8fCBub2RlLnRhZyA9PT0gTGVnYWN5SGlkZGVuQ29tcG9uZW50KSAmJiBub2RlLm1lbW9pemVkU3RhdGUgIT09IG51bGwgJiYgbm9kZSAhPT0gZmluaXNoZWRXb3JrKSA7IGVsc2UgaWYgKG5vZGUuY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgbm9kZS5jaGlsZC5yZXR1cm4gPSBub2RlO1xuICAgICAgICBub2RlID0gbm9kZS5jaGlsZDtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlID09PSBmaW5pc2hlZFdvcmspIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCB8fCBub2RlLnJldHVybiA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhvc3RTdWJ0cmVlUm9vdCA9PT0gbm9kZSkge1xuICAgICAgICAgIGhvc3RTdWJ0cmVlUm9vdCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChob3N0U3VidHJlZVJvb3QgPT09IG5vZGUpIHtcbiAgICAgICAgaG9zdFN1YnRyZWVSb290ID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgICAgbm9kZSA9IG5vZGUuc2libGluZztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0QXR0YWNoUmVmKGZpbmlzaGVkV29yaykge1xuICB2YXIgcmVmID0gZmluaXNoZWRXb3JrLnJlZjtcblxuICBpZiAocmVmICE9PSBudWxsKSB7XG4gICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICB2YXIgaW5zdGFuY2VUb1VzZTtcblxuICAgIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgICAgY2FzZSBIb3N0SG9pc3RhYmxlOlxuICAgICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICBpbnN0YW5jZVRvVXNlID0gZ2V0UHVibGljSW5zdGFuY2UoaW5zdGFuY2UpO1xuICAgICAgICBicmVhaztcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaW5zdGFuY2VUb1VzZSA9IGluc3RhbmNlO1xuICAgIH0gLy8gTW92ZWQgb3V0c2lkZSB0byBlbnN1cmUgRENFIHdvcmtzIHdpdGggdGhpcyBmbGFnXG5cbiAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKHNob3VsZFByb2ZpbGUoZmluaXNoZWRXb3JrKSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICBmaW5pc2hlZFdvcmsucmVmQ2xlYW51cCA9IHJlZihpbnN0YW5jZVRvVXNlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICByZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaW5pc2hlZFdvcmsucmVmQ2xlYW51cCA9IHJlZihpbnN0YW5jZVRvVXNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICAvLyBUT0RPOiBXZSBzaG91bGQgbW92ZSB0aGVzZSB3YXJuaW5ncyB0byBoYXBwZW4gZHVyaW5nIHRoZSByZW5kZXJcbiAgICAgICAgLy8gcGhhc2UgKG1hcmtSZWYpLlxuICAgICAgICBpZiAodHlwZW9mIHJlZiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBlcnJvcignU3RyaW5nIHJlZnMgYXJlIG5vIGxvbmdlciBzdXBwb3J0ZWQuJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXJlZi5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudCcpKSB7XG4gICAgICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgcmVmIG9iamVjdCBwcm92aWRlZCBmb3IgJXMuICcgKyAnVXNlIGVpdGhlciBhIHJlZi1zZXR0ZXIgZnVuY3Rpb24gb3IgUmVhY3QuY3JlYXRlUmVmKCkuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaW5pc2hlZFdvcmspKTtcbiAgICAgICAgfVxuICAgICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIHVuYWJsZSB0byBuYXJyb3cgdHlwZSB0byB0aGUgbm9uLWZ1bmN0aW9uIGNhc2VcblxuXG4gICAgICByZWYuY3VycmVudCA9IGluc3RhbmNlVG9Vc2U7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRldGFjaEZpYmVyTXV0YXRpb24oZmliZXIpIHtcbiAgLy8gQ3V0IG9mZiB0aGUgcmV0dXJuIHBvaW50ZXIgdG8gZGlzY29ubmVjdCBpdCBmcm9tIHRoZSB0cmVlLlxuICAvLyBUaGlzIGVuYWJsZXMgdXMgdG8gZGV0ZWN0IGFuZCB3YXJuIGFnYWluc3Qgc3RhdGUgdXBkYXRlcyBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LlxuICAvLyBJdCBhbHNvIHByZXZlbnRzIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIGZyb20gd2l0aGluIGRpc2Nvbm5lY3RlZCBjb21wb25lbnRzLlxuICAvL1xuICAvLyBJZGVhbGx5LCB3ZSBzaG91bGQgYWxzbyBjbGVhciB0aGUgY2hpbGQgcG9pbnRlciBvZiB0aGUgcGFyZW50IGFsdGVybmF0ZSB0byBsZXQgdGhpc1xuICAvLyBnZXQgR0M6ZWQgYnV0IHdlIGRvbid0IGtub3cgd2hpY2ggZm9yIHN1cmUgd2hpY2ggcGFyZW50IGlzIHRoZSBjdXJyZW50XG4gIC8vIG9uZSBzbyB3ZSdsbCBzZXR0bGUgZm9yIEdDOmluZyB0aGUgc3VidHJlZSBvZiB0aGlzIGNoaWxkLlxuICAvLyBUaGlzIGNoaWxkIGl0c2VsZiB3aWxsIGJlIEdDOmVkIHdoZW4gdGhlIHBhcmVudCB1cGRhdGVzIHRoZSBuZXh0IHRpbWUuXG4gIC8vXG4gIC8vIE5vdGUgdGhhdCB3ZSBjYW4ndCBjbGVhciBjaGlsZCBvciBzaWJsaW5nIHBvaW50ZXJzIHlldC5cbiAgLy8gVGhleSdyZSBuZWVkZWQgZm9yIHBhc3NpdmUgZWZmZWN0cyBhbmQgZm9yIGZpbmRET01Ob2RlLlxuICAvLyBXZSBkZWZlciB0aG9zZSBmaWVsZHMsIGFuZCBhbGwgb3RoZXIgY2xlYW51cCwgdG8gdGhlIHBhc3NpdmUgcGhhc2UgKHNlZSBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cykuXG4gIC8vXG4gIC8vIERvbid0IHJlc2V0IHRoZSBhbHRlcm5hdGUgeWV0LCBlaXRoZXIuIFdlIG5lZWQgdGhhdCBzbyB3ZSBjYW4gZGV0YWNoIHRoZVxuICAvLyBhbHRlcm5hdGUncyBmaWVsZHMgaW4gdGhlIHBhc3NpdmUgcGhhc2UuIENsZWFyaW5nIHRoZSByZXR1cm4gcG9pbnRlciBpc1xuICAvLyBzdWZmaWNpZW50IGZvciBmaW5kRE9NTm9kZSBzZW1hbnRpY3MuXG4gIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKGFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgIGFsdGVybmF0ZS5yZXR1cm4gPSBudWxsO1xuICB9XG5cbiAgZmliZXIucmV0dXJuID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZGV0YWNoRmliZXJBZnRlckVmZmVjdHMoZmliZXIpIHtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoYWx0ZXJuYXRlICE9PSBudWxsKSB7XG4gICAgZmliZXIuYWx0ZXJuYXRlID0gbnVsbDtcbiAgICBkZXRhY2hGaWJlckFmdGVyRWZmZWN0cyhhbHRlcm5hdGUpO1xuICB9IC8vIENsZWFyIGN5Y2xpY2FsIEZpYmVyIGZpZWxkcy4gVGhpcyBsZXZlbCBhbG9uZSBpcyBkZXNpZ25lZCB0byByb3VnaGx5XG4gIC8vIGFwcHJveGltYXRlIHRoZSBwbGFubmVkIEZpYmVyIHJlZmFjdG9yLiBJbiB0aGF0IHdvcmxkLCBgc2V0U3RhdGVgIHdpbGwgYmVcbiAgLy8gYm91bmQgdG8gYSBzcGVjaWFsIFwiaW5zdGFuY2VcIiBvYmplY3QgaW5zdGVhZCBvZiBhIEZpYmVyLiBUaGUgSW5zdGFuY2VcbiAgLy8gb2JqZWN0IHdpbGwgbm90IGhhdmUgYW55IG9mIHRoZXNlIGZpZWxkcy4gSXQgd2lsbCBvbmx5IGJlIGNvbm5lY3RlZCB0b1xuICAvLyB0aGUgZmliZXIgdHJlZSB2aWEgYSBzaW5nbGUgbGluayBhdCB0aGUgcm9vdC4gU28gaWYgdGhpcyBsZXZlbCBhbG9uZSBpc1xuICAvLyBzdWZmaWNpZW50IHRvIGZpeCBtZW1vcnkgaXNzdWVzLCB0aGF0IGJvZGVzIHdlbGwgZm9yIG91ciBwbGFucy5cblxuXG4gIGZpYmVyLmNoaWxkID0gbnVsbDtcbiAgZmliZXIuZGVsZXRpb25zID0gbnVsbDtcbiAgZmliZXIuc2libGluZyA9IG51bGw7IC8vIFRoZSBgc3RhdGVOb2RlYCBpcyBjeWNsaWNhbCBiZWNhdXNlIG9uIGhvc3Qgbm9kZXMgaXQgcG9pbnRzIHRvIHRoZSBob3N0XG4gIC8vIHRyZWUsIHdoaWNoIGhhcyBpdHMgb3duIHBvaW50ZXJzIHRvIGNoaWxkcmVuLCBwYXJlbnRzLCBhbmQgc2libGluZ3MuXG4gIC8vIFRoZSBvdGhlciBob3N0IG5vZGVzIGFsc28gcG9pbnQgYmFjayB0byBmaWJlcnMsIHNvIHdlIHNob3VsZCBkZXRhY2ggdGhhdFxuICAvLyBvbmUsIHRvby5cblxuICBpZiAoZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50KSB7XG4gICAgdmFyIGhvc3RJbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcblxuICAgIGlmIChob3N0SW5zdGFuY2UgIT09IG51bGwpIHtcbiAgICAgIGRldGFjaERlbGV0ZWRJbnN0YW5jZShob3N0SW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuXG4gIGZpYmVyLnN0YXRlTm9kZSA9IG51bGw7XG5cbiAge1xuICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gbnVsbDtcbiAgfSAvLyBUaGVvcmV0aWNhbGx5LCBub3RoaW5nIGluIGhlcmUgc2hvdWxkIGJlIG5lY2Vzc2FyeSwgYmVjYXVzZSB3ZSBhbHJlYWR5XG4gIC8vIGRpc2Nvbm5lY3RlZCB0aGUgZmliZXIgZnJvbSB0aGUgdHJlZS4gU28gZXZlbiBpZiBzb21ldGhpbmcgbGVha3MgdGhpc1xuICAvLyBwYXJ0aWN1bGFyIGZpYmVyLCBpdCB3b24ndCBsZWFrIGFueXRoaW5nIGVsc2UuXG5cblxuICBmaWJlci5yZXR1cm4gPSBudWxsO1xuICBmaWJlci5kZXBlbmRlbmNpZXMgPSBudWxsO1xuICBmaWJlci5tZW1vaXplZFByb3BzID0gbnVsbDtcbiAgZmliZXIubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIGZpYmVyLnBlbmRpbmdQcm9wcyA9IG51bGw7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IG51bGw7IC8vIFRPRE86IE1vdmUgdG8gYGNvbW1pdFBhc3NpdmVVbm1vdW50SW5zaWRlRGVsZXRlZFRyZWVPbkZpYmVyYCBpbnN0ZWFkLlxuXG4gIGZpYmVyLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gZW1wdHlQb3J0YWxDb250YWluZXIoY3VycmVudCkge1xuICBpZiAoIXN1cHBvcnRzUGVyc2lzdGVuY2UpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgcG9ydGFsID0gY3VycmVudC5zdGF0ZU5vZGU7XG4gIHZhciBjb250YWluZXJJbmZvID0gcG9ydGFsLmNvbnRhaW5lckluZm87XG4gIHZhciBlbXB0eUNoaWxkU2V0ID0gY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQoKTtcbiAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuKGNvbnRhaW5lckluZm8sIGVtcHR5Q2hpbGRTZXQpO1xufVxuXG5mdW5jdGlvbiBnZXRIb3N0UGFyZW50RmliZXIoZmliZXIpIHtcbiAgdmFyIHBhcmVudCA9IGZpYmVyLnJldHVybjtcblxuICB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgaWYgKGlzSG9zdFBhcmVudChwYXJlbnQpKSB7XG4gICAgICByZXR1cm4gcGFyZW50O1xuICAgIH1cblxuICAgIHBhcmVudCA9IHBhcmVudC5yZXR1cm47XG4gIH1cblxuICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIGZpbmQgYSBob3N0IHBhcmVudC4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5IGEgYnVnICcgKyAnaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xufVxuXG5mdW5jdGlvbiBpc0hvc3RQYXJlbnQoZmliZXIpIHtcbiAgcmV0dXJuIGZpYmVyLnRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCBmaWJlci50YWcgPT09IEhvc3RSb290IHx8IChzdXBwb3J0c1Jlc291cmNlcyA/IGZpYmVyLnRhZyA9PT0gSG9zdEhvaXN0YWJsZSA6IGZhbHNlKSB8fCAoc3VwcG9ydHNTaW5nbGV0b25zID8gZmliZXIudGFnID09PSBIb3N0U2luZ2xldG9uIDogZmFsc2UpIHx8IGZpYmVyLnRhZyA9PT0gSG9zdFBvcnRhbDtcbn1cblxuZnVuY3Rpb24gZ2V0SG9zdFNpYmxpbmcoZmliZXIpIHtcbiAgLy8gV2UncmUgZ29pbmcgdG8gc2VhcmNoIGZvcndhcmQgaW50byB0aGUgdHJlZSB1bnRpbCB3ZSBmaW5kIGEgc2libGluZyBob3N0XG4gIC8vIG5vZGUuIFVuZm9ydHVuYXRlbHksIGlmIG11bHRpcGxlIGluc2VydGlvbnMgYXJlIGRvbmUgaW4gYSByb3cgd2UgaGF2ZSB0b1xuICAvLyBzZWFyY2ggcGFzdCB0aGVtLiBUaGlzIGxlYWRzIHRvIGV4cG9uZW50aWFsIHNlYXJjaCBmb3IgdGhlIG5leHQgc2libGluZy5cbiAgLy8gVE9ETzogRmluZCBhIG1vcmUgZWZmaWNpZW50IHdheSB0byBkbyB0aGlzLlxuICB2YXIgbm9kZSA9IGZpYmVyO1xuXG4gIHNpYmxpbmdzOiB3aGlsZSAodHJ1ZSkge1xuICAgIC8vIElmIHdlIGRpZG4ndCBmaW5kIGFueXRoaW5nLCBsZXQncyB0cnkgdGhlIG5leHQgc2libGluZy5cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgaXNIb3N0UGFyZW50KG5vZGUucmV0dXJuKSkge1xuICAgICAgICAvLyBJZiB3ZSBwb3Agb3V0IG9mIHRoZSByb290IG9yIGhpdCB0aGUgcGFyZW50IHRoZSBmaWJlciB3ZSBhcmUgdGhlXG4gICAgICAgIC8vIGxhc3Qgc2libGluZy5cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgfVxuXG4gICAgbm9kZS5zaWJsaW5nLnJldHVybiA9IG5vZGUucmV0dXJuO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG5cbiAgICB3aGlsZSAobm9kZS50YWcgIT09IEhvc3RDb21wb25lbnQgJiYgbm9kZS50YWcgIT09IEhvc3RUZXh0ICYmICghc3VwcG9ydHNTaW5nbGV0b25zID8gdHJ1ZSA6IG5vZGUudGFnICE9PSBIb3N0U2luZ2xldG9uKSAmJiBub2RlLnRhZyAhPT0gRGVoeWRyYXRlZEZyYWdtZW50KSB7XG4gICAgICAvLyBJZiBpdCBpcyBub3QgaG9zdCBub2RlIGFuZCwgd2UgbWlnaHQgaGF2ZSBhIGhvc3Qgbm9kZSBpbnNpZGUgaXQuXG4gICAgICAvLyBUcnkgdG8gc2VhcmNoIGRvd24gdW50aWwgd2UgZmluZCBvbmUuXG4gICAgICBpZiAobm9kZS5mbGFncyAmIFBsYWNlbWVudCkge1xuICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIGEgY2hpbGQsIHRyeSB0aGUgc2libGluZ3MgaW5zdGVhZC5cbiAgICAgICAgY29udGludWUgc2libGluZ3M7XG4gICAgICB9IC8vIElmIHdlIGRvbid0IGhhdmUgYSBjaGlsZCwgdHJ5IHRoZSBzaWJsaW5ncyBpbnN0ZWFkLlxuICAgICAgLy8gV2UgYWxzbyBza2lwIHBvcnRhbHMgYmVjYXVzZSB0aGV5IGFyZSBub3QgcGFydCBvZiB0aGlzIGhvc3QgdHJlZS5cblxuXG4gICAgICBpZiAobm9kZS5jaGlsZCA9PT0gbnVsbCB8fCBub2RlLnRhZyA9PT0gSG9zdFBvcnRhbCkge1xuICAgICAgICBjb250aW51ZSBzaWJsaW5ncztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGUuY2hpbGQucmV0dXJuID0gbm9kZTtcbiAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGQ7XG4gICAgICB9XG4gICAgfSAvLyBDaGVjayBpZiB0aGlzIGhvc3Qgbm9kZSBpcyBzdGFibGUgb3IgYWJvdXQgdG8gYmUgcGxhY2VkLlxuXG5cbiAgICBpZiAoIShub2RlLmZsYWdzICYgUGxhY2VtZW50KSkge1xuICAgICAgLy8gRm91bmQgaXQhXG4gICAgICByZXR1cm4gbm9kZS5zdGF0ZU5vZGU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBsYWNlbWVudChmaW5pc2hlZFdvcmspIHtcbiAgaWYgKCFzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKHN1cHBvcnRzU2luZ2xldG9ucykge1xuICAgIGlmIChmaW5pc2hlZFdvcmsudGFnID09PSBIb3N0U2luZ2xldG9uKSB7XG4gICAgICAvLyBTaW5nbGV0b25zIGFyZSBhbHJlYWR5IGluIHRoZSBIb3N0IGFuZCBkb24ndCBuZWVkIHRvIGJlIHBsYWNlZFxuICAgICAgLy8gU2luY2UgdGhleSBvcGVyYXRlIHNvbWV3aGF0IGxpa2UgUG9ydGFscyB0aG91Z2ggdGhlaXIgY2hpbGRyZW4gd2lsbFxuICAgICAgLy8gaGF2ZSBQbGFjZW1lbnQgYW5kIHdpbGwgZ2V0IHBsYWNlZCBpbnNpZGUgdGhlbVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSAvLyBSZWN1cnNpdmVseSBpbnNlcnQgYWxsIGhvc3Qgbm9kZXMgaW50byB0aGUgcGFyZW50LlxuXG5cbiAgdmFyIHBhcmVudEZpYmVyID0gZ2V0SG9zdFBhcmVudEZpYmVyKGZpbmlzaGVkV29yayk7XG5cbiAgc3dpdGNoIChwYXJlbnRGaWJlci50YWcpIHtcbiAgICBjYXNlIEhvc3RTaW5nbGV0b246XG4gICAgICB7XG4gICAgICAgIGlmIChzdXBwb3J0c1NpbmdsZXRvbnMpIHtcbiAgICAgICAgICB2YXIgcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuICAgICAgICAgIHZhciBiZWZvcmUgPSBnZXRIb3N0U2libGluZyhmaW5pc2hlZFdvcmspOyAvLyBXZSBvbmx5IGhhdmUgdGhlIHRvcCBGaWJlciB0aGF0IHdhcyBpbnNlcnRlZCBidXQgd2UgbmVlZCB0byByZWN1cnNlIGRvd24gaXRzXG4gICAgICAgICAgLy8gY2hpbGRyZW4gdG8gZmluZCBhbGwgdGhlIHRlcm1pbmFsIG5vZGVzLlxuXG4gICAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKGZpbmlzaGVkV29yaywgYmVmb3JlLCBwYXJlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBfcGFyZW50ID0gcGFyZW50RmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChwYXJlbnRGaWJlci5mbGFncyAmIENvbnRlbnRSZXNldCkge1xuICAgICAgICAgIC8vIFJlc2V0IHRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIHBhcmVudCBiZWZvcmUgZG9pbmcgYW55IGluc2VydGlvbnNcbiAgICAgICAgICByZXNldFRleHRDb250ZW50KF9wYXJlbnQpOyAvLyBDbGVhciBDb250ZW50UmVzZXQgZnJvbSB0aGUgZWZmZWN0IHRhZ1xuXG4gICAgICAgICAgcGFyZW50RmliZXIuZmxhZ3MgJj0gfkNvbnRlbnRSZXNldDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfYmVmb3JlID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTsgLy8gV2Ugb25seSBoYXZlIHRoZSB0b3AgRmliZXIgdGhhdCB3YXMgaW5zZXJ0ZWQgYnV0IHdlIG5lZWQgdG8gcmVjdXJzZSBkb3duIGl0c1xuICAgICAgICAvLyBjaGlsZHJlbiB0byBmaW5kIGFsbCB0aGUgdGVybWluYWwgbm9kZXMuXG5cblxuICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoZmluaXNoZWRXb3JrLCBfYmVmb3JlLCBfcGFyZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RSb290OlxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9wYXJlbnQyID0gcGFyZW50RmliZXIuc3RhdGVOb2RlLmNvbnRhaW5lckluZm87XG5cbiAgICAgICAgdmFyIF9iZWZvcmUyID0gZ2V0SG9zdFNpYmxpbmcoZmluaXNoZWRXb3JrKTtcblxuICAgICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKGZpbmlzaGVkV29yaywgX2JlZm9yZTIsIF9wYXJlbnQyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGhvc3QgcGFyZW50IGZpYmVyLiBUaGlzIGVycm9yIGlzIGxpa2VseSBjYXVzZWQgYnkgYSBidWcgJyArICdpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lcihub2RlLCBiZWZvcmUsIHBhcmVudCkge1xuICB2YXIgdGFnID0gbm9kZS50YWc7XG4gIHZhciBpc0hvc3QgPSB0YWcgPT09IEhvc3RDb21wb25lbnQgfHwgdGFnID09PSBIb3N0VGV4dDtcblxuICBpZiAoaXNIb3N0KSB7XG4gICAgdmFyIHN0YXRlTm9kZSA9IG5vZGUuc3RhdGVOb2RlO1xuXG4gICAgaWYgKGJlZm9yZSkge1xuICAgICAgaW5zZXJ0SW5Db250YWluZXJCZWZvcmUocGFyZW50LCBzdGF0ZU5vZGUsIGJlZm9yZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFwcGVuZENoaWxkVG9Db250YWluZXIocGFyZW50LCBzdGF0ZU5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0YWcgPT09IEhvc3RQb3J0YWwgfHwgKHN1cHBvcnRzU2luZ2xldG9ucyA/IHRhZyA9PT0gSG9zdFNpbmdsZXRvbiA6IGZhbHNlKSkgOyBlbHNlIHtcbiAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkO1xuXG4gICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGVJbnRvQ29udGFpbmVyKGNoaWxkLCBiZWZvcmUsIHBhcmVudCk7XG4gICAgICB2YXIgc2libGluZyA9IGNoaWxkLnNpYmxpbmc7XG5cbiAgICAgIHdoaWxlIChzaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIGluc2VydE9yQXBwZW5kUGxhY2VtZW50Tm9kZUludG9Db250YWluZXIoc2libGluZywgYmVmb3JlLCBwYXJlbnQpO1xuICAgICAgICBzaWJsaW5nID0gc2libGluZy5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUobm9kZSwgYmVmb3JlLCBwYXJlbnQpIHtcbiAgdmFyIHRhZyA9IG5vZGUudGFnO1xuICB2YXIgaXNIb3N0ID0gdGFnID09PSBIb3N0Q29tcG9uZW50IHx8IHRhZyA9PT0gSG9zdFRleHQ7XG5cbiAgaWYgKGlzSG9zdCkge1xuICAgIHZhciBzdGF0ZU5vZGUgPSBub2RlLnN0YXRlTm9kZTtcblxuICAgIGlmIChiZWZvcmUpIHtcbiAgICAgIGluc2VydEJlZm9yZShwYXJlbnQsIHN0YXRlTm9kZSwgYmVmb3JlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXBwZW5kQ2hpbGQocGFyZW50LCBzdGF0ZU5vZGUpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0YWcgPT09IEhvc3RQb3J0YWwgfHwgKHN1cHBvcnRzU2luZ2xldG9ucyA/IHRhZyA9PT0gSG9zdFNpbmdsZXRvbiA6IGZhbHNlKSkgOyBlbHNlIHtcbiAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkO1xuXG4gICAgaWYgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBpbnNlcnRPckFwcGVuZFBsYWNlbWVudE5vZGUoY2hpbGQsIGJlZm9yZSwgcGFyZW50KTtcbiAgICAgIHZhciBzaWJsaW5nID0gY2hpbGQuc2libGluZztcblxuICAgICAgd2hpbGUgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgICAgaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlKHNpYmxpbmcsIGJlZm9yZSwgcGFyZW50KTtcbiAgICAgICAgc2libGluZyA9IHNpYmxpbmcuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn0gLy8gVGhlc2UgYXJlIHRyYWNrZWQgb24gdGhlIHN0YWNrIGFzIHdlIHJlY3Vyc2l2ZWx5IHRyYXZlcnNlIGFcbi8vIGRlbGV0ZWQgc3VidHJlZS5cbi8vIFRPRE86IFVwZGF0ZSB0aGVzZSBkdXJpbmcgdGhlIHdob2xlIG11dGF0aW9uIHBoYXNlLCBub3QganVzdCBkdXJpbmdcbi8vIGEgZGVsZXRpb24uXG5cblxudmFyIGhvc3RQYXJlbnQgPSBudWxsO1xudmFyIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IGZhbHNlO1xuXG5mdW5jdGlvbiBjb21taXREZWxldGlvbkVmZmVjdHMocm9vdCwgcmV0dXJuRmliZXIsIGRlbGV0ZWRGaWJlcikge1xuICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgIC8vIFdlIG9ubHkgaGF2ZSB0aGUgdG9wIEZpYmVyIHRoYXQgd2FzIGRlbGV0ZWQgYnV0IHdlIG5lZWQgdG8gcmVjdXJzZSBkb3duIGl0c1xuICAgIC8vIGNoaWxkcmVuIHRvIGZpbmQgYWxsIHRoZSB0ZXJtaW5hbCBub2Rlcy5cbiAgICAvLyBSZWN1cnNpdmVseSBkZWxldGUgYWxsIGhvc3Qgbm9kZXMgZnJvbSB0aGUgcGFyZW50LCBkZXRhY2ggcmVmcywgY2xlYW5cbiAgICAvLyB1cCBtb3VudGVkIGxheW91dCBlZmZlY3RzLCBhbmQgY2FsbCBjb21wb25lbnRXaWxsVW5tb3VudC5cbiAgICAvLyBXZSBvbmx5IG5lZWQgdG8gcmVtb3ZlIHRoZSB0b3Btb3N0IGhvc3QgY2hpbGQgaW4gZWFjaCBicmFuY2guIEJ1dCB0aGVuIHdlXG4gICAgLy8gc3RpbGwgbmVlZCB0byBrZWVwIHRyYXZlcnNpbmcgdG8gdW5tb3VudCBlZmZlY3RzLCByZWZzLCBhbmQgY1dVLiBUT0RPOiBXZVxuICAgIC8vIGNvdWxkIHNwbGl0IHRoaXMgaW50byB0d28gc2VwYXJhdGUgdHJhdmVyc2FscyBmdW5jdGlvbnMsIHdoZXJlIHRoZSBzZWNvbmRcbiAgICAvLyBvbmUgZG9lc24ndCBpbmNsdWRlIGFueSByZW1vdmVDaGlsZCBsb2dpYy4gVGhpcyBpcyBtYXliZSB0aGUgc2FtZVxuICAgIC8vIGZ1bmN0aW9uIGFzIFwiZGlzYXBwZWFyTGF5b3V0RWZmZWN0c1wiIChvciB3aGF0ZXZlciB0aGF0IHR1cm5zIGludG8gYWZ0ZXJcbiAgICAvLyB0aGUgbGF5b3V0IHBoYXNlIGlzIHJlZmFjdG9yZWQgdG8gdXNlIHJlY3Vyc2lvbikuXG4gICAgLy8gQmVmb3JlIHN0YXJ0aW5nLCBmaW5kIHRoZSBuZWFyZXN0IGhvc3QgcGFyZW50IG9uIHRoZSBzdGFjayBzbyB3ZSBrbm93XG4gICAgLy8gd2hpY2ggaW5zdGFuY2UvY29udGFpbmVyIHRvIHJlbW92ZSB0aGUgY2hpbGRyZW4gZnJvbS5cbiAgICAvLyBUT0RPOiBJbnN0ZWFkIG9mIHNlYXJjaGluZyB1cCB0aGUgZmliZXIgcmV0dXJuIHBhdGggb24gZXZlcnkgZGVsZXRpb24sIHdlXG4gICAgLy8gY2FuIHRyYWNrIHRoZSBuZWFyZXN0IGhvc3QgY29tcG9uZW50IG9uIHRoZSBKUyBzdGFjayBhcyB3ZSB0cmF2ZXJzZSB0aGVcbiAgICAvLyB0cmVlIGR1cmluZyB0aGUgY29tbWl0IHBoYXNlLiBUaGlzIHdvdWxkIG1ha2UgaW5zZXJ0aW9ucyBmYXN0ZXIsIHRvby5cbiAgICB2YXIgcGFyZW50ID0gcmV0dXJuRmliZXI7XG5cbiAgICBmaW5kUGFyZW50OiB3aGlsZSAocGFyZW50ICE9PSBudWxsKSB7XG4gICAgICBzd2l0Y2ggKHBhcmVudC50YWcpIHtcbiAgICAgICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgICAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaG9zdFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGU7XG4gICAgICAgICAgICBob3N0UGFyZW50SXNDb250YWluZXIgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrIGZpbmRQYXJlbnQ7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaG9zdFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaG9zdFBhcmVudCA9IHBhcmVudC5zdGF0ZU5vZGUuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgICBicmVhayBmaW5kUGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcGFyZW50ID0gcGFyZW50LnJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoaG9zdFBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCB0byBmaW5kIGEgaG9zdCBwYXJlbnQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSAnICsgJ2EgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG5cbiAgICBjb21taXREZWxldGlvbkVmZmVjdHNPbkZpYmVyKHJvb3QsIHJldHVybkZpYmVyLCBkZWxldGVkRmliZXIpO1xuICAgIGhvc3RQYXJlbnQgPSBudWxsO1xuICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IGZhbHNlO1xuICB9IGVsc2Uge1xuICAgIC8vIERldGFjaCByZWZzIGFuZCBjYWxsIGNvbXBvbmVudFdpbGxVbm1vdW50KCkgb24gdGhlIHdob2xlIHN1YnRyZWUuXG4gICAgY29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlcihyb290LCByZXR1cm5GaWJlciwgZGVsZXRlZEZpYmVyKTtcbiAgfVxuXG4gIGRldGFjaEZpYmVyTXV0YXRpb24oZGVsZXRlZEZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIHBhcmVudCkge1xuICAvLyBUT0RPOiBVc2UgYSBzdGF0aWMgZmxhZyB0byBza2lwIHRyZWVzIHRoYXQgZG9uJ3QgaGF2ZSB1bm1vdW50IGVmZmVjdHNcbiAgdmFyIGNoaWxkID0gcGFyZW50LmNoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgIGNvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBjaGlsZCk7XG4gICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdERlbGV0aW9uRWZmZWN0c09uRmliZXIoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpIHtcbiAgb25Db21taXRVbm1vdW50KGRlbGV0ZWRGaWJlcik7IC8vIFRoZSBjYXNlcyBpbiB0aGlzIG91dGVyIHN3aXRjaCBtb2RpZnkgdGhlIHN0YWNrIGJlZm9yZSB0aGV5IHRyYXZlcnNlXG4gIC8vIGludG8gdGhlaXIgc3VidHJlZS4gVGhlcmUgYXJlIHNpbXBsZXIgY2FzZXMgaW4gdGhlIGlubmVyIHN3aXRjaFxuICAvLyB0aGF0IGRvbid0IG1vZGlmeSB0aGUgc3RhY2suXG5cbiAgc3dpdGNoIChkZWxldGVkRmliZXIudGFnKSB7XG4gICAgY2FzZSBIb3N0SG9pc3RhYmxlOlxuICAgICAge1xuICAgICAgICBpZiAoc3VwcG9ydHNSZXNvdXJjZXMpIHtcbiAgICAgICAgICBpZiAoIW9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pIHtcbiAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuXG4gICAgICAgICAgaWYgKGRlbGV0ZWRGaWJlci5tZW1vaXplZFN0YXRlKSB7XG4gICAgICAgICAgICByZWxlYXNlUmVzb3VyY2UoZGVsZXRlZEZpYmVyLm1lbW9pemVkU3RhdGUpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSkge1xuICAgICAgICAgICAgdW5tb3VudEhvaXN0YWJsZShkZWxldGVkRmliZXIuc3RhdGVOb2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gRmFsbCB0aHJvdWdoXG5cbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICAgIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzU2luZ2xldG9ucykge1xuICAgICAgICAgIGlmICghb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbikge1xuICAgICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHByZXZIb3N0UGFyZW50ID0gaG9zdFBhcmVudDtcbiAgICAgICAgICB2YXIgcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IGhvc3RQYXJlbnRJc0NvbnRhaW5lcjtcbiAgICAgICAgICBob3N0UGFyZW50ID0gZGVsZXRlZEZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVsZXRlZEZpYmVyKTsgLy8gTm9ybWFsbHkgdGhpcyBpcyBjYWxsZWQgaW4gcGFzc2l2ZSB1bm1vdW50IGVmZmVjdCBwaGFzZSBob3dldmVyIHdpdGhcbiAgICAgICAgICAvLyBIb3N0U2luZ2xldG9uIHdlIHdhcm4gaWYgeW91IGFjcXVpcmUgb25lIHRoYXQgaXMgYWxyZWFkeSBhc3NvY2lhdGVkIHRvXG4gICAgICAgICAgLy8gYSBkaWZmZXJlbnQgZmliZXIuIFRvIGluY3JlYXNlIG91ciBjaGFuY2VzIG9mIGF2b2lkaW5nIHRoaXMsIHNwZWNpZmljYWxseVxuICAgICAgICAgIC8vIGlmIHlvdSBrZXllZCBhIEhvc3RTaW5nbGV0b24gc28gdGhlcmUgd2lsbCBiZSBhIGRlbGV0ZSBmb2xsb3dlZCBieSBhIFBsYWNlbWVudFxuICAgICAgICAgIC8vIHdlIHRyZWF0IGRldGFjaCBlYWdlcmx5IGhlcmVcblxuICAgICAgICAgIHJlbGVhc2VTaW5nbGV0b25JbnN0YW5jZShkZWxldGVkRmliZXIuc3RhdGVOb2RlKTtcbiAgICAgICAgICBob3N0UGFyZW50ID0gcHJldkhvc3RQYXJlbnQ7XG4gICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lcjtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gRmFsbCB0aHJvdWdoXG5cbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgaWYgKCFvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuKSB7XG4gICAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gICAgICAgIH0gLy8gSW50ZW50aW9uYWwgZmFsbHRocm91Z2ggdG8gbmV4dCBicmFuY2hcblxuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0VGV4dDpcbiAgICAgIHtcbiAgICAgICAgLy8gV2Ugb25seSBuZWVkIHRvIHJlbW92ZSB0aGUgbmVhcmVzdCBob3N0IGNoaWxkLiBTZXQgdGhlIGhvc3QgcGFyZW50XG4gICAgICAgIC8vIHRvIGBudWxsYCBvbiB0aGUgc3RhY2sgdG8gaW5kaWNhdGUgdGhhdCBuZXN0ZWQgY2hpbGRyZW4gZG9uJ3RcbiAgICAgICAgLy8gbmVlZCB0byBiZSByZW1vdmVkLlxuICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbikge1xuICAgICAgICAgIHZhciBfcHJldkhvc3RQYXJlbnQgPSBob3N0UGFyZW50O1xuICAgICAgICAgIHZhciBfcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IGhvc3RQYXJlbnRJc0NvbnRhaW5lcjtcbiAgICAgICAgICBob3N0UGFyZW50ID0gbnVsbDtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGVsZXRpb25FZmZlY3RzKGZpbmlzaGVkUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVsZXRlZEZpYmVyKTtcbiAgICAgICAgICBob3N0UGFyZW50ID0gX3ByZXZIb3N0UGFyZW50O1xuICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IF9wcmV2SG9zdFBhcmVudElzQ29udGFpbmVyO1xuXG4gICAgICAgICAgaWYgKGhvc3RQYXJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIE5vdyB0aGF0IGFsbCB0aGUgY2hpbGQgZWZmZWN0cyBoYXZlIHVubW91bnRlZCwgd2UgY2FuIHJlbW92ZSB0aGVcbiAgICAgICAgICAgIC8vIG5vZGUgZnJvbSB0aGUgdHJlZS5cbiAgICAgICAgICAgIGlmIChob3N0UGFyZW50SXNDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgcmVtb3ZlQ2hpbGRGcm9tQ29udGFpbmVyKGhvc3RQYXJlbnQsIGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVtb3ZlQ2hpbGQoaG9zdFBhcmVudCwgZGVsZXRlZEZpYmVyLnN0YXRlTm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBEZWh5ZHJhdGVkRnJhZ21lbnQ6XG4gICAgICB7XG4gICAgICAgIC8vIERlbGV0ZSB0aGUgZGVoeWRyYXRlZCBzdXNwZW5zZSBib3VuZGFyeSBhbmQgYWxsIG9mIGl0cyBjb250ZW50LlxuXG5cbiAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICBpZiAoaG9zdFBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGhvc3RQYXJlbnRJc0NvbnRhaW5lcikge1xuICAgICAgICAgICAgICBjbGVhclN1c3BlbnNlQm91bmRhcnlGcm9tQ29udGFpbmVyKGhvc3RQYXJlbnQsIGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY2xlYXJTdXNwZW5zZUJvdW5kYXJ5KGhvc3RQYXJlbnQsIGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICAvLyBXaGVuIHdlIGdvIGludG8gYSBwb3J0YWwsIGl0IGJlY29tZXMgdGhlIHBhcmVudCB0byByZW1vdmUgZnJvbS5cbiAgICAgICAgICB2YXIgX3ByZXZIb3N0UGFyZW50MiA9IGhvc3RQYXJlbnQ7XG4gICAgICAgICAgdmFyIF9wcmV2SG9zdFBhcmVudElzQ29udGFpbmVyMiA9IGhvc3RQYXJlbnRJc0NvbnRhaW5lcjtcbiAgICAgICAgICBob3N0UGFyZW50ID0gZGVsZXRlZEZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgIGhvc3RQYXJlbnRJc0NvbnRhaW5lciA9IHRydWU7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlbGV0ZWRGaWJlcik7XG4gICAgICAgICAgaG9zdFBhcmVudCA9IF9wcmV2SG9zdFBhcmVudDI7XG4gICAgICAgICAgaG9zdFBhcmVudElzQ29udGFpbmVyID0gX3ByZXZIb3N0UGFyZW50SXNDb250YWluZXIyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVtcHR5UG9ydGFsQ29udGFpbmVyKGRlbGV0ZWRGaWJlcik7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlbGV0ZWRGaWJlcik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBpZiAoIW9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4pIHtcbiAgICAgICAgICB2YXIgdXBkYXRlUXVldWUgPSBkZWxldGVkRmliZXIudXBkYXRlUXVldWU7XG5cbiAgICAgICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBsYXN0RWZmZWN0ID0gdXBkYXRlUXVldWUubGFzdEVmZmVjdDtcblxuICAgICAgICAgICAgaWYgKGxhc3RFZmZlY3QgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgdmFyIGZpcnN0RWZmZWN0ID0gbGFzdEVmZmVjdC5uZXh0O1xuICAgICAgICAgICAgICB2YXIgZWZmZWN0ID0gZmlyc3RFZmZlY3Q7XG5cbiAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgIHZhciB0YWcgPSBlZmZlY3QudGFnO1xuICAgICAgICAgICAgICAgIHZhciBpbnN0ID0gZWZmZWN0Lmluc3Q7XG4gICAgICAgICAgICAgICAgdmFyIGRlc3Ryb3kgPSBpbnN0LmRlc3Ryb3k7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGVzdHJveSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoKHRhZyAmIEluc2VydGlvbikgIT09IE5vRmxhZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5zdC5kZXN0cm95ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBzYWZlbHlDYWxsRGVzdHJveShkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlc3Ryb3kpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgodGFnICYgTGF5b3V0KSAhPT0gTm9GbGFncykge1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgbWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkKGRlbGV0ZWRGaWJlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkUHJvZmlsZShkZWxldGVkRmliZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICAgICAgICAgICAgICAgIGluc3QuZGVzdHJveSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICBzYWZlbHlDYWxsRGVzdHJveShkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlc3Ryb3kpO1xuICAgICAgICAgICAgICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGRlbGV0ZWRGaWJlcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgaW5zdC5kZXN0cm95ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICAgIHNhZmVseUNhbGxEZXN0cm95KGRlbGV0ZWRGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZGVzdHJveSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgbWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdG9wcGVkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBlZmZlY3QgPSBlZmZlY3QubmV4dDtcbiAgICAgICAgICAgICAgfSB3aGlsZSAoZWZmZWN0ICE9PSBmaXJzdEVmZmVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlbGV0ZWRGaWJlcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGlmICghb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbikge1xuICAgICAgICAgIHNhZmVseURldGFjaFJlZihkZWxldGVkRmliZXIsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgICAgICAgIHZhciBpbnN0YW5jZSA9IGRlbGV0ZWRGaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgICBpZiAodHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudFdpbGxVbm1vdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBpbnN0YW5jZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlbGV0ZWRGaWJlcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgU2NvcGVDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlbGV0ZWRGaWJlcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZGVsZXRlZEZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcblxuICAgICAgICB7XG4gICAgICAgICAgLy8gSWYgdGhpcyBvZmZzY3JlZW4gY29tcG9uZW50IGlzIGhpZGRlbiwgd2UgYWxyZWFkeSB1bm1vdW50ZWQgaXQuIEJlZm9yZVxuICAgICAgICAgIC8vIGRlbGV0aW5nIHRoZSBjaGlsZHJlbiwgdHJhY2sgdGhhdCBpdCdzIGFscmVhZHkgdW5tb3VudGVkIHNvIHRoYXQgd2VcbiAgICAgICAgICAvLyBkb24ndCBhdHRlbXB0IHRvIHVubW91bnQgdGhlIGVmZmVjdHMgYWdhaW4uXG4gICAgICAgICAgLy8gVE9ETzogSWYgdGhlIHRyZWUgaXMgaGlkZGVuLCBpbiBtb3N0IGNhc2VzIHdlIHNob3VsZCBiZSBhYmxlIHRvIHNraXBcbiAgICAgICAgICAvLyBvdmVyIHRoZSBuZXN0ZWQgY2hpbGRyZW4gZW50aXJlbHkuIEFuIGV4Y2VwdGlvbiBpcyB3ZSBoYXZlbid0IHlldCBmb3VuZFxuICAgICAgICAgIC8vIHRoZSB0b3Btb3N0IGhvc3Qgbm9kZSB0byBkZWxldGUsIHdoaWNoIHdlIGFscmVhZHkgdHJhY2sgb24gdGhlIHN0YWNrLlxuICAgICAgICAgIC8vIEJ1dCB0aGUgb3RoZXIgY2FzZSBpcyBwb3J0YWxzLCB3aGljaCBuZWVkIHRvIGJlIGRldGFjaGVkIG5vIG1hdHRlciBob3dcbiAgICAgICAgICAvLyBkZWVwbHkgdGhleSBhcmUgbmVzdGVkLiBXZSBzaG91bGQgdXNlIGEgc3VidHJlZSBmbGFnIHRvIHRyYWNrIHdoZXRoZXIgYVxuICAgICAgICAgIC8vIHN1YnRyZWUgaW5jbHVkZXMgYSBuZXN0ZWQgcG9ydGFsLlxuICAgICAgICAgIHZhciBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IHByZXZPZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuIHx8IGRlbGV0ZWRGaWJlci5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMoZmluaXNoZWRSb290LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yLCBkZWxldGVkRmliZXIpO1xuICAgICAgICAgIG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gPSBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURlbGV0aW9uRWZmZWN0cyhmaW5pc2hlZFJvb3QsIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGRlbGV0ZWRGaWJlcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRTdXNwZW5zZUNhbGxiYWNrKGZpbmlzaGVkV29yaykge1xufVxuXG5mdW5jdGlvbiBjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaykge1xuICBpZiAoIXN1cHBvcnRzSHlkcmF0aW9uKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIG5ld1N0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKG5ld1N0YXRlID09PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgIHZhciBwcmV2U3RhdGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGU7XG5cbiAgICAgIGlmIChwcmV2U3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIHN1c3BlbnNlSW5zdGFuY2UgPSBwcmV2U3RhdGUuZGVoeWRyYXRlZDtcblxuICAgICAgICBpZiAoc3VzcGVuc2VJbnN0YW5jZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2Uoc3VzcGVuc2VJbnN0YW5jZSk7XG5cbiAgICAgICAgICAgIHZhciBoeWRyYXRpb25DYWxsYmFja3MsIG9uSHlkcmF0ZWQ7IGlmIChlbmFibGVTdXNwZW5zZUNhbGxiYWNrKSA7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRSZXRyeUNhY2hlKGZpbmlzaGVkV29yaykge1xuICAvLyBUT0RPOiBVbmlmeSB0aGUgaW50ZXJmYWNlIGZvciB0aGUgcmV0cnkgY2FjaGUgc28gd2UgZG9uJ3QgaGF2ZSB0byBzd2l0Y2hcbiAgLy8gb24gdGhlIHRhZyBsaWtlIHRoaXMuXG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciByZXRyeUNhY2hlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcblxuICAgICAgICBpZiAocmV0cnlDYWNoZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHJ5Q2FjaGUgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlID0gbmV3IFBvc3NpYmx5V2Vha1NldCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldHJ5Q2FjaGU7XG4gICAgICB9XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIGluc3RhbmNlID0gZmluaXNoZWRXb3JrLnN0YXRlTm9kZTtcbiAgICAgICAgdmFyIF9yZXRyeUNhY2hlID0gaW5zdGFuY2UuX3JldHJ5Q2FjaGU7XG5cbiAgICAgICAgaWYgKF9yZXRyeUNhY2hlID09PSBudWxsKSB7XG4gICAgICAgICAgX3JldHJ5Q2FjaGUgPSBpbnN0YW5jZS5fcmV0cnlDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtTZXQoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfcmV0cnlDYWNoZTtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgU3VzcGVuc2UgaGFuZGxlciB0YWcgKFwiICsgZmluaXNoZWRXb3JrLnRhZyArIFwiKS4gVGhpcyBpcyBhIFwiICsgJ2J1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRhY2hPZmZzY3JlZW5JbnN0YW5jZShpbnN0YW5jZSkge1xuICB2YXIgZmliZXIgPSBpbnN0YW5jZS5fY3VycmVudDtcblxuICBpZiAoZmliZXIgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgT2Zmc2NyZWVuLmRldGFjaCBiZWZvcmUgaW5zdGFuY2UgaGFuZGxlIGhhcyBiZWVuIHNldC4nKTtcbiAgfVxuXG4gIGlmICgoaW5zdGFuY2UuX3BlbmRpbmdWaXNpYmlsaXR5ICYgT2Zmc2NyZWVuRGV0YWNoZWQpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAvLyBUaGUgaW5zdGFuY2UgaXMgYWxyZWFkeSBkZXRhY2hlZCwgdGhpcyBpcyBhIG5vb3AuXG4gICAgcmV0dXJuO1xuICB9IC8vIFRPRE86IFRoZXJlIGlzIGFuIG9wcG9ydHVuaXR5IHRvIG9wdGltaXNlIHRoaXMgYnkgbm90IGVudGVyaW5nIGNvbW1pdCBwaGFzZVxuICAvLyBhbmQgdW5tb3VudGluZyBlZmZlY3RzIGRpcmVjdGx5LlxuXG5cbiAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIFN5bmNMYW5lKTtcblxuICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgIGluc3RhbmNlLl9wZW5kaW5nVmlzaWJpbGl0eSB8PSBPZmZzY3JlZW5EZXRhY2hlZDtcbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lKTtcbiAgfVxufVxuZnVuY3Rpb24gYXR0YWNoT2Zmc2NyZWVuSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgdmFyIGZpYmVyID0gaW5zdGFuY2UuX2N1cnJlbnQ7XG5cbiAgaWYgKGZpYmVyID09PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIE9mZnNjcmVlbi5kZXRhY2ggYmVmb3JlIGluc3RhbmNlIGhhbmRsZSBoYXMgYmVlbiBzZXQuJyk7XG4gIH1cblxuICBpZiAoKGluc3RhbmNlLl9wZW5kaW5nVmlzaWJpbGl0eSAmIE9mZnNjcmVlbkRldGFjaGVkKSA9PT0gTm9GbGFncyQxKSB7XG4gICAgLy8gVGhlIGluc3RhbmNlIGlzIGFscmVhZHkgYXR0YWNoZWQsIHRoaXMgaXMgYSBub29wLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBTeW5jTGFuZSk7XG5cbiAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICBpbnN0YW5jZS5fcGVuZGluZ1Zpc2liaWxpdHkgJj0gfk9mZnNjcmVlbkRldGFjaGVkO1xuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgU3luY0xhbmUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMoZmluaXNoZWRXb3JrLCB3YWtlYWJsZXMpIHtcbiAgLy8gSWYgdGhpcyBib3VuZGFyeSBqdXN0IHRpbWVkIG91dCwgdGhlbiBpdCB3aWxsIGhhdmUgYSBzZXQgb2Ygd2FrZWFibGVzLlxuICAvLyBGb3IgZWFjaCB3YWtlYWJsZSwgYXR0YWNoIGEgbGlzdGVuZXIgc28gdGhhdCB3aGVuIGl0IHJlc29sdmVzLCBSZWFjdFxuICAvLyBhdHRlbXB0cyB0byByZS1yZW5kZXIgdGhlIGJvdW5kYXJ5IGluIHRoZSBwcmltYXJ5IChwcmUtdGltZW91dCkgc3RhdGUuXG4gIHZhciByZXRyeUNhY2hlID0gZ2V0UmV0cnlDYWNoZShmaW5pc2hlZFdvcmspO1xuICB3YWtlYWJsZXMuZm9yRWFjaChmdW5jdGlvbiAod2FrZWFibGUpIHtcbiAgICAvLyBNZW1vaXplIHVzaW5nIHRoZSBib3VuZGFyeSBmaWJlciB0byBwcmV2ZW50IHJlZHVuZGFudCBsaXN0ZW5lcnMuXG4gICAgdmFyIHJldHJ5ID0gcmVzb2x2ZVJldHJ5V2FrZWFibGUuYmluZChudWxsLCBmaW5pc2hlZFdvcmssIHdha2VhYmxlKTtcblxuICAgIGlmICghcmV0cnlDYWNoZS5oYXMod2FrZWFibGUpKSB7XG4gICAgICByZXRyeUNhY2hlLmFkZCh3YWtlYWJsZSk7XG5cbiAgICAgIHtcbiAgICAgICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICAgICAgaWYgKGluUHJvZ3Jlc3NMYW5lcyAhPT0gbnVsbCAmJiBpblByb2dyZXNzUm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBwZW5kaW5nIHdvcmsgc3RpbGwsIGFzc29jaWF0ZSB0aGUgb3JpZ2luYWwgdXBkYXRlcnMgd2l0aCBpdC5cbiAgICAgICAgICAgIHJlc3RvcmVQZW5kaW5nVXBkYXRlcnMoaW5Qcm9ncmVzc1Jvb3QsIGluUHJvZ3Jlc3NMYW5lcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdFeHBlY3RlZCBmaW5pc2hlZCByb290IGFuZCBsYW5lcyB0byBiZSBzZXQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHdha2VhYmxlLnRoZW4ocmV0cnksIHJldHJ5KTtcbiAgICB9XG4gIH0pO1xufSAvLyBUaGlzIGZ1bmN0aW9uIGRldGVjdHMgd2hlbiBhIFN1c3BlbnNlIGJvdW5kYXJ5IGdvZXMgZnJvbSB2aXNpYmxlIHRvIGhpZGRlbi5cbmZ1bmN0aW9uIGNvbW1pdE11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzKSB7XG4gIGluUHJvZ3Jlc3NMYW5lcyA9IGNvbW1pdHRlZExhbmVzO1xuICBpblByb2dyZXNzUm9vdCA9IHJvb3Q7XG4gIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoZmluaXNoZWRXb3JrKTtcbiAgY29tbWl0TXV0YXRpb25FZmZlY3RzT25GaWJlcihmaW5pc2hlZFdvcmssIHJvb3QpO1xuICByZXNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoKTtcbiAgaW5Qcm9ncmVzc0xhbmVzID0gbnVsbDtcbiAgaW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIHBhcmVudEZpYmVyLCBsYW5lcykge1xuICAvLyBEZWxldGlvbnMgZWZmZWN0cyBjYW4gYmUgc2NoZWR1bGVkIG9uIGFueSBmaWJlciB0eXBlLiBUaGV5IG5lZWQgdG8gaGFwcGVuXG4gIC8vIGJlZm9yZSB0aGUgY2hpbGRyZW4gZWZmZWN0cyBoYWUgZmlyZWQuXG4gIHZhciBkZWxldGlvbnMgPSBwYXJlbnRGaWJlci5kZWxldGlvbnM7XG5cbiAgaWYgKGRlbGV0aW9ucyAhPT0gbnVsbCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsZXRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgY2hpbGRUb0RlbGV0ZSA9IGRlbGV0aW9uc1tpXTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29tbWl0RGVsZXRpb25FZmZlY3RzKHJvb3QsIHBhcmVudEZpYmVyLCBjaGlsZFRvRGVsZXRlKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGNoaWxkVG9EZWxldGUsIHBhcmVudEZpYmVyLCBlcnJvcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgdmFyIHByZXZEZWJ1Z0ZpYmVyID0gZ2V0Q3VycmVudEZpYmVyKCk7XG5cbiAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIE11dGF0aW9uTWFzaykge1xuICAgIHZhciBjaGlsZCA9IHBhcmVudEZpYmVyLmNoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKGNoaWxkKTtcbiAgICAgIGNvbW1pdE11dGF0aW9uRWZmZWN0c09uRmliZXIoY2hpbGQsIHJvb3QpO1xuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYocHJldkRlYnVnRmliZXIpO1xufVxuXG52YXIgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBudWxsO1xuXG5mdW5jdGlvbiBjb21taXRNdXRhdGlvbkVmZmVjdHNPbkZpYmVyKGZpbmlzaGVkV29yaywgcm9vdCwgbGFuZXMpIHtcbiAgdmFyIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7IC8vIFRoZSBlZmZlY3QgZmxhZyBzaG91bGQgYmUgY2hlY2tlZCAqYWZ0ZXIqIHdlIHJlZmluZSB0aGUgdHlwZSBvZiBmaWJlcixcbiAgLy8gYmVjYXVzZSB0aGUgZmliZXIgdGFnIGlzIG1vcmUgc3BlY2lmaWMuIEFuIGV4Y2VwdGlvbiBpcyBhbnkgZmxhZyByZWxhdGVkXG4gIC8vIHRvIHJlY29uY2lsaWF0aW9uLCBiZWNhdXNlIHRob3NlIGNhbiBiZSBzZXQgb24gYWxsIGZpYmVyIHR5cGVzLlxuXG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChJbnNlcnRpb24gfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KEluc2VydGlvbiB8IEhhc0VmZmVjdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgfSAvLyBMYXlvdXQgZWZmZWN0cyBhcmUgZGVzdHJveWVkIGR1cmluZyB0aGUgbXV0YXRpb24gcGhhc2Ugc28gdGhhdCBhbGxcbiAgICAgICAgICAvLyBkZXN0cm95IGZ1bmN0aW9ucyBmb3IgYWxsIGZpYmVycyBhcmUgY2FsbGVkIGJlZm9yZSBhbnkgY3JlYXRlIGZ1bmN0aW9ucy5cbiAgICAgICAgICAvLyBUaGlzIHByZXZlbnRzIHNpYmxpbmcgY29tcG9uZW50IGVmZmVjdHMgZnJvbSBpbnRlcmZlcmluZyB3aXRoIGVhY2ggb3RoZXIsXG4gICAgICAgICAgLy8gZS5nLiBhIGRlc3Ryb3kgZnVuY3Rpb24gaW4gb25lIGNvbXBvbmVudCBzaG91bGQgbmV2ZXIgb3ZlcnJpZGUgYSByZWYgc2V0XG4gICAgICAgICAgLy8gYnkgYSBjcmVhdGUgZnVuY3Rpb24gaW4gYW5vdGhlciBjb21wb25lbnQgZHVyaW5nIHRoZSBzYW1lIGNvbW1pdC5cblxuXG4gICAgICAgICAgaWYgKHNob3VsZFByb2ZpbGUoZmluaXNoZWRXb3JrKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgc3RhcnRMYXlvdXRFZmZlY3RUaW1lcigpO1xuICAgICAgICAgICAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoTGF5b3V0IHwgSGFzRWZmZWN0LCBmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChMYXlvdXQgfCBIYXNFZmZlY3QsIGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFJlZikge1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgY3VycmVudC5yZXR1cm4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbGFncyAmIENhbGxiYWNrICYmIG9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbikge1xuICAgICAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcblxuICAgICAgICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVmZXJIaWRkZW5DYWxsYmFja3ModXBkYXRlUXVldWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdEhvaXN0YWJsZTpcbiAgICAgIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzUmVzb3VyY2VzKSB7XG4gICAgICAgICAgLy8gV2UgY2FzdCBiZWNhdXNlIHdlIGFsd2F5cyBzZXQgdGhlIHJvb3QgYXQgdGhlIFJlYWN0IHJvb3QgYW5kIHNvIGl0IGNhbm5vdCBiZVxuICAgICAgICAgIC8vIG51bGwgd2hpbGUgd2UgYXJlIHByb2Nlc3NpbmcgbXV0YXRpb24gZWZmZWN0c1xuICAgICAgICAgIHZhciBob2lzdGFibGVSb290ID0gY3VycmVudEhvaXN0YWJsZVJvb3Q7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuXG4gICAgICAgICAgaWYgKGZsYWdzICYgUmVmKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgY3VycmVudC5yZXR1cm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIGN1cnJlbnRSZXNvdXJjZSA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkU3RhdGUgOiBudWxsO1xuICAgICAgICAgICAgdmFyIG5ld1Jlc291cmNlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG5cbiAgICAgICAgICAgIGlmIChjdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIFdlIGFyZSBtb3VudGluZyBhIG5ldyBIb3N0SG9pc3RhYmxlIEZpYmVyLiBXZSBmb3JrIHRoZSBtb3VudFxuICAgICAgICAgICAgICAvLyBiZWhhdmlvciBiYXNlZCBvbiB3aGV0aGVyIHRoaXMgaW5zdGFuY2UgaXMgYSBIb2lzdGFibGUgSW5zdGFuY2VcbiAgICAgICAgICAgICAgLy8gb3IgYSBIb2lzdGFibGUgUmVzb3VyY2VcbiAgICAgICAgICAgICAgaWYgKG5ld1Jlc291cmNlID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUgPSBoeWRyYXRlSG9pc3RhYmxlKGhvaXN0YWJsZVJvb3QsIGZpbmlzaGVkV29yay50eXBlLCBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcywgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbW91bnRIb2lzdGFibGUoaG9pc3RhYmxlUm9vdCwgZmluaXNoZWRXb3JrLnR5cGUsIGZpbmlzaGVkV29yay5zdGF0ZU5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlID0gYWNxdWlyZVJlc291cmNlKGhvaXN0YWJsZVJvb3QsIG5ld1Jlc291cmNlLCBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wcyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlc291cmNlICE9PSBuZXdSZXNvdXJjZSkge1xuICAgICAgICAgICAgICAvLyBXZSBhcmUgbW92aW5nIHRvIG9yIGZyb20gSG9pc3RhYmxlIFJlc291cmNlLCBvciBiZXR3ZWVuIGRpZmZlcmVudCBIb2lzdGFibGUgUmVzb3VyY2VzXG4gICAgICAgICAgICAgIGlmIChjdXJyZW50UmVzb3VyY2UgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5zdGF0ZU5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHVubW91bnRIb2lzdGFibGUoY3VycmVudC5zdGF0ZU5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZWxlYXNlUmVzb3VyY2UoY3VycmVudFJlc291cmNlKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChuZXdSZXNvdXJjZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG1vdW50SG9pc3RhYmxlKGhvaXN0YWJsZVJvb3QsIGZpbmlzaGVkV29yay50eXBlLCBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY3F1aXJlUmVzb3VyY2UoaG9pc3RhYmxlUm9vdCwgbmV3UmVzb3VyY2UsIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChuZXdSZXNvdXJjZSA9PT0gbnVsbCAmJiBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29tbWl0VXBkYXRlKGZpbmlzaGVkV29yay5zdGF0ZU5vZGUsIGZpbmlzaGVkV29yay50eXBlLCBjdXJyZW50Lm1lbW9pemVkUHJvcHMsIGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzLCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RTaW5nbGV0b246XG4gICAgICB7XG4gICAgICAgIGlmIChzdXBwb3J0c1NpbmdsZXRvbnMpIHtcbiAgICAgICAgICBpZiAoZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c1dvcmsgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuXG4gICAgICAgICAgICBpZiAocHJldmlvdXNXb3JrID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBzaW5nbGV0b24gPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICAgICAgICB2YXIgcHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wczsgLy8gVGhpcyB3YXMgYSBuZXcgbW91bnQsIHdlIG5lZWQgdG8gY2xlYXIgYW5kIHNldCBpbml0aWFsIHByb3BlcnRpZXNcblxuICAgICAgICAgICAgICBjbGVhclNpbmdsZXRvbihzaW5nbGV0b24pO1xuICAgICAgICAgICAgICBhY3F1aXJlU2luZ2xldG9uSW5zdGFuY2UoZmluaXNoZWRXb3JrLnR5cGUsIHByb3BzLCBzaW5nbGV0b24sIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgUmVmKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNhZmVseURldGFjaFJlZihjdXJyZW50LCBjdXJyZW50LnJldHVybik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24pIHtcbiAgICAgICAgICAvLyBUT0RPOiBDb250ZW50UmVzZXQgZ2V0cyBjbGVhcmVkIGJ5IHRoZSBjaGlsZHJlbiBkdXJpbmcgdGhlIGNvbW1pdFxuICAgICAgICAgIC8vIHBoYXNlLiBUaGlzIGlzIGEgcmVmYWN0b3IgaGF6YXJkIGJlY2F1c2UgaXQgbWVhbnMgd2UgbXVzdCByZWFkXG4gICAgICAgICAgLy8gZmxhZ3MgdGhlIGZsYWdzIGFmdGVyIGBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHNgIGhhcyBhbHJlYWR5IHJ1bjtcbiAgICAgICAgICAvLyB0aGUgb3JkZXIgbWF0dGVycy4gV2Ugc2hvdWxkIHJlZmFjdG9yIHNvIHRoYXQgQ29udGVudFJlc2V0IGRvZXMgbm90XG4gICAgICAgICAgLy8gcmVseSBvbiBtdXRhdGluZyB0aGUgZmxhZyBkdXJpbmcgY29tbWl0LiBMaWtlIGJ5IHNldHRpbmcgYSBmbGFnXG4gICAgICAgICAgLy8gZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UgaW5zdGVhZC5cbiAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLmZsYWdzICYgQ29udGVudFJlc2V0KSB7XG4gICAgICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICByZXNldFRleHRDb250ZW50KGluc3RhbmNlKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIF9pbnN0YW5jZTIgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gICAgICAgICAgICBpZiAoX2luc3RhbmNlMiAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIC8vIENvbW1pdCB0aGUgd29yayBwcmVwYXJlZCBlYXJsaWVyLlxuICAgICAgICAgICAgICB2YXIgbmV3UHJvcHMgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRQcm9wczsgLy8gRm9yIGh5ZHJhdGlvbiB3ZSByZXVzZSB0aGUgdXBkYXRlIHBhdGggYnV0IHdlIHRyZWF0IHRoZSBvbGRQcm9wc1xuICAgICAgICAgICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgICAgICAgICAgLy8gdGhpcyBjYXNlLlxuXG4gICAgICAgICAgICAgIHZhciBvbGRQcm9wcyA9IGN1cnJlbnQgIT09IG51bGwgPyBjdXJyZW50Lm1lbW9pemVkUHJvcHMgOiBuZXdQcm9wcztcbiAgICAgICAgICAgICAgdmFyIHR5cGUgPSBmaW5pc2hlZFdvcmsudHlwZTtcblxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbW1pdFVwZGF0ZShfaW5zdGFuY2UyLCB0eXBlLCBvbGRQcm9wcywgbmV3UHJvcHMsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZmxhZ3MgJiBGb3JtUmVzZXQpIHtcbiAgICAgICAgICAgIG5lZWRzRm9ybVJlc2V0ID0gdHJ1ZTtcblxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLnR5cGUgIT09ICdmb3JtJykge1xuICAgICAgICAgICAgICAgIC8vIFBhcmFub2lkIGNvZGluZy4gSW4gY2FzZSB3ZSBhY2NpZGVudGFsbHkgc3RhcnQgdXNpbmcgdGhlXG4gICAgICAgICAgICAgICAgLy8gRm9ybVJlc2V0IGJpdCBmb3Igc29tZXRoaW5nIGVsc2UuXG4gICAgICAgICAgICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgaG9zdCBjb21wb25lbnQgdHlwZS4gRXhwZWN0ZWQgYSBmb3JtLiBUaGlzIGlzIGEgJyArICdidWcgaW4gUmVhY3QuJyk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RUZXh0OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIGlmIChzdXBwb3J0c011dGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoaXMgc2hvdWxkIGhhdmUgYSB0ZXh0IG5vZGUgaW5pdGlhbGl6ZWQuIFRoaXMgZXJyb3IgaXMgbGlrZWx5ICcgKyAnY2F1c2VkIGJ5IGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRleHRJbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICB2YXIgbmV3VGV4dCA9IGZpbmlzaGVkV29yay5tZW1vaXplZFByb3BzOyAvLyBGb3IgaHlkcmF0aW9uIHdlIHJldXNlIHRoZSB1cGRhdGUgcGF0aCBidXQgd2UgdHJlYXQgdGhlIG9sZFByb3BzXG4gICAgICAgICAgICAvLyBhcyB0aGUgbmV3UHJvcHMuIFRoZSB1cGRhdGVQYXlsb2FkIHdpbGwgY29udGFpbiB0aGUgcmVhbCBjaGFuZ2UgaW5cbiAgICAgICAgICAgIC8vIHRoaXMgY2FzZS5cblxuICAgICAgICAgICAgdmFyIG9sZFRleHQgPSBjdXJyZW50ICE9PSBudWxsID8gY3VycmVudC5tZW1vaXplZFByb3BzIDogbmV3VGV4dDtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgY29tbWl0VGV4dFVwZGF0ZSh0ZXh0SW5zdGFuY2UsIG9sZFRleHQsIG5ld1RleHQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzUmVzb3VyY2VzKSB7XG4gICAgICAgICAgcHJlcGFyZVRvQ29tbWl0SG9pc3RhYmxlcygpO1xuICAgICAgICAgIHZhciBwcmV2aW91c0hvaXN0YWJsZVJvb3QgPSBjdXJyZW50SG9pc3RhYmxlUm9vdDtcbiAgICAgICAgICBjdXJyZW50SG9pc3RhYmxlUm9vdCA9IGdldEhvaXN0YWJsZVJvb3Qocm9vdC5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBwcmV2aW91c0hvaXN0YWJsZVJvb3Q7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgaWYgKHN1cHBvcnRzTXV0YXRpb24gJiYgc3VwcG9ydHNIeWRyYXRpb24pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHZhciBwcmV2Um9vdFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuXG4gICAgICAgICAgICAgIGlmIChwcmV2Um9vdFN0YXRlLmlzRGVoeWRyYXRlZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICBjb21taXRIeWRyYXRlZENvbnRhaW5lcihyb290LmNvbnRhaW5lckluZm8pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5lckluZm8gPSByb290LmNvbnRhaW5lckluZm87XG4gICAgICAgICAgICB2YXIgcGVuZGluZ0NoaWxkcmVuID0gcm9vdC5wZW5kaW5nQ2hpbGRyZW47XG5cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIHJlcGxhY2VDb250YWluZXJDaGlsZHJlbihjb250YWluZXJJbmZvLCBwZW5kaW5nQ2hpbGRyZW4pO1xuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG5lZWRzRm9ybVJlc2V0KSB7XG4gICAgICAgICAgLy8gQSBmb3JtIGNvbXBvbmVudCByZXF1ZXN0ZWQgdG8gYmUgcmVzZXQgZHVyaW5nIHRoaXMgY29tbWl0LiBXZSBkbyB0aGlzXG4gICAgICAgICAgLy8gYWZ0ZXIgYWxsIG11dGF0aW9ucyBpbiB0aGUgcmVzdCBvZiB0aGUgdHJlZSBzbyB0aGF0IGBkZWZhdWx0VmFsdWVgXG4gICAgICAgICAgLy8gd2lsbCBhbHJlYWR5IGJlIHVwZGF0ZWQuIFRoaXMgd2F5IHlvdSBjYW4gdXBkYXRlIGBkZWZhdWx0VmFsdWVgIHVzaW5nXG4gICAgICAgICAgLy8gZGF0YSBzZW50IGJ5IHRoZSBzZXJ2ZXIgYXMgYSByZXN1bHQgb2YgdGhlIGZvcm0gc3VibWlzc2lvbi5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFRoZW9yZXRpY2FsbHkgd2UgY291bGQgY2hlY2sgZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIEZvcm1SZXNldCxcbiAgICAgICAgICAvLyBidXQgdGhlIEZvcm1SZXNldCBiaXQgaXMgb3ZlcmxvYWRlZCB3aXRoIG90aGVyIGZsYWdzIHVzZWQgYnkgb3RoZXJcbiAgICAgICAgICAvLyBmaWJlciB0eXBlcy4gU28gdGhpcyBleHRyYSB2YXJpYWJsZSBsZXRzIHVzIHNraXAgdHJhdmVyc2luZyB0aGUgdHJlZVxuICAgICAgICAgIC8vIGV4Y2VwdCB3aGVuIGEgZm9ybSB3YXMgYWN0dWFsbHkgc3VibWl0dGVkLlxuICAgICAgICAgIG5lZWRzRm9ybVJlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgcmVjdXJzaXZlbHlSZXNldEZvcm1zKGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIEhvc3RQb3J0YWw6XG4gICAgICB7XG4gICAgICAgIGlmIChzdXBwb3J0c1Jlc291cmNlcykge1xuICAgICAgICAgIHZhciBfcHJldmlvdXNIb2lzdGFibGVSb290ID0gY3VycmVudEhvaXN0YWJsZVJvb3Q7XG4gICAgICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBnZXRIb2lzdGFibGVSb290KGZpbmlzaGVkV29yay5zdGF0ZU5vZGUuY29udGFpbmVySW5mbyk7XG4gICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290ID0gX3ByZXZpb3VzSG9pc3RhYmxlUm9vdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlTXV0YXRpb25FZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICBpZiAoc3VwcG9ydHNQZXJzaXN0ZW5jZSkge1xuICAgICAgICAgICAgdmFyIHBvcnRhbCA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG4gICAgICAgICAgICB2YXIgX2NvbnRhaW5lckluZm8gPSBwb3J0YWwuY29udGFpbmVySW5mbztcbiAgICAgICAgICAgIHZhciBfcGVuZGluZ0NoaWxkcmVuID0gcG9ydGFsLnBlbmRpbmdDaGlsZHJlbjtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgcmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuKF9jb250YWluZXJJbmZvLCBfcGVuZGluZ0NoaWxkcmVuKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgY29tbWl0UmVjb25jaWxpYXRpb25FZmZlY3RzKGZpbmlzaGVkV29yayk7IC8vIFRPRE86IFdlIHNob3VsZCBtYXJrIGEgZmxhZyBvbiB0aGUgU3VzcGVuc2UgZmliZXIgaXRzZWxmLCByYXRoZXIgdGhhblxuICAgICAgICAvLyByZWx5aW5nIG9uIHRoZSBPZmZzY3JlZW4gZmliZXIgaGF2aW5nIGEgZmxhZyBhbHNvIGJlaW5nIG1hcmtlZC4gVGhlXG4gICAgICAgIC8vIHJlYXNvbiBpcyB0aGF0IHRoaXMgb2Zmc2NyZWVuIGZpYmVyIG1pZ2h0IG5vdCBiZSBwYXJ0IG9mIHRoZSB3b3JrLWluLVxuICAgICAgICAvLyBwcm9ncmVzcyB0cmVlISBJdCBjb3VsZCBoYXZlIGJlZW4gcmV1c2VkIGZyb20gYSBwcmV2aW91cyByZW5kZXIuIFRoaXNcbiAgICAgICAgLy8gZG9lc24ndCBsZWFkIHRvIGluY29ycmVjdCBiZWhhdmlvciBiZWNhdXNlIHdlIGRvbid0IHJlbHkgb24gdGhlIGZsYWdcbiAgICAgICAgLy8gY2hlY2sgYWxvbmU7IHdlIGFsc28gY29tcGFyZSB0aGUgc3RhdGVzIGV4cGxpY2l0bHkgYmVsb3cuIEJ1dCBmb3JcbiAgICAgICAgLy8gbW9kZWxpbmcgcHVycG9zZXMsIHdlIF9zaG91bGRfIGJlIGFibGUgdG8gcmVseSBvbiB0aGUgZmxhZyBjaGVjayBhbG9uZS5cbiAgICAgICAgLy8gU28gdGhpcyBpcyBhIGJpdCBmcmFnaWxlLlxuICAgICAgICAvL1xuICAgICAgICAvLyBBbHNvLCBhbGwgdGhpcyBsb2dpYyBjb3VsZC9zaG91bGQgbW92ZSB0byB0aGUgcGFzc2l2ZSBwaGFzZSBzbyBpdFxuICAgICAgICAvLyBkb2Vzbid0IGJsb2NrIHBhaW50LlxuXG4gICAgICAgIHZhciBvZmZzY3JlZW5GaWJlciA9IGZpbmlzaGVkV29yay5jaGlsZDtcblxuICAgICAgICBpZiAob2Zmc2NyZWVuRmliZXIuZmxhZ3MgJiBWaXNpYmlsaXR5KSB7XG4gICAgICAgICAgLy8gVGhyb3R0bGUgdGhlIGFwcGVhcmFuY2UgYW5kIGRpc2FwcGVhcmFuY2Ugb2YgU3VzcGVuc2UgZmFsbGJhY2tzLlxuICAgICAgICAgIHZhciBpc1Nob3dpbmdGYWxsYmFjayA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuICAgICAgICAgIHZhciB3YXNTaG93aW5nRmFsbGJhY2sgPSBjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChpc1Nob3dpbmdGYWxsYmFjayAhPT0gd2FzU2hvd2luZ0ZhbGxiYWNrKSB7XG4gICAgICAgICAgICAgIC8vIEEgZmFsbGJhY2sgaXMgZWl0aGVyIGFwcGVhcmluZyBvciBkaXNhcHBlYXJpbmcuXG4gICAgICAgICAgICAgIG1hcmtDb21taXRUaW1lT2ZGYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb21taXRTdXNwZW5zZUNhbGxiYWNrKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciByZXRyeVF1ZXVlID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgICAgaWYgKHJldHJ5UXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgICAgICAgICBhdHRhY2hTdXNwZW5zZVJldHJ5TGlzdGVuZXJzKGZpbmlzaGVkV29yaywgcmV0cnlRdWV1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGlmIChmbGFncyAmIFJlZikge1xuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBzYWZlbHlEZXRhY2hSZWYoY3VycmVudCwgY3VycmVudC5yZXR1cm4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBuZXdTdGF0ZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlO1xuICAgICAgICB2YXIgaXNIaWRkZW4gPSBuZXdTdGF0ZSAhPT0gbnVsbDtcbiAgICAgICAgdmFyIHdhc0hpZGRlbiA9IGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuXG4gICAgICAgIHtcbiAgICAgICAgICAvLyBCZWZvcmUgY29tbWl0dGluZyB0aGUgY2hpbGRyZW4sIHRyYWNrIG9uIHRoZSBzdGFjayB3aGV0aGVyIHRoaXNcbiAgICAgICAgICAvLyBvZmZzY3JlZW4gc3VidHJlZSB3YXMgYWxyZWFkeSBoaWRkZW4sIHNvIHRoYXQgd2UgZG9uJ3QgdW5tb3VudCB0aGVcbiAgICAgICAgICAvLyBlZmZlY3RzIGFnYWluLlxuICAgICAgICAgIHZhciBwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuO1xuICAgICAgICAgIHZhciBwcmV2T2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiA9IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gcHJldk9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiB8fCBpc0hpZGRlbjtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4gfHwgd2FzSGlkZGVuO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMocm9vdCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICBvZmZzY3JlZW5TdWJ0cmVlV2FzSGlkZGVuID0gcHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47XG4gICAgICAgICAgb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuID0gcHJldk9mZnNjcmVlblN1YnRyZWVJc0hpZGRlbjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICB2YXIgb2Zmc2NyZWVuSW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlOyAvLyBUT0RPOiBBZGQgZXhwbGljaXQgZWZmZWN0IGZsYWcgdG8gc2V0IF9jdXJyZW50LlxuXG4gICAgICAgIG9mZnNjcmVlbkluc3RhbmNlLl9jdXJyZW50ID0gZmluaXNoZWRXb3JrOyAvLyBPZmZzY3JlZW4gc3RvcmVzIHBlbmRpbmcgY2hhbmdlcyB0byB2aXNpYmlsaXR5IGluIGBfcGVuZGluZ1Zpc2liaWxpdHlgLiBUaGlzIGlzXG4gICAgICAgIC8vIHRvIHN1cHBvcnQgYmF0Y2hpbmcgb2YgYGF0dGFjaGAgYW5kIGBkZXRhY2hgIGNhbGxzLlxuXG4gICAgICAgIG9mZnNjcmVlbkluc3RhbmNlLl92aXNpYmlsaXR5ICY9IH5PZmZzY3JlZW5EZXRhY2hlZDtcbiAgICAgICAgb2Zmc2NyZWVuSW5zdGFuY2UuX3Zpc2liaWxpdHkgfD0gb2Zmc2NyZWVuSW5zdGFuY2UuX3BlbmRpbmdWaXNpYmlsaXR5ICYgT2Zmc2NyZWVuRGV0YWNoZWQ7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgVmlzaWJpbGl0eSkge1xuICAgICAgICAgIC8vIFRyYWNrIHRoZSBjdXJyZW50IHN0YXRlIG9uIHRoZSBPZmZzY3JlZW4gaW5zdGFuY2Ugc28gd2UgY2FuXG4gICAgICAgICAgLy8gcmVhZCBpdCBkdXJpbmcgYW4gZXZlbnRcbiAgICAgICAgICBpZiAoaXNIaWRkZW4pIHtcbiAgICAgICAgICAgIG9mZnNjcmVlbkluc3RhbmNlLl92aXNpYmlsaXR5ICY9IH5PZmZzY3JlZW5WaXNpYmxlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBvZmZzY3JlZW5JbnN0YW5jZS5fdmlzaWJpbGl0eSB8PSBPZmZzY3JlZW5WaXNpYmxlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChpc0hpZGRlbikge1xuICAgICAgICAgICAgdmFyIGlzVXBkYXRlID0gY3VycmVudCAhPT0gbnVsbDtcbiAgICAgICAgICAgIHZhciB3YXNIaWRkZW5CeUFuY2VzdG9yT2Zmc2NyZWVuID0gb2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuIHx8IG9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW47IC8vIE9ubHkgdHJpZ2dlciBkaXNhcHBlciBsYXlvdXQgZWZmZWN0cyBpZjpcbiAgICAgICAgICAgIC8vICAgLSBUaGlzIGlzIGFuIHVwZGF0ZSwgbm90IGZpcnN0IG1vdW50LlxuICAgICAgICAgICAgLy8gICAtIFRoaXMgT2Zmc2NyZWVuIHdhcyBub3QgaGlkZGVuIGJlZm9yZS5cbiAgICAgICAgICAgIC8vICAgLSBBbmNlc3RvciBPZmZzY3JlZW4gd2FzIG5vdCBoaWRkZW4gaW4gcHJldmlvdXMgY29tbWl0LlxuXG4gICAgICAgICAgICBpZiAoaXNVcGRhdGUgJiYgIXdhc0hpZGRlbiAmJiAhd2FzSGlkZGVuQnlBbmNlc3Rvck9mZnNjcmVlbikge1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgLy8gRGlzYXBwZWFyIHRoZSBsYXlvdXQgZWZmZWN0cyBvZiBhbGwgdGhlIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gLy8gT2Zmc2NyZWVuIHdpdGggbWFudWFsIG1vZGUgbWFuYWdlcyB2aXNpYmlsaXR5IG1hbnVhbGx5LlxuXG5cbiAgICAgICAgICBpZiAoc3VwcG9ydHNNdXRhdGlvbiAmJiAhaXNPZmZzY3JlZW5NYW51YWwoZmluaXNoZWRXb3JrKSkge1xuICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBuZWVkcyB0byBydW4gd2hlbmV2ZXIgdGhlcmUncyBhbiBpbnNlcnRpb24gb3IgdXBkYXRlXG4gICAgICAgICAgICAvLyBpbnNpZGUgYSBoaWRkZW4gT2Zmc2NyZWVuIHRyZWUuXG4gICAgICAgICAgICBoaWRlT3JVbmhpZGVBbGxDaGlsZHJlbihmaW5pc2hlZFdvcmssIGlzSGlkZGVuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gVE9ETzogTW92ZSB0byBwYXNzaXZlIHBoYXNlXG5cblxuICAgICAgICBpZiAoZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICB2YXIgb2Zmc2NyZWVuUXVldWUgPSBmaW5pc2hlZFdvcmsudXBkYXRlUXVldWU7XG5cbiAgICAgICAgICBpZiAob2Zmc2NyZWVuUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBfcmV0cnlRdWV1ZSA9IG9mZnNjcmVlblF1ZXVlLnJldHJ5UXVldWU7XG5cbiAgICAgICAgICAgIGlmIChfcmV0cnlRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICBvZmZzY3JlZW5RdWV1ZS5yZXRyeVF1ZXVlID0gbnVsbDtcbiAgICAgICAgICAgICAgYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyhmaW5pc2hlZFdvcmssIF9yZXRyeVF1ZXVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlTGlzdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcblxuICAgICAgICBpZiAoZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICB2YXIgX3JldHJ5UXVldWUyID0gZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlO1xuXG4gICAgICAgICAgaWYgKF9yZXRyeVF1ZXVlMiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgZmluaXNoZWRXb3JrLnVwZGF0ZVF1ZXVlID0gbnVsbDtcbiAgICAgICAgICAgIGF0dGFjaFN1c3BlbnNlUmV0cnlMaXN0ZW5lcnMoZmluaXNoZWRXb3JrLCBfcmV0cnlRdWV1ZTIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgIGNhc2UgU2NvcGVDb21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICBjb21taXRSZWNvbmNpbGlhdGlvbkVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyhmaW5pc2hlZFdvcmspIHtcbiAgLy8gUGxhY2VtZW50IGVmZmVjdHMgKGluc2VydGlvbnMsIHJlb3JkZXJzKSBjYW4gYmUgc2NoZWR1bGVkIG9uIGFueSBmaWJlclxuICAvLyB0eXBlLiBUaGV5IG5lZWRzIHRvIGhhcHBlbiBhZnRlciB0aGUgY2hpbGRyZW4gZWZmZWN0cyBoYXZlIGZpcmVkLCBidXRcbiAgLy8gYmVmb3JlIHRoZSBlZmZlY3RzIG9uIHRoaXMgZmliZXIgaGF2ZSBmaXJlZC5cbiAgdmFyIGZsYWdzID0gZmluaXNoZWRXb3JrLmZsYWdzO1xuXG4gIGlmIChmbGFncyAmIFBsYWNlbWVudCkge1xuICAgIHRyeSB7XG4gICAgICBjb21taXRQbGFjZW1lbnQoZmluaXNoZWRXb3JrKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgfSAvLyBDbGVhciB0aGUgXCJwbGFjZW1lbnRcIiBmcm9tIGVmZmVjdCB0YWcgc28gdGhhdCB3ZSBrbm93IHRoYXQgdGhpcyBpc1xuICAgIC8vIGluc2VydGVkLCBiZWZvcmUgYW55IGxpZmUtY3ljbGVzIGxpa2UgY29tcG9uZW50RGlkTW91bnQgZ2V0cyBjYWxsZWQuXG4gICAgLy8gVE9ETzogZmluZERPTU5vZGUgZG9lc24ndCByZWx5IG9uIHRoaXMgYW55IG1vcmUgYnV0IGlzTW91bnRlZCBkb2VzXG4gICAgLy8gYW5kIGlzTW91bnRlZCBpcyBkZXByZWNhdGVkIGFueXdheSBzbyB3ZSBzaG91bGQgYmUgYWJsZSB0byBraWxsIHRoaXMuXG5cblxuICAgIGZpbmlzaGVkV29yay5mbGFncyAmPSB+UGxhY2VtZW50O1xuICB9XG5cbiAgaWYgKGZsYWdzICYgSHlkcmF0aW5nKSB7XG4gICAgZmluaXNoZWRXb3JrLmZsYWdzICY9IH5IeWRyYXRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjdXJzaXZlbHlSZXNldEZvcm1zKHBhcmVudEZpYmVyKSB7XG4gIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiBGb3JtUmVzZXQpIHtcbiAgICB2YXIgY2hpbGQgPSBwYXJlbnRGaWJlci5jaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgcmVzZXRGb3JtT25GaWJlcihjaGlsZCk7XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlc2V0Rm9ybU9uRmliZXIoZmliZXIpIHtcbiAgcmVjdXJzaXZlbHlSZXNldEZvcm1zKGZpYmVyKTtcblxuICBpZiAoZmliZXIudGFnID09PSBIb3N0Q29tcG9uZW50ICYmIGZpYmVyLmZsYWdzICYgRm9ybVJlc2V0KSB7XG4gICAgdmFyIGZvcm1JbnN0YW5jZSA9IGZpYmVyLnN0YXRlTm9kZTtcbiAgICByZXNldEZvcm1JbnN0YW5jZShmb3JtSW5zdGFuY2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdExheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrLCByb290LCBjb21taXR0ZWRMYW5lcykge1xuICBpblByb2dyZXNzTGFuZXMgPSBjb21taXR0ZWRMYW5lcztcbiAgaW5Qcm9ncmVzc1Jvb3QgPSByb290O1xuICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKGZpbmlzaGVkV29yayk7XG4gIHZhciBjdXJyZW50ID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZTtcbiAgY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlcihyb290LCBjdXJyZW50LCBmaW5pc2hlZFdvcmspO1xuICByZXNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoKTtcbiAgaW5Qcm9ncmVzc0xhbmVzID0gbnVsbDtcbiAgaW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlTGF5b3V0RWZmZWN0cyhyb290LCBwYXJlbnRGaWJlciwgbGFuZXMpIHtcbiAgdmFyIHByZXZEZWJ1Z0ZpYmVyID0gZ2V0Q3VycmVudEZpYmVyKCk7XG5cbiAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIExheW91dE1hc2spIHtcbiAgICB2YXIgY2hpbGQgPSBwYXJlbnRGaWJlci5jaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihjaGlsZCk7XG4gICAgICB2YXIgY3VycmVudCA9IGNoaWxkLmFsdGVybmF0ZTtcbiAgICAgIGNvbW1pdExheW91dEVmZmVjdE9uRmliZXIocm9vdCwgY3VycmVudCwgY2hpbGQpO1xuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYocHJldkRlYnVnRmliZXIpO1xufVxuXG5mdW5jdGlvbiBkaXNhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkV29yaykge1xuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIE1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICAvLyBUT0RPIChPZmZzY3JlZW4pIENoZWNrOiBmbGFncyAmIExheW91dFN0YXRpY1xuICAgICAgICBpZiAoc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHN0YXJ0TGF5b3V0RWZmZWN0VGltZXIoKTtcbiAgICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChMYXlvdXQsIGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHJlY29yZExheW91dEVmZmVjdER1cmF0aW9uKGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChMYXlvdXQsIGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgIH1cblxuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIC8vIFRPRE8gKE9mZnNjcmVlbikgQ2hlY2s6IGZsYWdzICYgUmVmU3RhdGljXG4gICAgICAgIHNhZmVseURldGFjaFJlZihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4pO1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2UuY29tcG9uZW50V2lsbFVubW91bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBzYWZlbHlDYWxsQ29tcG9uZW50V2lsbFVubW91bnQoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBpbnN0YW5jZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdEhvaXN0YWJsZTpcbiAgICBjYXNlIEhvc3RTaW5nbGV0b246XG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICAvLyBUT0RPIChPZmZzY3JlZW4pIENoZWNrOiBmbGFncyAmIFJlZlN0YXRpY1xuICAgICAgICBzYWZlbHlEZXRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2FwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gVE9ETyAoT2Zmc2NyZWVuKSBDaGVjazogZmxhZ3MgJiBSZWZTdGF0aWNcbiAgICAgICAgc2FmZWx5RGV0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgIHZhciBpc0hpZGRlbiA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlICE9PSBudWxsO1xuXG4gICAgICAgIGlmIChpc0hpZGRlbikgOyBlbHNlIHtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhwYXJlbnRGaWJlcikge1xuICAvLyBUT0RPIChPZmZzY3JlZW4pIENoZWNrOiBmbGFncyAmIChSZWZTdGF0aWMgfCBMYXlvdXRTdGF0aWMpXG4gIHZhciBjaGlsZCA9IHBhcmVudEZpYmVyLmNoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgIGRpc2FwcGVhckxheW91dEVmZmVjdHMoY2hpbGQpO1xuICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiByZWFwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBjdXJyZW50LCBmaW5pc2hlZFdvcmssIC8vIFRoaXMgZnVuY3Rpb24gdmlzaXRzIGJvdGggbmV3bHkgZmluaXNoZWQgd29yayBhbmQgbm9kZXMgdGhhdCB3ZXJlIHJlLXVzZWRcbi8vIGZyb20gYSBwcmV2aW91c2x5IGNvbW1pdHRlZCB0cmVlLiBXZSBjYW5ub3QgY2hlY2sgbm9uLXN0YXRpYyBmbGFncyBpZiB0aGVcbi8vIG5vZGUgd2FzIHJldXNlZC5cbmluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMpIHtcbiAgLy8gVHVybiBvbiBsYXlvdXQgZWZmZWN0cyBpbiBhIHRyZWUgdGhhdCBwcmV2aW91c2x5IGRpc2FwcGVhcmVkLlxuICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG5cbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzKTsgLy8gVE9ETzogQ2hlY2sgZmxhZ3MgJiBMYXlvdXRTdGF0aWNcblxuICAgICAgICBjb21taXRIb29rTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFdvcmssIExheW91dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyk7IC8vIFRPRE86IENoZWNrIGZvciBMYXlvdXRTdGF0aWMgZmxhZ1xuXG4gICAgICAgIHZhciBpbnN0YW5jZSA9IGZpbmlzaGVkV29yay5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpbnN0YW5jZS5jb21wb25lbnREaWRNb3VudCgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihmaW5pc2hlZFdvcmssIGZpbmlzaGVkV29yay5yZXR1cm4sIGVycm9yKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gLy8gQ29tbWl0IGFueSBjYWxsYmFja3MgdGhhdCB3b3VsZCBoYXZlIGZpcmVkIHdoaWxlIHRoZSBjb21wb25lbnRcbiAgICAgICAgLy8gd2FzIGhpZGRlbi5cblxuXG4gICAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IGZpbmlzaGVkV29yay51cGRhdGVRdWV1ZTtcblxuICAgICAgICBpZiAodXBkYXRlUXVldWUgIT09IG51bGwpIHtcbiAgICAgICAgICBjb21taXRIaWRkZW5DYWxsYmFja3ModXBkYXRlUXVldWUsIGluc3RhbmNlKTtcbiAgICAgICAgfSAvLyBJZiB0aGlzIGlzIG5ld2x5IGZpbmlzaGVkIHdvcmssIGNoZWNrIGZvciBzZXRTdGF0ZSBjYWxsYmFja3NcblxuXG4gICAgICAgIGlmIChpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmIGZsYWdzICYgQ2FsbGJhY2spIHtcbiAgICAgICAgICBjb21taXRDbGFzc0NhbGxiYWNrcyhmaW5pc2hlZFdvcmspO1xuICAgICAgICB9IC8vIFRPRE86IENoZWNrIGZsYWdzICYgUmVmU3RhdGljXG5cblxuICAgICAgICBzYWZlbHlBdHRhY2hSZWYoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgLy8gVW5saWtlIGNvbW1pdExheW91dEVmZmVjdHNPbkZpYmVyLCB3ZSBkb24ndCBuZWVkIHRvIGhhbmRsZSBIb3N0Um9vdFxuICAgIC8vIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiBvbmx5IHZpc2l0cyBub2RlcyB0aGF0IGFyZSBpbnNpZGUgYW5cbiAgICAvLyBPZmZzY3JlZW4gZmliZXIuXG4gICAgLy8gY2FzZSBIb3N0Um9vdDoge1xuICAgIC8vICAuLi5cbiAgICAvLyB9XG5cbiAgICBjYXNlIEhvc3RIb2lzdGFibGU6XG4gICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyk7IC8vIFJlbmRlcmVycyBtYXkgc2NoZWR1bGUgd29yayB0byBiZSBkb25lIGFmdGVyIGhvc3QgY29tcG9uZW50cyBhcmUgbW91bnRlZFxuICAgICAgICAvLyAoZWcgRE9NIHJlbmRlcmVyIG1heSBzY2hlZHVsZSBhdXRvLWZvY3VzIGZvciBpbnB1dHMgYW5kIGZvcm0gY29udHJvbHMpLlxuICAgICAgICAvLyBUaGVzZSBlZmZlY3RzIHNob3VsZCBvbmx5IGJlIGNvbW1pdHRlZCB3aGVuIGNvbXBvbmVudHMgYXJlIGZpcnN0IG1vdW50ZWQsXG4gICAgICAgIC8vIGFrYSB3aGVuIHRoZXJlIGlzIG5vIGN1cnJlbnQvYWx0ZXJuYXRlLlxuXG4gICAgICAgIGlmIChpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmIGN1cnJlbnQgPT09IG51bGwgJiYgZmxhZ3MgJiBVcGRhdGUpIHtcbiAgICAgICAgICBjb21taXRIb3N0Q29tcG9uZW50TW91bnQoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfSAvLyBUT0RPOiBDaGVjayBmbGFncyAmIFJlZlxuXG5cbiAgICAgICAgc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBQcm9maWxlcjpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyk7IC8vIFRPRE86IEZpZ3VyZSBvdXQgaG93IFByb2ZpbGVyIHVwZGF0ZXMgc2hvdWxkIHdvcmsgd2l0aCBPZmZzY3JlZW5cblxuICAgICAgICBpZiAoaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJiBmbGFncyAmIFVwZGF0ZSkge1xuICAgICAgICAgIGNvbW1pdFByb2ZpbGVyVXBkYXRlKGZpbmlzaGVkV29yaywgY3VycmVudCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMpOyAvLyBUT0RPOiBGaWd1cmUgb3V0IGhvdyBTdXNwZW5zZSBoeWRyYXRpb24gY2FsbGJhY2tzIHNob3VsZCB3b3JrXG4gICAgICAgIC8vIHdpdGggT2Zmc2NyZWVuLlxuXG4gICAgICAgIGlmIChpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmIGZsYWdzICYgVXBkYXRlKSB7XG4gICAgICAgICAgY29tbWl0U3VzcGVuc2VIeWRyYXRpb25DYWxsYmFja3MoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIG9mZnNjcmVlblN0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHZhciBpc0hpZGRlbiA9IG9mZnNjcmVlblN0YXRlICE9PSBudWxsO1xuXG4gICAgICAgIGlmIChpc0hpZGRlbikgOyBlbHNlIHtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVhcHBlYXJMYXlvdXRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzKTtcbiAgICAgICAgfSAvLyBUT0RPOiBDaGVjayBmbGFncyAmIFJlZlxuXG5cbiAgICAgICAgc2FmZWx5QXR0YWNoUmVmKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWFwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBwYXJlbnRGaWJlciwgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cykge1xuICAvLyBUaGlzIGZ1bmN0aW9uIHZpc2l0cyBib3RoIG5ld2x5IGZpbmlzaGVkIHdvcmsgYW5kIG5vZGVzIHRoYXQgd2VyZSByZS11c2VkXG4gIC8vIGZyb20gYSBwcmV2aW91c2x5IGNvbW1pdHRlZCB0cmVlLiBXZSBjYW5ub3QgY2hlY2sgbm9uLXN0YXRpYyBmbGFncyBpZiB0aGVcbiAgLy8gbm9kZSB3YXMgcmV1c2VkLlxuICB2YXIgY2hpbGRTaG91bGRJbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzID0gaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgTGF5b3V0TWFzaykgIT09IE5vRmxhZ3MkMTsgLy8gVE9ETyAoT2Zmc2NyZWVuKSBDaGVjazogZmxhZ3MgJiAoUmVmU3RhdGljIHwgTGF5b3V0U3RhdGljKVxuXG4gIHZhciBwcmV2RGVidWdGaWJlciA9IGdldEN1cnJlbnRGaWJlcigpO1xuICB2YXIgY2hpbGQgPSBwYXJlbnRGaWJlci5jaGlsZDtcblxuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICB2YXIgY3VycmVudCA9IGNoaWxkLmFsdGVybmF0ZTtcbiAgICByZWFwcGVhckxheW91dEVmZmVjdHMoZmluaXNoZWRSb290LCBjdXJyZW50LCBjaGlsZCwgY2hpbGRTaG91bGRJbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzKTtcbiAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gIH1cblxuICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKHByZXZEZWJ1Z0ZpYmVyKTtcbn1cblxuZnVuY3Rpb24gY29tbWl0SG9va1Bhc3NpdmVNb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrLCBob29rRmxhZ3MpIHtcbiAgaWYgKHNob3VsZFByb2ZpbGUoZmluaXNoZWRXb3JrKSkge1xuICAgIHN0YXJ0UGFzc2l2ZUVmZmVjdFRpbWVyKCk7XG5cbiAgICB0cnkge1xuICAgICAgY29tbWl0SG9va0VmZmVjdExpc3RNb3VudChob29rRmxhZ3MsIGZpbmlzaGVkV29yayk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgZXJyb3IpO1xuICAgIH1cblxuICAgIHJlY29yZFBhc3NpdmVFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO1xuICB9IGVsc2Uge1xuICAgIHRyeSB7XG4gICAgICBjb21taXRIb29rRWZmZWN0TGlzdE1vdW50KGhvb2tGbGFncywgZmluaXNoZWRXb3JrKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY2FwdHVyZUNvbW1pdFBoYXNlRXJyb3IoZmluaXNoZWRXb3JrLCBmaW5pc2hlZFdvcmsucmV0dXJuLCBlcnJvcik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdE9mZnNjcmVlblBhc3NpdmVNb3VudEVmZmVjdHMoY3VycmVudCwgZmluaXNoZWRXb3JrLCBpbnN0YW5jZSkge1xuICB7XG4gICAgdmFyIHByZXZpb3VzQ2FjaGUgPSBudWxsO1xuXG4gICAgaWYgKGN1cnJlbnQgIT09IG51bGwgJiYgY3VycmVudC5tZW1vaXplZFN0YXRlICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgIT09IG51bGwpIHtcbiAgICAgIHByZXZpb3VzQ2FjaGUgPSBjdXJyZW50Lm1lbW9pemVkU3RhdGUuY2FjaGVQb29sLnBvb2w7XG4gICAgfVxuXG4gICAgdmFyIG5leHRDYWNoZSA9IG51bGw7XG5cbiAgICBpZiAoZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUgIT09IG51bGwgJiYgZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUuY2FjaGVQb29sICE9PSBudWxsKSB7XG4gICAgICBuZXh0Q2FjaGUgPSBmaW5pc2hlZFdvcmsubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbDtcbiAgICB9IC8vIFJldGFpbi9yZWxlYXNlIHRoZSBjYWNoZSB1c2VkIGZvciBwZW5kaW5nIChzdXNwZW5kZWQpIG5vZGVzLlxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIGlzIG9ubHkgcmVhY2hlZCBpbiB0aGUgbm9uLXN1c3BlbmRlZC92aXNpYmxlIGNhc2U6XG4gICAgLy8gd2hlbiB0aGUgY29udGVudCBpcyBzdXNwZW5kZWQvaGlkZGVuLCB0aGUgcmV0YWluL3JlbGVhc2Ugb2NjdXJzXG4gICAgLy8gdmlhIHRoZSBwYXJlbnQgU3VzcGVuc2UgY29tcG9uZW50IChzZWUgY2FzZSBhYm92ZSkuXG5cblxuICAgIGlmIChuZXh0Q2FjaGUgIT09IHByZXZpb3VzQ2FjaGUpIHtcbiAgICAgIGlmIChuZXh0Q2FjaGUgIT0gbnVsbCkge1xuICAgICAgICByZXRhaW5DYWNoZShuZXh0Q2FjaGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJldmlvdXNDYWNoZSAhPSBudWxsKSB7XG4gICAgICAgIHJlbGVhc2VDYWNoZShwcmV2aW91c0NhY2hlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0Q2FjaGVQYXNzaXZlTW91bnRFZmZlY3QoY3VycmVudCwgZmluaXNoZWRXb3JrKSB7XG4gIHtcbiAgICB2YXIgcHJldmlvdXNDYWNoZSA9IG51bGw7XG5cbiAgICBpZiAoZmluaXNoZWRXb3JrLmFsdGVybmF0ZSAhPT0gbnVsbCkge1xuICAgICAgcHJldmlvdXNDYWNoZSA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZS5jYWNoZTtcbiAgICB9XG5cbiAgICB2YXIgbmV4dENhY2hlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGUuY2FjaGU7IC8vIFJldGFpbi9yZWxlYXNlIHRoZSBjYWNoZS4gSW4gdGhlb3J5IHRoZSBjYWNoZSBjb21wb25lbnRcbiAgICAvLyBjb3VsZCBiZSBcImJvcnJvd2luZ1wiIGEgY2FjaGUgaW5zdGFuY2Ugb3duZWQgYnkgc29tZSBwYXJlbnQsXG4gICAgLy8gaW4gd2hpY2ggY2FzZSB3ZSBjb3VsZCBhdm9pZCByZXRhaW5pbmcvcmVsZWFzaW5nLiBCdXQgaXRcbiAgICAvLyBpcyBub24tdHJpdmlhbCB0byBkZXRlcm1pbmUgd2hlbiB0aGF0IGlzIHRoZSBjYXNlLCBzbyB3ZVxuICAgIC8vIGFsd2F5cyByZXRhaW4vcmVsZWFzZS5cblxuICAgIGlmIChuZXh0Q2FjaGUgIT09IHByZXZpb3VzQ2FjaGUpIHtcbiAgICAgIHJldGFpbkNhY2hlKG5leHRDYWNoZSk7XG5cbiAgICAgIGlmIChwcmV2aW91c0NhY2hlICE9IG51bGwpIHtcbiAgICAgICAgcmVsZWFzZUNhY2hlKHByZXZpb3VzQ2FjaGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzKHJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zKSB7XG4gIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoZmluaXNoZWRXb3JrKTtcbiAgY29tbWl0UGFzc2l2ZU1vdW50T25GaWJlcihyb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucyk7XG4gIHJlc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVigpO1xufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhyb290LCBwYXJlbnRGaWJlciwgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zKSB7XG4gIHZhciBwcmV2RGVidWdGaWJlciA9IGdldEN1cnJlbnRGaWJlcigpO1xuXG4gIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiBQYXNzaXZlTWFzaykge1xuICAgIHZhciBjaGlsZCA9IHBhcmVudEZpYmVyLmNoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKGNoaWxkKTtcbiAgICAgIGNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIocm9vdCwgY2hpbGQsIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucyk7XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihwcmV2RGVidWdGaWJlcik7XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFBhc3NpdmVNb3VudE9uRmliZXIoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucykge1xuICAvLyBXaGVuIHVwZGF0aW5nIHRoaXMgZnVuY3Rpb24sIGFsc28gdXBkYXRlIHJlY29ubmVjdFBhc3NpdmVFZmZlY3RzLCB3aGljaCBkb2VzXG4gIC8vIG1vc3Qgb2YgdGhlIHNhbWUgdGhpbmdzIHdoZW4gYW4gb2Zmc2NyZWVuIHRyZWUgZ29lcyBmcm9tIGhpZGRlbiAtPiB2aXNpYmxlLFxuICAvLyBvciB3aGVuIHRvZ2dsaW5nIGVmZmVjdHMgaW5zaWRlIGEgaGlkZGVuIHRyZWUuXG4gIHZhciBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcblxuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMpO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFBhc3NpdmUkMSkge1xuICAgICAgICAgIGNvbW1pdEhvb2tQYXNzaXZlTW91bnRFZmZlY3RzKGZpbmlzaGVkV29yaywgUGFzc2l2ZSB8IEhhc0VmZmVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlTW91bnRFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMpO1xuXG4gICAgICAgIGlmIChmbGFncyAmIFBhc3NpdmUkMSkge1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciBwcmV2aW91c0NhY2hlID0gbnVsbDtcblxuICAgICAgICAgICAgaWYgKGZpbmlzaGVkV29yay5hbHRlcm5hdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcHJldmlvdXNDYWNoZSA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGUubWVtb2l6ZWRTdGF0ZS5jYWNoZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG5leHRDYWNoZSA9IGZpbmlzaGVkV29yay5tZW1vaXplZFN0YXRlLmNhY2hlOyAvLyBSZXRhaW4vcmVsZWFzZSB0aGUgcm9vdCBjYWNoZS5cbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBvbiBpbml0aWFsIG1vdW50LCBwcmV2aW91c0NhY2hlIGFuZCBuZXh0Q2FjaGUgd2lsbCBiZSB0aGUgc2FtZVxuICAgICAgICAgICAgLy8gYW5kIHRoaXMgcmV0YWluIHdvbid0IG9jY3VyLiBUbyBjb3VudGVyIHRoaXMsIHdlIGluc3RlYWQgcmV0YWluIHRoZSBIb3N0Um9vdCdzXG4gICAgICAgICAgICAvLyBpbml0aWFsIGNhY2hlIHdoZW4gY3JlYXRpbmcgdGhlIHJvb3QgaXRzZWxmIChzZWUgY3JlYXRlRmliZXJSb290KCkgaW5cbiAgICAgICAgICAgIC8vIFJlYWN0RmliZXJSb290LmpzKS4gU3Vic2VxdWVudCB1cGRhdGVzIHRoYXQgY2hhbmdlIHRoZSBjYWNoZSBhcmUgcmVmbGVjdGVkXG4gICAgICAgICAgICAvLyBoZXJlLCBzdWNoIHRoYXQgcHJldmlvdXMvbmV4dCBjYWNoZXMgYXJlIHJldGFpbmVkIGNvcnJlY3RseS5cblxuICAgICAgICAgICAgaWYgKG5leHRDYWNoZSAhPT0gcHJldmlvdXNDYWNoZSkge1xuICAgICAgICAgICAgICByZXRhaW5DYWNoZShuZXh0Q2FjaGUpO1xuXG4gICAgICAgICAgICAgIGlmIChwcmV2aW91c0NhY2hlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZWxlYXNlQ2FjaGUocHJldmlvdXNDYWNoZSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgTGVnYWN5SGlkZGVuQ29tcG9uZW50OlxuICAgICAge1xuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIC8vIFRPRE86IFBhc3MgYGN1cnJlbnRgIGFzIGFyZ3VtZW50IHRvIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgdmFyIF9pbnN0YW5jZTMgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICB2YXIgbmV4dFN0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHZhciBpc0hpZGRlbiA9IG5leHRTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgICBpZiAoaXNIaWRkZW4pIHtcbiAgICAgICAgICBpZiAoX2luc3RhbmNlMy5fdmlzaWJpbGl0eSAmIE9mZnNjcmVlblBhc3NpdmVFZmZlY3RzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICAvLyBUaGUgZWZmZWN0cyBhcmUgY3VycmVudGx5IGNvbm5lY3RlZC4gVXBkYXRlIHRoZW0uXG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZU1vdW50RWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyBUaGUgZWZmZWN0cyBhcmUgY3VycmVudGx5IGRpc2Nvbm5lY3RlZC4gU2luY2UgdGhlIHRyZWUgaXMgaGlkZGVuLFxuICAgICAgICAgICAgICAvLyBkb24ndCBjb25uZWN0IHRoZW0uIFRoaXMgYWxzbyBhcHBsaWVzIHRvIHRoZSBpbml0aWFsIHJlbmRlci5cbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIC8vIFwiQXRvbWljXCIgZWZmZWN0cyBhcmUgb25lcyB0aGF0IG5lZWQgdG8gZmlyZSBvbiBldmVyeSBjb21taXQsXG4gICAgICAgICAgICAgICAgLy8gZXZlbiBkdXJpbmcgcHJlLXJlbmRlcmluZy4gQW4gZXhhbXBsZSBpcyB1cGRhdGluZyB0aGUgcmVmZXJlbmNlXG4gICAgICAgICAgICAgICAgLy8gY291bnQgb24gY2FjaGUgaW5zdGFuY2VzLlxuICAgICAgICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBdG9taWNQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yayk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVHJlZSBpcyB2aXNpYmxlXG4gICAgICAgICAgaWYgKF9pbnN0YW5jZTMuX3Zpc2liaWxpdHkgJiBPZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgLy8gVGhlIGVmZmVjdHMgYXJlIGN1cnJlbnRseSBjb25uZWN0ZWQuIFVwZGF0ZSB0aGVtLlxuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRoZSBlZmZlY3RzIGFyZSBjdXJyZW50bHkgZGlzY29ubmVjdGVkLiBSZWNvbm5lY3QgdGhlbSwgd2hpbGUgYWxzb1xuICAgICAgICAgICAgLy8gZmlyaW5nIGVmZmVjdHMgaW5zaWRlIG5ld2x5IG1vdW50ZWQgdHJlZXMuIFRoaXMgYWxzbyBhcHBsaWVzIHRvXG4gICAgICAgICAgICAvLyB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgICAgICAgICBfaW5zdGFuY2UzLl92aXNpYmlsaXR5IHw9IE9mZnNjcmVlblBhc3NpdmVFZmZlY3RzQ29ubmVjdGVkO1xuICAgICAgICAgICAgdmFyIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgPSAoZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIFBhc3NpdmVNYXNrKSAhPT0gTm9GbGFncyQxO1xuICAgICAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMsIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChmbGFncyAmIFBhc3NpdmUkMSkge1xuICAgICAgICAgIHZhciBfY3VycmVudCA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG4gICAgICAgICAgY29tbWl0T2Zmc2NyZWVuUGFzc2l2ZU1vdW50RWZmZWN0cyhfY3VycmVudCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBDYWNoZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucyk7XG5cbiAgICAgICAgaWYgKGZsYWdzICYgUGFzc2l2ZSQxKSB7XG4gICAgICAgICAgLy8gVE9ETzogUGFzcyBgY3VycmVudGAgYXMgYXJndW1lbnQgdG8gdGhpcyBmdW5jdGlvblxuICAgICAgICAgIHZhciBfY3VycmVudDIgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuICAgICAgICAgIGNvbW1pdENhY2hlUGFzc2l2ZU1vdW50RWZmZWN0KF9jdXJyZW50MiwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBUcmFjaW5nTWFya2VyQ29tcG9uZW50OlxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlY3Vyc2l2ZWx5VHJhdmVyc2VSZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFJvb3QsIHBhcmVudEZpYmVyLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMsIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMpIHtcbiAgLy8gVGhpcyBmdW5jdGlvbiB2aXNpdHMgYm90aCBuZXdseSBmaW5pc2hlZCB3b3JrIGFuZCBub2RlcyB0aGF0IHdlcmUgcmUtdXNlZFxuICAvLyBmcm9tIGEgcHJldmlvdXNseSBjb21taXR0ZWQgdHJlZS4gV2UgY2Fubm90IGNoZWNrIG5vbi1zdGF0aWMgZmxhZ3MgaWYgdGhlXG4gIC8vIG5vZGUgd2FzIHJldXNlZC5cbiAgdmFyIGNoaWxkU2hvdWxkSW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyA9IGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMgJiYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIFBhc3NpdmVNYXNrKSAhPT0gTm9GbGFncyQxOyAvLyBUT0RPIChPZmZzY3JlZW4pIENoZWNrOiBmbGFncyAmIChSZWZTdGF0aWMgfCBMYXlvdXRTdGF0aWMpXG5cbiAgdmFyIHByZXZEZWJ1Z0ZpYmVyID0gZ2V0Q3VycmVudEZpYmVyKCk7XG4gIHZhciBjaGlsZCA9IHBhcmVudEZpYmVyLmNoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgIHJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgY2hpbGQsIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucywgY2hpbGRTaG91bGRJbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzKTtcbiAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gIH1cblxuICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKHByZXZEZWJ1Z0ZpYmVyKTtcbn1cblxuZnVuY3Rpb24gcmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucywgLy8gVGhpcyBmdW5jdGlvbiB2aXNpdHMgYm90aCBuZXdseSBmaW5pc2hlZCB3b3JrIGFuZCBub2RlcyB0aGF0IHdlcmUgcmUtdXNlZFxuLy8gZnJvbSBhIHByZXZpb3VzbHkgY29tbWl0dGVkIHRyZWUuIFdlIGNhbm5vdCBjaGVjayBub24tc3RhdGljIGZsYWdzIGlmIHRoZVxuLy8gbm9kZSB3YXMgcmV1c2VkLlxuaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cykge1xuICB2YXIgZmxhZ3MgPSBmaW5pc2hlZFdvcmsuZmxhZ3M7XG5cbiAgc3dpdGNoIChmaW5pc2hlZFdvcmsudGFnKSB7XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucywgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyk7IC8vIFRPRE86IENoZWNrIGZvciBQYXNzaXZlU3RhdGljIGZsYWdcblxuICAgICAgICBjb21taXRIb29rUGFzc2l2ZU1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmssIFBhc3NpdmUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAvLyBVbmxpa2UgY29tbWl0UGFzc2l2ZU1vdW50T25GaWJlciwgd2UgZG9uJ3QgbmVlZCB0byBoYW5kbGUgSG9zdFJvb3RcbiAgICAvLyBiZWNhdXNlIHRoaXMgZnVuY3Rpb24gb25seSB2aXNpdHMgbm9kZXMgdGhhdCBhcmUgaW5zaWRlIGFuXG4gICAgLy8gT2Zmc2NyZWVuIGZpYmVyLlxuICAgIC8vIGNhc2UgSG9zdFJvb3Q6IHtcbiAgICAvLyAgLi4uXG4gICAgLy8gfVxuXG4gICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgICB7XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgdmFyIF9pbnN0YW5jZTQgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICB2YXIgbmV4dFN0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHZhciBpc0hpZGRlbiA9IG5leHRTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgICBpZiAoaXNIaWRkZW4pIHtcbiAgICAgICAgICBpZiAoX2luc3RhbmNlNC5fdmlzaWJpbGl0eSAmIE9mZnNjcmVlblBhc3NpdmVFZmZlY3RzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgICAvLyBUaGUgZWZmZWN0cyBhcmUgY3VycmVudGx5IGNvbm5lY3RlZC4gVXBkYXRlIHRoZW0uXG4gICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucywgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gVGhlIGVmZmVjdHMgYXJlIGN1cnJlbnRseSBkaXNjb25uZWN0ZWQuIFNpbmNlIHRoZSB0cmVlIGlzIGhpZGRlbixcbiAgICAgICAgICAgICAgLy8gZG9uJ3QgY29ubmVjdCB0aGVtLiBUaGlzIGFsc28gYXBwbGllcyB0byB0aGUgaW5pdGlhbCByZW5kZXIuXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBcIkF0b21pY1wiIGVmZmVjdHMgYXJlIG9uZXMgdGhhdCBuZWVkIHRvIGZpcmUgb24gZXZlcnkgY29tbWl0LFxuICAgICAgICAgICAgICAgIC8vIGV2ZW4gZHVyaW5nIHByZS1yZW5kZXJpbmcuIEFuIGV4YW1wbGUgaXMgdXBkYXRpbmcgdGhlIHJlZmVyZW5jZVxuICAgICAgICAgICAgICAgIC8vIGNvdW50IG9uIGNhY2hlIGluc3RhbmNlcy5cbiAgICAgICAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFRyZWUgaXMgdmlzaWJsZVxuICAgICAgICAgIC8vIFNpbmNlIHdlJ3JlIGFscmVhZHkgaW5zaWRlIGEgcmVjb25uZWN0aW5nIHRyZWUsIGl0IGRvZXNuJ3QgbWF0dGVyXG4gICAgICAgICAgLy8gd2hldGhlciB0aGUgZWZmZWN0cyBhcmUgY3VycmVudGx5IGNvbm5lY3RlZC4gSW4gZWl0aGVyIGNhc2UsIHdlJ2xsXG4gICAgICAgICAgLy8gY29udGludWUgdHJhdmVyc2luZyB0aGUgdHJlZSBhbmQgZmlyaW5nIGFsbCB0aGUgZWZmZWN0cy5cbiAgICAgICAgICAvL1xuICAgICAgICAgIC8vIFdlIGRvIG5lZWQgdG8gc2V0IHRoZSBcImNvbm5lY3RlZFwiIGZsYWcgb24gdGhlIGluc3RhbmNlLCB0aG91Z2guXG4gICAgICAgICAgX2luc3RhbmNlNC5fdmlzaWJpbGl0eSB8PSBPZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZDtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmssIGNvbW1pdHRlZExhbmVzLCBjb21taXR0ZWRUcmFuc2l0aW9ucywgaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaW5jbHVkZVdvcmtJblByb2dyZXNzRWZmZWN0cyAmJiBmbGFncyAmIFBhc3NpdmUkMSkge1xuICAgICAgICAgIC8vIFRPRE86IFBhc3MgYGN1cnJlbnRgIGFzIGFyZ3VtZW50IHRvIHRoaXMgZnVuY3Rpb25cbiAgICAgICAgICB2YXIgX2N1cnJlbnQzID0gZmluaXNoZWRXb3JrLmFsdGVybmF0ZTtcbiAgICAgICAgICBjb21taXRPZmZzY3JlZW5QYXNzaXZlTW91bnRFZmZlY3RzKF9jdXJyZW50MywgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBDYWNoZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMsIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMpO1xuXG4gICAgICAgIGlmIChpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzICYmIGZsYWdzICYgUGFzc2l2ZSQxKSB7XG4gICAgICAgICAgLy8gVE9ETzogUGFzcyBgY3VycmVudGAgYXMgYXJndW1lbnQgdG8gdGhpcyBmdW5jdGlvblxuICAgICAgICAgIHZhciBfY3VycmVudDQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuICAgICAgICAgIGNvbW1pdENhY2hlUGFzc2l2ZU1vdW50RWZmZWN0KF9jdXJyZW50NCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBUcmFjaW5nTWFya2VyQ29tcG9uZW50OlxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVJlY29ubmVjdFBhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrLCBjb21taXR0ZWRMYW5lcywgY29tbWl0dGVkVHJhbnNpdGlvbnMsIGluY2x1ZGVXb3JrSW5Qcm9ncmVzc0VmZmVjdHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRSb290LCBwYXJlbnRGaWJlciwgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zKSB7XG4gIC8vIFwiQXRvbWljXCIgZWZmZWN0cyBhcmUgb25lcyB0aGF0IG5lZWQgdG8gZmlyZSBvbiBldmVyeSBjb21taXQsIGV2ZW4gZHVyaW5nXG4gIC8vIHByZS1yZW5kZXJpbmcuIFdlIGNhbGwgdGhpcyBmdW5jdGlvbiB3aGVuIHRyYXZlcnNpbmcgYSBoaWRkZW4gdHJlZSB3aG9zZVxuICAvLyByZWd1bGFyIGVmZmVjdHMgYXJlIGN1cnJlbnRseSBkaXNjb25uZWN0ZWQuXG4gIHZhciBwcmV2RGVidWdGaWJlciA9IGdldEN1cnJlbnRGaWJlcigpOyAvLyBUT0RPOiBBZGQgc3BlY2lhbCBmbGFnIGZvciBhdG9taWMgZWZmZWN0c1xuXG4gIGlmIChwYXJlbnRGaWJlci5zdWJ0cmVlRmxhZ3MgJiBQYXNzaXZlTWFzaykge1xuICAgIHZhciBjaGlsZCA9IHBhcmVudEZpYmVyLmNoaWxkO1xuXG4gICAgd2hpbGUgKGNoaWxkICE9PSBudWxsKSB7XG4gICAgICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKGNoaWxkKTtcbiAgICAgIGNvbW1pdEF0b21pY1Bhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgY2hpbGQpO1xuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYocHJldkRlYnVnRmliZXIpO1xufVxuXG5mdW5jdGlvbiBjb21taXRBdG9taWNQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFJvb3QsIGZpbmlzaGVkV29yaywgY29tbWl0dGVkTGFuZXMsIGNvbW1pdHRlZFRyYW5zaXRpb25zKSB7XG4gIC8vIFwiQXRvbWljXCIgZWZmZWN0cyBhcmUgb25lcyB0aGF0IG5lZWQgdG8gZmlyZSBvbiBldmVyeSBjb21taXQsIGV2ZW4gZHVyaW5nXG4gIC8vIHByZS1yZW5kZXJpbmcuIFdlIGNhbGwgdGhpcyBmdW5jdGlvbiB3aGVuIHRyYXZlcnNpbmcgYSBoaWRkZW4gdHJlZSB3aG9zZVxuICAvLyByZWd1bGFyIGVmZmVjdHMgYXJlIGN1cnJlbnRseSBkaXNjb25uZWN0ZWQuXG4gIHZhciBmbGFncyA9IGZpbmlzaGVkV29yay5mbGFncztcblxuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIE9mZnNjcmVlbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcblxuICAgICAgICBpZiAoZmxhZ3MgJiBQYXNzaXZlJDEpIHtcbiAgICAgICAgICAvLyBUT0RPOiBQYXNzIGBjdXJyZW50YCBhcyBhcmd1bWVudCB0byB0aGlzIGZ1bmN0aW9uXG4gICAgICAgICAgdmFyIGN1cnJlbnQgPSBmaW5pc2hlZFdvcmsuYWx0ZXJuYXRlO1xuICAgICAgICAgIGNvbW1pdE9mZnNjcmVlblBhc3NpdmVNb3VudEVmZmVjdHMoY3VycmVudCwgZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBDYWNoZUNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZUF0b21pY1Bhc3NpdmVFZmZlY3RzKGZpbmlzaGVkUm9vdCwgZmluaXNoZWRXb3JrKTtcblxuICAgICAgICBpZiAoZmxhZ3MgJiBQYXNzaXZlJDEpIHtcbiAgICAgICAgICAvLyBUT0RPOiBQYXNzIGBjdXJyZW50YCBhcyBhcmd1bWVudCB0byB0aGlzIGZ1bmN0aW9uXG4gICAgICAgICAgdmFyIF9jdXJyZW50NSA9IGZpbmlzaGVkV29yay5hbHRlcm5hdGU7XG4gICAgICAgICAgY29tbWl0Q2FjaGVQYXNzaXZlTW91bnRFZmZlY3QoX2N1cnJlbnQ1LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBkZWZhdWx0OlxuICAgICAge1xuICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRSb290LCBmaW5pc2hlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrKSB7XG4gIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoZmluaXNoZWRXb3JrKTtcbiAgY29tbWl0UGFzc2l2ZVVubW91bnRPbkZpYmVyKGZpbmlzaGVkV29yayk7XG4gIHJlc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVigpO1xufSAvLyBJZiB3ZSdyZSBpbnNpZGUgYSBicmFuZCBuZXcgdHJlZSwgb3IgYSB0cmVlIHRoYXQgd2FzIGFscmVhZHkgdmlzaWJsZSwgdGhlbiB3ZVxuLy8gc2hvdWxkIG9ubHkgc3VzcGVuZCBob3N0IGNvbXBvbmVudHMgdGhhdCBoYXZlIGEgU2hvdWxkU3VzcGVuZENvbW1pdCBmbGFnLlxuLy8gQ29tcG9uZW50cyB3aXRob3V0IGl0IGhhdmVuJ3QgY2hhbmdlZCBzaW5jZSB0aGUgbGFzdCBjb21taXQsIHNvIHdlIGNhbiBza2lwXG4vLyBvdmVyIHRob3NlLlxuLy9cbi8vIFdoZW4gd2UgZW50ZXIgYSB0cmVlIHRoYXQgaXMgYmVpbmcgcmV2ZWFsZWQgKGdvaW5nIGZyb20gaGlkZGVuIC0+IHZpc2libGUpLFxuLy8gd2UgbmVlZCB0byBzdXNwZW5kIF9hbnlfIGNvbXBvbmVudCB0aGF0IF9tYXlfIHN1c3BlbmQuIEV2ZW4gaWYgdGhleSdyZVxuLy8gYWxyZWFkeSBpbiB0aGUgXCJjdXJyZW50XCIgdHJlZS4gQmVjYXVzZSB0aGVpciB2aXNpYmlsaXR5IGhhcyBjaGFuZ2VkLCB0aGVcbi8vIGJyb3dzZXIgbWF5IG5vdCBoYXZlIHByZXJlbmRlcmVkIHRoZW0geWV0LiBTbyB3ZSBjaGVjayB0aGUgTWF5U3VzcGVuZENvbW1pdFxuLy8gZmxhZyBpbnN0ZWFkLlxuXG52YXIgc3VzcGVuc2V5Q29tbWl0RmxhZyA9IFNob3VsZFN1c3BlbmRDb21taXQ7XG5mdW5jdGlvbiBhY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpbmlzaGVkV29yaykge1xuICBhY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0T25GaWJlcihmaW5pc2hlZFdvcmspO1xufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQocGFyZW50RmliZXIpIHtcbiAgaWYgKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIHN1c3BlbnNleUNvbW1pdEZsYWcpIHtcbiAgICB2YXIgY2hpbGQgPSBwYXJlbnRGaWJlci5jaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgYWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdE9uRmliZXIoY2hpbGQpO1xuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0T25GaWJlcihmaWJlcikge1xuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdEhvaXN0YWJsZTpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpYmVyKTtcblxuICAgICAgICBpZiAoZmliZXIuZmxhZ3MgJiBzdXNwZW5zZXlDb21taXRGbGFnKSB7XG4gICAgICAgICAgaWYgKGZpYmVyLm1lbW9pemVkU3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN1c3BlbmRSZXNvdXJjZSggLy8gVGhpcyBzaG91bGQgYWx3YXlzIGJlIHNldCBieSB2aXNpdGluZyBIb3N0Um9vdCBmaXJzdFxuICAgICAgICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QsIGZpYmVyLm1lbW9pemVkU3RhdGUsIGZpYmVyLm1lbW9pemVkUHJvcHMpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGZpYmVyLnR5cGU7XG4gICAgICAgICAgICB2YXIgcHJvcHMgPSBmaWJlci5tZW1vaXplZFByb3BzO1xuICAgICAgICAgICAgc3VzcGVuZEluc3RhbmNlKHR5cGUsIHByb3BzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpYmVyKTtcblxuICAgICAgICBpZiAoZmliZXIuZmxhZ3MgJiBzdXNwZW5zZXlDb21taXRGbGFnKSB7XG4gICAgICAgICAgdmFyIF90eXBlID0gZmliZXIudHlwZTtcbiAgICAgICAgICB2YXIgX3Byb3BzID0gZmliZXIubWVtb2l6ZWRQcm9wcztcbiAgICAgICAgICBzdXNwZW5kSW5zdGFuY2UoX3R5cGUsIF9wcm9wcyk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgY2FzZSBIb3N0UG9ydGFsOlxuICAgICAge1xuICAgICAgICBpZiAoc3VwcG9ydHNSZXNvdXJjZXMpIHtcbiAgICAgICAgICB2YXIgcHJldmlvdXNIb2lzdGFibGVSb290ID0gY3VycmVudEhvaXN0YWJsZVJvb3Q7XG4gICAgICAgICAgdmFyIGNvbnRhaW5lciA9IGZpYmVyLnN0YXRlTm9kZS5jb250YWluZXJJbmZvO1xuICAgICAgICAgIGN1cnJlbnRIb2lzdGFibGVSb290ID0gZ2V0SG9pc3RhYmxlUm9vdChjb250YWluZXIpO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcik7XG4gICAgICAgICAgY3VycmVudEhvaXN0YWJsZVJvb3QgPSBwcmV2aW91c0hvaXN0YWJsZVJvb3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpYmVyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHZhciBpc0hpZGRlbiA9IGZpYmVyLm1lbW9pemVkU3RhdGUgIT09IG51bGw7XG5cbiAgICAgICAgaWYgKGlzSGlkZGVuKSA7IGVsc2Uge1xuICAgICAgICAgIHZhciBjdXJyZW50ID0gZmliZXIuYWx0ZXJuYXRlO1xuICAgICAgICAgIHZhciB3YXNIaWRkZW4gPSBjdXJyZW50ICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgICAgIGlmICh3YXNIaWRkZW4pIHtcbiAgICAgICAgICAgIC8vIFRoaXMgdHJlZSBpcyBiZWluZyByZXZlYWxlZC4gVmlzaXQgYWxsIG5ld2x5IHZpc2libGUgc3VzcGVuc2V5XG4gICAgICAgICAgICAvLyBpbnN0YW5jZXMsIGV2ZW4gaWYgdGhleSdyZSBpbiB0aGUgY3VycmVudCB0cmVlLlxuICAgICAgICAgICAgdmFyIHByZXZGbGFncyA9IHN1c3BlbnNleUNvbW1pdEZsYWc7XG4gICAgICAgICAgICBzdXNwZW5zZXlDb21taXRGbGFnID0gTWF5U3VzcGVuZENvbW1pdDtcbiAgICAgICAgICAgIHJlY3Vyc2l2ZWx5QWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdChmaWJlcik7XG4gICAgICAgICAgICBzdXNwZW5zZXlDb21taXRGbGFnID0gcHJldkZsYWdzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmliZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlBY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0KGZpYmVyKTtcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRhY2hBbHRlcm5hdGVTaWJsaW5ncyhwYXJlbnRGaWJlcikge1xuICAvLyBBIGZpYmVyIHdhcyBkZWxldGVkIGZyb20gdGhpcyBwYXJlbnQgZmliZXIsIGJ1dCBpdCdzIHN0aWxsIHBhcnQgb2YgdGhlXG4gIC8vIHByZXZpb3VzIChhbHRlcm5hdGUpIHBhcmVudCBmaWJlcidzIGxpc3Qgb2YgY2hpbGRyZW4uIEJlY2F1c2UgY2hpbGRyZW5cbiAgLy8gYXJlIGEgbGlua2VkIGxpc3QsIGFuIGVhcmxpZXIgc2libGluZyB0aGF0J3Mgc3RpbGwgYWxpdmUgd2lsbCBiZVxuICAvLyBjb25uZWN0ZWQgdG8gdGhlIGRlbGV0ZWQgZmliZXIgdmlhIGl0cyBgYWx0ZXJuYXRlYDpcbiAgLy9cbiAgLy8gICBsaXZlIGZpYmVyIC0tYWx0ZXJuYXRlLS0+IHByZXZpb3VzIGxpdmUgZmliZXIgLS1zaWJsaW5nLS0+IGRlbGV0ZWRcbiAgLy8gICBmaWJlclxuICAvL1xuICAvLyBXZSBjYW4ndCBkaXNjb25uZWN0IGBhbHRlcm5hdGVgIG9uIG5vZGVzIHRoYXQgaGF2ZW4ndCBiZWVuIGRlbGV0ZWQgeWV0LFxuICAvLyBidXQgd2UgY2FuIGRpc2Nvbm5lY3QgdGhlIGBzaWJsaW5nYCBhbmQgYGNoaWxkYCBwb2ludGVycy5cbiAgdmFyIHByZXZpb3VzRmliZXIgPSBwYXJlbnRGaWJlci5hbHRlcm5hdGU7XG5cbiAgaWYgKHByZXZpb3VzRmliZXIgIT09IG51bGwpIHtcbiAgICB2YXIgZGV0YWNoZWRDaGlsZCA9IHByZXZpb3VzRmliZXIuY2hpbGQ7XG5cbiAgICBpZiAoZGV0YWNoZWRDaGlsZCAhPT0gbnVsbCkge1xuICAgICAgcHJldmlvdXNGaWJlci5jaGlsZCA9IG51bGw7XG5cbiAgICAgIGRvIHtcbiAgICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICAgIHZhciBkZXRhY2hlZFNpYmxpbmcgPSBkZXRhY2hlZENoaWxkLnNpYmxpbmc7IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gZm91bmQgd2hlbiB1cGdyYWRpbmcgRmxvd1xuXG4gICAgICAgIGRldGFjaGVkQ2hpbGQuc2libGluZyA9IG51bGw7XG4gICAgICAgIGRldGFjaGVkQ2hpbGQgPSBkZXRhY2hlZFNpYmxpbmc7XG4gICAgICB9IHdoaWxlIChkZXRhY2hlZENoaWxkICE9PSBudWxsKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0SG9va1Bhc3NpdmVVbm1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmssIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IsIGhvb2tGbGFncykge1xuICBpZiAoc2hvdWxkUHJvZmlsZShmaW5pc2hlZFdvcmspKSB7XG4gICAgc3RhcnRQYXNzaXZlRWZmZWN0VGltZXIoKTtcbiAgICBjb21taXRIb29rRWZmZWN0TGlzdFVubW91bnQoaG9va0ZsYWdzLCBmaW5pc2hlZFdvcmssIG5lYXJlc3RNb3VudGVkQW5jZXN0b3IpO1xuICAgIHJlY29yZFBhc3NpdmVFZmZlY3REdXJhdGlvbihmaW5pc2hlZFdvcmspO1xuICB9IGVsc2Uge1xuICAgIGNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudChob29rRmxhZ3MsIGZpbmlzaGVkV29yaywgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVVbm1vdW50RWZmZWN0cyhwYXJlbnRGaWJlcikge1xuICAvLyBEZWxldGlvbnMgZWZmZWN0cyBjYW4gYmUgc2NoZWR1bGVkIG9uIGFueSBmaWJlciB0eXBlLiBUaGV5IG5lZWQgdG8gaGFwcGVuXG4gIC8vIGJlZm9yZSB0aGUgY2hpbGRyZW4gZWZmZWN0cyBoYXZlIGZpcmVkLlxuICB2YXIgZGVsZXRpb25zID0gcGFyZW50RmliZXIuZGVsZXRpb25zO1xuXG4gIGlmICgocGFyZW50RmliZXIuZmxhZ3MgJiBDaGlsZERlbGV0aW9uKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgaWYgKGRlbGV0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxldGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkVG9EZWxldGUgPSBkZWxldGlvbnNbaV07IC8vIFRPRE86IENvbnZlcnQgdGhpcyB0byB1c2UgcmVjdXJzaW9uXG5cbiAgICAgICAgbmV4dEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfYmVnaW4oY2hpbGRUb0RlbGV0ZSwgcGFyZW50RmliZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRldGFjaEFsdGVybmF0ZVNpYmxpbmdzKHBhcmVudEZpYmVyKTtcbiAgfVxuXG4gIHZhciBwcmV2RGVidWdGaWJlciA9IGdldEN1cnJlbnRGaWJlcigpOyAvLyBUT0RPOiBTcGxpdCBQYXNzaXZlTWFzayBpbnRvIHNlcGFyYXRlIG1hc2tzIGZvciBtb3VudCBhbmQgdW5tb3VudD9cblxuICBpZiAocGFyZW50RmliZXIuc3VidHJlZUZsYWdzICYgUGFzc2l2ZU1hc2spIHtcbiAgICB2YXIgY2hpbGQgPSBwYXJlbnRGaWJlci5jaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihjaGlsZCk7XG4gICAgICBjb21taXRQYXNzaXZlVW5tb3VudE9uRmliZXIoY2hpbGQpO1xuICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgIH1cbiAgfVxuXG4gIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYocHJldkRlYnVnRmliZXIpO1xufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudE9uRmliZXIoZmluaXNoZWRXb3JrKSB7XG4gIHN3aXRjaCAoZmluaXNoZWRXb3JrLnRhZykge1xuICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVVbm1vdW50RWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuXG4gICAgICAgIGlmIChmaW5pc2hlZFdvcmsuZmxhZ3MgJiBQYXNzaXZlJDEpIHtcbiAgICAgICAgICBjb21taXRIb29rUGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgUGFzc2l2ZSB8IEhhc0VmZmVjdCk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuICAgICAgICB2YXIgbmV4dFN0YXRlID0gZmluaXNoZWRXb3JrLm1lbW9pemVkU3RhdGU7XG4gICAgICAgIHZhciBpc0hpZGRlbiA9IG5leHRTdGF0ZSAhPT0gbnVsbDtcblxuICAgICAgICBpZiAoaXNIaWRkZW4gJiYgaW5zdGFuY2UuX3Zpc2liaWxpdHkgJiBPZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZCAmJiAoIC8vIEZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSwgZG9uJ3QgdW5tb3VudCB3aGVuIGEgdHJlZSBzdXNwZW5kcy4gSW5cbiAgICAgICAgLy8gdGhlIGZ1dHVyZSB3ZSBtYXkgY2hhbmdlIHRoaXMgdG8gdW5tb3VudCBhZnRlciBhIGRlbGF5LlxuICAgICAgICBmaW5pc2hlZFdvcmsucmV0dXJuID09PSBudWxsIHx8IGZpbmlzaGVkV29yay5yZXR1cm4udGFnICE9PSBTdXNwZW5zZUNvbXBvbmVudCkpIHtcbiAgICAgICAgICAvLyBUaGUgZWZmZWN0cyBhcmUgY3VycmVudGx5IGNvbm5lY3RlZC4gRGlzY29ubmVjdCB0aGVtLlxuICAgICAgICAgIC8vIFRPRE86IEFkZCBvcHRpb24gb3IgaGV1cmlzdGljIHRvIGRlbGF5IGJlZm9yZSBkaXNjb25uZWN0aW5nIHRoZVxuICAgICAgICAgIC8vIGVmZmVjdHMuIFRoZW4gaWYgdGhlIHRyZWUgcmVhcHBlYXJzIGJlZm9yZSB0aGUgZGVsYXkgaGFzIGVsYXBzZWQsIHdlXG4gICAgICAgICAgLy8gY2FuIHNraXAgdG9nZ2xpbmcgdGhlIGVmZmVjdHMgZW50aXJlbHkuXG4gICAgICAgICAgaW5zdGFuY2UuX3Zpc2liaWxpdHkgJj0gfk9mZnNjcmVlblBhc3NpdmVFZmZlY3RzQ29ubmVjdGVkO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZWN1cnNpdmVseVRyYXZlcnNlUGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yayk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0cyhwYXJlbnRGaWJlcikge1xuICAvLyBEZWxldGlvbnMgZWZmZWN0cyBjYW4gYmUgc2NoZWR1bGVkIG9uIGFueSBmaWJlciB0eXBlLiBUaGV5IG5lZWQgdG8gaGFwcGVuXG4gIC8vIGJlZm9yZSB0aGUgY2hpbGRyZW4gZWZmZWN0cyBoYXZlIGZpcmVkLlxuICB2YXIgZGVsZXRpb25zID0gcGFyZW50RmliZXIuZGVsZXRpb25zO1xuXG4gIGlmICgocGFyZW50RmliZXIuZmxhZ3MgJiBDaGlsZERlbGV0aW9uKSAhPT0gTm9GbGFncyQxKSB7XG4gICAgaWYgKGRlbGV0aW9ucyAhPT0gbnVsbCkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkZWxldGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkVG9EZWxldGUgPSBkZWxldGlvbnNbaV07IC8vIFRPRE86IENvbnZlcnQgdGhpcyB0byB1c2UgcmVjdXJzaW9uXG5cbiAgICAgICAgbmV4dEVmZmVjdCA9IGNoaWxkVG9EZWxldGU7XG4gICAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfYmVnaW4oY2hpbGRUb0RlbGV0ZSwgcGFyZW50RmliZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRldGFjaEFsdGVybmF0ZVNpYmxpbmdzKHBhcmVudEZpYmVyKTtcbiAgfVxuXG4gIHZhciBwcmV2RGVidWdGaWJlciA9IGdldEN1cnJlbnRGaWJlcigpOyAvLyBUT0RPOiBDaGVjayBQYXNzaXZlU3RhdGljIGZsYWdcblxuICB2YXIgY2hpbGQgPSBwYXJlbnRGaWJlci5jaGlsZDtcblxuICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKGNoaWxkKTtcbiAgICBkaXNjb25uZWN0UGFzc2l2ZUVmZmVjdChjaGlsZCk7XG4gICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICB9XG5cbiAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihwcmV2RGVidWdGaWJlcik7XG59XG5cbmZ1bmN0aW9uIGRpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0KGZpbmlzaGVkV29yaykge1xuICBzd2l0Y2ggKGZpbmlzaGVkV29yay50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIC8vIFRPRE86IENoZWNrIFBhc3NpdmVTdGF0aWMgZmxhZ1xuICAgICAgICBjb21taXRIb29rUGFzc2l2ZVVubW91bnRFZmZlY3RzKGZpbmlzaGVkV29yaywgZmluaXNoZWRXb3JrLnJldHVybiwgUGFzc2l2ZSk7IC8vIFdoZW4gZGlzY29ubmVjdGluZyBwYXNzaXZlIGVmZmVjdHMsIHdlIGZpcmUgdGhlIGVmZmVjdHMgaW4gdGhlIHNhbWVcbiAgICAgICAgLy8gb3JkZXIgYXMgZHVyaW5nIGEgZGVsZXRpb25nOiBwYXJlbnQgYmVmb3JlIGNoaWxkXG5cbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBmaW5pc2hlZFdvcmsuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChpbnN0YW5jZS5fdmlzaWJpbGl0eSAmIE9mZnNjcmVlblBhc3NpdmVFZmZlY3RzQ29ubmVjdGVkKSB7XG4gICAgICAgICAgaW5zdGFuY2UuX3Zpc2liaWxpdHkgJj0gfk9mZnNjcmVlblBhc3NpdmVFZmZlY3RzQ29ubmVjdGVkO1xuICAgICAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VEaXNjb25uZWN0UGFzc2l2ZUVmZmVjdHMoZmluaXNoZWRXb3JrKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgZGVmYXVsdDpcbiAgICAgIHtcbiAgICAgICAgcmVjdXJzaXZlbHlUcmF2ZXJzZURpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0cyhmaW5pc2hlZFdvcmspO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2JlZ2luKGRlbGV0ZWRTdWJ0cmVlUm9vdCwgbmVhcmVzdE1vdW50ZWRBbmNlc3Rvcikge1xuICB3aGlsZSAobmV4dEVmZmVjdCAhPT0gbnVsbCkge1xuICAgIHZhciBmaWJlciA9IG5leHRFZmZlY3Q7IC8vIERlbGV0aW9uIGVmZmVjdHMgZmlyZSBpbiBwYXJlbnQgLT4gY2hpbGQgb3JkZXJcbiAgICAvLyBUT0RPOiBDaGVjayBpZiBmaWJlciBoYXMgYSBQYXNzaXZlU3RhdGljIGZsYWdcblxuICAgIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoZmliZXIpO1xuICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50SW5zaWRlRGVsZXRlZFRyZWVPbkZpYmVyKGZpYmVyLCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKTtcbiAgICByZXNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoKTtcbiAgICB2YXIgY2hpbGQgPSBmaWJlci5jaGlsZDsgLy8gVE9ETzogT25seSB0cmF2ZXJzZSBzdWJ0cmVlIGlmIGl0IGhhcyBhIFBhc3NpdmVTdGF0aWMgZmxhZy5cblxuICAgIGlmIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgY2hpbGQucmV0dXJuID0gZmliZXI7XG4gICAgICBuZXh0RWZmZWN0ID0gY2hpbGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0c0luc2lkZU9mRGVsZXRlZFRyZWVfY29tcGxldGUoZGVsZXRlZFN1YnRyZWVSb290KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tbWl0UGFzc2l2ZVVubW91bnRFZmZlY3RzSW5zaWRlT2ZEZWxldGVkVHJlZV9jb21wbGV0ZShkZWxldGVkU3VidHJlZVJvb3QpIHtcbiAgd2hpbGUgKG5leHRFZmZlY3QgIT09IG51bGwpIHtcbiAgICB2YXIgZmliZXIgPSBuZXh0RWZmZWN0O1xuICAgIHZhciBzaWJsaW5nID0gZmliZXIuc2libGluZztcbiAgICB2YXIgcmV0dXJuRmliZXIgPSBmaWJlci5yZXR1cm47IC8vIFJlY3Vyc2l2ZWx5IHRyYXZlcnNlIHRoZSBlbnRpcmUgZGVsZXRlZCB0cmVlIGFuZCBjbGVhbiB1cCBmaWJlciBmaWVsZHMuXG4gICAgLy8gVGhpcyBpcyBtb3JlIGFnZ3Jlc3NpdmUgdGhhbiBpZGVhbCwgYW5kIHRoZSBsb25nIHRlcm0gZ29hbCBpcyB0byBvbmx5XG4gICAgLy8gaGF2ZSB0byBkZXRhY2ggdGhlIGRlbGV0ZWQgdHJlZSBhdCB0aGUgcm9vdC5cblxuICAgIGRldGFjaEZpYmVyQWZ0ZXJFZmZlY3RzKGZpYmVyKTtcblxuICAgIGlmIChmaWJlciA9PT0gZGVsZXRlZFN1YnRyZWVSb290KSB7XG4gICAgICBuZXh0RWZmZWN0ID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgc2libGluZy5yZXR1cm4gPSByZXR1cm5GaWJlcjtcbiAgICAgIG5leHRFZmZlY3QgPSBzaWJsaW5nO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG5leHRFZmZlY3QgPSByZXR1cm5GaWJlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXRQYXNzaXZlVW5tb3VudEluc2lkZURlbGV0ZWRUcmVlT25GaWJlcihjdXJyZW50LCBuZWFyZXN0TW91bnRlZEFuY2VzdG9yKSB7XG4gIHN3aXRjaCAoY3VycmVudC50YWcpIHtcbiAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgIGNhc2UgRm9yd2FyZFJlZjpcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIGNvbW1pdEhvb2tQYXNzaXZlVW5tb3VudEVmZmVjdHMoY3VycmVudCwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgUGFzc2l2ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIC8vIFRPRE86IHJ1biBwYXNzaXZlIHVubW91bnQgZWZmZWN0cyB3aGVuIHVubW91bnRpbmcgYSByb290LlxuICAgIC8vIEJlY2F1c2UgcGFzc2l2ZSB1bm1vdW50IGVmZmVjdHMgYXJlIG5vdCBjdXJyZW50bHkgcnVuLFxuICAgIC8vIHRoZSBjYWNoZSBpbnN0YW5jZSBvd25lZCBieSB0aGUgcm9vdCB3aWxsIG5ldmVyIGJlIGZyZWVkLlxuICAgIC8vIFdoZW4gZWZmZWN0cyBhcmUgcnVuLCB0aGUgY2FjaGUgc2hvdWxkIGJlIGZyZWVkIGhlcmU6XG4gICAgLy8gY2FzZSBIb3N0Um9vdDoge1xuICAgIC8vICAgaWYgKGVuYWJsZUNhY2hlKSB7XG4gICAgLy8gICAgIGNvbnN0IGNhY2hlID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlO1xuICAgIC8vICAgICByZWxlYXNlQ2FjaGUoY2FjaGUpO1xuICAgIC8vICAgfVxuICAgIC8vICAgYnJlYWs7XG4gICAgLy8gfVxuXG4gICAgY2FzZSBMZWdhY3lIaWRkZW5Db21wb25lbnQ6XG4gICAgY2FzZSBPZmZzY3JlZW5Db21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAoY3VycmVudC5tZW1vaXplZFN0YXRlICE9PSBudWxsICYmIGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBjYWNoZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZS5jYWNoZVBvb2wucG9vbDsgLy8gUmV0YWluL3JlbGVhc2UgdGhlIGNhY2hlIHVzZWQgZm9yIHBlbmRpbmcgKHN1c3BlbmRlZCkgbm9kZXMuXG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgdGhpcyBpcyBvbmx5IHJlYWNoZWQgaW4gdGhlIG5vbi1zdXNwZW5kZWQvdmlzaWJsZSBjYXNlOlxuICAgICAgICAgICAgLy8gd2hlbiB0aGUgY29udGVudCBpcyBzdXNwZW5kZWQvaGlkZGVuLCB0aGUgcmV0YWluL3JlbGVhc2Ugb2NjdXJzXG4gICAgICAgICAgICAvLyB2aWEgdGhlIHBhcmVudCBTdXNwZW5zZSBjb21wb25lbnQgKHNlZSBjYXNlIGFib3ZlKS5cblxuICAgICAgICAgICAgaWYgKGNhY2hlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgcmV0YWluQ2FjaGUoY2FjaGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBTdXNwZW5zZUNvbXBvbmVudDpcbiAgICAgIHtcblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgQ2FjaGVDb21wb25lbnQ6XG4gICAgICB7XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgX2NhY2hlID0gY3VycmVudC5tZW1vaXplZFN0YXRlLmNhY2hlO1xuICAgICAgICAgIHJlbGVhc2VDYWNoZShfY2FjaGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Q2FjaGVGb3JUeXBlKHJlc291cmNlVHlwZSkge1xuXG4gIHZhciBjYWNoZSA9IHJlYWRDb250ZXh0KENhY2hlQ29udGV4dCk7XG4gIHZhciBjYWNoZUZvclR5cGUgPSBjYWNoZS5kYXRhLmdldChyZXNvdXJjZVR5cGUpO1xuXG4gIGlmIChjYWNoZUZvclR5cGUgPT09IHVuZGVmaW5lZCkge1xuICAgIGNhY2hlRm9yVHlwZSA9IHJlc291cmNlVHlwZSgpO1xuICAgIGNhY2hlLmRhdGEuc2V0KHJlc291cmNlVHlwZSwgY2FjaGVGb3JUeXBlKTtcbiAgfVxuXG4gIHJldHVybiBjYWNoZUZvclR5cGU7XG59XG5cbnZhciBEZWZhdWx0QXN5bmNEaXNwYXRjaGVyID0ge1xuICBnZXRDYWNoZUZvclR5cGU6IGdldENhY2hlRm9yVHlwZVxufTtcblxue1xuICBEZWZhdWx0QXN5bmNEaXNwYXRjaGVyLmdldE93bmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjdXJyZW50O1xuICB9O1xufVxuXG52YXIgQ09NUE9ORU5UX1RZUEUgPSAwO1xudmFyIEhBU19QU0VVRE9fQ0xBU1NfVFlQRSA9IDE7XG52YXIgUk9MRV9UWVBFID0gMjtcbnZhciBURVNUX05BTUVfVFlQRSA9IDM7XG52YXIgVEVYVF9UWVBFID0gNDtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcikge1xuICB2YXIgc3ltYm9sRm9yID0gU3ltYm9sLmZvcjtcbiAgQ09NUE9ORU5UX1RZUEUgPSBzeW1ib2xGb3IoJ3NlbGVjdG9yLmNvbXBvbmVudCcpO1xuICBIQVNfUFNFVURPX0NMQVNTX1RZUEUgPSBzeW1ib2xGb3IoJ3NlbGVjdG9yLmhhc19wc2V1ZG9fY2xhc3MnKTtcbiAgUk9MRV9UWVBFID0gc3ltYm9sRm9yKCdzZWxlY3Rvci5yb2xlJyk7XG4gIFRFU1RfTkFNRV9UWVBFID0gc3ltYm9sRm9yKCdzZWxlY3Rvci50ZXN0X2lkJyk7XG4gIFRFWFRfVFlQRSA9IHN5bWJvbEZvcignc2VsZWN0b3IudGV4dCcpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRTZWxlY3Rvcihjb21wb25lbnQpIHtcbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogQ09NUE9ORU5UX1RZUEUsXG4gICAgdmFsdWU6IGNvbXBvbmVudFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSGFzUHNldWRvQ2xhc3NTZWxlY3RvcihzZWxlY3RvcnMpIHtcbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogSEFTX1BTRVVET19DTEFTU19UWVBFLFxuICAgIHZhbHVlOiBzZWxlY3RvcnNcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvbGVTZWxlY3Rvcihyb2xlKSB7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IFJPTEVfVFlQRSxcbiAgICB2YWx1ZTogcm9sZVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlVGV4dFNlbGVjdG9yKHRleHQpIHtcbiAgcmV0dXJuIHtcbiAgICAkJHR5cGVvZjogVEVYVF9UWVBFLFxuICAgIHZhbHVlOiB0ZXh0XG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVUZXN0TmFtZVNlbGVjdG9yKGlkKSB7XG4gIHJldHVybiB7XG4gICAgJCR0eXBlb2Y6IFRFU1RfTkFNRV9UWVBFLFxuICAgIHZhbHVlOiBpZFxuICB9O1xufVxuXG5mdW5jdGlvbiBmaW5kRmliZXJSb290Rm9ySG9zdFJvb3QoaG9zdFJvb3QpIHtcbiAgdmFyIG1heWJlRmliZXIgPSBnZXRJbnN0YW5jZUZyb21Ob2RlKGhvc3RSb290KTtcblxuICBpZiAobWF5YmVGaWJlciAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiBtYXliZUZpYmVyLm1lbW9pemVkUHJvcHNbJ2RhdGEtdGVzdG5hbWUnXSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBob3N0IHJvb3Qgc3BlY2lmaWVkLiBTaG91bGQgYmUgZWl0aGVyIGEgUmVhY3QgY29udGFpbmVyIG9yIGEgbm9kZSB3aXRoIGEgdGVzdG5hbWUgYXR0cmlidXRlLicpO1xuICAgIH1cblxuICAgIHJldHVybiBtYXliZUZpYmVyO1xuICB9IGVsc2Uge1xuICAgIHZhciBmaWJlclJvb3QgPSBmaW5kRmliZXJSb290KGhvc3RSb290KTtcblxuICAgIGlmIChmaWJlclJvb3QgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGZpbmQgUmVhY3QgY29udGFpbmVyIHdpdGhpbiBzcGVjaWZpZWQgaG9zdCBzdWJ0cmVlLicpO1xuICAgIH0gLy8gVGhlIEZsb3cgdHlwZSBmb3IgRmliZXJSb290IGlzIGEgbGl0dGxlIGZ1bmt5LlxuICAgIC8vIGNyZWF0ZUZpYmVyUm9vdCgpIGNoZWF0cyB0aGlzIGJ5IHRyZWF0aW5nIHRoZSByb290IGFzIDphbnkgYW5kIGFkZGluZyBzdGF0ZU5vZGUgbGF6aWx5LlxuXG5cbiAgICByZXR1cm4gZmliZXJSb290LnN0YXRlTm9kZS5jdXJyZW50O1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoU2VsZWN0b3IoZmliZXIsIHNlbGVjdG9yKSB7XG4gIHZhciB0YWcgPSBmaWJlci50YWc7XG5cbiAgc3dpdGNoIChzZWxlY3Rvci4kJHR5cGVvZikge1xuICAgIGNhc2UgQ09NUE9ORU5UX1RZUEU6XG4gICAgICBpZiAoZmliZXIudHlwZSA9PT0gc2VsZWN0b3IudmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBIQVNfUFNFVURPX0NMQVNTX1RZUEU6XG4gICAgICByZXR1cm4gaGFzTWF0Y2hpbmdQYXRocyhmaWJlciwgc2VsZWN0b3IudmFsdWUpO1xuXG4gICAgY2FzZSBST0xFX1RZUEU6XG4gICAgICBpZiAodGFnID09PSBIb3N0Q29tcG9uZW50IHx8IHRhZyA9PT0gSG9zdEhvaXN0YWJsZSB8fCB0YWcgPT09IEhvc3RTaW5nbGV0b24pIHtcbiAgICAgICAgdmFyIG5vZGUgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgICAgaWYgKG1hdGNoQWNjZXNzaWJpbGl0eVJvbGUobm9kZSwgc2VsZWN0b3IudmFsdWUpKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFRFWFRfVFlQRTpcbiAgICAgIGlmICh0YWcgPT09IEhvc3RDb21wb25lbnQgfHwgdGFnID09PSBIb3N0VGV4dCB8fCB0YWcgPT09IEhvc3RIb2lzdGFibGUgfHwgdGFnID09PSBIb3N0U2luZ2xldG9uKSB7XG4gICAgICAgIHZhciB0ZXh0Q29udGVudCA9IGdldFRleHRDb250ZW50KGZpYmVyKTtcblxuICAgICAgICBpZiAodGV4dENvbnRlbnQgIT09IG51bGwgJiYgdGV4dENvbnRlbnQuaW5kZXhPZihzZWxlY3Rvci52YWx1ZSkgPj0gMCkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBURVNUX05BTUVfVFlQRTpcbiAgICAgIGlmICh0YWcgPT09IEhvc3RDb21wb25lbnQgfHwgdGFnID09PSBIb3N0SG9pc3RhYmxlIHx8IHRhZyA9PT0gSG9zdFNpbmdsZXRvbikge1xuICAgICAgICB2YXIgZGF0YVRlc3RJRCA9IGZpYmVyLm1lbW9pemVkUHJvcHNbJ2RhdGEtdGVzdG5hbWUnXTtcblxuICAgICAgICBpZiAodHlwZW9mIGRhdGFUZXN0SUQgPT09ICdzdHJpbmcnICYmIGRhdGFUZXN0SUQudG9Mb3dlckNhc2UoKSA9PT0gc2VsZWN0b3IudmFsdWUudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzZWxlY3RvciB0eXBlIHNwZWNpZmllZC4nKTtcbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc2VsZWN0b3JUb1N0cmluZyhzZWxlY3Rvcikge1xuICBzd2l0Y2ggKHNlbGVjdG9yLiQkdHlwZW9mKSB7XG4gICAgY2FzZSBDT01QT05FTlRfVFlQRTpcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShzZWxlY3Rvci52YWx1ZSkgfHwgJ1Vua25vd24nO1xuICAgICAgcmV0dXJuIFwiPFwiICsgZGlzcGxheU5hbWUgKyBcIj5cIjtcblxuICAgIGNhc2UgSEFTX1BTRVVET19DTEFTU19UWVBFOlxuICAgICAgcmV0dXJuIFwiOmhhcyhcIiArIChzZWxlY3RvclRvU3RyaW5nKHNlbGVjdG9yKSB8fCAnJykgKyBcIilcIjtcblxuICAgIGNhc2UgUk9MRV9UWVBFOlxuICAgICAgcmV0dXJuIFwiW3JvbGU9XFxcIlwiICsgc2VsZWN0b3IudmFsdWUgKyBcIlxcXCJdXCI7XG5cbiAgICBjYXNlIFRFWFRfVFlQRTpcbiAgICAgIHJldHVybiBcIlxcXCJcIiArIHNlbGVjdG9yLnZhbHVlICsgXCJcXFwiXCI7XG5cbiAgICBjYXNlIFRFU1RfTkFNRV9UWVBFOlxuICAgICAgcmV0dXJuIFwiW2RhdGEtdGVzdG5hbWU9XFxcIlwiICsgc2VsZWN0b3IudmFsdWUgKyBcIlxcXCJdXCI7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHNlbGVjdG9yIHR5cGUgc3BlY2lmaWVkLicpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRQYXRocyhyb290LCBzZWxlY3RvcnMpIHtcbiAgdmFyIG1hdGNoaW5nRmliZXJzID0gW107XG4gIHZhciBzdGFjayA9IFtyb290LCAwXTtcbiAgdmFyIGluZGV4ID0gMDtcblxuICB3aGlsZSAoaW5kZXggPCBzdGFjay5sZW5ndGgpIHtcbiAgICB2YXIgZmliZXIgPSBzdGFja1tpbmRleCsrXTtcbiAgICB2YXIgdGFnID0gZmliZXIudGFnO1xuICAgIHZhciBzZWxlY3RvckluZGV4ID0gc3RhY2tbaW5kZXgrK107XG4gICAgdmFyIHNlbGVjdG9yID0gc2VsZWN0b3JzW3NlbGVjdG9ySW5kZXhdO1xuXG4gICAgaWYgKCh0YWcgPT09IEhvc3RDb21wb25lbnQgfHwgdGFnID09PSBIb3N0SG9pc3RhYmxlIHx8IHRhZyA9PT0gSG9zdFNpbmdsZXRvbikgJiYgaXNIaWRkZW5TdWJ0cmVlKGZpYmVyKSkge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChzZWxlY3RvciAhPSBudWxsICYmIG1hdGNoU2VsZWN0b3IoZmliZXIsIHNlbGVjdG9yKSkge1xuICAgICAgICBzZWxlY3RvckluZGV4Kys7XG4gICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3JzW3NlbGVjdG9ySW5kZXhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZWxlY3RvckluZGV4ID09PSBzZWxlY3RvcnMubGVuZ3RoKSB7XG4gICAgICBtYXRjaGluZ0ZpYmVycy5wdXNoKGZpYmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBzdGFjay5wdXNoKGNoaWxkLCBzZWxlY3RvckluZGV4KTtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXRjaGluZ0ZpYmVycztcbn0gLy8gU2FtZSBhcyBmaW5kUGF0aHMgYnV0IHdpdGggZWFnZXIgYmFpbG91dCBvbiBmaXJzdCBtYXRjaFxuXG5cbmZ1bmN0aW9uIGhhc01hdGNoaW5nUGF0aHMocm9vdCwgc2VsZWN0b3JzKSB7XG4gIHZhciBzdGFjayA9IFtyb290LCAwXTtcbiAgdmFyIGluZGV4ID0gMDtcblxuICB3aGlsZSAoaW5kZXggPCBzdGFjay5sZW5ndGgpIHtcbiAgICB2YXIgZmliZXIgPSBzdGFja1tpbmRleCsrXTtcbiAgICB2YXIgdGFnID0gZmliZXIudGFnO1xuICAgIHZhciBzZWxlY3RvckluZGV4ID0gc3RhY2tbaW5kZXgrK107XG4gICAgdmFyIHNlbGVjdG9yID0gc2VsZWN0b3JzW3NlbGVjdG9ySW5kZXhdO1xuXG4gICAgaWYgKCh0YWcgPT09IEhvc3RDb21wb25lbnQgfHwgdGFnID09PSBIb3N0SG9pc3RhYmxlIHx8IHRhZyA9PT0gSG9zdFNpbmdsZXRvbikgJiYgaXNIaWRkZW5TdWJ0cmVlKGZpYmVyKSkge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdoaWxlIChzZWxlY3RvciAhPSBudWxsICYmIG1hdGNoU2VsZWN0b3IoZmliZXIsIHNlbGVjdG9yKSkge1xuICAgICAgICBzZWxlY3RvckluZGV4Kys7XG4gICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3JzW3NlbGVjdG9ySW5kZXhdO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZWxlY3RvckluZGV4ID09PSBzZWxlY3RvcnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBzdGFjay5wdXNoKGNoaWxkLCBzZWxlY3RvckluZGV4KTtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gZmluZEFsbE5vZGVzKGhvc3RSb290LCBzZWxlY3RvcnMpIHtcbiAgaWYgKCFzdXBwb3J0c1Rlc3RTZWxlY3RvcnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Rlc3Qgc2VsZWN0b3IgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgYnkgdGhpcyByZW5kZXJlci4nKTtcbiAgfVxuXG4gIHZhciByb290ID0gZmluZEZpYmVyUm9vdEZvckhvc3RSb290KGhvc3RSb290KTtcbiAgdmFyIG1hdGNoaW5nRmliZXJzID0gZmluZFBhdGhzKHJvb3QsIHNlbGVjdG9ycyk7XG4gIHZhciBpbnN0YW5jZVJvb3RzID0gW107XG4gIHZhciBzdGFjayA9IEFycmF5LmZyb20obWF0Y2hpbmdGaWJlcnMpO1xuICB2YXIgaW5kZXggPSAwO1xuXG4gIHdoaWxlIChpbmRleCA8IHN0YWNrLmxlbmd0aCkge1xuICAgIHZhciBub2RlID0gc3RhY2tbaW5kZXgrK107XG4gICAgdmFyIHRhZyA9IG5vZGUudGFnO1xuXG4gICAgaWYgKHRhZyA9PT0gSG9zdENvbXBvbmVudCB8fCB0YWcgPT09IEhvc3RIb2lzdGFibGUgfHwgdGFnID09PSBIb3N0U2luZ2xldG9uKSB7XG4gICAgICBpZiAoaXNIaWRkZW5TdWJ0cmVlKG5vZGUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpbnN0YW5jZVJvb3RzLnB1c2gobm9kZS5zdGF0ZU5vZGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY2hpbGQgPSBub2RlLmNoaWxkO1xuXG4gICAgICB3aGlsZSAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgc3RhY2sucHVzaChjaGlsZCk7XG4gICAgICAgIGNoaWxkID0gY2hpbGQuc2libGluZztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2VSb290cztcbn1cbmZ1bmN0aW9uIGdldEZpbmRBbGxOb2Rlc0ZhaWx1cmVEZXNjcmlwdGlvbihob3N0Um9vdCwgc2VsZWN0b3JzKSB7XG4gIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuJyk7XG4gIH1cblxuICB2YXIgcm9vdCA9IGZpbmRGaWJlclJvb3RGb3JIb3N0Um9vdChob3N0Um9vdCk7XG4gIHZhciBtYXhTZWxlY3RvckluZGV4ID0gMDtcbiAgdmFyIG1hdGNoZWROYW1lcyA9IFtdOyAvLyBUaGUgbG9naWMgb2YgdGhpcyBsb29wIHNob3VsZCBiZSBrZXB0IGluIHN5bmMgd2l0aCBmaW5kUGF0aHMoKVxuXG4gIHZhciBzdGFjayA9IFtyb290LCAwXTtcbiAgdmFyIGluZGV4ID0gMDtcblxuICB3aGlsZSAoaW5kZXggPCBzdGFjay5sZW5ndGgpIHtcbiAgICB2YXIgZmliZXIgPSBzdGFja1tpbmRleCsrXTtcbiAgICB2YXIgdGFnID0gZmliZXIudGFnO1xuICAgIHZhciBzZWxlY3RvckluZGV4ID0gc3RhY2tbaW5kZXgrK107XG4gICAgdmFyIHNlbGVjdG9yID0gc2VsZWN0b3JzW3NlbGVjdG9ySW5kZXhdO1xuXG4gICAgaWYgKCh0YWcgPT09IEhvc3RDb21wb25lbnQgfHwgdGFnID09PSBIb3N0SG9pc3RhYmxlIHx8IHRhZyA9PT0gSG9zdFNpbmdsZXRvbikgJiYgaXNIaWRkZW5TdWJ0cmVlKGZpYmVyKSkge1xuICAgICAgY29udGludWU7XG4gICAgfSBlbHNlIGlmIChtYXRjaFNlbGVjdG9yKGZpYmVyLCBzZWxlY3RvcikpIHtcbiAgICAgIG1hdGNoZWROYW1lcy5wdXNoKHNlbGVjdG9yVG9TdHJpbmcoc2VsZWN0b3IpKTtcbiAgICAgIHNlbGVjdG9ySW5kZXgrKztcblxuICAgICAgaWYgKHNlbGVjdG9ySW5kZXggPiBtYXhTZWxlY3RvckluZGV4KSB7XG4gICAgICAgIG1heFNlbGVjdG9ySW5kZXggPSBzZWxlY3RvckluZGV4O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZWxlY3RvckluZGV4IDwgc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgICAgdmFyIGNoaWxkID0gZmliZXIuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBzdGFjay5wdXNoKGNoaWxkLCBzZWxlY3RvckluZGV4KTtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChtYXhTZWxlY3RvckluZGV4IDwgc2VsZWN0b3JzLmxlbmd0aCkge1xuICAgIHZhciB1bm1hdGNoZWROYW1lcyA9IFtdO1xuXG4gICAgZm9yICh2YXIgaSA9IG1heFNlbGVjdG9ySW5kZXg7IGkgPCBzZWxlY3RvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHVubWF0Y2hlZE5hbWVzLnB1c2goc2VsZWN0b3JUb1N0cmluZyhzZWxlY3RvcnNbaV0pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gJ2ZpbmRBbGxOb2RlcyB3YXMgYWJsZSB0byBtYXRjaCBwYXJ0IG9mIHRoZSBzZWxlY3RvcjpcXG4nICsgKFwiICBcIiArIG1hdGNoZWROYW1lcy5qb2luKCcgPiAnKSArIFwiXFxuXFxuXCIpICsgJ05vIG1hdGNoaW5nIGNvbXBvbmVudCB3YXMgZm91bmQgZm9yOlxcbicgKyAoXCIgIFwiICsgdW5tYXRjaGVkTmFtZXMuam9pbignID4gJykpO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBmaW5kQm91bmRpbmdSZWN0cyhob3N0Um9vdCwgc2VsZWN0b3JzKSB7XG4gIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuJyk7XG4gIH1cblxuICB2YXIgaW5zdGFuY2VSb290cyA9IGZpbmRBbGxOb2Rlcyhob3N0Um9vdCwgc2VsZWN0b3JzKTtcbiAgdmFyIGJvdW5kaW5nUmVjdHMgPSBbXTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGluc3RhbmNlUm9vdHMubGVuZ3RoOyBpKyspIHtcbiAgICBib3VuZGluZ1JlY3RzLnB1c2goZ2V0Qm91bmRpbmdSZWN0KGluc3RhbmNlUm9vdHNbaV0pKTtcbiAgfVxuXG4gIGZvciAodmFyIF9pID0gYm91bmRpbmdSZWN0cy5sZW5ndGggLSAxOyBfaSA+IDA7IF9pLS0pIHtcbiAgICB2YXIgdGFyZ2V0UmVjdCA9IGJvdW5kaW5nUmVjdHNbX2ldO1xuICAgIHZhciB0YXJnZXRMZWZ0ID0gdGFyZ2V0UmVjdC54O1xuICAgIHZhciB0YXJnZXRSaWdodCA9IHRhcmdldExlZnQgKyB0YXJnZXRSZWN0LndpZHRoO1xuICAgIHZhciB0YXJnZXRUb3AgPSB0YXJnZXRSZWN0Lnk7XG4gICAgdmFyIHRhcmdldEJvdHRvbSA9IHRhcmdldFRvcCArIHRhcmdldFJlY3QuaGVpZ2h0O1xuXG4gICAgZm9yICh2YXIgaiA9IF9pIC0gMTsgaiA+PSAwOyBqLS0pIHtcbiAgICAgIGlmIChfaSAhPT0gaikge1xuICAgICAgICB2YXIgb3RoZXJSZWN0ID0gYm91bmRpbmdSZWN0c1tqXTtcbiAgICAgICAgdmFyIG90aGVyTGVmdCA9IG90aGVyUmVjdC54O1xuICAgICAgICB2YXIgb3RoZXJSaWdodCA9IG90aGVyTGVmdCArIG90aGVyUmVjdC53aWR0aDtcbiAgICAgICAgdmFyIG90aGVyVG9wID0gb3RoZXJSZWN0Lnk7XG4gICAgICAgIHZhciBvdGhlckJvdHRvbSA9IG90aGVyVG9wICsgb3RoZXJSZWN0LmhlaWdodDsgLy8gTWVyZ2luZyBhbGwgcmVjdHMgdG8gdGhlIG1pbmltdW1zIHNldCB3b3VsZCBiZSBjb21wbGljYXRlZCxcbiAgICAgICAgLy8gYnV0IHdlIGNhbiBoYW5kbGUgdGhlIG1vc3QgY29tbW9uIGNhc2VzOlxuICAgICAgICAvLyAxLiBjb21wbGV0ZWx5IG92ZXJsYXBwaW5nIHJlY3RzXG4gICAgICAgIC8vIDIuIGFkamFjZW50IHJlY3RzIHRoYXQgYXJlIHRoZSBzYW1lIHdpZHRoIG9yIGhlaWdodCAoZS5nLiBpdGVtcyBpbiBhIGxpc3QpXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEV2ZW4gZ2l2ZW4gdGhlIGFib3ZlIGNvbnN0cmFpbnRzLFxuICAgICAgICAvLyB3ZSBzdGlsbCB3b24ndCBlbmQgdXAgd2l0aCB0aGUgZmV3ZXN0IHBvc3NpYmxlIHJlY3RzIHdpdGhvdXQgZG9pbmcgbXVsdGlwbGUgcGFzc2VzLFxuICAgICAgICAvLyBidXQgaXQncyBnb29kIGVub3VnaCBmb3IgdGhpcyBwdXJwb3NlLlxuXG4gICAgICAgIGlmICh0YXJnZXRMZWZ0ID49IG90aGVyTGVmdCAmJiB0YXJnZXRUb3AgPj0gb3RoZXJUb3AgJiYgdGFyZ2V0UmlnaHQgPD0gb3RoZXJSaWdodCAmJiB0YXJnZXRCb3R0b20gPD0gb3RoZXJCb3R0b20pIHtcbiAgICAgICAgICAvLyBDb21wbGV0ZSBvdmVybGFwcGluZyByZWN0czsgcmVtb3ZlIHRoZSBpbm5lciBvbmUuXG4gICAgICAgICAgYm91bmRpbmdSZWN0cy5zcGxpY2UoX2ksIDEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldExlZnQgPT09IG90aGVyTGVmdCAmJiB0YXJnZXRSZWN0LndpZHRoID09PSBvdGhlclJlY3Qud2lkdGggJiYgIShvdGhlckJvdHRvbSA8IHRhcmdldFRvcCkgJiYgIShvdGhlclRvcCA+IHRhcmdldEJvdHRvbSkpIHtcbiAgICAgICAgICAvLyBBZGphY2VudCB2ZXJ0aWNhbCByZWN0czsgbWVyZ2UgdGhlbS5cbiAgICAgICAgICBpZiAob3RoZXJUb3AgPiB0YXJnZXRUb3ApIHtcbiAgICAgICAgICAgIG90aGVyUmVjdC5oZWlnaHQgKz0gb3RoZXJUb3AgLSB0YXJnZXRUb3A7XG4gICAgICAgICAgICBvdGhlclJlY3QueSA9IHRhcmdldFRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAob3RoZXJCb3R0b20gPCB0YXJnZXRCb3R0b20pIHtcbiAgICAgICAgICAgIG90aGVyUmVjdC5oZWlnaHQgPSB0YXJnZXRCb3R0b20gLSBvdGhlclRvcDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBib3VuZGluZ1JlY3RzLnNwbGljZShfaSwgMSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0VG9wID09PSBvdGhlclRvcCAmJiB0YXJnZXRSZWN0LmhlaWdodCA9PT0gb3RoZXJSZWN0LmhlaWdodCAmJiAhKG90aGVyUmlnaHQgPCB0YXJnZXRMZWZ0KSAmJiAhKG90aGVyTGVmdCA+IHRhcmdldFJpZ2h0KSkge1xuICAgICAgICAgIC8vIEFkamFjZW50IGhvcml6b250YWwgcmVjdHM7IG1lcmdlIHRoZW0uXG4gICAgICAgICAgaWYgKG90aGVyTGVmdCA+IHRhcmdldExlZnQpIHtcbiAgICAgICAgICAgIG90aGVyUmVjdC53aWR0aCArPSBvdGhlckxlZnQgLSB0YXJnZXRMZWZ0O1xuICAgICAgICAgICAgb3RoZXJSZWN0LnggPSB0YXJnZXRMZWZ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvdGhlclJpZ2h0IDwgdGFyZ2V0UmlnaHQpIHtcbiAgICAgICAgICAgIG90aGVyUmVjdC53aWR0aCA9IHRhcmdldFJpZ2h0IC0gb3RoZXJMZWZ0O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJvdW5kaW5nUmVjdHMuc3BsaWNlKF9pLCAxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBib3VuZGluZ1JlY3RzO1xufVxuZnVuY3Rpb24gZm9jdXNXaXRoaW4oaG9zdFJvb3QsIHNlbGVjdG9ycykge1xuICBpZiAoIXN1cHBvcnRzVGVzdFNlbGVjdG9ycykge1xuICAgIHRocm93IG5ldyBFcnJvcignVGVzdCBzZWxlY3RvciBBUEkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGlzIHJlbmRlcmVyLicpO1xuICB9XG5cbiAgdmFyIHJvb3QgPSBmaW5kRmliZXJSb290Rm9ySG9zdFJvb3QoaG9zdFJvb3QpO1xuICB2YXIgbWF0Y2hpbmdGaWJlcnMgPSBmaW5kUGF0aHMocm9vdCwgc2VsZWN0b3JzKTtcbiAgdmFyIHN0YWNrID0gQXJyYXkuZnJvbShtYXRjaGluZ0ZpYmVycyk7XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgd2hpbGUgKGluZGV4IDwgc3RhY2subGVuZ3RoKSB7XG4gICAgdmFyIGZpYmVyID0gc3RhY2tbaW5kZXgrK107XG4gICAgdmFyIHRhZyA9IGZpYmVyLnRhZztcblxuICAgIGlmIChpc0hpZGRlblN1YnRyZWUoZmliZXIpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAodGFnID09PSBIb3N0Q29tcG9uZW50IHx8IHRhZyA9PT0gSG9zdEhvaXN0YWJsZSB8fCB0YWcgPT09IEhvc3RTaW5nbGV0b24pIHtcbiAgICAgIHZhciBub2RlID0gZmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICBpZiAoc2V0Rm9jdXNJZkZvY3VzYWJsZShub2RlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY2hpbGQgPSBmaWJlci5jaGlsZDtcblxuICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgc3RhY2sucHVzaChjaGlsZCk7XG4gICAgICBjaGlsZCA9IGNoaWxkLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxudmFyIGNvbW1pdEhvb2tzID0gW107XG5mdW5jdGlvbiBvbkNvbW1pdFJvb3QoKSB7XG4gIGlmIChzdXBwb3J0c1Rlc3RTZWxlY3RvcnMpIHtcbiAgICBjb21taXRIb29rcy5mb3JFYWNoKGZ1bmN0aW9uIChjb21taXRIb29rKSB7XG4gICAgICByZXR1cm4gY29tbWl0SG9vaygpO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBvYnNlcnZlVmlzaWJsZVJlY3RzKGhvc3RSb290LCBzZWxlY3RvcnMsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gIGlmICghc3VwcG9ydHNUZXN0U2VsZWN0b3JzKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUZXN0IHNlbGVjdG9yIEFQSSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoaXMgcmVuZGVyZXIuJyk7XG4gIH1cblxuICB2YXIgaW5zdGFuY2VSb290cyA9IGZpbmRBbGxOb2Rlcyhob3N0Um9vdCwgc2VsZWN0b3JzKTtcblxuICB2YXIgX3NldHVwSW50ZXJzZWN0aW9uT2JzID0gc2V0dXBJbnRlcnNlY3Rpb25PYnNlcnZlcihpbnN0YW5jZVJvb3RzLCBjYWxsYmFjaywgb3B0aW9ucyksXG4gICAgICBkaXNjb25uZWN0ID0gX3NldHVwSW50ZXJzZWN0aW9uT2JzLmRpc2Nvbm5lY3QsXG4gICAgICBvYnNlcnZlID0gX3NldHVwSW50ZXJzZWN0aW9uT2JzLm9ic2VydmUsXG4gICAgICB1bm9ic2VydmUgPSBfc2V0dXBJbnRlcnNlY3Rpb25PYnMudW5vYnNlcnZlOyAvLyBXaGVuIFJlYWN0IG11dGF0ZXMgdGhlIGhvc3QgZW52aXJvbm1lbnQsIHdlIG1heSBuZWVkIHRvIGNoYW5nZSB3aGF0IHdlJ3JlIGxpc3RlbmluZyB0by5cblxuXG4gIHZhciBjb21taXRIb29rID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBuZXh0SW5zdGFuY2VSb290cyA9IGZpbmRBbGxOb2Rlcyhob3N0Um9vdCwgc2VsZWN0b3JzKTtcbiAgICBpbnN0YW5jZVJvb3RzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgICAgaWYgKG5leHRJbnN0YW5jZVJvb3RzLmluZGV4T2YodGFyZ2V0KSA8IDApIHtcbiAgICAgICAgdW5vYnNlcnZlKHRhcmdldCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbmV4dEluc3RhbmNlUm9vdHMuZm9yRWFjaChmdW5jdGlvbiAodGFyZ2V0KSB7XG4gICAgICBpZiAoaW5zdGFuY2VSb290cy5pbmRleE9mKHRhcmdldCkgPCAwKSB7XG4gICAgICAgIG9ic2VydmUodGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICBjb21taXRIb29rcy5wdXNoKGNvbW1pdEhvb2spO1xuICByZXR1cm4ge1xuICAgIGRpc2Nvbm5lY3Q6IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIFN0b3AgbGlzdGVuaW5nIGZvciBSZWFjdCBtdXRhdGlvbnM6XG4gICAgICB2YXIgaW5kZXggPSBjb21taXRIb29rcy5pbmRleE9mKGNvbW1pdEhvb2spO1xuXG4gICAgICBpZiAoaW5kZXggPj0gMCkge1xuICAgICAgICBjb21taXRIb29rcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgfSAvLyBEaXNjb25uZWN0IHRoZSBob3N0IG9ic2VydmVyOlxuXG5cbiAgICAgIGRpc2Nvbm5lY3QoKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzQ29uY3VycmVudEFjdEVudmlyb25tZW50KCkge1xuICB7XG4gICAgdmFyIGlzUmVhY3RBY3RFbnZpcm9ubWVudEdsb2JhbCA9IC8vICRGbG93Rml4TWVbY2Fubm90LXJlc29sdmUtbmFtZV0gRmxvdyBkb2Vzbid0IGtub3cgYWJvdXQgSVNfUkVBQ1RfQUNUX0VOVklST05NRU5UIGdsb2JhbFxuICAgIHR5cGVvZiBJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQgIT09ICd1bmRlZmluZWQnID8gLy8gJEZsb3dGaXhNZVtjYW5ub3QtcmVzb2x2ZS1uYW1lXVxuICAgIElTX1JFQUNUX0FDVF9FTlZJUk9OTUVOVCA6IHVuZGVmaW5lZDtcblxuICAgIGlmICghaXNSZWFjdEFjdEVudmlyb25tZW50R2xvYmFsICYmIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAvLyBUT0RPOiBJbmNsdWRlIGxpbmsgdG8gcmVsZXZhbnQgZG9jdW1lbnRhdGlvbiBwYWdlLlxuICAgICAgZXJyb3IoJ1RoZSBjdXJyZW50IHRlc3RpbmcgZW52aXJvbm1lbnQgaXMgbm90IGNvbmZpZ3VyZWQgdG8gc3VwcG9ydCAnICsgJ2FjdCguLi4pJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzUmVhY3RBY3RFbnZpcm9ubWVudEdsb2JhbDtcbiAgfVxufVxuXG52YXIgUG9zc2libHlXZWFrTWFwID0gdHlwZW9mIFdlYWtNYXAgPT09ICdmdW5jdGlvbicgPyBXZWFrTWFwIDogTWFwO1xudmFyIE5vQ29udGV4dCA9XG4vKiAgICAgICAgICAgICAqL1xuMDtcbnZhciBCYXRjaGVkQ29udGV4dCA9XG4vKiAgICAgICAgICAgICAgICovXG4xO1xudmFyIFJlbmRlckNvbnRleHQgPVxuLyogICAgICAgICAqL1xuMjtcbnZhciBDb21taXRDb250ZXh0ID1cbi8qICAgICAgICAgKi9cbjQ7XG52YXIgUm9vdEluUHJvZ3Jlc3MgPSAwO1xudmFyIFJvb3RGYXRhbEVycm9yZWQgPSAxO1xudmFyIFJvb3RFcnJvcmVkID0gMjtcbnZhciBSb290U3VzcGVuZGVkID0gMztcbnZhciBSb290U3VzcGVuZGVkV2l0aERlbGF5ID0gNDtcbnZhciBSb290Q29tcGxldGVkID0gNTtcbnZhciBSb290RGlkTm90Q29tcGxldGUgPSA2OyAvLyBEZXNjcmliZXMgd2hlcmUgd2UgYXJlIGluIHRoZSBSZWFjdCBleGVjdXRpb24gc3RhY2tcblxudmFyIGV4ZWN1dGlvbkNvbnRleHQgPSBOb0NvbnRleHQ7IC8vIFRoZSByb290IHdlJ3JlIHdvcmtpbmcgb25cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdCA9IG51bGw7IC8vIFRoZSBmaWJlciB3ZSdyZSB3b3JraW5nIG9uXG5cbnZhciB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7IC8vIFRoZSBsYW5lcyB3ZSdyZSByZW5kZXJpbmdcblxudmFyIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gTm9MYW5lcztcbnZhciBOb3RTdXNwZW5kZWQgPSAwO1xudmFyIFN1c3BlbmRlZE9uRXJyb3IgPSAxO1xudmFyIFN1c3BlbmRlZE9uRGF0YSA9IDI7XG52YXIgU3VzcGVuZGVkT25JbW1lZGlhdGUgPSAzO1xudmFyIFN1c3BlbmRlZE9uSW5zdGFuY2UgPSA0O1xudmFyIFN1c3BlbmRlZE9uSW5zdGFuY2VBbmRSZWFkeVRvQ29udGludWUgPSA1O1xudmFyIFN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZSA9IDY7XG52YXIgU3VzcGVuZGVkQW5kUmVhZHlUb0NvbnRpbnVlID0gNztcbnZhciBTdXNwZW5kZWRPbkh5ZHJhdGlvbiA9IDg7IC8vIFdoZW4gdGhpcyBpcyB0cnVlLCB0aGUgd29yay1pbi1wcm9ncmVzcyBmaWJlciBqdXN0IHN1c3BlbmRlZCAob3IgZXJyb3JlZCkgYW5kXG4vLyB3ZSd2ZSB5ZXQgdG8gdW53aW5kIHRoZSBzdGFjay4gSW4gc29tZSBjYXNlcywgd2UgbWF5IHlpZWxkIHRvIHRoZSBtYWluIHRocmVhZFxuLy8gYWZ0ZXIgdGhpcyBoYXBwZW5zLiBJZiB0aGUgZmliZXIgaXMgcGluZ2VkIGJlZm9yZSB3ZSByZXN1bWUsIHdlIGNhbiByZXRyeVxuLy8gaW1tZWRpYXRlbHkgaW5zdGVhZCBvZiB1bndpbmRpbmcgdGhlIHN0YWNrLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG52YXIgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7IC8vIFdoZXRoZXIgYSBwaW5nIGxpc3RlbmVyIHdhcyBhdHRhY2hlZCBkdXJpbmcgdGhpcyByZW5kZXIuIFRoaXMgaXMgc2xpZ2h0bHlcbi8vIGRpZmZlcmVudCB0aGF0IHdoZXRoZXIgc29tZXRoaW5nIHN1c3BlbmRlZCwgYmVjYXVzZSB3ZSBkb24ndCBhZGQgbXVsdGlwbGVcbi8vIGxpc3RlbmVycyB0byBhIHByb21pc2Ugd2UndmUgYWxyZWFkeSBzZWVuIChwZXIgcm9vdCBhbmQgbGFuZSkuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRBdHRhY2hQaW5nTGlzdGVuZXIgPSBmYWxzZTsgLy8gQSBjb250ZXh0dWFsIHZlcnNpb24gb2Ygd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMuIEl0IGlzIGEgc3VwZXJzZXQgb2Zcbi8vIHRoZSBsYW5lcyB0aGF0IHdlIHN0YXJ0ZWQgd29ya2luZyBvbiBhdCB0aGUgcm9vdC4gV2hlbiB3ZSBlbnRlciBhIHN1YnRyZWVcbi8vIHRoYXQgaXMgY3VycmVudGx5IGhpZGRlbiwgd2UgYWRkIHRoZSBsYW5lcyB0aGF0IHdvdWxkIGhhdmUgY29tbWl0dGVkIGlmXG4vLyB0aGUgaGlkZGVuIHRyZWUgaGFkbid0IGJlZW4gZGVmZXJyZWQuIFRoaXMgaXMgbW9kaWZpZWQgYnkgdGhlXG4vLyBIaWRkZW5Db250ZXh0IG1vZHVsZS5cbi8vXG4vLyBNb3N0IHRoaW5ncyBpbiB0aGUgd29yayBsb29wIHNob3VsZCBkZWFsIHdpdGggd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMuXG4vLyBNb3N0IHRoaW5ncyBpbiBiZWdpbi9jb21wbGV0ZSBwaGFzZXMgc2hvdWxkIGRlYWwgd2l0aCBlbnRhbmdsZWRSZW5kZXJMYW5lcy5cblxudmFyIGVudGFuZ2xlZFJlbmRlckxhbmVzID0gTm9MYW5lczsgLy8gV2hldGhlciB0byByb290IGNvbXBsZXRlZCwgZXJyb3JlZCwgc3VzcGVuZGVkLCBldGMuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEluUHJvZ3Jlc3M7IC8vIFRoZSB3b3JrIGxlZnQgb3ZlciBieSBjb21wb25lbnRzIHRoYXQgd2VyZSB2aXNpdGVkIGR1cmluZyB0aGlzIHJlbmRlci4gT25seVxuLy8gaW5jbHVkZXMgdW5wcm9jZXNzZWQgdXBkYXRlcywgbm90IHdvcmsgaW4gYmFpbGVkIG91dCBjaGlsZHJlbi5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyA9IE5vTGFuZXM7IC8vIExhbmVzIHRoYXQgd2VyZSB1cGRhdGVkIChpbiBhbiBpbnRlcmxlYXZlZCBldmVudCkgZHVyaW5nIHRoaXMgcmVuZGVyLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgPSBOb0xhbmVzOyAvLyBMYW5lcyB0aGF0IHdlcmUgdXBkYXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZSAoKm5vdCogYW4gaW50ZXJsZWF2ZWQgZXZlbnQpLlxuXG52YXIgd29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMgPSBOb0xhbmVzOyAvLyBJZiB0aGlzIGxhbmUgc2NoZWR1bGVkIGRlZmVycmVkIHdvcmssIHRoaXMgaXMgdGhlIGxhbmUgb2YgdGhlIGRlZmVycmVkIHRhc2suXG5cbnZhciB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSA9IE5vTGFuZTsgLy8gRXJyb3JzIHRoYXQgYXJlIHRocm93biBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMgPSBudWxsOyAvLyBUaGVzZSBhcmUgZXJyb3JzIHRoYXQgd2UgcmVjb3ZlcmVkIGZyb20gd2l0aG91dCBzdXJmYWNpbmcgdGhlbSB0byB0aGUgVUkuXG4vLyBXZSB3aWxsIGxvZyB0aGVtIG9uY2UgdGhlIHRyZWUgY29tbWl0cy5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID0gbnVsbDsgLy8gVHJhY2tzIHdoZW4gYW4gdXBkYXRlIG9jY3VycyBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS5cblxudmFyIHdvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUgPSBmYWxzZTsgLy8gVGhhY2tzIHdoZW4gYW4gdXBkYXRlIG9jY3VycyBkdXJpbmcgdGhlIGNvbW1pdCBwaGFzZS4gSXQncyBhIHNlcGFyYXRlXG4vLyB2YXJpYWJsZSBmcm9tIHRoZSBvbmUgZm9yIHJlbmRlcnMgYmVjYXVzZSB0aGUgY29tbWl0IHBoYXNlIG1heSBydW5cbi8vIGNvbmN1cnJlbnRseSB0byBhIHJlbmRlciBwaGFzZS5cblxudmFyIGRpZEluY2x1ZGVDb21taXRQaGFzZVVwZGF0ZSA9IGZhbHNlOyAvLyBUaGUgbW9zdCByZWNlbnQgdGltZSB3ZSBlaXRoZXIgY29tbWl0dGVkIGEgZmFsbGJhY2ssIG9yIHdoZW4gYSBmYWxsYmFjayB3YXNcbi8vIGZpbGxlZCBpbiB3aXRoIHRoZSByZXNvbHZlZCBVSS4gVGhpcyBsZXRzIHVzIHRocm90dGxlIHRoZSBhcHBlYXJhbmNlIG9mIG5ld1xuLy8gY29udGVudCBhcyBpdCBzdHJlYW1zIGluLCB0byBtaW5pbWl6ZSBqYW5rLlxuLy8gVE9ETzogVGhpbmsgb2YgYSBiZXR0ZXIgbmFtZSBmb3IgdGhpcyB2YXJpYWJsZT9cblxudmFyIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPSAwO1xudmFyIEZBTExCQUNLX1RIUk9UVExFX01TID0gMzAwOyAvLyBUaGUgYWJzb2x1dGUgdGltZSBmb3Igd2hlbiB3ZSBzaG91bGQgc3RhcnQgZ2l2aW5nIHVwIG9uIHJlbmRlcmluZ1xuLy8gbW9yZSBhbmQgcHJlZmVyIENQVSBzdXNwZW5zZSBoZXVyaXN0aWNzIGluc3RlYWQuXG5cbnZhciB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lID0gSW5maW5pdHk7IC8vIEhvdyBsb25nIGEgcmVuZGVyIGlzIHN1cHBvc2VkIHRvIHRha2UgYmVmb3JlIHdlIHN0YXJ0IGZvbGxvd2luZyBDUFVcbi8vIHN1c3BlbnNlIGhldXJpc3RpY3MgYW5kIG9wdCBvdXQgb2YgcmVuZGVyaW5nIG1vcmUgY29udGVudC5cblxudmFyIFJFTkRFUl9USU1FT1VUX01TID0gNTAwO1xudmFyIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMgPSBudWxsO1xuXG5mdW5jdGlvbiByZXNldFJlbmRlclRpbWVyKCkge1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lID0gbm93JDEoKSArIFJFTkRFUl9USU1FT1VUX01TO1xufVxuXG5mdW5jdGlvbiBnZXRSZW5kZXJUYXJnZXRUaW1lKCkge1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyVGFyZ2V0VGltZTtcbn1cbnZhciBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG51bGw7XG52YXIgcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMgPSBmYWxzZTtcbnZhciByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9IG51bGw7XG52YXIgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMgPSBOb0xhbmVzO1xudmFyIHBlbmRpbmdQYXNzaXZlUHJvZmlsZXJFZmZlY3RzID0gW107XG52YXIgcGVuZGluZ1Bhc3NpdmVFZmZlY3RzUmVtYWluaW5nTGFuZXMgPSBOb0xhbmVzO1xudmFyIHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMgPSBudWxsOyAvLyBVc2UgdGhlc2UgdG8gcHJldmVudCBhbiBpbmZpbml0ZSBsb29wIG9mIG5lc3RlZCB1cGRhdGVzXG5cbnZhciBORVNURURfVVBEQVRFX0xJTUlUID0gNTA7XG52YXIgbmVzdGVkVXBkYXRlQ291bnQgPSAwO1xudmFyIHJvb3RXaXRoTmVzdGVkVXBkYXRlcyA9IG51bGw7XG52YXIgaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzID0gZmFsc2U7XG52YXIgZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xudmFyIE5FU1RFRF9QQVNTSVZFX1VQREFURV9MSU1JVCA9IDUwO1xudmFyIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDA7XG52YXIgcm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcyA9IG51bGw7XG52YXIgaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0ID0gZmFsc2U7XG5mdW5jdGlvbiBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QoKSB7XG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzc1Jvb3Q7XG59XG5mdW5jdGlvbiBnZXRXb3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcygpIHtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzO1xufVxuZnVuY3Rpb24gaXNXb3JrTG9vcFN1c3BlbmRlZE9uRGF0YSgpIHtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID09PSBTdXNwZW5kZWRPbkRhdGE7XG59XG5mdW5jdGlvbiByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcikge1xuXG4gIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpICE9PSBOb0NvbnRleHQgJiYgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAvLyBUaGlzIGlzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gVGhlc2UgYXJlIG5vdCBvZmZpY2lhbGx5IHN1cHBvcnRlZC4gVGhlXG4gICAgLy8gb2xkIGJlaGF2aW9yIGlzIHRvIGdpdmUgdGhpcyB0aGUgc2FtZSBcInRocmVhZFwiIChsYW5lcykgYXNcbiAgICAvLyB3aGF0ZXZlciBpcyBjdXJyZW50bHkgcmVuZGVyaW5nLiBTbyBpZiB5b3UgY2FsbCBgc2V0U3RhdGVgIG9uIGEgY29tcG9uZW50XG4gICAgLy8gdGhhdCBoYXBwZW5zIGxhdGVyIGluIHRoZSBzYW1lIHJlbmRlciwgaXQgd2lsbCBmbHVzaC4gSWRlYWxseSwgd2Ugd2FudCB0b1xuICAgIC8vIHJlbW92ZSB0aGUgc3BlY2lhbCBjYXNlIGFuZCB0cmVhdCB0aGVtIGFzIGlmIHRoZXkgY2FtZSBmcm9tIGFuXG4gICAgLy8gaW50ZXJsZWF2ZWQgZXZlbnQuIFJlZ2FyZGxlc3MsIHRoaXMgcGF0dGVybiBpcyBub3Qgb2ZmaWNpYWxseSBzdXBwb3J0ZWQuXG4gICAgLy8gVGhpcyBiZWhhdmlvciBpcyBvbmx5IGEgZmFsbGJhY2suIFRoZSBmbGFnIG9ubHkgZXhpc3RzIHVudGlsIHdlIGNhbiByb2xsXG4gICAgLy8gb3V0IHRoZSBzZXRTdGF0ZSB3YXJuaW5nLCBzaW5jZSBleGlzdGluZyBjb2RlIG1pZ2h0IGFjY2lkZW50YWxseSByZWx5IG9uXG4gICAgLy8gdGhlIGN1cnJlbnQgYmVoYXZpb3IuXG4gICAgcmV0dXJuIHBpY2tBcmJpdHJhcnlMYW5lKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgfVxuXG4gIHZhciB0cmFuc2l0aW9uID0gcmVxdWVzdEN1cnJlbnRUcmFuc2l0aW9uKCk7XG5cbiAgaWYgKHRyYW5zaXRpb24gIT09IG51bGwpIHtcbiAgICB7XG4gICAgICBpZiAoIXRyYW5zaXRpb24uX3VwZGF0ZWRGaWJlcnMpIHtcbiAgICAgICAgdHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycyA9IG5ldyBTZXQoKTtcbiAgICAgIH1cblxuICAgICAgdHJhbnNpdGlvbi5fdXBkYXRlZEZpYmVycy5hZGQoZmliZXIpO1xuICAgIH1cblxuICAgIHZhciBhY3Rpb25TY29wZUxhbmUgPSBwZWVrRW50YW5nbGVkQWN0aW9uTGFuZSgpO1xuICAgIHJldHVybiBhY3Rpb25TY29wZUxhbmUgIT09IE5vTGFuZSA/IC8vIFdlJ3JlIGluc2lkZSBhbiBhc3luYyBhY3Rpb24gc2NvcGUuIFJldXNlIHRoZSBzYW1lIGxhbmUuXG4gICAgYWN0aW9uU2NvcGVMYW5lIDogLy8gV2UgbWF5IG9yIG1heSBub3QgYmUgaW5zaWRlIGFuIGFzeW5jIGFjdGlvbiBzY29wZS4gSWYgd2UgYXJlLCB0aGlzXG4gICAgLy8gaXMgdGhlIGZpcnN0IHVwZGF0ZSBpbiB0aGF0IHNjb3BlLiBFaXRoZXIgd2F5LCB3ZSBuZWVkIHRvIGdldCBhXG4gICAgLy8gZnJlc2ggdHJhbnNpdGlvbiBsYW5lLlxuICAgIHJlcXVlc3RUcmFuc2l0aW9uTGFuZSgpO1xuICB9XG5cbiAgcmV0dXJuIGV2ZW50UHJpb3JpdHlUb0xhbmUocmVzb2x2ZVVwZGF0ZVByaW9yaXR5KCkpO1xufVxuXG5mdW5jdGlvbiByZXF1ZXN0UmV0cnlMYW5lKGZpYmVyKSB7XG5cbiAgcmV0dXJuIGNsYWltTmV4dFJldHJ5TGFuZSgpO1xufVxuXG5mdW5jdGlvbiByZXF1ZXN0RGVmZXJyZWRMYW5lKCkge1xuICBpZiAod29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUgPT09IE5vTGFuZSkge1xuICAgIC8vIElmIHRoZXJlIGFyZSBtdWx0aXBsZSB1c2VEZWZlcnJlZFZhbHVlIGhvb2tzIGluIHRoZSBzYW1lIHJlbmRlciwgdGhlXG4gICAgLy8gdGFza3MgdGhhdCB0aGV5IHNwYXduIHNob3VsZCBhbGwgYmUgYmF0Y2hlZCB0b2dldGhlciwgc28gdGhleSBzaG91bGQgYWxsXG4gICAgLy8gcmVjZWl2ZSB0aGUgc2FtZSBsYW5lLlxuICAgIC8vIENoZWNrIHRoZSBwcmlvcml0eSBvZiB0aGUgY3VycmVudCByZW5kZXIgdG8gZGVjaWRlIHRoZSBwcmlvcml0eSBvZiB0aGVcbiAgICAvLyBkZWZlcnJlZCB0YXNrLlxuICAgIC8vIE9mZnNjcmVlbkxhbmUgaXMgdXNlZCBmb3IgcHJlcmVuZGVyaW5nLCBidXQgd2UgYWxzbyB1c2UgT2Zmc2NyZWVuTGFuZVxuICAgIC8vIGZvciBpbmNyZW1lbnRhbCBoeWRyYXRpb24uIEl0J3MgZ2l2ZW4gdGhlIGxvd2VzdCBwcmlvcml0eSBiZWNhdXNlIHRoZVxuICAgIC8vIGluaXRpYWwgSFRNTCBpcyB0aGUgc2FtZSBhcyB0aGUgZmluYWwgVUkuIEJ1dCB1c2VEZWZlcnJlZFZhbHVlIGR1cmluZ1xuICAgIC8vIGh5ZHJhdGlvbiBpcyBhbiBleGNlcHRpb24g4oCUIHdlIG5lZWQgdG8gdXBncmFkZSB0aGUgVUkgdG8gdGhlIGZpbmFsXG4gICAgLy8gdmFsdWUuIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBoeWRyYXRpbmcsIHdlIHRyZWF0IGl0IGxpa2UgYSB0cmFuc2l0aW9uLlxuICAgIHZhciBpc1ByZXJlbmRlcmluZyA9IGluY2x1ZGVzU29tZUxhbmUod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMsIE9mZnNjcmVlbkxhbmUpICYmICFnZXRJc0h5ZHJhdGluZygpO1xuXG4gICAgaWYgKGlzUHJlcmVuZGVyaW5nKSB7XG4gICAgICAvLyBUaGVyZSdzIG9ubHkgb25lIE9mZnNjcmVlbkxhbmUsIHNvIGlmIGl0IGNvbnRhaW5zIGRlZmVycmVkIHdvcmssIHdlXG4gICAgICAvLyBzaG91bGQganVzdCByZXNjaGVkdWxlIHVzaW5nIHRoZSBzYW1lIGxhbmUuXG4gICAgICB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSA9IE9mZnNjcmVlbkxhbmU7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpcyBzcGF3bmVkIGFzIGEgdHJhbnNpdGlvbi5cbiAgICAgIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lID0gY2xhaW1OZXh0VHJhbnNpdGlvbkxhbmUoKTtcbiAgICB9XG4gIH0gLy8gTWFyayB0aGUgcGFyZW50IFN1c3BlbnNlIGJvdW5kYXJ5IHNvIGl0IGtub3dzIHRvIHNwYXduIHRoZSBkZWZlcnJlZCBsYW5lLlxuXG5cbiAgdmFyIHN1c3BlbnNlSGFuZGxlciA9IGdldFN1c3BlbnNlSGFuZGxlcigpO1xuXG4gIGlmIChzdXNwZW5zZUhhbmRsZXIgIT09IG51bGwpIHtcbiAgICAvLyBUT0RPOiBBcyBhbiBvcHRpbWl6YXRpb24sIHdlIHNob3VsZG4ndCBlbnRhbmdsZSB0aGUgbGFuZXMgYXQgdGhlIHJvb3Q7IHdlXG4gICAgLy8gY2FuIGVudGFuZ2xlIHRoZW0gdXNpbmcgdGhlIGJhc2VMYW5lcyBvZiB0aGUgU3VzcGVuc2UgYm91bmRhcnkgaW5zdGVhZC5cbiAgICAvLyBXZSBvbmx5IG5lZWQgdG8gZG8gc29tZXRoaW5nIHNwZWNpYWwgaWYgdGhlcmUncyBubyBTdXNwZW5zZSBib3VuZGFyeS5cbiAgICBzdXNwZW5zZUhhbmRsZXIuZmxhZ3MgfD0gRGlkRGVmZXI7XG4gIH1cblxuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmU7XG59XG5mdW5jdGlvbiBwZWVrRGVmZXJyZWRMYW5lKCkge1xuICByZXR1cm4gd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmU7XG59XG5mdW5jdGlvbiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIGxhbmUpIHtcbiAge1xuICAgIGlmIChpc1J1bm5pbmdJbnNlcnRpb25FZmZlY3QpIHtcbiAgICAgIGVycm9yKCd1c2VJbnNlcnRpb25FZmZlY3QgbXVzdCBub3Qgc2NoZWR1bGUgdXBkYXRlcy4nKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgaWYgKGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cykge1xuICAgICAgZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyA9IHRydWU7XG4gICAgfVxuICB9IC8vIENoZWNrIGlmIHRoZSB3b3JrIGxvb3AgaXMgY3VycmVudGx5IHN1c3BlbmRlZCBhbmQgd2FpdGluZyBmb3IgZGF0YSB0b1xuICAvLyBmaW5pc2ggbG9hZGluZy5cblxuXG4gIGlmICggLy8gU3VzcGVuZGVkIHJlbmRlciBwaGFzZVxuICByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgJiYgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPT09IFN1c3BlbmRlZE9uRGF0YSB8fCAvLyBTdXNwZW5kZWQgY29tbWl0IHBoYXNlXG4gIHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdCAhPT0gbnVsbCkge1xuICAgIC8vIFRoZSBpbmNvbWluZyB1cGRhdGUgbWlnaHQgdW5ibG9jayB0aGUgY3VycmVudCByZW5kZXIuIEludGVycnVwdCB0aGVcbiAgICAvLyBjdXJyZW50IGF0dGVtcHQgYW5kIHJlc3RhcnQgZnJvbSB0aGUgdG9wLlxuICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIE5vTGFuZXMpO1xuICAgIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzLCB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSk7XG4gIH0gLy8gTWFyayB0aGF0IHRoZSByb290IGhhcyBhIHBlbmRpbmcgdXBkYXRlLlxuXG5cbiAgbWFya1Jvb3RVcGRhdGVkKHJvb3QsIGxhbmUpO1xuXG4gIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpICE9PSBOb0xhbmVzICYmIHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCkge1xuICAgIC8vIFRoaXMgdXBkYXRlIHdhcyBkaXNwYXRjaGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLiBUaGlzIGlzIGEgbWlzdGFrZVxuICAgIC8vIGlmIHRoZSB1cGRhdGUgb3JpZ2luYXRlcyBmcm9tIHVzZXIgc3BhY2UgKHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBsb2NhbFxuICAgIC8vIGhvb2sgdXBkYXRlcywgd2hpY2ggYXJlIGhhbmRsZWQgZGlmZmVyZW50bHkgYW5kIGRvbid0IHJlYWNoIHRoaXNcbiAgICAvLyBmdW5jdGlvbiksIGJ1dCB0aGVyZSBhcmUgc29tZSBpbnRlcm5hbCBSZWFjdCBmZWF0dXJlcyB0aGF0IHVzZSB0aGlzIGFzXG4gICAgLy8gYW4gaW1wbGVtZW50YXRpb24gZGV0YWlsLCBsaWtlIHNlbGVjdGl2ZSBoeWRyYXRpb24uXG4gICAgd2FybkFib3V0UmVuZGVyUGhhc2VVcGRhdGVzSW5ERVYoZmliZXIpOyAvLyBUcmFjayBsYW5lcyB0aGF0IHdlcmUgdXBkYXRlZCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZVxuICB9IGVsc2Uge1xuICAgIC8vIFRoaXMgaXMgYSBub3JtYWwgdXBkYXRlLCBzY2hlZHVsZWQgZnJvbSBvdXRzaWRlIHRoZSByZW5kZXIgcGhhc2UuIEZvclxuICAgIC8vIGV4YW1wbGUsIGR1cmluZyBhbiBpbnB1dCBldmVudC5cbiAgICB7XG4gICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgICAgYWRkRmliZXJUb0xhbmVzTWFwKHJvb3QsIGZpYmVyLCBsYW5lKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3YXJuSWZVcGRhdGVzTm90V3JhcHBlZFdpdGhBY3RERVYoZmliZXIpO1xuXG4gICAgaWYgKHJvb3QgPT09IHdvcmtJblByb2dyZXNzUm9vdCkge1xuICAgICAgLy8gUmVjZWl2ZWQgYW4gdXBkYXRlIHRvIGEgdHJlZSB0aGF0J3MgaW4gdGhlIG1pZGRsZSBvZiByZW5kZXJpbmcuIE1hcmtcbiAgICAgIC8vIHRoYXQgdGhlcmUgd2FzIGFuIGludGVybGVhdmVkIHVwZGF0ZSB3b3JrIG9uIHRoaXMgcm9vdC5cbiAgICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpID09PSBOb0NvbnRleHQpIHtcbiAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgPSBtZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzLCBsYW5lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXkpIHtcbiAgICAgICAgLy8gVGhlIHJvb3QgYWxyZWFkeSBzdXNwZW5kZWQgd2l0aCBhIGRlbGF5LCB3aGljaCBtZWFucyB0aGlzIHJlbmRlclxuICAgICAgICAvLyBkZWZpbml0ZWx5IHdvbid0IGZpbmlzaC4gU2luY2Ugd2UgaGF2ZSBhIG5ldyB1cGRhdGUsIGxldCdzIG1hcmsgaXQgYXNcbiAgICAgICAgLy8gc3VzcGVuZGVkIG5vdywgcmlnaHQgYmVmb3JlIG1hcmtpbmcgdGhlIGluY29taW5nIHVwZGF0ZS4gVGhpcyBoYXMgdGhlXG4gICAgICAgIC8vIGVmZmVjdCBvZiBpbnRlcnJ1cHRpbmcgdGhlIGN1cnJlbnQgcmVuZGVyIGFuZCBzd2l0Y2hpbmcgdG8gdGhlIHVwZGF0ZS5cbiAgICAgICAgLy8gVE9ETzogTWFrZSBzdXJlIHRoaXMgZG9lc24ndCBvdmVycmlkZSBwaW5ncyB0aGF0IGhhcHBlbiB3aGlsZSB3ZSd2ZVxuICAgICAgICAvLyBhbHJlYWR5IHN0YXJ0ZWQgcmVuZGVyaW5nLlxuICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChyb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcywgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcblxuICAgIGlmIChsYW5lID09PSBTeW5jTGFuZSAmJiBleGVjdXRpb25Db250ZXh0ID09PSBOb0NvbnRleHQgJiYgIWRpc2FibGVMZWdhY3lNb2RlICYmIChmaWJlci5tb2RlICYgQ29uY3VycmVudE1vZGUpID09PSBOb01vZGUpIHtcbiAgICAgIGlmIChSZWFjdFNoYXJlZEludGVybmFscy5pc0JhdGNoaW5nTGVnYWN5KSA7IGVsc2Uge1xuICAgICAgICAvLyBGbHVzaCB0aGUgc3luY2hyb25vdXMgd29yayBub3csIHVubGVzcyB3ZSdyZSBhbHJlYWR5IHdvcmtpbmcgb3IgaW5zaWRlXG4gICAgICAgIC8vIGEgYmF0Y2guIFRoaXMgaXMgaW50ZW50aW9uYWxseSBpbnNpZGUgc2NoZWR1bGVVcGRhdGVPbkZpYmVyIGluc3RlYWQgb2ZcbiAgICAgICAgLy8gc2NoZWR1bGVDYWxsYmFja0ZvckZpYmVyIHRvIHByZXNlcnZlIHRoZSBhYmlsaXR5IHRvIHNjaGVkdWxlIGEgY2FsbGJhY2tcbiAgICAgICAgLy8gd2l0aG91dCBpbW1lZGlhdGVseSBmbHVzaGluZyBpdC4gV2Ugb25seSBkbyB0aGlzIGZvciB1c2VyLWluaXRpYXRlZFxuICAgICAgICAvLyB1cGRhdGVzLCB0byBwcmVzZXJ2ZSBoaXN0b3JpY2FsIGJlaGF2aW9yIG9mIGxlZ2FjeSBtb2RlLlxuICAgICAgICByZXNldFJlbmRlclRpbWVyKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBzY2hlZHVsZUluaXRpYWxIeWRyYXRpb25PblJvb3Qocm9vdCwgbGFuZSkge1xuICAvLyBUaGlzIGlzIGEgc3BlY2lhbCBmb3JrIG9mIHNjaGVkdWxlVXBkYXRlT25GaWJlciB0aGF0IGlzIG9ubHkgdXNlZCB0b1xuICAvLyBzY2hlZHVsZSB0aGUgaW5pdGlhbCBoeWRyYXRpb24gb2YgYSByb290IHRoYXQgaGFzIGp1c3QgYmVlbiBjcmVhdGVkLiBNb3N0XG4gIC8vIG9mIHRoZSBzdHVmZiBpbiBzY2hlZHVsZVVwZGF0ZU9uRmliZXIgY2FuIGJlIHNraXBwZWQuXG4gIC8vXG4gIC8vIFRoZSBtYWluIHJlYXNvbiBmb3IgdGhpcyBzZXBhcmF0ZSBwYXRoLCB0aG91Z2gsIGlzIHRvIGRpc3Rpbmd1aXNoIHRoZVxuICAvLyBpbml0aWFsIGNoaWxkcmVuIGZyb20gc3Vic2VxdWVudCB1cGRhdGVzLiBJbiBmdWxseSBjbGllbnQtcmVuZGVyZWQgcm9vdHNcbiAgLy8gKGNyZWF0ZVJvb3QgaW5zdGVhZCBvZiBoeWRyYXRlUm9vdCksIGFsbCB0b3AtbGV2ZWwgcmVuZGVycyBhcmUgbW9kZWxlZCBhc1xuICAvLyB1cGRhdGVzLCBidXQgaHlkcmF0aW9uIHJvb3RzIGFyZSBzcGVjaWFsIGJlY2F1c2UgdGhlIGluaXRpYWwgcmVuZGVyIG11c3RcbiAgLy8gbWF0Y2ggd2hhdCB3YXMgcmVuZGVyZWQgb24gdGhlIHNlcnZlci5cbiAgdmFyIGN1cnJlbnQgPSByb290LmN1cnJlbnQ7XG4gIGN1cnJlbnQubGFuZXMgPSBsYW5lO1xuICBtYXJrUm9vdFVwZGF0ZWQocm9vdCwgbGFuZSk7XG4gIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbn1cbmZ1bmN0aW9uIGlzVW5zYWZlQ2xhc3NSZW5kZXJQaGFzZVVwZGF0ZShmaWJlcikge1xuICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgcmVuZGVyIHBoYXNlIHVwZGF0ZS4gT25seSBjYWxsZWQgYnkgY2xhc3MgY29tcG9uZW50cyxcbiAgLy8gd2hpY2ggc3BlY2lhbCAoZGVwcmVjYXRlZCkgYmVoYXZpb3IgZm9yIFVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZSBwcm9wcy5cbiAgcmV0dXJuIChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgIT09IE5vQ29udGV4dDtcbn0gLy8gVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZm9yIGV2ZXJ5IGNvbmN1cnJlbnQgdGFzaywgaS5lLiBhbnl0aGluZyB0aGF0XG4vLyBnb2VzIHRocm91Z2ggU2NoZWR1bGVyLlxuXG5mdW5jdGlvbiBwZXJmb3JtQ29uY3VycmVudFdvcmtPblJvb3Qocm9vdCwgZGlkVGltZW91dCkge1xuICB7XG4gICAgcmVzZXROZXN0ZWRVcGRhdGVGbGFnKCk7XG4gIH1cblxuICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy4nKTtcbiAgfSAvLyBGbHVzaCBhbnkgcGVuZGluZyBwYXNzaXZlIGVmZmVjdHMgYmVmb3JlIGRlY2lkaW5nIHdoaWNoIGxhbmVzIHRvIHdvcmsgb24sXG4gIC8vIGluIGNhc2UgdGhleSBzY2hlZHVsZSBhZGRpdGlvbmFsIHdvcmsuXG5cblxuICB2YXIgb3JpZ2luYWxDYWxsYmFja05vZGUgPSByb290LmNhbGxiYWNrTm9kZTtcbiAgdmFyIGRpZEZsdXNoUGFzc2l2ZUVmZmVjdHMgPSBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG5cbiAgaWYgKGRpZEZsdXNoUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAvLyBTb21ldGhpbmcgaW4gdGhlIHBhc3NpdmUgZWZmZWN0IHBoYXNlIG1heSBoYXZlIGNhbmNlbGVkIHRoZSBjdXJyZW50IHRhc2suXG4gICAgLy8gQ2hlY2sgaWYgdGhlIHRhc2sgbm9kZSBmb3IgdGhpcyByb290IHdhcyBjaGFuZ2VkLlxuICAgIGlmIChyb290LmNhbGxiYWNrTm9kZSAhPT0gb3JpZ2luYWxDYWxsYmFja05vZGUpIHtcbiAgICAgIC8vIFRoZSBjdXJyZW50IHRhc2sgd2FzIGNhbmNlbGVkLiBFeGl0LiBXZSBkb24ndCBuZWVkIHRvIGNhbGxcbiAgICAgIC8vIGBlbnN1cmVSb290SXNTY2hlZHVsZWRgIGJlY2F1c2UgdGhlIGNoZWNrIGFib3ZlIGltcGxpZXMgZWl0aGVyIHRoYXRcbiAgICAgIC8vIHRoZXJlJ3MgYSBuZXcgdGFzaywgb3IgdGhhdCB0aGVyZSdzIG5vIHJlbWFpbmluZyB3b3JrIG9uIHRoaXMgcm9vdC5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSAvLyBEZXRlcm1pbmUgdGhlIG5leHQgbGFuZXMgdG8gd29yayBvbiwgdXNpbmcgdGhlIGZpZWxkcyBzdG9yZWRcbiAgLy8gb24gdGhlIHJvb3QuXG4gIC8vIFRPRE86IFRoaXMgd2FzIGFscmVhZHkgY29tcHV0ZWQgaW4gdGhlIGNhbGxlci4gUGFzcyBpdCBhcyBhbiBhcmd1bWVudC5cblxuXG4gIHZhciBsYW5lcyA9IGdldE5leHRMYW5lcyhyb290LCByb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QgPyB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA6IE5vTGFuZXMpO1xuXG4gIGlmIChsYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIC8vIERlZmVuc2l2ZSBjb2RpbmcuIFRoaXMgaXMgbmV2ZXIgZXhwZWN0ZWQgdG8gaGFwcGVuLlxuICAgIHJldHVybiBudWxsO1xuICB9IC8vIFdlIGRpc2FibGUgdGltZS1zbGljaW5nIGluIHNvbWUgY2FzZXM6IGlmIHRoZSB3b3JrIGhhcyBiZWVuIENQVS1ib3VuZFxuICAvLyBmb3IgdG9vIGxvbmcgKFwiZXhwaXJlZFwiIHdvcmssIHRvIHByZXZlbnQgc3RhcnZhdGlvbiksIG9yIHdlJ3JlIGluXG4gIC8vIHN5bmMtdXBkYXRlcy1ieS1kZWZhdWx0IG1vZGUuXG4gIC8vIFRPRE86IFdlIG9ubHkgY2hlY2sgYGRpZFRpbWVvdXRgIGRlZmVuc2l2ZWx5LCB0byBhY2NvdW50IGZvciBhIFNjaGVkdWxlclxuICAvLyBidWcgd2UncmUgc3RpbGwgaW52ZXN0aWdhdGluZy4gT25jZSB0aGUgYnVnIGluIFNjaGVkdWxlciBpcyBmaXhlZCxcbiAgLy8gd2UgY2FuIHJlbW92ZSB0aGlzLCBzaW5jZSB3ZSB0cmFjayBleHBpcmF0aW9uIG91cnNlbHZlcy5cblxuXG4gIHZhciBzaG91bGRUaW1lU2xpY2UgPSAhaW5jbHVkZXNCbG9ja2luZ0xhbmUocm9vdCwgbGFuZXMpICYmICFpbmNsdWRlc0V4cGlyZWRMYW5lKHJvb3QsIGxhbmVzKSAmJiAoIWRpZFRpbWVvdXQpO1xuICB2YXIgZXhpdFN0YXR1cyA9IHNob3VsZFRpbWVTbGljZSA/IHJlbmRlclJvb3RDb25jdXJyZW50KHJvb3QsIGxhbmVzKSA6IHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzKTtcblxuICBpZiAoZXhpdFN0YXR1cyAhPT0gUm9vdEluUHJvZ3Jlc3MpIHtcbiAgICB2YXIgcmVuZGVyV2FzQ29uY3VycmVudCA9IHNob3VsZFRpbWVTbGljZTtcblxuICAgIGRvIHtcbiAgICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RGlkTm90Q29tcGxldGUpIHtcbiAgICAgICAgLy8gVGhlIHJlbmRlciB1bndvdW5kIHdpdGhvdXQgY29tcGxldGluZyB0aGUgdHJlZS4gVGhpcyBoYXBwZW5zIGluIHNwZWNpYWxcbiAgICAgICAgLy8gY2FzZXMgd2hlcmUgbmVlZCB0byBleGl0IHRoZSBjdXJyZW50IHJlbmRlciB3aXRob3V0IHByb2R1Y2luZyBhXG4gICAgICAgIC8vIGNvbnNpc3RlbnQgdHJlZSBvciBjb21taXR0aW5nLlxuICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChyb290LCBsYW5lcywgTm9MYW5lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoZSByZW5kZXIgY29tcGxldGVkLlxuICAgICAgICAvLyBDaGVjayBpZiB0aGlzIHJlbmRlciBtYXkgaGF2ZSB5aWVsZGVkIHRvIGEgY29uY3VycmVudCBldmVudCwgYW5kIGlmIHNvLFxuICAgICAgICAvLyBjb25maXJtIHRoYXQgYW55IG5ld2x5IHJlbmRlcmVkIHN0b3JlcyBhcmUgY29uc2lzdGVudC5cbiAgICAgICAgLy8gVE9ETzogSXQncyBwb3NzaWJsZSB0aGF0IGV2ZW4gYSBjb25jdXJyZW50IHJlbmRlciBtYXkgbmV2ZXIgaGF2ZSB5aWVsZGVkXG4gICAgICAgIC8vIHRvIHRoZSBtYWluIHRocmVhZCwgaWYgaXQgd2FzIGZhc3QgZW5vdWdoLCBvciBpZiBpdCBleHBpcmVkLiBXZSBjb3VsZFxuICAgICAgICAvLyBza2lwIHRoZSBjb25zaXN0ZW5jeSBjaGVjayBpbiB0aGF0IGNhc2UsIHRvby5cbiAgICAgICAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuY3VycmVudC5hbHRlcm5hdGU7XG5cbiAgICAgICAgaWYgKHJlbmRlcldhc0NvbmN1cnJlbnQgJiYgIWlzUmVuZGVyQ29uc2lzdGVudFdpdGhFeHRlcm5hbFN0b3JlcyhmaW5pc2hlZFdvcmspKSB7XG4gICAgICAgICAgLy8gQSBzdG9yZSB3YXMgbXV0YXRlZCBpbiBhbiBpbnRlcmxlYXZlZCBldmVudC4gUmVuZGVyIGFnYWluLFxuICAgICAgICAgIC8vIHN5bmNocm9ub3VzbHksIHRvIGJsb2NrIGZ1cnRoZXIgbXV0YXRpb25zLlxuICAgICAgICAgIGV4aXRTdGF0dXMgPSByZW5kZXJSb290U3luYyhyb290LCBsYW5lcyk7IC8vIFdlIGFzc3VtZSB0aGUgdHJlZSBpcyBub3cgY29uc2lzdGVudCBiZWNhdXNlIHdlIGRpZG4ndCB5aWVsZCB0byBhbnlcbiAgICAgICAgICAvLyBjb25jdXJyZW50IGV2ZW50cy5cblxuICAgICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnQgPSBmYWxzZTsgLy8gTmVlZCB0byBjaGVjayB0aGUgZXhpdCBzdGF0dXMgYWdhaW4uXG5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBDaGVjayBpZiBzb21ldGhpbmcgdGhyZXdcblxuXG4gICAgICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RXJyb3JlZCkge1xuICAgICAgICAgIHZhciBsYW5lc1RoYXRKdXN0RXJyb3JlZCA9IGxhbmVzO1xuICAgICAgICAgIHZhciBlcnJvclJldHJ5TGFuZXMgPSBnZXRMYW5lc1RvUmV0cnlTeW5jaHJvbm91c2x5T25FcnJvcihyb290LCBsYW5lc1RoYXRKdXN0RXJyb3JlZCk7XG5cbiAgICAgICAgICBpZiAoZXJyb3JSZXRyeUxhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICAgICAgICBsYW5lcyA9IGVycm9yUmV0cnlMYW5lcztcbiAgICAgICAgICAgIGV4aXRTdGF0dXMgPSByZWNvdmVyRnJvbUNvbmN1cnJlbnRFcnJvcihyb290LCBsYW5lc1RoYXRKdXN0RXJyb3JlZCwgZXJyb3JSZXRyeUxhbmVzKTtcbiAgICAgICAgICAgIHJlbmRlcldhc0NvbmN1cnJlbnQgPSBmYWxzZTsgLy8gTmVlZCB0byBjaGVjayB0aGUgZXhpdCBzdGF0dXMgYWdhaW4uXG5cbiAgICAgICAgICAgIGlmIChleGl0U3RhdHVzICE9PSBSb290RXJyb3JlZCkge1xuICAgICAgICAgICAgICAvLyBUaGUgcm9vdCBkaWQgbm90IGVycm9yIHRoaXMgdGltZS4gUmVzdGFydCB0aGUgZXhpdCBhbGdvcml0aG1cbiAgICAgICAgICAgICAgLy8gZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAgICAgICAgICAvLyBUT0RPOiBSZWZhY3RvciB0aGUgZXhpdCBhbGdvcml0aG0gdG8gYmUgbGVzcyBjb25mdXNpbmcuIE1heWJlXG4gICAgICAgICAgICAgIC8vIG1vcmUgYnJhbmNoZXMgKyByZWN1cnNpb24gaW5zdGVhZCBvZiBhIGxvb3AuIEkgdGhpbmsgdGhlIG9ubHlcbiAgICAgICAgICAgICAgLy8gdGhpbmcgdGhhdCBjYXVzZXMgaXQgdG8gYmUgYSBsb29wIGlzIHRoZSBSb290RGlkTm90Q29tcGxldGVcbiAgICAgICAgICAgICAgLy8gY2hlY2suIElmIHRoYXQncyB0cnVlLCB0aGVuIHdlIGRvbid0IG5lZWQgYSBsb29wL3JlY3Vyc2lvblxuICAgICAgICAgICAgICAvLyBhdCBhbGwuXG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChleGl0U3RhdHVzID09PSBSb290RmF0YWxFcnJvcmVkKSB7XG4gICAgICAgICAgcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgTm9MYW5lcyk7XG4gICAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQocm9vdCwgbGFuZXMsIE5vTGFuZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gLy8gV2Ugbm93IGhhdmUgYSBjb25zaXN0ZW50IHRyZWUuIFRoZSBuZXh0IHN0ZXAgaXMgZWl0aGVyIHRvIGNvbW1pdCBpdCxcbiAgICAgICAgLy8gb3IsIGlmIHNvbWV0aGluZyBzdXNwZW5kZWQsIHdhaXQgdG8gY29tbWl0IGl0IGFmdGVyIGEgdGltZW91dC5cblxuXG4gICAgICAgIHJvb3QuZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrO1xuICAgICAgICByb290LmZpbmlzaGVkTGFuZXMgPSBsYW5lcztcbiAgICAgICAgZmluaXNoQ29uY3VycmVudFJlbmRlcihyb290LCBleGl0U3RhdHVzLCBmaW5pc2hlZFdvcmssIGxhbmVzKTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG4gICAgfSB3aGlsZSAodHJ1ZSk7XG4gIH1cblxuICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG4gIHJldHVybiBnZXRDb250aW51YXRpb25Gb3JSb290KHJvb3QsIG9yaWdpbmFsQ2FsbGJhY2tOb2RlKTtcbn1cblxuZnVuY3Rpb24gcmVjb3ZlckZyb21Db25jdXJyZW50RXJyb3Iocm9vdCwgb3JpZ2luYWxseUF0dGVtcHRlZExhbmVzLCBlcnJvclJldHJ5TGFuZXMpIHtcbiAgLy8gSWYgYW4gZXJyb3Igb2NjdXJyZWQgZHVyaW5nIGh5ZHJhdGlvbiwgZGlzY2FyZCBzZXJ2ZXIgcmVzcG9uc2UgYW5kIGZhbGxcbiAgLy8gYmFjayB0byBjbGllbnQgc2lkZSByZW5kZXIuXG4gIC8vIEJlZm9yZSByZW5kZXJpbmcgYWdhaW4sIHNhdmUgdGhlIGVycm9ycyBmcm9tIHRoZSBwcmV2aW91cyBhdHRlbXB0LlxuICB2YXIgZXJyb3JzRnJvbUZpcnN0QXR0ZW1wdCA9IHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnM7XG4gIHZhciB3YXNSb290RGVoeWRyYXRlZCA9IHN1cHBvcnRzSHlkcmF0aW9uICYmIGlzUm9vdERlaHlkcmF0ZWQocm9vdCk7XG5cbiAgaWYgKHdhc1Jvb3REZWh5ZHJhdGVkKSB7XG4gICAgLy8gVGhlIHNoZWxsIGZhaWxlZCB0byBoeWRyYXRlLiBTZXQgYSBmbGFnIHRvIGZvcmNlIGEgY2xpZW50IHJlbmRlcmluZ1xuICAgIC8vIGR1cmluZyB0aGUgbmV4dCBhdHRlbXB0LiBUbyBkbyB0aGlzLCB3ZSBjYWxsIHByZXBhcmVGcmVzaFN0YWNrIG5vd1xuICAgIC8vIHRvIGNyZWF0ZSB0aGUgcm9vdCB3b3JrLWluLXByb2dyZXNzIGZpYmVyLiBUaGlzIGlzIGEgYml0IHdlaXJkIGluIHRlcm1zXG4gICAgLy8gb2YgZmFjdG9yaW5nLCBiZWNhdXNlIGl0IHJlbGllcyBvbiByZW5kZXJSb290U3luYyBub3QgY2FsbGluZ1xuICAgIC8vIHByZXBhcmVGcmVzaFN0YWNrIGFnYWluIGluIHRoZSBjYWxsIGJlbG93LCB3aGljaCBoYXBwZW5zIGJlY2F1c2UgdGhlXG4gICAgLy8gcm9vdCBhbmQgbGFuZXMgaGF2ZW4ndCBjaGFuZ2VkLlxuICAgIC8vXG4gICAgLy8gVE9ETzogSSB0aGluayB3aGF0IHdlIHNob3VsZCBkbyBpcyBzZXQgRm9yY2VDbGllbnRSZW5kZXIgaW5zaWRlXG4gICAgLy8gdGhyb3dFeGNlcHRpb24sIGxpa2Ugd2UgZG8gZm9yIG5lc3RlZCBTdXNwZW5zZSBib3VuZGFyaWVzLiBUaGUgcmVhc29uXG4gICAgLy8gaXQncyBoZXJlIGluc3RlYWQgaXMgc28gd2UgY2FuIHN3aXRjaCB0byB0aGUgc3luY2hyb25vdXMgd29yayBsb29wLCB0b28uXG4gICAgLy8gU29tZXRoaW5nIHRvIGNvbnNpZGVyIGZvciBhIGZ1dHVyZSByZWZhY3Rvci5cbiAgICB2YXIgcm9vdFdvcmtJblByb2dyZXNzID0gcHJlcGFyZUZyZXNoU3RhY2socm9vdCwgZXJyb3JSZXRyeUxhbmVzKTtcbiAgICByb290V29ya0luUHJvZ3Jlc3MuZmxhZ3MgfD0gRm9yY2VDbGllbnRSZW5kZXI7XG4gIH1cblxuICB2YXIgZXhpdFN0YXR1cyA9IHJlbmRlclJvb3RTeW5jKHJvb3QsIGVycm9yUmV0cnlMYW5lcyk7XG5cbiAgaWYgKGV4aXRTdGF0dXMgIT09IFJvb3RFcnJvcmVkKSB7XG4gICAgLy8gU3VjY2Vzc2Z1bGx5IGZpbmlzaGVkIHJlbmRlcmluZyBvbiByZXRyeVxuICAgIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3REaWRBdHRhY2hQaW5nTGlzdGVuZXIgJiYgIXdhc1Jvb3REZWh5ZHJhdGVkKSB7XG4gICAgICAvLyBEdXJpbmcgdGhlIHN5bmNocm9ub3VzIHJlbmRlciwgd2UgYXR0YWNoZWQgYWRkaXRpb25hbCBwaW5nIGxpc3RlbmVycy5cbiAgICAgIC8vIFRoaXMgaXMgaGlnaGx5IHN1Z2dlc3RpdmUgb2YgYW4gdW5jYWNoZWQgcHJvbWlzZSAodGhvdWdoIGl0J3Mgbm90IHRoZVxuICAgICAgLy8gb25seSByZWFzb24gdGhpcyB3b3VsZCBoYXBwZW4pLiBJZiBpdCB3YXMgYW4gdW5jYWNoZWQgcHJvbWlzZSwgdGhlblxuICAgICAgLy8gaXQgbWF5IGhhdmUgbWFza2VkIGEgZG93bnN0cmVhbSBlcnJvciBmcm9tIG9jdXJyaW5nIHdpdGhvdXQgYWN0dWFsbHlcbiAgICAgIC8vIGZpeGluZyBpdC4gRXhhbXBsZTpcbiAgICAgIC8vXG4gICAgICAvLyAgICB1c2UoUHJvbWlzZS5yZXNvbHZlKCd1bmNhY2hlZCcpKVxuICAgICAgLy8gICAgdGhyb3cgbmV3IEVycm9yKCdPb3BzIScpXG4gICAgICAvL1xuICAgICAgLy8gV2hlbiB0aGlzIGhhcHBlbnMsIHRoZXJlJ3MgYSBjb25mbGljdCBiZXR3ZWVuIGJsb2NraW5nIHBvdGVudGlhbFxuICAgICAgLy8gY29uY3VycmVudCBkYXRhIHJhY2VzIGFuZCB1bndyYXBwaW5nIHVuY2FjaGVkIHByb21pc2UgdmFsdWVzLiBXZVxuICAgICAgLy8gaGF2ZSB0byBjaG9vc2Ugb25lIG9yIHRoZSBvdGhlci4gQmVjYXVzZSB0aGUgZGF0YSByYWNlIHJlY292ZXJ5IGlzXG4gICAgICAvLyBhIGxhc3QgZGl0Y2ggZWZmb3J0LCB3ZSdsbCBkaXNhYmxlIGl0LlxuICAgICAgcm9vdC5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcyA9IG1lcmdlTGFuZXMocm9vdC5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcywgb3JpZ2luYWxseUF0dGVtcHRlZExhbmVzKTsgLy8gTWFyayB0aGUgY3VycmVudCByZW5kZXIgYXMgc3VzcGVuZGVkIGFuZCBmb3JjZSBpdCB0byByZXN0YXJ0LiBPbmNlXG4gICAgICAvLyB0aGVzZSBsYW5lcyBmaW5pc2ggc3VjY2Vzc2Z1bGx5LCB3ZSdsbCByZS1lbmFibGUgdGhlIGVycm9yIHJlY292ZXJ5XG4gICAgICAvLyBtZWNoYW5pc20gZm9yIHN1YnNlcXVlbnQgdXBkYXRlcy5cblxuICAgICAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgfD0gb3JpZ2luYWxseUF0dGVtcHRlZExhbmVzO1xuICAgICAgcmV0dXJuIFJvb3RTdXNwZW5kZWRXaXRoRGVsYXk7XG4gICAgfSAvLyBUaGUgZXJyb3JzIGZyb20gdGhlIGZhaWxlZCBmaXJzdCBhdHRlbXB0IGhhdmUgYmVlbiByZWNvdmVyZWQuIEFkZFxuICAgIC8vIHRoZW0gdG8gdGhlIGNvbGxlY3Rpb24gb2YgcmVjb3ZlcmFibGUgZXJyb3JzLiBXZSdsbCBsb2cgdGhlbSBpbiB0aGVcbiAgICAvLyBjb21taXQgcGhhc2UuXG5cblxuICAgIHZhciBlcnJvcnNGcm9tU2Vjb25kQXR0ZW1wdCA9IHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzO1xuICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID0gZXJyb3JzRnJvbUZpcnN0QXR0ZW1wdDsgLy8gVGhlIGVycm9ycyBmcm9tIHRoZSBzZWNvbmQgYXR0ZW1wdCBzaG91bGQgYmUgcXVldWVkIGFmdGVyIHRoZSBlcnJvcnNcbiAgICAvLyBmcm9tIHRoZSBmaXJzdCBhdHRlbXB0LCB0byBwcmVzZXJ2ZSB0aGUgY2F1c2FsIHNlcXVlbmNlLlxuXG4gICAgaWYgKGVycm9yc0Zyb21TZWNvbmRBdHRlbXB0ICE9PSBudWxsKSB7XG4gICAgICBxdWV1ZVJlY292ZXJhYmxlRXJyb3JzKGVycm9yc0Zyb21TZWNvbmRBdHRlbXB0KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXhpdFN0YXR1cztcbn1cblxuZnVuY3Rpb24gcXVldWVSZWNvdmVyYWJsZUVycm9ycyhlcnJvcnMpIHtcbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID09PSBudWxsKSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBlcnJvcnM7XG4gIH0gZWxzZSB7XG4gICAgLy8gJEZsb3dGaXhNZVttZXRob2QtdW5iaW5kaW5nXVxuICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLnB1c2guYXBwbHkod29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMsIGVycm9ycyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoQ29uY3VycmVudFJlbmRlcihyb290LCBleGl0U3RhdHVzLCBmaW5pc2hlZFdvcmssIGxhbmVzKSB7XG4gIC8vIFRPRE86IFRoZSBmYWN0IHRoYXQgbW9zdCBvZiB0aGVzZSBicmFuY2hlcyBhcmUgaWRlbnRpY2FsIHN1Z2dlc3RzIHRoYXQgc29tZVxuICAvLyBvZiB0aGUgZXhpdCBzdGF0dXNlcyBhcmUgbm90IGJlc3QgbW9kZWxlZCBhcyBleGl0IHN0YXR1c2VzIGFuZCBzaG91bGQgYmVcbiAgLy8gdHJhY2tlZCBvcnRob2dvbmFsbHkuXG4gIHN3aXRjaCAoZXhpdFN0YXR1cykge1xuICAgIGNhc2UgUm9vdEluUHJvZ3Jlc3M6XG4gICAgY2FzZSBSb290RmF0YWxFcnJvcmVkOlxuICAgICAge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jvb3QgZGlkIG5vdCBjb21wbGV0ZS4gVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgICAgIH1cblxuICAgIGNhc2UgUm9vdFN1c3BlbmRlZFdpdGhEZWxheTpcbiAgICAgIHtcbiAgICAgICAgaWYgKGluY2x1ZGVzT25seVRyYW5zaXRpb25zKGxhbmVzKSkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgYSB0cmFuc2l0aW9uLCBzbyB3ZSBzaG91bGQgZXhpdCB3aXRob3V0IGNvbW1pdHRpbmcgYVxuICAgICAgICAgIC8vIHBsYWNlaG9sZGVyIGFuZCB3aXRob3V0IHNjaGVkdWxpbmcgYSB0aW1lb3V0LiBEZWxheSBpbmRlZmluaXRlbHlcbiAgICAgICAgICAvLyB1bnRpbCB3ZSByZWNlaXZlIG1vcmUgZGF0YS5cbiAgICAgICAgICBtYXJrUm9vdFN1c3BlbmRlZChyb290LCBsYW5lcywgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSAvLyBDb21taXQgdGhlIHBsYWNlaG9sZGVyLlxuXG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFJvb3RFcnJvcmVkOlxuICAgICAge1xuICAgICAgICAvLyBUaGlzIHJlbmRlciBlcnJvcmVkLiBJZ25vcmUgYW55IHJlY292ZXJhYmxlIGVycm9ycyBiZWNhdXNlIHdlIHdlcmVuJ3QgYWN0dWFsbHlcbiAgICAgICAgLy8gYWJsZSB0byByZWNvdmVyLiBJbnN0ZWFkLCB3aGF0ZXZlciB0aGUgZmluYWwgZXJyb3JzIHdlcmUgaXMgdGhlIG9uZXMgd2UgbG9nLlxuICAgICAgICAvLyBUaGlzIGVuc3VyZXMgdGhhdCB3ZSBvbmx5IGxvZyB0aGUgYWN0dWFsIGNsaWVudCBzaWRlIGVycm9yIGlmIGl0J3MganVzdCBhIHBsYWluXG4gICAgICAgIC8vIGVycm9yIHRocm93biBmcm9tIGEgY29tcG9uZW50IG9uIHRoZSBzZXJ2ZXIgYW5kIHRoZSBjbGllbnQuXG4gICAgICAgIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzID0gbnVsbDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFJvb3RTdXNwZW5kZWQ6XG4gICAgY2FzZSBSb290Q29tcGxldGVkOlxuICAgICAge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biByb290IGV4aXQgc3RhdHVzLicpO1xuICAgICAgfVxuICB9XG5cbiAgaWYgKHNob3VsZEZvcmNlRmx1c2hGYWxsYmFja3NJbkRFVigpKSB7XG4gICAgLy8gV2UncmUgaW5zaWRlIGFuIGBhY3RgIHNjb3BlLiBDb21taXQgaW1tZWRpYXRlbHkuXG4gICAgY29tbWl0Um9vdChyb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycywgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucywgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSwgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUpO1xuICB9IGVsc2Uge1xuICAgIGlmIChpbmNsdWRlc09ubHlSZXRyaWVzKGxhbmVzKSAmJiAoYWx3YXlzVGhyb3R0bGVSZXRyaWVzICkpIHtcbiAgICAgIC8vIFRoaXMgcmVuZGVyIG9ubHkgaW5jbHVkZWQgcmV0cmllcywgbm8gdXBkYXRlcy4gVGhyb3R0bGUgY29tbWl0dGluZ1xuICAgICAgLy8gcmV0cmllcyBzbyB0aGF0IHdlIGRvbid0IHNob3cgdG9vIG1hbnkgbG9hZGluZyBzdGF0ZXMgdG9vIHF1aWNrbHkuXG4gICAgICB2YXIgbXNVbnRpbFRpbWVvdXQgPSBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lICsgRkFMTEJBQ0tfVEhST1RUTEVfTVMgLSBub3ckMSgpOyAvLyBEb24ndCBib3RoZXIgd2l0aCBhIHZlcnkgc2hvcnQgc3VzcGVuc2UgdGltZS5cblxuICAgICAgaWYgKG1zVW50aWxUaW1lb3V0ID4gMTApIHtcbiAgICAgICAgbWFya1Jvb3RTdXNwZW5kZWQocm9vdCwgbGFuZXMsIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lKTtcbiAgICAgICAgdmFyIG5leHRMYW5lcyA9IGdldE5leHRMYW5lcyhyb290LCBOb0xhbmVzKTtcblxuICAgICAgICBpZiAobmV4dExhbmVzICE9PSBOb0xhbmVzKSB7XG4gICAgICAgICAgLy8gVGhlcmUncyBhZGRpdGlvbmFsIHdvcmsgd2UgY2FuIGRvIG9uIHRoaXMgcm9vdC4gV2UgbWlnaHQgYXMgd2VsbFxuICAgICAgICAgIC8vIGF0dGVtcHQgdG8gd29yayBvbiB0aGF0IHdoaWxlIHdlJ3JlIHN1c3BlbmRlZC5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gLy8gVGhlIHJlbmRlciBpcyBzdXNwZW5kZWQsIGl0IGhhc24ndCB0aW1lZCBvdXQsIGFuZCB0aGVyZSdzIG5vXG4gICAgICAgIC8vIGxvd2VyIHByaW9yaXR5IHdvcmsgdG8gZG8uIEluc3RlYWQgb2YgY29tbWl0dGluZyB0aGUgZmFsbGJhY2tcbiAgICAgICAgLy8gaW1tZWRpYXRlbHksIHdhaXQgZm9yIG1vcmUgZGF0YSB0byBhcnJpdmUuXG4gICAgICAgIC8vIFRPRE86IENvbWJpbmUgcmV0cnkgdGhyb3R0bGluZyB3aXRoIFN1c3BlbnNleSBjb21taXRzLiBSaWdodCBub3cgdGhleVxuICAgICAgICAvLyBydW4gb25lIGFmdGVyIHRoZSBvdGhlci5cblxuXG4gICAgICAgIHJvb3QudGltZW91dEhhbmRsZSA9IHNjaGVkdWxlVGltZW91dChjb21taXRSb290V2hlblJlYWR5LmJpbmQobnVsbCwgcm9vdCwgZmluaXNoZWRXb3JrLCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycywgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucywgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSwgbGFuZXMsIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lKSwgbXNVbnRpbFRpbWVvdXQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29tbWl0Um9vdFdoZW5SZWFkeShyb290LCBmaW5pc2hlZFdvcmssIHdvcmtJblByb2dyZXNzUm9vdFJlY292ZXJhYmxlRXJyb3JzLCB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zLCB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlLCBsYW5lcywgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNvbW1pdFJvb3RXaGVuUmVhZHkocm9vdCwgZmluaXNoZWRXb3JrLCByZWNvdmVyYWJsZUVycm9ycywgdHJhbnNpdGlvbnMsIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSwgbGFuZXMsIHNwYXduZWRMYW5lKSB7XG4gIC8vIFRPRE86IENvbWJpbmUgcmV0cnkgdGhyb3R0bGluZyB3aXRoIFN1c3BlbnNleSBjb21taXRzLiBSaWdodCBub3cgdGhleSBydW5cbiAgLy8gb25lIGFmdGVyIHRoZSBvdGhlci5cbiAgdmFyIEJvdGhWaXNpYmlsaXR5QW5kTWF5U3VzcGVuZENvbW1pdCA9IFZpc2liaWxpdHkgfCBNYXlTdXNwZW5kQ29tbWl0O1xuICB2YXIgc3VidHJlZUZsYWdzID0gZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncztcblxuICBpZiAoc3VidHJlZUZsYWdzICYgU2hvdWxkU3VzcGVuZENvbW1pdCB8fCAoc3VidHJlZUZsYWdzICYgQm90aFZpc2liaWxpdHlBbmRNYXlTdXNwZW5kQ29tbWl0KSA9PT0gQm90aFZpc2liaWxpdHlBbmRNYXlTdXNwZW5kQ29tbWl0KSB7XG4gICAgLy8gQmVmb3JlIGNvbW1pdHRpbmcsIGFzayB0aGUgcmVuZGVyZXIgd2hldGhlciB0aGUgaG9zdCB0cmVlIGlzIHJlYWR5LlxuICAgIC8vIElmIGl0J3Mgbm90LCB3ZSdsbCB3YWl0IHVudGlsIGl0IG5vdGlmaWVzIHVzLlxuICAgIHN0YXJ0U3VzcGVuZGluZ0NvbW1pdCgpOyAvLyBUaGlzIHdpbGwgd2FsayB0aGUgY29tcGxldGVkIGZpYmVyIHRyZWUgYW5kIGF0dGFjaCBsaXN0ZW5lcnMgdG8gYWxsXG4gICAgLy8gdGhlIHN1c3BlbnNleSByZXNvdXJjZXMuIFRoZSByZW5kZXJlciBpcyByZXNwb25zaWJsZSBmb3IgYWNjdW11bGF0aW5nXG4gICAgLy8gYWxsIHRoZSBsb2FkIGV2ZW50cy4gVGhpcyBhbGwgaGFwcGVucyBpbiBhIHNpbmdsZSBzeW5jaHJvbm91c1xuICAgIC8vIHRyYW5zYWN0aW9uLCBzbyBpdCB0cmFjayBzdGF0ZSBpbiBpdHMgb3duIG1vZHVsZSBzY29wZS5cblxuICAgIGFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQoZmluaXNoZWRXb3JrKTsgLy8gQXQgdGhlIGVuZCwgYXNrIHRoZSByZW5kZXJlciBpZiBpdCdzIHJlYWR5IHRvIGNvbW1pdCwgb3IgaWYgd2Ugc2hvdWxkXG4gICAgLy8gc3VzcGVuZC4gSWYgaXQncyBub3QgcmVhZHksIGl0IHdpbGwgcmV0dXJuIGEgY2FsbGJhY2sgdG8gc3Vic2NyaWJlIHRvXG4gICAgLy8gYSByZWFkeSBldmVudC5cblxuICAgIHZhciBzY2hlZHVsZVBlbmRpbmdDb21taXQgPSB3YWl0Rm9yQ29tbWl0VG9CZVJlYWR5KCk7XG5cbiAgICBpZiAoc2NoZWR1bGVQZW5kaW5nQ29tbWl0ICE9PSBudWxsKSB7XG4gICAgICAvLyBOT1RFOiB3YWl0Rm9yQ29tbWl0VG9CZVJlYWR5IHJldHVybnMgYSBzdWJzY3JpYmUgZnVuY3Rpb24gc28gdGhhdCB3ZVxuICAgICAgLy8gb25seSBhbGxvY2F0ZSBhIGZ1bmN0aW9uIGlmIHRoZSBjb21taXQgaXNuJ3QgcmVhZHkgeWV0LiBUaGUgb3RoZXJcbiAgICAgIC8vIHBhdHRlcm4gd291bGQgYmUgdG8gYWx3YXlzIHBhc3MgYSBjYWxsYmFjayB0byB3YWl0Rm9yQ29tbWl0VG9CZVJlYWR5LlxuICAgICAgLy8gTm90IHlldCByZWFkeSB0byBjb21taXQuIERlbGF5IHRoZSBjb21taXQgdW50aWwgdGhlIHJlbmRlcmVyIG5vdGlmaWVzXG4gICAgICAvLyB1cyB0aGF0IGl0J3MgcmVhZHkuIFRoaXMgd2lsbCBiZSBjYW5jZWxlZCBpZiB3ZSBzdGFydCB3b3JrIG9uIHRoZVxuICAgICAgLy8gcm9vdCBhZ2Fpbi5cbiAgICAgIHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdCA9IHNjaGVkdWxlUGVuZGluZ0NvbW1pdChjb21taXRSb290LmJpbmQobnVsbCwgcm9vdCwgcmVjb3ZlcmFibGVFcnJvcnMsIHRyYW5zaXRpb25zLCBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUpKTtcbiAgICAgIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIGxhbmVzLCBzcGF3bmVkTGFuZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9IC8vIE90aGVyd2lzZSwgY29tbWl0IGltbWVkaWF0ZWx5LlxuXG5cbiAgY29tbWl0Um9vdChyb290LCByZWNvdmVyYWJsZUVycm9ycywgdHJhbnNpdGlvbnMsIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSwgc3Bhd25lZExhbmUpO1xufVxuXG5mdW5jdGlvbiBpc1JlbmRlckNvbnNpc3RlbnRXaXRoRXh0ZXJuYWxTdG9yZXMoZmluaXNoZWRXb3JrKSB7XG4gIC8vIFNlYXJjaCB0aGUgcmVuZGVyZWQgdHJlZSBmb3IgZXh0ZXJuYWwgc3RvcmUgcmVhZHMsIGFuZCBjaGVjayB3aGV0aGVyIHRoZVxuICAvLyBzdG9yZXMgd2VyZSBtdXRhdGVkIGluIGEgY29uY3VycmVudCBldmVudC4gSW50ZW50aW9uYWxseSB1c2luZyBhbiBpdGVyYXRpdmVcbiAgLy8gbG9vcCBpbnN0ZWFkIG9mIHJlY3Vyc2lvbiBzbyB3ZSBjYW4gZXhpdCBlYXJseS5cbiAgdmFyIG5vZGUgPSBmaW5pc2hlZFdvcms7XG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBpZiAobm9kZS5mbGFncyAmIFN0b3JlQ29uc2lzdGVuY3kpIHtcbiAgICAgIHZhciB1cGRhdGVRdWV1ZSA9IG5vZGUudXBkYXRlUXVldWU7XG5cbiAgICAgIGlmICh1cGRhdGVRdWV1ZSAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgY2hlY2tzID0gdXBkYXRlUXVldWUuc3RvcmVzO1xuXG4gICAgICAgIGlmIChjaGVja3MgIT09IG51bGwpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoZWNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGNoZWNrID0gY2hlY2tzW2ldO1xuICAgICAgICAgICAgdmFyIGdldFNuYXBzaG90ID0gY2hlY2suZ2V0U25hcHNob3Q7XG4gICAgICAgICAgICB2YXIgcmVuZGVyZWRWYWx1ZSA9IGNoZWNrLnZhbHVlO1xuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBpZiAoIW9iamVjdElzKGdldFNuYXBzaG90KCksIHJlbmRlcmVkVmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgLy8gRm91bmQgYW4gaW5jb25zaXN0ZW50IHN0b3JlLlxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgLy8gSWYgYGdldFNuYXBzaG90YCB0aHJvd3MsIHJldHVybiBgZmFsc2VgLiBUaGlzIHdpbGwgc2NoZWR1bGVcbiAgICAgICAgICAgICAgLy8gYSByZS1yZW5kZXIsIGFuZCB0aGUgZXJyb3Igd2lsbCBiZSByZXRocm93biBkdXJpbmcgcmVuZGVyLlxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoaWxkID0gbm9kZS5jaGlsZDtcblxuICAgIGlmIChub2RlLnN1YnRyZWVGbGFncyAmIFN0b3JlQ29uc2lzdGVuY3kgJiYgY2hpbGQgIT09IG51bGwpIHtcbiAgICAgIGNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICBub2RlID0gY2hpbGQ7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobm9kZSA9PT0gZmluaXNoZWRXb3JrKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICB3aGlsZSAobm9kZS5zaWJsaW5nID09PSBudWxsKSB7XG4gICAgICBpZiAobm9kZS5yZXR1cm4gPT09IG51bGwgfHwgbm9kZS5yZXR1cm4gPT09IGZpbmlzaGVkV29yaykge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgbm9kZSA9IG5vZGUucmV0dXJuO1xuICAgIH1cblxuICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICBub2RlID0gbm9kZS5zaWJsaW5nO1xuICB9IC8vIEZsb3cgZG9lc24ndCBrbm93IHRoaXMgaXMgdW5yZWFjaGFibGUsIGJ1dCBlc2xpbnQgZG9lc1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5yZWFjaGFibGVcblxuXG4gIHJldHVybiB0cnVlO1xufSAvLyBUaGUgZXh0cmEgaW5kaXJlY3Rpb25zIGFyb3VuZCBtYXJrUm9vdFVwZGF0ZWQgYW5kIG1hcmtSb290U3VzcGVuZGVkIGlzXG4vLyBuZWVkZWQgdG8gYXZvaWQgYSBjaXJjdWxhciBkZXBlbmRlbmN5IGJldHdlZW4gdGhpcyBtb2R1bGUgYW5kXG4vLyBSZWFjdEZpYmVyTGFuZS4gVGhlcmUncyBwcm9iYWJseSBhIGJldHRlciB3YXkgdG8gc3BsaXQgdXAgdGhlc2UgbW9kdWxlcyBhbmRcbi8vIGF2b2lkIHRoaXMgcHJvYmxlbS4gUGVyaGFwcyBhbGwgdGhlIHJvb3QtbWFya2luZyBmdW5jdGlvbnMgc2hvdWxkIG1vdmUgaW50b1xuLy8gdGhlIHdvcmsgbG9vcC5cblxuXG5mdW5jdGlvbiBtYXJrUm9vdFVwZGF0ZWQocm9vdCwgdXBkYXRlZExhbmVzKSB7XG4gIG1hcmtSb290VXBkYXRlZCQxKHJvb3QsIHVwZGF0ZWRMYW5lcyk7XG5cbiAge1xuICAgIC8vIENoZWNrIGZvciByZWN1cnNpdmUgdXBkYXRlc1xuICAgIGlmIChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChleGVjdXRpb25Db250ZXh0ICYgQ29tbWl0Q29udGV4dCkge1xuICAgICAgZGlkSW5jbHVkZUNvbW1pdFBoYXNlVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aHJvd0lmSW5maW5pdGVVcGRhdGVMb29wRGV0ZWN0ZWQoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXJrUm9vdFBpbmdlZChyb290LCBwaW5nZWRMYW5lcykge1xuICBtYXJrUm9vdFBpbmdlZCQxKHJvb3QsIHBpbmdlZExhbmVzKTtcblxuICB7XG4gICAgLy8gQ2hlY2sgZm9yIHJlY3Vyc2l2ZSBwaW5ncy4gUGluZ3MgYXJlIGNvbmNlcHR1YWxseSBkaWZmZXJlbnQgZnJvbSB1cGRhdGVzIGluXG4gICAgLy8gb3RoZXIgY29udGV4dHMgYnV0IHdlIGNhbGwgaXQgYW4gXCJ1cGRhdGVcIiBpbiB0aGlzIGNvbnRleHQgYmVjYXVzZVxuICAgIC8vIHJlcGVhdGVkbHkgcGluZ2luZyBhIHN1c3BlbmRlZCByZW5kZXIgY2FuIGNhdXNlIGEgcmVjdXJzaXZlIHJlbmRlciBsb29wLlxuICAgIC8vIFRoZSByZWxldmFudCBwcm9wZXJ0eSBpcyB0aGF0IGl0IGNhbiByZXN1bHQgaW4gYSBuZXcgcmVuZGVyIGF0dGVtcHRcbiAgICAvLyBiZWluZyBzY2hlZHVsZWQuXG4gICAgaWYgKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0KSB7XG4gICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGV4ZWN1dGlvbkNvbnRleHQgJiBDb21taXRDb250ZXh0KSB7XG4gICAgICBkaWRJbmNsdWRlQ29tbWl0UGhhc2VVcGRhdGUgPSB0cnVlO1xuICAgIH1cblxuICAgIHRocm93SWZJbmZpbml0ZVVwZGF0ZUxvb3BEZXRlY3RlZCgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIHN1c3BlbmRlZExhbmVzLCBzcGF3bmVkTGFuZSkge1xuICAvLyBXaGVuIHN1c3BlbmRpbmcsIHdlIHNob3VsZCBhbHdheXMgZXhjbHVkZSBsYW5lcyB0aGF0IHdlcmUgcGluZ2VkIG9yIChtb3JlXG4gIC8vIHJhcmVseSwgc2luY2Ugd2UgdHJ5IHRvIGF2b2lkIGl0KSB1cGRhdGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLlxuICBzdXNwZW5kZWRMYW5lcyA9IHJlbW92ZUxhbmVzKHN1c3BlbmRlZExhbmVzLCB3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyk7XG4gIHN1c3BlbmRlZExhbmVzID0gcmVtb3ZlTGFuZXMoc3VzcGVuZGVkTGFuZXMsIHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzKTtcblxuICBtYXJrUm9vdFN1c3BlbmRlZCQxKHJvb3QsIHN1c3BlbmRlZExhbmVzLCBzcGF3bmVkTGFuZSk7XG59IC8vIFRoaXMgaXMgdGhlIGVudHJ5IHBvaW50IGZvciBzeW5jaHJvbm91cyB0YXNrcyB0aGF0IGRvbid0IGdvXG4vLyB0aHJvdWdoIFNjaGVkdWxlclxuXG5cbmZ1bmN0aW9uIHBlcmZvcm1TeW5jV29ya09uUm9vdChyb290LCBsYW5lcykge1xuICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy4nKTtcbiAgfVxuXG4gIHZhciBkaWRGbHVzaFBhc3NpdmVFZmZlY3RzID0gZmx1c2hQYXNzaXZlRWZmZWN0cygpO1xuXG4gIGlmIChkaWRGbHVzaFBhc3NpdmVFZmZlY3RzKSB7XG4gICAgLy8gSWYgcGFzc2l2ZSBlZmZlY3RzIHdlcmUgZmx1c2hlZCwgZXhpdCB0byB0aGUgb3V0ZXIgd29yayBsb29wIGluIHRoZSByb290XG4gICAgLy8gc2NoZWR1bGVyLCBzbyB3ZSBjYW4gcmVjb21wdXRlIHRoZSBwcmlvcml0eS5cbiAgICAvLyBUT0RPOiBXZSBkb24ndCBhY3R1YWxseSBuZWVkIHRoaXMgYGVuc3VyZVJvb3RJc1NjaGVkdWxlZGAgY2FsbCBiZWNhdXNlXG4gICAgLy8gdGhpcyBwYXRoIGlzIG9ubHkgcmVhY2hhYmxlIGlmIHRoZSByb290IGlzIGFscmVhZHkgcGFydCBvZiB0aGUgc2NoZWR1bGUuXG4gICAgLy8gSSdtIGluY2x1ZGluZyBpdCBvbmx5IGZvciBjb25zaXN0ZW5jeSB3aXRoIHRoZSBvdGhlciBleGl0IHBvaW50cyBmcm9tXG4gICAgLy8gdGhpcyBmdW5jdGlvbi4gQ2FuIGFkZHJlc3MgaW4gYSBzdWJzZXF1ZW50IHJlZmFjdG9yLlxuICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBzeW5jTmVzdGVkVXBkYXRlRmxhZygpO1xuICB9XG5cbiAgdmFyIGV4aXRTdGF0dXMgPSByZW5kZXJSb290U3luYyhyb290LCBsYW5lcyk7XG5cbiAgaWYgKGV4aXRTdGF0dXMgPT09IFJvb3RFcnJvcmVkKSB7XG4gICAgLy8gSWYgc29tZXRoaW5nIHRocmV3IGFuIGVycm9yLCB0cnkgcmVuZGVyaW5nIG9uZSBtb3JlIHRpbWUuIFdlJ2xsIHJlbmRlclxuICAgIC8vIHN5bmNocm9ub3VzbHkgdG8gYmxvY2sgY29uY3VycmVudCBkYXRhIG11dGF0aW9ucywgYW5kIHdlJ2xsIGluY2x1ZGVzXG4gICAgLy8gYWxsIHBlbmRpbmcgdXBkYXRlcyBhcmUgaW5jbHVkZWQuIElmIGl0IHN0aWxsIGZhaWxzIGFmdGVyIHRoZSBzZWNvbmRcbiAgICAvLyBhdHRlbXB0LCB3ZSdsbCBnaXZlIHVwIGFuZCBjb21taXQgdGhlIHJlc3VsdGluZyB0cmVlLlxuICAgIHZhciBvcmlnaW5hbGx5QXR0ZW1wdGVkTGFuZXMgPSBsYW5lcztcbiAgICB2YXIgZXJyb3JSZXRyeUxhbmVzID0gZ2V0TGFuZXNUb1JldHJ5U3luY2hyb25vdXNseU9uRXJyb3Iocm9vdCwgb3JpZ2luYWxseUF0dGVtcHRlZExhbmVzKTtcblxuICAgIGlmIChlcnJvclJldHJ5TGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICAgIGxhbmVzID0gZXJyb3JSZXRyeUxhbmVzO1xuICAgICAgZXhpdFN0YXR1cyA9IHJlY292ZXJGcm9tQ29uY3VycmVudEVycm9yKHJvb3QsIG9yaWdpbmFsbHlBdHRlbXB0ZWRMYW5lcywgZXJyb3JSZXRyeUxhbmVzKTtcbiAgICB9XG4gIH1cblxuICBpZiAoZXhpdFN0YXR1cyA9PT0gUm9vdEZhdGFsRXJyb3JlZCkge1xuICAgIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIE5vTGFuZXMpO1xuICAgIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIGxhbmVzLCBOb0xhbmUpO1xuICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChleGl0U3RhdHVzID09PSBSb290RGlkTm90Q29tcGxldGUpIHtcbiAgICAvLyBUaGUgcmVuZGVyIHVud291bmQgd2l0aG91dCBjb21wbGV0aW5nIHRoZSB0cmVlLiBUaGlzIGhhcHBlbnMgaW4gc3BlY2lhbFxuICAgIC8vIGNhc2VzIHdoZXJlIG5lZWQgdG8gZXhpdCB0aGUgY3VycmVudCByZW5kZXIgd2l0aG91dCBwcm9kdWNpbmcgYVxuICAgIC8vIGNvbnNpc3RlbnQgdHJlZSBvciBjb21taXR0aW5nLlxuICAgIG1hcmtSb290U3VzcGVuZGVkKHJvb3QsIGxhbmVzLCB3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSk7XG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICAgIHJldHVybiBudWxsO1xuICB9IC8vIFdlIG5vdyBoYXZlIGEgY29uc2lzdGVudCB0cmVlLiBCZWNhdXNlIHRoaXMgaXMgYSBzeW5jIHJlbmRlciwgd2VcbiAgLy8gd2lsbCBjb21taXQgaXQgZXZlbiBpZiBzb21ldGhpbmcgc3VzcGVuZGVkLlxuXG5cbiAgdmFyIGZpbmlzaGVkV29yayA9IHJvb3QuY3VycmVudC5hbHRlcm5hdGU7XG4gIHJvb3QuZmluaXNoZWRXb3JrID0gZmluaXNoZWRXb3JrO1xuICByb290LmZpbmlzaGVkTGFuZXMgPSBsYW5lcztcbiAgY29tbWl0Um9vdChyb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycywgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucywgd29ya0luUHJvZ3Jlc3NSb290RGlkSW5jbHVkZVJlY3Vyc2l2ZVJlbmRlclVwZGF0ZSwgd29ya0luUHJvZ3Jlc3NEZWZlcnJlZExhbmUpOyAvLyBCZWZvcmUgZXhpdGluZywgbWFrZSBzdXJlIHRoZXJlJ3MgYSBjYWxsYmFjayBzY2hlZHVsZWQgZm9yIHRoZSBuZXh0XG4gIC8vIHBlbmRpbmcgbGV2ZWwuXG5cbiAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGZsdXNoUm9vdChyb290LCBsYW5lcykge1xuICBpZiAobGFuZXMgIT09IE5vTGFuZXMpIHtcbiAgICB1cGdyYWRlUGVuZGluZ0xhbmVzVG9TeW5jKHJvb3QsIGxhbmVzKTtcbiAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG5cbiAgICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSA9PT0gTm9Db250ZXh0KSB7XG4gICAgICByZXNldFJlbmRlclRpbWVyKCk7IC8vIFRPRE86IEZvciBoaXN0b3JpY2FsIHJlYXNvbnMgdGhpcyBmbHVzaGVzIGFsbCBzeW5jIHdvcmsgYWNyb3NzIGFsbFxuICAgICAgLy8gcm9vdHMuIEl0IHNob3VsZG4ndCByZWFsbHkgbWF0dGVyIGVpdGhlciB3YXksIGJ1dCB3ZSBjb3VsZCBjaGFuZ2UgdGhpc1xuICAgICAgLy8gdG8gb25seSBmbHVzaCB0aGUgZ2l2ZW4gcm9vdC5cblxuICAgICAgZmx1c2hTeW5jV29ya09uQWxsUm9vdHMoKTtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGdldEV4ZWN1dGlvbkNvbnRleHQoKSB7XG4gIHJldHVybiBleGVjdXRpb25Db250ZXh0O1xufVxuZnVuY3Rpb24gZGVmZXJyZWRVcGRhdGVzKGZuKSB7XG4gIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQ7XG4gIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cbiAgdHJ5IHtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoRGVmYXVsdEV2ZW50UHJpb3JpdHkpO1xuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBudWxsO1xuICAgIHJldHVybiBmbigpO1xuICB9IGZpbmFsbHkge1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KTtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb247XG4gIH1cbn1cbmZ1bmN0aW9uIGJhdGNoZWRVcGRhdGVzKGZuLCBhKSB7XG4gIHtcbiAgICAvLyBiYXRjaGVkVXBkYXRlcyBpcyBhIG5vLW9wIG5vdywgYnV0IHRoZXJlJ3Mgc3RpbGwgc29tZSBpbnRlcm5hbCByZWFjdC1kb21cbiAgICAvLyBjb2RlIGNhbGxpbmcgaXQsIHRoYXQgd2UgY2FuJ3QgcmVtb3ZlIHVudGlsIHdlIHJlbW92ZSBsZWdhY3kgbW9kZS5cbiAgICByZXR1cm4gZm4oYSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGRpc2NyZXRlVXBkYXRlcyhmbiwgYSwgYiwgYywgZCkge1xuICB2YXIgcHJldlRyYW5zaXRpb24gPSBSZWFjdFNoYXJlZEludGVybmFscy5UO1xuICB2YXIgcHJldmlvdXNQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuXG4gIHRyeSB7XG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KERpc2NyZXRlRXZlbnRQcmlvcml0eSk7XG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGw7XG4gICAgcmV0dXJuIGZuKGEsIGIsIGMsIGQpO1xuICB9IGZpbmFsbHkge1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KTtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb247XG5cbiAgICBpZiAoZXhlY3V0aW9uQ29udGV4dCA9PT0gTm9Db250ZXh0KSB7XG4gICAgICByZXNldFJlbmRlclRpbWVyKCk7XG4gICAgfVxuICB9XG59IC8vIE92ZXJsb2FkIHRoZSBkZWZpbml0aW9uIHRvIHRoZSB0d28gdmFsaWQgc2lnbmF0dXJlcy5cbi8vIFdhcm5pbmcsIHRoaXMgb3B0cy1vdXQgb2YgY2hlY2tpbmcgdGhlIGZ1bmN0aW9uIGJvZHkuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gZmx1c2hTeW5jRnJvbVJlY29uY2lsZXIoZm4pIHtcbiAgLy8gSW4gbGVnYWN5IG1vZGUsIHdlIGZsdXNoIHBlbmRpbmcgcGFzc2l2ZSBlZmZlY3RzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlXG4gIC8vIG5leHQgZXZlbnQsIG5vdCBhdCB0aGUgZW5kIG9mIHRoZSBwcmV2aW91cyBvbmUuXG4gIGlmIChyb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyAhPT0gbnVsbCAmJiAhZGlzYWJsZUxlZ2FjeU1vZGUgJiYgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMudGFnID09PSBMZWdhY3lSb290ICYmIChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgPT09IE5vQ29udGV4dCkge1xuICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgfVxuXG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gQmF0Y2hlZENvbnRleHQ7XG4gIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQ7XG4gIHZhciBwcmV2aW91c1ByaW9yaXR5ID0gZ2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KCk7XG5cbiAgdHJ5IHtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5KTtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gbnVsbDtcblxuICAgIGlmIChmbikge1xuICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1ByaW9yaXR5KTtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5UID0gcHJldlRyYW5zaXRpb247XG4gICAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0OyAvLyBGbHVzaCB0aGUgaW1tZWRpYXRlIGNhbGxiYWNrcyB0aGF0IHdlcmUgc2NoZWR1bGVkIGR1cmluZyB0aGlzIGJhdGNoLlxuICAgIC8vIE5vdGUgdGhhdCB0aGlzIHdpbGwgaGFwcGVuIGV2ZW4gaWYgYmF0Y2hlZFVwZGF0ZXMgaXMgaGlnaGVyIHVwXG4gICAgLy8gdGhlIHN0YWNrLlxuXG4gICAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgPT09IE5vQ29udGV4dCkge1xuICAgICAgZmx1c2hTeW5jV29ya09uQWxsUm9vdHMoKTtcbiAgICB9XG4gIH1cbn0gLy8gSWYgY2FsbGVkIG91dHNpZGUgb2YgYSByZW5kZXIgb3IgY29tbWl0IHdpbGwgZmx1c2ggYWxsIHN5bmMgd29yayBvbiBhbGwgcm9vdHNcbi8vIFJldHVybnMgd2hldGhlciB0aGUgdGhlIGNhbGwgd2FzIGR1cmluZyBhIHJlbmRlciBvciBub3RcblxuZnVuY3Rpb24gZmx1c2hTeW5jV29yaygpIHtcbiAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgKFJlbmRlckNvbnRleHQgfCBDb21taXRDb250ZXh0KSkgPT09IE5vQ29udGV4dCkge1xuICAgIGZsdXNoU3luY1dvcmtPbkFsbFJvb3RzKCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBpc0FscmVhZHlSZW5kZXJpbmcoKSB7XG4gIC8vIFVzZWQgYnkgdGhlIHJlbmRlcmVyIHRvIHByaW50IGEgd2FybmluZyBpZiBjZXJ0YWluIEFQSXMgYXJlIGNhbGxlZCBmcm9tXG4gIC8vIHRoZSB3cm9uZyBjb250ZXh0LlxuICByZXR1cm4gKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0O1xufVxuLy8gaGlkZGVuIHN1YnRyZWUuIFRoZSBzdGFjayBsb2dpYyBpcyBtYW5hZ2VkIHRoZXJlIGJlY2F1c2UgdGhhdCdzIHRoZSBvbmx5XG4vLyBwbGFjZSB0aGF0IGV2ZXIgbW9kaWZpZXMgaXQuIFdoaWNoIG1vZHVsZSBpdCBsaXZlcyBpbiBkb2Vzbid0IG1hdHRlciBmb3Jcbi8vIHBlcmZvcm1hbmNlIGJlY2F1c2UgdGhpcyBmdW5jdGlvbiB3aWxsIGdldCBpbmxpbmVkIHJlZ2FyZGxlc3NcblxuZnVuY3Rpb24gc2V0RW50YW5nbGVkUmVuZGVyTGFuZXMobmV3RW50YW5nbGVkUmVuZGVyTGFuZXMpIHtcbiAgZW50YW5nbGVkUmVuZGVyTGFuZXMgPSBuZXdFbnRhbmdsZWRSZW5kZXJMYW5lcztcbn1cbmZ1bmN0aW9uIGdldEVudGFuZ2xlZFJlbmRlckxhbmVzKCkge1xuICByZXR1cm4gZW50YW5nbGVkUmVuZGVyTGFuZXM7XG59XG5cbmZ1bmN0aW9uIHJlc2V0V29ya0luUHJvZ3Jlc3NTdGFjaygpIHtcbiAgaWYgKHdvcmtJblByb2dyZXNzID09PSBudWxsKSByZXR1cm47XG4gIHZhciBpbnRlcnJ1cHRlZFdvcms7XG5cbiAgaWYgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID09PSBOb3RTdXNwZW5kZWQpIHtcbiAgICAvLyBOb3JtYWwgY2FzZS4gV29yay1pbi1wcm9ncmVzcyBoYXNuJ3Qgc3RhcnRlZCB5ZXQuIFVud2luZCBhbGxcbiAgICAvLyBpdHMgcGFyZW50cy5cbiAgICBpbnRlcnJ1cHRlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcy5yZXR1cm47XG4gIH0gZWxzZSB7XG4gICAgLy8gV29yay1pbi1wcm9ncmVzcyBpcyBpbiBzdXNwZW5kZWQgc3RhdGUuIFJlc2V0IHRoZSB3b3JrIGxvb3AgYW5kIHVud2luZFxuICAgIC8vIGJvdGggdGhlIHN1c3BlbmRlZCBmaWJlciBhbmQgYWxsIGl0cyBwYXJlbnRzLlxuICAgIHJlc2V0U3VzcGVuZGVkV29ya0xvb3BPblVud2luZCh3b3JrSW5Qcm9ncmVzcyk7XG4gICAgaW50ZXJydXB0ZWRXb3JrID0gd29ya0luUHJvZ3Jlc3M7XG4gIH1cblxuICB3aGlsZSAoaW50ZXJydXB0ZWRXb3JrICE9PSBudWxsKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBpbnRlcnJ1cHRlZFdvcmsuYWx0ZXJuYXRlO1xuICAgIHVud2luZEludGVycnVwdGVkV29yayhjdXJyZW50LCBpbnRlcnJ1cHRlZFdvcmspO1xuICAgIGludGVycnVwdGVkV29yayA9IGludGVycnVwdGVkV29yay5yZXR1cm47XG4gIH1cblxuICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIHByZXBhcmVGcmVzaFN0YWNrKHJvb3QsIGxhbmVzKSB7XG4gIHJvb3QuZmluaXNoZWRXb3JrID0gbnVsbDtcbiAgcm9vdC5maW5pc2hlZExhbmVzID0gTm9MYW5lcztcbiAgdmFyIHRpbWVvdXRIYW5kbGUgPSByb290LnRpbWVvdXRIYW5kbGU7XG5cbiAgaWYgKHRpbWVvdXRIYW5kbGUgIT09IG5vVGltZW91dCkge1xuICAgIC8vIFRoZSByb290IHByZXZpb3VzIHN1c3BlbmRlZCBhbmQgc2NoZWR1bGVkIGEgdGltZW91dCB0byBjb21taXQgYSBmYWxsYmFja1xuICAgIC8vIHN0YXRlLiBOb3cgdGhhdCB3ZSBoYXZlIGFkZGl0aW9uYWwgd29yaywgY2FuY2VsIHRoZSB0aW1lb3V0LlxuICAgIHJvb3QudGltZW91dEhhbmRsZSA9IG5vVGltZW91dDsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF0gQ29tcGxhaW5zIG5vVGltZW91dCBpcyBub3QgYSBUaW1lb3V0SUQsIGRlc3BpdGUgdGhlIGNoZWNrIGFib3ZlXG5cbiAgICBjYW5jZWxUaW1lb3V0KHRpbWVvdXRIYW5kbGUpO1xuICB9XG5cbiAgdmFyIGNhbmNlbFBlbmRpbmdDb21taXQgPSByb290LmNhbmNlbFBlbmRpbmdDb21taXQ7XG5cbiAgaWYgKGNhbmNlbFBlbmRpbmdDb21taXQgIT09IG51bGwpIHtcbiAgICByb290LmNhbmNlbFBlbmRpbmdDb21taXQgPSBudWxsO1xuICAgIGNhbmNlbFBlbmRpbmdDb21taXQoKTtcbiAgfVxuXG4gIHJlc2V0V29ya0luUHJvZ3Jlc3NTdGFjaygpO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSByb290O1xuICB2YXIgcm9vdFdvcmtJblByb2dyZXNzID0gY3JlYXRlV29ya0luUHJvZ3Jlc3Mocm9vdC5jdXJyZW50LCBudWxsKTtcbiAgd29ya0luUHJvZ3Jlc3MgPSByb290V29ya0luUHJvZ3Jlc3M7XG4gIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gbGFuZXM7XG4gIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NSb290RGlkQXR0YWNoUGluZ0xpc3RlbmVyID0gZmFsc2U7XG4gIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290SW5Qcm9ncmVzcztcbiAgd29ya0luUHJvZ3Jlc3NSb290U2tpcHBlZExhbmVzID0gTm9MYW5lcztcbiAgd29ya0luUHJvZ3Jlc3NSb290SW50ZXJsZWF2ZWRVcGRhdGVkTGFuZXMgPSBOb0xhbmVzO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lID0gTm9MYW5lO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RDb25jdXJyZW50RXJyb3JzID0gbnVsbDtcbiAgd29ya0luUHJvZ3Jlc3NSb290UmVjb3ZlcmFibGVFcnJvcnMgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3REaWRJbmNsdWRlUmVjdXJzaXZlUmVuZGVyVXBkYXRlID0gZmFsc2U7IC8vIEdldCB0aGUgbGFuZXMgdGhhdCBhcmUgZW50YW5nbGVkIHdpdGggd2hhdGV2ZXIgd2UncmUgYWJvdXQgdG8gcmVuZGVyLiBXZVxuICAvLyB0cmFjayB0aGVzZSBzZXBhcmF0ZWx5IHNvIHdlIGNhbiBkaXN0aW5ndWlzaCB0aGUgcHJpb3JpdHkgb2YgdGhlIHJlbmRlclxuICAvLyB0YXNrIGZyb20gdGhlIHByaW9yaXR5IG9mIHRoZSBsYW5lcyBpdCBpcyBlbnRhbmdsZWQgd2l0aC4gRm9yIGV4YW1wbGUsIGFcbiAgLy8gdHJhbnNpdGlvbiBtYXkgbm90IGJlIGFsbG93ZWQgdG8gZmluaXNoIHVubGVzcyBpdCBpbmNsdWRlcyB0aGUgU3luYyBsYW5lLFxuICAvLyB3aGljaCBpcyBjdXJyZW50bHkgc3VzcGVuZGVkLiBXZSBzaG91bGQgYmUgYWJsZSB0byByZW5kZXIgdGhlIFRyYW5zaXRpb25cbiAgLy8gYW5kIFN5bmMgbGFuZSBpbiB0aGUgc2FtZSBiYXRjaCwgYnV0IGF0IFRyYW5zaXRpb24gcHJpb3JpdHksIGJlY2F1c2UgdGhlXG4gIC8vIFN5bmMgbGFuZSBhbHJlYWR5IHN1c3BlbmRlZC5cblxuICBlbnRhbmdsZWRSZW5kZXJMYW5lcyA9IGdldEVudGFuZ2xlZExhbmVzKHJvb3QsIGxhbmVzKTtcbiAgZmluaXNoUXVldWVpbmdDb25jdXJyZW50VXBkYXRlcygpO1xuXG4gIHtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5kaXNjYXJkUGVuZGluZ1dhcm5pbmdzKCk7XG4gIH1cblxuICByZXR1cm4gcm9vdFdvcmtJblByb2dyZXNzO1xufVxuXG5mdW5jdGlvbiByZXNldFN1c3BlbmRlZFdvcmtMb29wT25VbndpbmQoZmliZXIpIHtcbiAgLy8gUmVzZXQgbW9kdWxlLWxldmVsIHN0YXRlIHRoYXQgd2FzIHNldCBkdXJpbmcgdGhlIHJlbmRlciBwaGFzZS5cbiAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG4gIHJlc2V0SG9va3NPblVud2luZChmaWJlcik7XG4gIHJlc2V0Q2hpbGRSZWNvbmNpbGVyT25VbndpbmQoKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlVGhyb3cocm9vdCwgdGhyb3duVmFsdWUpIHtcbiAgLy8gQSBjb21wb25lbnQgdGhyZXcgYW4gZXhjZXB0aW9uLiBVc3VhbGx5IHRoaXMgaXMgYmVjYXVzZSBpdCBzdXNwZW5kZWQsIGJ1dFxuICAvLyBpdCBhbHNvIGluY2x1ZGVzIHJlZ3VsYXIgcHJvZ3JhbSBlcnJvcnMuXG4gIC8vXG4gIC8vIFdlJ3JlIGVpdGhlciBnb2luZyB0byB1bndpbmQgdGhlIHN0YWNrIHRvIHNob3cgYSBTdXNwZW5zZSBvciBlcnJvclxuICAvLyBib3VuZGFyeSwgb3Igd2UncmUgZ29pbmcgdG8gcmVwbGF5IHRoZSBjb21wb25lbnQgYWdhaW4uIExpa2UgYWZ0ZXIgYVxuICAvLyBwcm9taXNlIHJlc29sdmVzLlxuICAvL1xuICAvLyBVbnRpbCB3ZSBkZWNpZGUgd2hldGhlciB3ZSdyZSBnb2luZyB0byB1bndpbmQgb3IgcmVwbGF5LCB3ZSBzaG91bGQgcHJlc2VydmVcbiAgLy8gdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIHdvcmsgbG9vcCB3aXRob3V0IHJlc2V0dGluZyBhbnl0aGluZy5cbiAgLy9cbiAgLy8gSWYgd2UgZG8gZGVjaWRlIHRvIHVud2luZCB0aGUgc3RhY2ssIG1vZHVsZS1sZXZlbCB2YXJpYWJsZXMgd2lsbCBiZSByZXNldFxuICAvLyBpbiByZXNldFN1c3BlbmRlZFdvcmtMb29wT25VbndpbmQuXG4gIC8vIFRoZXNlIHNob3VsZCBiZSByZXNldCBpbW1lZGlhdGVseSBiZWNhdXNlIHRoZXkncmUgb25seSBzdXBwb3NlZCB0byBiZSBzZXRcbiAgLy8gd2hlbiBSZWFjdCBpcyBleGVjdXRpbmcgdXNlciBjb2RlLlxuICByZXNldEhvb2tzQWZ0ZXJUaHJvdygpO1xuXG4gIHtcbiAgICByZXNldEN1cnJlbnRGaWJlcigpO1xuICB9XG5cbiAgaWYgKHRocm93blZhbHVlID09PSBTdXNwZW5zZUV4Y2VwdGlvbikge1xuICAgIC8vIFRoaXMgaXMgYSBzcGVjaWFsIHR5cGUgb2YgZXhjZXB0aW9uIHVzZWQgZm9yIFN1c3BlbnNlLiBGb3IgaGlzdG9yaWNhbFxuICAgIC8vIHJlYXNvbnMsIHRoZSByZXN0IG9mIHRoZSBTdXNwZW5zZSBpbXBsZW1lbnRhdGlvbiBleHBlY3RzIHRoZSB0aHJvd24gdmFsdWVcbiAgICAvLyB0byBiZSBhIHRoZW5hYmxlLCBiZWNhdXNlIGJlZm9yZSBgdXNlYCBleGlzdGVkIHRoYXQgd2FzIHRoZSAodW5zdGFibGUpXG4gICAgLy8gQVBJIGZvciBzdXNwZW5kaW5nLiBUaGlzIGltcGxlbWVudGF0aW9uIGRldGFpbCBjYW4gY2hhbmdlIGxhdGVyLCBvbmNlIHdlXG4gICAgLy8gZGVwcmVjYXRlIHRoZSBvbGQgQVBJIGluIGZhdm9yIG9mIGB1c2VgLlxuICAgIHRocm93blZhbHVlID0gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKTtcbiAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IHNob3VsZFJlbWFpbk9uUHJldmlvdXNTY3JlZW4oKSAmJiAvLyBDaGVjayBpZiB0aGVyZSBhcmUgb3RoZXIgcGVuZGluZyB1cGRhdGVzIHRoYXQgbWlnaHQgcG9zc2libHkgdW5ibG9jayB0aGlzXG4gICAgLy8gY29tcG9uZW50IGZyb20gc3VzcGVuZGluZy4gVGhpcyBtaXJyb3JzIHRoZSBjaGVjayBpblxuICAgIC8vIHJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUuIFdlIHNob3VsZCBhdHRlbXB0IHRvIHVuaWZ5IHRoZW0gc29tZWhvdy5cbiAgICAvLyBUT0RPOiBDb25zaWRlciB1bndpbmRpbmcgaW1tZWRpYXRlbHksIHVzaW5nIHRoZVxuICAgIC8vIFN1c3BlbmRlZE9uSHlkcmF0aW9uIG1lY2hhbmlzbS5cbiAgICAhaW5jbHVkZXNOb25JZGxlV29yayh3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMpICYmICFpbmNsdWRlc05vbklkbGVXb3JrKHdvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzKSA/IC8vIFN1c3BlbmQgd29yayBsb29wIHVudGlsIGRhdGEgcmVzb2x2ZXNcbiAgICBTdXNwZW5kZWRPbkRhdGEgOiAvLyBEb24ndCBzdXNwZW5kIHdvcmsgbG9vcCwgZXhjZXB0IHRvIGNoZWNrIGlmIHRoZSBkYXRhIGhhc1xuICAgIC8vIGltbWVkaWF0ZWx5IHJlc29sdmVkIChpLmUuIGluIGEgbWljcm90YXNrKS4gT3RoZXJ3aXNlLCB0cmlnZ2VyIHRoZVxuICAgIC8vIG5lYXJlc3QgU3VzcGVuc2UgZmFsbGJhY2suXG4gICAgU3VzcGVuZGVkT25JbW1lZGlhdGU7XG4gIH0gZWxzZSBpZiAodGhyb3duVmFsdWUgPT09IFN1c3BlbnNleUNvbW1pdEV4Y2VwdGlvbikge1xuICAgIHRocm93blZhbHVlID0gZ2V0U3VzcGVuZGVkVGhlbmFibGUoKTtcbiAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IFN1c3BlbmRlZE9uSW5zdGFuY2U7XG4gIH0gZWxzZSBpZiAodGhyb3duVmFsdWUgPT09IFNlbGVjdGl2ZUh5ZHJhdGlvbkV4Y2VwdGlvbikge1xuICAgIC8vIEFuIHVwZGF0ZSBmbG93ZWQgaW50byBhIGRlaHlkcmF0ZWQgYm91bmRhcnkuIEJlZm9yZSB3ZSBjYW4gYXBwbHkgdGhlXG4gICAgLy8gdXBkYXRlLCB3ZSBuZWVkIHRvIGZpbmlzaCBoeWRyYXRpbmcuIEludGVycnVwdCB0aGUgd29yay1pbi1wcm9ncmVzc1xuICAgIC8vIHJlbmRlciBzbyB3ZSBjYW4gcmVzdGFydCBhdCB0aGUgaHlkcmF0aW9uIGxhbmUuXG4gICAgLy9cbiAgICAvLyBUaGUgaWRlYWwgaW1wbGVtZW50YXRpb24gd291bGQgYmUgYWJsZSB0byBzd2l0Y2ggY29udGV4dHMgd2l0aG91dFxuICAgIC8vIHVud2luZGluZyB0aGUgY3VycmVudCBzdGFjay5cbiAgICAvL1xuICAgIC8vIFdlIGNvdWxkIG5hbWUgdGhpcyBzb21ldGhpbmcgbW9yZSBnZW5lcmFsIGJ1dCBhcyBvZiBub3cgaXQncyB0aGUgb25seVxuICAgIC8vIGNhc2Ugd2hlcmUgd2UgdGhpbmsgdGhpcyBzaG91bGQgaGFwcGVuLlxuICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gU3VzcGVuZGVkT25IeWRyYXRpb247XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhIHJlZ3VsYXIgZXJyb3IuXG4gICAgdmFyIGlzV2FrZWFibGUgPSB0aHJvd25WYWx1ZSAhPT0gbnVsbCAmJiB0eXBlb2YgdGhyb3duVmFsdWUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0aHJvd25WYWx1ZS50aGVuID09PSAnZnVuY3Rpb24nO1xuICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gaXNXYWtlYWJsZSA/IC8vIEEgd2FrZWFibGUgb2JqZWN0IHdhcyB0aHJvd24gYnkgYSBsZWdhY3kgU3VzcGVuc2UgaW1wbGVtZW50YXRpb24uXG4gICAgLy8gVGhpcyBoYXMgc2xpZ2h0bHkgZGlmZmVyZW50IGJlaGF2aW9yIHRoYW4gc3VzcGVuZGluZyB3aXRoIGB1c2VgLlxuICAgIFN1c3BlbmRlZE9uRGVwcmVjYXRlZFRocm93UHJvbWlzZSA6IC8vIFRoaXMgaXMgYSByZWd1bGFyIGVycm9yLiBJZiBzb21ldGhpbmcgZWFybGllciBpbiB0aGUgY29tcG9uZW50IGFscmVhZHlcbiAgICAvLyBzdXNwZW5kZWQsIHdlIG11c3QgY2xlYXIgdGhlIHRoZW5hYmxlIHN0YXRlIHRvIHVuYmxvY2sgdGhlIHdvcmsgbG9vcC5cbiAgICBTdXNwZW5kZWRPbkVycm9yO1xuICB9XG5cbiAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IHRocm93blZhbHVlO1xuICB2YXIgZXJyb3JlZFdvcmsgPSB3b3JrSW5Qcm9ncmVzcztcblxuICBpZiAoZXJyb3JlZFdvcmsgPT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIGEgZmF0YWwgZXJyb3JcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEZhdGFsRXJyb3JlZDtcbiAgICBsb2dVbmNhdWdodEVycm9yKHJvb3QsIGNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyKHRocm93blZhbHVlLCByb290LmN1cnJlbnQpKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZXJyb3JlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSB7XG4gICAgLy8gUmVjb3JkIHRoZSB0aW1lIHNwZW50IHJlbmRlcmluZyBiZWZvcmUgYW4gZXJyb3Igd2FzIHRocm93bi4gVGhpc1xuICAgIC8vIGF2b2lkcyBpbmFjY3VyYXRlIFByb2ZpbGVyIGR1cmF0aW9ucyBpbiB0aGUgY2FzZSBvZiBhXG4gICAgLy8gc3VzcGVuZGVkIHJlbmRlci5cbiAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGVycm9yZWRXb3JrLCB0cnVlKTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCgpO1xuXG4gICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbikge1xuICAgICAgY2FzZSBTdXNwZW5kZWRPbkVycm9yOlxuICAgICAgICB7XG4gICAgICAgICAgbWFya0NvbXBvbmVudEVycm9yZWQoZXJyb3JlZFdvcmssIHRocm93blZhbHVlLCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBTdXNwZW5kZWRPbkRhdGE6XG4gICAgICBjYXNlIFN1c3BlbmRlZE9uSW1tZWRpYXRlOlxuICAgICAgY2FzZSBTdXNwZW5kZWRPbkRlcHJlY2F0ZWRUaHJvd1Byb21pc2U6XG4gICAgICBjYXNlIFN1c3BlbmRlZEFuZFJlYWR5VG9Db250aW51ZTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciB3YWtlYWJsZSA9IHRocm93blZhbHVlO1xuICAgICAgICAgIG1hcmtDb21wb25lbnRTdXNwZW5kZWQoZXJyb3JlZFdvcmssIHdha2VhYmxlLCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2hvdWxkUmVtYWluT25QcmV2aW91c1NjcmVlbigpIHtcbiAgLy8gVGhpcyBpcyBhc2tpbmcgd2hldGhlciBpdCdzIGJldHRlciB0byBzdXNwZW5kIHRoZSB0cmFuc2l0aW9uIGFuZCByZW1haW5cbiAgLy8gb24gdGhlIHByZXZpb3VzIHNjcmVlbiwgdmVyc3VzIHNob3dpbmcgYSBmYWxsYmFjayBhcyBzb29uIGFzIHBvc3NpYmxlLiBJdFxuICAvLyB0YWtlcyBpbnRvIGFjY291bnQgYm90aCB0aGUgcHJpb3JpdHkgb2YgcmVuZGVyIGFuZCBhbHNvIHdoZXRoZXIgc2hvd2luZyBhXG4gIC8vIGZhbGxiYWNrIHdvdWxkIHByb2R1Y2UgYSBkZXNpcmFibGUgdXNlciBleHBlcmllbmNlLlxuICB2YXIgaGFuZGxlciA9IGdldFN1c3BlbnNlSGFuZGxlcigpO1xuXG4gIGlmIChoYW5kbGVyID09PSBudWxsKSB7XG4gICAgLy8gVGhlcmUncyBubyBTdXNwZW5zZSBib3VuZGFyeSB0aGF0IGNhbiBwcm92aWRlIGEgZmFsbGJhY2suIFdlIGhhdmUgbm9cbiAgICAvLyBjaG9pY2UgYnV0IHRvIHJlbWFpbiBvbiB0aGUgcHJldmlvdXMgc2NyZWVuLlxuICAgIC8vIE5PVEU6IFdlIGRvIHRoaXMgZXZlbiBmb3Igc3luYyB1cGRhdGVzLCBmb3IgbGFjayBvZiBhbnkgYmV0dGVyIG9wdGlvbi4gSW5cbiAgICAvLyB0aGUgZnV0dXJlLCB3ZSBtYXkgY2hhbmdlIGhvdyB3ZSBoYW5kbGUgdGhpcywgbGlrZSBieSBwdXR0aW5nIHRoZSB3aG9sZVxuICAgIC8vIHJvb3QgaW50byBhIFwiZGV0YWNoZWRcIiBtb2RlLlxuICAgIHJldHVybiB0cnVlO1xuICB9IC8vIFRPRE86IE9uY2UgYHVzZWAgaGFzIGZ1bGx5IHJlcGxhY2VkIHRoZSBgdGhyb3cgcHJvbWlzZWAgcGF0dGVybiwgd2Ugc2hvdWxkXG4gIC8vIGJlIGFibGUgdG8gcmVtb3ZlIHRoZSBlcXVpdmFsZW50IGNoZWNrIGluIGZpbmlzaENvbmN1cnJlbnRSZW5kZXIsIGFuZCByZWx5XG4gIC8vIGp1c3Qgb24gdGhpcyBvbmUuXG5cblxuICBpZiAoaW5jbHVkZXNPbmx5VHJhbnNpdGlvbnMod29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpKSB7XG4gICAgaWYgKGdldFNoZWxsQm91bmRhcnkoKSA9PT0gbnVsbCkge1xuICAgICAgLy8gV2UncmUgcmVuZGVyaW5nIGluc2lkZSB0aGUgXCJzaGVsbFwiIG9mIHRoZSBhcHAuIEFjdGl2YXRpbmcgdGhlIG5lYXJlc3RcbiAgICAgIC8vIGZhbGxiYWNrIHdvdWxkIGNhdXNlIHZpc2libGUgY29udGVudCB0byBkaXNhcHBlYXIuIEl0J3MgYmV0dGVyIHRvXG4gICAgICAvLyBzdXNwZW5kIHRoZSB0cmFuc2l0aW9uIGFuZCByZW1haW4gb24gdGhlIHByZXZpb3VzIHNjcmVlbi5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBXZSdyZSByZW5kZXJpbmcgY29udGVudCB0aGF0IHdhc24ndCBwYXJ0IG9mIHRoZSBwcmV2aW91cyBzY3JlZW4uXG4gICAgICAvLyBSYXRoZXIgdGhhbiBibG9jayB0aGUgdHJhbnNpdGlvbiwgaXQncyBiZXR0ZXIgdG8gc2hvdyBhIGZhbGxiYWNrIGFzXG4gICAgICAvLyBzb29uIGFzIHBvc3NpYmxlLiBUaGUgYXBwZWFyYW5jZSBvZiBhbnkgbmVzdGVkIGZhbGxiYWNrcyB3aWxsIGJlXG4gICAgICAvLyB0aHJvdHRsZWQgdG8gYXZvaWQgamFuay5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBpZiAoaW5jbHVkZXNPbmx5UmV0cmllcyh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcykgfHwgLy8gSW4gdGhpcyBjb250ZXh0LCBhbiBPZmZzY3JlZW5MYW5lIGNvdW50cyBhcyBhIFJldHJ5XG4gIC8vIFRPRE86IEl0J3MgYmVjb21lIGluY3JlYXNpbmdseSBjbGVhciB0aGF0IFJldHJpZXMgYW5kIE9mZnNjcmVlbiBhcmVcbiAgLy8gZGVlcGx5IGNvbm5lY3RlZC4gVGhleSBwcm9iYWJseSBjYW4gYmUgdW5pZmllZCBmdXJ0aGVyLlxuICBpbmNsdWRlc1NvbWVMYW5lKHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzLCBPZmZzY3JlZW5MYW5lKSkge1xuICAgIC8vIER1cmluZyBhIHJldHJ5LCB3ZSBjYW4gc3VzcGVuZCByZW5kZXJpbmcgaWYgdGhlIG5lYXJlc3QgU3VzcGVuc2UgYm91bmRhcnlcbiAgICAvLyBpcyB0aGUgYm91bmRhcnkgb2YgdGhlIFwic2hlbGxcIiwgYmVjYXVzZSB3ZSdyZSBndWFyYW50ZWVkIG5vdCB0byBibG9ja1xuICAgIC8vIGFueSBuZXcgY29udGVudCBmcm9tIGFwcGVhcmluZy5cbiAgICAvL1xuICAgIC8vIFRoZSByZWFzb24gd2UgbXVzdCBjaGVjayBpZiB0aGlzIGlzIGEgcmV0cnkgaXMgYmVjYXVzZSBpdCBndWFyYW50ZWVzXG4gICAgLy8gdGhhdCBzdXNwZW5kaW5nIHRoZSB3b3JrIGxvb3Agd29uJ3QgYmxvY2sgYW4gYWN0dWFsIHVwZGF0ZSwgYmVjYXVzZVxuICAgIC8vIHJldHJpZXMgZG9uJ3QgXCJ1cGRhdGVcIiBhbnl0aGluZzsgdGhleSBmaWxsIGluIGZhbGxiYWNrcyB0aGF0IHdlcmUgbGVmdFxuICAgIC8vIGJlaGluZCBieSBhIHByZXZpb3VzIHRyYW5zaXRpb24uXG4gICAgcmV0dXJuIGhhbmRsZXIgPT09IGdldFNoZWxsQm91bmRhcnkoKTtcbiAgfSAvLyBGb3IgYWxsIG90aGVyIExhbmVzIGJlc2lkZXMgVHJhbnNpdGlvbnMgYW5kIFJldHJpZXMsIHdlIHNob3VsZCBub3Qgd2FpdFxuICAvLyBmb3IgdGhlIGRhdGEgdG8gbG9hZC5cblxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gcHVzaERpc3BhdGNoZXIoY29udGFpbmVyKSB7XG4gIHZhciBwcmV2RGlzcGF0Y2hlciA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLkg7XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBDb250ZXh0T25seURpc3BhdGNoZXI7XG5cbiAgaWYgKHByZXZEaXNwYXRjaGVyID09PSBudWxsKSB7XG4gICAgLy8gVGhlIFJlYWN0IGlzb21vcnBoaWMgcGFja2FnZSBkb2VzIG5vdCBpbmNsdWRlIGEgZGVmYXVsdCBkaXNwYXRjaGVyLlxuICAgIC8vIEluc3RlYWQgdGhlIGZpcnN0IHJlbmRlcmVyIHdpbGwgbGF6aWx5IGF0dGFjaCBvbmUsIGluIG9yZGVyIHRvIGdpdmVcbiAgICAvLyBuaWNlciBlcnJvciBtZXNzYWdlcy5cbiAgICByZXR1cm4gQ29udGV4dE9ubHlEaXNwYXRjaGVyO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBwcmV2RGlzcGF0Y2hlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BEaXNwYXRjaGVyKHByZXZEaXNwYXRjaGVyKSB7XG4gIFJlYWN0U2hhcmVkSW50ZXJuYWxzLkggPSBwcmV2RGlzcGF0Y2hlcjtcbn1cblxuZnVuY3Rpb24gcHVzaEFzeW5jRGlzcGF0Y2hlcigpIHtcbiAge1xuICAgIHZhciBwcmV2QXN5bmNEaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuQTtcbiAgICBSZWFjdFNoYXJlZEludGVybmFscy5BID0gRGVmYXVsdEFzeW5jRGlzcGF0Y2hlcjtcbiAgICByZXR1cm4gcHJldkFzeW5jRGlzcGF0Y2hlcjtcbiAgfVxufVxuXG5mdW5jdGlvbiBwb3BBc3luY0Rpc3BhdGNoZXIocHJldkFzeW5jRGlzcGF0Y2hlcikge1xuICB7XG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuQSA9IHByZXZBc3luY0Rpc3BhdGNoZXI7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya0NvbW1pdFRpbWVPZkZhbGxiYWNrKCkge1xuICBnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lID0gbm93JDEoKTtcbn1cbmZ1bmN0aW9uIG1hcmtTa2lwcGVkVXBkYXRlTGFuZXMobGFuZSkge1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RTa2lwcGVkTGFuZXMgPSBtZXJnZUxhbmVzKGxhbmUsIHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyk7XG59XG5mdW5jdGlvbiByZW5kZXJEaWRTdXNwZW5kKCkge1xuICBpZiAod29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9PT0gUm9vdEluUHJvZ3Jlc3MpIHtcbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdFN1c3BlbmRlZDtcbiAgfVxufVxuZnVuY3Rpb24gcmVuZGVyRGlkU3VzcGVuZERlbGF5SWZQb3NzaWJsZSgpIHtcbiAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RTdXNwZW5kZWRXaXRoRGVsYXk7IC8vIENoZWNrIGlmIHRoZXJlIGFyZSB1cGRhdGVzIHRoYXQgd2Ugc2tpcHBlZCB0cmVlIHRoYXQgbWlnaHQgaGF2ZSB1bmJsb2NrZWRcbiAgLy8gdGhpcyByZW5kZXIuXG5cbiAgaWYgKChpbmNsdWRlc05vbklkbGVXb3JrKHdvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcykgfHwgaW5jbHVkZXNOb25JZGxlV29yayh3b3JrSW5Qcm9ncmVzc1Jvb3RJbnRlcmxlYXZlZFVwZGF0ZWRMYW5lcykpICYmIHdvcmtJblByb2dyZXNzUm9vdCAhPT0gbnVsbCkge1xuICAgIC8vIE1hcmsgdGhlIGN1cnJlbnQgcmVuZGVyIGFzIHN1c3BlbmRlZCBzbyB0aGF0IHdlIHN3aXRjaCB0byB3b3JraW5nIG9uXG4gICAgLy8gdGhlIHVwZGF0ZXMgdGhhdCB3ZXJlIHNraXBwZWQuIFVzdWFsbHkgd2Ugb25seSBzdXNwZW5kIGF0IHRoZSBlbmQgb2ZcbiAgICAvLyB0aGUgcmVuZGVyIHBoYXNlLlxuICAgIC8vIFRPRE86IFdlIHNob3VsZCBwcm9iYWJseSBhbHdheXMgbWFyayB0aGUgcm9vdCBhcyBzdXNwZW5kZWQgaW1tZWRpYXRlbHlcbiAgICAvLyAoaW5zaWRlIHRoaXMgZnVuY3Rpb24pLCBzaW5jZSBieSBzdXNwZW5kaW5nIGF0IHRoZSBlbmQgb2YgdGhlIHJlbmRlclxuICAgIC8vIHBoYXNlIGludHJvZHVjZXMgYSBwb3RlbnRpYWwgbWlzdGFrZSB3aGVyZSB3ZSBzdXNwZW5kIGxhbmVzIHRoYXQgd2VyZVxuICAgIC8vIHBpbmdlZCBvciB1cGRhdGVkIHdoaWxlIHdlIHdlcmUgcmVuZGVyaW5nLlxuICAgIC8vIFRPRE86IENvbnNpZGVyIHVud2luZGluZyBpbW1lZGlhdGVseSwgdXNpbmcgdGhlXG4gICAgLy8gU3VzcGVuZGVkT25IeWRyYXRpb24gbWVjaGFuaXNtLlxuICAgIG1hcmtSb290U3VzcGVuZGVkKHdvcmtJblByb2dyZXNzUm9vdCwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMsIHdvcmtJblByb2dyZXNzRGVmZXJyZWRMYW5lKTtcbiAgfVxufVxuZnVuY3Rpb24gcmVuZGVyRGlkRXJyb3IoKSB7XG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzICE9PSBSb290U3VzcGVuZGVkV2l0aERlbGF5KSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RFcnJvcmVkO1xuICB9XG59XG5mdW5jdGlvbiBxdWV1ZUNvbmN1cnJlbnRFcnJvcihlcnJvcikge1xuICBpZiAod29ya0luUHJvZ3Jlc3NSb290Q29uY3VycmVudEVycm9ycyA9PT0gbnVsbCkge1xuICAgIHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMgPSBbZXJyb3JdO1xuICB9IGVsc2Uge1xuICAgIHdvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMucHVzaChlcnJvcik7XG4gIH1cbn0gLy8gQ2FsbGVkIGR1cmluZyByZW5kZXIgdG8gZGV0ZXJtaW5lIGlmIGFueXRoaW5nIGhhcyBzdXNwZW5kZWQuXG4vLyBSZXR1cm5zIGZhbHNlIGlmIHdlJ3JlIG5vdCBzdXJlLlxuXG5mdW5jdGlvbiByZW5kZXJIYXNOb3RTdXNwZW5kZWRZZXQoKSB7XG4gIC8vIElmIHNvbWV0aGluZyBlcnJvcmVkIG9yIGNvbXBsZXRlZCwgd2UgY2FuJ3QgcmVhbGx5IGJlIHN1cmUsXG4gIC8vIHNvIHRob3NlIGFyZSBmYWxzZS5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RJblByb2dyZXNzO1xufSAvLyBUT0RPOiBPdmVyIHRpbWUsIHRoaXMgZnVuY3Rpb24gYW5kIHJlbmRlclJvb3RDb25jdXJyZW50IGhhdmUgYmVjb21lIG1vcmVcbi8vIGFuZCBtb3JlIHNpbWlsYXIuIE5vdCBzdXJlIGl0IG1ha2VzIHNlbnNlIHRvIG1haW50YWluIGZvcmtlZCBwYXRocy4gQ29uc2lkZXJcbi8vIHVuaWZ5aW5nIHRoZW0gYWdhaW4uXG5cbmZ1bmN0aW9uIHJlbmRlclJvb3RTeW5jKHJvb3QsIGxhbmVzKSB7XG4gIHZhciBwcmV2RXhlY3V0aW9uQ29udGV4dCA9IGV4ZWN1dGlvbkNvbnRleHQ7XG4gIGV4ZWN1dGlvbkNvbnRleHQgfD0gUmVuZGVyQ29udGV4dDtcbiAgdmFyIHByZXZEaXNwYXRjaGVyID0gcHVzaERpc3BhdGNoZXIoKTtcbiAgdmFyIHByZXZBc3luY0Rpc3BhdGNoZXIgPSBwdXNoQXN5bmNEaXNwYXRjaGVyKCk7IC8vIElmIHRoZSByb290IG9yIGxhbmVzIGhhdmUgY2hhbmdlZCwgdGhyb3cgb3V0IHRoZSBleGlzdGluZyBzdGFja1xuICAvLyBhbmQgcHJlcGFyZSBhIGZyZXNoIG9uZS4gT3RoZXJ3aXNlIHdlJ2xsIGNvbnRpbnVlIHdoZXJlIHdlIGxlZnQgb2ZmLlxuXG4gIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3QgIT09IHJvb3QgfHwgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgIT09IGxhbmVzKSB7XG4gICAge1xuICAgICAgaWYgKGlzRGV2VG9vbHNQcmVzZW50KSB7XG4gICAgICAgIHZhciBtZW1vaXplZFVwZGF0ZXJzID0gcm9vdC5tZW1vaXplZFVwZGF0ZXJzO1xuXG4gICAgICAgIGlmIChtZW1vaXplZFVwZGF0ZXJzLnNpemUgPiAwKSB7XG4gICAgICAgICAgcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gICAgICAgICAgbWVtb2l6ZWRVcGRhdGVycy5jbGVhcigpO1xuICAgICAgICB9IC8vIEF0IHRoaXMgcG9pbnQsIG1vdmUgRmliZXJzIHRoYXQgc2NoZWR1bGVkIHRoZSB1cGNvbWluZyB3b3JrIGZyb20gdGhlIE1hcCB0byB0aGUgU2V0LlxuICAgICAgICAvLyBJZiB3ZSBiYWlsb3V0IG9uIHRoaXMgd29yaywgd2UnbGwgbW92ZSB0aGVtIGJhY2sgKGxpa2UgYWJvdmUpLlxuICAgICAgICAvLyBJdCdzIGltcG9ydGFudCB0byBtb3ZlIHRoZW0gbm93IGluIGNhc2UgdGhlIHdvcmsgc3Bhd25zIG1vcmUgd29yayBhdCB0aGUgc2FtZSBwcmlvcml0eSB3aXRoIGRpZmZlcmVudCB1cGRhdGVycy5cbiAgICAgICAgLy8gVGhhdCB3YXkgd2UgY2FuIGtlZXAgdGhlIGN1cnJlbnQgdXBkYXRlIGFuZCBmdXR1cmUgdXBkYXRlcyBzZXBhcmF0ZS5cblxuXG4gICAgICAgIG1vdmVQZW5kaW5nRmliZXJzVG9NZW1vaXplZChyb290LCBsYW5lcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyA9IGdldFRyYW5zaXRpb25zRm9yTGFuZXMoKTtcbiAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcyk7XG4gIH1cblxuICB7XG4gICAgbWFya1JlbmRlclN0YXJ0ZWQobGFuZXMpO1xuICB9XG5cbiAgdmFyIGRpZFN1c3BlbmRJblNoZWxsID0gZmFsc2U7XG5cbiAgb3V0ZXI6IGRvIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uICE9PSBOb3RTdXNwZW5kZWQgJiYgd29ya0luUHJvZ3Jlc3MgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhlIHdvcmsgbG9vcCBpcyBzdXNwZW5kZWQuIER1cmluZyBhIHN5bmNocm9ub3VzIHJlbmRlciwgd2UgZG9uJ3RcbiAgICAgICAgLy8geWllbGQgdG8gdGhlIG1haW4gdGhyZWFkLiBJbW1lZGlhdGVseSB1bndpbmQgdGhlIHN0YWNrLiBUaGlzIHdpbGxcbiAgICAgICAgLy8gdHJpZ2dlciBlaXRoZXIgYSBmYWxsYmFjayBvciBhbiBlcnJvciBib3VuZGFyeS5cbiAgICAgICAgLy8gVE9ETzogRm9yIGRpc2NyZXRlIGFuZCBcImRlZmF1bHRcIiB1cGRhdGVzIChhbnl0aGluZyB0aGF0J3Mgbm90XG4gICAgICAgIC8vIGZsdXNoU3luYyksIHdlIHdhbnQgdG8gd2FpdCBmb3IgdGhlIG1pY3JvdGFza3MgdGhlIGZsdXNoIGJlZm9yZVxuICAgICAgICAvLyB1bndpbmRpbmcuIFdpbGwgcHJvYmFibHkgaW1wbGVtZW50IHRoaXMgdXNpbmcgcmVuZGVyUm9vdENvbmN1cnJlbnQsXG4gICAgICAgIC8vIG9yIG1lcmdlIHJlbmRlclJvb3RTeW5jIGFuZCByZW5kZXJSb290Q29uY3VycmVudCBpbnRvIHRoZSBzYW1lXG4gICAgICAgIC8vIGZ1bmN0aW9uIGFuZCBmb3JrIHRoZSBiZWhhdmlvciBzb21lIG90aGVyIHdheS5cbiAgICAgICAgdmFyIHVuaXRPZldvcmsgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgdmFyIHRocm93blZhbHVlID0gd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZTtcblxuICAgICAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uKSB7XG4gICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkh5ZHJhdGlvbjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gU2VsZWN0aXZlIGh5ZHJhdGlvbi4gQW4gdXBkYXRlIGZsb3dlZCBpbnRvIGEgZGVoeWRyYXRlZCB0cmVlLlxuICAgICAgICAgICAgICAvLyBJbnRlcnJ1cHQgdGhlIGN1cnJlbnQgcmVuZGVyIHNvIHRoZSB3b3JrIGxvb3AgY2FuIHN3aXRjaCB0byB0aGVcbiAgICAgICAgICAgICAgLy8gaHlkcmF0aW9uIGxhbmUuXG4gICAgICAgICAgICAgIHJlc2V0V29ya0luUHJvZ3Jlc3NTdGFjaygpO1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdERpZE5vdENvbXBsZXRlO1xuICAgICAgICAgICAgICBicmVhayBvdXRlcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25JbW1lZGlhdGU6XG4gICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkRhdGE6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGlmICghZGlkU3VzcGVuZEluU2hlbGwgJiYgZ2V0U3VzcGVuc2VIYW5kbGVyKCkgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkaWRTdXNwZW5kSW5TaGVsbCA9IHRydWU7XG4gICAgICAgICAgICAgIH0gLy8gSW50ZW50aW9uYWwgZmFsbHRocm91Z2hcblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gVW53aW5kIHRoZW4gY29udGludWUgd2l0aCB0aGUgbm9ybWFsIHdvcmsgbG9vcC5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICB0aHJvd0FuZFVud2luZFdvcmtMb29wKHJvb3QsIHVuaXRPZldvcmssIHRocm93blZhbHVlKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgd29ya0xvb3BTeW5jKCk7XG4gICAgICBicmVhaztcbiAgICB9IGNhdGNoICh0aHJvd25WYWx1ZSkge1xuICAgICAgaGFuZGxlVGhyb3cocm9vdCwgdGhyb3duVmFsdWUpO1xuICAgIH1cbiAgfSB3aGlsZSAodHJ1ZSk7IC8vIENoZWNrIGlmIHNvbWV0aGluZyBzdXNwZW5kZWQgaW4gdGhlIHNoZWxsLiBXZSB1c2UgdGhpcyB0byBkZXRlY3QgYW5cbiAgLy8gaW5maW5pdGUgcGluZyBsb29wIGNhdXNlZCBieSBhbiB1bmNhY2hlZCBwcm9taXNlLlxuICAvL1xuICAvLyBPbmx5IGluY3JlbWVudCB0aGlzIGNvdW50ZXIgb25jZSBwZXIgc3luY2hyb25vdXMgcmVuZGVyIGF0dGVtcHQgYWNyb3NzIHRoZVxuICAvLyB3aG9sZSB0cmVlLiBFdmVuIGlmIHRoZXJlIGFyZSBtYW55IHNpYmxpbmcgY29tcG9uZW50cyB0aGF0IHN1c3BlbmQsIHRoaXNcbiAgLy8gY291bnRlciBvbmx5IGdldHMgaW5jcmVtZW50ZWQgb25jZS5cblxuXG4gIGlmIChkaWRTdXNwZW5kSW5TaGVsbCkge1xuICAgIHJvb3Quc2hlbGxTdXNwZW5kQ291bnRlcisrO1xuICB9XG5cbiAgcmVzZXRDb250ZXh0RGVwZW5kZW5jaWVzKCk7XG4gIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcbiAgcG9wRGlzcGF0Y2hlcihwcmV2RGlzcGF0Y2hlcik7XG4gIHBvcEFzeW5jRGlzcGF0Y2hlcihwcmV2QXN5bmNEaXNwYXRjaGVyKTtcblxuICBpZiAod29ya0luUHJvZ3Jlc3MgIT09IG51bGwpIHtcbiAgICAvLyBUaGlzIGlzIGEgc3luYyByZW5kZXIsIHNvIHdlIHNob3VsZCBoYXZlIGZpbmlzaGVkIHRoZSB3aG9sZSB0cmVlLlxuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbW1pdCBhbiBpbmNvbXBsZXRlIHJvb3QuIFRoaXMgZXJyb3IgaXMgbGlrZWx5IGNhdXNlZCBieSBhICcgKyAnYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgfVxuXG4gIHtcbiAgICBtYXJrUmVuZGVyU3RvcHBlZCgpO1xuICB9IC8vIFNldCB0aGlzIHRvIG51bGwgdG8gaW5kaWNhdGUgdGhlcmUncyBubyBpbi1wcm9ncmVzcyByZW5kZXIuXG5cblxuICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xuICB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyA9IE5vTGFuZXM7IC8vIEl0J3Mgc2FmZSB0byBwcm9jZXNzIHRoZSBxdWV1ZSBub3cgdGhhdCB0aGUgcmVuZGVyIHBoYXNlIGlzIGNvbXBsZXRlLlxuXG4gIGZpbmlzaFF1ZXVlaW5nQ29uY3VycmVudFVwZGF0ZXMoKTtcbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXM7XG59IC8vIFRoZSB3b3JrIGxvb3AgaXMgYW4gZXh0cmVtZWx5IGhvdCBwYXRoLiBUZWxsIENsb3N1cmUgbm90IHRvIGlubGluZSBpdC5cblxuLyoqIEBub2lubGluZSAqL1xuXG5cbmZ1bmN0aW9uIHdvcmtMb29wU3luYygpIHtcbiAgLy8gUGVyZm9ybSB3b3JrIHdpdGhvdXQgY2hlY2tpbmcgaWYgd2UgbmVlZCB0byB5aWVsZCBiZXR3ZWVuIGZpYmVyLlxuICB3aGlsZSAod29ya0luUHJvZ3Jlc3MgIT09IG51bGwpIHtcbiAgICBwZXJmb3JtVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVuZGVyUm9vdENvbmN1cnJlbnQocm9vdCwgbGFuZXMpIHtcbiAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgZXhlY3V0aW9uQ29udGV4dCB8PSBSZW5kZXJDb250ZXh0O1xuICB2YXIgcHJldkRpc3BhdGNoZXIgPSBwdXNoRGlzcGF0Y2hlcigpO1xuICB2YXIgcHJldkFzeW5jRGlzcGF0Y2hlciA9IHB1c2hBc3luY0Rpc3BhdGNoZXIoKTsgLy8gSWYgdGhlIHJvb3Qgb3IgbGFuZXMgaGF2ZSBjaGFuZ2VkLCB0aHJvdyBvdXQgdGhlIGV4aXN0aW5nIHN0YWNrXG4gIC8vIGFuZCBwcmVwYXJlIGEgZnJlc2ggb25lLiBPdGhlcndpc2Ugd2UnbGwgY29udGludWUgd2hlcmUgd2UgbGVmdCBvZmYuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdCAhPT0gcm9vdCB8fCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyAhPT0gbGFuZXMpIHtcbiAgICB7XG4gICAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgICAgdmFyIG1lbW9pemVkVXBkYXRlcnMgPSByb290Lm1lbW9pemVkVXBkYXRlcnM7XG5cbiAgICAgICAgaWYgKG1lbW9pemVkVXBkYXRlcnMuc2l6ZSA+IDApIHtcbiAgICAgICAgICByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgICBtZW1vaXplZFVwZGF0ZXJzLmNsZWFyKCk7XG4gICAgICAgIH0gLy8gQXQgdGhpcyBwb2ludCwgbW92ZSBGaWJlcnMgdGhhdCBzY2hlZHVsZWQgdGhlIHVwY29taW5nIHdvcmsgZnJvbSB0aGUgTWFwIHRvIHRoZSBTZXQuXG4gICAgICAgIC8vIElmIHdlIGJhaWxvdXQgb24gdGhpcyB3b3JrLCB3ZSdsbCBtb3ZlIHRoZW0gYmFjayAobGlrZSBhYm92ZSkuXG4gICAgICAgIC8vIEl0J3MgaW1wb3J0YW50IHRvIG1vdmUgdGhlbSBub3cgaW4gY2FzZSB0aGUgd29yayBzcGF3bnMgbW9yZSB3b3JrIGF0IHRoZSBzYW1lIHByaW9yaXR5IHdpdGggZGlmZmVyZW50IHVwZGF0ZXJzLlxuICAgICAgICAvLyBUaGF0IHdheSB3ZSBjYW4ga2VlcCB0aGUgY3VycmVudCB1cGRhdGUgYW5kIGZ1dHVyZSB1cGRhdGVzIHNlcGFyYXRlLlxuXG5cbiAgICAgICAgbW92ZVBlbmRpbmdGaWJlcnNUb01lbW9pemVkKHJvb3QsIGxhbmVzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB3b3JrSW5Qcm9ncmVzc1RyYW5zaXRpb25zID0gZ2V0VHJhbnNpdGlvbnNGb3JMYW5lcygpO1xuICAgIHJlc2V0UmVuZGVyVGltZXIoKTtcbiAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBsYW5lcyk7XG4gIH1cblxuICB7XG4gICAgbWFya1JlbmRlclN0YXJ0ZWQobGFuZXMpO1xuICB9XG5cbiAgb3V0ZXI6IGRvIHtcbiAgICB0cnkge1xuICAgICAgaWYgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uICE9PSBOb3RTdXNwZW5kZWQgJiYgd29ya0luUHJvZ3Jlc3MgIT09IG51bGwpIHtcbiAgICAgICAgLy8gVGhlIHdvcmsgbG9vcCBpcyBzdXNwZW5kZWQuIFdlIG5lZWQgdG8gZWl0aGVyIHVud2luZCB0aGUgc3RhY2sgb3JcbiAgICAgICAgLy8gcmVwbGF5IHRoZSBzdXNwZW5kZWQgY29tcG9uZW50LlxuICAgICAgICB2YXIgdW5pdE9mV29yayA9IHdvcmtJblByb2dyZXNzO1xuICAgICAgICB2YXIgdGhyb3duVmFsdWUgPSB3b3JrSW5Qcm9ncmVzc1Rocm93blZhbHVlO1xuXG4gICAgICAgIHJlc3VtZU9yVW53aW5kOiBzd2l0Y2ggKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uKSB7XG4gICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkVycm9yOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyBVbndpbmQgdGhlbiBjb250aW51ZSB3aXRoIHRoZSBub3JtYWwgd29yayBsb29wLlxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3Aocm9vdCwgdW5pdE9mV29yaywgdGhyb3duVmFsdWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25EYXRhOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB2YXIgdGhlbmFibGUgPSB0aHJvd25WYWx1ZTtcblxuICAgICAgICAgICAgICBpZiAoaXNUaGVuYWJsZVJlc29sdmVkKHRoZW5hYmxlKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoZSBkYXRhIHJlc29sdmVkLiBUcnkgcmVuZGVyaW5nIHRoZSBjb21wb25lbnQgYWdhaW4uXG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBOb3RTdXNwZW5kZWQ7XG4gICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgcmVwbGF5U3VzcGVuZGVkVW5pdE9mV29yayh1bml0T2ZXb3JrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfSAvLyBUaGUgd29yayBsb29wIGlzIHN1c3BlbmRlZCBvbiBkYXRhLiBXZSBzaG91bGQgd2FpdCBmb3IgaXQgdG9cbiAgICAgICAgICAgICAgLy8gcmVzb2x2ZSBiZWZvcmUgY29udGludWluZyB0byByZW5kZXIuXG4gICAgICAgICAgICAgIC8vIFRPRE86IEhhbmRsZSB0aGUgY2FzZSB3aGVyZSB0aGUgcHJvbWlzZSByZXNvbHZlcyBzeW5jaHJvbm91c2x5LlxuICAgICAgICAgICAgICAvLyBVc3VhbGx5IHRoaXMgaXMgaGFuZGxlZCB3aGVuIHdlIGluc3RydW1lbnQgdGhlIHByb21pc2UgdG8gYWRkIGFcbiAgICAgICAgICAgICAgLy8gYHN0YXR1c2AgZmllbGQsIGJ1dCBpZiB0aGUgcHJvbWlzZSBhbHJlYWR5IGhhcyBhIHN0YXR1cywgd2Ugd29uJ3RcbiAgICAgICAgICAgICAgLy8gaGF2ZSBhZGRlZCBhIGxpc3RlbmVyIHVudGlsIHJpZ2h0IGhlcmUuXG5cblxuICAgICAgICAgICAgICB2YXIgb25SZXNvbHV0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSByb290IGlzIHN0aWxsIHN1c3BlbmRlZCBvbiB0aGlzIHByb21pc2UuXG4gICAgICAgICAgICAgICAgaWYgKHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID09PSBTdXNwZW5kZWRPbkRhdGEgJiYgd29ya0luUHJvZ3Jlc3NSb290ID09PSByb290KSB7XG4gICAgICAgICAgICAgICAgICAvLyBNYXJrIHRoZSByb290IGFzIHJlYWR5IHRvIGNvbnRpbnVlIHJlbmRlcmluZy5cbiAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gU3VzcGVuZGVkQW5kUmVhZHlUb0NvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH0gLy8gRW5zdXJlIHRoZSByb290IGlzIHNjaGVkdWxlZC4gV2Ugc2hvdWxkIGRvIHRoaXMgZXZlbiBpZiB3ZSdyZVxuICAgICAgICAgICAgICAgIC8vIGN1cnJlbnRseSB3b3JraW5nIG9uIGEgZGlmZmVyZW50IHJvb3QsIHNvIHRoYXQgd2UgcmVzdW1lXG4gICAgICAgICAgICAgICAgLy8gcmVuZGVyaW5nIGxhdGVyLlxuXG5cbiAgICAgICAgICAgICAgICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG4gICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgdGhlbmFibGUudGhlbihvblJlc29sdXRpb24sIG9uUmVzb2x1dGlvbik7XG4gICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkltbWVkaWF0ZTpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhpcyBmaWJlciBqdXN0IHN1c3BlbmRlZCwgaXQncyBwb3NzaWJsZSB0aGUgZGF0YSBpcyBhbHJlYWR5XG4gICAgICAgICAgICAgIC8vIGNhY2hlZC4gWWllbGQgdG8gdGhlIG1haW4gdGhyZWFkIHRvIGdpdmUgaXQgYSBjaGFuY2UgdG8gcGluZy4gSWZcbiAgICAgICAgICAgICAgLy8gaXQgZG9lcywgd2UgY2FuIHJldHJ5IGltbWVkaWF0ZWx5IHdpdGhvdXQgdW53aW5kaW5nIHRoZSBzdGFjay5cbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NTdXNwZW5kZWRSZWFzb24gPSBTdXNwZW5kZWRBbmRSZWFkeVRvQ29udGludWU7XG4gICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBTdXNwZW5kZWRPbkluc3RhbmNlOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IFN1c3BlbmRlZE9uSW5zdGFuY2VBbmRSZWFkeVRvQ29udGludWU7XG4gICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgY2FzZSBTdXNwZW5kZWRBbmRSZWFkeVRvQ29udGludWU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciBfdGhlbmFibGUgPSB0aHJvd25WYWx1ZTtcblxuICAgICAgICAgICAgICBpZiAoaXNUaGVuYWJsZVJlc29sdmVkKF90aGVuYWJsZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgZGF0YSByZXNvbHZlZC4gVHJ5IHJlbmRlcmluZyB0aGUgY29tcG9uZW50IGFnYWluLlxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHJlcGxheVN1c3BlbmRlZFVuaXRPZldvcmsodW5pdE9mV29yayk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCB1bndpbmQgdGhlbiBjb250aW51ZSB3aXRoIHRoZSBub3JtYWwgd29yayBsb29wLlxuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3Aocm9vdCwgdW5pdE9mV29yaywgdGhyb3duVmFsdWUpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBjYXNlIFN1c3BlbmRlZE9uSW5zdGFuY2VBbmRSZWFkeVRvQ29udGludWU6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHZhciByZXNvdXJjZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgc3dpdGNoICh3b3JrSW5Qcm9ncmVzcy50YWcpIHtcbiAgICAgICAgICAgICAgICBjYXNlIEhvc3RIb2lzdGFibGU6XG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJlc291cmNlID0gd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpbnRlbnRpb25hbCBmYWxsdGhyb3VnaFxuXG4gICAgICAgICAgICAgICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAgICAgICAgICAgIGNhc2UgSG9zdFNpbmdsZXRvbjpcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQmVmb3JlIHVud2luZGluZyB0aGUgc3RhY2ssIGNoZWNrIG9uZSBtb3JlIHRpbWUgaWYgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGluc3RhbmNlIGlzIHJlYWR5LiBJdCBtYXkgaGF2ZSBsb2FkZWQgd2hlbiBSZWFjdCB5aWVsZGVkIHRvXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZSBtYWluIHRocmVhZC5cbiAgICAgICAgICAgICAgICAgICAgLy8gQXNzaWduaW5nIHRoaXMgdG8gYSBjb25zdGFudCBzbyBGbG93IGtub3dzIHRoZSBiaW5kaW5nIHdvbid0XG4gICAgICAgICAgICAgICAgICAgIC8vIGJlIG11dGF0ZWQgYnkgYHByZWxvYWRJbnN0YW5jZWAuXG4gICAgICAgICAgICAgICAgICAgIHZhciBob3N0RmliZXIgPSB3b3JrSW5Qcm9ncmVzcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIHR5cGUgPSBob3N0RmliZXIudHlwZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb3BzID0gaG9zdEZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzUmVhZHkgPSByZXNvdXJjZSA/IHByZWxvYWRSZXNvdXJjZShyZXNvdXJjZSkgOiBwcmVsb2FkSW5zdGFuY2UodHlwZSwgcHJvcHMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1JlYWR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGRhdGEgcmVzb2x2ZWQuIFJlc3VtZSB0aGUgd29yayBsb29wIGFzIGlmIG5vdGhpbmdcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdXNwZW5kZWQuIFVubGlrZSB3aGVuIGEgdXNlciBjb21wb25lbnQgc3VzcGVuZHMsIHdlIGRvbid0XG4gICAgICAgICAgICAgICAgICAgICAgLy8gaGF2ZSB0byByZXBsYXkgYW55dGhpbmcgYmVjYXVzZSB0aGUgaG9zdCBmaWJlclxuICAgICAgICAgICAgICAgICAgICAgIC8vIGFscmVhZHkgY29tcGxldGVkLlxuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uID0gTm90U3VzcGVuZGVkO1xuICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzVGhyb3duVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgIHZhciBzaWJsaW5nID0gaG9zdEZpYmVyLnNpYmxpbmc7XG5cbiAgICAgICAgICAgICAgICAgICAgICBpZiAoc2libGluZyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSBzaWJsaW5nO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmV0dXJuRmliZXIgPSBob3N0RmliZXIucmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgY29tcGxldGVVbml0T2ZXb3JrKHJldHVybkZpYmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICBicmVhayByZXN1bWVPclVud2luZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGZhaWwgZ3JhY2VmdWxseSBidXQgaXQncyBub3QgY29ycmVjdCwgc28gbG9nIGFcbiAgICAgICAgICAgICAgICAgICAgLy8gd2FybmluZyBpbiBkZXYuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ1VuZXhwZWN0ZWQgdHlwZSBvZiBmaWJlciB0cmlnZ2VyZWQgYSBzdXNwZW5zZXkgY29tbWl0LiAnICsgJ1RoaXMgaXMgYSBidWcgaW4gUmVhY3QuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSAvLyBPdGhlcndpc2UsIHVud2luZCB0aGVuIGNvbnRpbnVlIHdpdGggdGhlIG5vcm1hbCB3b3JrIGxvb3AuXG5cblxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3Aocm9vdCwgdW5pdE9mV29yaywgdGhyb3duVmFsdWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25EZXByZWNhdGVkVGhyb3dQcm9taXNlOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAvLyBTdXNwZW5kZWQgYnkgYW4gb2xkIGltcGxlbWVudGF0aW9uIHRoYXQgdXNlcyB0aGUgYHRocm93IHByb21pc2VgXG4gICAgICAgICAgICAgIC8vIHBhdHRlcm4uIFRoZSBuZXdlciByZXBsYXlpbmcgYmVoYXZpb3IgY2FuIGNhdXNlIHN1YnRsZSBpc3N1ZXNcbiAgICAgICAgICAgICAgLy8gbGlrZSBpbmZpbml0ZSBwaW5nIGxvb3BzLiBTbyB3ZSBtYWludGFpbiB0aGUgb2xkIGJlaGF2aW9yIGFuZFxuICAgICAgICAgICAgICAvLyBhbHdheXMgdW53aW5kLlxuICAgICAgICAgICAgICB3b3JrSW5Qcm9ncmVzc1N1c3BlbmRlZFJlYXNvbiA9IE5vdFN1c3BlbmRlZDtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSA9IG51bGw7XG4gICAgICAgICAgICAgIHRocm93QW5kVW53aW5kV29ya0xvb3Aocm9vdCwgdW5pdE9mV29yaywgdGhyb3duVmFsdWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgIGNhc2UgU3VzcGVuZGVkT25IeWRyYXRpb246XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIC8vIFNlbGVjdGl2ZSBoeWRyYXRpb24uIEFuIHVwZGF0ZSBmbG93ZWQgaW50byBhIGRlaHlkcmF0ZWQgdHJlZS5cbiAgICAgICAgICAgICAgLy8gSW50ZXJydXB0IHRoZSBjdXJyZW50IHJlbmRlciBzbyB0aGUgd29yayBsb29wIGNhbiBzd2l0Y2ggdG8gdGhlXG4gICAgICAgICAgICAgIC8vIGh5ZHJhdGlvbiBsYW5lLlxuICAgICAgICAgICAgICByZXNldFdvcmtJblByb2dyZXNzU3RhY2soKTtcbiAgICAgICAgICAgICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3REaWROb3RDb21wbGV0ZTtcbiAgICAgICAgICAgICAgYnJlYWsgb3V0ZXI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgU3VzcGVuZGVkUmVhc29uLiBUaGlzIGlzIGEgYnVnIGluIFJlYWN0LicpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0cnVlICYmIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlICE9PSBudWxsKSB7XG4gICAgICAgIC8vIGBhY3RgIHNwZWNpYWwgY2FzZTogSWYgd2UncmUgaW5zaWRlIGFuIGBhY3RgIHNjb3BlLCBkb24ndCBjb25zdWx0XG4gICAgICAgIC8vIGBzaG91bGRZaWVsZGAuIEFsd2F5cyBrZWVwIHdvcmtpbmcgdW50aWwgdGhlIHJlbmRlciBpcyBjb21wbGV0ZS5cbiAgICAgICAgLy8gVGhpcyBpcyBub3QganVzdCBhbiBvcHRpbWl6YXRpb246IGluIGEgdW5pdCB0ZXN0IGVudmlyb25tZW50LCB3ZVxuICAgICAgICAvLyBjYW4ndCB0cnVzdCB0aGUgcmVzdWx0IG9mIGBzaG91bGRZaWVsZGAsIGJlY2F1c2UgdGhlIGhvc3QgSS9PIGlzXG4gICAgICAgIC8vIGxpa2VseSBtb2NrZWQuXG4gICAgICAgIHdvcmtMb29wU3luYygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgd29ya0xvb3BDb25jdXJyZW50KCk7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIH0gY2F0Y2ggKHRocm93blZhbHVlKSB7XG4gICAgICBoYW5kbGVUaHJvdyhyb290LCB0aHJvd25WYWx1ZSk7XG4gICAgfVxuICB9IHdoaWxlICh0cnVlKTtcblxuICByZXNldENvbnRleHREZXBlbmRlbmNpZXMoKTtcbiAgcG9wRGlzcGF0Y2hlcihwcmV2RGlzcGF0Y2hlcik7XG4gIHBvcEFzeW5jRGlzcGF0Y2hlcihwcmV2QXN5bmNEaXNwYXRjaGVyKTtcbiAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0O1xuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzICE9PSBudWxsKSB7XG4gICAgLy8gU3RpbGwgd29yayByZW1haW5pbmcuXG4gICAge1xuICAgICAgbWFya1JlbmRlcllpZWxkZWQoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gUm9vdEluUHJvZ3Jlc3M7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ29tcGxldGVkIHRoZSB0cmVlLlxuICAgIHtcbiAgICAgIG1hcmtSZW5kZXJTdG9wcGVkKCk7XG4gICAgfSAvLyBTZXQgdGhpcyB0byBudWxsIHRvIGluZGljYXRlIHRoZXJlJ3Mgbm8gaW4tcHJvZ3Jlc3MgcmVuZGVyLlxuXG5cbiAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzID0gTm9MYW5lczsgLy8gSXQncyBzYWZlIHRvIHByb2Nlc3MgdGhlIHF1ZXVlIG5vdyB0aGF0IHRoZSByZW5kZXIgcGhhc2UgaXMgY29tcGxldGUuXG5cbiAgICBmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzKCk7IC8vIFJldHVybiB0aGUgZmluYWwgZXhpdCBzdGF0dXMuXG5cbiAgICByZXR1cm4gd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cztcbiAgfVxufVxuLyoqIEBub2lubGluZSAqL1xuXG5cbmZ1bmN0aW9uIHdvcmtMb29wQ29uY3VycmVudCgpIHtcbiAgLy8gUGVyZm9ybSB3b3JrIHVudGlsIFNjaGVkdWxlciBhc2tzIHVzIHRvIHlpZWxkXG4gIHdoaWxlICh3b3JrSW5Qcm9ncmVzcyAhPT0gbnVsbCAmJiAhc2hvdWxkWWllbGQoKSkge1xuICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLWNhbGxdIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcbiAgICBwZXJmb3JtVW5pdE9mV29yayh3b3JrSW5Qcm9ncmVzcyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGVyZm9ybVVuaXRPZldvcmsodW5pdE9mV29yaykge1xuICAvLyBUaGUgY3VycmVudCwgZmx1c2hlZCwgc3RhdGUgb2YgdGhpcyBmaWJlciBpcyB0aGUgYWx0ZXJuYXRlLiBJZGVhbGx5XG4gIC8vIG5vdGhpbmcgc2hvdWxkIHJlbHkgb24gdGhpcywgYnV0IHJlbHlpbmcgb24gaXQgaGVyZSBtZWFucyB0aGF0IHdlIGRvbid0XG4gIC8vIG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpbiBwcm9ncmVzcy5cbiAgdmFyIGN1cnJlbnQgPSB1bml0T2ZXb3JrLmFsdGVybmF0ZTtcbiAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVih1bml0T2ZXb3JrKTtcbiAgdmFyIG5leHQ7XG5cbiAgaWYgKCh1bml0T2ZXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgIHN0YXJ0UHJvZmlsZXJUaW1lcih1bml0T2ZXb3JrKTtcbiAgICBuZXh0ID0gYmVnaW5Xb3JrKGN1cnJlbnQsIHVuaXRPZldvcmssIGVudGFuZ2xlZFJlbmRlckxhbmVzKTtcbiAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKHVuaXRPZldvcmssIHRydWUpO1xuICB9IGVsc2Uge1xuICAgIG5leHQgPSBiZWdpbldvcmsoY3VycmVudCwgdW5pdE9mV29yaywgZW50YW5nbGVkUmVuZGVyTGFuZXMpO1xuICB9XG5cbiAge1xuICAgIHJlc2V0Q3VycmVudEZpYmVyKCk7XG4gIH1cblxuICB1bml0T2ZXb3JrLm1lbW9pemVkUHJvcHMgPSB1bml0T2ZXb3JrLnBlbmRpbmdQcm9wcztcblxuICBpZiAobmV4dCA9PT0gbnVsbCkge1xuICAgIC8vIElmIHRoaXMgZG9lc24ndCBzcGF3biBuZXcgd29yaywgY29tcGxldGUgdGhlIGN1cnJlbnQgd29yay5cbiAgICBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yayk7XG4gIH0gZWxzZSB7XG4gICAgd29ya0luUHJvZ3Jlc3MgPSBuZXh0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcGxheVN1c3BlbmRlZFVuaXRPZldvcmsodW5pdE9mV29yaykge1xuICAvLyBUaGlzIGlzIGEgZm9yayBvZiBwZXJmb3JtVW5pdE9mV29yayBzcGVjaWZjYWxseSBmb3IgcmVwbGF5aW5nIGEgZmliZXIgdGhhdFxuICAvLyBqdXN0IHN1c3BlbmRlZC5cbiAgLy9cbiAgdmFyIGN1cnJlbnQgPSB1bml0T2ZXb3JrLmFsdGVybmF0ZTtcbiAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVih1bml0T2ZXb3JrKTtcbiAgdmFyIG5leHQ7XG4gIHZhciBpc1Byb2ZpbGluZ01vZGUgPSAodW5pdE9mV29yay5tb2RlICYgUHJvZmlsZU1vZGUpICE9PSBOb01vZGU7XG5cbiAgaWYgKGlzUHJvZmlsaW5nTW9kZSkge1xuICAgIHN0YXJ0UHJvZmlsZXJUaW1lcih1bml0T2ZXb3JrKTtcbiAgfVxuXG4gIHN3aXRjaCAodW5pdE9mV29yay50YWcpIHtcbiAgICBjYXNlIFNpbXBsZU1lbW9Db21wb25lbnQ6XG4gICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgIHtcbiAgICAgICAgLy8gUmVzb2x2ZSBgZGVmYXVsdFByb3BzYC4gVGhpcyBsb2dpYyBpcyBjb3BpZWQgZnJvbSBgYmVnaW5Xb3JrYC5cbiAgICAgICAgLy8gVE9ETzogQ29uc2lkZXIgbW92aW5nIHRoaXMgc3dpdGNoIHN0YXRlbWVudCBpbnRvIHRoYXQgbW9kdWxlLiBBbHNvLFxuICAgICAgICAvLyBjb3VsZCBtYXliZSB1c2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBzYXkgYHVzZWAgZG9lc24ndCB3b3JrIHdpdGhcbiAgICAgICAgLy8gYGRlZmF1bHRQcm9wc2AgOilcbiAgICAgICAgdmFyIENvbXBvbmVudCA9IHVuaXRPZldvcmsudHlwZTtcbiAgICAgICAgdmFyIHVucmVzb2x2ZWRQcm9wcyA9IHVuaXRPZldvcmsucGVuZGluZ1Byb3BzO1xuICAgICAgICB2YXIgcmVzb2x2ZWRQcm9wcyA9IHVucmVzb2x2ZWRQcm9wcyA7XG4gICAgICAgIHZhciBjb250ZXh0O1xuXG4gICAgICAgIG5leHQgPSByZXBsYXlGdW5jdGlvbkNvbXBvbmVudChjdXJyZW50LCB1bml0T2ZXb3JrLCByZXNvbHZlZFByb3BzLCBDb21wb25lbnQsIGNvbnRleHQsIHdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICB7XG4gICAgICAgIC8vIFJlc29sdmUgYGRlZmF1bHRQcm9wc2AuIFRoaXMgbG9naWMgaXMgY29waWVkIGZyb20gYGJlZ2luV29ya2AuXG4gICAgICAgIC8vIFRPRE86IENvbnNpZGVyIG1vdmluZyB0aGlzIHN3aXRjaCBzdGF0ZW1lbnQgaW50byB0aGF0IG1vZHVsZS4gQWxzbyxcbiAgICAgICAgLy8gY291bGQgbWF5YmUgdXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gc2F5IGB1c2VgIGRvZXNuJ3Qgd29yayB3aXRoXG4gICAgICAgIC8vIGBkZWZhdWx0UHJvcHNgIDopXG4gICAgICAgIHZhciBfQ29tcG9uZW50ID0gdW5pdE9mV29yay50eXBlLnJlbmRlcjtcbiAgICAgICAgdmFyIF91bnJlc29sdmVkUHJvcHMgPSB1bml0T2ZXb3JrLnBlbmRpbmdQcm9wcztcblxuICAgICAgICB2YXIgX3Jlc29sdmVkUHJvcHMgPSBfdW5yZXNvbHZlZFByb3BzIDtcblxuICAgICAgICBuZXh0ID0gcmVwbGF5RnVuY3Rpb25Db21wb25lbnQoY3VycmVudCwgdW5pdE9mV29yaywgX3Jlc29sdmVkUHJvcHMsIF9Db21wb25lbnQsIHVuaXRPZldvcmsucmVmLCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSBIb3N0Q29tcG9uZW50OlxuICAgICAge1xuICAgICAgICAvLyBTb21lIGhvc3QgY29tcG9uZW50cyBhcmUgc3RhdGVmdWwgKHRoYXQncyBob3cgd2UgaW1wbGVtZW50IGZvcm1cbiAgICAgICAgLy8gYWN0aW9ucykgYnV0IHdlIGRvbid0IGJvdGhlciB0byByZXVzZSB0aGUgbWVtb2l6ZWQgc3RhdGUgYmVjYXVzZSBpdCdzXG4gICAgICAgIC8vIG5vdCB3b3J0aCB0aGUgZXh0cmEgY29kZS4gVGhlIG1haW4gcmVhc29uIHRvIHJldXNlIHRoZSBwcmV2aW91cyBob29rc1xuICAgICAgICAvLyBpcyB0byByZXVzZSB1bmNhY2hlZCBwcm9taXNlcywgYnV0IHdlIGhhcHBlbiB0byBrbm93IHRoYXQgdGhlIG9ubHlcbiAgICAgICAgLy8gcHJvbWlzZXMgdGhhdCBhIGhvc3QgY29tcG9uZW50IG1pZ2h0IHN1c3BlbmQgb24gYXJlIGRlZmluaXRlbHkgY2FjaGVkXG4gICAgICAgIC8vIGJlY2F1c2UgdGhleSBhcmUgY29udHJvbGxlZCBieSB1cy4gU28gZG9uJ3QgYm90aGVyLlxuICAgICAgICByZXNldEhvb2tzT25VbndpbmQodW5pdE9mV29yayk7IC8vIEZhbGx0aHJvdWdoIHRvIHRoZSBuZXh0IGJyYW5jaC5cbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIC8vIE90aGVyIHR5cGVzIGJlc2lkZXMgZnVuY3Rpb24gY29tcG9uZW50cyBhcmUgcmVzZXQgY29tcGxldGVseSBiZWZvcmVcbiAgICAgICAgLy8gYmVpbmcgcmVwbGF5ZWQuIEN1cnJlbnRseSB0aGlzIG9ubHkgaGFwcGVucyB3aGVuIGEgVXNhYmxlIHR5cGUgaXNcbiAgICAgICAgLy8gcmVjb25jaWxlZCDigJQgdGhlIHJlY29uY2lsZXIgd2lsbCBzdXNwZW5kLlxuICAgICAgICAvL1xuICAgICAgICAvLyBXZSByZXNldCB0aGUgZmliZXIgYmFjayB0byBpdHMgb3JpZ2luYWwgc3RhdGU7IGhvd2V2ZXIsIHRoaXMgaXNuJ3RcbiAgICAgICAgLy8gYSBmdWxsIFwidW53aW5kXCIgYmVjYXVzZSB3ZSdyZSBnb2luZyB0byByZXVzZSB0aGUgcHJvbWlzZXMgdGhhdCB3ZXJlXG4gICAgICAgIC8vIHJlY29uY2lsZWQgcHJldmlvdXNseS4gU28gaXQncyBpbnRlbnRpb25hbCB0aGF0IHdlIGRvbid0IGNhbGxcbiAgICAgICAgLy8gcmVzZXRTdXNwZW5kZWRXb3JrTG9vcE9uVW53aW5kIGhlcmUuXG4gICAgICAgIHVud2luZEludGVycnVwdGVkV29yayhjdXJyZW50LCB1bml0T2ZXb3JrKTtcbiAgICAgICAgdW5pdE9mV29yayA9IHdvcmtJblByb2dyZXNzID0gcmVzZXRXb3JrSW5Qcm9ncmVzcyh1bml0T2ZXb3JrLCBlbnRhbmdsZWRSZW5kZXJMYW5lcyk7XG4gICAgICAgIG5leHQgPSBiZWdpbldvcmsoY3VycmVudCwgdW5pdE9mV29yaywgZW50YW5nbGVkUmVuZGVyTGFuZXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgfVxuXG4gIGlmIChpc1Byb2ZpbGluZ01vZGUpIHtcbiAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKHVuaXRPZldvcmssIHRydWUpO1xuICB9IC8vIFRoZSBiZWdpbiBwaGFzZSBmaW5pc2hlZCBzdWNjZXNzZnVsbHkgd2l0aG91dCBzdXNwZW5kaW5nLiBSZXR1cm4gdG8gdGhlXG4gIC8vIG5vcm1hbCB3b3JrIGxvb3AuXG5cblxuICB7XG4gICAgcmVzZXRDdXJyZW50RmliZXIoKTtcbiAgfVxuXG4gIHVuaXRPZldvcmsubWVtb2l6ZWRQcm9wcyA9IHVuaXRPZldvcmsucGVuZGluZ1Byb3BzO1xuXG4gIGlmIChuZXh0ID09PSBudWxsKSB7XG4gICAgLy8gSWYgdGhpcyBkb2Vzbid0IHNwYXduIG5ldyB3b3JrLCBjb21wbGV0ZSB0aGUgY3VycmVudCB3b3JrLlxuICAgIGNvbXBsZXRlVW5pdE9mV29yayh1bml0T2ZXb3JrKTtcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzcyA9IG5leHQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gdGhyb3dBbmRVbndpbmRXb3JrTG9vcChyb290LCB1bml0T2ZXb3JrLCB0aHJvd25WYWx1ZSkge1xuICAvLyBUaGlzIGlzIGEgZm9yayBvZiBwZXJmb3JtVW5pdE9mV29yayBzcGVjaWZjYWxseSBmb3IgdW53aW5kaW5nIGEgZmliZXJcbiAgLy8gdGhhdCB0aHJldyBhbiBleGNlcHRpb24uXG4gIC8vXG4gIC8vIFJldHVybiB0byB0aGUgbm9ybWFsIHdvcmsgbG9vcC4gVGhpcyB3aWxsIHVud2luZCB0aGUgc3RhY2ssIGFuZCBwb3RlbnRpYWxseVxuICAvLyByZXN1bHQgaW4gc2hvd2luZyBhIGZhbGxiYWNrLlxuICByZXNldFN1c3BlbmRlZFdvcmtMb29wT25VbndpbmQodW5pdE9mV29yayk7XG4gIHZhciByZXR1cm5GaWJlciA9IHVuaXRPZldvcmsucmV0dXJuO1xuXG4gIHRyeSB7XG4gICAgLy8gRmluZCBhbmQgbWFyayB0aGUgbmVhcmVzdCBTdXNwZW5zZSBvciBlcnJvciBib3VuZGFyeSB0aGF0IGNhbiBoYW5kbGVcbiAgICAvLyB0aGlzIFwiZXhjZXB0aW9uXCIuXG4gICAgdmFyIGRpZEZhdGFsID0gdGhyb3dFeGNlcHRpb24ocm9vdCwgcmV0dXJuRmliZXIsIHVuaXRPZldvcmssIHRocm93blZhbHVlLCB3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyk7XG5cbiAgICBpZiAoZGlkRmF0YWwpIHtcbiAgICAgIHBhbmljT25Sb290RXJyb3Iocm9vdCwgdGhyb3duVmFsdWUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAvLyBXZSBoYWQgdHJvdWJsZSBwcm9jZXNzaW5nIHRoZSBlcnJvci4gQW4gZXhhbXBsZSBvZiB0aGlzIGhhcHBlbmluZyBpc1xuICAgIC8vIHdoZW4gYWNjZXNzaW5nIHRoZSBgY29tcG9uZW50RGlkQ2F0Y2hgIHByb3BlcnR5IG9mIGFuIGVycm9yIGJvdW5kYXJ5XG4gICAgLy8gdGhyb3dzIGFuIGVycm9yLiBBIHdlaXJkIGVkZ2UgY2FzZS4gVGhlcmUncyBhIHJlZ3Jlc3Npb24gdGVzdCBmb3IgdGhpcy5cbiAgICAvLyBUbyBwcmV2ZW50IGFuIGluZmluaXRlIGxvb3AsIGJ1YmJsZSB0aGUgZXJyb3IgdXAgdG8gdGhlIG5leHQgcGFyZW50LlxuICAgIGlmIChyZXR1cm5GaWJlciAhPT0gbnVsbCkge1xuICAgICAgd29ya0luUHJvZ3Jlc3MgPSByZXR1cm5GaWJlcjtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYW5pY09uUm9vdEVycm9yKHJvb3QsIHRocm93blZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBpZiAodW5pdE9mV29yay5mbGFncyAmIEluY29tcGxldGUpIHtcbiAgICAvLyBVbndpbmQgdGhlIHN0YWNrIHVudGlsIHdlIHJlYWNoIHRoZSBuZWFyZXN0IGJvdW5kYXJ5LlxuICAgIHVud2luZFVuaXRPZldvcmsodW5pdE9mV29yayk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQWx0aG91Z2ggdGhlIGZpYmVyIHN1c3BlbmRlZCwgd2UncmUgaW50ZW50aW9uYWxseSBnb2luZyB0byBjb21taXQgaXQgaW5cbiAgICAvLyBhbiBpbmNvbnNpc3RlbnQgc3RhdGUuIFdlIGNhbiBkbyB0aGlzIHNhZmVseSBpbiBjYXNlcyB3aGVyZSB3ZSBrbm93IHRoZVxuICAgIC8vIGluY29uc2lzdGVudCB0cmVlIHdpbGwgYmUgaGlkZGVuLlxuICAgIC8vXG4gICAgLy8gVGhpcyBjdXJyZW50bHkgb25seSBhcHBsaWVzIHRvIExlZ2FjeSBTdXNwZW5zZSBpbXBsZW1lbnRhdGlvbiwgYnV0IHdlIG1heVxuICAgIC8vIHBvcnQgYSB2ZXJzaW9uIG9mIHRoaXMgdG8gY29uY3VycmVudCByb290cywgdG9vLCB3aGVuIHBlcmZvcm1pbmcgYVxuICAgIC8vIHN5bmNocm9ub3VzIHJlbmRlci4gQmVjYXVzZSB0aGF0IHdpbGwgYWxsb3cgdXMgdG8gbXV0YXRlIHRoZSB0cmVlIGFzIHdlXG4gICAgLy8gZ28gaW5zdGVhZCBvZiBidWZmZXJpbmcgbXV0YXRpb25zIHVudGlsIHRoZSBlbmQuIFRob3VnaCBpdCdzIHVuY2xlYXIgaWZcbiAgICAvLyB0aGlzIHBhcnRpY3VsYXIgcGF0aCBpcyBob3cgdGhhdCB3b3VsZCBiZSBpbXBsZW1lbnRlZC5cbiAgICBjb21wbGV0ZVVuaXRPZldvcmsodW5pdE9mV29yayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFuaWNPblJvb3RFcnJvcihyb290LCBlcnJvcikge1xuICAvLyBUaGVyZSdzIG5vIGFuY2VzdG9yIHRoYXQgY2FuIGhhbmRsZSB0aGlzIGV4Y2VwdGlvbi4gVGhpcyBzaG91bGQgbmV2ZXJcbiAgLy8gaGFwcGVuIGJlY2F1c2UgdGhlIHJvb3QgaXMgc3VwcG9zZWQgdG8gY2FwdHVyZSBhbGwgZXJyb3JzIHRoYXQgd2VyZW4ndFxuICAvLyBjYXVnaHQgYnkgYW4gZXJyb3IgYm91bmRhcnkuIFRoaXMgaXMgYSBmYXRhbCBlcnJvciwgb3IgcGFuaWMgY29uZGl0aW9uLFxuICAvLyBiZWNhdXNlIHdlJ3ZlIHJ1biBvdXQgb2Ygd2F5cyB0byByZWNvdmVyLlxuICB3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID0gUm9vdEZhdGFsRXJyb3JlZDtcbiAgbG9nVW5jYXVnaHRFcnJvcihyb290LCBjcmVhdGVDYXB0dXJlZFZhbHVlQXRGaWJlcihlcnJvciwgcm9vdC5jdXJyZW50KSk7IC8vIFNldCBgd29ya0luUHJvZ3Jlc3NgIHRvIG51bGwuIFRoaXMgcmVwcmVzZW50cyBhZHZhbmNpbmcgdG8gdGhlIG5leHRcbiAgLy8gc2libGluZywgb3IgdGhlIHBhcmVudCBpZiB0aGVyZSBhcmUgbm8gc2libGluZ3MuIEJ1dCBzaW5jZSB0aGUgcm9vdFxuICAvLyBoYXMgbm8gc2libGluZ3Mgbm9yIGEgcGFyZW50LCB3ZSBzZXQgaXQgdG8gbnVsbC4gVXN1YWxseSB0aGlzIGlzXG4gIC8vIGhhbmRsZWQgYnkgYGNvbXBsZXRlVW5pdE9mV29ya2Agb3IgYHVud2luZFdvcmtgLCBidXQgc2luY2Ugd2UncmVcbiAgLy8gaW50ZW50aW9uYWxseSBub3QgY2FsbGluZyB0aG9zZSwgd2UgbmVlZCBzZXQgaXQgaGVyZS5cbiAgLy8gVE9ETzogQ29uc2lkZXIgY2FsbGluZyBgdW53aW5kV29ya2AgdG8gcG9wIHRoZSBjb250ZXh0cy5cblxuICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG59XG5cbmZ1bmN0aW9uIGNvbXBsZXRlVW5pdE9mV29yayh1bml0T2ZXb3JrKSB7XG4gIC8vIEF0dGVtcHQgdG8gY29tcGxldGUgdGhlIGN1cnJlbnQgdW5pdCBvZiB3b3JrLCB0aGVuIG1vdmUgdG8gdGhlIG5leHRcbiAgLy8gc2libGluZy4gSWYgdGhlcmUgYXJlIG5vIG1vcmUgc2libGluZ3MsIHJldHVybiB0byB0aGUgcGFyZW50IGZpYmVyLlxuICB2YXIgY29tcGxldGVkV29yayA9IHVuaXRPZldvcms7XG5cbiAgZG8ge1xuICAgIHtcbiAgICAgIGlmICgoY29tcGxldGVkV29yay5mbGFncyAmIEluY29tcGxldGUpICE9PSBOb0ZsYWdzJDEpIHtcbiAgICAgICAgLy8gTk9URTogSWYgd2UgcmUtZW5hYmxlIHNpYmxpbmcgcHJlcmVuZGVyaW5nIGluIHNvbWUgY2FzZXMsIHRoaXMgYnJhbmNoXG4gICAgICAgIC8vIGlzIHdoZXJlIHdlIHdvdWxkIHN3aXRjaCB0byB0aGUgdW53aW5kaW5nIHBhdGguXG4gICAgICAgIGVycm9yKCdJbnRlcm5hbCBSZWFjdCBlcnJvcjogRXhwZWN0ZWQgdGhpcyBmaWJlciB0byBiZSBjb21wbGV0ZSwgYnV0ICcgKyBcIml0IGlzbid0LiBJdCBzaG91bGQgaGF2ZSBiZWVuIHVud291bmQuIFRoaXMgaXMgYSBidWcgaW4gUmVhY3QuXCIpO1xuICAgICAgfVxuICAgIH0gLy8gVGhlIGN1cnJlbnQsIGZsdXNoZWQsIHN0YXRlIG9mIHRoaXMgZmliZXIgaXMgdGhlIGFsdGVybmF0ZS4gSWRlYWxseVxuICAgIC8vIG5vdGhpbmcgc2hvdWxkIHJlbHkgb24gdGhpcywgYnV0IHJlbHlpbmcgb24gaXQgaGVyZSBtZWFucyB0aGF0IHdlIGRvbid0XG4gICAgLy8gbmVlZCBhbiBhZGRpdGlvbmFsIGZpZWxkIG9uIHRoZSB3b3JrIGluIHByb2dyZXNzLlxuXG5cbiAgICB2YXIgY3VycmVudCA9IGNvbXBsZXRlZFdvcmsuYWx0ZXJuYXRlO1xuICAgIHZhciByZXR1cm5GaWJlciA9IGNvbXBsZXRlZFdvcmsucmV0dXJuO1xuICAgIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoY29tcGxldGVkV29yayk7XG4gICAgdmFyIG5leHQgPSB2b2lkIDA7XG5cbiAgICBpZiAoKGNvbXBsZXRlZFdvcmsubW9kZSAmIFByb2ZpbGVNb2RlKSA9PT0gTm9Nb2RlKSB7XG4gICAgICBuZXh0ID0gY29tcGxldGVXb3JrKGN1cnJlbnQsIGNvbXBsZXRlZFdvcmssIGVudGFuZ2xlZFJlbmRlckxhbmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRQcm9maWxlclRpbWVyKGNvbXBsZXRlZFdvcmspO1xuICAgICAgbmV4dCA9IGNvbXBsZXRlV29yayhjdXJyZW50LCBjb21wbGV0ZWRXb3JrLCBlbnRhbmdsZWRSZW5kZXJMYW5lcyk7IC8vIFVwZGF0ZSByZW5kZXIgZHVyYXRpb24gYXNzdW1pbmcgd2UgZGlkbid0IGVycm9yLlxuXG4gICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGNvbXBsZXRlZFdvcmssIGZhbHNlKTtcbiAgICB9XG5cbiAgICByZXNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoKTtcblxuICAgIGlmIChuZXh0ICE9PSBudWxsKSB7XG4gICAgICAvLyBDb21wbGV0aW5nIHRoaXMgZmliZXIgc3Bhd25lZCBuZXcgd29yay4gV29yayBvbiB0aGF0IG5leHQuXG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IG5leHQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHNpYmxpbmdGaWJlciA9IGNvbXBsZXRlZFdvcmsuc2libGluZztcblxuICAgIGlmIChzaWJsaW5nRmliZXIgIT09IG51bGwpIHtcbiAgICAgIC8vIElmIHRoZXJlIGlzIG1vcmUgd29yayB0byBkbyBpbiB0aGlzIHJldHVybkZpYmVyLCBkbyB0aGF0IG5leHQuXG4gICAgICB3b3JrSW5Qcm9ncmVzcyA9IHNpYmxpbmdGaWJlcjtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIE90aGVyd2lzZSwgcmV0dXJuIHRvIHRoZSBwYXJlbnRcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSB3ZSBiYWlsIG91dCB3aGVuIHdlIGdldCBhIG51bGxcblxuXG4gICAgY29tcGxldGVkV29yayA9IHJldHVybkZpYmVyOyAvLyBVcGRhdGUgdGhlIG5leHQgdGhpbmcgd2UncmUgd29ya2luZyBvbiBpbiBjYXNlIHNvbWV0aGluZyB0aHJvd3MuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcyA9IGNvbXBsZXRlZFdvcms7XG4gIH0gd2hpbGUgKGNvbXBsZXRlZFdvcmsgIT09IG51bGwpOyAvLyBXZSd2ZSByZWFjaGVkIHRoZSByb290LlxuXG5cbiAgaWYgKHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RJblByb2dyZXNzKSB7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyA9IFJvb3RDb21wbGV0ZWQ7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW53aW5kVW5pdE9mV29yayh1bml0T2ZXb3JrKSB7XG4gIHZhciBpbmNvbXBsZXRlV29yayA9IHVuaXRPZldvcms7XG5cbiAgZG8ge1xuICAgIC8vIFRoZSBjdXJyZW50LCBmbHVzaGVkLCBzdGF0ZSBvZiB0aGlzIGZpYmVyIGlzIHRoZSBhbHRlcm5hdGUuIElkZWFsbHlcbiAgICAvLyBub3RoaW5nIHNob3VsZCByZWx5IG9uIHRoaXMsIGJ1dCByZWx5aW5nIG9uIGl0IGhlcmUgbWVhbnMgdGhhdCB3ZSBkb24ndFxuICAgIC8vIG5lZWQgYW4gYWRkaXRpb25hbCBmaWVsZCBvbiB0aGUgd29yayBpbiBwcm9ncmVzcy5cbiAgICB2YXIgY3VycmVudCA9IGluY29tcGxldGVXb3JrLmFsdGVybmF0ZTsgLy8gVGhpcyBmaWJlciBkaWQgbm90IGNvbXBsZXRlIGJlY2F1c2Ugc29tZXRoaW5nIHRocmV3LiBQb3AgdmFsdWVzIG9mZlxuICAgIC8vIHRoZSBzdGFjayB3aXRob3V0IGVudGVyaW5nIHRoZSBjb21wbGV0ZSBwaGFzZS4gSWYgdGhpcyBpcyBhIGJvdW5kYXJ5LFxuICAgIC8vIGNhcHR1cmUgdmFsdWVzIGlmIHBvc3NpYmxlLlxuXG4gICAgdmFyIG5leHQgPSB1bndpbmRXb3JrKGN1cnJlbnQsIGluY29tcGxldGVXb3JrKTsgLy8gQmVjYXVzZSB0aGlzIGZpYmVyIGRpZCBub3QgY29tcGxldGUsIGRvbid0IHJlc2V0IGl0cyBsYW5lcy5cblxuICAgIGlmIChuZXh0ICE9PSBudWxsKSB7XG4gICAgICAvLyBGb3VuZCBhIGJvdW5kYXJ5IHRoYXQgY2FuIGhhbmRsZSB0aGlzIGV4Y2VwdGlvbi4gUmUtcmVudGVyIHRoZVxuICAgICAgLy8gYmVnaW4gcGhhc2UuIFRoaXMgYnJhbmNoIHdpbGwgcmV0dXJuIHVzIHRvIHRoZSBub3JtYWwgd29yayBsb29wLlxuICAgICAgLy9cbiAgICAgIC8vIFNpbmNlIHdlJ3JlIHJlc3RhcnRpbmcsIHJlbW92ZSBhbnl0aGluZyB0aGF0IGlzIG5vdCBhIGhvc3QgZWZmZWN0XG4gICAgICAvLyBmcm9tIHRoZSBlZmZlY3QgdGFnLlxuICAgICAgbmV4dC5mbGFncyAmPSBIb3N0RWZmZWN0TWFzaztcbiAgICAgIHdvcmtJblByb2dyZXNzID0gbmV4dDtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIEtlZXAgdW53aW5kaW5nIHVudGlsIHdlIHJlYWNoIGVpdGhlciBhIGJvdW5kYXJ5IG9yIHRoZSByb290LlxuXG5cbiAgICBpZiAoKGluY29tcGxldGVXb3JrLm1vZGUgJiBQcm9maWxlTW9kZSkgIT09IE5vTW9kZSkge1xuICAgICAgLy8gUmVjb3JkIHRoZSByZW5kZXIgZHVyYXRpb24gZm9yIHRoZSBmaWJlciB0aGF0IGVycm9yZWQuXG4gICAgICBzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZ0FuZFJlY29yZERlbHRhKGluY29tcGxldGVXb3JrLCBmYWxzZSk7IC8vIEluY2x1ZGUgdGhlIHRpbWUgc3BlbnQgd29ya2luZyBvbiBmYWlsZWQgY2hpbGRyZW4gYmVmb3JlIGNvbnRpbnVpbmcuXG5cbiAgICAgIHZhciBhY3R1YWxEdXJhdGlvbiA9IGluY29tcGxldGVXb3JrLmFjdHVhbER1cmF0aW9uO1xuICAgICAgdmFyIGNoaWxkID0gaW5jb21wbGV0ZVdvcmsuY2hpbGQ7XG5cbiAgICAgIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICAvLyAkRmxvd0ZpeE1lW3Vuc2FmZS1hZGRpdGlvbl0gYWRkaXRpb24gd2l0aCBwb3NzaWJsZSBudWxsL3VuZGVmaW5lZCB2YWx1ZVxuICAgICAgICBhY3R1YWxEdXJhdGlvbiArPSBjaGlsZC5hY3R1YWxEdXJhdGlvbjtcbiAgICAgICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBpbmNvbXBsZXRlV29yay5hY3R1YWxEdXJhdGlvbiA9IGFjdHVhbER1cmF0aW9uO1xuICAgIH0gLy8gVE9ETzogT25jZSB3ZSBzdG9wIHByZXJlbmRlcmluZyBzaWJsaW5ncywgaW5zdGVhZCBvZiByZXNldHRpbmcgdGhlIHBhcmVudFxuICAgIC8vIG9mIHRoZSBub2RlIGJlaW5nIHVud291bmQsIHdlIHNob3VsZCBiZSBhYmxlIHRvIHJlc2V0IG5vZGUgaXRzZWxmIGFzIHdlXG4gICAgLy8gdW53aW5kIHRoZSBzdGFjay4gU2F2ZXMgYW4gYWRkaXRpb25hbCBudWxsIGNoZWNrLlxuXG5cbiAgICB2YXIgcmV0dXJuRmliZXIgPSBpbmNvbXBsZXRlV29yay5yZXR1cm47XG5cbiAgICBpZiAocmV0dXJuRmliZXIgIT09IG51bGwpIHtcbiAgICAgIC8vIE1hcmsgdGhlIHBhcmVudCBmaWJlciBhcyBpbmNvbXBsZXRlIGFuZCBjbGVhciBpdHMgc3VidHJlZSBmbGFncy5cbiAgICAgIC8vIFRPRE86IE9uY2Ugd2Ugc3RvcCBwcmVyZW5kZXJpbmcgc2libGluZ3MsIHdlIG1heSBiZSBhYmxlIHRvIGdldCByaWQgb2ZcbiAgICAgIC8vIHRoZSBJbmNvbXBsZXRlIGZsYWcgYmVjYXVzZSB1bndpbmRpbmcgdG8gdGhlIG5lYXJlc3QgYm91bmRhcnkgd2lsbFxuICAgICAgLy8gaGFwcGVuIHN5bmNocm9ub3VzbHkuXG4gICAgICByZXR1cm5GaWJlci5mbGFncyB8PSBJbmNvbXBsZXRlO1xuICAgICAgcmV0dXJuRmliZXIuc3VidHJlZUZsYWdzID0gTm9GbGFncyQxO1xuICAgICAgcmV0dXJuRmliZXIuZGVsZXRpb25zID0gbnVsbDtcbiAgICB9IC8vIE5PVEU6IElmIHdlIHJlLWVuYWJsZSBzaWJsaW5nIHByZXJlbmRlcmluZyBpbiBzb21lIGNhc2VzLCBoZXJlIHdlXG4gICAgLy8gd291bGQgc3dpdGNoIHRvIHRoZSBub3JtYWwgY29tcGxldGlvbiBwYXRoOiBjaGVjayBpZiBhIHNpYmxpbmdcbiAgICAvLyBleGlzdHMsIGFuZCBpZiBzbywgYmVnaW4gd29yayBvbiBpdC5cbiAgICAvLyBPdGhlcndpc2UsIHJldHVybiB0byB0aGUgcGFyZW50XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdHlwZV0gd2UgYmFpbCBvdXQgd2hlbiB3ZSBnZXQgYSBudWxsXG5cblxuICAgIGluY29tcGxldGVXb3JrID0gcmV0dXJuRmliZXI7IC8vIFVwZGF0ZSB0aGUgbmV4dCB0aGluZyB3ZSdyZSB3b3JraW5nIG9uIGluIGNhc2Ugc29tZXRoaW5nIHRocm93cy5cblxuICAgIHdvcmtJblByb2dyZXNzID0gaW5jb21wbGV0ZVdvcms7XG4gIH0gd2hpbGUgKGluY29tcGxldGVXb3JrICE9PSBudWxsKTsgLy8gV2UndmUgdW53b3VuZCBhbGwgdGhlIHdheSB0byB0aGUgcm9vdC5cblxuXG4gIHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPSBSb290RGlkTm90Q29tcGxldGU7XG4gIHdvcmtJblByb2dyZXNzID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tbWl0Um9vdChyb290LCByZWNvdmVyYWJsZUVycm9ycywgdHJhbnNpdGlvbnMsIGRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSwgc3Bhd25lZExhbmUpIHtcbiAgLy8gVE9ETzogVGhpcyBubyBsb25nZXIgbWFrZXMgYW55IHNlbnNlLiBXZSBhbHJlYWR5IHdyYXAgdGhlIG11dGF0aW9uIGFuZFxuICAvLyBsYXlvdXQgcGhhc2VzLiBTaG91bGQgYmUgYWJsZSB0byByZW1vdmUuXG4gIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQ7XG4gIHZhciBwcmV2aW91c1VwZGF0ZUxhbmVQcmlvcml0eSA9IGdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSgpO1xuXG4gIHRyeSB7XG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KERpc2NyZXRlRXZlbnRQcmlvcml0eSk7XG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGw7XG4gICAgY29tbWl0Um9vdEltcGwocm9vdCwgcmVjb3ZlcmFibGVFcnJvcnMsIHRyYW5zaXRpb25zLCBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUsIHByZXZpb3VzVXBkYXRlTGFuZVByaW9yaXR5LCBzcGF3bmVkTGFuZSk7XG4gIH0gZmluYWxseSB7XG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZUcmFuc2l0aW9uO1xuICAgIHNldEN1cnJlbnRVcGRhdGVQcmlvcml0eShwcmV2aW91c1VwZGF0ZUxhbmVQcmlvcml0eSk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gY29tbWl0Um9vdEltcGwocm9vdCwgcmVjb3ZlcmFibGVFcnJvcnMsIHRyYW5zaXRpb25zLCBkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUsIHJlbmRlclByaW9yaXR5TGV2ZWwsIHNwYXduZWRMYW5lKSB7XG4gIGRvIHtcbiAgICAvLyBgZmx1c2hQYXNzaXZlRWZmZWN0c2Agd2lsbCBjYWxsIGBmbHVzaFN5bmNVcGRhdGVRdWV1ZWAgYXQgdGhlIGVuZCwgd2hpY2hcbiAgICAvLyBtZWFucyBgZmx1c2hQYXNzaXZlRWZmZWN0c2Agd2lsbCBzb21ldGltZXMgcmVzdWx0IGluIGFkZGl0aW9uYWxcbiAgICAvLyBwYXNzaXZlIGVmZmVjdHMuIFNvIHdlIG5lZWQgdG8ga2VlcCBmbHVzaGluZyBpbiBhIGxvb3AgdW50aWwgdGhlcmUgYXJlXG4gICAgLy8gbm8gbW9yZSBwZW5kaW5nIGVmZmVjdHMuXG4gICAgLy8gVE9ETzogTWlnaHQgYmUgYmV0dGVyIGlmIGBmbHVzaFBhc3NpdmVFZmZlY3RzYCBkaWQgbm90IGF1dG9tYXRpY2FsbHlcbiAgICAvLyBmbHVzaCBzeW5jaHJvbm91cyB3b3JrIGF0IHRoZSBlbmQsIHRvIGF2b2lkIGZhY3RvcmluZyBoYXphcmRzIGxpa2UgdGhpcy5cbiAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gIH0gd2hpbGUgKHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzICE9PSBudWxsKTtcblxuICBmbHVzaFJlbmRlclBoYXNlU3RyaWN0TW9kZVdhcm5pbmdzSW5ERVYoKTtcblxuICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTaG91bGQgbm90IGFscmVhZHkgYmUgd29ya2luZy4nKTtcbiAgfVxuXG4gIHZhciBmaW5pc2hlZFdvcmsgPSByb290LmZpbmlzaGVkV29yaztcbiAgdmFyIGxhbmVzID0gcm9vdC5maW5pc2hlZExhbmVzO1xuXG4gIHtcbiAgICBtYXJrQ29tbWl0U3RhcnRlZChsYW5lcyk7XG4gIH1cblxuICBpZiAoZmluaXNoZWRXb3JrID09PSBudWxsKSB7XG5cbiAgICB7XG4gICAgICBtYXJrQ29tbWl0U3RvcHBlZCgpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2Uge1xuICAgIHtcbiAgICAgIGlmIChsYW5lcyA9PT0gTm9MYW5lcykge1xuICAgICAgICBlcnJvcigncm9vdC5maW5pc2hlZExhbmVzIHNob3VsZCBub3QgYmUgZW1wdHkgZHVyaW5nIGEgY29tbWl0LiBUaGlzIGlzIGEgJyArICdidWcgaW4gUmVhY3QuJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcm9vdC5maW5pc2hlZFdvcmsgPSBudWxsO1xuICByb290LmZpbmlzaGVkTGFuZXMgPSBOb0xhbmVzO1xuXG4gIGlmIChmaW5pc2hlZFdvcmsgPT09IHJvb3QuY3VycmVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGNvbW1pdCB0aGUgc2FtZSB0cmVlIGFzIGJlZm9yZS4gVGhpcyBlcnJvciBpcyBsaWtlbHkgY2F1c2VkIGJ5ICcgKyAnYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICB9IC8vIGNvbW1pdFJvb3QgbmV2ZXIgcmV0dXJucyBhIGNvbnRpbnVhdGlvbjsgaXQgYWx3YXlzIGZpbmlzaGVzIHN5bmNocm9ub3VzbHkuXG4gIC8vIFNvIHdlIGNhbiBjbGVhciB0aGVzZSBub3cgdG8gYWxsb3cgYSBuZXcgY2FsbGJhY2sgdG8gYmUgc2NoZWR1bGVkLlxuXG5cbiAgcm9vdC5jYWxsYmFja05vZGUgPSBudWxsO1xuICByb290LmNhbGxiYWNrUHJpb3JpdHkgPSBOb0xhbmU7XG4gIHJvb3QuY2FuY2VsUGVuZGluZ0NvbW1pdCA9IG51bGw7IC8vIENoZWNrIHdoaWNoIGxhbmVzIG5vIGxvbmdlciBoYXZlIGFueSB3b3JrIHNjaGVkdWxlZCBvbiB0aGVtLCBhbmQgbWFya1xuICAvLyB0aG9zZSBhcyBmaW5pc2hlZC5cblxuICB2YXIgcmVtYWluaW5nTGFuZXMgPSBtZXJnZUxhbmVzKGZpbmlzaGVkV29yay5sYW5lcywgZmluaXNoZWRXb3JrLmNoaWxkTGFuZXMpOyAvLyBNYWtlIHN1cmUgdG8gYWNjb3VudCBmb3IgbGFuZXMgdGhhdCB3ZXJlIHVwZGF0ZWQgYnkgYSBjb25jdXJyZW50IGV2ZW50XG4gIC8vIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlOyBkb24ndCBtYXJrIHRoZW0gYXMgZmluaXNoZWQuXG5cbiAgdmFyIGNvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcyA9IGdldENvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcygpO1xuICByZW1haW5pbmdMYW5lcyA9IG1lcmdlTGFuZXMocmVtYWluaW5nTGFuZXMsIGNvbmN1cnJlbnRseVVwZGF0ZWRMYW5lcyk7XG4gIG1hcmtSb290RmluaXNoZWQocm9vdCwgcmVtYWluaW5nTGFuZXMsIHNwYXduZWRMYW5lKTsgLy8gUmVzZXQgdGhpcyBiZWZvcmUgZmlyaW5nIHNpZGUgZWZmZWN0cyBzbyB3ZSBjYW4gZGV0ZWN0IHJlY3Vyc2l2ZSB1cGRhdGVzLlxuXG4gIGRpZEluY2x1ZGVDb21taXRQaGFzZVVwZGF0ZSA9IGZhbHNlO1xuXG4gIGlmIChyb290ID09PSB3b3JrSW5Qcm9ncmVzc1Jvb3QpIHtcbiAgICAvLyBXZSBjYW4gcmVzZXQgdGhlc2Ugbm93IHRoYXQgdGhleSBhcmUgZmluaXNoZWQuXG4gICAgd29ya0luUHJvZ3Jlc3NSb290ID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcyA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMgPSBOb0xhbmVzO1xuICB9IC8vIElmIHRoZXJlIGFyZSBwZW5kaW5nIHBhc3NpdmUgZWZmZWN0cywgc2NoZWR1bGUgYSBjYWxsYmFjayB0byBwcm9jZXNzIHRoZW0uXG4gIC8vIERvIHRoaXMgYXMgZWFybHkgYXMgcG9zc2libGUsIHNvIGl0IGlzIHF1ZXVlZCBiZWZvcmUgYW55dGhpbmcgZWxzZSB0aGF0XG4gIC8vIG1pZ2h0IGdldCBzY2hlZHVsZWQgaW4gdGhlIGNvbW1pdCBwaGFzZS4gKFNlZSAjMTY3MTQuKVxuICAvLyBUT0RPOiBEZWxldGUgYWxsIG90aGVyIHBsYWNlcyB0aGF0IHNjaGVkdWxlIHRoZSBwYXNzaXZlIGVmZmVjdCBjYWxsYmFja1xuICAvLyBUaGV5J3JlIHJlZHVuZGFudC5cblxuXG4gIGlmICgoZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIFBhc3NpdmVNYXNrKSAhPT0gTm9GbGFncyQxIHx8IChmaW5pc2hlZFdvcmsuZmxhZ3MgJiBQYXNzaXZlTWFzaykgIT09IE5vRmxhZ3MkMSkge1xuICAgIGlmICghcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAgIHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzID0gdHJ1ZTtcbiAgICAgIHBlbmRpbmdQYXNzaXZlRWZmZWN0c1JlbWFpbmluZ0xhbmVzID0gcmVtYWluaW5nTGFuZXM7IC8vIHdvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMgbWlnaHQgYmUgb3ZlcndyaXR0ZW4sIHNvIHdlIHdhbnRcbiAgICAgIC8vIHRvIHN0b3JlIGl0IGluIHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMgdW50aWwgdGhleSBnZXQgcHJvY2Vzc2VkXG4gICAgICAvLyBXZSBuZWVkIHRvIHBhc3MgdGhpcyB0aHJvdWdoIGFzIGFuIGFyZ3VtZW50IHRvIGNvbW1pdFJvb3RcbiAgICAgIC8vIGJlY2F1c2Ugd29ya0luUHJvZ3Jlc3NUcmFuc2l0aW9ucyBtaWdodCBoYXZlIGNoYW5nZWQgYmV0d2VlblxuICAgICAgLy8gdGhlIHByZXZpb3VzIHJlbmRlciBhbmQgY29tbWl0IGlmIHdlIHRocm90dGxlIHRoZSBjb21taXRcbiAgICAgIC8vIHdpdGggc2V0VGltZW91dFxuXG4gICAgICBwZW5kaW5nUGFzc2l2ZVRyYW5zaXRpb25zID0gdHJhbnNpdGlvbnM7XG4gICAgICBzY2hlZHVsZUNhbGxiYWNrKE5vcm1hbFByaW9yaXR5JDEsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZmx1c2hQYXNzaXZlRWZmZWN0cygpOyAvLyBUaGlzIHJlbmRlciB0cmlnZ2VyZWQgcGFzc2l2ZSBlZmZlY3RzOiByZWxlYXNlIHRoZSByb290IGNhY2hlIHBvb2xcbiAgICAgICAgLy8gKmFmdGVyKiBwYXNzaXZlIGVmZmVjdHMgZmlyZSB0byBhdm9pZCBmcmVlaW5nIGEgY2FjaGUgcG9vbCB0aGF0IG1heVxuICAgICAgICAvLyBiZSByZWZlcmVuY2VkIGJ5IGEgbm9kZSBpbiB0aGUgdHJlZSAoSG9zdFJvb3QsIENhY2hlIGJvdW5kYXJ5IGV0YylcblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0pO1xuICAgIH1cbiAgfSAvLyBDaGVjayBpZiB0aGVyZSBhcmUgYW55IGVmZmVjdHMgaW4gdGhlIHdob2xlIHRyZWUuXG4gIC8vIFRPRE86IFRoaXMgaXMgbGVmdCBvdmVyIGZyb20gdGhlIGVmZmVjdCBsaXN0IGltcGxlbWVudGF0aW9uLCB3aGVyZSB3ZSBoYWRcbiAgLy8gdG8gY2hlY2sgZm9yIHRoZSBleGlzdGVuY2Ugb2YgYGZpcnN0RWZmZWN0YCB0byBzYXRpc2Z5IEZsb3cuIEkgdGhpbmsgdGhlXG4gIC8vIG9ubHkgb3RoZXIgcmVhc29uIHRoaXMgb3B0aW1pemF0aW9uIGV4aXN0cyBpcyBiZWNhdXNlIGl0IGFmZmVjdHMgcHJvZmlsaW5nLlxuICAvLyBSZWNvbnNpZGVyIHdoZXRoZXIgdGhpcyBpcyBuZWNlc3NhcnkuXG5cblxuICB2YXIgc3VidHJlZUhhc0VmZmVjdHMgPSAoZmluaXNoZWRXb3JrLnN1YnRyZWVGbGFncyAmIChCZWZvcmVNdXRhdGlvbk1hc2sgfCBNdXRhdGlvbk1hc2sgfCBMYXlvdXRNYXNrIHwgUGFzc2l2ZU1hc2spKSAhPT0gTm9GbGFncyQxO1xuICB2YXIgcm9vdEhhc0VmZmVjdCA9IChmaW5pc2hlZFdvcmsuZmxhZ3MgJiAoQmVmb3JlTXV0YXRpb25NYXNrIHwgTXV0YXRpb25NYXNrIHwgTGF5b3V0TWFzayB8IFBhc3NpdmVNYXNrKSkgIT09IE5vRmxhZ3MkMTtcblxuICBpZiAoc3VidHJlZUhhc0VmZmVjdHMgfHwgcm9vdEhhc0VmZmVjdCkge1xuICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQ7XG4gICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcbiAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoRGlzY3JldGVFdmVudFByaW9yaXR5KTtcbiAgICB2YXIgcHJldkV4ZWN1dGlvbkNvbnRleHQgPSBleGVjdXRpb25Db250ZXh0O1xuICAgIGV4ZWN1dGlvbkNvbnRleHQgfD0gQ29tbWl0Q29udGV4dDsgLy8gVGhlIGNvbW1pdCBwaGFzZSBpcyBicm9rZW4gaW50byBzZXZlcmFsIHN1Yi1waGFzZXMuIFdlIGRvIGEgc2VwYXJhdGUgcGFzc1xuICAgIC8vIG9mIHRoZSBlZmZlY3QgbGlzdCBmb3IgZWFjaCBwaGFzZTogYWxsIG11dGF0aW9uIGVmZmVjdHMgY29tZSBiZWZvcmUgYWxsXG4gICAgLy8gbGF5b3V0IGVmZmVjdHMsIGFuZCBzbyBvbi5cbiAgICAvLyBUaGUgZmlyc3QgcGhhc2UgYSBcImJlZm9yZSBtdXRhdGlvblwiIHBoYXNlLiBXZSB1c2UgdGhpcyBwaGFzZSB0byByZWFkIHRoZVxuICAgIC8vIHN0YXRlIG9mIHRoZSBob3N0IHRyZWUgcmlnaHQgYmVmb3JlIHdlIG11dGF0ZSBpdC4gVGhpcyBpcyB3aGVyZVxuICAgIC8vIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlIGlzIGNhbGxlZC5cblxuICAgIGNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmspO1xuXG4gICAge1xuICAgICAgLy8gTWFyayB0aGUgY3VycmVudCBjb21taXQgdGltZSB0byBiZSBzaGFyZWQgYnkgYWxsIFByb2ZpbGVycyBpbiB0aGlzXG4gICAgICAvLyBiYXRjaC4gVGhpcyBlbmFibGVzIHRoZW0gdG8gYmUgZ3JvdXBlZCBsYXRlci5cbiAgICAgIHJlY29yZENvbW1pdFRpbWUoKTtcbiAgICB9IC8vIFRoZSBuZXh0IHBoYXNlIGlzIHRoZSBtdXRhdGlvbiBwaGFzZSwgd2hlcmUgd2UgbXV0YXRlIHRoZSBob3N0IHRyZWUuXG5cblxuICAgIGNvbW1pdE11dGF0aW9uRWZmZWN0cyhyb290LCBmaW5pc2hlZFdvcmssIGxhbmVzKTtcblxuICAgIHJlc2V0QWZ0ZXJDb21taXQocm9vdC5jb250YWluZXJJbmZvKTsgLy8gVGhlIHdvcmstaW4tcHJvZ3Jlc3MgdHJlZSBpcyBub3cgdGhlIGN1cnJlbnQgdHJlZS4gVGhpcyBtdXN0IGNvbWUgYWZ0ZXJcbiAgICAvLyB0aGUgbXV0YXRpb24gcGhhc2UsIHNvIHRoYXQgdGhlIHByZXZpb3VzIHRyZWUgaXMgc3RpbGwgY3VycmVudCBkdXJpbmdcbiAgICAvLyBjb21wb25lbnRXaWxsVW5tb3VudCwgYnV0IGJlZm9yZSB0aGUgbGF5b3V0IHBoYXNlLCBzbyB0aGF0IHRoZSBmaW5pc2hlZFxuICAgIC8vIHdvcmsgaXMgY3VycmVudCBkdXJpbmcgY29tcG9uZW50RGlkTW91bnQvVXBkYXRlLlxuXG4gICAgcm9vdC5jdXJyZW50ID0gZmluaXNoZWRXb3JrOyAvLyBUaGUgbmV4dCBwaGFzZSBpcyB0aGUgbGF5b3V0IHBoYXNlLCB3aGVyZSB3ZSBjYWxsIGVmZmVjdHMgdGhhdCByZWFkXG5cbiAgICB7XG4gICAgICBtYXJrTGF5b3V0RWZmZWN0c1N0YXJ0ZWQobGFuZXMpO1xuICAgIH1cblxuICAgIGNvbW1pdExheW91dEVmZmVjdHMoZmluaXNoZWRXb3JrLCByb290LCBsYW5lcyk7XG5cbiAgICB7XG4gICAgICBtYXJrTGF5b3V0RWZmZWN0c1N0b3BwZWQoKTtcbiAgICB9IC8vIFRlbGwgU2NoZWR1bGVyIHRvIHlpZWxkIGF0IHRoZSBlbmQgb2YgdGhlIGZyYW1lLCBzbyB0aGUgYnJvd3NlciBoYXMgYW5cbiAgICAvLyBvcHBvcnR1bml0eSB0byBwYWludC5cblxuXG4gICAgcmVxdWVzdFBhaW50KCk7XG4gICAgZXhlY3V0aW9uQ29udGV4dCA9IHByZXZFeGVjdXRpb25Db250ZXh0OyAvLyBSZXNldCB0aGUgcHJpb3JpdHkgdG8gdGhlIHByZXZpb3VzIG5vbi1zeW5jIHZhbHVlLlxuXG4gICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1xuICAgIFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQgPSBwcmV2VHJhbnNpdGlvbjtcbiAgfSBlbHNlIHtcbiAgICAvLyBObyBlZmZlY3RzLlxuICAgIHJvb3QuY3VycmVudCA9IGZpbmlzaGVkV29yazsgLy8gTWVhc3VyZSB0aGVzZSBhbnl3YXkgc28gdGhlIGZsYW1lZ3JhcGggZXhwbGljaXRseSBzaG93cyB0aGF0IHRoZXJlIHdlcmVcbiAgICAvLyBubyBlZmZlY3RzLlxuICAgIC8vIFRPRE86IE1heWJlIHRoZXJlJ3MgYSBiZXR0ZXIgd2F5IHRvIHJlcG9ydCB0aGlzLlxuXG4gICAge1xuICAgICAgcmVjb3JkQ29tbWl0VGltZSgpO1xuICAgIH1cbiAgfVxuXG4gIHZhciByb290RGlkSGF2ZVBhc3NpdmVFZmZlY3RzID0gcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHM7XG5cbiAgaWYgKHJvb3REb2VzSGF2ZVBhc3NpdmVFZmZlY3RzKSB7XG4gICAgLy8gVGhpcyBjb21taXQgaGFzIHBhc3NpdmUgZWZmZWN0cy4gU3Rhc2ggYSByZWZlcmVuY2UgdG8gdGhlbS4gQnV0IGRvbid0XG4gICAgLy8gc2NoZWR1bGUgYSBjYWxsYmFjayB1bnRpbCBhZnRlciBmbHVzaGluZyBsYXlvdXQgd29yay5cbiAgICByb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xuICAgIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzID0gcm9vdDtcbiAgICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcyA9IGxhbmVzO1xuICB9IGVsc2Uge1xuICAgIC8vIFRoZXJlIHdlcmUgbm8gcGFzc2l2ZSBlZmZlY3RzLCBzbyB3ZSBjYW4gaW1tZWRpYXRlbHkgcmVsZWFzZSB0aGUgY2FjaGVcbiAgICAvLyBwb29sIGZvciB0aGlzIHJlbmRlci5cbiAgICByZWxlYXNlUm9vdFBvb2xlZENhY2hlKHJvb3QsIHJlbWFpbmluZ0xhbmVzKTtcblxuICAgIHtcbiAgICAgIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDA7XG4gICAgICByb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzID0gbnVsbDtcbiAgICB9XG4gIH0gLy8gUmVhZCB0aGlzIGFnYWluLCBzaW5jZSBhbiBlZmZlY3QgbWlnaHQgaGF2ZSB1cGRhdGVkIGl0XG5cblxuICByZW1haW5pbmdMYW5lcyA9IHJvb3QucGVuZGluZ0xhbmVzOyAvLyBDaGVjayBpZiB0aGVyZSdzIHJlbWFpbmluZyB3b3JrIG9uIHRoaXMgcm9vdFxuICAvLyBUT0RPOiBUaGlzIGlzIHBhcnQgb2YgdGhlIGBjb21wb25lbnREaWRDYXRjaGAgaW1wbGVtZW50YXRpb24uIEl0cyBwdXJwb3NlXG4gIC8vIGlzIHRvIGRldGVjdCB3aGV0aGVyIHNvbWV0aGluZyBtaWdodCBoYXZlIGNhbGxlZCBzZXRTdGF0ZSBpbnNpZGVcbiAgLy8gYGNvbXBvbmVudERpZENhdGNoYC4gVGhlIG1lY2hhbmlzbSBpcyBrbm93biB0byBiZSBmbGF3ZWQgYmVjYXVzZSBgc2V0U3RhdGVgXG4gIC8vIGluc2lkZSBgY29tcG9uZW50RGlkQ2F0Y2hgIGlzIGl0c2VsZiBmbGF3ZWQg4oCUIHRoYXQncyB3aHkgd2UgcmVjb21tZW5kXG4gIC8vIGBnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3JgIGluc3RlYWQuIEhvd2V2ZXIsIGl0IGNvdWxkIGJlIGltcHJvdmVkIGJ5XG4gIC8vIGNoZWNraW5nIGlmIHJlbWFpbmluZ0xhbmVzIGluY2x1ZGVzIFN5bmMgd29yaywgaW5zdGVhZCBvZiB3aGV0aGVyIHRoZXJlJ3NcbiAgLy8gYW55IHdvcmsgcmVtYWluaW5nIGF0IGFsbCAod2hpY2ggd291bGQgYWxzbyBpbmNsdWRlIHN0dWZmIGxpa2UgU3VzcGVuc2VcbiAgLy8gcmV0cmllcyBvciB0cmFuc2l0aW9ucykuIEl0J3MgYmVlbiBsaWtlIHRoaXMgZm9yIGEgd2hpbGUsIHRob3VnaCwgc28gZml4aW5nXG4gIC8vIGl0IHByb2JhYmx5IGlzbid0IHRoYXQgdXJnZW50LlxuXG4gIGlmIChyZW1haW5pbmdMYW5lcyA9PT0gTm9MYW5lcykge1xuICAgIC8vIElmIHRoZXJlJ3Mgbm8gcmVtYWluaW5nIHdvcmssIHdlIGNhbiBjbGVhciB0aGUgc2V0IG9mIGFscmVhZHkgZmFpbGVkXG4gICAgLy8gZXJyb3IgYm91bmRhcmllcy5cbiAgICBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG51bGw7XG4gIH1cblxuICB7XG4gICAgaWYgKCFyb290RGlkSGF2ZVBhc3NpdmVFZmZlY3RzKSB7XG4gICAgICBjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocm9vdCk7XG4gICAgfVxuICB9XG5cbiAgb25Db21taXRSb290JDEoZmluaXNoZWRXb3JrLnN0YXRlTm9kZSwgcmVuZGVyUHJpb3JpdHlMZXZlbCk7XG5cbiAge1xuICAgIGlmIChpc0RldlRvb2xzUHJlc2VudCkge1xuICAgICAgcm9vdC5tZW1vaXplZFVwZGF0ZXJzLmNsZWFyKCk7XG4gICAgfVxuICB9XG5cbiAge1xuICAgIG9uQ29tbWl0Um9vdCgpO1xuICB9IC8vIEFsd2F5cyBjYWxsIHRoaXMgYmVmb3JlIGV4aXRpbmcgYGNvbW1pdFJvb3RgLCB0byBlbnN1cmUgdGhhdCBhbnlcbiAgLy8gYWRkaXRpb25hbCB3b3JrIG9uIHRoaXMgcm9vdCBpcyBzY2hlZHVsZWQuXG5cblxuICBlbnN1cmVSb290SXNTY2hlZHVsZWQocm9vdCk7XG5cbiAgaWYgKHJlY292ZXJhYmxlRXJyb3JzICE9PSBudWxsKSB7XG4gICAgLy8gVGhlcmUgd2VyZSBlcnJvcnMgZHVyaW5nIHRoaXMgcmVuZGVyLCBidXQgcmVjb3ZlcmVkIGZyb20gdGhlbSB3aXRob3V0XG4gICAgLy8gbmVlZGluZyB0byBzdXJmYWNlIGl0IHRvIHRoZSBVSS4gV2UgbG9nIHRoZW0gaGVyZS5cbiAgICB2YXIgb25SZWNvdmVyYWJsZUVycm9yID0gcm9vdC5vblJlY292ZXJhYmxlRXJyb3I7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlY292ZXJhYmxlRXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcmVjb3ZlcmFibGVFcnJvciA9IHJlY292ZXJhYmxlRXJyb3JzW2ldO1xuICAgICAgdmFyIGVycm9ySW5mbyA9IG1ha2VFcnJvckluZm8ocmVjb3ZlcmFibGVFcnJvci5zdGFjayk7XG4gICAgICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKHJlY292ZXJhYmxlRXJyb3Iuc291cmNlKTtcbiAgICAgIG9uUmVjb3ZlcmFibGVFcnJvcihyZWNvdmVyYWJsZUVycm9yLnZhbHVlLCBlcnJvckluZm8pO1xuICAgICAgcmVzZXRDdXJyZW50RGVidWdGaWJlckluREVWKCk7XG4gICAgfVxuICB9IC8vIElmIHRoZSBwYXNzaXZlIGVmZmVjdHMgYXJlIHRoZSByZXN1bHQgb2YgYSBkaXNjcmV0ZSByZW5kZXIsIGZsdXNoIHRoZW1cbiAgLy8gc3luY2hyb25vdXNseSBhdCB0aGUgZW5kIG9mIHRoZSBjdXJyZW50IHRhc2sgc28gdGhhdCB0aGUgcmVzdWx0IGlzXG4gIC8vIGltbWVkaWF0ZWx5IG9ic2VydmFibGUuIE90aGVyd2lzZSwgd2UgYXNzdW1lIHRoYXQgdGhleSBhcmUgbm90XG4gIC8vIG9yZGVyLWRlcGVuZGVudCBhbmQgZG8gbm90IG5lZWQgdG8gYmUgb2JzZXJ2ZWQgYnkgZXh0ZXJuYWwgc3lzdGVtcywgc28gd2VcbiAgLy8gY2FuIHdhaXQgdW50aWwgYWZ0ZXIgcGFpbnQuXG4gIC8vIFRPRE86IFdlIGNhbiBvcHRpbWl6ZSB0aGlzIGJ5IG5vdCBzY2hlZHVsaW5nIHRoZSBjYWxsYmFjayBlYXJsaWVyLiBTaW5jZSB3ZVxuICAvLyBjdXJyZW50bHkgc2NoZWR1bGUgdGhlIGNhbGxiYWNrIGluIG11bHRpcGxlIHBsYWNlcywgd2lsbCB3YWl0IHVudGlsIHRob3NlXG4gIC8vIGFyZSBjb25zb2xpZGF0ZWQuXG5cblxuICBpZiAoaW5jbHVkZXNTeW5jTGFuZShwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcykgJiYgKGRpc2FibGVMZWdhY3lNb2RlICkpIHtcbiAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gIH0gLy8gUmVhZCB0aGlzIGFnYWluLCBzaW5jZSBhIHBhc3NpdmUgZWZmZWN0IG1pZ2h0IGhhdmUgdXBkYXRlZCBpdFxuXG5cbiAgcmVtYWluaW5nTGFuZXMgPSByb290LnBlbmRpbmdMYW5lczsgLy8gQ2hlY2sgaWYgdGhpcyByZW5kZXIgc2NoZWR1bGVkIGEgY2FzY2FkaW5nIHN5bmNocm9ub3VzIHVwZGF0ZS4gVGhpcyBpcyBhXG4gIC8vIGhldXJzdGljIHRvIGRldGVjdCBpbmZpbml0ZSB1cGRhdGUgbG9vcHMuIFdlIGFyZSBpbnRlbnRpb25hbGx5IGV4Y2x1ZGluZ1xuICAvLyBoeWRyYXRpb24gbGFuZXMgaW4gdGhpcyBjaGVjaywgYmVjYXVzZSByZW5kZXIgdHJpZ2dlcmVkIGJ5IHNlbGVjdGl2ZVxuICAvLyBoeWRyYXRpb24gaXMgY29uY2VwdHVhbGx5IG5vdCBhbiB1cGRhdGUuXG5cbiAgaWYgKCAvLyBDaGVjayBpZiB0aGVyZSB3YXMgYSByZWN1cnNpdmUgdXBkYXRlIHNwYXduZWQgYnkgdGhpcyByZW5kZXIsIGluIGVpdGhlclxuICAvLyB0aGUgcmVuZGVyIHBoYXNlIG9yIHRoZSBjb21taXQgcGhhc2UuIFdlIHRyYWNrIHRoZXNlIGV4cGxpY2l0bHkgYmVjYXVzZVxuICAvLyB3ZSBjYW4ndCBpbmZlciBmcm9tIHRoZSByZW1haW5pbmcgbGFuZXMgYWxvbmUuXG4gIChkaWRJbmNsdWRlUmVuZGVyUGhhc2VVcGRhdGUgfHwgZGlkSW5jbHVkZUNvbW1pdFBoYXNlVXBkYXRlKSB8fCAvLyBXYXMgdGhlIGZpbmlzaGVkIHJlbmRlciB0aGUgcmVzdWx0IG9mIGFuIHVwZGF0ZSAobm90IGh5ZHJhdGlvbik/XG4gIGluY2x1ZGVzU29tZUxhbmUobGFuZXMsIFVwZGF0ZUxhbmVzKSAmJiAvLyBEaWQgaXQgc2NoZWR1bGUgYSBzeW5jIHVwZGF0ZT9cbiAgaW5jbHVkZXNTb21lTGFuZShyZW1haW5pbmdMYW5lcywgU3luY1VwZGF0ZUxhbmVzKSkge1xuICAgIHtcbiAgICAgIG1hcmtOZXN0ZWRVcGRhdGVTY2hlZHVsZWQoKTtcbiAgICB9IC8vIENvdW50IHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIHJvb3Qgc3luY2hyb25vdXNseSByZS1yZW5kZXJzIHdpdGhvdXRcbiAgICAvLyBmaW5pc2hpbmcuIElmIHRoZXJlIGFyZSB0b28gbWFueSwgaXQgaW5kaWNhdGVzIGFuIGluZmluaXRlIHVwZGF0ZSBsb29wLlxuXG5cbiAgICBpZiAocm9vdCA9PT0gcm9vdFdpdGhOZXN0ZWRVcGRhdGVzKSB7XG4gICAgICBuZXN0ZWRVcGRhdGVDb3VudCsrO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG4gICAgICByb290V2l0aE5lc3RlZFVwZGF0ZXMgPSByb290O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG4gIH0gLy8gSWYgbGF5b3V0IHdvcmsgd2FzIHNjaGVkdWxlZCwgZmx1c2ggaXQgbm93LlxuXG5cbiAgZmx1c2hTeW5jV29ya09uQWxsUm9vdHMoKTtcblxuICB7XG4gICAgbWFya0NvbW1pdFN0b3BwZWQoKTtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBtYWtlRXJyb3JJbmZvKGNvbXBvbmVudFN0YWNrKSB7XG4gIHZhciBlcnJvckluZm8gPSB7XG4gICAgY29tcG9uZW50U3RhY2s6IGNvbXBvbmVudFN0YWNrXG4gIH07XG5cbiAge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvckluZm8sICdkaWdlc3QnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZXJyb3IoJ1lvdSBhcmUgYWNjZXNzaW5nIFwiZGlnZXN0XCIgZnJvbSB0aGUgZXJyb3JJbmZvIG9iamVjdCBwYXNzZWQgdG8gb25SZWNvdmVyYWJsZUVycm9yLicgKyAnIFRoaXMgcHJvcGVydHkgaXMgbm8gbG9uZ2VyIHByb3ZpZGVkIGFzIHBhcnQgb2YgZXJyb3JJbmZvIGJ1dCBjYW4gYmUgYWNjZXNzZWQgYXMgYSBwcm9wZXJ0eScgKyAnIG9mIHRoZSBFcnJvciBpbnN0YW5jZSBpdHNlbGYuJyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gZXJyb3JJbmZvO1xufVxuXG5mdW5jdGlvbiByZWxlYXNlUm9vdFBvb2xlZENhY2hlKHJvb3QsIHJlbWFpbmluZ0xhbmVzKSB7XG4gIHtcbiAgICB2YXIgcG9vbGVkQ2FjaGVMYW5lcyA9IHJvb3QucG9vbGVkQ2FjaGVMYW5lcyAmPSByZW1haW5pbmdMYW5lcztcblxuICAgIGlmIChwb29sZWRDYWNoZUxhbmVzID09PSBOb0xhbmVzKSB7XG4gICAgICAvLyBOb25lIG9mIHRoZSByZW1haW5pbmcgd29yayByZWxpZXMgb24gdGhlIGNhY2hlIHBvb2wuIENsZWFyIGl0IHNvXG4gICAgICAvLyBzdWJzZXF1ZW50IHJlcXVlc3RzIGdldCBhIG5ldyBjYWNoZVxuICAgICAgdmFyIHBvb2xlZENhY2hlID0gcm9vdC5wb29sZWRDYWNoZTtcblxuICAgICAgaWYgKHBvb2xlZENhY2hlICE9IG51bGwpIHtcbiAgICAgICAgcm9vdC5wb29sZWRDYWNoZSA9IG51bGw7XG4gICAgICAgIHJlbGVhc2VDYWNoZShwb29sZWRDYWNoZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKSB7XG4gIC8vIFJldHVybnMgd2hldGhlciBwYXNzaXZlIGVmZmVjdHMgd2VyZSBmbHVzaGVkLlxuICAvLyBUT0RPOiBDb21iaW5lIHRoaXMgY2hlY2sgd2l0aCB0aGUgb25lIGluIGZsdXNoUGFzc2l2ZUVGZmVjdHNJbXBsLiBXZSBzaG91bGRcbiAgLy8gcHJvYmFibHkganVzdCBjb21iaW5lIHRoZSB0d28gZnVuY3Rpb25zLiBJIGJlbGlldmUgdGhleSB3ZXJlIG9ubHkgc2VwYXJhdGVcbiAgLy8gaW4gdGhlIGZpcnN0IHBsYWNlIGJlY2F1c2Ugd2UgdXNlZCB0byB3cmFwIGl0IHdpdGhcbiAgLy8gYFNjaGVkdWxlci5ydW5XaXRoUHJpb3JpdHlgLCB3aGljaCBhY2NlcHRzIGEgZnVuY3Rpb24uIEJ1dCBub3cgd2UgdHJhY2sgdGhlXG4gIC8vIHByaW9yaXR5IHdpdGhpbiBSZWFjdCBpdHNlbGYsIHNvIHdlIGNhbiBtdXRhdGUgdGhlIHZhcmlhYmxlIGRpcmVjdGx5LlxuICBpZiAocm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgIT09IG51bGwpIHtcbiAgICAvLyBDYWNoZSB0aGUgcm9vdCBzaW5jZSByb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyBpcyBjbGVhcmVkIGluXG4gICAgLy8gZmx1c2hQYXNzaXZlRWZmZWN0c0ltcGxcbiAgICB2YXIgcm9vdCA9IHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzOyAvLyBDYWNoZSBhbmQgY2xlYXIgdGhlIHJlbWFpbmluZyBsYW5lcyBmbGFnOyBpdCBtdXN0IGJlIHJlc2V0IHNpbmNlIHRoaXNcbiAgICAvLyBtZXRob2QgY2FuIGJlIGNhbGxlZCBmcm9tIHZhcmlvdXMgcGxhY2VzLCBub3QgYWx3YXlzIGZyb20gY29tbWl0Um9vdFxuICAgIC8vIHdoZXJlIHRoZSByZW1haW5pbmcgbGFuZXMgYXJlIGtub3duXG5cbiAgICB2YXIgcmVtYWluaW5nTGFuZXMgPSBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW1haW5pbmdMYW5lcztcbiAgICBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNSZW1haW5pbmdMYW5lcyA9IE5vTGFuZXM7XG4gICAgdmFyIHJlbmRlclByaW9yaXR5ID0gbGFuZXNUb0V2ZW50UHJpb3JpdHkocGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMpO1xuICAgIHZhciBwcmlvcml0eSA9IGxvd2VyRXZlbnRQcmlvcml0eShEZWZhdWx0RXZlbnRQcmlvcml0eSwgcmVuZGVyUHJpb3JpdHkpO1xuICAgIHZhciBwcmV2VHJhbnNpdGlvbiA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlQ7XG4gICAgdmFyIHByZXZpb3VzUHJpb3JpdHkgPSBnZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkoKTtcblxuICAgIHRyeSB7XG4gICAgICBzZXRDdXJyZW50VXBkYXRlUHJpb3JpdHkocHJpb3JpdHkpO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IG51bGw7XG4gICAgICByZXR1cm4gZmx1c2hQYXNzaXZlRWZmZWN0c0ltcGwoKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgc2V0Q3VycmVudFVwZGF0ZVByaW9yaXR5KHByZXZpb3VzUHJpb3JpdHkpO1xuICAgICAgUmVhY3RTaGFyZWRJbnRlcm5hbHMuVCA9IHByZXZUcmFuc2l0aW9uOyAvLyBPbmNlIHBhc3NpdmUgZWZmZWN0cyBoYXZlIHJ1biBmb3IgdGhlIHRyZWUgLSBnaXZpbmcgY29tcG9uZW50cyBhXG4gICAgICAvLyBjaGFuY2UgdG8gcmV0YWluIGNhY2hlIGluc3RhbmNlcyB0aGV5IHVzZSAtIHJlbGVhc2UgdGhlIHBvb2xlZFxuICAgICAgLy8gY2FjaGUgYXQgdGhlIHJvb3QgKGlmIHRoZXJlIGlzIG9uZSlcblxuICAgICAgcmVsZWFzZVJvb3RQb29sZWRDYWNoZShyb290LCByZW1haW5pbmdMYW5lcyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuZnVuY3Rpb24gZW5xdWV1ZVBlbmRpbmdQYXNzaXZlUHJvZmlsZXJFZmZlY3QoZmliZXIpIHtcbiAge1xuICAgIHBlbmRpbmdQYXNzaXZlUHJvZmlsZXJFZmZlY3RzLnB1c2goZmliZXIpO1xuXG4gICAgaWYgKCFyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cykge1xuICAgICAgcm9vdERvZXNIYXZlUGFzc2l2ZUVmZmVjdHMgPSB0cnVlO1xuICAgICAgc2NoZWR1bGVDYWxsYmFjayhOb3JtYWxQcmlvcml0eSQxLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZsdXNoUGFzc2l2ZUVmZmVjdHMoKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmx1c2hQYXNzaXZlRWZmZWN0c0ltcGwoKSB7XG4gIGlmIChyb290V2l0aFBlbmRpbmdQYXNzaXZlRWZmZWN0cyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBDYWNoZSBhbmQgY2xlYXIgdGhlIHRyYW5zaXRpb25zIGZsYWdcblxuXG4gIHZhciB0cmFuc2l0aW9ucyA9IHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnM7XG4gIHBlbmRpbmdQYXNzaXZlVHJhbnNpdGlvbnMgPSBudWxsO1xuICB2YXIgcm9vdCA9IHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzO1xuICB2YXIgbGFuZXMgPSBwZW5kaW5nUGFzc2l2ZUVmZmVjdHNMYW5lcztcbiAgcm9vdFdpdGhQZW5kaW5nUGFzc2l2ZUVmZmVjdHMgPSBudWxsOyAvLyBUT0RPOiBUaGlzIGlzIHNvbWV0aW1lcyBvdXQgb2Ygc3luYyB3aXRoIHJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzLlxuICAvLyBGaWd1cmUgb3V0IHdoeSBhbmQgZml4IGl0LiBJdCdzIG5vdCBjYXVzaW5nIGFueSBrbm93biBpc3N1ZXMgKHByb2JhYmx5XG4gIC8vIGJlY2F1c2UgaXQncyBvbmx5IHVzZWQgZm9yIHByb2ZpbGluZyksIGJ1dCBpdCdzIGEgcmVmYWN0b3IgaGF6YXJkLlxuXG4gIHBlbmRpbmdQYXNzaXZlRWZmZWN0c0xhbmVzID0gTm9MYW5lcztcblxuICBpZiAoKGV4ZWN1dGlvbkNvbnRleHQgJiAoUmVuZGVyQ29udGV4dCB8IENvbW1pdENvbnRleHQpKSAhPT0gTm9Db250ZXh0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgZmx1c2ggcGFzc2l2ZSBlZmZlY3RzIHdoaWxlIGFscmVhZHkgcmVuZGVyaW5nLicpO1xuICB9XG5cbiAge1xuICAgIGlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyA9IHRydWU7XG4gICAgZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xuICB9XG5cbiAge1xuICAgIG1hcmtQYXNzaXZlRWZmZWN0c1N0YXJ0ZWQobGFuZXMpO1xuICB9XG5cbiAgdmFyIHByZXZFeGVjdXRpb25Db250ZXh0ID0gZXhlY3V0aW9uQ29udGV4dDtcbiAgZXhlY3V0aW9uQ29udGV4dCB8PSBDb21taXRDb250ZXh0O1xuICBjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHMocm9vdC5jdXJyZW50KTtcbiAgY29tbWl0UGFzc2l2ZU1vdW50RWZmZWN0cyhyb290LCByb290LmN1cnJlbnQsIGxhbmVzLCB0cmFuc2l0aW9ucyk7IC8vIFRPRE86IE1vdmUgdG8gY29tbWl0UGFzc2l2ZU1vdW50RWZmZWN0c1xuXG4gIHtcbiAgICB2YXIgcHJvZmlsZXJFZmZlY3RzID0gcGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdHM7XG4gICAgcGVuZGluZ1Bhc3NpdmVQcm9maWxlckVmZmVjdHMgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvZmlsZXJFZmZlY3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZmliZXIgPSBwcm9maWxlckVmZmVjdHNbaV07XG4gICAgICBjb21taXRQYXNzaXZlRWZmZWN0RHVyYXRpb25zKHJvb3QsIGZpYmVyKTtcbiAgICB9XG4gIH1cblxuICB7XG4gICAgbWFya1Bhc3NpdmVFZmZlY3RzU3RvcHBlZCgpO1xuICB9XG5cbiAge1xuICAgIGNvbW1pdERvdWJsZUludm9rZUVmZmVjdHNJbkRFVihyb290KTtcbiAgfVxuXG4gIGV4ZWN1dGlvbkNvbnRleHQgPSBwcmV2RXhlY3V0aW9uQ29udGV4dDtcbiAgZmx1c2hTeW5jV29ya09uQWxsUm9vdHMoKTtcblxuICB7XG4gICAgLy8gSWYgYWRkaXRpb25hbCBwYXNzaXZlIGVmZmVjdHMgd2VyZSBzY2hlZHVsZWQsIGluY3JlbWVudCBhIGNvdW50ZXIuIElmIHRoaXNcbiAgICAvLyBleGNlZWRzIHRoZSBsaW1pdCwgd2UnbGwgZmlyZSBhIHdhcm5pbmcuXG4gICAgaWYgKGRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICAgIGlmIChyb290ID09PSByb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzKSB7XG4gICAgICAgIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMDtcbiAgICAgICAgcm9vdFdpdGhQYXNzaXZlTmVzdGVkVXBkYXRlcyA9IHJvb3Q7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDA7XG4gICAgfVxuXG4gICAgaXNGbHVzaGluZ1Bhc3NpdmVFZmZlY3RzID0gZmFsc2U7XG4gICAgZGlkU2NoZWR1bGVVcGRhdGVEdXJpbmdQYXNzaXZlRWZmZWN0cyA9IGZhbHNlO1xuICB9IC8vIFRPRE86IE1vdmUgdG8gY29tbWl0UGFzc2l2ZU1vdW50RWZmZWN0c1xuXG5cbiAgb25Qb3N0Q29tbWl0Um9vdChyb290KTtcblxuICB7XG4gICAgdmFyIHN0YXRlTm9kZSA9IHJvb3QuY3VycmVudC5zdGF0ZU5vZGU7XG4gICAgc3RhdGVOb2RlLmVmZmVjdER1cmF0aW9uID0gMDtcbiAgICBzdGF0ZU5vZGUucGFzc2l2ZUVmZmVjdER1cmF0aW9uID0gMDtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSB7XG4gIHJldHVybiBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCAhPT0gbnVsbCAmJiBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZC5oYXMoaW5zdGFuY2UpO1xufVxuZnVuY3Rpb24gbWFya0xlZ2FjeUVycm9yQm91bmRhcnlBc0ZhaWxlZChpbnN0YW5jZSkge1xuICBpZiAobGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQgPT09IG51bGwpIHtcbiAgICBsZWdhY3lFcnJvckJvdW5kYXJpZXNUaGF0QWxyZWFkeUZhaWxlZCA9IG5ldyBTZXQoW2luc3RhbmNlXSk7XG4gIH0gZWxzZSB7XG4gICAgbGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQuYWRkKGluc3RhbmNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChyb290RmliZXIsIHNvdXJjZUZpYmVyLCBlcnJvcikge1xuICB2YXIgZXJyb3JJbmZvID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoZXJyb3IsIHNvdXJjZUZpYmVyKTtcbiAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVJvb3RFcnJvclVwZGF0ZShyb290RmliZXIuc3RhdGVOb2RlLCBlcnJvckluZm8sIFN5bmNMYW5lKTtcbiAgdmFyIHJvb3QgPSBlbnF1ZXVlVXBkYXRlKHJvb3RGaWJlciwgdXBkYXRlLCBTeW5jTGFuZSk7XG5cbiAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICBtYXJrUm9vdFVwZGF0ZWQocm9vdCwgU3luY0xhbmUpO1xuICAgIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvcihzb3VyY2VGaWJlciwgbmVhcmVzdE1vdW50ZWRBbmNlc3RvciwgZXJyb3IkMSkge1xuICB7XG4gICAgc2V0SXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0KGZhbHNlKTtcbiAgfVxuXG4gIGlmIChzb3VyY2VGaWJlci50YWcgPT09IEhvc3RSb290KSB7XG4gICAgLy8gRXJyb3Igd2FzIHRocm93biBhdCB0aGUgcm9vdC4gVGhlcmUgaXMgbm8gcGFyZW50LCBzbyB0aGUgcm9vdFxuICAgIC8vIGl0c2VsZiBzaG91bGQgY2FwdHVyZSBpdC5cbiAgICBjYXB0dXJlQ29tbWl0UGhhc2VFcnJvck9uUm9vdChzb3VyY2VGaWJlciwgc291cmNlRmliZXIsIGVycm9yJDEpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBmaWJlciA9IG5lYXJlc3RNb3VudGVkQW5jZXN0b3I7XG5cbiAgd2hpbGUgKGZpYmVyICE9PSBudWxsKSB7XG4gICAgaWYgKGZpYmVyLnRhZyA9PT0gSG9zdFJvb3QpIHtcbiAgICAgIGNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290KGZpYmVyLCBzb3VyY2VGaWJlciwgZXJyb3IkMSk7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICB2YXIgY3RvciA9IGZpYmVyLnR5cGU7XG4gICAgICB2YXIgaW5zdGFuY2UgPSBmaWJlci5zdGF0ZU5vZGU7XG5cbiAgICAgIGlmICh0eXBlb2YgY3Rvci5nZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIGluc3RhbmNlLmNvbXBvbmVudERpZENhdGNoID09PSAnZnVuY3Rpb24nICYmICFpc0FscmVhZHlGYWlsZWRMZWdhY3lFcnJvckJvdW5kYXJ5KGluc3RhbmNlKSkge1xuICAgICAgICB2YXIgZXJyb3JJbmZvID0gY3JlYXRlQ2FwdHVyZWRWYWx1ZUF0RmliZXIoZXJyb3IkMSwgc291cmNlRmliZXIpO1xuICAgICAgICB2YXIgdXBkYXRlID0gY3JlYXRlQ2xhc3NFcnJvclVwZGF0ZShTeW5jTGFuZSk7XG4gICAgICAgIHZhciByb290ID0gZW5xdWV1ZVVwZGF0ZShmaWJlciwgdXBkYXRlLCBTeW5jTGFuZSk7XG5cbiAgICAgICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgICBpbml0aWFsaXplQ2xhc3NFcnJvclVwZGF0ZSh1cGRhdGUsIHJvb3QsIGZpYmVyLCBlcnJvckluZm8pO1xuICAgICAgICAgIG1hcmtSb290VXBkYXRlZChyb290LCBTeW5jTGFuZSk7XG4gICAgICAgICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZpYmVyID0gZmliZXIucmV0dXJuO1xuICB9XG5cbiAge1xuICAgIGVycm9yKCdJbnRlcm5hbCBSZWFjdCBlcnJvcjogQXR0ZW1wdGVkIHRvIGNhcHR1cmUgYSBjb21taXQgcGhhc2UgZXJyb3IgJyArICdpbnNpZGUgYSBkZXRhY2hlZCB0cmVlLiBUaGlzIGluZGljYXRlcyBhIGJ1ZyBpbiBSZWFjdC4gUG90ZW50aWFsICcgKyAnY2F1c2VzIGluY2x1ZGUgZGVsZXRpbmcgdGhlIHNhbWUgZmliZXIgbW9yZSB0aGFuIG9uY2UsIGNvbW1pdHRpbmcgYW4gJyArICdhbHJlYWR5LWZpbmlzaGVkIHRyZWUsIG9yIGFuIGluY29uc2lzdGVudCByZXR1cm4gcG9pbnRlci5cXG5cXG4nICsgJ0Vycm9yIG1lc3NhZ2U6XFxuXFxuJXMnLCBlcnJvciQxKTtcbiAgfVxufVxuZnVuY3Rpb24gYXR0YWNoUGluZ0xpc3RlbmVyKHJvb3QsIHdha2VhYmxlLCBsYW5lcykge1xuICAvLyBBdHRhY2ggYSBwaW5nIGxpc3RlbmVyXG4gIC8vXG4gIC8vIFRoZSBkYXRhIG1pZ2h0IHJlc29sdmUgYmVmb3JlIHdlIGhhdmUgYSBjaGFuY2UgdG8gY29tbWl0IHRoZSBmYWxsYmFjay4gT3IsXG4gIC8vIGluIHRoZSBjYXNlIG9mIGEgcmVmcmVzaCwgd2UnbGwgbmV2ZXIgY29tbWl0IGEgZmFsbGJhY2suIFNvIHdlIG5lZWQgdG9cbiAgLy8gYXR0YWNoIGEgbGlzdGVuZXIgbm93LiBXaGVuIGl0IHJlc29sdmVzIChcInBpbmdzXCIpLCB3ZSBjYW4gZGVjaWRlIHdoZXRoZXIgdG9cbiAgLy8gdHJ5IHJlbmRlcmluZyB0aGUgdHJlZSBhZ2Fpbi5cbiAgLy9cbiAgLy8gT25seSBhdHRhY2ggYSBsaXN0ZW5lciBpZiBvbmUgZG9lcyBub3QgYWxyZWFkeSBleGlzdCBmb3IgdGhlIGxhbmVzXG4gIC8vIHdlJ3JlIGN1cnJlbnRseSByZW5kZXJpbmcgKHdoaWNoIGFjdHMgbGlrZSBhIFwidGhyZWFkIElEXCIgaGVyZSkuXG4gIC8vXG4gIC8vIFdlIG9ubHkgbmVlZCB0byBkbyB0aGlzIGluIGNvbmN1cnJlbnQgbW9kZS4gTGVnYWN5IFN1c3BlbnNlIGFsd2F5c1xuICAvLyBjb21taXRzIGZhbGxiYWNrcyBzeW5jaHJvbm91c2x5LCBzbyB0aGVyZSBhcmUgbm8gcGluZ3MuXG4gIHZhciBwaW5nQ2FjaGUgPSByb290LnBpbmdDYWNoZTtcbiAgdmFyIHRocmVhZElEcztcblxuICBpZiAocGluZ0NhY2hlID09PSBudWxsKSB7XG4gICAgcGluZ0NhY2hlID0gcm9vdC5waW5nQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG4gICAgdGhyZWFkSURzID0gbmV3IFNldCgpO1xuICAgIHBpbmdDYWNoZS5zZXQod2FrZWFibGUsIHRocmVhZElEcyk7XG4gIH0gZWxzZSB7XG4gICAgdGhyZWFkSURzID0gcGluZ0NhY2hlLmdldCh3YWtlYWJsZSk7XG5cbiAgICBpZiAodGhyZWFkSURzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocmVhZElEcyA9IG5ldyBTZXQoKTtcbiAgICAgIHBpbmdDYWNoZS5zZXQod2FrZWFibGUsIHRocmVhZElEcyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCF0aHJlYWRJRHMuaGFzKGxhbmVzKSkge1xuICAgIHdvcmtJblByb2dyZXNzUm9vdERpZEF0dGFjaFBpbmdMaXN0ZW5lciA9IHRydWU7IC8vIE1lbW9pemUgdXNpbmcgdGhlIHRocmVhZCBJRCB0byBwcmV2ZW50IHJlZHVuZGFudCBsaXN0ZW5lcnMuXG5cbiAgICB0aHJlYWRJRHMuYWRkKGxhbmVzKTtcbiAgICB2YXIgcGluZyA9IHBpbmdTdXNwZW5kZWRSb290LmJpbmQobnVsbCwgcm9vdCwgd2FrZWFibGUsIGxhbmVzKTtcblxuICAgIHtcbiAgICAgIGlmIChpc0RldlRvb2xzUHJlc2VudCkge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIHBlbmRpbmcgd29yayBzdGlsbCwgcmVzdG9yZSB0aGUgb3JpZ2luYWwgdXBkYXRlcnNcbiAgICAgICAgcmVzdG9yZVBlbmRpbmdVcGRhdGVycyhyb290LCBsYW5lcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgd2FrZWFibGUudGhlbihwaW5nLCBwaW5nKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwaW5nU3VzcGVuZGVkUm9vdChyb290LCB3YWtlYWJsZSwgcGluZ2VkTGFuZXMpIHtcbiAgdmFyIHBpbmdDYWNoZSA9IHJvb3QucGluZ0NhY2hlO1xuXG4gIGlmIChwaW5nQ2FjaGUgIT09IG51bGwpIHtcbiAgICAvLyBUaGUgd2FrZWFibGUgcmVzb2x2ZWQsIHNvIHdlIG5vIGxvbmdlciBuZWVkIHRvIG1lbW9pemUsIGJlY2F1c2UgaXQgd2lsbFxuICAgIC8vIG5ldmVyIGJlIHRocm93biBhZ2Fpbi5cbiAgICBwaW5nQ2FjaGUuZGVsZXRlKHdha2VhYmxlKTtcbiAgfVxuXG4gIG1hcmtSb290UGluZ2VkKHJvb3QsIHBpbmdlZExhbmVzKTtcbiAgd2FybklmU3VzcGVuc2VSZXNvbHV0aW9uTm90V3JhcHBlZFdpdGhBY3RERVYoKTtcblxuICBpZiAod29ya0luUHJvZ3Jlc3NSb290ID09PSByb290ICYmIGlzU3Vic2V0T2ZMYW5lcyh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcywgcGluZ2VkTGFuZXMpKSB7XG4gICAgLy8gUmVjZWl2ZWQgYSBwaW5nIGF0IHRoZSBzYW1lIHByaW9yaXR5IGxldmVsIGF0IHdoaWNoIHdlJ3JlIGN1cnJlbnRseVxuICAgIC8vIHJlbmRlcmluZy4gV2UgbWlnaHQgd2FudCB0byByZXN0YXJ0IHRoaXMgcmVuZGVyLiBUaGlzIHNob3VsZCBtaXJyb3JcbiAgICAvLyB0aGUgbG9naWMgb2Ygd2hldGhlciBvciBub3QgYSByb290IHN1c3BlbmRzIG9uY2UgaXQgY29tcGxldGVzLlxuICAgIC8vIFRPRE86IElmIHdlJ3JlIHJlbmRlcmluZyBzeW5jIGVpdGhlciBkdWUgdG8gU3luYywgQmF0Y2hlZCBvciBleHBpcmVkLFxuICAgIC8vIHdlIHNob3VsZCBwcm9iYWJseSBuZXZlciByZXN0YXJ0LlxuICAgIC8vIElmIHdlJ3JlIHN1c3BlbmRlZCB3aXRoIGRlbGF5LCBvciBpZiBpdCdzIGEgcmV0cnksIHdlJ2xsIGFsd2F5cyBzdXNwZW5kXG4gICAgLy8gc28gd2UgY2FuIGFsd2F5cyByZXN0YXJ0LlxuICAgIGlmICh3b3JrSW5Qcm9ncmVzc1Jvb3RFeGl0U3RhdHVzID09PSBSb290U3VzcGVuZGVkV2l0aERlbGF5IHx8IHdvcmtJblByb2dyZXNzUm9vdEV4aXRTdGF0dXMgPT09IFJvb3RTdXNwZW5kZWQgJiYgaW5jbHVkZXNPbmx5UmV0cmllcyh3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcykgJiYgbm93JDEoKSAtIGdsb2JhbE1vc3RSZWNlbnRGYWxsYmFja1RpbWUgPCBGQUxMQkFDS19USFJPVFRMRV9NUykge1xuICAgICAgLy8gRm9yY2UgYSByZXN0YXJ0IGZyb20gdGhlIHJvb3QgYnkgdW53aW5kaW5nIHRoZSBzdGFjay4gVW5sZXNzIHRoaXMgaXNcbiAgICAgIC8vIGJlaW5nIGNhbGxlZCBmcm9tIHRoZSByZW5kZXIgcGhhc2UsIGJlY2F1c2UgdGhhdCB3b3VsZCBjYXVzZSBhIGNyYXNoLlxuICAgICAgaWYgKChleGVjdXRpb25Db250ZXh0ICYgUmVuZGVyQ29udGV4dCkgPT09IE5vQ29udGV4dCkge1xuICAgICAgICBwcmVwYXJlRnJlc2hTdGFjayhyb290LCBOb0xhbmVzKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRXZlbiB0aG91Z2ggd2UgY2FuJ3QgcmVzdGFydCByaWdodCBub3csIHdlIG1pZ2h0IGdldCBhblxuICAgICAgLy8gb3Bwb3J0dW5pdHkgbGF0ZXIuIFNvIHdlIG1hcmsgdGhpcyByZW5kZXIgYXMgaGF2aW5nIGEgcGluZy5cbiAgICAgIHdvcmtJblByb2dyZXNzUm9vdFBpbmdlZExhbmVzID0gbWVyZ2VMYW5lcyh3b3JrSW5Qcm9ncmVzc1Jvb3RQaW5nZWRMYW5lcywgcGluZ2VkTGFuZXMpO1xuICAgIH1cbiAgfVxuXG4gIGVuc3VyZVJvb3RJc1NjaGVkdWxlZChyb290KTtcbn1cblxuZnVuY3Rpb24gcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSkge1xuICAvLyBUaGUgYm91bmRhcnkgZmliZXIgKGEgU3VzcGVuc2UgY29tcG9uZW50IG9yIFN1c3BlbnNlTGlzdCBjb21wb25lbnQpXG4gIC8vIHByZXZpb3VzbHkgd2FzIHJlbmRlcmVkIGluIGl0cyBmYWxsYmFjayBzdGF0ZS4gT25lIG9mIHRoZSBwcm9taXNlcyB0aGF0XG4gIC8vIHN1c3BlbmRlZCBpdCBoYXMgcmVzb2x2ZWQsIHdoaWNoIG1lYW5zIGF0IGxlYXN0IHBhcnQgb2YgdGhlIHRyZWUgd2FzXG4gIC8vIGxpa2VseSB1bmJsb2NrZWQuIFRyeSByZW5kZXJpbmcgYWdhaW4sIGF0IGEgbmV3IGxhbmVzLlxuICBpZiAocmV0cnlMYW5lID09PSBOb0xhbmUpIHtcbiAgICAvLyBUT0RPOiBBc3NpZ24gdGhpcyB0byBgc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmVgPyB0byBhdm9pZFxuICAgIC8vIHVubmVjZXNzYXJ5IGVudGFuZ2xlbWVudD9cbiAgICByZXRyeUxhbmUgPSByZXF1ZXN0UmV0cnlMYW5lKCk7XG4gIH0gLy8gVE9ETzogU3BlY2lhbCBjYXNlIGlkbGUgcHJpb3JpdHk/XG5cblxuICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShib3VuZGFyeUZpYmVyLCByZXRyeUxhbmUpO1xuXG4gIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgbWFya1Jvb3RVcGRhdGVkKHJvb3QsIHJldHJ5TGFuZSk7XG4gICAgZW5zdXJlUm9vdElzU2NoZWR1bGVkKHJvb3QpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJldHJ5RGVoeWRyYXRlZFN1c3BlbnNlQm91bmRhcnkoYm91bmRhcnlGaWJlcikge1xuICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGJvdW5kYXJ5RmliZXIubWVtb2l6ZWRTdGF0ZTtcbiAgdmFyIHJldHJ5TGFuZSA9IE5vTGFuZTtcblxuICBpZiAoc3VzcGVuc2VTdGF0ZSAhPT0gbnVsbCkge1xuICAgIHJldHJ5TGFuZSA9IHN1c3BlbnNlU3RhdGUucmV0cnlMYW5lO1xuICB9XG5cbiAgcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG59XG5mdW5jdGlvbiByZXNvbHZlUmV0cnlXYWtlYWJsZShib3VuZGFyeUZpYmVyLCB3YWtlYWJsZSkge1xuICB2YXIgcmV0cnlMYW5lID0gTm9MYW5lOyAvLyBEZWZhdWx0XG5cbiAgdmFyIHJldHJ5Q2FjaGU7XG5cbiAgc3dpdGNoIChib3VuZGFyeUZpYmVyLnRhZykge1xuICAgIGNhc2UgU3VzcGVuc2VDb21wb25lbnQ6XG4gICAgICByZXRyeUNhY2hlID0gYm91bmRhcnlGaWJlci5zdGF0ZU5vZGU7XG4gICAgICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGJvdW5kYXJ5RmliZXIubWVtb2l6ZWRTdGF0ZTtcblxuICAgICAgaWYgKHN1c3BlbnNlU3RhdGUgIT09IG51bGwpIHtcbiAgICAgICAgcmV0cnlMYW5lID0gc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmU7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBTdXNwZW5zZUxpc3RDb21wb25lbnQ6XG4gICAgICByZXRyeUNhY2hlID0gYm91bmRhcnlGaWJlci5zdGF0ZU5vZGU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgT2Zmc2NyZWVuQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBib3VuZGFyeUZpYmVyLnN0YXRlTm9kZTtcbiAgICAgICAgcmV0cnlDYWNoZSA9IGluc3RhbmNlLl9yZXRyeUNhY2hlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BpbmdlZCB1bmtub3duIHN1c3BlbnNlIGJvdW5kYXJ5IHR5cGUuICcgKyAnVGhpcyBpcyBwcm9iYWJseSBhIGJ1ZyBpbiBSZWFjdC4nKTtcbiAgfVxuXG4gIGlmIChyZXRyeUNhY2hlICE9PSBudWxsKSB7XG4gICAgLy8gVGhlIHdha2VhYmxlIHJlc29sdmVkLCBzbyB3ZSBubyBsb25nZXIgbmVlZCB0byBtZW1vaXplLCBiZWNhdXNlIGl0IHdpbGxcbiAgICAvLyBuZXZlciBiZSB0aHJvd24gYWdhaW4uXG4gICAgcmV0cnlDYWNoZS5kZWxldGUod2FrZWFibGUpO1xuICB9XG5cbiAgcmV0cnlUaW1lZE91dEJvdW5kYXJ5KGJvdW5kYXJ5RmliZXIsIHJldHJ5TGFuZSk7XG59XG5mdW5jdGlvbiB0aHJvd0lmSW5maW5pdGVVcGRhdGVMb29wRGV0ZWN0ZWQoKSB7XG4gIGlmIChuZXN0ZWRVcGRhdGVDb3VudCA+IE5FU1RFRF9VUERBVEVfTElNSVQpIHtcbiAgICBuZXN0ZWRVcGRhdGVDb3VudCA9IDA7XG4gICAgbmVzdGVkUGFzc2l2ZVVwZGF0ZUNvdW50ID0gMDtcbiAgICByb290V2l0aE5lc3RlZFVwZGF0ZXMgPSBudWxsO1xuICAgIHJvb3RXaXRoUGFzc2l2ZU5lc3RlZFVwZGF0ZXMgPSBudWxsO1xuXG4gICAge1xuICAgICAgaWYgKGV4ZWN1dGlvbkNvbnRleHQgJiBSZW5kZXJDb250ZXh0ICYmIHdvcmtJblByb2dyZXNzUm9vdCAhPT0gbnVsbCkge1xuICAgICAgICAvLyBXZSdyZSBpbiB0aGUgcmVuZGVyIHBoYXNlLiBEaXNhYmxlIHRoZSBjb25jdXJyZW50IGVycm9yIHJlY292ZXJ5XG4gICAgICAgIC8vIG1lY2hhbmlzbSB0byBlbnN1cmUgdGhhdCB0aGUgZXJyb3Igd2UncmUgYWJvdXQgdG8gdGhyb3cgZ2V0cyBoYW5kbGVkLlxuICAgICAgICAvLyBXZSBuZWVkIGl0IHRvIHRyaWdnZXIgdGhlIG5lYXJlc3QgZXJyb3IgYm91bmRhcnkgc28gdGhhdCB0aGUgaW5maW5pdGVcbiAgICAgICAgLy8gdXBkYXRlIGxvb3AgaXMgYnJva2VuLlxuICAgICAgICB3b3JrSW5Qcm9ncmVzc1Jvb3QuZXJyb3JSZWNvdmVyeURpc2FibGVkTGFuZXMgPSBtZXJnZUxhbmVzKHdvcmtJblByb2dyZXNzUm9vdC5lcnJvclJlY292ZXJ5RGlzYWJsZWRMYW5lcywgd29ya0luUHJvZ3Jlc3NSb290UmVuZGVyTGFuZXMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRocm93IG5ldyBFcnJvcignTWF4aW11bSB1cGRhdGUgZGVwdGggZXhjZWVkZWQuIFRoaXMgY2FuIGhhcHBlbiB3aGVuIGEgY29tcG9uZW50ICcgKyAncmVwZWF0ZWRseSBjYWxscyBzZXRTdGF0ZSBpbnNpZGUgY29tcG9uZW50V2lsbFVwZGF0ZSBvciAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZS4gUmVhY3QgbGltaXRzIHRoZSBudW1iZXIgb2YgbmVzdGVkIHVwZGF0ZXMgdG8gJyArICdwcmV2ZW50IGluZmluaXRlIGxvb3BzLicpO1xuICB9XG5cbiAge1xuICAgIGlmIChuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQgPiBORVNURURfUEFTU0lWRV9VUERBVEVfTElNSVQpIHtcbiAgICAgIG5lc3RlZFBhc3NpdmVVcGRhdGVDb3VudCA9IDA7XG4gICAgICByb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzID0gbnVsbDtcblxuICAgICAgZXJyb3IoJ01heGltdW0gdXBkYXRlIGRlcHRoIGV4Y2VlZGVkLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiBhIGNvbXBvbmVudCAnICsgXCJjYWxscyBzZXRTdGF0ZSBpbnNpZGUgdXNlRWZmZWN0LCBidXQgdXNlRWZmZWN0IGVpdGhlciBkb2Vzbid0IFwiICsgJ2hhdmUgYSBkZXBlbmRlbmN5IGFycmF5LCBvciBvbmUgb2YgdGhlIGRlcGVuZGVuY2llcyBjaGFuZ2VzIG9uICcgKyAnZXZlcnkgcmVuZGVyLicpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaFJlbmRlclBoYXNlU3RyaWN0TW9kZVdhcm5pbmdzSW5ERVYoKSB7XG4gIHtcbiAgICBSZWFjdFN0cmljdE1vZGVXYXJuaW5ncy5mbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nKCk7XG4gICAgUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MuZmx1c2hQZW5kaW5nVW5zYWZlTGlmZWN5Y2xlV2FybmluZ3MoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWN1cnNpdmVseVRyYXZlcnNlQW5kRG91YmxlSW52b2tlRWZmZWN0c0luREVWKHJvb3QsIHBhcmVudEZpYmVyLCBpc0luU3RyaWN0TW9kZSkge1xuICBpZiAoKHBhcmVudEZpYmVyLnN1YnRyZWVGbGFncyAmIChQbGFjZW1lbnRERVYgfCBWaXNpYmlsaXR5KSkgPT09IE5vRmxhZ3MkMSkge1xuICAgIC8vIFBhcmVudCdzIGRlc2NlbmRhbnRzIGhhdmUgYWxyZWFkeSBoYWQgZWZmZWN0cyBkb3VibGUgaW52b2tlZC5cbiAgICAvLyBFYXJseSBleGl0IHRvIGF2b2lkIHVubmVjZXNzYXJ5IHRyZWUgdHJhdmVyc2FsLlxuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjaGlsZCA9IHBhcmVudEZpYmVyLmNoaWxkO1xuXG4gIHdoaWxlIChjaGlsZCAhPT0gbnVsbCkge1xuICAgIGRvdWJsZUludm9rZUVmZmVjdHNJbkRFVklmTmVjZXNzYXJ5KHJvb3QsIGNoaWxkLCBpc0luU3RyaWN0TW9kZSk7XG4gICAgY2hpbGQgPSBjaGlsZC5zaWJsaW5nO1xuICB9XG59IC8vIFVuY29uZGl0aW9uYWxseSBkaXNjb25uZWN0cyBhbmQgY29ubmVjdHMgcGFzc2l2ZSBhbmQgbGF5b3V0IGVmZmVjdHMuXG5cblxuZnVuY3Rpb24gZG91YmxlSW52b2tlRWZmZWN0c09uRmliZXIocm9vdCwgZmliZXIpIHtcbiAgdmFyIHNob3VsZERvdWJsZUludm9rZVBhc3NpdmVFZmZlY3RzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB0cnVlO1xuICBzZXRJc1N0cmljdE1vZGVGb3JEZXZ0b29scyh0cnVlKTtcbiAgZGlzYXBwZWFyTGF5b3V0RWZmZWN0cyhmaWJlcik7XG5cbiAgaWYgKHNob3VsZERvdWJsZUludm9rZVBhc3NpdmVFZmZlY3RzKSB7XG4gICAgZGlzY29ubmVjdFBhc3NpdmVFZmZlY3QoZmliZXIpO1xuICB9XG5cbiAgcmVhcHBlYXJMYXlvdXRFZmZlY3RzKHJvb3QsIGZpYmVyLmFsdGVybmF0ZSwgZmliZXIsIGZhbHNlKTtcblxuICBpZiAoc2hvdWxkRG91YmxlSW52b2tlUGFzc2l2ZUVmZmVjdHMpIHtcbiAgICByZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyhyb290LCBmaWJlciwgTm9MYW5lcywgbnVsbCwgZmFsc2UpO1xuICB9XG5cbiAgc2V0SXNTdHJpY3RNb2RlRm9yRGV2dG9vbHMoZmFsc2UpO1xufVxuXG5mdW5jdGlvbiBkb3VibGVJbnZva2VFZmZlY3RzSW5ERVZJZk5lY2Vzc2FyeShyb290LCBmaWJlciwgcGFyZW50SXNJblN0cmljdE1vZGUpIHtcbiAgdmFyIGlzU3RyaWN0TW9kZUZpYmVyID0gZmliZXIudHlwZSA9PT0gUkVBQ1RfU1RSSUNUX01PREVfVFlQRTtcbiAgdmFyIGlzSW5TdHJpY3RNb2RlID0gcGFyZW50SXNJblN0cmljdE1vZGUgfHwgaXNTdHJpY3RNb2RlRmliZXI7IC8vIEZpcnN0IGNhc2U6IHRoZSBmaWJlciAqKmlzIG5vdCoqIG9mIHR5cGUgT2Zmc2NyZWVuQ29tcG9uZW50LiBOb1xuICAvLyBzcGVjaWFsIHJ1bGVzIGFwcGx5IHRvIGRvdWJsZSBpbnZva2luZyBlZmZlY3RzLlxuXG4gIGlmIChmaWJlci50YWcgIT09IE9mZnNjcmVlbkNvbXBvbmVudCkge1xuICAgIGlmIChmaWJlci5mbGFncyAmIFBsYWNlbWVudERFVikge1xuICAgICAgc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVihmaWJlcik7XG5cbiAgICAgIGlmIChpc0luU3RyaWN0TW9kZSkge1xuICAgICAgICBkb3VibGVJbnZva2VFZmZlY3RzT25GaWJlcihyb290LCBmaWJlciwgKGZpYmVyLm1vZGUgJiBOb1N0cmljdFBhc3NpdmVFZmZlY3RzTW9kZSkgPT09IE5vTW9kZSk7XG4gICAgICB9XG5cbiAgICAgIHJlc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVigpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlQW5kRG91YmxlSW52b2tlRWZmZWN0c0luREVWKHJvb3QsIGZpYmVyLCBpc0luU3RyaWN0TW9kZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuO1xuICB9IC8vIFNlY29uZCBjYXNlOiB0aGUgZmliZXIgKippcyoqIG9mIHR5cGUgT2Zmc2NyZWVuQ29tcG9uZW50LlxuICAvLyBUaGlzIGJyYW5jaCBjb250YWlucyBjYXNlcyBzcGVjaWZpYyB0byBPZmZzY3JlZW4uXG5cblxuICBpZiAoZmliZXIubWVtb2l6ZWRTdGF0ZSA9PT0gbnVsbCkge1xuICAgIC8vIE9ubHkgY29uc2lkZXIgT2Zmc2NyZWVuIHRoYXQgaXMgdmlzaWJsZS5cbiAgICAvLyBUT0RPIChPZmZzY3JlZW4pIEhhbmRsZSBtYW51YWwgbW9kZS5cbiAgICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKGZpYmVyKTtcblxuICAgIGlmIChpc0luU3RyaWN0TW9kZSAmJiBmaWJlci5mbGFncyAmIFZpc2liaWxpdHkpIHtcbiAgICAgIC8vIERvdWJsZSBpbnZva2UgZWZmZWN0cyBvbiBPZmZzY3JlZW4ncyBzdWJ0cmVlIG9ubHlcbiAgICAgIC8vIGlmIGl0IGlzIHZpc2libGUgYW5kIGl0cyB2aXNpYmlsaXR5IGhhcyBjaGFuZ2VkLlxuICAgICAgZG91YmxlSW52b2tlRWZmZWN0c09uRmliZXIocm9vdCwgZmliZXIpO1xuICAgIH0gZWxzZSBpZiAoZmliZXIuc3VidHJlZUZsYWdzICYgUGxhY2VtZW50REVWKSB7XG4gICAgICAvLyBTb21ldGhpbmcgaW4gdGhlIHN1YnRyZWUgY291bGQgaGF2ZSBiZWVuIHN1c3BlbmRlZC5cbiAgICAgIC8vIFdlIG5lZWQgdG8gY29udGludWUgdHJhdmVyc2FsIGFuZCBmaW5kIG5ld2x5IGluc2VydGVkIGZpYmVycy5cbiAgICAgIHJlY3Vyc2l2ZWx5VHJhdmVyc2VBbmREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocm9vdCwgZmliZXIsIGlzSW5TdHJpY3RNb2RlKTtcbiAgICB9XG5cbiAgICByZXNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21taXREb3VibGVJbnZva2VFZmZlY3RzSW5ERVYocm9vdCwgaGFzUGFzc2l2ZUVmZmVjdHMpIHtcbiAge1xuICAgIHtcbiAgICAgIHZhciBkb3VibGVJbnZva2VFZmZlY3RzID0gdHJ1ZTtcblxuICAgICAgaWYgKCEocm9vdC5jdXJyZW50Lm1vZGUgJiAoU3RyaWN0TGVnYWN5TW9kZSB8IFN0cmljdEVmZmVjdHNNb2RlKSkpIHtcbiAgICAgICAgZG91YmxlSW52b2tlRWZmZWN0cyA9IGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZWN1cnNpdmVseVRyYXZlcnNlQW5kRG91YmxlSW52b2tlRWZmZWN0c0luREVWKHJvb3QsIHJvb3QuY3VycmVudCwgZG91YmxlSW52b2tlRWZmZWN0cyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuU3RhdGVVcGRhdGVGb3JOb3RZZXRNb3VudGVkQ29tcG9uZW50ID0gbnVsbDtcbmZ1bmN0aW9uIHdhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYoZmliZXIpIHtcbiAge1xuICAgIGlmICgoZXhlY3V0aW9uQ29udGV4dCAmIFJlbmRlckNvbnRleHQpICE9PSBOb0NvbnRleHQpIHtcbiAgICAgIC8vIFdlIGxldCB0aGUgb3RoZXIgd2FybmluZyBhYm91dCByZW5kZXIgcGhhc2UgdXBkYXRlcyBkZWFsIHdpdGggdGhpcyBvbmUuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHRhZyA9IGZpYmVyLnRhZztcblxuICAgIGlmICh0YWcgIT09IEhvc3RSb290ICYmIHRhZyAhPT0gQ2xhc3NDb21wb25lbnQgJiYgdGFnICE9PSBGdW5jdGlvbkNvbXBvbmVudCAmJiB0YWcgIT09IEZvcndhcmRSZWYgJiYgdGFnICE9PSBNZW1vQ29tcG9uZW50ICYmIHRhZyAhPT0gU2ltcGxlTWVtb0NvbXBvbmVudCkge1xuICAgICAgLy8gT25seSB3YXJuIGZvciB1c2VyLWRlZmluZWQgY29tcG9uZW50cywgbm90IGludGVybmFsIG9uZXMgbGlrZSBTdXNwZW5zZS5cbiAgICAgIHJldHVybjtcbiAgICB9IC8vIFdlIHNob3cgdGhlIHdob2xlIHN0YWNrIGJ1dCBkZWR1cGUgb24gdGhlIHRvcCBjb21wb25lbnQncyBuYW1lIGJlY2F1c2VcbiAgICAvLyB0aGUgcHJvYmxlbWF0aWMgY29kZSBhbG1vc3QgYWx3YXlzIGxpZXMgaW5zaWRlIHRoYXQgY29tcG9uZW50LlxuXG5cbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIoZmliZXIpIHx8ICdSZWFjdENvbXBvbmVudCc7XG5cbiAgICBpZiAoZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudCAhPT0gbnVsbCkge1xuICAgICAgaWYgKGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQuaGFzKGNvbXBvbmVudE5hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgZGlkV2FyblN0YXRlVXBkYXRlRm9yTm90WWV0TW91bnRlZENvbXBvbmVudC5hZGQoY29tcG9uZW50TmFtZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQgPSBuZXcgU2V0KFtjb21wb25lbnROYW1lXSk7XG4gICAgfVxuXG4gICAgdmFyIHByZXZpb3VzRmliZXIgPSBjdXJyZW50O1xuXG4gICAgdHJ5IHtcbiAgICAgIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoZmliZXIpO1xuXG4gICAgICBlcnJvcihcIkNhbid0IHBlcmZvcm0gYSBSZWFjdCBzdGF0ZSB1cGRhdGUgb24gYSBjb21wb25lbnQgdGhhdCBoYXNuJ3QgbW91bnRlZCB5ZXQuIFwiICsgJ1RoaXMgaW5kaWNhdGVzIHRoYXQgeW91IGhhdmUgYSBzaWRlLWVmZmVjdCBpbiB5b3VyIHJlbmRlciBmdW5jdGlvbiB0aGF0ICcgKyAnYXN5bmNocm9ub3VzbHkgbGF0ZXIgY2FsbHMgdHJpZXMgdG8gdXBkYXRlIHRoZSBjb21wb25lbnQuIE1vdmUgdGhpcyB3b3JrIHRvICcgKyAndXNlRWZmZWN0IGluc3RlYWQuJyk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChwcmV2aW91c0ZpYmVyKSB7XG4gICAgICAgIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoZmliZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzZXRDdXJyZW50RGVidWdGaWJlckluREVWKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG52YXIgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXIgPSBmYWxzZTtcbnZhciBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQ7XG5cbntcbiAgZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXJGb3JBbm90aGVyQ29tcG9uZW50ID0gbmV3IFNldCgpO1xufVxuXG5mdW5jdGlvbiB3YXJuQWJvdXRSZW5kZXJQaGFzZVVwZGF0ZXNJbkRFVihmaWJlcikge1xuICB7XG4gICAgaWYgKGlzUmVuZGVyaW5nKSB7XG4gICAgICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAgICB7XG4gICAgICAgICAgICB2YXIgcmVuZGVyaW5nQ29tcG9uZW50TmFtZSA9IHdvcmtJblByb2dyZXNzICYmIGdldENvbXBvbmVudE5hbWVGcm9tRmliZXIod29ya0luUHJvZ3Jlc3MpIHx8ICdVbmtub3duJzsgLy8gRGVkdXBlIGJ5IHRoZSByZW5kZXJpbmcgY29tcG9uZW50IGJlY2F1c2UgaXQncyB0aGUgb25lIHRoYXQgbmVlZHMgdG8gYmUgZml4ZWQuXG5cbiAgICAgICAgICAgIHZhciBkZWR1cGVLZXkgPSByZW5kZXJpbmdDb21wb25lbnROYW1lO1xuXG4gICAgICAgICAgICBpZiAoIWRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudC5oYXMoZGVkdXBlS2V5KSkge1xuICAgICAgICAgICAgICBkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlckZvckFub3RoZXJDb21wb25lbnQuYWRkKGRlZHVwZUtleSk7XG4gICAgICAgICAgICAgIHZhciBzZXRTdGF0ZUNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSB8fCAnVW5rbm93bic7XG5cbiAgICAgICAgICAgICAgZXJyb3IoJ0Nhbm5vdCB1cGRhdGUgYSBjb21wb25lbnQgKGAlc2ApIHdoaWxlIHJlbmRlcmluZyBhICcgKyAnZGlmZmVyZW50IGNvbXBvbmVudCAoYCVzYCkuIFRvIGxvY2F0ZSB0aGUgYmFkIHNldFN0YXRlKCkgY2FsbCBpbnNpZGUgYCVzYCwgJyArICdmb2xsb3cgdGhlIHN0YWNrIHRyYWNlIGFzIGRlc2NyaWJlZCBpbiBodHRwczovL3JlYWN0LmRldi9saW5rL3NldHN0YXRlLWluLXJlbmRlcicsIHNldFN0YXRlQ29tcG9uZW50TmFtZSwgcmVuZGVyaW5nQ29tcG9uZW50TmFtZSwgcmVuZGVyaW5nQ29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmICghZGlkV2FybkFib3V0VXBkYXRlSW5SZW5kZXIpIHtcbiAgICAgICAgICAgICAgZXJyb3IoJ0Nhbm5vdCB1cGRhdGUgZHVyaW5nIGFuIGV4aXN0aW5nIHN0YXRlIHRyYW5zaXRpb24gKHN1Y2ggYXMgJyArICd3aXRoaW4gYHJlbmRlcmApLiBSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlICcgKyAnZnVuY3Rpb24gb2YgcHJvcHMgYW5kIHN0YXRlLicpO1xuXG4gICAgICAgICAgICAgIGRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiByZXN0b3JlUGVuZGluZ1VwZGF0ZXJzKHJvb3QsIGxhbmVzKSB7XG4gIHtcbiAgICBpZiAoaXNEZXZUb29sc1ByZXNlbnQpIHtcbiAgICAgIHZhciBtZW1vaXplZFVwZGF0ZXJzID0gcm9vdC5tZW1vaXplZFVwZGF0ZXJzO1xuICAgICAgbWVtb2l6ZWRVcGRhdGVycy5mb3JFYWNoKGZ1bmN0aW9uIChzY2hlZHVsaW5nRmliZXIpIHtcbiAgICAgICAgYWRkRmliZXJUb0xhbmVzTWFwKHJvb3QsIHNjaGVkdWxpbmdGaWJlciwgbGFuZXMpO1xuICAgICAgfSk7IC8vIFRoaXMgZnVuY3Rpb24gaW50ZW50aW9uYWxseSBkb2VzIG5vdCBjbGVhciBtZW1vaXplZCB1cGRhdGVycy5cbiAgICAgIC8vIFRob3NlIG1heSBzdGlsbCBiZSByZWxldmFudCB0byB0aGUgY3VycmVudCBjb21taXRcbiAgICAgIC8vIGFuZCBhIGZ1dHVyZSBvbmUgKGUuZy4gU3VzcGVuc2UpLlxuICAgIH1cbiAgfVxufVxudmFyIGZha2VBY3RDYWxsYmFja05vZGUgPSB7fTsgLy8gJEZsb3dGaXhNZVttaXNzaW5nLWxvY2FsLWFubm90XVxuXG5mdW5jdGlvbiBzY2hlZHVsZUNhbGxiYWNrKHByaW9yaXR5TGV2ZWwsIGNhbGxiYWNrKSB7XG4gIHtcbiAgICAvLyBJZiB3ZSdyZSBjdXJyZW50bHkgaW5zaWRlIGFuIGBhY3RgIHNjb3BlLCBieXBhc3MgU2NoZWR1bGVyIGFuZCBwdXNoIHRvXG4gICAgLy8gdGhlIGBhY3RgIHF1ZXVlIGluc3RlYWQuXG4gICAgdmFyIGFjdFF1ZXVlID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuYWN0UXVldWU7XG5cbiAgICBpZiAoYWN0UXVldWUgIT09IG51bGwpIHtcbiAgICAgIGFjdFF1ZXVlLnB1c2goY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIGZha2VBY3RDYWxsYmFja05vZGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBzY2hlZHVsZUNhbGxiYWNrJDMocHJpb3JpdHlMZXZlbCwgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRGb3JjZUZsdXNoRmFsbGJhY2tzSW5ERVYoKSB7XG4gIC8vIE5ldmVyIGZvcmNlIGZsdXNoIGluIHByb2R1Y3Rpb24uIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGdldCBzdHJpcHBlZCBvdXQuXG4gIHJldHVybiBSZWFjdFNoYXJlZEludGVybmFscy5hY3RRdWV1ZSAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gd2FybklmVXBkYXRlc05vdFdyYXBwZWRXaXRoQWN0REVWKGZpYmVyKSB7XG4gIHtcbiAgICB7XG4gICAgICBpZiAoIWlzQ29uY3VycmVudEFjdEVudmlyb25tZW50KCkpIHtcbiAgICAgICAgLy8gTm90IGluIGFuIGFjdCBlbnZpcm9ubWVudC4gTm8gbmVlZCB0byB3YXJuLlxuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlID09PSBudWxsKSB7XG4gICAgICB2YXIgcHJldmlvdXNGaWJlciA9IGN1cnJlbnQ7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoZmliZXIpO1xuXG4gICAgICAgIGVycm9yKCdBbiB1cGRhdGUgdG8gJXMgaW5zaWRlIGEgdGVzdCB3YXMgbm90IHdyYXBwZWQgaW4gYWN0KC4uLikuXFxuXFxuJyArICdXaGVuIHRlc3RpbmcsIGNvZGUgdGhhdCBjYXVzZXMgUmVhY3Qgc3RhdGUgdXBkYXRlcyBzaG91bGQgYmUgJyArICd3cmFwcGVkIGludG8gYWN0KC4uLik6XFxuXFxuJyArICdhY3QoKCkgPT4ge1xcbicgKyAnICAvKiBmaXJlIGV2ZW50cyB0aGF0IHVwZGF0ZSBzdGF0ZSAqL1xcbicgKyAnfSk7XFxuJyArICcvKiBhc3NlcnQgb24gdGhlIG91dHB1dCAqL1xcblxcbicgKyBcIlRoaXMgZW5zdXJlcyB0aGF0IHlvdSdyZSB0ZXN0aW5nIHRoZSBiZWhhdmlvciB0aGUgdXNlciB3b3VsZCBzZWUgXCIgKyAnaW4gdGhlIGJyb3dzZXIuJyArICcgTGVhcm4gbW9yZSBhdCBodHRwczovL3JlYWN0LmRldi9saW5rL3dyYXAtdGVzdHMtd2l0aC1hY3QnLCBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKGZpYmVyKSk7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAocHJldmlvdXNGaWJlcikge1xuICAgICAgICAgIHNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoZmliZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc2V0Q3VycmVudERlYnVnRmliZXJJbkRFVigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN1c3BlbnNlUmVzb2x1dGlvbk5vdFdyYXBwZWRXaXRoQWN0REVWKHJvb3QpIHtcbiAge1xuICAgIGlmIChpc0NvbmN1cnJlbnRBY3RFbnZpcm9ubWVudCgpICYmIFJlYWN0U2hhcmVkSW50ZXJuYWxzLmFjdFF1ZXVlID09PSBudWxsKSB7XG4gICAgICBlcnJvcignQSBzdXNwZW5kZWQgcmVzb3VyY2UgZmluaXNoZWQgbG9hZGluZyBpbnNpZGUgYSB0ZXN0LCBidXQgdGhlIGV2ZW50ICcgKyAnd2FzIG5vdCB3cmFwcGVkIGluIGFjdCguLi4pLlxcblxcbicgKyAnV2hlbiB0ZXN0aW5nLCBjb2RlIHRoYXQgcmVzb2x2ZXMgc3VzcGVuZGVkIGRhdGEgc2hvdWxkIGJlIHdyYXBwZWQgJyArICdpbnRvIGFjdCguLi4pOlxcblxcbicgKyAnYWN0KCgpID0+IHtcXG4nICsgJyAgLyogZmluaXNoIGxvYWRpbmcgc3VzcGVuZGVkIGRhdGEgKi9cXG4nICsgJ30pO1xcbicgKyAnLyogYXNzZXJ0IG9uIHRoZSBvdXRwdXQgKi9cXG5cXG4nICsgXCJUaGlzIGVuc3VyZXMgdGhhdCB5b3UncmUgdGVzdGluZyB0aGUgYmVoYXZpb3IgdGhlIHVzZXIgd291bGQgc2VlIFwiICsgJ2luIHRoZSBicm93c2VyLicgKyAnIExlYXJuIG1vcmUgYXQgaHR0cHM6Ly9yZWFjdC5kZXYvbGluay93cmFwLXRlc3RzLXdpdGgtYWN0Jyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHNldElzUnVubmluZ0luc2VydGlvbkVmZmVjdChpc1J1bm5pbmcpIHtcbiAge1xuICAgIGlzUnVubmluZ0luc2VydGlvbkVmZmVjdCA9IGlzUnVubmluZztcbiAgfVxufVxuXG4vKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzICovXG4vLyBVc2VkIGJ5IFJlYWN0IFJlZnJlc2ggcnVudGltZSB0aHJvdWdoIERldlRvb2xzIEdsb2JhbCBIb29rLlxuXG52YXIgcmVzb2x2ZUZhbWlseSA9IG51bGw7XG52YXIgZmFpbGVkQm91bmRhcmllcyA9IG51bGw7XG52YXIgc2V0UmVmcmVzaEhhbmRsZXIgPSBmdW5jdGlvbiAoaGFuZGxlcikge1xuICB7XG4gICAgcmVzb2x2ZUZhbWlseSA9IGhhbmRsZXI7XG4gIH1cbn07XG5mdW5jdGlvbiByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcodHlwZSkge1xuICB7XG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIC8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG4gICAgICByZXR1cm4gdHlwZTtcbiAgICB9XG5cbiAgICB2YXIgZmFtaWx5ID0gcmVzb2x2ZUZhbWlseSh0eXBlKTtcblxuICAgIGlmIChmYW1pbHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfSAvLyBVc2UgdGhlIGxhdGVzdCBrbm93biBpbXBsZW1lbnRhdGlvbi5cblxuXG4gICAgcmV0dXJuIGZhbWlseS5jdXJyZW50O1xuICB9XG59XG5mdW5jdGlvbiByZXNvbHZlQ2xhc3NGb3JIb3RSZWxvYWRpbmcodHlwZSkge1xuICAvLyBObyBpbXBsZW1lbnRhdGlvbiBkaWZmZXJlbmNlcy5cbiAgcmV0dXJuIHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyh0eXBlKTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKHR5cGUpIHtcbiAge1xuICAgIGlmIChyZXNvbHZlRmFtaWx5ID09PSBudWxsKSB7XG4gICAgICAvLyBIb3QgcmVsb2FkaW5nIGlzIGRpc2FibGVkLlxuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfVxuXG4gICAgdmFyIGZhbWlseSA9IHJlc29sdmVGYW1pbHkodHlwZSk7XG5cbiAgICBpZiAoZmFtaWx5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIHJlYWwgZm9yd2FyZFJlZi4gRG9uJ3Qgd2FudCB0byBjcmFzaCBlYXJseS5cbiAgICAgIGlmICh0eXBlICE9PSBudWxsICYmIHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgdHlwZS5yZW5kZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRm9yd2FyZFJlZiBpcyBzcGVjaWFsIGJlY2F1c2UgaXRzIHJlc29sdmVkIC50eXBlIGlzIGFuIG9iamVjdCxcbiAgICAgICAgLy8gYnV0IGl0J3MgcG9zc2libGUgdGhhdCB3ZSBvbmx5IGhhdmUgaXRzIGlubmVyIHJlbmRlciBmdW5jdGlvbiBpbiB0aGUgbWFwLlxuICAgICAgICAvLyBJZiB0aGF0IGlubmVyIHJlbmRlciBmdW5jdGlvbiBpcyBkaWZmZXJlbnQsIHdlJ2xsIGJ1aWxkIGEgbmV3IGZvcndhcmRSZWYgdHlwZS5cbiAgICAgICAgdmFyIGN1cnJlbnRSZW5kZXIgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcodHlwZS5yZW5kZXIpO1xuXG4gICAgICAgIGlmICh0eXBlLnJlbmRlciAhPT0gY3VycmVudFJlbmRlcikge1xuICAgICAgICAgIHZhciBzeW50aGV0aWNUeXBlID0ge1xuICAgICAgICAgICAgJCR0eXBlb2Y6IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUsXG4gICAgICAgICAgICByZW5kZXI6IGN1cnJlbnRSZW5kZXJcbiAgICAgICAgICB9O1xuXG4gICAgICAgICAgaWYgKHR5cGUuZGlzcGxheU5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3ludGhldGljVHlwZS5kaXNwbGF5TmFtZSA9IHR5cGUuZGlzcGxheU5hbWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuIHN5bnRoZXRpY1R5cGU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHR5cGU7XG4gICAgfSAvLyBVc2UgdGhlIGxhdGVzdCBrbm93biBpbXBsZW1lbnRhdGlvbi5cblxuXG4gICAgcmV0dXJuIGZhbWlseS5jdXJyZW50O1xuICB9XG59XG5mdW5jdGlvbiBpc0NvbXBhdGlibGVGYW1pbHlGb3JIb3RSZWxvYWRpbmcoZmliZXIsIGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChyZXNvbHZlRmFtaWx5ID09PSBudWxsKSB7XG4gICAgICAvLyBIb3QgcmVsb2FkaW5nIGlzIGRpc2FibGVkLlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZhciBwcmV2VHlwZSA9IGZpYmVyLmVsZW1lbnRUeXBlO1xuICAgIHZhciBuZXh0VHlwZSA9IGVsZW1lbnQudHlwZTsgLy8gSWYgd2UgZ290IGhlcmUsIHdlIGtub3cgdHlwZXMgYXJlbid0ID09PSBlcXVhbC5cblxuICAgIHZhciBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IGZhbHNlO1xuICAgIHZhciAkJHR5cGVvZk5leHRUeXBlID0gdHlwZW9mIG5leHRUeXBlID09PSAnb2JqZWN0JyAmJiBuZXh0VHlwZSAhPT0gbnVsbCA/IG5leHRUeXBlLiQkdHlwZW9mIDogbnVsbDtcblxuICAgIHN3aXRjaCAoZmliZXIudGFnKSB7XG4gICAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBuZXh0VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgRnVuY3Rpb25Db21wb25lbnQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG5leHRUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmICgkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9MQVpZX1RZUEUpIHtcbiAgICAgICAgICAgIC8vIFdlIGRvbid0IGtub3cgdGhlIGlubmVyIHR5cGUgeWV0LlxuICAgICAgICAgICAgLy8gV2UncmUgZ29pbmcgdG8gYXNzdW1lIHRoYXQgdGhlIGxhenkgaW5uZXIgdHlwZSBpcyBzdGFibGUsXG4gICAgICAgICAgICAvLyBhbmQgc28gaXQgaXMgc3VmZmljaWVudCB0byBhdm9pZCByZWNvbmNpbGluZyBpdCBhd2F5LlxuICAgICAgICAgICAgLy8gV2UncmUgbm90IGdvaW5nIHRvIHVud3JhcCBvciBhY3R1YWxseSB1c2UgdGhlIG5ldyBsYXp5IHR5cGUuXG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICB7XG4gICAgICAgICAgaWYgKCQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUpIHtcbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCQkdHlwZW9mTmV4dFR5cGUgPT09IFJFQUNUX0xBWllfVFlQRSkge1xuICAgICAgICAgICAgbmVlZHNDb21wYXJlRmFtaWxpZXMgPSB0cnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgTWVtb0NvbXBvbmVudDpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAge1xuICAgICAgICAgIGlmICgkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9NRU1PX1RZUEUpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IGlmIGl0IHdhcyBidXQgY2FuIG5vIGxvbmdlciBiZSBzaW1wbGUsXG4gICAgICAgICAgICAvLyB3ZSBzaG91bGRuJ3Qgc2V0IHRoaXMuXG4gICAgICAgICAgICBuZWVkc0NvbXBhcmVGYW1pbGllcyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIGlmICgkJHR5cGVvZk5leHRUeXBlID09PSBSRUFDVF9MQVpZX1RZUEUpIHtcbiAgICAgICAgICAgIG5lZWRzQ29tcGFyZUZhbWlsaWVzID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSAvLyBDaGVjayBpZiBib3RoIHR5cGVzIGhhdmUgYSBmYW1pbHkgYW5kIGl0J3MgdGhlIHNhbWUgb25lLlxuXG5cbiAgICBpZiAobmVlZHNDb21wYXJlRmFtaWxpZXMpIHtcbiAgICAgIC8vIE5vdGU6IG1lbW8oKSBhbmQgZm9yd2FyZFJlZigpIHdlJ2xsIGNvbXBhcmUgb3V0ZXIgcmF0aGVyIHRoYW4gaW5uZXIgdHlwZS5cbiAgICAgIC8vIFRoaXMgbWVhbnMgYm90aCBvZiB0aGVtIG5lZWQgdG8gYmUgcmVnaXN0ZXJlZCB0byBwcmVzZXJ2ZSBzdGF0ZS5cbiAgICAgIC8vIElmIHdlIHVud3JhcHBlZCBhbmQgY29tcGFyZWQgdGhlIGlubmVyIHR5cGVzIGZvciB3cmFwcGVycyBpbnN0ZWFkLFxuICAgICAgLy8gdGhlbiB3ZSB3b3VsZCByaXNrIGZhbHNlbHkgc2F5aW5nIHR3byBzZXBhcmF0ZSBtZW1vKEZvbylcbiAgICAgIC8vIGNhbGxzIGFyZSBlcXVpdmFsZW50IGJlY2F1c2UgdGhleSB3cmFwIHRoZSBzYW1lIEZvbyBmdW5jdGlvbi5cbiAgICAgIHZhciBwcmV2RmFtaWx5ID0gcmVzb2x2ZUZhbWlseShwcmV2VHlwZSk7IC8vICRGbG93Rml4TWVbbm90LWEtZnVuY3Rpb25dIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuICAgICAgaWYgKHByZXZGYW1pbHkgIT09IHVuZGVmaW5lZCAmJiBwcmV2RmFtaWx5ID09PSByZXNvbHZlRmFtaWx5KG5leHRUeXBlKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmZ1bmN0aW9uIG1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nKGZpYmVyKSB7XG4gIHtcbiAgICBpZiAocmVzb2x2ZUZhbWlseSA9PT0gbnVsbCkge1xuICAgICAgLy8gSG90IHJlbG9hZGluZyBpcyBkaXNhYmxlZC5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIFdlYWtTZXQgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZmFpbGVkQm91bmRhcmllcyA9PT0gbnVsbCkge1xuICAgICAgZmFpbGVkQm91bmRhcmllcyA9IG5ldyBXZWFrU2V0KCk7XG4gICAgfVxuXG4gICAgZmFpbGVkQm91bmRhcmllcy5hZGQoZmliZXIpO1xuICB9XG59XG52YXIgc2NoZWR1bGVSZWZyZXNoID0gZnVuY3Rpb24gKHJvb3QsIHVwZGF0ZSkge1xuICB7XG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIC8vIEhvdCByZWxvYWRpbmcgaXMgZGlzYWJsZWQuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHN0YWxlRmFtaWxpZXMgPSB1cGRhdGUuc3RhbGVGYW1pbGllcyxcbiAgICAgICAgdXBkYXRlZEZhbWlsaWVzID0gdXBkYXRlLnVwZGF0ZWRGYW1pbGllcztcbiAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gICAgc2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseShyb290LmN1cnJlbnQsIHVwZGF0ZWRGYW1pbGllcywgc3RhbGVGYW1pbGllcyk7XG4gICAgZmx1c2hTeW5jV29yaygpO1xuICB9XG59O1xudmFyIHNjaGVkdWxlUm9vdCA9IGZ1bmN0aW9uIChyb290LCBlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAocm9vdC5jb250ZXh0ICE9PSBlbXB0eUNvbnRleHRPYmplY3QpIHtcbiAgICAgIC8vIFN1cGVyIGVkZ2UgY2FzZTogcm9vdCBoYXMgYSBsZWdhY3kgX3JlbmRlclN1YnRyZWUgY29udGV4dFxuICAgICAgLy8gYnV0IHdlIGRvbid0IGtub3cgdGhlIHBhcmVudENvbXBvbmVudCBzbyB3ZSBjYW4ndCBwYXNzIGl0LlxuICAgICAgLy8gSnVzdCBpZ25vcmUuIFdlJ2xsIGRlbGV0ZSB0aGlzIHdpdGggX3JlbmRlclN1YnRyZWUgY29kZSBwYXRoIGxhdGVyLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHVwZGF0ZUNvbnRhaW5lclN5bmMoZWxlbWVudCwgcm9vdCwgbnVsbCwgbnVsbCk7XG4gICAgZmx1c2hTeW5jV29yaygpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBzY2hlZHVsZUZpYmVyc1dpdGhGYW1pbGllc1JlY3Vyc2l2ZWx5KGZpYmVyLCB1cGRhdGVkRmFtaWxpZXMsIHN0YWxlRmFtaWxpZXMpIHtcbiAge1xuICAgIHZhciBhbHRlcm5hdGUgPSBmaWJlci5hbHRlcm5hdGUsXG4gICAgICAgIGNoaWxkID0gZmliZXIuY2hpbGQsXG4gICAgICAgIHNpYmxpbmcgPSBmaWJlci5zaWJsaW5nLFxuICAgICAgICB0YWcgPSBmaWJlci50YWcsXG4gICAgICAgIHR5cGUgPSBmaWJlci50eXBlO1xuICAgIHZhciBjYW5kaWRhdGVUeXBlID0gbnVsbDtcblxuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICBjYXNlIEZ1bmN0aW9uQ29tcG9uZW50OlxuICAgICAgY2FzZSBTaW1wbGVNZW1vQ29tcG9uZW50OlxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgY2FuZGlkYXRlVHlwZSA9IHR5cGU7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIEZvcndhcmRSZWY6XG4gICAgICAgIGNhbmRpZGF0ZVR5cGUgPSB0eXBlLnJlbmRlcjtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgaWYgKHJlc29sdmVGYW1pbHkgPT09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgcmVzb2x2ZUZhbWlseSB0byBiZSBzZXQgZHVyaW5nIGhvdCByZWxvYWQuJyk7XG4gICAgfVxuXG4gICAgdmFyIG5lZWRzUmVuZGVyID0gZmFsc2U7XG4gICAgdmFyIG5lZWRzUmVtb3VudCA9IGZhbHNlO1xuXG4gICAgaWYgKGNhbmRpZGF0ZVR5cGUgIT09IG51bGwpIHtcbiAgICAgIHZhciBmYW1pbHkgPSByZXNvbHZlRmFtaWx5KGNhbmRpZGF0ZVR5cGUpO1xuXG4gICAgICBpZiAoZmFtaWx5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHN0YWxlRmFtaWxpZXMuaGFzKGZhbWlseSkpIHtcbiAgICAgICAgICBuZWVkc1JlbW91bnQgPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKHVwZGF0ZWRGYW1pbGllcy5oYXMoZmFtaWx5KSkge1xuICAgICAgICAgIGlmICh0YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgICAgICAgICBuZWVkc1JlbW91bnQgPSB0cnVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZWVkc1JlbmRlciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZhaWxlZEJvdW5kYXJpZXMgIT09IG51bGwpIHtcbiAgICAgIGlmIChmYWlsZWRCb3VuZGFyaWVzLmhhcyhmaWJlcikgfHwgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG4gICAgICBhbHRlcm5hdGUgIT09IG51bGwgJiYgZmFpbGVkQm91bmRhcmllcy5oYXMoYWx0ZXJuYXRlKSkge1xuICAgICAgICBuZWVkc1JlbW91bnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChuZWVkc1JlbW91bnQpIHtcbiAgICAgIGZpYmVyLl9kZWJ1Z05lZWRzUmVtb3VudCA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG5lZWRzUmVtb3VudCB8fCBuZWVkc1JlbmRlcikge1xuICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIFN5bmNMYW5lKTtcblxuICAgICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBTeW5jTGFuZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNoaWxkICE9PSBudWxsICYmICFuZWVkc1JlbW91bnQpIHtcbiAgICAgIHNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkoY2hpbGQsIHVwZGF0ZWRGYW1pbGllcywgc3RhbGVGYW1pbGllcyk7XG4gICAgfVxuXG4gICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgIHNjaGVkdWxlRmliZXJzV2l0aEZhbWlsaWVzUmVjdXJzaXZlbHkoc2libGluZywgdXBkYXRlZEZhbWlsaWVzLCBzdGFsZUZhbWlsaWVzKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGZpbmRIb3N0SW5zdGFuY2VzRm9yUmVmcmVzaCA9IGZ1bmN0aW9uIChyb290LCBmYW1pbGllcykge1xuICB7XG4gICAgdmFyIGhvc3RJbnN0YW5jZXMgPSBuZXcgU2V0KCk7XG4gICAgdmFyIHR5cGVzID0gbmV3IFNldChmYW1pbGllcy5tYXAoZnVuY3Rpb24gKGZhbWlseSkge1xuICAgICAgcmV0dXJuIGZhbWlseS5jdXJyZW50O1xuICAgIH0pKTtcbiAgICBmaW5kSG9zdEluc3RhbmNlc0Zvck1hdGNoaW5nRmliZXJzUmVjdXJzaXZlbHkocm9vdC5jdXJyZW50LCB0eXBlcywgaG9zdEluc3RhbmNlcyk7XG4gICAgcmV0dXJuIGhvc3RJbnN0YW5jZXM7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2VzRm9yTWF0Y2hpbmdGaWJlcnNSZWN1cnNpdmVseShmaWJlciwgdHlwZXMsIGhvc3RJbnN0YW5jZXMpIHtcbiAge1xuICAgIHZhciBjaGlsZCA9IGZpYmVyLmNoaWxkLFxuICAgICAgICBzaWJsaW5nID0gZmliZXIuc2libGluZyxcbiAgICAgICAgdGFnID0gZmliZXIudGFnLFxuICAgICAgICB0eXBlID0gZmliZXIudHlwZTtcbiAgICB2YXIgY2FuZGlkYXRlVHlwZSA9IG51bGw7XG5cbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgIGNhc2UgQ2xhc3NDb21wb25lbnQ6XG4gICAgICAgIGNhbmRpZGF0ZVR5cGUgPSB0eXBlO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICBjYW5kaWRhdGVUeXBlID0gdHlwZS5yZW5kZXI7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBkaWRNYXRjaCA9IGZhbHNlO1xuXG4gICAgaWYgKGNhbmRpZGF0ZVR5cGUgIT09IG51bGwpIHtcbiAgICAgIGlmICh0eXBlcy5oYXMoY2FuZGlkYXRlVHlwZSkpIHtcbiAgICAgICAgZGlkTWF0Y2ggPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChkaWRNYXRjaCkge1xuICAgICAgLy8gV2UgaGF2ZSBhIG1hdGNoLiBUaGlzIG9ubHkgZHJpbGxzIGRvd24gdG8gdGhlIGNsb3Nlc3QgaG9zdCBjb21wb25lbnRzLlxuICAgICAgLy8gVGhlcmUncyBubyBuZWVkIHRvIHNlYXJjaCBkZWVwZXIgYmVjYXVzZSBmb3IgdGhlIHB1cnBvc2Ugb2YgZ2l2aW5nXG4gICAgICAvLyB2aXN1YWwgZmVlZGJhY2ssIFwiZmxhc2hpbmdcIiBvdXRlcm1vc3QgcGFyZW50IHJlY3RhbmdsZXMgaXMgc3VmZmljaWVudC5cbiAgICAgIGZpbmRIb3N0SW5zdGFuY2VzRm9yRmliZXJTaGFsbG93bHkoZmliZXIsIGhvc3RJbnN0YW5jZXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiB0aGVyZSdzIG5vIG1hdGNoLCBtYXliZSB0aGVyZSB3aWxsIGJlIG9uZSBmdXJ0aGVyIGRvd24gaW4gdGhlIGNoaWxkIHRyZWUuXG4gICAgICBpZiAoY2hpbGQgIT09IG51bGwpIHtcbiAgICAgICAgZmluZEhvc3RJbnN0YW5jZXNGb3JNYXRjaGluZ0ZpYmVyc1JlY3Vyc2l2ZWx5KGNoaWxkLCB0eXBlcywgaG9zdEluc3RhbmNlcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHNpYmxpbmcgIT09IG51bGwpIHtcbiAgICAgIGZpbmRIb3N0SW5zdGFuY2VzRm9yTWF0Y2hpbmdGaWJlcnNSZWN1cnNpdmVseShzaWJsaW5nLCB0eXBlcywgaG9zdEluc3RhbmNlcyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2VzRm9yRmliZXJTaGFsbG93bHkoZmliZXIsIGhvc3RJbnN0YW5jZXMpIHtcbiAge1xuICAgIHZhciBmb3VuZEhvc3RJbnN0YW5jZXMgPSBmaW5kQ2hpbGRIb3N0SW5zdGFuY2VzRm9yRmliZXJTaGFsbG93bHkoZmliZXIsIGhvc3RJbnN0YW5jZXMpO1xuXG4gICAgaWYgKGZvdW5kSG9zdEluc3RhbmNlcykge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gSWYgd2UgZGlkbid0IGZpbmQgYW55IGhvc3QgY2hpbGRyZW4sIGZhbGxiYWNrIHRvIGNsb3Nlc3QgaG9zdCBwYXJlbnQuXG5cblxuICAgIHZhciBub2RlID0gZmliZXI7XG5cbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgc3dpdGNoIChub2RlLnRhZykge1xuICAgICAgICBjYXNlIEhvc3RTaW5nbGV0b246XG4gICAgICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgICAgICBob3N0SW5zdGFuY2VzLmFkZChub2RlLnN0YXRlTm9kZSk7XG4gICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgIGNhc2UgSG9zdFBvcnRhbDpcbiAgICAgICAgICBob3N0SW5zdGFuY2VzLmFkZChub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgY2FzZSBIb3N0Um9vdDpcbiAgICAgICAgICBob3N0SW5zdGFuY2VzLmFkZChub2RlLnN0YXRlTm9kZS5jb250YWluZXJJbmZvKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnJldHVybiA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHRvIHJlYWNoIHJvb3QgZmlyc3QuJyk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLnJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZENoaWxkSG9zdEluc3RhbmNlc0ZvckZpYmVyU2hhbGxvd2x5KGZpYmVyLCBob3N0SW5zdGFuY2VzKSB7XG4gIHtcbiAgICB2YXIgbm9kZSA9IGZpYmVyO1xuICAgIHZhciBmb3VuZEhvc3RJbnN0YW5jZXMgPSBmYWxzZTtcblxuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICBpZiAobm9kZS50YWcgPT09IEhvc3RDb21wb25lbnQgfHwgbm9kZS50YWcgPT09IEhvc3RIb2lzdGFibGUgfHwgKHN1cHBvcnRzU2luZ2xldG9ucyA/IG5vZGUudGFnID09PSBIb3N0U2luZ2xldG9uIDogZmFsc2UpKSB7XG4gICAgICAgIC8vIFdlIGdvdCBhIG1hdGNoLlxuICAgICAgICBmb3VuZEhvc3RJbnN0YW5jZXMgPSB0cnVlO1xuICAgICAgICBob3N0SW5zdGFuY2VzLmFkZChub2RlLnN0YXRlTm9kZSk7IC8vIFRoZXJlIG1heSBzdGlsbCBiZSBtb3JlLCBzbyBrZWVwIHNlYXJjaGluZy5cbiAgICAgIH0gZWxzZSBpZiAobm9kZS5jaGlsZCAhPT0gbnVsbCkge1xuICAgICAgICBub2RlLmNoaWxkLnJldHVybiA9IG5vZGU7XG4gICAgICAgIG5vZGUgPSBub2RlLmNoaWxkO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vZGUgPT09IGZpYmVyKSB7XG4gICAgICAgIHJldHVybiBmb3VuZEhvc3RJbnN0YW5jZXM7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChub2RlLnNpYmxpbmcgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKG5vZGUucmV0dXJuID09PSBudWxsIHx8IG5vZGUucmV0dXJuID09PSBmaWJlcikge1xuICAgICAgICAgIHJldHVybiBmb3VuZEhvc3RJbnN0YW5jZXM7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gbm9kZS5yZXR1cm47XG4gICAgICB9XG5cbiAgICAgIG5vZGUuc2libGluZy5yZXR1cm4gPSBub2RlLnJldHVybjtcbiAgICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG52YXIgaGFzQmFkTWFwUG9seWZpbGw7XG5cbntcbiAgaGFzQmFkTWFwUG9seWZpbGwgPSBmYWxzZTtcblxuICB0cnkge1xuICAgIHZhciBub25FeHRlbnNpYmxlT2JqZWN0ID0gT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHt9KTtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1uZXcgKi9cblxuICAgIG5ldyBNYXAoW1tub25FeHRlbnNpYmxlT2JqZWN0LCBudWxsXV0pO1xuICAgIG5ldyBTZXQoW25vbkV4dGVuc2libGVPYmplY3RdKTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLW5ldyAqL1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gVE9ETzogQ29uc2lkZXIgd2FybmluZyBhYm91dCBiYWQgcG9seWZpbGxzXG4gICAgaGFzQmFkTWFwUG9seWZpbGwgPSB0cnVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIEZpYmVyTm9kZSh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSB7XG4gIC8vIEluc3RhbmNlXG4gIHRoaXMudGFnID0gdGFnO1xuICB0aGlzLmtleSA9IGtleTtcbiAgdGhpcy5lbGVtZW50VHlwZSA9IG51bGw7XG4gIHRoaXMudHlwZSA9IG51bGw7XG4gIHRoaXMuc3RhdGVOb2RlID0gbnVsbDsgLy8gRmliZXJcblxuICB0aGlzLnJldHVybiA9IG51bGw7XG4gIHRoaXMuY2hpbGQgPSBudWxsO1xuICB0aGlzLnNpYmxpbmcgPSBudWxsO1xuICB0aGlzLmluZGV4ID0gMDtcbiAgdGhpcy5yZWYgPSBudWxsO1xuICB0aGlzLnJlZkNsZWFudXAgPSBudWxsO1xuICB0aGlzLnBlbmRpbmdQcm9wcyA9IHBlbmRpbmdQcm9wcztcbiAgdGhpcy5tZW1vaXplZFByb3BzID0gbnVsbDtcbiAgdGhpcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gIHRoaXMubWVtb2l6ZWRTdGF0ZSA9IG51bGw7XG4gIHRoaXMuZGVwZW5kZW5jaWVzID0gbnVsbDtcbiAgdGhpcy5tb2RlID0gbW9kZTsgLy8gRWZmZWN0c1xuXG4gIHRoaXMuZmxhZ3MgPSBOb0ZsYWdzJDE7XG4gIHRoaXMuc3VidHJlZUZsYWdzID0gTm9GbGFncyQxO1xuICB0aGlzLmRlbGV0aW9ucyA9IG51bGw7XG4gIHRoaXMubGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLmNoaWxkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLmFsdGVybmF0ZSA9IG51bGw7XG5cbiAge1xuICAgIC8vIE5vdGU6IFRoZSBmb2xsb3dpbmcgaXMgZG9uZSB0byBhdm9pZCBhIHY4IHBlcmZvcm1hbmNlIGNsaWZmLlxuICAgIC8vXG4gICAgLy8gSW5pdGlhbGl6aW5nIHRoZSBmaWVsZHMgYmVsb3cgdG8gc21pcyBhbmQgbGF0ZXIgdXBkYXRpbmcgdGhlbSB3aXRoXG4gICAgLy8gZG91YmxlIHZhbHVlcyB3aWxsIGNhdXNlIEZpYmVycyB0byBlbmQgdXAgaGF2aW5nIHNlcGFyYXRlIHNoYXBlcy5cbiAgICAvLyBUaGlzIGJlaGF2aW9yL2J1ZyBoYXMgc29tZXRoaW5nIHRvIGRvIHdpdGggT2JqZWN0LnByZXZlbnRFeHRlbnNpb24oKS5cbiAgICAvLyBGb3J0dW5hdGVseSB0aGlzIG9ubHkgaW1wYWN0cyBERVYgYnVpbGRzLlxuICAgIC8vIFVuZm9ydHVuYXRlbHkgaXQgbWFrZXMgUmVhY3QgdW51c2FibHkgc2xvdyBmb3Igc29tZSBhcHBsaWNhdGlvbnMuXG4gICAgLy8gVG8gd29yayBhcm91bmQgdGhpcywgaW5pdGlhbGl6ZSB0aGUgZmllbGRzIGJlbG93IHdpdGggZG91Ymxlcy5cbiAgICAvL1xuICAgIC8vIExlYXJuIG1vcmUgYWJvdXQgdGhpcyBoZXJlOlxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTQzNjVcbiAgICAvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD04NTM4XG4gICAgdGhpcy5hY3R1YWxEdXJhdGlvbiA9IE51bWJlci5OYU47XG4gICAgdGhpcy5hY3R1YWxTdGFydFRpbWUgPSBOdW1iZXIuTmFOO1xuICAgIHRoaXMuc2VsZkJhc2VEdXJhdGlvbiA9IE51bWJlci5OYU47XG4gICAgdGhpcy50cmVlQmFzZUR1cmF0aW9uID0gTnVtYmVyLk5hTjsgLy8gSXQncyBva2F5IHRvIHJlcGxhY2UgdGhlIGluaXRpYWwgZG91YmxlcyB3aXRoIHNtaXMgYWZ0ZXIgaW5pdGlhbGl6YXRpb24uXG4gICAgLy8gVGhpcyB3b24ndCB0cmlnZ2VyIHRoZSBwZXJmb3JtYW5jZSBjbGlmZiBtZW50aW9uZWQgYWJvdmUsXG4gICAgLy8gYW5kIGl0IHNpbXBsaWZpZXMgb3RoZXIgcHJvZmlsZXIgY29kZSAoaW5jbHVkaW5nIERldlRvb2xzKS5cblxuICAgIHRoaXMuYWN0dWFsRHVyYXRpb24gPSAwO1xuICAgIHRoaXMuYWN0dWFsU3RhcnRUaW1lID0gLTE7XG4gICAgdGhpcy5zZWxmQmFzZUR1cmF0aW9uID0gMDtcbiAgICB0aGlzLnRyZWVCYXNlRHVyYXRpb24gPSAwO1xuICB9XG5cbiAge1xuICAgIC8vIFRoaXMgaXNuJ3QgZGlyZWN0bHkgdXNlZCBidXQgaXMgaGFuZHkgZm9yIGRlYnVnZ2luZyBpbnRlcm5hbHM6XG4gICAgdGhpcy5fZGVidWdJbmZvID0gbnVsbDtcbiAgICB0aGlzLl9kZWJ1Z093bmVyID0gbnVsbDtcbiAgICB0aGlzLl9kZWJ1Z05lZWRzUmVtb3VudCA9IGZhbHNlO1xuICAgIHRoaXMuX2RlYnVnSG9va1R5cGVzID0gbnVsbDtcblxuICAgIGlmICghaGFzQmFkTWFwUG9seWZpbGwgJiYgdHlwZW9mIE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKHRoaXMpO1xuICAgIH1cbiAgfVxufSAvLyBUaGlzIGlzIGEgY29uc3RydWN0b3IgZnVuY3Rpb24sIHJhdGhlciB0aGFuIGEgUE9KTyBjb25zdHJ1Y3Rvciwgc3RpbGxcbi8vIHBsZWFzZSBlbnN1cmUgd2UgZG8gdGhlIGZvbGxvd2luZzpcbi8vIDEpIE5vYm9keSBzaG91bGQgYWRkIGFueSBpbnN0YW5jZSBtZXRob2RzIG9uIHRoaXMuIEluc3RhbmNlIG1ldGhvZHMgY2FuIGJlXG4vLyAgICBtb3JlIGRpZmZpY3VsdCB0byBwcmVkaWN0IHdoZW4gdGhleSBnZXQgb3B0aW1pemVkIGFuZCB0aGV5IGFyZSBhbG1vc3Rcbi8vICAgIG5ldmVyIGlubGluZWQgcHJvcGVybHkgaW4gc3RhdGljIGNvbXBpbGVycy5cbi8vIDIpIE5vYm9keSBzaG91bGQgcmVseSBvbiBgaW5zdGFuY2VvZiBGaWJlcmAgZm9yIHR5cGUgdGVzdGluZy4gV2Ugc2hvdWxkXG4vLyAgICBhbHdheXMga25vdyB3aGVuIGl0IGlzIGEgZmliZXIuXG4vLyAzKSBXZSBtaWdodCB3YW50IHRvIGV4cGVyaW1lbnQgd2l0aCB1c2luZyBudW1lcmljIGtleXMgc2luY2UgdGhleSBhcmUgZWFzaWVyXG4vLyAgICB0byBvcHRpbWl6ZSBpbiBhIG5vbi1KSVQgZW52aXJvbm1lbnQuXG4vLyA0KSBXZSBjYW4gZWFzaWx5IGdvIGZyb20gYSBjb25zdHJ1Y3RvciB0byBhIGNyZWF0ZUZpYmVyIG9iamVjdCBsaXRlcmFsIGlmIHRoYXRcbi8vICAgIGlzIGZhc3Rlci5cbi8vIDUpIEl0IHNob3VsZCBiZSBlYXN5IHRvIHBvcnQgdGhpcyB0byBhIEMgc3RydWN0IGFuZCBrZWVwIGEgQyBpbXBsZW1lbnRhdGlvblxuLy8gICAgY29tcGF0aWJsZS5cblxuXG5mdW5jdGlvbiBjcmVhdGVGaWJlcih0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKSB7XG4gIC8vICRGbG93Rml4TWVbaW52YWxpZC1jb25zdHJ1Y3Rvcl06IHRoZSBzaGFwZXMgYXJlIGV4YWN0IGhlcmUgYnV0IEZsb3cgZG9lc24ndCBsaWtlIGNvbnN0cnVjdG9yc1xuICByZXR1cm4gbmV3IEZpYmVyTm9kZSh0YWcsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkQ29uc3RydWN0KENvbXBvbmVudCkge1xuICB2YXIgcHJvdG90eXBlID0gQ29tcG9uZW50LnByb3RvdHlwZTtcbiAgcmV0dXJuICEhKHByb3RvdHlwZSAmJiBwcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCk7XG59XG5cbmZ1bmN0aW9uIGlzU2ltcGxlRnVuY3Rpb25Db21wb25lbnQodHlwZSkge1xuICByZXR1cm4gdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicgJiYgIXNob3VsZENvbnN0cnVjdCh0eXBlKSAmJiB0eXBlLmRlZmF1bHRQcm9wcyA9PT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNGdW5jdGlvbkNsYXNzQ29tcG9uZW50KHR5cGUpIHtcbiAgcmV0dXJuIHNob3VsZENvbnN0cnVjdCh0eXBlKTtcbn0gLy8gVGhpcyBpcyB1c2VkIHRvIGNyZWF0ZSBhbiBhbHRlcm5hdGUgZmliZXIgdG8gZG8gd29yayBvbi5cblxuZnVuY3Rpb24gY3JlYXRlV29ya0luUHJvZ3Jlc3MoY3VycmVudCwgcGVuZGluZ1Byb3BzKSB7XG4gIHZhciB3b3JrSW5Qcm9ncmVzcyA9IGN1cnJlbnQuYWx0ZXJuYXRlO1xuXG4gIGlmICh3b3JrSW5Qcm9ncmVzcyA9PT0gbnVsbCkge1xuICAgIC8vIFdlIHVzZSBhIGRvdWJsZSBidWZmZXJpbmcgcG9vbGluZyB0ZWNobmlxdWUgYmVjYXVzZSB3ZSBrbm93IHRoYXQgd2UnbGxcbiAgICAvLyBvbmx5IGV2ZXIgbmVlZCBhdCBtb3N0IHR3byB2ZXJzaW9ucyBvZiBhIHRyZWUuIFdlIHBvb2wgdGhlIFwib3RoZXJcIiB1bnVzZWRcbiAgICAvLyBub2RlIHRoYXQgd2UncmUgZnJlZSB0byByZXVzZS4gVGhpcyBpcyBsYXppbHkgY3JlYXRlZCB0byBhdm9pZCBhbGxvY2F0aW5nXG4gICAgLy8gZXh0cmEgb2JqZWN0cyBmb3IgdGhpbmdzIHRoYXQgYXJlIG5ldmVyIHVwZGF0ZWQuIEl0IGFsc28gYWxsb3cgdXMgdG9cbiAgICAvLyByZWNsYWltIHRoZSBleHRyYSBtZW1vcnkgaWYgbmVlZGVkLlxuICAgIHdvcmtJblByb2dyZXNzID0gY3JlYXRlRmliZXIoY3VycmVudC50YWcsIHBlbmRpbmdQcm9wcywgY3VycmVudC5rZXksIGN1cnJlbnQubW9kZSk7XG4gICAgd29ya0luUHJvZ3Jlc3MuZWxlbWVudFR5cGUgPSBjdXJyZW50LmVsZW1lbnRUeXBlO1xuICAgIHdvcmtJblByb2dyZXNzLnR5cGUgPSBjdXJyZW50LnR5cGU7XG4gICAgd29ya0luUHJvZ3Jlc3Muc3RhdGVOb2RlID0gY3VycmVudC5zdGF0ZU5vZGU7XG5cbiAgICB7XG4gICAgICAvLyBERVYtb25seSBmaWVsZHNcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z093bmVyID0gY3VycmVudC5fZGVidWdPd25lcjtcbiAgICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z0hvb2tUeXBlcyA9IGN1cnJlbnQuX2RlYnVnSG9va1R5cGVzO1xuICAgIH1cblxuICAgIHdvcmtJblByb2dyZXNzLmFsdGVybmF0ZSA9IGN1cnJlbnQ7XG4gICAgY3VycmVudC5hbHRlcm5hdGUgPSB3b3JrSW5Qcm9ncmVzcztcbiAgfSBlbHNlIHtcbiAgICB3b3JrSW5Qcm9ncmVzcy5wZW5kaW5nUHJvcHMgPSBwZW5kaW5nUHJvcHM7IC8vIE5lZWRlZCBiZWNhdXNlIEJsb2NrcyBzdG9yZSBkYXRhIG9uIHR5cGUuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlOyAvLyBXZSBhbHJlYWR5IGhhdmUgYW4gYWx0ZXJuYXRlLlxuICAgIC8vIFJlc2V0IHRoZSBlZmZlY3QgdGFnLlxuXG4gICAgd29ya0luUHJvZ3Jlc3MuZmxhZ3MgPSBOb0ZsYWdzJDE7IC8vIFRoZSBlZmZlY3RzIGFyZSBubyBsb25nZXIgdmFsaWQuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy5zdWJ0cmVlRmxhZ3MgPSBOb0ZsYWdzJDE7XG4gICAgd29ya0luUHJvZ3Jlc3MuZGVsZXRpb25zID0gbnVsbDtcblxuICAgIHtcbiAgICAgIC8vIFdlIGludGVudGlvbmFsbHkgcmVzZXQsIHJhdGhlciB0aGFuIGNvcHksIGFjdHVhbER1cmF0aW9uICYgYWN0dWFsU3RhcnRUaW1lLlxuICAgICAgLy8gVGhpcyBwcmV2ZW50cyB0aW1lIGZyb20gZW5kbGVzc2x5IGFjY3VtdWxhdGluZyBpbiBuZXcgY29tbWl0cy5cbiAgICAgIC8vIFRoaXMgaGFzIHRoZSBkb3duc2lkZSBvZiByZXNldHRpbmcgdmFsdWVzIGZvciBkaWZmZXJlbnQgcHJpb3JpdHkgcmVuZGVycyxcbiAgICAgIC8vIEJ1dCB3b3JrcyBmb3IgeWllbGRpbmcgKHRoZSBjb21tb24gY2FzZSkgYW5kIHNob3VsZCBzdXBwb3J0IHJlc3VtaW5nLlxuICAgICAgd29ya0luUHJvZ3Jlc3MuYWN0dWFsRHVyYXRpb24gPSAwO1xuICAgICAgd29ya0luUHJvZ3Jlc3MuYWN0dWFsU3RhcnRUaW1lID0gLTE7XG4gICAgfVxuICB9IC8vIFJlc2V0IGFsbCBlZmZlY3RzIGV4Y2VwdCBzdGF0aWMgb25lcy5cbiAgLy8gU3RhdGljIGVmZmVjdHMgYXJlIG5vdCBzcGVjaWZpYyB0byBhIHJlbmRlci5cblxuXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzID0gY3VycmVudC5mbGFncyAmIFN0YXRpY01hc2s7XG4gIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBjdXJyZW50LmNoaWxkTGFuZXM7XG4gIHdvcmtJblByb2dyZXNzLmxhbmVzID0gY3VycmVudC5sYW5lcztcbiAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gY3VycmVudC5tZW1vaXplZFByb3BzO1xuICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gY3VycmVudC5tZW1vaXplZFN0YXRlO1xuICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7IC8vIENsb25lIHRoZSBkZXBlbmRlbmNpZXMgb2JqZWN0LiBUaGlzIGlzIG11dGF0ZWQgZHVyaW5nIHRoZSByZW5kZXIgcGhhc2UsIHNvXG4gIC8vIGl0IGNhbm5vdCBiZSBzaGFyZWQgd2l0aCB0aGUgY3VycmVudCBmaWJlci5cblxuICB2YXIgY3VycmVudERlcGVuZGVuY2llcyA9IGN1cnJlbnQuZGVwZW5kZW5jaWVzO1xuICB3b3JrSW5Qcm9ncmVzcy5kZXBlbmRlbmNpZXMgPSBjdXJyZW50RGVwZW5kZW5jaWVzID09PSBudWxsID8gbnVsbCA6IHtcbiAgICBsYW5lczogY3VycmVudERlcGVuZGVuY2llcy5sYW5lcyxcbiAgICBmaXJzdENvbnRleHQ6IGN1cnJlbnREZXBlbmRlbmNpZXMuZmlyc3RDb250ZXh0XG4gIH07IC8vIFRoZXNlIHdpbGwgYmUgb3ZlcnJpZGRlbiBkdXJpbmcgdGhlIHBhcmVudCdzIHJlY29uY2lsaWF0aW9uXG5cbiAgd29ya0luUHJvZ3Jlc3Muc2libGluZyA9IGN1cnJlbnQuc2libGluZztcbiAgd29ya0luUHJvZ3Jlc3MuaW5kZXggPSBjdXJyZW50LmluZGV4O1xuICB3b3JrSW5Qcm9ncmVzcy5yZWYgPSBjdXJyZW50LnJlZjtcbiAgd29ya0luUHJvZ3Jlc3MucmVmQ2xlYW51cCA9IGN1cnJlbnQucmVmQ2xlYW51cDtcblxuICB7XG4gICAgd29ya0luUHJvZ3Jlc3Muc2VsZkJhc2VEdXJhdGlvbiA9IGN1cnJlbnQuc2VsZkJhc2VEdXJhdGlvbjtcbiAgICB3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uID0gY3VycmVudC50cmVlQmFzZUR1cmF0aW9uO1xuICB9XG5cbiAge1xuICAgIHdvcmtJblByb2dyZXNzLl9kZWJ1Z0luZm8gPSBjdXJyZW50Ll9kZWJ1Z0luZm87XG4gICAgd29ya0luUHJvZ3Jlc3MuX2RlYnVnTmVlZHNSZW1vdW50ID0gY3VycmVudC5fZGVidWdOZWVkc1JlbW91bnQ7XG5cbiAgICBzd2l0Y2ggKHdvcmtJblByb2dyZXNzLnRhZykge1xuICAgICAgY2FzZSBGdW5jdGlvbkNvbXBvbmVudDpcbiAgICAgIGNhc2UgU2ltcGxlTWVtb0NvbXBvbmVudDpcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IHJlc29sdmVGdW5jdGlvbkZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBDbGFzc0NvbXBvbmVudDpcbiAgICAgICAgd29ya0luUHJvZ3Jlc3MudHlwZSA9IHJlc29sdmVDbGFzc0ZvckhvdFJlbG9hZGluZyhjdXJyZW50LnR5cGUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBGb3J3YXJkUmVmOlxuICAgICAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gcmVzb2x2ZUZvcndhcmRSZWZGb3JIb3RSZWxvYWRpbmcoY3VycmVudC50eXBlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHdvcmtJblByb2dyZXNzO1xufSAvLyBVc2VkIHRvIHJldXNlIGEgRmliZXIgZm9yIGEgc2Vjb25kIHBhc3MuXG5cbmZ1bmN0aW9uIHJlc2V0V29ya0luUHJvZ3Jlc3Mod29ya0luUHJvZ3Jlc3MsIHJlbmRlckxhbmVzKSB7XG4gIC8vIFRoaXMgcmVzZXRzIHRoZSBGaWJlciB0byB3aGF0IGNyZWF0ZUZpYmVyIG9yIGNyZWF0ZVdvcmtJblByb2dyZXNzIHdvdWxkXG4gIC8vIGhhdmUgc2V0IHRoZSB2YWx1ZXMgdG8gYmVmb3JlIGR1cmluZyB0aGUgZmlyc3QgcGFzcy4gSWRlYWxseSB0aGlzIHdvdWxkbid0XG4gIC8vIGJlIG5lY2Vzc2FyeSBidXQgdW5mb3J0dW5hdGVseSBtYW55IGNvZGUgcGF0aHMgcmVhZHMgZnJvbSB0aGUgd29ya0luUHJvZ3Jlc3NcbiAgLy8gd2hlbiB0aGV5IHNob3VsZCBiZSByZWFkaW5nIGZyb20gY3VycmVudCBhbmQgd3JpdGluZyB0byB3b3JrSW5Qcm9ncmVzcy5cbiAgLy8gV2UgYXNzdW1lIHBlbmRpbmdQcm9wcywgaW5kZXgsIGtleSwgcmVmLCByZXR1cm4gYXJlIHN0aWxsIHVudG91Y2hlZCB0b1xuICAvLyBhdm9pZCBkb2luZyBhbm90aGVyIHJlY29uY2lsaWF0aW9uLlxuICAvLyBSZXNldCB0aGUgZWZmZWN0IGZsYWdzIGJ1dCBrZWVwIGFueSBQbGFjZW1lbnQgdGFncywgc2luY2UgdGhhdCdzIHNvbWV0aGluZ1xuICAvLyB0aGF0IGNoaWxkIGZpYmVyIGlzIHNldHRpbmcsIG5vdCB0aGUgcmVjb25jaWxpYXRpb24uXG4gIHdvcmtJblByb2dyZXNzLmZsYWdzICY9IFN0YXRpY01hc2sgfCBQbGFjZW1lbnQ7IC8vIFRoZSBlZmZlY3RzIGFyZSBubyBsb25nZXIgdmFsaWQuXG5cbiAgdmFyIGN1cnJlbnQgPSB3b3JrSW5Qcm9ncmVzcy5hbHRlcm5hdGU7XG5cbiAgaWYgKGN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAvLyBSZXNldCB0byBjcmVhdGVGaWJlcidzIGluaXRpYWwgdmFsdWVzLlxuICAgIHdvcmtJblByb2dyZXNzLmNoaWxkTGFuZXMgPSBOb0xhbmVzO1xuICAgIHdvcmtJblByb2dyZXNzLmxhbmVzID0gcmVuZGVyTGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IE5vRmxhZ3MkMTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFByb3BzID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5tZW1vaXplZFN0YXRlID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IG51bGw7XG4gICAgd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID0gbnVsbDtcbiAgICB3b3JrSW5Qcm9ncmVzcy5zdGF0ZU5vZGUgPSBudWxsO1xuXG4gICAge1xuICAgICAgLy8gTm90ZTogV2UgZG9uJ3QgcmVzZXQgdGhlIGFjdHVhbFRpbWUgY291bnRzLiBJdCdzIHVzZWZ1bCB0byBhY2N1bXVsYXRlXG4gICAgICAvLyBhY3R1YWwgdGltZSBhY3Jvc3MgbXVsdGlwbGUgcmVuZGVyIHBhc3Nlcy5cbiAgICAgIHdvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb24gPSAwO1xuICAgICAgd29ya0luUHJvZ3Jlc3MudHJlZUJhc2VEdXJhdGlvbiA9IDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFJlc2V0IHRvIHRoZSBjbG9uZWQgdmFsdWVzIHRoYXQgY3JlYXRlV29ya0luUHJvZ3Jlc3Mgd291bGQndmUuXG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGRMYW5lcyA9IGN1cnJlbnQuY2hpbGRMYW5lcztcbiAgICB3b3JrSW5Qcm9ncmVzcy5sYW5lcyA9IGN1cnJlbnQubGFuZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MuY2hpbGQgPSBjdXJyZW50LmNoaWxkO1xuICAgIHdvcmtJblByb2dyZXNzLnN1YnRyZWVGbGFncyA9IE5vRmxhZ3MkMTtcbiAgICB3b3JrSW5Qcm9ncmVzcy5kZWxldGlvbnMgPSBudWxsO1xuICAgIHdvcmtJblByb2dyZXNzLm1lbW9pemVkUHJvcHMgPSBjdXJyZW50Lm1lbW9pemVkUHJvcHM7XG4gICAgd29ya0luUHJvZ3Jlc3MubWVtb2l6ZWRTdGF0ZSA9IGN1cnJlbnQubWVtb2l6ZWRTdGF0ZTtcbiAgICB3b3JrSW5Qcm9ncmVzcy51cGRhdGVRdWV1ZSA9IGN1cnJlbnQudXBkYXRlUXVldWU7IC8vIE5lZWRlZCBiZWNhdXNlIEJsb2NrcyBzdG9yZSBkYXRhIG9uIHR5cGUuXG5cbiAgICB3b3JrSW5Qcm9ncmVzcy50eXBlID0gY3VycmVudC50eXBlOyAvLyBDbG9uZSB0aGUgZGVwZW5kZW5jaWVzIG9iamVjdC4gVGhpcyBpcyBtdXRhdGVkIGR1cmluZyB0aGUgcmVuZGVyIHBoYXNlLCBzb1xuICAgIC8vIGl0IGNhbm5vdCBiZSBzaGFyZWQgd2l0aCB0aGUgY3VycmVudCBmaWJlci5cblxuICAgIHZhciBjdXJyZW50RGVwZW5kZW5jaWVzID0gY3VycmVudC5kZXBlbmRlbmNpZXM7XG4gICAgd29ya0luUHJvZ3Jlc3MuZGVwZW5kZW5jaWVzID0gY3VycmVudERlcGVuZGVuY2llcyA9PT0gbnVsbCA/IG51bGwgOiB7XG4gICAgICBsYW5lczogY3VycmVudERlcGVuZGVuY2llcy5sYW5lcyxcbiAgICAgIGZpcnN0Q29udGV4dDogY3VycmVudERlcGVuZGVuY2llcy5maXJzdENvbnRleHRcbiAgICB9O1xuXG4gICAge1xuICAgICAgLy8gTm90ZTogV2UgZG9uJ3QgcmVzZXQgdGhlIGFjdHVhbFRpbWUgY291bnRzLiBJdCdzIHVzZWZ1bCB0byBhY2N1bXVsYXRlXG4gICAgICAvLyBhY3R1YWwgdGltZSBhY3Jvc3MgbXVsdGlwbGUgcmVuZGVyIHBhc3Nlcy5cbiAgICAgIHdvcmtJblByb2dyZXNzLnNlbGZCYXNlRHVyYXRpb24gPSBjdXJyZW50LnNlbGZCYXNlRHVyYXRpb247XG4gICAgICB3b3JrSW5Qcm9ncmVzcy50cmVlQmFzZUR1cmF0aW9uID0gY3VycmVudC50cmVlQmFzZUR1cmF0aW9uO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB3b3JrSW5Qcm9ncmVzcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZUhvc3RSb290RmliZXIodGFnLCBpc1N0cmljdE1vZGUsIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUpIHtcbiAgdmFyIG1vZGU7XG5cbiAge1xuICAgIG1vZGUgPSBDb25jdXJyZW50TW9kZTtcblxuICAgIGlmIChpc1N0cmljdE1vZGUgPT09IHRydWUpIHtcbiAgICAgIG1vZGUgfD0gU3RyaWN0TGVnYWN5TW9kZSB8IFN0cmljdEVmZmVjdHNNb2RlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpc0RldlRvb2xzUHJlc2VudCkge1xuICAgIC8vIEFsd2F5cyBjb2xsZWN0IHByb2ZpbGUgdGltaW5ncyB3aGVuIERldlRvb2xzIGFyZSBwcmVzZW50LlxuICAgIC8vIFRoaXMgZW5hYmxlcyBEZXZUb29scyB0byBzdGFydCBjYXB0dXJpbmcgdGltaW5nIGF0IGFueSBwb2ludOKAk1xuICAgIC8vIFdpdGhvdXQgc29tZSBub2RlcyBpbiB0aGUgdHJlZSBoYXZpbmcgZW1wdHkgYmFzZSB0aW1lcy5cbiAgICBtb2RlIHw9IFByb2ZpbGVNb2RlO1xuICB9XG5cbiAgcmV0dXJuIGNyZWF0ZUZpYmVyKEhvc3RSb290LCBudWxsLCBudWxsLCBtb2RlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyh0eXBlLCAvLyBSZWFjdCRFbGVtZW50VHlwZVxua2V5LCBwZW5kaW5nUHJvcHMsIG93bmVyLCBtb2RlLCBsYW5lcykge1xuICB2YXIgZmliZXJUYWcgPSBGdW5jdGlvbkNvbXBvbmVudDsgLy8gVGhlIHJlc29sdmVkIHR5cGUgaXMgc2V0IGlmIHdlIGtub3cgd2hhdCB0aGUgZmluYWwgdHlwZSB3aWxsIGJlLiBJLmUuIGl0J3Mgbm90IGxhenkuXG5cbiAgdmFyIHJlc29sdmVkVHlwZSA9IHR5cGU7XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHNob3VsZENvbnN0cnVjdCh0eXBlKSkge1xuICAgICAgZmliZXJUYWcgPSBDbGFzc0NvbXBvbmVudDtcblxuICAgICAge1xuICAgICAgICByZXNvbHZlZFR5cGUgPSByZXNvbHZlQ2xhc3NGb3JIb3RSZWxvYWRpbmcocmVzb2x2ZWRUeXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAge1xuICAgICAgICByZXNvbHZlZFR5cGUgPSByZXNvbHZlRnVuY3Rpb25Gb3JIb3RSZWxvYWRpbmcocmVzb2x2ZWRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHN1cHBvcnRzUmVzb3VyY2VzICYmIHN1cHBvcnRzU2luZ2xldG9ucykge1xuICAgICAgdmFyIGhvc3RDb250ZXh0ID0gZ2V0SG9zdENvbnRleHQoKTtcbiAgICAgIGZpYmVyVGFnID0gaXNIb3N0SG9pc3RhYmxlVHlwZSh0eXBlLCBwZW5kaW5nUHJvcHMsIGhvc3RDb250ZXh0KSA/IEhvc3RIb2lzdGFibGUgOiBpc0hvc3RTaW5nbGV0b25UeXBlKHR5cGUpID8gSG9zdFNpbmdsZXRvbiA6IEhvc3RDb21wb25lbnQ7XG4gICAgfSBlbHNlIGlmIChzdXBwb3J0c1Jlc291cmNlcykge1xuICAgICAgdmFyIF9ob3N0Q29udGV4dCA9IGdldEhvc3RDb250ZXh0KCk7XG5cbiAgICAgIGZpYmVyVGFnID0gaXNIb3N0SG9pc3RhYmxlVHlwZSh0eXBlLCBwZW5kaW5nUHJvcHMsIF9ob3N0Q29udGV4dCkgPyBIb3N0SG9pc3RhYmxlIDogSG9zdENvbXBvbmVudDtcbiAgICB9IGVsc2UgaWYgKHN1cHBvcnRzU2luZ2xldG9ucykge1xuICAgICAgZmliZXJUYWcgPSBpc0hvc3RTaW5nbGV0b25UeXBlKHR5cGUpID8gSG9zdFNpbmdsZXRvbiA6IEhvc3RDb21wb25lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpYmVyVGFnID0gSG9zdENvbXBvbmVudDtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZ2V0VGFnOiBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRlJBR01FTlRfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbUZyYWdtZW50KHBlbmRpbmdQcm9wcy5jaGlsZHJlbiwgbW9kZSwgbGFuZXMsIGtleSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgICAgZmliZXJUYWcgPSBNb2RlO1xuICAgICAgICBtb2RlIHw9IFN0cmljdExlZ2FjeU1vZGU7XG5cbiAgICAgICAge1xuICAgICAgICAgIC8vIFN0cmljdCBlZmZlY3RzIHNob3VsZCBuZXZlciBydW4gb24gbGVnYWN5IHJvb3RzXG4gICAgICAgICAgbW9kZSB8PSBTdHJpY3RFZmZlY3RzTW9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21Qcm9maWxlcihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpO1xuXG4gICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICAgIHJldHVybiBjcmVhdGVGaWJlckZyb21TdXNwZW5zZShwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpO1xuXG4gICAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlTGlzdChwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpO1xuXG4gICAgICBjYXNlIFJFQUNUX09GRlNDUkVFTl9UWVBFOlxuICAgICAgICByZXR1cm4gY3JlYXRlRmliZXJGcm9tT2Zmc2NyZWVuKHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFOlxuXG4gICAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgICAgY2FzZSBSRUFDVF9TQ09QRV9UWVBFOlxuXG4gICAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgICAgY2FzZSBSRUFDVF9UUkFDSU5HX01BUktFUl9UWVBFOlxuXG4gICAgICAvLyBGYWxsIHRocm91Z2hcblxuICAgICAgY2FzZSBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRTpcblxuICAgICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHtcbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgICAgICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG5cbiAgICAgICAgICAgICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgZmliZXJUYWcgPSBDb250ZXh0UHJvdmlkZXI7XG4gICAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfQ09OU1VNRVJfVFlQRTpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBmaWJlclRhZyA9IENvbnRleHRDb25zdW1lcjtcbiAgICAgICAgICAgICAgICAgIGJyZWFrIGdldFRhZztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gRmFsbCB0aHJvdWdoXG5cbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gRm9yd2FyZFJlZjtcblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIHJlc29sdmVkVHlwZSA9IHJlc29sdmVGb3J3YXJkUmVmRm9ySG90UmVsb2FkaW5nKHJlc29sdmVkVHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuXG4gICAgICAgICAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAgICAgICAgIGZpYmVyVGFnID0gTWVtb0NvbXBvbmVudDtcbiAgICAgICAgICAgICAgICBicmVhayBnZXRUYWc7XG5cbiAgICAgICAgICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgICAgICAgICAgZmliZXJUYWcgPSBMYXp5Q29tcG9uZW50O1xuICAgICAgICAgICAgICAgIHJlc29sdmVkVHlwZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgYnJlYWsgZ2V0VGFnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBpbmZvID0gJyc7XG4gICAgICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KHR5cGUpKSB7XG4gICAgICAgICAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgICAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZS50eXBlKSB8fCAnVW5rbm93bicpICsgXCIgLz5cIjtcbiAgICAgICAgICAgICAgaW5mbyA9ICcgRGlkIHlvdSBhY2NpZGVudGFsbHkgZXhwb3J0IGEgSlNYIGxpdGVyYWwgaW5zdGVhZCBvZiBhIGNvbXBvbmVudD8nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdHlwZVN0cmluZyA9IHR5cGVvZiB0eXBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3duZXJOYW1lID0gb3duZXIgPyBnZXRDb21wb25lbnROYW1lRnJvbU93bmVyKG93bmVyKSA6IG51bGw7XG5cbiAgICAgICAgICAgIGlmIChvd25lck5hbWUpIHtcbiAgICAgICAgICAgICAgaW5mbyArPSAnXFxuXFxuQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBvd25lck5hbWUgKyAnYC4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRWxlbWVudCB0eXBlIGlzIGludmFsaWQ6IGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgYnVpbHQtaW4gJyArICdjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpICcgKyAoXCJidXQgZ290OiBcIiArIHR5cGVTdHJpbmcgKyBcIi5cIiArIGluZm8pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKGZpYmVyVGFnLCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gdHlwZTtcbiAgZmliZXIudHlwZSA9IHJlc29sdmVkVHlwZTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcblxuICB7XG4gICAgZmliZXIuX2RlYnVnT3duZXIgPSBvd25lcjtcbiAgfVxuXG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQoZWxlbWVudCwgbW9kZSwgbGFuZXMpIHtcbiAgdmFyIG93bmVyID0gbnVsbDtcblxuICB7XG4gICAgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgfVxuXG4gIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuICB2YXIga2V5ID0gZWxlbWVudC5rZXk7XG4gIHZhciBwZW5kaW5nUHJvcHMgPSBlbGVtZW50LnByb3BzO1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlckZyb21UeXBlQW5kUHJvcHModHlwZSwga2V5LCBwZW5kaW5nUHJvcHMsIG93bmVyLCBtb2RlLCBsYW5lcyk7XG5cbiAge1xuICAgIGZpYmVyLl9kZWJ1Z093bmVyID0gZWxlbWVudC5fb3duZXI7XG4gIH1cblxuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21GcmFnbWVudChlbGVtZW50cywgbW9kZSwgbGFuZXMsIGtleSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihGcmFnbWVudCwgZWxlbWVudHMsIGtleSwgbW9kZSk7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tUHJvZmlsZXIocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIHBlbmRpbmdQcm9wcy5pZCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGVycm9yKCdQcm9maWxlciBtdXN0IHNwZWNpZnkgYW4gXCJpZFwiIG9mIHR5cGUgYHN0cmluZ2AgYXMgYSBwcm9wLiBSZWNlaXZlZCB0aGUgdHlwZSBgJXNgIGluc3RlYWQuJywgdHlwZW9mIHBlbmRpbmdQcm9wcy5pZCk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoUHJvZmlsZXIsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlIHwgUHJvZmlsZU1vZGUpO1xuICBmaWJlci5lbGVtZW50VHlwZSA9IFJFQUNUX1BST0ZJTEVSX1RZUEU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG5cbiAge1xuICAgIGZpYmVyLnN0YXRlTm9kZSA9IHtcbiAgICAgIGVmZmVjdER1cmF0aW9uOiAwLFxuICAgICAgcGFzc2l2ZUVmZmVjdER1cmF0aW9uOiAwXG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tU3VzcGVuc2UocGVuZGluZ1Byb3BzLCBtb2RlLCBsYW5lcywga2V5KSB7XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKFN1c3BlbnNlQ29tcG9uZW50LCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gUkVBQ1RfU1VTUEVOU0VfVFlQRTtcbiAgZmliZXIubGFuZXMgPSBsYW5lcztcbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tU3VzcGVuc2VMaXN0KHBlbmRpbmdQcm9wcywgbW9kZSwgbGFuZXMsIGtleSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihTdXNwZW5zZUxpc3RDb21wb25lbnQsIHBlbmRpbmdQcm9wcywga2V5LCBtb2RlKTtcbiAgZmliZXIuZWxlbWVudFR5cGUgPSBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbihwZW5kaW5nUHJvcHMsIG1vZGUsIGxhbmVzLCBrZXkpIHtcbiAgdmFyIGZpYmVyID0gY3JlYXRlRmliZXIoT2Zmc2NyZWVuQ29tcG9uZW50LCBwZW5kaW5nUHJvcHMsIGtleSwgbW9kZSk7XG4gIGZpYmVyLmVsZW1lbnRUeXBlID0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEU7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHZhciBwcmltYXJ5Q2hpbGRJbnN0YW5jZSA9IHtcbiAgICBfdmlzaWJpbGl0eTogT2Zmc2NyZWVuVmlzaWJsZSxcbiAgICBfcGVuZGluZ1Zpc2liaWxpdHk6IE9mZnNjcmVlblZpc2libGUsXG4gICAgX3BlbmRpbmdNYXJrZXJzOiBudWxsLFxuICAgIF9yZXRyeUNhY2hlOiBudWxsLFxuICAgIF90cmFuc2l0aW9uczogbnVsbCxcbiAgICBfY3VycmVudDogbnVsbCxcbiAgICBkZXRhY2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBkZXRhY2hPZmZzY3JlZW5JbnN0YW5jZShwcmltYXJ5Q2hpbGRJbnN0YW5jZSk7XG4gICAgfSxcbiAgICBhdHRhY2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhdHRhY2hPZmZzY3JlZW5JbnN0YW5jZShwcmltYXJ5Q2hpbGRJbnN0YW5jZSk7XG4gICAgfVxuICB9O1xuICBmaWJlci5zdGF0ZU5vZGUgPSBwcmltYXJ5Q2hpbGRJbnN0YW5jZTtcbiAgcmV0dXJuIGZpYmVyO1xufVxuZnVuY3Rpb24gY3JlYXRlRmliZXJGcm9tVGV4dChjb250ZW50LCBtb2RlLCBsYW5lcykge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihIb3N0VGV4dCwgY29udGVudCwgbnVsbCwgbW9kZSk7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIHJldHVybiBmaWJlcjtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUZpYmVyRnJvbURlaHlkcmF0ZWRGcmFnbWVudChkZWh5ZHJhdGVkTm9kZSkge1xuICB2YXIgZmliZXIgPSBjcmVhdGVGaWJlcihEZWh5ZHJhdGVkRnJhZ21lbnQsIG51bGwsIG51bGwsIE5vTW9kZSk7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IGRlaHlkcmF0ZWROb2RlO1xuICByZXR1cm4gZmliZXI7XG59XG5mdW5jdGlvbiBjcmVhdGVGaWJlckZyb21Qb3J0YWwocG9ydGFsLCBtb2RlLCBsYW5lcykge1xuICB2YXIgcGVuZGluZ1Byb3BzID0gcG9ydGFsLmNoaWxkcmVuICE9PSBudWxsID8gcG9ydGFsLmNoaWxkcmVuIDogW107XG4gIHZhciBmaWJlciA9IGNyZWF0ZUZpYmVyKEhvc3RQb3J0YWwsIHBlbmRpbmdQcm9wcywgcG9ydGFsLmtleSwgbW9kZSk7XG4gIGZpYmVyLmxhbmVzID0gbGFuZXM7XG4gIGZpYmVyLnN0YXRlTm9kZSA9IHtcbiAgICBjb250YWluZXJJbmZvOiBwb3J0YWwuY29udGFpbmVySW5mbyxcbiAgICBwZW5kaW5nQ2hpbGRyZW46IG51bGwsXG4gICAgLy8gVXNlZCBieSBwZXJzaXN0ZW50IHVwZGF0ZXNcbiAgICBpbXBsZW1lbnRhdGlvbjogcG9ydGFsLmltcGxlbWVudGF0aW9uXG4gIH07XG4gIHJldHVybiBmaWJlcjtcbn1cblxuZnVuY3Rpb24gRmliZXJSb290Tm9kZShjb250YWluZXJJbmZvLCAvLyAkRmxvd0ZpeE1lW21pc3NpbmctbG9jYWwtYW5ub3RdXG50YWcsIGh5ZHJhdGUsIGlkZW50aWZpZXJQcmVmaXgsIG9uVW5jYXVnaHRFcnJvciwgb25DYXVnaHRFcnJvciwgb25SZWNvdmVyYWJsZUVycm9yLCBmb3JtU3RhdGUpIHtcbiAgdGhpcy50YWcgPSBDb25jdXJyZW50Um9vdCA7XG4gIHRoaXMuY29udGFpbmVySW5mbyA9IGNvbnRhaW5lckluZm87XG4gIHRoaXMucGVuZGluZ0NoaWxkcmVuID0gbnVsbDtcbiAgdGhpcy5jdXJyZW50ID0gbnVsbDtcbiAgdGhpcy5waW5nQ2FjaGUgPSBudWxsO1xuICB0aGlzLmZpbmlzaGVkV29yayA9IG51bGw7XG4gIHRoaXMudGltZW91dEhhbmRsZSA9IG5vVGltZW91dDtcbiAgdGhpcy5jYW5jZWxQZW5kaW5nQ29tbWl0ID0gbnVsbDtcbiAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgdGhpcy5wZW5kaW5nQ29udGV4dCA9IG51bGw7XG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuY2FsbGJhY2tOb2RlID0gbnVsbDtcbiAgdGhpcy5jYWxsYmFja1ByaW9yaXR5ID0gTm9MYW5lO1xuICB0aGlzLmV4cGlyYXRpb25UaW1lcyA9IGNyZWF0ZUxhbmVNYXAoTm9UaW1lc3RhbXApO1xuICB0aGlzLnBlbmRpbmdMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuc3VzcGVuZGVkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLnBpbmdlZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5leHBpcmVkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLmZpbmlzaGVkTGFuZXMgPSBOb0xhbmVzO1xuICB0aGlzLmVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzID0gTm9MYW5lcztcbiAgdGhpcy5zaGVsbFN1c3BlbmRDb3VudGVyID0gMDtcbiAgdGhpcy5lbnRhbmdsZWRMYW5lcyA9IE5vTGFuZXM7XG4gIHRoaXMuZW50YW5nbGVtZW50cyA9IGNyZWF0ZUxhbmVNYXAoTm9MYW5lcyk7XG4gIHRoaXMuaGlkZGVuVXBkYXRlcyA9IGNyZWF0ZUxhbmVNYXAobnVsbCk7XG4gIHRoaXMuaWRlbnRpZmllclByZWZpeCA9IGlkZW50aWZpZXJQcmVmaXg7XG4gIHRoaXMub25VbmNhdWdodEVycm9yID0gb25VbmNhdWdodEVycm9yO1xuICB0aGlzLm9uQ2F1Z2h0RXJyb3IgPSBvbkNhdWdodEVycm9yO1xuICB0aGlzLm9uUmVjb3ZlcmFibGVFcnJvciA9IG9uUmVjb3ZlcmFibGVFcnJvcjtcblxuICB7XG4gICAgdGhpcy5wb29sZWRDYWNoZSA9IG51bGw7XG4gICAgdGhpcy5wb29sZWRDYWNoZUxhbmVzID0gTm9MYW5lcztcbiAgfVxuXG4gIHRoaXMuZm9ybVN0YXRlID0gZm9ybVN0YXRlO1xuICB0aGlzLmluY29tcGxldGVUcmFuc2l0aW9ucyA9IG5ldyBNYXAoKTtcblxuICB7XG4gICAgdGhpcy5lZmZlY3REdXJhdGlvbiA9IDA7XG4gICAgdGhpcy5wYXNzaXZlRWZmZWN0RHVyYXRpb24gPSAwO1xuICB9XG5cbiAge1xuICAgIHRoaXMubWVtb2l6ZWRVcGRhdGVycyA9IG5ldyBTZXQoKTtcbiAgICB2YXIgcGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCA9IHRoaXMucGVuZGluZ1VwZGF0ZXJzTGFuZU1hcCA9IFtdO1xuXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IFRvdGFsTGFuZXM7IF9pKyspIHtcbiAgICAgIHBlbmRpbmdVcGRhdGVyc0xhbmVNYXAucHVzaChuZXcgU2V0KCkpO1xuICAgIH1cbiAgfVxuXG4gIHtcbiAgICB7XG4gICAgICAvLyBUT0RPOiBUaGlzIHZhcmllcyBieSBlYWNoIHJlbmRlcmVyLlxuICAgICAgdGhpcy5fZGVidWdSb290VHlwZSA9IGh5ZHJhdGUgPyAnaHlkcmF0ZVJvb3QoKScgOiAnY3JlYXRlUm9vdCgpJztcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSwgaW5pdGlhbENoaWxkcmVuLCBoeWRyYXRpb25DYWxsYmFja3MsIGlzU3RyaWN0TW9kZSwgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSwgLy8gVE9ETzogV2UgaGF2ZSBzZXZlcmFsIG9mIHRoZXNlIGFyZ3VtZW50cyB0aGF0IGFyZSBjb25jZXB0dWFsbHkgcGFydCBvZiB0aGVcbi8vIGhvc3QgY29uZmlnLCBidXQgYmVjYXVzZSB0aGV5IGFyZSBwYXNzZWQgaW4gYXQgcnVudGltZSwgd2UgaGF2ZSB0byB0aHJlYWRcbi8vIHRoZW0gdGhyb3VnaCB0aGUgcm9vdCBjb25zdHJ1Y3Rvci4gUGVyaGFwcyB3ZSBzaG91bGQgcHV0IHRoZW0gYWxsIGludG8gYVxuLy8gc2luZ2xlIHR5cGUsIGxpa2UgYSBEeW5hbWljSG9zdENvbmZpZyB0aGF0IGlzIGRlZmluZWQgYnkgdGhlIHJlbmRlcmVyLlxuaWRlbnRpZmllclByZWZpeCwgb25VbmNhdWdodEVycm9yLCBvbkNhdWdodEVycm9yLCBvblJlY292ZXJhYmxlRXJyb3IsIHRyYW5zaXRpb25DYWxsYmFja3MsIGZvcm1TdGF0ZSkge1xuICAvLyAkRmxvd0ZpeE1lW2ludmFsaWQtY29uc3RydWN0b3JdIEZsb3cgbm8gbG9uZ2VyIHN1cHBvcnRzIGNhbGxpbmcgbmV3IG9uIGZ1bmN0aW9uc1xuICB2YXIgcm9vdCA9IG5ldyBGaWJlclJvb3ROb2RlKGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSwgaWRlbnRpZmllclByZWZpeCwgb25VbmNhdWdodEVycm9yLCBvbkNhdWdodEVycm9yLCBvblJlY292ZXJhYmxlRXJyb3IsIGZvcm1TdGF0ZSk7XG4gIC8vIHN0YXRlTm9kZSBpcyBhbnkuXG5cblxuICB2YXIgdW5pbml0aWFsaXplZEZpYmVyID0gY3JlYXRlSG9zdFJvb3RGaWJlcih0YWcsIGlzU3RyaWN0TW9kZSk7XG4gIHJvb3QuY3VycmVudCA9IHVuaW5pdGlhbGl6ZWRGaWJlcjtcbiAgdW5pbml0aWFsaXplZEZpYmVyLnN0YXRlTm9kZSA9IHJvb3Q7XG5cbiAge1xuICAgIHZhciBpbml0aWFsQ2FjaGUgPSBjcmVhdGVDYWNoZSgpO1xuICAgIHJldGFpbkNhY2hlKGluaXRpYWxDYWNoZSk7IC8vIFRoZSBwb29sZWRDYWNoZSBpcyBhIGZyZXNoIGNhY2hlIGluc3RhbmNlIHRoYXQgaXMgdXNlZCB0ZW1wb3JhcmlseVxuICAgIC8vIGZvciBuZXdseSBtb3VudGVkIGJvdW5kYXJpZXMgZHVyaW5nIGEgcmVuZGVyLiBJbiBnZW5lcmFsLCB0aGVcbiAgICAvLyBwb29sZWRDYWNoZSBpcyBhbHdheXMgY2xlYXJlZCBmcm9tIHRoZSByb290IGF0IHRoZSBlbmQgb2YgYSByZW5kZXI6XG4gICAgLy8gaXQgaXMgZWl0aGVyIHJlbGVhc2VkIHdoZW4gcmVuZGVyIGNvbW1pdHMsIG9yIG1vdmVkIHRvIGFuIE9mZnNjcmVlblxuICAgIC8vIGNvbXBvbmVudCBpZiByZW5kZXJpbmcgc3VzcGVuZHMuIEJlY2F1c2UgdGhlIGxpZmV0aW1lIG9mIHRoZSBwb29sZWRcbiAgICAvLyBjYWNoZSBpcyBkaXN0aW5jdCBmcm9tIHRoZSBtYWluIG1lbW9pemVkU3RhdGUuY2FjaGUsIGl0IG11c3QgYmVcbiAgICAvLyByZXRhaW5lZCBzZXBhcmF0ZWx5LlxuXG4gICAgcm9vdC5wb29sZWRDYWNoZSA9IGluaXRpYWxDYWNoZTtcbiAgICByZXRhaW5DYWNoZShpbml0aWFsQ2FjaGUpO1xuICAgIHZhciBpbml0aWFsU3RhdGUgPSB7XG4gICAgICBlbGVtZW50OiBpbml0aWFsQ2hpbGRyZW4sXG4gICAgICBpc0RlaHlkcmF0ZWQ6IGh5ZHJhdGUsXG4gICAgICBjYWNoZTogaW5pdGlhbENhY2hlXG4gICAgfTtcbiAgICB1bmluaXRpYWxpemVkRmliZXIubWVtb2l6ZWRTdGF0ZSA9IGluaXRpYWxTdGF0ZTtcbiAgfVxuXG4gIGluaXRpYWxpemVVcGRhdGVRdWV1ZSh1bmluaXRpYWxpemVkRmliZXIpO1xuICByZXR1cm4gcm9vdDtcbn1cblxudmFyIFJlYWN0VmVyc2lvbiA9ICcxOS4wLjAtcmMtOTM1MTgwYzdlMC0yMDI0MDUyNCc7XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JzsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250YWluZXJJbmZvLCAvLyBUT0RPOiBmaWd1cmUgb3V0IHRoZSBBUEkgZm9yIGNyb3NzLXJlbmRlcmVyIGltcGxlbWVudGF0aW9uLlxuaW1wbGVtZW50YXRpb24pIHtcbiAgdmFyIGtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcblxuICB7XG4gICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihrZXkpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvdyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgUG9ydGFsXG4gICAgJCR0eXBlb2Y6IFJFQUNUX1BPUlRBTF9UWVBFLFxuICAgIGtleToga2V5ID09IG51bGwgPyBudWxsIDogJycgKyBrZXksXG4gICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgIGNvbnRhaW5lckluZm86IGNvbnRhaW5lckluZm8sXG4gICAgaW1wbGVtZW50YXRpb246IGltcGxlbWVudGF0aW9uXG4gIH07XG59XG5cbi8vIE1pZ2h0IGFkZCBQUk9GSUxFIGxhdGVyLlxuXG52YXIgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcztcbnZhciBkaWRXYXJuQWJvdXRGaW5kTm9kZUluU3RyaWN0TW9kZTtcblxue1xuICBkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzID0gZmFsc2U7XG4gIGRpZFdhcm5BYm91dEZpbmROb2RlSW5TdHJpY3RNb2RlID0ge307XG59XG5cbmZ1bmN0aW9uIGdldENvbnRleHRGb3JTdWJ0cmVlKHBhcmVudENvbXBvbmVudCkge1xuICBpZiAoIXBhcmVudENvbXBvbmVudCkge1xuICAgIHJldHVybiBlbXB0eUNvbnRleHRPYmplY3Q7XG4gIH1cblxuICB2YXIgZmliZXIgPSBnZXQocGFyZW50Q29tcG9uZW50KTtcbiAgdmFyIHBhcmVudENvbnRleHQgPSBmaW5kQ3VycmVudFVubWFza2VkQ29udGV4dCgpO1xuXG4gIGlmIChmaWJlci50YWcgPT09IENsYXNzQ29tcG9uZW50KSB7XG4gICAgdmFyIENvbXBvbmVudCA9IGZpYmVyLnR5cGU7XG5cbiAgICBpZiAoaXNDb250ZXh0UHJvdmlkZXIoKSkge1xuICAgICAgcmV0dXJuIHByb2Nlc3NDaGlsZENvbnRleHQoZmliZXIsIENvbXBvbmVudCwgcGFyZW50Q29udGV4dCk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcmVudENvbnRleHQ7XG59XG5cbmZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2UoY29tcG9uZW50KSB7XG4gIHZhciBmaWJlciA9IGdldChjb21wb25lbnQpO1xuXG4gIGlmIChmaWJlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBjb21wb25lbnQucmVuZGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhjb21wb25lbnQpLmpvaW4oJywnKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50IGFwcGVhcnMgdG8gbm90IGJlIGEgUmVhY3RDb21wb25lbnQuIEtleXM6IFwiICsga2V5cyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyKGZpYmVyKTtcblxuICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoaG9zdEZpYmVyLnN0YXRlTm9kZSk7XG59XG5cbmZ1bmN0aW9uIGZpbmRIb3N0SW5zdGFuY2VXaXRoV2FybmluZyhjb21wb25lbnQsIG1ldGhvZE5hbWUpIHtcbiAge1xuICAgIHZhciBmaWJlciA9IGdldChjb21wb25lbnQpO1xuXG4gICAgaWYgKGZpYmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICh0eXBlb2YgY29tcG9uZW50LnJlbmRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIG5vZGUgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoY29tcG9uZW50KS5qb2luKCcsJyk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkFyZ3VtZW50IGFwcGVhcnMgdG8gbm90IGJlIGEgUmVhY3RDb21wb25lbnQuIEtleXM6IFwiICsga2V5cyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyKGZpYmVyKTtcblxuICAgIGlmIChob3N0RmliZXIgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGlmIChob3N0RmliZXIubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihmaWJlcikgfHwgJ0NvbXBvbmVudCc7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGVbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGVbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgICB2YXIgcHJldmlvdXNGaWJlciA9IGN1cnJlbnQ7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKGhvc3RGaWJlcik7XG5cbiAgICAgICAgICBpZiAoZmliZXIubW9kZSAmIFN0cmljdExlZ2FjeU1vZGUpIHtcbiAgICAgICAgICAgIGVycm9yKCclcyBpcyBkZXByZWNhdGVkIGluIFN0cmljdE1vZGUuICcgKyAnJXMgd2FzIHBhc3NlZCBhbiBpbnN0YW5jZSBvZiAlcyB3aGljaCBpcyBpbnNpZGUgU3RyaWN0TW9kZS4gJyArICdJbnN0ZWFkLCBhZGQgYSByZWYgZGlyZWN0bHkgdG8gdGhlIGVsZW1lbnQgeW91IHdhbnQgdG8gcmVmZXJlbmNlLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0LmRldi9saW5rL3N0cmljdC1tb2RlLWZpbmQtbm9kZScsIG1ldGhvZE5hbWUsIG1ldGhvZE5hbWUsIGNvbXBvbmVudE5hbWUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlcnJvcignJXMgaXMgZGVwcmVjYXRlZCBpbiBTdHJpY3RNb2RlLiAnICsgJyVzIHdhcyBwYXNzZWQgYW4gaW5zdGFuY2Ugb2YgJXMgd2hpY2ggcmVuZGVycyBTdHJpY3RNb2RlIGNoaWxkcmVuLiAnICsgJ0luc3RlYWQsIGFkZCBhIHJlZiBkaXJlY3RseSB0byB0aGUgZWxlbWVudCB5b3Ugd2FudCB0byByZWZlcmVuY2UuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3QuZGV2L2xpbmsvc3RyaWN0LW1vZGUtZmluZC1ub2RlJywgbWV0aG9kTmFtZSwgbWV0aG9kTmFtZSwgY29tcG9uZW50TmFtZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgIC8vIElkZWFsbHkgdGhpcyBzaG91bGQgcmVzZXQgdG8gcHJldmlvdXMgYnV0IHRoaXMgc2hvdWxkbid0IGJlIGNhbGxlZCBpblxuICAgICAgICAgIC8vIHJlbmRlciBhbmQgdGhlcmUncyBhbm90aGVyIHdhcm5pbmcgZm9yIHRoYXQgYW55d2F5LlxuICAgICAgICAgIGlmIChwcmV2aW91c0ZpYmVyKSB7XG4gICAgICAgICAgICBzZXRDdXJyZW50RGVidWdGaWJlckluREVWKHByZXZpb3VzRmliZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoaG9zdEZpYmVyLnN0YXRlTm9kZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29udGFpbmVyKGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0aW9uQ2FsbGJhY2tzLCBpc1N0cmljdE1vZGUsIGNvbmN1cnJlbnRVcGRhdGVzQnlEZWZhdWx0T3ZlcnJpZGUsIGlkZW50aWZpZXJQcmVmaXgsIG9uVW5jYXVnaHRFcnJvciwgb25DYXVnaHRFcnJvciwgb25SZWNvdmVyYWJsZUVycm9yLCB0cmFuc2l0aW9uQ2FsbGJhY2tzKSB7XG4gIHZhciBoeWRyYXRlID0gZmFsc2U7XG4gIHZhciBpbml0aWFsQ2hpbGRyZW4gPSBudWxsO1xuICByZXR1cm4gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSwgaW5pdGlhbENoaWxkcmVuLCBoeWRyYXRpb25DYWxsYmFja3MsIGlzU3RyaWN0TW9kZSwgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSwgaWRlbnRpZmllclByZWZpeCwgb25VbmNhdWdodEVycm9yLCBvbkNhdWdodEVycm9yLCBvblJlY292ZXJhYmxlRXJyb3IsIHRyYW5zaXRpb25DYWxsYmFja3MsIG51bGwpO1xufVxuZnVuY3Rpb24gY3JlYXRlSHlkcmF0aW9uQ29udGFpbmVyKGluaXRpYWxDaGlsZHJlbiwgLy8gVE9ETzogUmVtb3ZlIGBjYWxsYmFja2Agd2hlbiB3ZSBkZWxldGUgbGVnYWN5IG1vZGUuXG5jYWxsYmFjaywgY29udGFpbmVySW5mbywgdGFnLCBoeWRyYXRpb25DYWxsYmFja3MsIGlzU3RyaWN0TW9kZSwgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSwgaWRlbnRpZmllclByZWZpeCwgb25VbmNhdWdodEVycm9yLCBvbkNhdWdodEVycm9yLCBvblJlY292ZXJhYmxlRXJyb3IsIHRyYW5zaXRpb25DYWxsYmFja3MsIGZvcm1TdGF0ZSkge1xuICB2YXIgaHlkcmF0ZSA9IHRydWU7XG4gIHZhciByb290ID0gY3JlYXRlRmliZXJSb290KGNvbnRhaW5lckluZm8sIHRhZywgaHlkcmF0ZSwgaW5pdGlhbENoaWxkcmVuLCBoeWRyYXRpb25DYWxsYmFja3MsIGlzU3RyaWN0TW9kZSwgY29uY3VycmVudFVwZGF0ZXNCeURlZmF1bHRPdmVycmlkZSwgaWRlbnRpZmllclByZWZpeCwgb25VbmNhdWdodEVycm9yLCBvbkNhdWdodEVycm9yLCBvblJlY292ZXJhYmxlRXJyb3IsIHRyYW5zaXRpb25DYWxsYmFja3MsIGZvcm1TdGF0ZSk7IC8vIFRPRE86IE1vdmUgdGhpcyB0byBGaWJlclJvb3QgY29uc3RydWN0b3JcblxuICByb290LmNvbnRleHQgPSBnZXRDb250ZXh0Rm9yU3VidHJlZShudWxsKTsgLy8gU2NoZWR1bGUgdGhlIGluaXRpYWwgcmVuZGVyLiBJbiBhIGh5ZHJhdGlvbiByb290LCB0aGlzIGlzIGRpZmZlcmVudCBmcm9tXG4gIC8vIGEgcmVndWxhciB1cGRhdGUgYmVjYXVzZSB0aGUgaW5pdGlhbCByZW5kZXIgbXVzdCBtYXRjaCB3YXMgd2FzIHJlbmRlcmVkXG4gIC8vIG9uIHRoZSBzZXJ2ZXIuXG4gIC8vIE5PVEU6IFRoaXMgdXBkYXRlIGludGVudGlvbmFsbHkgZG9lc24ndCBoYXZlIGEgcGF5bG9hZC4gV2UncmUgb25seSB1c2luZ1xuICAvLyB0aGUgdXBkYXRlIHRvIHNjaGVkdWxlIHdvcmsgb24gdGhlIHJvb3QgZmliZXIgKGFuZCwgZm9yIGxlZ2FjeSByb290cywgdG9cbiAgLy8gZW5xdWV1ZSB0aGUgY2FsbGJhY2sgaWYgb25lIGlzIHByb3ZpZGVkKS5cblxuICB2YXIgY3VycmVudCA9IHJvb3QuY3VycmVudDtcbiAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShjdXJyZW50KTtcbiAgdmFyIHVwZGF0ZSA9IGNyZWF0ZVVwZGF0ZShsYW5lKTtcbiAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2sgIT09IHVuZGVmaW5lZCAmJiBjYWxsYmFjayAhPT0gbnVsbCA/IGNhbGxiYWNrIDogbnVsbDtcbiAgZW5xdWV1ZVVwZGF0ZShjdXJyZW50LCB1cGRhdGUsIGxhbmUpO1xuICBzY2hlZHVsZUluaXRpYWxIeWRyYXRpb25PblJvb3Qocm9vdCwgbGFuZSk7XG4gIHJldHVybiByb290O1xufVxuZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyKGVsZW1lbnQsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjaykge1xuICB2YXIgY3VycmVudCA9IGNvbnRhaW5lci5jdXJyZW50O1xuICB2YXIgbGFuZSA9IHJlcXVlc3RVcGRhdGVMYW5lKGN1cnJlbnQpO1xuICB1cGRhdGVDb250YWluZXJJbXBsKGN1cnJlbnQsIGxhbmUsIGVsZW1lbnQsIGNvbnRhaW5lciwgcGFyZW50Q29tcG9uZW50LCBjYWxsYmFjayk7XG4gIHJldHVybiBsYW5lO1xufVxuZnVuY3Rpb24gdXBkYXRlQ29udGFpbmVyU3luYyhlbGVtZW50LCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgY2FsbGJhY2spIHtcbiAgaWYgKGNvbnRhaW5lci50YWcgPT09IExlZ2FjeVJvb3QpIHtcbiAgICBmbHVzaFBhc3NpdmVFZmZlY3RzKCk7XG4gIH1cblxuICB2YXIgY3VycmVudCA9IGNvbnRhaW5lci5jdXJyZW50O1xuICB1cGRhdGVDb250YWluZXJJbXBsKGN1cnJlbnQsIFN5bmNMYW5lLCBlbGVtZW50LCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgY2FsbGJhY2spO1xuICByZXR1cm4gU3luY0xhbmU7XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUNvbnRhaW5lckltcGwocm9vdEZpYmVyLCBsYW5lLCBlbGVtZW50LCBjb250YWluZXIsIHBhcmVudENvbXBvbmVudCwgY2FsbGJhY2spIHtcbiAge1xuICAgIG9uU2NoZWR1bGVSb290KGNvbnRhaW5lciwgZWxlbWVudCk7XG4gIH1cblxuICB7XG4gICAgbWFya1JlbmRlclNjaGVkdWxlZChsYW5lKTtcbiAgfVxuXG4gIHZhciBjb250ZXh0ID0gZ2V0Q29udGV4dEZvclN1YnRyZWUocGFyZW50Q29tcG9uZW50KTtcblxuICBpZiAoY29udGFpbmVyLmNvbnRleHQgPT09IG51bGwpIHtcbiAgICBjb250YWluZXIuY29udGV4dCA9IGNvbnRleHQ7XG4gIH0gZWxzZSB7XG4gICAgY29udGFpbmVyLnBlbmRpbmdDb250ZXh0ID0gY29udGV4dDtcbiAgfVxuXG4gIHtcbiAgICBpZiAoaXNSZW5kZXJpbmcgJiYgY3VycmVudCAhPT0gbnVsbCAmJiAhZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcykge1xuICAgICAgZGlkV2FybkFib3V0TmVzdGVkVXBkYXRlcyA9IHRydWU7XG5cbiAgICAgIGVycm9yKCdSZW5kZXIgbWV0aG9kcyBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZTsgJyArICd0cmlnZ2VyaW5nIG5lc3RlZCBjb21wb25lbnQgdXBkYXRlcyBmcm9tIHJlbmRlciBpcyBub3QgYWxsb3dlZC4gJyArICdJZiBuZWNlc3NhcnksIHRyaWdnZXIgbmVzdGVkIHVwZGF0ZXMgaW4gY29tcG9uZW50RGlkVXBkYXRlLlxcblxcbicgKyAnQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJXMuJywgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcihjdXJyZW50KSB8fCAnVW5rbm93bicpO1xuICAgIH1cbiAgfVxuXG4gIHZhciB1cGRhdGUgPSBjcmVhdGVVcGRhdGUobGFuZSk7IC8vIENhdXRpb246IFJlYWN0IERldlRvb2xzIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJvcGVydHlcbiAgLy8gYmVpbmcgY2FsbGVkIFwiZWxlbWVudFwiLlxuXG4gIHVwZGF0ZS5wYXlsb2FkID0ge1xuICAgIGVsZW1lbnQ6IGVsZW1lbnRcbiAgfTtcbiAgY2FsbGJhY2sgPSBjYWxsYmFjayA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNhbGxiYWNrO1xuXG4gIGlmIChjYWxsYmFjayAhPT0gbnVsbCkge1xuICAgIHtcbiAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZXJyb3IoJ0V4cGVjdGVkIHRoZSBsYXN0IG9wdGlvbmFsIGBjYWxsYmFja2AgYXJndW1lbnQgdG8gYmUgYSAnICsgJ2Z1bmN0aW9uLiBJbnN0ZWFkIHJlY2VpdmVkOiAlcy4nLCBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdXBkYXRlLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gIH1cblxuICB2YXIgcm9vdCA9IGVucXVldWVVcGRhdGUocm9vdEZpYmVyLCB1cGRhdGUsIGxhbmUpO1xuXG4gIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIHJvb3RGaWJlciwgbGFuZSk7XG4gICAgZW50YW5nbGVUcmFuc2l0aW9ucyhyb290LCByb290RmliZXIsIGxhbmUpO1xuICB9XG59XG5mdW5jdGlvbiBnZXRQdWJsaWNSb290SW5zdGFuY2UoY29udGFpbmVyKSB7XG4gIHZhciBjb250YWluZXJGaWJlciA9IGNvbnRhaW5lci5jdXJyZW50O1xuXG4gIGlmICghY29udGFpbmVyRmliZXIuY2hpbGQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHN3aXRjaCAoY29udGFpbmVyRmliZXIuY2hpbGQudGFnKSB7XG4gICAgY2FzZSBIb3N0U2luZ2xldG9uOlxuICAgIGNhc2UgSG9zdENvbXBvbmVudDpcbiAgICAgIHJldHVybiBnZXRQdWJsaWNJbnN0YW5jZShjb250YWluZXJGaWJlci5jaGlsZC5zdGF0ZU5vZGUpO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBjb250YWluZXJGaWJlci5jaGlsZC5zdGF0ZU5vZGU7XG4gIH1cbn1cbmZ1bmN0aW9uIGF0dGVtcHRTeW5jaHJvbm91c0h5ZHJhdGlvbihmaWJlcikge1xuICBzd2l0Y2ggKGZpYmVyLnRhZykge1xuICAgIGNhc2UgSG9zdFJvb3Q6XG4gICAgICB7XG4gICAgICAgIHZhciByb290ID0gZmliZXIuc3RhdGVOb2RlO1xuXG4gICAgICAgIGlmIChpc1Jvb3REZWh5ZHJhdGVkKHJvb3QpKSB7XG4gICAgICAgICAgLy8gRmx1c2ggdGhlIGZpcnN0IHNjaGVkdWxlZCBcInVwZGF0ZVwiLlxuICAgICAgICAgIHZhciBsYW5lcyA9IGdldEhpZ2hlc3RQcmlvcml0eVBlbmRpbmdMYW5lcyhyb290KTtcbiAgICAgICAgICBmbHVzaFJvb3Qocm9vdCwgbGFuZXMpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICBjYXNlIFN1c3BlbnNlQ29tcG9uZW50OlxuICAgICAge1xuICAgICAgICB2YXIgX3Jvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIFN5bmNMYW5lKTtcblxuICAgICAgICBpZiAoX3Jvb3QgIT09IG51bGwpIHtcbiAgICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIoX3Jvb3QsIGZpYmVyLCBTeW5jTGFuZSk7XG4gICAgICAgIH1cblxuICAgICAgICBmbHVzaFN5bmNXb3JrKCk7IC8vIElmIHdlJ3JlIHN0aWxsIGJsb2NrZWQgYWZ0ZXIgdGhpcywgd2UgbmVlZCB0byBpbmNyZWFzZVxuICAgICAgICAvLyB0aGUgcHJpb3JpdHkgb2YgYW55IHByb21pc2VzIHJlc29sdmluZyB3aXRoaW4gdGhpc1xuICAgICAgICAvLyBib3VuZGFyeSBzbyB0aGF0IHRoZXkgbmV4dCBhdHRlbXB0IGFsc28gaGFzIGhpZ2hlciBwcmkuXG5cbiAgICAgICAgdmFyIHJldHJ5TGFuZSA9IFN5bmNMYW5lO1xuICAgICAgICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgcmV0cnlMYW5lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1JldHJ5TGFuZUltcGwoZmliZXIsIHJldHJ5TGFuZSkge1xuICB2YXIgc3VzcGVuc2VTdGF0ZSA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG5cbiAgaWYgKHN1c3BlbnNlU3RhdGUgIT09IG51bGwgJiYgc3VzcGVuc2VTdGF0ZS5kZWh5ZHJhdGVkICE9PSBudWxsKSB7XG4gICAgc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUgPSBoaWdoZXJQcmlvcml0eUxhbmUoc3VzcGVuc2VTdGF0ZS5yZXRyeUxhbmUsIHJldHJ5TGFuZSk7XG4gIH1cbn0gLy8gSW5jcmVhc2VzIHRoZSBwcmlvcml0eSBvZiB0aGVuYWJsZXMgd2hlbiB0aGV5IHJlc29sdmUgd2l0aGluIHRoaXMgYm91bmRhcnkuXG5cblxuZnVuY3Rpb24gbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIHJldHJ5TGFuZSkge1xuICBtYXJrUmV0cnlMYW5lSW1wbChmaWJlciwgcmV0cnlMYW5lKTtcbiAgdmFyIGFsdGVybmF0ZSA9IGZpYmVyLmFsdGVybmF0ZTtcblxuICBpZiAoYWx0ZXJuYXRlKSB7XG4gICAgbWFya1JldHJ5TGFuZUltcGwoYWx0ZXJuYXRlLCByZXRyeUxhbmUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uKGZpYmVyKSB7XG4gIGlmIChmaWJlci50YWcgIT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgLy8gV2UgaWdub3JlIEhvc3RSb290cyBoZXJlIGJlY2F1c2Ugd2UgY2FuJ3QgaW5jcmVhc2VcbiAgICAvLyB0aGVpciBwcmlvcml0eSBhbmQgdGhleSBzaG91bGQgbm90IHN1c3BlbmQgb24gSS9PLFxuICAgIC8vIHNpbmNlIHlvdSBoYXZlIHRvIHdyYXAgYW55dGhpbmcgdGhhdCBtaWdodCBzdXNwZW5kIGluXG4gICAgLy8gU3VzcGVuc2UuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGxhbmUgPSBTZWxlY3RpdmVIeWRyYXRpb25MYW5lO1xuICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgbGFuZSk7XG5cbiAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIGxhbmUpO1xuICB9XG5cbiAgbWFya1JldHJ5TGFuZUlmTm90SHlkcmF0ZWQoZmliZXIsIGxhbmUpO1xufVxuZnVuY3Rpb24gYXR0ZW1wdEh5ZHJhdGlvbkF0Q3VycmVudFByaW9yaXR5KGZpYmVyKSB7XG4gIGlmIChmaWJlci50YWcgIT09IFN1c3BlbnNlQ29tcG9uZW50KSB7XG4gICAgLy8gV2UgaWdub3JlIEhvc3RSb290cyBoZXJlIGJlY2F1c2Ugd2UgY2FuJ3QgaW5jcmVhc2VcbiAgICAvLyB0aGVpciBwcmlvcml0eSBvdGhlciB0aGFuIHN5bmNocm9ub3VzbHkgZmx1c2ggaXQuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGxhbmUgPSByZXF1ZXN0VXBkYXRlTGFuZShmaWJlcik7XG4gIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBsYW5lKTtcblxuICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgbGFuZSk7XG4gIH1cblxuICBtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZChmaWJlciwgbGFuZSk7XG59XG5mdW5jdGlvbiBmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyhmaWJlcikge1xuICB2YXIgaG9zdEZpYmVyID0gZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzKGZpYmVyKTtcblxuICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gZ2V0UHVibGljSW5zdGFuY2UoaG9zdEZpYmVyLnN0YXRlTm9kZSk7XG59XG5cbnZhciBzaG91bGRFcnJvckltcGwgPSBmdW5jdGlvbiAoZmliZXIpIHtcbiAgcmV0dXJuIG51bGw7XG59O1xuXG5mdW5jdGlvbiBzaG91bGRFcnJvcihmaWJlcikge1xuICByZXR1cm4gc2hvdWxkRXJyb3JJbXBsKGZpYmVyKTtcbn1cblxudmFyIHNob3VsZFN1c3BlbmRJbXBsID0gZnVuY3Rpb24gKGZpYmVyKSB7XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbmZ1bmN0aW9uIHNob3VsZFN1c3BlbmQoZmliZXIpIHtcbiAgcmV0dXJuIHNob3VsZFN1c3BlbmRJbXBsKGZpYmVyKTtcbn1cbnZhciBvdmVycmlkZUhvb2tTdGF0ZSA9IG51bGw7XG52YXIgb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoID0gbnVsbDtcbnZhciBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGggPSBudWxsO1xudmFyIG92ZXJyaWRlUHJvcHMgPSBudWxsO1xudmFyIG92ZXJyaWRlUHJvcHNEZWxldGVQYXRoID0gbnVsbDtcbnZhciBvdmVycmlkZVByb3BzUmVuYW1lUGF0aCA9IG51bGw7XG52YXIgc2NoZWR1bGVVcGRhdGUgPSBudWxsO1xudmFyIHNldEVycm9ySGFuZGxlciA9IG51bGw7XG52YXIgc2V0U3VzcGVuc2VIYW5kbGVyID0gbnVsbDtcblxue1xuICB2YXIgY29weVdpdGhEZWxldGVJbXBsID0gZnVuY3Rpb24gKG9iaiwgcGF0aCwgaW5kZXgpIHtcbiAgICB2YXIga2V5ID0gcGF0aFtpbmRleF07XG4gICAgdmFyIHVwZGF0ZWQgPSBpc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IGFzc2lnbih7fSwgb2JqKTtcblxuICAgIGlmIChpbmRleCArIDEgPT09IHBhdGgubGVuZ3RoKSB7XG4gICAgICBpZiAoaXNBcnJheSh1cGRhdGVkKSkge1xuICAgICAgICB1cGRhdGVkLnNwbGljZShrZXksIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVsZXRlIHVwZGF0ZWRba2V5XTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVwZGF0ZWQ7XG4gICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG5cblxuICAgIHVwZGF0ZWRba2V5XSA9IGNvcHlXaXRoRGVsZXRlSW1wbChvYmpba2V5XSwgcGF0aCwgaW5kZXggKyAxKTtcbiAgICByZXR1cm4gdXBkYXRlZDtcbiAgfTtcblxuICB2YXIgY29weVdpdGhEZWxldGUgPSBmdW5jdGlvbiAob2JqLCBwYXRoKSB7XG4gICAgcmV0dXJuIGNvcHlXaXRoRGVsZXRlSW1wbChvYmosIHBhdGgsIDApO1xuICB9O1xuXG4gIHZhciBjb3B5V2l0aFJlbmFtZUltcGwgPSBmdW5jdGlvbiAob2JqLCBvbGRQYXRoLCBuZXdQYXRoLCBpbmRleCkge1xuICAgIHZhciBvbGRLZXkgPSBvbGRQYXRoW2luZGV4XTtcbiAgICB2YXIgdXBkYXRlZCA9IGlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogYXNzaWduKHt9LCBvYmopO1xuXG4gICAgaWYgKGluZGV4ICsgMSA9PT0gb2xkUGF0aC5sZW5ndGgpIHtcbiAgICAgIHZhciBuZXdLZXkgPSBuZXdQYXRoW2luZGV4XTsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuXG4gICAgICB1cGRhdGVkW25ld0tleV0gPSB1cGRhdGVkW29sZEtleV07XG5cbiAgICAgIGlmIChpc0FycmF5KHVwZGF0ZWQpKSB7XG4gICAgICAgIHVwZGF0ZWQuc3BsaWNlKG9sZEtleSwgMSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkZWxldGUgdXBkYXRlZFtvbGRLZXldO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS11c2VdIG51bWJlciBvciBzdHJpbmcgaXMgZmluZSBoZXJlXG4gICAgICB1cGRhdGVkW29sZEtleV0gPSBjb3B5V2l0aFJlbmFtZUltcGwoIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXVzZV0gbnVtYmVyIG9yIHN0cmluZyBpcyBmaW5lIGhlcmVcbiAgICAgIG9ialtvbGRLZXldLCBvbGRQYXRoLCBuZXdQYXRoLCBpbmRleCArIDEpO1xuICAgIH1cblxuICAgIHJldHVybiB1cGRhdGVkO1xuICB9O1xuXG4gIHZhciBjb3B5V2l0aFJlbmFtZSA9IGZ1bmN0aW9uIChvYmosIG9sZFBhdGgsIG5ld1BhdGgpIHtcbiAgICBpZiAob2xkUGF0aC5sZW5ndGggIT09IG5ld1BhdGgubGVuZ3RoKSB7XG4gICAgICB3YXJuKCdjb3B5V2l0aFJlbmFtZSgpIGV4cGVjdHMgcGF0aHMgb2YgdGhlIHNhbWUgbGVuZ3RoJyk7XG5cbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2Uge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdQYXRoLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICBpZiAob2xkUGF0aFtpXSAhPT0gbmV3UGF0aFtpXSkge1xuICAgICAgICAgIHdhcm4oJ2NvcHlXaXRoUmVuYW1lKCkgZXhwZWN0cyBwYXRocyB0byBiZSB0aGUgc2FtZSBleGNlcHQgZm9yIHRoZSBkZWVwZXN0IGtleScpO1xuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvcHlXaXRoUmVuYW1lSW1wbChvYmosIG9sZFBhdGgsIG5ld1BhdGgsIDApO1xuICB9O1xuXG4gIHZhciBjb3B5V2l0aFNldEltcGwgPSBmdW5jdGlvbiAob2JqLCBwYXRoLCBpbmRleCwgdmFsdWUpIHtcbiAgICBpZiAoaW5kZXggPj0gcGF0aC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG5cbiAgICB2YXIga2V5ID0gcGF0aFtpbmRleF07XG4gICAgdmFyIHVwZGF0ZWQgPSBpc0FycmF5KG9iaikgPyBvYmouc2xpY2UoKSA6IGFzc2lnbih7fSwgb2JqKTsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBudW1iZXIgb3Igc3RyaW5nIGlzIGZpbmUgaGVyZVxuXG4gICAgdXBkYXRlZFtrZXldID0gY29weVdpdGhTZXRJbXBsKG9ialtrZXldLCBwYXRoLCBpbmRleCArIDEsIHZhbHVlKTtcbiAgICByZXR1cm4gdXBkYXRlZDtcbiAgfTtcblxuICB2YXIgY29weVdpdGhTZXQgPSBmdW5jdGlvbiAob2JqLCBwYXRoLCB2YWx1ZSkge1xuICAgIHJldHVybiBjb3B5V2l0aFNldEltcGwob2JqLCBwYXRoLCAwLCB2YWx1ZSk7XG4gIH07XG5cbiAgdmFyIGZpbmRIb29rID0gZnVuY3Rpb24gKGZpYmVyLCBpZCkge1xuICAgIC8vIEZvciBub3csIHRoZSBcImlkXCIgb2Ygc3RhdGVmdWwgaG9va3MgaXMganVzdCB0aGUgc3RhdGVmdWwgaG9vayBpbmRleC5cbiAgICAvLyBUaGlzIG1heSBjaGFuZ2UgaW4gdGhlIGZ1dHVyZSB3aXRoIGUuZy4gbmVzdGVkIGhvb2tzLlxuICAgIHZhciBjdXJyZW50SG9vayA9IGZpYmVyLm1lbW9pemVkU3RhdGU7XG5cbiAgICB3aGlsZSAoY3VycmVudEhvb2sgIT09IG51bGwgJiYgaWQgPiAwKSB7XG4gICAgICBjdXJyZW50SG9vayA9IGN1cnJlbnRIb29rLm5leHQ7XG4gICAgICBpZC0tO1xuICAgIH1cblxuICAgIHJldHVybiBjdXJyZW50SG9vaztcbiAgfTsgLy8gU3VwcG9ydCBEZXZUb29scyBlZGl0YWJsZSB2YWx1ZXMgZm9yIHVzZVN0YXRlIGFuZCB1c2VSZWR1Y2VyLlxuXG5cbiAgb3ZlcnJpZGVIb29rU3RhdGUgPSBmdW5jdGlvbiAoZmliZXIsIGlkLCBwYXRoLCB2YWx1ZSkge1xuICAgIHZhciBob29rID0gZmluZEhvb2soZmliZXIsIGlkKTtcblxuICAgIGlmIChob29rICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV3U3RhdGUgPSBjb3B5V2l0aFNldChob29rLm1lbW9pemVkU3RhdGUsIHBhdGgsIHZhbHVlKTtcbiAgICAgIGhvb2subWVtb2l6ZWRTdGF0ZSA9IG5ld1N0YXRlO1xuICAgICAgaG9vay5iYXNlU3RhdGUgPSBuZXdTdGF0ZTsgLy8gV2UgYXJlbid0IGFjdHVhbGx5IGFkZGluZyBhbiB1cGRhdGUgdG8gdGhlIHF1ZXVlLFxuICAgICAgLy8gYmVjYXVzZSB0aGVyZSBpcyBubyB1cGRhdGUgd2UgY2FuIGFkZCBmb3IgdXNlUmVkdWNlciBob29rcyB0aGF0IHdvbid0IHRyaWdnZXIgYW4gZXJyb3IuXG4gICAgICAvLyAoVGhlcmUncyBubyBhcHByb3ByaWF0ZSBhY3Rpb24gdHlwZSBmb3IgRGV2VG9vbHMgb3ZlcnJpZGVzLilcbiAgICAgIC8vIEFzIGEgcmVzdWx0IHRob3VnaCwgUmVhY3Qgd2lsbCBzZWUgdGhlIHNjaGVkdWxlZCB1cGRhdGUgYXMgYSBub29wIGFuZCBiYWlsb3V0LlxuICAgICAgLy8gU2hhbGxvdyBjbG9uaW5nIHByb3BzIHdvcmtzIGFzIGEgd29ya2Fyb3VuZCBmb3Igbm93IHRvIGJ5cGFzcyB0aGUgYmFpbG91dCBjaGVjay5cblxuICAgICAgZmliZXIubWVtb2l6ZWRQcm9wcyA9IGFzc2lnbih7fSwgZmliZXIubWVtb2l6ZWRQcm9wcyk7XG4gICAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgU3luY0xhbmUpO1xuXG4gICAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgICBzY2hlZHVsZVVwZGF0ZU9uRmliZXIocm9vdCwgZmliZXIsIFN5bmNMYW5lKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoID0gZnVuY3Rpb24gKGZpYmVyLCBpZCwgcGF0aCkge1xuICAgIHZhciBob29rID0gZmluZEhvb2soZmliZXIsIGlkKTtcblxuICAgIGlmIChob29rICE9PSBudWxsKSB7XG4gICAgICB2YXIgbmV3U3RhdGUgPSBjb3B5V2l0aERlbGV0ZShob29rLm1lbW9pemVkU3RhdGUsIHBhdGgpO1xuICAgICAgaG9vay5tZW1vaXplZFN0YXRlID0gbmV3U3RhdGU7XG4gICAgICBob29rLmJhc2VTdGF0ZSA9IG5ld1N0YXRlOyAvLyBXZSBhcmVuJ3QgYWN0dWFsbHkgYWRkaW5nIGFuIHVwZGF0ZSB0byB0aGUgcXVldWUsXG4gICAgICAvLyBiZWNhdXNlIHRoZXJlIGlzIG5vIHVwZGF0ZSB3ZSBjYW4gYWRkIGZvciB1c2VSZWR1Y2VyIGhvb2tzIHRoYXQgd29uJ3QgdHJpZ2dlciBhbiBlcnJvci5cbiAgICAgIC8vIChUaGVyZSdzIG5vIGFwcHJvcHJpYXRlIGFjdGlvbiB0eXBlIGZvciBEZXZUb29scyBvdmVycmlkZXMuKVxuICAgICAgLy8gQXMgYSByZXN1bHQgdGhvdWdoLCBSZWFjdCB3aWxsIHNlZSB0aGUgc2NoZWR1bGVkIHVwZGF0ZSBhcyBhIG5vb3AgYW5kIGJhaWxvdXQuXG4gICAgICAvLyBTaGFsbG93IGNsb25pbmcgcHJvcHMgd29ya3MgYXMgYSB3b3JrYXJvdW5kIGZvciBub3cgdG8gYnlwYXNzIHRoZSBiYWlsb3V0IGNoZWNrLlxuXG4gICAgICBmaWJlci5tZW1vaXplZFByb3BzID0gYXNzaWduKHt9LCBmaWJlci5tZW1vaXplZFByb3BzKTtcbiAgICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBTeW5jTGFuZSk7XG5cbiAgICAgIGlmIChyb290ICE9PSBudWxsKSB7XG4gICAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgU3luY0xhbmUpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGggPSBmdW5jdGlvbiAoZmliZXIsIGlkLCBvbGRQYXRoLCBuZXdQYXRoKSB7XG4gICAgdmFyIGhvb2sgPSBmaW5kSG9vayhmaWJlciwgaWQpO1xuXG4gICAgaWYgKGhvb2sgIT09IG51bGwpIHtcbiAgICAgIHZhciBuZXdTdGF0ZSA9IGNvcHlXaXRoUmVuYW1lKGhvb2subWVtb2l6ZWRTdGF0ZSwgb2xkUGF0aCwgbmV3UGF0aCk7XG4gICAgICBob29rLm1lbW9pemVkU3RhdGUgPSBuZXdTdGF0ZTtcbiAgICAgIGhvb2suYmFzZVN0YXRlID0gbmV3U3RhdGU7IC8vIFdlIGFyZW4ndCBhY3R1YWxseSBhZGRpbmcgYW4gdXBkYXRlIHRvIHRoZSBxdWV1ZSxcbiAgICAgIC8vIGJlY2F1c2UgdGhlcmUgaXMgbm8gdXBkYXRlIHdlIGNhbiBhZGQgZm9yIHVzZVJlZHVjZXIgaG9va3MgdGhhdCB3b24ndCB0cmlnZ2VyIGFuIGVycm9yLlxuICAgICAgLy8gKFRoZXJlJ3Mgbm8gYXBwcm9wcmlhdGUgYWN0aW9uIHR5cGUgZm9yIERldlRvb2xzIG92ZXJyaWRlcy4pXG4gICAgICAvLyBBcyBhIHJlc3VsdCB0aG91Z2gsIFJlYWN0IHdpbGwgc2VlIHRoZSBzY2hlZHVsZWQgdXBkYXRlIGFzIGEgbm9vcCBhbmQgYmFpbG91dC5cbiAgICAgIC8vIFNoYWxsb3cgY2xvbmluZyBwcm9wcyB3b3JrcyBhcyBhIHdvcmthcm91bmQgZm9yIG5vdyB0byBieXBhc3MgdGhlIGJhaWxvdXQgY2hlY2suXG5cbiAgICAgIGZpYmVyLm1lbW9pemVkUHJvcHMgPSBhc3NpZ24oe30sIGZpYmVyLm1lbW9pemVkUHJvcHMpO1xuICAgICAgdmFyIHJvb3QgPSBlbnF1ZXVlQ29uY3VycmVudFJlbmRlckZvckxhbmUoZmliZXIsIFN5bmNMYW5lKTtcblxuICAgICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBTeW5jTGFuZSk7XG4gICAgICB9XG4gICAgfVxuICB9OyAvLyBTdXBwb3J0IERldlRvb2xzIHByb3BzIGZvciBmdW5jdGlvbiBjb21wb25lbnRzLCBmb3J3YXJkUmVmLCBtZW1vLCBob3N0IGNvbXBvbmVudHMsIGV0Yy5cblxuXG4gIG92ZXJyaWRlUHJvcHMgPSBmdW5jdGlvbiAoZmliZXIsIHBhdGgsIHZhbHVlKSB7XG4gICAgZmliZXIucGVuZGluZ1Byb3BzID0gY29weVdpdGhTZXQoZmliZXIubWVtb2l6ZWRQcm9wcywgcGF0aCwgdmFsdWUpO1xuXG4gICAgaWYgKGZpYmVyLmFsdGVybmF0ZSkge1xuICAgICAgZmliZXIuYWx0ZXJuYXRlLnBlbmRpbmdQcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICB9XG5cbiAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgU3luY0xhbmUpO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgU3luY0xhbmUpO1xuICAgIH1cbiAgfTtcblxuICBvdmVycmlkZVByb3BzRGVsZXRlUGF0aCA9IGZ1bmN0aW9uIChmaWJlciwgcGF0aCkge1xuICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGNvcHlXaXRoRGVsZXRlKGZpYmVyLm1lbW9pemVkUHJvcHMsIHBhdGgpO1xuXG4gICAgaWYgKGZpYmVyLmFsdGVybmF0ZSkge1xuICAgICAgZmliZXIuYWx0ZXJuYXRlLnBlbmRpbmdQcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICB9XG5cbiAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgU3luY0xhbmUpO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgU3luY0xhbmUpO1xuICAgIH1cbiAgfTtcblxuICBvdmVycmlkZVByb3BzUmVuYW1lUGF0aCA9IGZ1bmN0aW9uIChmaWJlciwgb2xkUGF0aCwgbmV3UGF0aCkge1xuICAgIGZpYmVyLnBlbmRpbmdQcm9wcyA9IGNvcHlXaXRoUmVuYW1lKGZpYmVyLm1lbW9pemVkUHJvcHMsIG9sZFBhdGgsIG5ld1BhdGgpO1xuXG4gICAgaWYgKGZpYmVyLmFsdGVybmF0ZSkge1xuICAgICAgZmliZXIuYWx0ZXJuYXRlLnBlbmRpbmdQcm9wcyA9IGZpYmVyLnBlbmRpbmdQcm9wcztcbiAgICB9XG5cbiAgICB2YXIgcm9vdCA9IGVucXVldWVDb25jdXJyZW50UmVuZGVyRm9yTGFuZShmaWJlciwgU3luY0xhbmUpO1xuXG4gICAgaWYgKHJvb3QgIT09IG51bGwpIHtcbiAgICAgIHNjaGVkdWxlVXBkYXRlT25GaWJlcihyb290LCBmaWJlciwgU3luY0xhbmUpO1xuICAgIH1cbiAgfTtcblxuICBzY2hlZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uIChmaWJlcikge1xuICAgIHZhciByb290ID0gZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lKGZpYmVyLCBTeW5jTGFuZSk7XG5cbiAgICBpZiAocm9vdCAhPT0gbnVsbCkge1xuICAgICAgc2NoZWR1bGVVcGRhdGVPbkZpYmVyKHJvb3QsIGZpYmVyLCBTeW5jTGFuZSk7XG4gICAgfVxuICB9O1xuXG4gIHNldEVycm9ySGFuZGxlciA9IGZ1bmN0aW9uIChuZXdTaG91bGRFcnJvckltcGwpIHtcbiAgICBzaG91bGRFcnJvckltcGwgPSBuZXdTaG91bGRFcnJvckltcGw7XG4gIH07XG5cbiAgc2V0U3VzcGVuc2VIYW5kbGVyID0gZnVuY3Rpb24gKG5ld1Nob3VsZFN1c3BlbmRJbXBsKSB7XG4gICAgc2hvdWxkU3VzcGVuZEltcGwgPSBuZXdTaG91bGRTdXNwZW5kSW1wbDtcbiAgfTtcbn1cblxuZnVuY3Rpb24gZmluZEhvc3RJbnN0YW5jZUJ5RmliZXIoZmliZXIpIHtcbiAgdmFyIGhvc3RGaWJlciA9IGZpbmRDdXJyZW50SG9zdEZpYmVyKGZpYmVyKTtcblxuICBpZiAoaG9zdEZpYmVyID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICByZXR1cm4gaG9zdEZpYmVyLnN0YXRlTm9kZTtcbn1cblxuZnVuY3Rpb24gZW1wdHlGaW5kRmliZXJCeUhvc3RJbnN0YW5jZShpbnN0YW5jZSkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0Q3VycmVudEZpYmVyRm9yRGV2VG9vbHMoKSB7XG4gIHJldHVybiBjdXJyZW50O1xufVxuXG5mdW5jdGlvbiBpbmplY3RJbnRvRGV2VG9vbHMoZGV2VG9vbHNDb25maWcpIHtcbiAgdmFyIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlID0gZGV2VG9vbHNDb25maWcuZmluZEZpYmVyQnlIb3N0SW5zdGFuY2U7XG4gIHJldHVybiBpbmplY3RJbnRlcm5hbHMoe1xuICAgIGJ1bmRsZVR5cGU6IGRldlRvb2xzQ29uZmlnLmJ1bmRsZVR5cGUsXG4gICAgdmVyc2lvbjogZGV2VG9vbHNDb25maWcudmVyc2lvbixcbiAgICByZW5kZXJlclBhY2thZ2VOYW1lOiBkZXZUb29sc0NvbmZpZy5yZW5kZXJlclBhY2thZ2VOYW1lLFxuICAgIHJlbmRlcmVyQ29uZmlnOiBkZXZUb29sc0NvbmZpZy5yZW5kZXJlckNvbmZpZyxcbiAgICBvdmVycmlkZUhvb2tTdGF0ZTogb3ZlcnJpZGVIb29rU3RhdGUsXG4gICAgb3ZlcnJpZGVIb29rU3RhdGVEZWxldGVQYXRoOiBvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGgsXG4gICAgb3ZlcnJpZGVIb29rU3RhdGVSZW5hbWVQYXRoOiBvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGgsXG4gICAgb3ZlcnJpZGVQcm9wczogb3ZlcnJpZGVQcm9wcyxcbiAgICBvdmVycmlkZVByb3BzRGVsZXRlUGF0aDogb3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGgsXG4gICAgb3ZlcnJpZGVQcm9wc1JlbmFtZVBhdGg6IG92ZXJyaWRlUHJvcHNSZW5hbWVQYXRoLFxuICAgIHNldEVycm9ySGFuZGxlcjogc2V0RXJyb3JIYW5kbGVyLFxuICAgIHNldFN1c3BlbnNlSGFuZGxlcjogc2V0U3VzcGVuc2VIYW5kbGVyLFxuICAgIHNjaGVkdWxlVXBkYXRlOiBzY2hlZHVsZVVwZGF0ZSxcbiAgICBjdXJyZW50RGlzcGF0Y2hlclJlZjogUmVhY3RTaGFyZWRJbnRlcm5hbHMsXG4gICAgZmluZEhvc3RJbnN0YW5jZUJ5RmliZXI6IGZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyLFxuICAgIGZpbmRGaWJlckJ5SG9zdEluc3RhbmNlOiBmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSB8fCBlbXB0eUZpbmRGaWJlckJ5SG9zdEluc3RhbmNlLFxuICAgIC8vIFJlYWN0IFJlZnJlc2hcbiAgICBmaW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2g6IGZpbmRIb3N0SW5zdGFuY2VzRm9yUmVmcmVzaCAsXG4gICAgc2NoZWR1bGVSZWZyZXNoOiBzY2hlZHVsZVJlZnJlc2ggLFxuICAgIHNjaGVkdWxlUm9vdDogc2NoZWR1bGVSb290ICxcbiAgICBzZXRSZWZyZXNoSGFuZGxlcjogc2V0UmVmcmVzaEhhbmRsZXIgLFxuICAgIC8vIEVuYWJsZXMgRGV2VG9vbHMgdG8gYXBwZW5kIG93bmVyIHN0YWNrcyB0byBlcnJvciBtZXNzYWdlcyBpbiBERVYgbW9kZS5cbiAgICBnZXRDdXJyZW50RmliZXI6IGdldEN1cnJlbnRGaWJlckZvckRldlRvb2xzICxcbiAgICAvLyBFbmFibGVzIERldlRvb2xzIHRvIGRldGVjdCByZWNvbmNpbGVyIHZlcnNpb24gcmF0aGVyIHRoYW4gcmVuZGVyZXIgdmVyc2lvblxuICAgIC8vIHdoaWNoIG1heSBub3QgbWF0Y2ggZm9yIHRoaXJkIHBhcnR5IHJlbmRlcmVycy5cbiAgICByZWNvbmNpbGVyVmVyc2lvbjogUmVhY3RWZXJzaW9uXG4gIH0pO1xufVxuXG5leHBvcnRzLmF0dGVtcHRDb250aW51b3VzSHlkcmF0aW9uID0gYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb247XG5leHBvcnRzLmF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eSA9IGF0dGVtcHRIeWRyYXRpb25BdEN1cnJlbnRQcmlvcml0eTtcbmV4cG9ydHMuYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uID0gYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uO1xuZXhwb3J0cy5iYXRjaGVkVXBkYXRlcyA9IGJhdGNoZWRVcGRhdGVzO1xuZXhwb3J0cy5jcmVhdGVDb21wb25lbnRTZWxlY3RvciA9IGNyZWF0ZUNvbXBvbmVudFNlbGVjdG9yO1xuZXhwb3J0cy5jcmVhdGVDb250YWluZXIgPSBjcmVhdGVDb250YWluZXI7XG5leHBvcnRzLmNyZWF0ZUhhc1BzZXVkb0NsYXNzU2VsZWN0b3IgPSBjcmVhdGVIYXNQc2V1ZG9DbGFzc1NlbGVjdG9yO1xuZXhwb3J0cy5jcmVhdGVIeWRyYXRpb25Db250YWluZXIgPSBjcmVhdGVIeWRyYXRpb25Db250YWluZXI7XG5leHBvcnRzLmNyZWF0ZVBvcnRhbCA9IGNyZWF0ZVBvcnRhbDtcbmV4cG9ydHMuY3JlYXRlUm9sZVNlbGVjdG9yID0gY3JlYXRlUm9sZVNlbGVjdG9yO1xuZXhwb3J0cy5jcmVhdGVUZXN0TmFtZVNlbGVjdG9yID0gY3JlYXRlVGVzdE5hbWVTZWxlY3RvcjtcbmV4cG9ydHMuY3JlYXRlVGV4dFNlbGVjdG9yID0gY3JlYXRlVGV4dFNlbGVjdG9yO1xuZXhwb3J0cy5kZWZhdWx0T25DYXVnaHRFcnJvciA9IGRlZmF1bHRPbkNhdWdodEVycm9yO1xuZXhwb3J0cy5kZWZhdWx0T25SZWNvdmVyYWJsZUVycm9yID0gZGVmYXVsdE9uUmVjb3ZlcmFibGVFcnJvcjtcbmV4cG9ydHMuZGVmYXVsdE9uVW5jYXVnaHRFcnJvciA9IGRlZmF1bHRPblVuY2F1Z2h0RXJyb3I7XG5leHBvcnRzLmRlZmVycmVkVXBkYXRlcyA9IGRlZmVycmVkVXBkYXRlcztcbmV4cG9ydHMuZGlzY3JldGVVcGRhdGVzID0gZGlzY3JldGVVcGRhdGVzO1xuZXhwb3J0cy5maW5kQWxsTm9kZXMgPSBmaW5kQWxsTm9kZXM7XG5leHBvcnRzLmZpbmRCb3VuZGluZ1JlY3RzID0gZmluZEJvdW5kaW5nUmVjdHM7XG5leHBvcnRzLmZpbmRIb3N0SW5zdGFuY2UgPSBmaW5kSG9zdEluc3RhbmNlO1xuZXhwb3J0cy5maW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyA9IGZpbmRIb3N0SW5zdGFuY2VXaXRoTm9Qb3J0YWxzO1xuZXhwb3J0cy5maW5kSG9zdEluc3RhbmNlV2l0aFdhcm5pbmcgPSBmaW5kSG9zdEluc3RhbmNlV2l0aFdhcm5pbmc7XG5leHBvcnRzLmZsdXNoUGFzc2l2ZUVmZmVjdHMgPSBmbHVzaFBhc3NpdmVFZmZlY3RzO1xuZXhwb3J0cy5mbHVzaFN5bmNGcm9tUmVjb25jaWxlciA9IGZsdXNoU3luY0Zyb21SZWNvbmNpbGVyO1xuZXhwb3J0cy5mbHVzaFN5bmNXb3JrID0gZmx1c2hTeW5jV29yaztcbmV4cG9ydHMuZm9jdXNXaXRoaW4gPSBmb2N1c1dpdGhpbjtcbmV4cG9ydHMuZ2V0RmluZEFsbE5vZGVzRmFpbHVyZURlc2NyaXB0aW9uID0gZ2V0RmluZEFsbE5vZGVzRmFpbHVyZURlc2NyaXB0aW9uO1xuZXhwb3J0cy5nZXRQdWJsaWNSb290SW5zdGFuY2UgPSBnZXRQdWJsaWNSb290SW5zdGFuY2U7XG5leHBvcnRzLmluamVjdEludG9EZXZUb29scyA9IGluamVjdEludG9EZXZUb29scztcbmV4cG9ydHMuaXNBbHJlYWR5UmVuZGVyaW5nID0gaXNBbHJlYWR5UmVuZGVyaW5nO1xuZXhwb3J0cy5vYnNlcnZlVmlzaWJsZVJlY3RzID0gb2JzZXJ2ZVZpc2libGVSZWN0cztcbmV4cG9ydHMuc2hvdWxkRXJyb3IgPSBzaG91bGRFcnJvcjtcbmV4cG9ydHMuc2hvdWxkU3VzcGVuZCA9IHNob3VsZFN1c3BlbmQ7XG5leHBvcnRzLnN0YXJ0SG9zdFRyYW5zaXRpb24gPSBzdGFydEhvc3RUcmFuc2l0aW9uO1xuZXhwb3J0cy51cGRhdGVDb250YWluZXIgPSB1cGRhdGVDb250YWluZXI7XG5leHBvcnRzLnVwZGF0ZUNvbnRhaW5lclN5bmMgPSB1cGRhdGVDb250YWluZXJTeW5jO1xuICAgIHJldHVybiBleHBvcnRzO1xuICB9O1xuICBtb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gbW9kdWxlLmV4cG9ydHM7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUuZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCIkJCRyZWNvbmNpbGVyIiwiJCQkY29uZmlnIiwiUmVhY3QiLCJyZXF1aXJlIiwiU2NoZWR1bGVyIiwiUmVhY3RTaGFyZWRJbnRlcm5hbHMiLCJfX0NMSUVOVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9XQVJOX1VTRVJTX1RIRVlfQ0FOTk9UX1VQR1JBREUiLCJzdXBwcmVzc1dhcm5pbmciLCJzZXRTdXBwcmVzc1dhcm5pbmciLCJuZXdTdXBwcmVzc1dhcm5pbmciLCJ3YXJuIiwiZm9ybWF0IiwiX2xlbiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkiLCJwcmludFdhcm5pbmciLCJlcnJvciIsIl9sZW4yIiwiX2tleTIiLCJsZXZlbCIsImlzRXJyb3JMb2dnZXIiLCJnZXRDdXJyZW50U3RhY2siLCJzdGFjayIsImNvbmNhdCIsInVuc2hpZnQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwiRnVuY3Rpb24iLCJwcm90b3R5cGUiLCJhcHBseSIsImNhbGwiLCJjb25zb2xlIiwiYXNzaWduIiwiT2JqZWN0IiwiTGVnYWN5Um9vdCIsIkNvbmN1cnJlbnRSb290IiwiZ2V0Iiwia2V5IiwiX3JlYWN0SW50ZXJuYWxzIiwic2V0IiwidmFsdWUiLCJmYXZvclNhZmV0eU92ZXJIeWRyYXRpb25QZXJmIiwiZW5hYmxlQXN5bmNBY3Rpb25zIiwiZGlzYWJsZURlZmF1bHRQcm9wc0V4Y2VwdEZvckNsYXNzZXMiLCJlbmFibGVTdXNwZW5zZUNhbGxiYWNrIiwiZW5hYmxlQXN5bmNJdGVyYWJsZUNoaWxkcmVuIiwiZW5hYmxlTGF6eUNvbnRleHRQcm9wYWdhdGlvbiIsImVuYWJsZUxlZ2FjeUhpZGRlbiIsImFsd2F5c1Rocm90dGxlUmV0cmllcyIsInBhc3NDaGlsZHJlbldoZW5DbG9uaW5nUGVyc2lzdGVkTm9kZXMiLCJzeW5jTGFuZUV4cGlyYXRpb25NcyIsInRyYW5zaXRpb25MYW5lRXhwaXJhdGlvbk1zIiwiZGlzYWJsZUxlZ2FjeU1vZGUiLCJlbmFibGVTY2hlZHVsaW5nUHJvZmlsZXIiLCJlbmFibGVQcm9maWxlclRpbWVyIiwiZW5hYmxlUHJvZmlsZXJDb21taXRIb29rcyIsImVuYWJsZVByb2ZpbGVyTmVzdGVkVXBkYXRlUGhhc2UiLCJGdW5jdGlvbkNvbXBvbmVudCIsIkNsYXNzQ29tcG9uZW50IiwiSG9zdFJvb3QiLCJIb3N0UG9ydGFsIiwiSG9zdENvbXBvbmVudCIsIkhvc3RUZXh0IiwiRnJhZ21lbnQiLCJNb2RlIiwiQ29udGV4dENvbnN1bWVyIiwiQ29udGV4dFByb3ZpZGVyIiwiRm9yd2FyZFJlZiIsIlByb2ZpbGVyIiwiU3VzcGVuc2VDb21wb25lbnQiLCJNZW1vQ29tcG9uZW50IiwiU2ltcGxlTWVtb0NvbXBvbmVudCIsIkxhenlDb21wb25lbnQiLCJJbmNvbXBsZXRlQ2xhc3NDb21wb25lbnQiLCJEZWh5ZHJhdGVkRnJhZ21lbnQiLCJTdXNwZW5zZUxpc3RDb21wb25lbnQiLCJTY29wZUNvbXBvbmVudCIsIk9mZnNjcmVlbkNvbXBvbmVudCIsIkxlZ2FjeUhpZGRlbkNvbXBvbmVudCIsIkNhY2hlQ29tcG9uZW50IiwiVHJhY2luZ01hcmtlckNvbXBvbmVudCIsIkhvc3RIb2lzdGFibGUiLCJIb3N0U2luZ2xldG9uIiwiSW5jb21wbGV0ZUZ1bmN0aW9uQ29tcG9uZW50IiwiUkVBQ1RfTEVHQUNZX0VMRU1FTlRfVFlQRSIsIlN5bWJvbCIsImZvciIsIlJFQUNUX0VMRU1FTlRfVFlQRSIsIlJFQUNUX1BPUlRBTF9UWVBFIiwiUkVBQ1RfRlJBR01FTlRfVFlQRSIsIlJFQUNUX1NUUklDVF9NT0RFX1RZUEUiLCJSRUFDVF9QUk9GSUxFUl9UWVBFIiwiUkVBQ1RfUFJPVklERVJfVFlQRSIsIlJFQUNUX0NPTlNVTUVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX1NDT1BFX1RZUEUiLCJSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfTEVHQUNZX0hJRERFTl9UWVBFIiwiUkVBQ1RfVFJBQ0lOR19NQVJLRVJfVFlQRSIsIlJFQUNUX01FTU9fQ0FDSEVfU0VOVElORUwiLCJNQVlCRV9JVEVSQVRPUl9TWU1CT0wiLCJpdGVyYXRvciIsIkZBVVhfSVRFUkFUT1JfU1lNQk9MIiwiZ2V0SXRlcmF0b3JGbiIsIm1heWJlSXRlcmFibGUiLCJtYXliZUl0ZXJhdG9yIiwiZ2V0V3JhcHBlZE5hbWUkMSIsIm91dGVyVHlwZSIsImlubmVyVHlwZSIsIndyYXBwZXJOYW1lIiwiZGlzcGxheU5hbWUiLCJmdW5jdGlvbk5hbWUiLCJuYW1lIiwiZ2V0Q29udGV4dE5hbWUkMSIsInR5cGUiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwiZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlIiwiJCR0eXBlb2YiLCJ0YWciLCJjb250ZXh0IiwiY29uc3VtZXIiLCJfY29udGV4dCIsInJlbmRlciIsIm91dGVyTmFtZSIsImxhenlDb21wb25lbnQiLCJwYXlsb2FkIiwiX3BheWxvYWQiLCJpbml0IiwiX2luaXQiLCJ4IiwiZ2V0V3JhcHBlZE5hbWUiLCJnZXRDb250ZXh0TmFtZSIsImdldENvbXBvbmVudE5hbWVGcm9tT3duZXIiLCJvd25lciIsImdldENvbXBvbmVudE5hbWVGcm9tRmliZXIiLCJmaWJlciIsIk5vRmxhZ3MkMSIsIlBlcmZvcm1lZFdvcmsiLCJQbGFjZW1lbnQiLCJEaWRDYXB0dXJlIiwiSHlkcmF0aW5nIiwiVXBkYXRlIiwiQ2hpbGREZWxldGlvbiIsIkNvbnRlbnRSZXNldCIsIkNhbGxiYWNrIiwiRm9yY2VDbGllbnRSZW5kZXIiLCJSZWYiLCJTbmFwc2hvdCIsIlBhc3NpdmUkMSIsIlZpc2liaWxpdHkiLCJTdG9yZUNvbnNpc3RlbmN5IiwiU2NoZWR1bGVSZXRyeSIsIlNob3VsZFN1c3BlbmRDb21taXQiLCJEaWREZWZlciIsIkZvcm1SZXNldCIsIkhvc3RFZmZlY3RNYXNrIiwiSW5jb21wbGV0ZSIsIlNob3VsZENhcHR1cmUiLCJGb3JjZVVwZGF0ZUZvckxlZ2FjeVN1c3BlbnNlIiwiRm9ya2VkIiwiUmVmU3RhdGljIiwiTGF5b3V0U3RhdGljIiwiUGFzc2l2ZVN0YXRpYyIsIk1heVN1c3BlbmRDb21taXQiLCJQbGFjZW1lbnRERVYiLCJNb3VudExheW91dERldiIsIk1vdW50UGFzc2l2ZURldiIsIkJlZm9yZU11dGF0aW9uTWFzayIsIk11dGF0aW9uTWFzayIsIkxheW91dE1hc2siLCJQYXNzaXZlTWFzayIsIlN0YXRpY01hc2siLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsImdyb3VwIiwiZ3JvdXBDb2xsYXBzZWQiLCJncm91cEVuZCIsInByb3BzIiwiY29uZmlndXJhYmxlIiwiZW51bWVyYWJsZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsInByZWZpeCIsImRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lIiwidW5kZWZpbmVkIiwiRXJyb3IiLCJtYXRjaCIsInRyaW0iLCJkZXNjcmliZURlYnVnSW5mb0ZyYW1lIiwiZW52IiwicmVlbnRyeSIsImNvbXBvbmVudEZyYW1lQ2FjaGUiLCJQb3NzaWJseVdlYWtNYXAkMSIsIldlYWtNYXAiLCJNYXAiLCJkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lIiwiZm4iLCJjb25zdHJ1Y3QiLCJmcmFtZSIsInByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UiLCJwcmVwYXJlU3RhY2tUcmFjZSIsInByZXZpb3VzRGlzcGF0Y2hlciIsIkgiLCJSdW5JblJvb3RGcmFtZSIsIkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCIsImNvbnRyb2wiLCJGYWtlIiwiZGVmaW5lUHJvcGVydHkiLCJSZWZsZWN0IiwibWF5YmVQcm9taXNlIiwiY2F0Y2giLCJzYW1wbGUiLCJuYW1lUHJvcERlc2NyaXB0b3IiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfUnVuSW5Sb290RnJhbWUkRGV0ZXIiLCJzYW1wbGVTdGFjayIsImNvbnRyb2xTdGFjayIsInNhbXBsZUxpbmVzIiwic3BsaXQiLCJjb250cm9sTGluZXMiLCJzIiwiYyIsImluY2x1ZGVzIiwiX2ZyYW1lIiwicmVwbGFjZSIsInN5bnRoZXRpY0ZyYW1lIiwiZGVzY3JpYmVDbGFzc0NvbXBvbmVudEZyYW1lIiwiY3RvciIsImRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSIsImRlc2NyaWJlRmliZXIiLCJnZXRTdGFja0J5RmliZXJJbkRldkFuZFByb2QiLCJ3b3JrSW5Qcm9ncmVzcyIsIm5vZGUiLCJkZWJ1Z0luZm8iLCJfZGVidWdJbmZvIiwiaSIsImVudHJ5IiwicmV0dXJuIiwibWVzc2FnZSIsImN1cnJlbnQiLCJpc1JlbmRlcmluZyIsImdldEN1cnJlbnRGaWJlclN0YWNrSW5EZXYiLCJyZXNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYiLCJyZXNldEN1cnJlbnRGaWJlciIsInNldEN1cnJlbnREZWJ1Z0ZpYmVySW5ERVYiLCJzZXRDdXJyZW50RmliZXIiLCJnZXRDdXJyZW50RmliZXIiLCJzZXRJc1JlbmRlcmluZyIsInJlbmRlcmluZyIsImdldE5lYXJlc3RNb3VudGVkRmliZXIiLCJuZWFyZXN0TW91bnRlZCIsImFsdGVybmF0ZSIsIm5leHROb2RlIiwiZmxhZ3MiLCJpc01vdW50ZWQiLCJjb21wb25lbnQiLCJvd25lckZpYmVyIiwiaW5zdGFuY2UiLCJzdGF0ZU5vZGUiLCJfd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIiLCJhc3NlcnRJc01vdW50ZWQiLCJmaW5kQ3VycmVudEZpYmVyVXNpbmdTbG93UGF0aCIsImEiLCJiIiwicGFyZW50QSIsInBhcmVudEIiLCJuZXh0UGFyZW50IiwiY2hpbGQiLCJzaWJsaW5nIiwiZGlkRmluZENoaWxkIiwiX2NoaWxkIiwiZmluZEN1cnJlbnRIb3N0RmliZXIiLCJwYXJlbnQiLCJjdXJyZW50UGFyZW50IiwiZmluZEN1cnJlbnRIb3N0RmliZXJJbXBsIiwiZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzIiwiZmluZEN1cnJlbnRIb3N0RmliZXJXaXRoTm9Qb3J0YWxzSW1wbCIsImlzQXJyYXlJbXBsIiwiaXNBcnJheSIsImdldFB1YmxpY0luc3RhbmNlIiwiZ2V0Um9vdEhvc3RDb250ZXh0IiwiZ2V0Q2hpbGRIb3N0Q29udGV4dCIsInByZXBhcmVGb3JDb21taXQiLCJyZXNldEFmdGVyQ29tbWl0IiwiY3JlYXRlSW5zdGFuY2UiLCJhcHBlbmRJbml0aWFsQ2hpbGQiLCJmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbiIsInNob3VsZFNldFRleHRDb250ZW50IiwiY3JlYXRlVGV4dEluc3RhbmNlIiwic2NoZWR1bGVUaW1lb3V0IiwiY2FuY2VsVGltZW91dCIsIm5vVGltZW91dCIsImlzUHJpbWFyeVJlbmRlcmVyIiwid2FybnNJZk5vdEFjdGluZyIsInN1cHBvcnRzTXV0YXRpb24iLCJzdXBwb3J0c1BlcnNpc3RlbmNlIiwic3VwcG9ydHNIeWRyYXRpb24iLCJnZXRJbnN0YW5jZUZyb21Ob2RlIiwiYmVmb3JlQWN0aXZlSW5zdGFuY2VCbHVyIiwiYWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXIiLCJwcmVwYXJlUG9ydGFsTW91bnQiLCJwcmVwYXJlU2NvcGVVcGRhdGUiLCJnZXRJbnN0YW5jZUZyb21TY29wZSIsInNldEN1cnJlbnRVcGRhdGVQcmlvcml0eSIsImdldEN1cnJlbnRVcGRhdGVQcmlvcml0eSIsInJlc29sdmVVcGRhdGVQcmlvcml0eSIsInNob3VsZEF0dGVtcHRFYWdlclRyYW5zaXRpb24iLCJkZXRhY2hEZWxldGVkSW5zdGFuY2UiLCJyZXF1ZXN0UG9zdFBhaW50Q2FsbGJhY2siLCJtYXlTdXNwZW5kQ29tbWl0IiwicHJlbG9hZEluc3RhbmNlIiwic3RhcnRTdXNwZW5kaW5nQ29tbWl0Iiwic3VzcGVuZEluc3RhbmNlIiwid2FpdEZvckNvbW1pdFRvQmVSZWFkeSIsIk5vdFBlbmRpbmdUcmFuc2l0aW9uIiwicmVzZXRGb3JtSW5zdGFuY2UiLCJzdXBwb3J0c01pY3JvdGFza3MiLCJzY2hlZHVsZU1pY3JvdGFzayIsInN1cHBvcnRzVGVzdFNlbGVjdG9ycyIsImZpbmRGaWJlclJvb3QiLCJnZXRCb3VuZGluZ1JlY3QiLCJnZXRUZXh0Q29udGVudCIsImlzSGlkZGVuU3VidHJlZSIsIm1hdGNoQWNjZXNzaWJpbGl0eVJvbGUiLCJzZXRGb2N1c0lmRm9jdXNhYmxlIiwic2V0dXBJbnRlcnNlY3Rpb25PYnNlcnZlciIsImFwcGVuZENoaWxkIiwiYXBwZW5kQ2hpbGRUb0NvbnRhaW5lciIsImNvbW1pdFRleHRVcGRhdGUiLCJjb21taXRNb3VudCIsImNvbW1pdFVwZGF0ZSIsImluc2VydEJlZm9yZSIsImluc2VydEluQ29udGFpbmVyQmVmb3JlIiwicmVtb3ZlQ2hpbGQiLCJyZW1vdmVDaGlsZEZyb21Db250YWluZXIiLCJyZXNldFRleHRDb250ZW50IiwiaGlkZUluc3RhbmNlIiwiaGlkZVRleHRJbnN0YW5jZSIsInVuaGlkZUluc3RhbmNlIiwidW5oaWRlVGV4dEluc3RhbmNlIiwiY2xlYXJDb250YWluZXIiLCJjbG9uZUluc3RhbmNlIiwiY3JlYXRlQ29udGFpbmVyQ2hpbGRTZXQiLCJhcHBlbmRDaGlsZFRvQ29udGFpbmVyQ2hpbGRTZXQiLCJmaW5hbGl6ZUNvbnRhaW5lckNoaWxkcmVuIiwicmVwbGFjZUNvbnRhaW5lckNoaWxkcmVuIiwiY2xvbmVIaWRkZW5JbnN0YW5jZSIsImNsb25lSGlkZGVuVGV4dEluc3RhbmNlIiwiaXNTdXNwZW5zZUluc3RhbmNlUGVuZGluZyIsImlzU3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrIiwiZ2V0U3VzcGVuc2VJbnN0YW5jZUZhbGxiYWNrRXJyb3JEZXRhaWxzIiwicmVnaXN0ZXJTdXNwZW5zZUluc3RhbmNlUmV0cnkiLCJjYW5IeWRyYXRlRm9ybVN0YXRlTWFya2VyIiwiaXNGb3JtU3RhdGVNYXJrZXJNYXRjaGluZyIsImdldE5leHRIeWRyYXRhYmxlU2libGluZyIsImdldEZpcnN0SHlkcmF0YWJsZUNoaWxkIiwiZ2V0Rmlyc3RIeWRyYXRhYmxlQ2hpbGRXaXRoaW5Db250YWluZXIiLCJnZXRGaXJzdEh5ZHJhdGFibGVDaGlsZFdpdGhpblN1c3BlbnNlSW5zdGFuY2UiLCJjYW5IeWRyYXRlSW5zdGFuY2UiLCJjYW5IeWRyYXRlVGV4dEluc3RhbmNlIiwiY2FuSHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UiLCJoeWRyYXRlSW5zdGFuY2UiLCJoeWRyYXRlVGV4dEluc3RhbmNlIiwiaHlkcmF0ZVN1c3BlbnNlSW5zdGFuY2UiLCJnZXROZXh0SHlkcmF0YWJsZUluc3RhbmNlQWZ0ZXJTdXNwZW5zZUluc3RhbmNlIiwiY29tbWl0SHlkcmF0ZWRDb250YWluZXIiLCJjb21taXRIeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UiLCJjbGVhclN1c3BlbnNlQm91bmRhcnkiLCJjbGVhclN1c3BlbnNlQm91bmRhcnlGcm9tQ29udGFpbmVyIiwic2hvdWxkRGVsZXRlVW5oeWRyYXRlZFRhaWxJbnN0YW5jZXMiLCJkaWZmSHlkcmF0ZWRQcm9wc0ZvckRldldhcm5pbmdzIiwiZGlmZkh5ZHJhdGVkVGV4dEZvckRldldhcm5pbmdzIiwiZGVzY3JpYmVIeWRyYXRhYmxlSW5zdGFuY2VGb3JEZXZXYXJuaW5ncyIsInZhbGlkYXRlSHlkcmF0YWJsZUluc3RhbmNlIiwidmFsaWRhdGVIeWRyYXRhYmxlVGV4dEluc3RhbmNlIiwic3VwcG9ydHNSZXNvdXJjZXMiLCJpc0hvc3RIb2lzdGFibGVUeXBlIiwiZ2V0SG9pc3RhYmxlUm9vdCIsImdldFJlc291cmNlIiwiYWNxdWlyZVJlc291cmNlIiwicmVsZWFzZVJlc291cmNlIiwiaHlkcmF0ZUhvaXN0YWJsZSIsIm1vdW50SG9pc3RhYmxlIiwidW5tb3VudEhvaXN0YWJsZSIsImNyZWF0ZUhvaXN0YWJsZUluc3RhbmNlIiwicHJlcGFyZVRvQ29tbWl0SG9pc3RhYmxlcyIsIm1heVJlc291cmNlU3VzcGVuZENvbW1pdCIsInByZWxvYWRSZXNvdXJjZSIsInN1c3BlbmRSZXNvdXJjZSIsInN1cHBvcnRzU2luZ2xldG9ucyIsInJlc29sdmVTaW5nbGV0b25JbnN0YW5jZSIsImNsZWFyU2luZ2xldG9uIiwiYWNxdWlyZVNpbmdsZXRvbkluc3RhbmNlIiwicmVsZWFzZVNpbmdsZXRvbkluc3RhbmNlIiwiaXNIb3N0U2luZ2xldG9uVHlwZSIsInZhbHVlU3RhY2siLCJmaWJlclN0YWNrIiwiaW5kZXgiLCJjcmVhdGVDdXJzb3IiLCJkZWZhdWx0VmFsdWUiLCJwb3AiLCJjdXJzb3IiLCJwdXNoIiwiZW1wdHlDb250ZXh0T2JqZWN0IiwiZnJlZXplIiwiaGFzQ29udGV4dENoYW5nZWQiLCJpc0NvbnRleHRQcm92aWRlciIsInByb2Nlc3NDaGlsZENvbnRleHQiLCJwYXJlbnRDb250ZXh0IiwiZmluZEN1cnJlbnRVbm1hc2tlZENvbnRleHQiLCJPZmZzY3JlZW5WaXNpYmxlIiwiT2Zmc2NyZWVuRGV0YWNoZWQiLCJPZmZzY3JlZW5QYXNzaXZlRWZmZWN0c0Nvbm5lY3RlZCIsImlzT2Zmc2NyZWVuTWFudWFsIiwib2Zmc2NyZWVuRmliZXIiLCJtZW1vaXplZFByb3BzIiwibW9kZSIsIk5vTW9kZSIsIkNvbmN1cnJlbnRNb2RlIiwiUHJvZmlsZU1vZGUiLCJTdHJpY3RMZWdhY3lNb2RlIiwiU3RyaWN0RWZmZWN0c01vZGUiLCJOb1N0cmljdFBhc3NpdmVFZmZlY3RzTW9kZSIsImNsejMyIiwiTWF0aCIsImNsejMyRmFsbGJhY2siLCJsb2ckMSIsIkxOMiIsImFzVWludCIsIlRvdGFsTGFuZXMiLCJOb0xhbmVzIiwiTm9MYW5lIiwiU3luY0h5ZHJhdGlvbkxhbmUiLCJTeW5jTGFuZSIsIlN5bmNMYW5lSW5kZXgiLCJJbnB1dENvbnRpbnVvdXNIeWRyYXRpb25MYW5lIiwiSW5wdXRDb250aW51b3VzTGFuZSIsIkRlZmF1bHRIeWRyYXRpb25MYW5lIiwiRGVmYXVsdExhbmUiLCJTeW5jVXBkYXRlTGFuZXMiLCJUcmFuc2l0aW9uSHlkcmF0aW9uTGFuZSIsIlRyYW5zaXRpb25MYW5lcyIsIlRyYW5zaXRpb25MYW5lMSIsIlRyYW5zaXRpb25MYW5lMiIsIlRyYW5zaXRpb25MYW5lMyIsIlRyYW5zaXRpb25MYW5lNCIsIlRyYW5zaXRpb25MYW5lNSIsIlRyYW5zaXRpb25MYW5lNiIsIlRyYW5zaXRpb25MYW5lNyIsIlRyYW5zaXRpb25MYW5lOCIsIlRyYW5zaXRpb25MYW5lOSIsIlRyYW5zaXRpb25MYW5lMTAiLCJUcmFuc2l0aW9uTGFuZTExIiwiVHJhbnNpdGlvbkxhbmUxMiIsIlRyYW5zaXRpb25MYW5lMTMiLCJUcmFuc2l0aW9uTGFuZTE0IiwiVHJhbnNpdGlvbkxhbmUxNSIsIlJldHJ5TGFuZXMiLCJSZXRyeUxhbmUxIiwiUmV0cnlMYW5lMiIsIlJldHJ5TGFuZTMiLCJSZXRyeUxhbmU0IiwiU29tZVJldHJ5TGFuZSIsIlNlbGVjdGl2ZUh5ZHJhdGlvbkxhbmUiLCJOb25JZGxlTGFuZXMiLCJJZGxlSHlkcmF0aW9uTGFuZSIsIklkbGVMYW5lIiwiT2Zmc2NyZWVuTGFuZSIsIkRlZmVycmVkTGFuZSIsIlVwZGF0ZUxhbmVzIiwiZ2V0TGFiZWxGb3JMYW5lIiwibGFuZSIsIk5vVGltZXN0YW1wIiwibmV4dFRyYW5zaXRpb25MYW5lIiwibmV4dFJldHJ5TGFuZSIsImdldEhpZ2hlc3RQcmlvcml0eUxhbmVzIiwibGFuZXMiLCJwZW5kaW5nU3luY0xhbmVzIiwiZ2V0SGlnaGVzdFByaW9yaXR5TGFuZSIsImdldE5leHRMYW5lcyIsInJvb3QiLCJ3aXBMYW5lcyIsInBlbmRpbmdMYW5lcyIsIm5leHRMYW5lcyIsInN1c3BlbmRlZExhbmVzIiwicGluZ2VkTGFuZXMiLCJub25JZGxlUGVuZGluZ0xhbmVzIiwibm9uSWRsZVVuYmxvY2tlZExhbmVzIiwibm9uSWRsZVBpbmdlZExhbmVzIiwidW5ibG9ja2VkTGFuZXMiLCJuZXh0TGFuZSIsIndpcExhbmUiLCJnZXRFbnRhbmdsZWRMYW5lcyIsInJlbmRlckxhbmVzIiwiZW50YW5nbGVkTGFuZXMiLCJhbGxFbnRhbmdsZWRMYW5lcyIsImVudGFuZ2xlbWVudHMiLCJwaWNrQXJiaXRyYXJ5TGFuZUluZGV4IiwiY29tcHV0ZUV4cGlyYXRpb25UaW1lIiwiY3VycmVudFRpbWUiLCJtYXJrU3RhcnZlZExhbmVzQXNFeHBpcmVkIiwiZXhwaXJhdGlvblRpbWVzIiwiZXhwaXJhdGlvblRpbWUiLCJleHBpcmVkTGFuZXMiLCJnZXRIaWdoZXN0UHJpb3JpdHlQZW5kaW5nTGFuZXMiLCJnZXRMYW5lc1RvUmV0cnlTeW5jaHJvbm91c2x5T25FcnJvciIsIm9yaWdpbmFsbHlBdHRlbXB0ZWRMYW5lcyIsImVycm9yUmVjb3ZlcnlEaXNhYmxlZExhbmVzIiwiZXZlcnl0aGluZ0J1dE9mZnNjcmVlbiIsImluY2x1ZGVzU3luY0xhbmUiLCJpbmNsdWRlc05vbklkbGVXb3JrIiwiaW5jbHVkZXNPbmx5UmV0cmllcyIsImluY2x1ZGVzT25seU5vblVyZ2VudExhbmVzIiwiVXJnZW50TGFuZXMiLCJpbmNsdWRlc09ubHlUcmFuc2l0aW9ucyIsImluY2x1ZGVzQmxvY2tpbmdMYW5lIiwiU3luY0RlZmF1bHRMYW5lcyIsImluY2x1ZGVzRXhwaXJlZExhbmUiLCJpc1RyYW5zaXRpb25MYW5lIiwiY2xhaW1OZXh0VHJhbnNpdGlvbkxhbmUiLCJjbGFpbU5leHRSZXRyeUxhbmUiLCJwaWNrQXJiaXRyYXJ5TGFuZSIsImxhbmVUb0luZGV4IiwiaW5jbHVkZXNTb21lTGFuZSIsImlzU3Vic2V0T2ZMYW5lcyIsInN1YnNldCIsIm1lcmdlTGFuZXMiLCJyZW1vdmVMYW5lcyIsImludGVyc2VjdExhbmVzIiwibGFuZVRvTGFuZXMiLCJoaWdoZXJQcmlvcml0eUxhbmUiLCJjcmVhdGVMYW5lTWFwIiwiaW5pdGlhbCIsImxhbmVNYXAiLCJtYXJrUm9vdFVwZGF0ZWQkMSIsInVwZGF0ZUxhbmUiLCJtYXJrUm9vdFN1c3BlbmRlZCQxIiwic3Bhd25lZExhbmUiLCJtYXJrU3Bhd25lZERlZmVycmVkTGFuZSIsIm1hcmtSb290UGluZ2VkJDEiLCJtYXJrUm9vdEZpbmlzaGVkIiwicmVtYWluaW5nTGFuZXMiLCJub0xvbmdlclBlbmRpbmdMYW5lcyIsInNoZWxsU3VzcGVuZENvdW50ZXIiLCJoaWRkZW5VcGRhdGVzIiwiaGlkZGVuVXBkYXRlc0ZvckxhbmUiLCJ1cGRhdGUiLCJzcGF3bmVkTGFuZUluZGV4IiwibWFya1Jvb3RFbnRhbmdsZWQiLCJyb290RW50YW5nbGVkTGFuZXMiLCJ1cGdyYWRlUGVuZGluZ0xhbmVUb1N5bmMiLCJ1cGdyYWRlUGVuZGluZ0xhbmVzVG9TeW5jIiwibGFuZXNUb1VwZ3JhZGUiLCJtYXJrSGlkZGVuVXBkYXRlIiwiZ2V0QnVtcGVkTGFuZUZvckh5ZHJhdGlvbiIsInJlbmRlckxhbmUiLCJhZGRGaWJlclRvTGFuZXNNYXAiLCJpc0RldlRvb2xzUHJlc2VudCIsInBlbmRpbmdVcGRhdGVyc0xhbmVNYXAiLCJ1cGRhdGVycyIsImFkZCIsIm1vdmVQZW5kaW5nRmliZXJzVG9NZW1vaXplZCIsIm1lbW9pemVkVXBkYXRlcnMiLCJzaXplIiwiZm9yRWFjaCIsImhhcyIsImNsZWFyIiwiZ2V0VHJhbnNpdGlvbnNGb3JMYW5lcyIsIkRpc2NyZXRlRXZlbnRQcmlvcml0eSIsIkNvbnRpbnVvdXNFdmVudFByaW9yaXR5IiwiRGVmYXVsdEV2ZW50UHJpb3JpdHkiLCJJZGxlRXZlbnRQcmlvcml0eSIsImhpZ2hlckV2ZW50UHJpb3JpdHkiLCJsb3dlckV2ZW50UHJpb3JpdHkiLCJpc0hpZ2hlckV2ZW50UHJpb3JpdHkiLCJldmVudFByaW9yaXR5VG9MYW5lIiwidXBkYXRlUHJpb3JpdHkiLCJsYW5lc1RvRXZlbnRQcmlvcml0eSIsInNjaGVkdWxlQ2FsbGJhY2skMyIsInVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2siLCJjYW5jZWxDYWxsYmFjayQxIiwidW5zdGFibGVfY2FuY2VsQ2FsbGJhY2siLCJzaG91bGRZaWVsZCIsInVuc3RhYmxlX3Nob3VsZFlpZWxkIiwicmVxdWVzdFBhaW50IiwidW5zdGFibGVfcmVxdWVzdFBhaW50Iiwibm93JDEiLCJ1bnN0YWJsZV9ub3ciLCJJbW1lZGlhdGVQcmlvcml0eSIsInVuc3RhYmxlX0ltbWVkaWF0ZVByaW9yaXR5IiwiVXNlckJsb2NraW5nUHJpb3JpdHkiLCJ1bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSIsIk5vcm1hbFByaW9yaXR5JDEiLCJ1bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSIsIklkbGVQcmlvcml0eSIsInVuc3RhYmxlX0lkbGVQcmlvcml0eSIsInVuc3RhYmxlX3NldERpc2FibGVZaWVsZFZhbHVlIiwicmVuZGVyZXJJRCIsImluamVjdGVkSG9vayIsImluamVjdGVkUHJvZmlsaW5nSG9va3MiLCJoYXNMb2dnZWRFcnJvciIsIl9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyIsImluamVjdEludGVybmFscyIsImludGVybmFscyIsImhvb2siLCJpc0Rpc2FibGVkIiwic3VwcG9ydHNGaWJlciIsImdldExhbmVMYWJlbE1hcCIsImluamVjdFByb2ZpbGluZ0hvb2tzIiwiaW5qZWN0IiwiZXJyIiwiY2hlY2tEQ0UiLCJvblNjaGVkdWxlUm9vdCIsImNoaWxkcmVuIiwib25TY2hlZHVsZUZpYmVyUm9vdCIsIm9uQ29tbWl0Um9vdCQxIiwiZXZlbnRQcmlvcml0eSIsIm9uQ29tbWl0RmliZXJSb290IiwiZGlkRXJyb3IiLCJzY2hlZHVsZXJQcmlvcml0eSIsIm9uUG9zdENvbW1pdFJvb3QiLCJvblBvc3RDb21taXRGaWJlclJvb3QiLCJvbkNvbW1pdFVubW91bnQiLCJvbkNvbW1pdEZpYmVyVW5tb3VudCIsInNldElzU3RyaWN0TW9kZUZvckRldnRvb2xzIiwibmV3SXNTdHJpY3RNb2RlIiwic2V0U3RyaWN0TW9kZSIsInByb2ZpbGluZ0hvb2tzIiwibGFiZWwiLCJtYXJrQ29tbWl0U3RhcnRlZCIsIm1hcmtDb21taXRTdG9wcGVkIiwibWFya0NvbXBvbmVudFJlbmRlclN0YXJ0ZWQiLCJtYXJrQ29tcG9uZW50UmVuZGVyU3RvcHBlZCIsIm1hcmtDb21wb25lbnRQYXNzaXZlRWZmZWN0TW91bnRTdGFydGVkIiwibWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RNb3VudFN0b3BwZWQiLCJtYXJrQ29tcG9uZW50UGFzc2l2ZUVmZmVjdFVubW91bnRTdGFydGVkIiwibWFya0NvbXBvbmVudFBhc3NpdmVFZmZlY3RVbm1vdW50U3RvcHBlZCIsIm1hcmtDb21wb25lbnRMYXlvdXRFZmZlY3RNb3VudFN0YXJ0ZWQiLCJtYXJrQ29tcG9uZW50TGF5b3V0RWZmZWN0TW91bnRTdG9wcGVkIiwibWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdGFydGVkIiwibWFya0NvbXBvbmVudExheW91dEVmZmVjdFVubW91bnRTdG9wcGVkIiwibWFya0NvbXBvbmVudEVycm9yZWQiLCJ0aHJvd25WYWx1ZSIsIm1hcmtDb21wb25lbnRTdXNwZW5kZWQiLCJ3YWtlYWJsZSIsIm1hcmtMYXlvdXRFZmZlY3RzU3RhcnRlZCIsIm1hcmtMYXlvdXRFZmZlY3RzU3RvcHBlZCIsIm1hcmtQYXNzaXZlRWZmZWN0c1N0YXJ0ZWQiLCJtYXJrUGFzc2l2ZUVmZmVjdHNTdG9wcGVkIiwibWFya1JlbmRlclN0YXJ0ZWQiLCJtYXJrUmVuZGVyWWllbGRlZCIsIm1hcmtSZW5kZXJTdG9wcGVkIiwibWFya1JlbmRlclNjaGVkdWxlZCIsIm1hcmtGb3JjZVVwZGF0ZVNjaGVkdWxlZCIsIm1hcmtTdGF0ZVVwZGF0ZVNjaGVkdWxlZCIsImlzIiwieSIsIm9iamVjdElzIiwiaXNSb290RGVoeWRyYXRlZCIsImN1cnJlbnRTdGF0ZSIsIm1lbW9pemVkU3RhdGUiLCJpc0RlaHlkcmF0ZWQiLCJDYXB0dXJlZFN0YWNrcyIsImNyZWF0ZUNhcHR1cmVkVmFsdWVBdEZpYmVyIiwic291cmNlIiwiY2FwdHVyZWRTdGFjayIsImNyZWF0ZUNhcHR1cmVkVmFsdWVGcm9tRXJyb3IiLCJmb3JrU3RhY2siLCJmb3JrU3RhY2tJbmRleCIsInRyZWVGb3JrUHJvdmlkZXIiLCJ0cmVlRm9ya0NvdW50IiwiaWRTdGFjayIsImlkU3RhY2tJbmRleCIsInRyZWVDb250ZXh0UHJvdmlkZXIiLCJ0cmVlQ29udGV4dElkIiwidHJlZUNvbnRleHRPdmVyZmxvdyIsImlzRm9ya2VkQ2hpbGQiLCJ3YXJuSWZOb3RIeWRyYXRpbmciLCJnZXRGb3Jrc0F0TGV2ZWwiLCJnZXRUcmVlSWQiLCJvdmVyZmxvdyIsImlkV2l0aExlYWRpbmdCaXQiLCJpZCIsImdldExlYWRpbmdCaXQiLCJ0b1N0cmluZyIsInB1c2hUcmVlRm9yayIsInRvdGFsQ2hpbGRyZW4iLCJwdXNoVHJlZUlkIiwiYmFzZUlkV2l0aExlYWRpbmdCaXQiLCJiYXNlT3ZlcmZsb3ciLCJiYXNlTGVuZ3RoIiwiZ2V0Qml0TGVuZ3RoIiwiYmFzZUlkIiwic2xvdCIsIm51bWJlck9mT3ZlcmZsb3dCaXRzIiwibmV3T3ZlcmZsb3dCaXRzIiwibmV3T3ZlcmZsb3ciLCJyZXN0T2ZCYXNlSWQiLCJyZXN0T2ZCYXNlTGVuZ3RoIiwicmVzdE9mTGVuZ3RoIiwicmVzdE9mTmV3Qml0cyIsIm5ld0JpdHMiLCJfaWQiLCJfb3ZlcmZsb3ciLCJwdXNoTWF0ZXJpYWxpemVkVHJlZUlkIiwicmV0dXJuRmliZXIiLCJudW1iZXJPZkZvcmtzIiwic2xvdEluZGV4IiwibnVtYmVyIiwicG9wVHJlZUNvbnRleHQiLCJnZXRTdXNwZW5kZWRUcmVlQ29udGV4dCIsInJlc3RvcmVTdXNwZW5kZWRUcmVlQ29udGV4dCIsInN1c3BlbmRlZENvbnRleHQiLCJnZXRJc0h5ZHJhdGluZyIsImNvbnRleHRTdGFja0N1cnNvciIsImNvbnRleHRGaWJlclN0YWNrQ3Vyc29yIiwicm9vdEluc3RhbmNlU3RhY2tDdXJzb3IiLCJob3N0VHJhbnNpdGlvblByb3ZpZGVyQ3Vyc29yIiwiSG9zdFRyYW5zaXRpb25Db250ZXh0IiwiUHJvdmlkZXIiLCJDb25zdW1lciIsIl9jdXJyZW50VmFsdWUiLCJfY3VycmVudFZhbHVlMiIsIl90aHJlYWRDb3VudCIsInJlcXVpcmVkQ29udGV4dCIsImdldFJvb3RIb3N0Q29udGFpbmVyIiwicm9vdEluc3RhbmNlIiwicHVzaEhvc3RDb250YWluZXIiLCJuZXh0Um9vdEluc3RhbmNlIiwibmV4dFJvb3RDb250ZXh0IiwicG9wSG9zdENvbnRhaW5lciIsImdldEhvc3RDb250ZXh0IiwicHVzaEhvc3RDb250ZXh0Iiwic3RhdGVIb29rIiwibmV4dENvbnRleHQiLCJwb3BIb3N0Q29udGV4dCIsIm1heFJvd0xlbmd0aCIsImlkZWFsRGVwdGgiLCJmaW5kTm90YWJsZU5vZGUiLCJpbmRlbnQiLCJzZXJ2ZXJQcm9wcyIsInNlcnZlclRhaWwiLCJkaXN0YW5jZUZyb21MZWFmIiwiaW5kZW50YXRpb24iLCJyZXBlYXQiLCJhZGRlZCIsInJlbW92ZWQiLCJkZXNjcmliZUZpYmVyVHlwZSIsImN0ciIsIm5lZWRzRXNjYXBpbmciLCJkZXNjcmliZVRleHROb2RlIiwiY29udGVudCIsIm1heExlbmd0aCIsInRlc3QiLCJlbmNvZGVkIiwiSlNPTiIsInN0cmluZ2lmeSIsInNsaWNlIiwiZGVzY3JpYmVUZXh0RGlmZiIsImNsaWVudFRleHQiLCJzZXJ2ZXJUZXh0IiwiZmlyc3REaWZmIiwiY2hhckNvZGVBdCIsIm9iamVjdE5hbWUiLCJvYmplY3QiLCJtIiwicDAiLCJkZXNjcmliZVZhbHVlIiwicHJvcGVydGllcyIsInByb3BOYW1lIiwiaGFzT3duUHJvcGVydHkiLCJqc29uUHJvcE5hbWUiLCJwcm9wVmFsdWUiLCJfbmFtZSIsImRlc2NyaWJlUHJvcFZhbHVlIiwiZGVzY3JpYmVDb2xsYXBzZWRFbGVtZW50IiwiZGVzY3JpYmVFeHBhbmRlZEVsZW1lbnQiLCJyb3dQcmVmaXgiLCJyZW1haW5pbmdSb3dMZW5ndGgiLCJqb2luIiwiZGVzY3JpYmVQcm9wZXJ0aWVzRGlmZiIsImNsaWVudE9iamVjdCIsInNlcnZlck9iamVjdCIsInJlbWFpbmluZ1NlcnZlclByb3BlcnRpZXMiLCJjbGllbnRWYWx1ZSIsImNsaWVudFByb3BWYWx1ZSIsInNlcnZlclZhbHVlIiwic2VydmVyUHJvcFZhbHVlIiwiX3Byb3BOYW1lIiwiX21heExlbmd0aCIsIl9zZXJ2ZXJWYWx1ZSIsIl9zZXJ2ZXJQcm9wVmFsdWUiLCJkZXNjcmliZUVsZW1lbnREaWZmIiwiY2xpZW50UHJvcHMiLCJzZXJ2ZXJQcm9wTmFtZXMiLCJ0b0xvd2VyQ2FzZSIsIl9wcm9wTmFtZTIiLCJzZXJ2ZXJQcm9wTmFtZSIsImRlbGV0ZSIsImtleXMiLCJpbmRleE9mIiwic2VydmVyQ2hpbGRyZW4iLCJjbGllbnRDaGlsZHJlbiIsImRlc2NyaWJlU2libGluZ0ZpYmVyIiwiZmxhdENvbnRlbnQiLCJjaGlsZEZpYmVyIiwiZGVzY3JpYmVOb2RlIiwic2tpcFRvTm9kZSIsInBhcmVudENvbnRlbnQiLCJzZXJ2ZXJDb21wb25lbnROYW1lIiwic2VsZkNvbnRlbnQiLCJwZW5kaW5nUHJvcHMiLCJjaGlsZENvbnRlbnQiLCJkaWZmSWR4IiwiY2hpbGROb2RlIiwiX2kiLCJ0YWlsTm9kZSIsImRlc2NyaWJlRGlmZiIsInJvb3ROb2RlIiwiaHlkcmF0aW9uUGFyZW50RmliZXIiLCJuZXh0SHlkcmF0YWJsZUluc3RhbmNlIiwiaXNIeWRyYXRpbmciLCJkaWRTdXNwZW5kT3JFcnJvckRFViIsImh5ZHJhdGlvbkRpZmZSb290REVWIiwiaHlkcmF0aW9uRXJyb3JzIiwicm9vdE9yU2luZ2xldG9uQ29udGV4dCIsImJ1aWxkSHlkcmF0aW9uRGlmZk5vZGUiLCJzaWJsaW5ncyIsImV4aXN0aW5nIiwibmV3Tm9kZSIsIndhcm5JZkh5ZHJhdGluZyIsIm1hcmtEaWRUaHJvd1doaWxlSHlkcmF0aW5nREVWIiwiZW50ZXJIeWRyYXRpb25TdGF0ZSIsInBhcmVudEluc3RhbmNlIiwiY29udGFpbmVySW5mbyIsInJlZW50ZXJIeWRyYXRpb25TdGF0ZUZyb21EZWh5ZHJhdGVkU3VzcGVuc2VJbnN0YW5jZSIsInN1c3BlbnNlSW5zdGFuY2UiLCJ0cmVlQ29udGV4dCIsIndhcm5Ob25IeWRyYXRlZEluc3RhbmNlIiwicmVqZWN0ZWRDYW5kaWRhdGUiLCJkaWZmTm9kZSIsImRlc2NyaXB0aW9uIiwidHJ5SHlkcmF0ZUluc3RhbmNlIiwibmV4dEluc3RhbmNlIiwiaG9zdENvbnRleHQiLCJkaWZmZXJlbmNlcyIsInRyeUh5ZHJhdGVUZXh0IiwidGV4dCIsInRleHRJbnN0YW5jZSIsInRyeUh5ZHJhdGVTdXNwZW5zZSIsInN1c3BlbnNlU3RhdGUiLCJkZWh5ZHJhdGVkIiwicmV0cnlMYW5lIiwiZGVoeWRyYXRlZEZyYWdtZW50IiwiY3JlYXRlRmliZXJGcm9tRGVoeWRyYXRlZEZyYWdtZW50IiwiSHlkcmF0aW9uTWlzbWF0Y2hFeGNlcHRpb24iLCJ0aHJvd09uSHlkcmF0aW9uTWlzbWF0Y2giLCJkaWZmIiwiZGlmZlJvb3QiLCJxdWV1ZUh5ZHJhdGlvbkVycm9yIiwiY2xhaW1IeWRyYXRhYmxlU2luZ2xldG9uIiwiY3VycmVudFJvb3RDb250YWluZXIiLCJjdXJyZW50SG9zdENvbnRleHQiLCJ0cnlUb0NsYWltTmV4dEh5ZHJhdGFibGVJbnN0YW5jZSIsInNob3VsZEtlZXBXYXJuaW5nIiwidHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlVGV4dEluc3RhbmNlIiwidHJ5VG9DbGFpbU5leHRIeWRyYXRhYmxlU3VzcGVuc2VJbnN0YW5jZSIsInRyeVRvQ2xhaW1OZXh0SHlkcmF0YWJsZUZvcm1NYXJrZXJJbnN0YW5jZSIsIm1hcmtlckluc3RhbmNlIiwicHJlcGFyZVRvSHlkcmF0ZUhvc3RJbnN0YW5jZSIsImRpZEh5ZHJhdGUiLCJwcmVwYXJlVG9IeWRyYXRlSG9zdFRleHRJbnN0YW5jZSIsInRleHRDb250ZW50Iiwic2hvdWxkV2FybklmTWlzbWF0Y2hEZXYiLCJwYXJlbnRQcm9wcyIsImRpZmZlcmVuY2UiLCJfZGlmZmVyZW5jZSIsIl9kaWZmTm9kZSIsInByZXBhcmVUb0h5ZHJhdGVIb3N0U3VzcGVuc2VJbnN0YW5jZSIsInNraXBQYXN0RGVoeWRyYXRlZFN1c3BlbnNlSW5zdGFuY2UiLCJwb3BUb05leHRIb3N0UGFyZW50IiwicG9wSHlkcmF0aW9uU3RhdGUiLCJzaG91bGRDbGVhciIsIndhcm5JZlVuaHlkcmF0ZWRUYWlsTm9kZXMiLCJyZXNldEh5ZHJhdGlvblN0YXRlIiwidXBncmFkZUh5ZHJhdGlvbkVycm9yc1RvUmVjb3ZlcmFibGUiLCJxdWV1ZVJlY292ZXJhYmxlRXJyb3JzIiwiZW1pdFBlbmRpbmdIeWRyYXRpb25XYXJuaW5ncyIsImNvbmN1cnJlbnRRdWV1ZXMiLCJjb25jdXJyZW50UXVldWVzSW5kZXgiLCJjb25jdXJyZW50bHlVcGRhdGVkTGFuZXMiLCJmaW5pc2hRdWV1ZWluZ0NvbmN1cnJlbnRVcGRhdGVzIiwiZW5kSW5kZXgiLCJxdWV1ZSIsInBlbmRpbmciLCJuZXh0IiwibWFya1VwZGF0ZUxhbmVGcm9tRmliZXJUb1Jvb3QiLCJnZXRDb25jdXJyZW50bHlVcGRhdGVkTGFuZXMiLCJlbnF1ZXVlVXBkYXRlJDEiLCJlbnF1ZXVlQ29uY3VycmVudEhvb2tVcGRhdGUiLCJjb25jdXJyZW50UXVldWUiLCJjb25jdXJyZW50VXBkYXRlIiwiZ2V0Um9vdEZvclVwZGF0ZWRGaWJlciIsImVucXVldWVDb25jdXJyZW50SG9va1VwZGF0ZUFuZEVhZ2VybHlCYWlsb3V0IiwiaXNDb25jdXJyZW50bHlSZW5kZXJpbmciLCJnZXRXb3JrSW5Qcm9ncmVzc1Jvb3QiLCJlbnF1ZXVlQ29uY3VycmVudENsYXNzVXBkYXRlIiwiZW5xdWV1ZUNvbmN1cnJlbnRSZW5kZXJGb3JMYW5lIiwidW5zYWZlX21hcmtVcGRhdGVMYW5lRnJvbUZpYmVyVG9Sb290Iiwic291cmNlRmliZXIiLCJpc0hpZGRlbiIsImNoaWxkTGFuZXMiLCJvZmZzY3JlZW5JbnN0YW5jZSIsIl92aXNpYmlsaXR5IiwidGhyb3dJZkluZmluaXRlVXBkYXRlTG9vcERldGVjdGVkIiwiZGV0ZWN0VXBkYXRlT25Vbm1vdW50ZWRGaWJlciIsIndhcm5BYm91dFVwZGF0ZU9uTm90WWV0TW91bnRlZEZpYmVySW5ERVYiLCJmaXJzdFNjaGVkdWxlZFJvb3QiLCJsYXN0U2NoZWR1bGVkUm9vdCIsImRpZFNjaGVkdWxlTWljcm90YXNrIiwiZGlkU2NoZWR1bGVNaWNyb3Rhc2tfYWN0IiwibWlnaHRIYXZlUGVuZGluZ1N5bmNXb3JrIiwiaXNGbHVzaGluZ1dvcmsiLCJjdXJyZW50RXZlbnRUcmFuc2l0aW9uTGFuZSIsImVuc3VyZVJvb3RJc1NjaGVkdWxlZCIsImFjdFF1ZXVlIiwic2NoZWR1bGVJbW1lZGlhdGVUYXNrIiwicHJvY2Vzc1Jvb3RTY2hlZHVsZUluTWljcm90YXNrIiwiZmx1c2hTeW5jV29ya09uQWxsUm9vdHMiLCJmbHVzaFN5bmNXb3JrQWNyb3NzUm9vdHNfaW1wbCIsIm9ubHlMZWdhY3kiLCJkaWRQZXJmb3JtU29tZVdvcmsiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3QiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJMYW5lcyIsImdldFdvcmtJblByb2dyZXNzUm9vdFJlbmRlckxhbmVzIiwicGVyZm9ybVN5bmNXb3JrT25Sb290IiwicHJldiIsInNjaGVkdWxlVGFza0ZvclJvb3REdXJpbmdNaWNyb3Rhc2siLCJleGlzdGluZ0NhbGxiYWNrTm9kZSIsImNhbGxiYWNrTm9kZSIsImlzV29ya0xvb3BTdXNwZW5kZWRPbkRhdGEiLCJjYW5jZWxQZW5kaW5nQ29tbWl0IiwiY2FuY2VsQ2FsbGJhY2siLCJjYWxsYmFja1ByaW9yaXR5IiwiZXhpc3RpbmdDYWxsYmFja1ByaW9yaXR5IiwibmV3Q2FsbGJhY2tQcmlvcml0eSIsImZha2VBY3RDYWxsYmFja05vZGUkMSIsInNjaGVkdWxlclByaW9yaXR5TGV2ZWwiLCJuZXdDYWxsYmFja05vZGUiLCJzY2hlZHVsZUNhbGxiYWNrJDIiLCJwZXJmb3JtQ29uY3VycmVudFdvcmtPblJvb3QiLCJiaW5kIiwiZ2V0Q29udGludWF0aW9uRm9yUm9vdCIsIm9yaWdpbmFsQ2FsbGJhY2tOb2RlIiwicHJpb3JpdHlMZXZlbCIsImNhbGxiYWNrIiwiY2IiLCJleGVjdXRpb25Db250ZXh0IiwiZ2V0RXhlY3V0aW9uQ29udGV4dCIsIlJlbmRlckNvbnRleHQiLCJDb21taXRDb250ZXh0IiwiTm9Db250ZXh0IiwicmVxdWVzdFRyYW5zaXRpb25MYW5lIiwidHJhbnNpdGlvbiIsImN1cnJlbnRFbnRhbmdsZWRMaXN0ZW5lcnMiLCJjdXJyZW50RW50YW5nbGVkUGVuZGluZ0NvdW50IiwiY3VycmVudEVudGFuZ2xlZExhbmUiLCJjdXJyZW50RW50YW5nbGVkQWN0aW9uVGhlbmFibGUiLCJlbnRhbmdsZUFzeW5jQWN0aW9uIiwidGhlbmFibGUiLCJlbnRhbmdsZWRMaXN0ZW5lcnMiLCJlbnRhbmdsZWRUaGVuYWJsZSIsInN0YXR1cyIsInRoZW4iLCJyZXNvbHZlIiwicGluZ0VuZ3RhbmdsZWRBY3Rpb25TY29wZSIsImZ1bGZpbGxlZFRoZW5hYmxlIiwibGlzdGVuZXJzIiwibGlzdGVuZXIiLCJjaGFpblRoZW5hYmxlVmFsdWUiLCJyZXN1bHQiLCJ0aGVuYWJsZVdpdGhPdmVycmlkZSIsInJlYXNvbiIsInJlamVjdGVkVGhlbmFibGUiLCJwZWVrRW50YW5nbGVkQWN0aW9uTGFuZSIsInBlZWtFbnRhbmdsZWRBY3Rpb25UaGVuYWJsZSIsIlVwZGF0ZVN0YXRlIiwiUmVwbGFjZVN0YXRlIiwiRm9yY2VVcGRhdGUiLCJDYXB0dXJlVXBkYXRlIiwiaGFzRm9yY2VVcGRhdGUiLCJkaWRXYXJuVXBkYXRlSW5zaWRlVXBkYXRlIiwiY3VycmVudGx5UHJvY2Vzc2luZ1F1ZXVlIiwiaW5pdGlhbGl6ZVVwZGF0ZVF1ZXVlIiwiYmFzZVN0YXRlIiwiZmlyc3RCYXNlVXBkYXRlIiwibGFzdEJhc2VVcGRhdGUiLCJzaGFyZWQiLCJoaWRkZW5DYWxsYmFja3MiLCJjYWxsYmFja3MiLCJ1cGRhdGVRdWV1ZSIsImNsb25lVXBkYXRlUXVldWUiLCJjdXJyZW50UXVldWUiLCJjbG9uZSIsImNyZWF0ZVVwZGF0ZSIsImVucXVldWVVcGRhdGUiLCJzaGFyZWRRdWV1ZSIsImNvbXBvbmVudE5hbWUiLCJpc1Vuc2FmZUNsYXNzUmVuZGVyUGhhc2VVcGRhdGUiLCJlbnRhbmdsZVRyYW5zaXRpb25zIiwicXVldWVMYW5lcyIsIm5ld1F1ZXVlTGFuZXMiLCJlbnF1ZXVlQ2FwdHVyZWRVcGRhdGUiLCJjYXB0dXJlZFVwZGF0ZSIsIm5ld0ZpcnN0IiwibmV3TGFzdCIsImdldFN0YXRlRnJvbVVwZGF0ZSIsInByZXZTdGF0ZSIsIm5leHRQcm9wcyIsImVudGVyRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYiLCJuZXh0U3RhdGUiLCJleGl0RGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYiLCJwYXJ0aWFsU3RhdGUiLCJkaWRSZWFkRnJvbUVudGFuZ2xlZEFzeW5jQWN0aW9uIiwic3VzcGVuZElmVXBkYXRlUmVhZEZyb21FbnRhbmdsZWRBc3luY0FjdGlvbiIsImVudGFuZ2xlZEFjdGlvblRoZW5hYmxlIiwicHJvY2Vzc1VwZGF0ZVF1ZXVlIiwicGVuZGluZ1F1ZXVlIiwibGFzdFBlbmRpbmdVcGRhdGUiLCJmaXJzdFBlbmRpbmdVcGRhdGUiLCJjdXJyZW50TGFzdEJhc2VVcGRhdGUiLCJuZXdTdGF0ZSIsIm5ld0xhbmVzIiwibmV3QmFzZVN0YXRlIiwibmV3Rmlyc3RCYXNlVXBkYXRlIiwibmV3TGFzdEJhc2VVcGRhdGUiLCJpc0hpZGRlblVwZGF0ZSIsInNob3VsZFNraXBVcGRhdGUiLCJfY2xvbmUiLCJfbGFzdFBlbmRpbmdVcGRhdGUiLCJfZmlyc3RQZW5kaW5nVXBkYXRlIiwibWFya1NraXBwZWRVcGRhdGVMYW5lcyIsImNhbGxDYWxsYmFjayIsInJlc2V0SGFzRm9yY2VVcGRhdGVCZWZvcmVQcm9jZXNzaW5nIiwiY2hlY2tIYXNGb3JjZVVwZGF0ZUFmdGVyUHJvY2Vzc2luZyIsImRlZmVySGlkZGVuQ2FsbGJhY2tzIiwibmV3SGlkZGVuQ2FsbGJhY2tzIiwiZXhpc3RpbmdIaWRkZW5DYWxsYmFja3MiLCJjb21taXRIaWRkZW5DYWxsYmFja3MiLCJjb21taXRDYWxsYmFja3MiLCJzaGFsbG93RXF1YWwiLCJvYmpBIiwib2JqQiIsImtleXNBIiwia2V5c0IiLCJjdXJyZW50S2V5IiwiUmVhY3RTdHJpY3RNb2RlV2FybmluZ3MiLCJyZWNvcmRVbnNhZmVMaWZlY3ljbGVXYXJuaW5ncyIsImZsdXNoUGVuZGluZ1Vuc2FmZUxpZmVjeWNsZVdhcm5pbmdzIiwicmVjb3JkTGVnYWN5Q29udGV4dFdhcm5pbmciLCJmbHVzaExlZ2FjeUNvbnRleHRXYXJuaW5nIiwiZGlzY2FyZFBlbmRpbmdXYXJuaW5ncyIsImZpbmRTdHJpY3RSb290IiwibWF5YmVTdHJpY3RSb290Iiwic2V0VG9Tb3J0ZWRTdHJpbmciLCJhcnJheSIsInNvcnQiLCJwZW5kaW5nQ29tcG9uZW50V2lsbE1vdW50V2FybmluZ3MiLCJwZW5kaW5nVU5TQUZFX0NvbXBvbmVudFdpbGxNb3VudFdhcm5pbmdzIiwicGVuZGluZ0NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHNXYXJuaW5ncyIsInBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1dhcm5pbmdzIiwicGVuZGluZ0NvbXBvbmVudFdpbGxVcGRhdGVXYXJuaW5ncyIsInBlbmRpbmdVTlNBRkVfQ29tcG9uZW50V2lsbFVwZGF0ZVdhcm5pbmdzIiwiZGlkV2FybkFib3V0VW5zYWZlTGlmZWN5Y2xlcyIsIlNldCIsImNvbXBvbmVudFdpbGxNb3VudCIsIl9fc3VwcHJlc3NEZXByZWNhdGlvbldhcm5pbmciLCJVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50IiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIlVOU0FGRV9jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiY29tcG9uZW50V2lsbFVwZGF0ZSIsIlVOU0FGRV9jb21wb25lbnRXaWxsVXBkYXRlIiwiY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMiLCJVTlNBRkVfY29tcG9uZW50V2lsbE1vdW50VW5pcXVlTmFtZXMiLCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzVW5pcXVlTmFtZXMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wc1VuaXF1ZU5hbWVzIiwiY29tcG9uZW50V2lsbFVwZGF0ZVVuaXF1ZU5hbWVzIiwiVU5TQUZFX2NvbXBvbmVudFdpbGxVcGRhdGVVbmlxdWVOYW1lcyIsInNvcnRlZE5hbWVzIiwiX3NvcnRlZE5hbWVzIiwiX3NvcnRlZE5hbWVzMiIsIl9zb3J0ZWROYW1lczMiLCJfc29ydGVkTmFtZXM0IiwiX3NvcnRlZE5hbWVzNSIsInBlbmRpbmdMZWdhY3lDb250ZXh0V2FybmluZyIsImRpZFdhcm5BYm91dExlZ2FjeUNvbnRleHQiLCJzdHJpY3RSb290Iiwid2FybmluZ3NGb3JSb290IiwiY29udGV4dFR5cGVzIiwiY2hpbGRDb250ZXh0VHlwZXMiLCJnZXRDaGlsZENvbnRleHQiLCJmaWJlckFycmF5IiwiZmlyc3RGaWJlciIsInVuaXF1ZU5hbWVzIiwiZ2V0VGhlbmFibGVzRnJvbVN0YXRlIiwic3RhdGUiLCJkZXZTdGF0ZSIsInRoZW5hYmxlcyIsIlN1c3BlbnNlRXhjZXB0aW9uIiwiU3VzcGVuc2V5Q29tbWl0RXhjZXB0aW9uIiwibm9vcFN1c3BlbnNleUNvbW1pdFRoZW5hYmxlIiwiY3JlYXRlVGhlbmFibGVTdGF0ZSIsImRpZFdhcm5BYm91dFVuY2FjaGVkUHJvbWlzZSIsImlzVGhlbmFibGVSZXNvbHZlZCIsIm5vb3AkMSIsInRyYWNrVXNlZFRoZW5hYmxlIiwidGhlbmFibGVTdGF0ZSIsImRpZFVzZVByb21pc2UiLCJ0cmFja2VkVGhlbmFibGVzIiwicHJldmlvdXMiLCJ0aGVuYWJsZVN0YXRlRGV2IiwiZnVsZmlsbGVkVmFsdWUiLCJyZWplY3RlZEVycm9yIiwiY2hlY2tJZlVzZVdyYXBwZWRJbkFzeW5jQ2F0Y2giLCJwZW5kaW5nVGhlbmFibGUiLCJfcmVqZWN0ZWRFcnJvciIsInN1c3BlbmRlZFRoZW5hYmxlIiwibmVlZHNUb1Jlc2V0U3VzcGVuZGVkVGhlbmFibGVERVYiLCJzdXNwZW5kQ29tbWl0IiwiZ2V0U3VzcGVuZGVkVGhlbmFibGUiLCJjaGVja0lmVXNlV3JhcHBlZEluVHJ5Q2F0Y2giLCJyZWplY3RlZFJlYXNvbiIsInRoZW5hYmxlU3RhdGUkMSIsInRoZW5hYmxlSW5kZXhDb3VudGVyJDEiLCJtZXJnZURlYnVnSW5mbyIsIm91dGVyIiwiaW5uZXIiLCJkaWRXYXJuQWJvdXRNYXBzIiwiZGlkV2FybkFib3V0R2VuZXJhdG9ycyIsIm93bmVySGFzS2V5VXNlV2FybmluZyIsIm93bmVySGFzRnVuY3Rpb25UeXBlV2FybmluZyIsIm93bmVySGFzU3ltYm9sVHlwZVdhcm5pbmciLCJ3YXJuRm9yTWlzc2luZ0tleSIsIl9zdG9yZSIsInZhbGlkYXRlZCIsImNvbXBvbmVudEtleSIsImNoaWxkT3duZXIiLCJfb3duZXIiLCJwYXJlbnRPd25lciIsIl9kZWJ1Z093bmVyIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXJBcHBlbmRpeCIsIm93bmVyTmFtZSIsImNyZWF0ZUZpYmVyRnJvbUVsZW1lbnQiLCJwcmV2RGVidWdGaWJlciIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImVsZW1lbnQiLCJ1bndyYXBUaGVuYWJsZSIsImNvZXJjZVJlZiIsInJlZiIsInJlZlByb3AiLCJ0aHJvd09uSW52YWxpZE9iamVjdFR5cGUiLCJuZXdDaGlsZCIsImNoaWxkU3RyaW5nIiwid2Fybk9uRnVuY3Rpb25UeXBlIiwiaW52YWxpZENoaWxkIiwicGFyZW50TmFtZSIsIndhcm5PblN5bWJvbFR5cGUiLCJyZXNvbHZlTGF6eSIsImxhenlUeXBlIiwiY3JlYXRlQ2hpbGRSZWNvbmNpbGVyIiwic2hvdWxkVHJhY2tTaWRlRWZmZWN0cyIsImRlbGV0ZUNoaWxkIiwiY2hpbGRUb0RlbGV0ZSIsImRlbGV0aW9ucyIsImRlbGV0ZVJlbWFpbmluZ0NoaWxkcmVuIiwiY3VycmVudEZpcnN0Q2hpbGQiLCJtYXBSZW1haW5pbmdDaGlsZHJlbiIsImV4aXN0aW5nQ2hpbGRyZW4iLCJleGlzdGluZ0NoaWxkIiwidXNlRmliZXIiLCJjcmVhdGVXb3JrSW5Qcm9ncmVzcyIsInBsYWNlQ2hpbGQiLCJuZXdGaWJlciIsImxhc3RQbGFjZWRJbmRleCIsIm5ld0luZGV4Iiwib2xkSW5kZXgiLCJwbGFjZVNpbmdsZUNoaWxkIiwidXBkYXRlVGV4dE5vZGUiLCJjcmVhdGVkIiwiY3JlYXRlRmliZXJGcm9tVGV4dCIsInVwZGF0ZUVsZW1lbnQiLCJlbGVtZW50VHlwZSIsInVwZGF0ZWQiLCJ1cGRhdGVGcmFnbWVudCIsImlzQ29tcGF0aWJsZUZhbWlseUZvckhvdFJlbG9hZGluZyIsInVwZGF0ZVBvcnRhbCIsInBvcnRhbCIsImltcGxlbWVudGF0aW9uIiwiY3JlYXRlRmliZXJGcm9tUG9ydGFsIiwiZnJhZ21lbnQiLCJjcmVhdGVGaWJlckZyb21GcmFnbWVudCIsImNyZWF0ZUNoaWxkIiwiX2NyZWF0ZWQiLCJfY3JlYXRlZDIiLCJfY3JlYXRlZDMiLCJyZWFkQ29udGV4dER1cmluZ1JlY29uY2lsaWF0aW9uIiwidXBkYXRlU2xvdCIsIm9sZEZpYmVyIiwidXBkYXRlRnJvbU1hcCIsIm5ld0lkeCIsIm1hdGNoZWRGaWJlciIsIl9tYXRjaGVkRmliZXIiLCJfbWF0Y2hlZEZpYmVyMiIsIl9tYXRjaGVkRmliZXIzIiwid2Fybk9uSW52YWxpZEtleSIsImtub3duS2V5cyIsInJlY29uY2lsZUNoaWxkcmVuQXJyYXkiLCJuZXdDaGlsZHJlbiIsInJlc3VsdGluZ0ZpcnN0Q2hpbGQiLCJwcmV2aW91c05ld0ZpYmVyIiwibmV4dE9sZEZpYmVyIiwiX25ld0ZpYmVyIiwiX251bWJlck9mRm9ya3MiLCJfbmV3RmliZXIyIiwiX251bWJlck9mRm9ya3MyIiwicmVjb25jaWxlQ2hpbGRyZW5JdGVyYXRhYmxlIiwibmV3Q2hpbGRyZW5JdGVyYWJsZSIsIml0ZXJhdG9yRm4iLCJpc0dlbmVyYXRvckNvbXBvbmVudCIsImVudHJpZXMiLCJyZWNvbmNpbGVDaGlsZHJlbkl0ZXJhdG9yIiwic3RlcCIsImRvbmUiLCJfbmV3RmliZXIzIiwiX251bWJlck9mRm9ya3MzIiwiX25ld0ZpYmVyNCIsIl9udW1iZXJPZkZvcmtzNCIsInJlY29uY2lsZVNpbmdsZVRleHROb2RlIiwicmVjb25jaWxlU2luZ2xlRWxlbWVudCIsIl9leGlzdGluZyIsIl9jcmVhdGVkNCIsInJlY29uY2lsZVNpbmdsZVBvcnRhbCIsInJlY29uY2lsZUNoaWxkRmliZXJzSW1wbCIsImlzVW5rZXllZFRvcExldmVsRnJhZ21lbnQiLCJyZWNvbmNpbGVDaGlsZEZpYmVycyIsImZpcnN0Q2hpbGRGaWJlciIsIm1vdW50Q2hpbGRGaWJlcnMiLCJyZXNldENoaWxkUmVjb25jaWxlck9uVW53aW5kIiwiY2xvbmVDaGlsZEZpYmVycyIsImN1cnJlbnRDaGlsZCIsInJlc2V0Q2hpbGRGaWJlcnMiLCJyZXNldFdvcmtJblByb2dyZXNzIiwiY3VycmVudFRyZWVIaWRkZW5TdGFja0N1cnNvciIsInByZXZFbnRhbmdsZWRSZW5kZXJMYW5lc0N1cnNvciIsInB1c2hIaWRkZW5Db250ZXh0IiwicHJldkVudGFuZ2xlZFJlbmRlckxhbmVzIiwiZ2V0RW50YW5nbGVkUmVuZGVyTGFuZXMiLCJzZXRFbnRhbmdsZWRSZW5kZXJMYW5lcyIsImJhc2VMYW5lcyIsInJldXNlSGlkZGVuQ29udGV4dE9uU3RhY2siLCJwb3BIaWRkZW5Db250ZXh0IiwiaXNDdXJyZW50VHJlZUhpZGRlbiIsInN1c3BlbnNlSGFuZGxlclN0YWNrQ3Vyc29yIiwic2hlbGxCb3VuZGFyeSIsImdldFNoZWxsQm91bmRhcnkiLCJwdXNoUHJpbWFyeVRyZWVTdXNwZW5zZUhhbmRsZXIiLCJoYW5kbGVyIiwicHVzaFN1c3BlbnNlTGlzdENvbnRleHQiLCJzZXREZWZhdWx0U2hhbGxvd1N1c3BlbnNlTGlzdENvbnRleHQiLCJzdXNwZW5zZVN0YWNrQ3Vyc29yIiwicHVzaEZhbGxiYWNrVHJlZVN1c3BlbnNlSGFuZGxlciIsInJldXNlU3VzcGVuc2VIYW5kbGVyT25TdGFjayIsInB1c2hPZmZzY3JlZW5TdXNwZW5zZUhhbmRsZXIiLCJnZXRTdXNwZW5zZUhhbmRsZXIiLCJwb3BTdXNwZW5zZUhhbmRsZXIiLCJwb3BTdXNwZW5zZUxpc3RDb250ZXh0IiwiRGVmYXVsdFN1c3BlbnNlQ29udGV4dCIsIlN1YnRyZWVTdXNwZW5zZUNvbnRleHRNYXNrIiwiRm9yY2VTdXNwZW5zZUZhbGxiYWNrIiwiaGFzU3VzcGVuc2VMaXN0Q29udGV4dCIsImZsYWciLCJzZXRTaGFsbG93U3VzcGVuc2VMaXN0Q29udGV4dCIsInNoYWxsb3dDb250ZXh0IiwibmV3Q29udGV4dCIsImZpbmRGaXJzdFN1c3BlbmRlZCIsInJvdyIsInJldmVhbE9yZGVyIiwiZGlkU3VzcGVuZCIsIk5vRmxhZ3MiLCJIYXNFZmZlY3QiLCJJbnNlcnRpb24iLCJMYXlvdXQiLCJQYXNzaXZlIiwiZGlkV2FybkFib3V0TWlzbWF0Y2hlZEhvb2tzRm9yQ29tcG9uZW50IiwiZGlkV2FyblVuY2FjaGVkR2V0U25hcHNob3QiLCJkaWRXYXJuQWJvdXRVc2VXcmFwcGVkSW5UcnlDYXRjaCIsImRpZFdhcm5BYm91dEFzeW5jQ2xpZW50Q29tcG9uZW50IiwiZGlkV2FybkFib3V0VXNlRm9ybVN0YXRlIiwiY3VycmVudGx5UmVuZGVyaW5nRmliZXIkMSIsImN1cnJlbnRIb29rIiwid29ya0luUHJvZ3Jlc3NIb29rIiwiZGlkU2NoZWR1bGVSZW5kZXJQaGFzZVVwZGF0ZSIsImRpZFNjaGVkdWxlUmVuZGVyUGhhc2VVcGRhdGVEdXJpbmdUaGlzUGFzcyIsInNob3VsZERvdWJsZUludm9rZVVzZXJGbnNJbkhvb2tzREVWIiwibG9jYWxJZENvdW50ZXIiLCJ0aGVuYWJsZUluZGV4Q291bnRlciIsImdsb2JhbENsaWVudElkQ291bnRlciIsIlJFX1JFTkRFUl9MSU1JVCIsImN1cnJlbnRIb29rTmFtZUluRGV2IiwiaG9va1R5cGVzRGV2IiwiaG9va1R5cGVzVXBkYXRlSW5kZXhEZXYiLCJpZ25vcmVQcmV2aW91c0RlcGVuZGVuY2llcyIsIm1vdW50SG9va1R5cGVzRGV2IiwiaG9va05hbWUiLCJ1cGRhdGVIb29rVHlwZXNEZXYiLCJ3YXJuT25Ib29rTWlzbWF0Y2hJbkRldiIsImNoZWNrRGVwc0FyZUFycmF5RGV2IiwiZGVwcyIsImN1cnJlbnRIb29rTmFtZSIsInRhYmxlIiwic2Vjb25kQ29sdW1uU3RhcnQiLCJvbGRIb29rTmFtZSIsIm5ld0hvb2tOYW1lIiwid2Fybk9uVXNlRm9ybVN0YXRlSW5EZXYiLCJ3YXJuSWZBc3luY0NsaWVudENvbXBvbmVudCIsIkNvbXBvbmVudCIsImlzQXN5bmNGdW5jdGlvbiIsInRocm93SW52YWxpZEhvb2tFcnJvciIsImFyZUhvb2tJbnB1dHNFcXVhbCIsIm5leHREZXBzIiwicHJldkRlcHMiLCJyZW5kZXJXaXRoSG9va3MiLCJzZWNvbmRBcmciLCJuZXh0UmVuZGVyTGFuZXMiLCJfZGVidWdIb29rVHlwZXMiLCJIb29rc0Rpc3BhdGNoZXJPblVwZGF0ZUluREVWIiwiSG9va3NEaXNwYXRjaGVyT25Nb3VudFdpdGhIb29rVHlwZXNJbkRFViIsIkhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViIsInNob3VsZERvdWJsZVJlbmRlckRFViIsInJlbmRlcldpdGhIb29rc0FnYWluIiwiZmluaXNoUmVuZGVyaW5nSG9va3MiLCJDb250ZXh0T25seURpc3BhdGNoZXIiLCJkaWRSZW5kZXJUb29GZXdIb29rcyIsInJlcGxheVN1c3BlbmRlZENvbXBvbmVudFdpdGhIb29rcyIsIm51bWJlck9mUmVSZW5kZXJzIiwiSG9va3NEaXNwYXRjaGVyT25SZXJlbmRlckluREVWIiwicmVuZGVyVHJhbnNpdGlvbkF3YXJlSG9zdENvbXBvbmVudFdpdGhIb29rcyIsIlRyYW5zaXRpb25Bd2FyZUhvc3RDb21wb25lbnQiLCJkaXNwYXRjaGVyIiwiX2Rpc3BhdGNoZXIkdXNlU3RhdGUiLCJ1c2VTdGF0ZSIsIm1heWJlVGhlbmFibGUiLCJ1c2VUaGVuYWJsZSIsIl9kaXNwYXRjaGVyJHVzZVN0YXRlMiIsIm5leHRSZXNldFN0YXRlIiwicHJldlJlc2V0U3RhdGUiLCJjaGVja0RpZFJlbmRlcklkSG9vayIsImRpZFJlbmRlcklkSG9vayIsImJhaWxvdXRIb29rcyIsInJlc2V0SG9va3NBZnRlclRocm93IiwicmVzZXRIb29rc09uVW53aW5kIiwibW91bnRXb3JrSW5Qcm9ncmVzc0hvb2siLCJiYXNlUXVldWUiLCJ1cGRhdGVXb3JrSW5Qcm9ncmVzc0hvb2siLCJuZXh0Q3VycmVudEhvb2siLCJuZXh0V29ya0luUHJvZ3Jlc3NIb29rIiwiY3VycmVudEZpYmVyIiwibmV3SG9vayIsImNyZWF0ZUZ1bmN0aW9uQ29tcG9uZW50VXBkYXRlUXVldWUiLCJsYXN0RWZmZWN0IiwiZXZlbnRzIiwic3RvcmVzIiwibWVtb0NhY2hlIiwidXNlIiwidXNhYmxlIiwicmVhZENvbnRleHQiLCJ1c2VNZW1vQ2FjaGUiLCJjdXJyZW50VXBkYXRlUXVldWUiLCJjdXJyZW50TWVtb0NhY2hlIiwiZGF0YSIsImJhc2ljU3RhdGVSZWR1Y2VyIiwiYWN0aW9uIiwibW91bnRSZWR1Y2VyIiwicmVkdWNlciIsImluaXRpYWxBcmciLCJpbml0aWFsU3RhdGUiLCJkaXNwYXRjaCIsImxhc3RSZW5kZXJlZFJlZHVjZXIiLCJsYXN0UmVuZGVyZWRTdGF0ZSIsImRpc3BhdGNoUmVkdWNlckFjdGlvbiIsInVwZGF0ZVJlZHVjZXIiLCJ1cGRhdGVSZWR1Y2VySW1wbCIsImJhc2VGaXJzdCIsInBlbmRpbmdGaXJzdCIsImZpcnN0IiwibmV3QmFzZVF1ZXVlRmlyc3QiLCJuZXdCYXNlUXVldWVMYXN0IiwicmV2ZXJ0TGFuZSIsImhhc0VhZ2VyU3RhdGUiLCJlYWdlclN0YXRlIiwiX2Nsb25lMiIsIm1hcmtXb3JrSW5Qcm9ncmVzc1JlY2VpdmVkVXBkYXRlIiwicmVyZW5kZXJSZWR1Y2VyIiwibGFzdFJlbmRlclBoYXNlVXBkYXRlIiwiZmlyc3RSZW5kZXJQaGFzZVVwZGF0ZSIsIm1vdW50U3luY0V4dGVybmFsU3RvcmUiLCJzdWJzY3JpYmUiLCJnZXRTbmFwc2hvdCIsImdldFNlcnZlclNuYXBzaG90IiwibmV4dFNuYXBzaG90IiwiY2FjaGVkU25hcHNob3QiLCJyb290UmVuZGVyTGFuZXMiLCJwdXNoU3RvcmVDb25zaXN0ZW5jeUNoZWNrIiwiaW5zdCIsIm1vdW50RWZmZWN0Iiwic3Vic2NyaWJlVG9TdG9yZSIsInB1c2hFZmZlY3QiLCJ1cGRhdGVTdG9yZUluc3RhbmNlIiwiY3JlYXRlRWZmZWN0SW5zdGFuY2UiLCJ1cGRhdGVTeW5jRXh0ZXJuYWxTdG9yZSIsInByZXZTbmFwc2hvdCIsInNuYXBzaG90Q2hhbmdlZCIsInVwZGF0ZUVmZmVjdCIsInJlbmRlcmVkU25hcHNob3QiLCJjaGVjayIsImNvbXBvbmVudFVwZGF0ZVF1ZXVlIiwiY2hlY2tJZlNuYXBzaG90Q2hhbmdlZCIsImZvcmNlU3RvcmVSZXJlbmRlciIsImhhbmRsZVN0b3JlQ2hhbmdlIiwibGF0ZXN0R2V0U25hcHNob3QiLCJwcmV2VmFsdWUiLCJuZXh0VmFsdWUiLCJzY2hlZHVsZVVwZGF0ZU9uRmliZXIiLCJtb3VudFN0YXRlSW1wbCIsImluaXRpYWxTdGF0ZUluaXRpYWxpemVyIiwibW91bnRTdGF0ZSIsImRpc3BhdGNoU2V0U3RhdGUiLCJ1cGRhdGVTdGF0ZSIsInJlcmVuZGVyU3RhdGUiLCJtb3VudE9wdGltaXN0aWMiLCJwYXNzdGhyb3VnaCIsImRpc3BhdGNoT3B0aW1pc3RpY1NldFN0YXRlIiwidXBkYXRlT3B0aW1pc3RpYyIsInVwZGF0ZU9wdGltaXN0aWNJbXBsIiwicmVzb2x2ZWRSZWR1Y2VyIiwicmVyZW5kZXJPcHRpbWlzdGljIiwiZGlzcGF0Y2hBY3Rpb25TdGF0ZSIsImFjdGlvblF1ZXVlIiwic2V0UGVuZGluZ1N0YXRlIiwic2V0U3RhdGUiLCJpc1JlbmRlclBoYXNlVXBkYXRlIiwibGFzdCIsInJ1bkFjdGlvblN0YXRlQWN0aW9uIiwiX25ld0xhc3QiLCJwcmV2VHJhbnNpdGlvbiIsIlQiLCJjdXJyZW50VHJhbnNpdGlvbiIsIl91cGRhdGVkRmliZXJzIiwicmV0dXJuVmFsdWUiLCJvblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCIsIlMiLCJmaW5pc2hSdW5uaW5nQWN0aW9uU3RhdGVBY3Rpb24iLCJ1cGRhdGVkRmliZXJzQ291bnQiLCJhY3Rpb25TdGF0ZVJlZHVjZXIiLCJvbGRTdGF0ZSIsIm1vdW50QWN0aW9uU3RhdGUiLCJpbml0aWFsU3RhdGVQcm9wIiwicGVybWFsaW5rIiwic3NyRm9ybVN0YXRlIiwiZm9ybVN0YXRlIiwiaXNNYXRjaGluZyIsInN0YXRlUXVldWUiLCJwZW5kaW5nU3RhdGVIb29rIiwiYWN0aW9uUXVldWVIb29rIiwidXBkYXRlQWN0aW9uU3RhdGUiLCJjdXJyZW50U3RhdGVIb29rIiwidXBkYXRlQWN0aW9uU3RhdGVJbXBsIiwiX3VwZGF0ZVJlZHVjZXJJbXBsIiwiYWN0aW9uUmVzdWx0IiwiX3VwZGF0ZVN0YXRlIiwiaXNQZW5kaW5nIiwicHJldkFjdGlvbiIsImFjdGlvblN0YXRlQWN0aW9uRWZmZWN0IiwicmVyZW5kZXJBY3Rpb25TdGF0ZSIsImNyZWF0ZSIsImVmZmVjdCIsImZpcnN0RWZmZWN0IiwiZGVzdHJveSIsIm1vdW50UmVmIiwiaW5pdGlhbFZhbHVlIiwidXBkYXRlUmVmIiwibW91bnRFZmZlY3RJbXBsIiwiZmliZXJGbGFncyIsImhvb2tGbGFncyIsInVwZGF0ZUVmZmVjdEltcGwiLCJwcmV2RWZmZWN0IiwibW91bnRJbnNlcnRpb25FZmZlY3QiLCJ1cGRhdGVJbnNlcnRpb25FZmZlY3QiLCJtb3VudExheW91dEVmZmVjdCIsInVwZGF0ZUxheW91dEVmZmVjdCIsImltcGVyYXRpdmVIYW5kbGVFZmZlY3QiLCJyZWZDYWxsYmFjayIsInJlZkNsZWFudXAiLCJyZWZPYmplY3QiLCJfaW5zdCIsIm1vdW50SW1wZXJhdGl2ZUhhbmRsZSIsImVmZmVjdERlcHMiLCJ1cGRhdGVJbXBlcmF0aXZlSGFuZGxlIiwibW91bnREZWJ1Z1ZhbHVlIiwiZm9ybWF0dGVyRm4iLCJ1cGRhdGVEZWJ1Z1ZhbHVlIiwibW91bnRDYWxsYmFjayIsInVwZGF0ZUNhbGxiYWNrIiwibW91bnRNZW1vIiwibmV4dENyZWF0ZSIsInVwZGF0ZU1lbW8iLCJtb3VudERlZmVycmVkVmFsdWUiLCJtb3VudERlZmVycmVkVmFsdWVJbXBsIiwidXBkYXRlRGVmZXJyZWRWYWx1ZSIsInJlc29sdmVkQ3VycmVudEhvb2siLCJ1cGRhdGVEZWZlcnJlZFZhbHVlSW1wbCIsInJlcmVuZGVyRGVmZXJyZWRWYWx1ZSIsImRlZmVycmVkTGFuZSIsInJlcXVlc3REZWZlcnJlZExhbmUiLCJyZXN1bHRWYWx1ZSIsInNob3VsZERlZmVyVmFsdWUiLCJzdGFydFRyYW5zaXRpb24iLCJwZW5kaW5nU3RhdGUiLCJmaW5pc2hlZFN0YXRlIiwib3B0aW9ucyIsInByZXZpb3VzUHJpb3JpdHkiLCJ0aGVuYWJsZUZvckZpbmlzaGVkU3RhdGUiLCJub29wIiwic3RhcnRIb3N0VHJhbnNpdGlvbiIsImZvcm1GaWJlciIsImZvcm1EYXRhIiwiZW5zdXJlRm9ybUNvbXBvbmVudElzU3RhdGVmdWwiLCJyZXF1ZXN0Rm9ybVJlc2V0IiwiZXhpc3RpbmdTdGF0ZUhvb2siLCJuZXdRdWV1ZSIsImluaXRpYWxSZXNldFN0YXRlIiwibmV3UmVzZXRTdGF0ZVF1ZXVlIiwicmVzZXRTdGF0ZUhvb2siLCJyZXF1ZXN0Q3VycmVudFRyYW5zaXRpb24iLCJuZXdSZXNldFN0YXRlIiwicmVzZXRTdGF0ZVF1ZXVlIiwibW91bnRUcmFuc2l0aW9uIiwic3RhcnQiLCJ1cGRhdGVUcmFuc2l0aW9uIiwiX3VwZGF0ZVN0YXRlMiIsImJvb2xlYW5PclRoZW5hYmxlIiwicmVyZW5kZXJUcmFuc2l0aW9uIiwiX3JlcmVuZGVyU3RhdGUiLCJ1c2VIb3N0VHJhbnNpdGlvblN0YXR1cyIsIm1vdW50SWQiLCJpZGVudGlmaWVyUHJlZml4IiwidHJlZUlkIiwibG9jYWxJZCIsImdsb2JhbENsaWVudElkIiwidXBkYXRlSWQiLCJtb3VudFJlZnJlc2giLCJyZWZyZXNoIiwicmVmcmVzaENhY2hlIiwidXBkYXRlUmVmcmVzaCIsInNlZWRLZXkiLCJzZWVkVmFsdWUiLCJwcm92aWRlciIsInJlcXVlc3RVcGRhdGVMYW5lIiwicmVmcmVzaFVwZGF0ZSIsInNlZWRlZENhY2hlIiwiY3JlYXRlQ2FjaGUiLCJjYWNoZSIsImVucXVldWVSZW5kZXJQaGFzZVVwZGF0ZSIsImVudGFuZ2xlVHJhbnNpdGlvblVwZGF0ZSIsIm1hcmtVcGRhdGVJbkRldlRvb2xzIiwicHJldkRpc3BhdGNoZXIiLCJJbnZhbGlkTmVzdGVkSG9va3NEaXNwYXRjaGVyT25VcGRhdGVJbkRFViIsInRocm93SWZEdXJpbmdSZW5kZXIiLCJ1c2VDYWxsYmFjayIsInVzZUNvbnRleHQiLCJ1c2VFZmZlY3QiLCJ1c2VJbXBlcmF0aXZlSGFuZGxlIiwidXNlTGF5b3V0RWZmZWN0IiwidXNlSW5zZXJ0aW9uRWZmZWN0IiwidXNlTWVtbyIsInVzZVJlZHVjZXIiLCJ1c2VSZWYiLCJ1c2VEZWJ1Z1ZhbHVlIiwidXNlRGVmZXJyZWRWYWx1ZSIsInVzZVRyYW5zaXRpb24iLCJ1c2VTeW5jRXh0ZXJuYWxTdG9yZSIsInVzZUlkIiwidXNlQ2FjaGVSZWZyZXNoIiwidXNlRm9ybVN0YXRlIiwidXNlQWN0aW9uU3RhdGUiLCJ1c2VPcHRpbWlzdGljIiwiSW52YWxpZE5lc3RlZEhvb2tzRGlzcGF0Y2hlck9uTW91bnRJbkRFViIsIkludmFsaWROZXN0ZWRIb29rc0Rpc3BhdGNoZXJPblJlcmVuZGVySW5ERVYiLCJ3YXJuSW52YWxpZENvbnRleHRBY2Nlc3MiLCJ3YXJuSW52YWxpZEhvb2tBY2Nlc3MiLCJub3ciLCJjb21taXRUaW1lIiwibGF5b3V0RWZmZWN0U3RhcnRUaW1lIiwicHJvZmlsZXJTdGFydFRpbWUiLCJwYXNzaXZlRWZmZWN0U3RhcnRUaW1lIiwiY3VycmVudFVwZGF0ZUlzTmVzdGVkIiwibmVzdGVkVXBkYXRlU2NoZWR1bGVkIiwiaXNDdXJyZW50VXBkYXRlTmVzdGVkIiwibWFya05lc3RlZFVwZGF0ZVNjaGVkdWxlZCIsInJlc2V0TmVzdGVkVXBkYXRlRmxhZyIsInN5bmNOZXN0ZWRVcGRhdGVGbGFnIiwiZ2V0Q29tbWl0VGltZSIsInJlY29yZENvbW1pdFRpbWUiLCJzdGFydFByb2ZpbGVyVGltZXIiLCJhY3R1YWxTdGFydFRpbWUiLCJzdG9wUHJvZmlsZXJUaW1lcklmUnVubmluZyIsInN0b3BQcm9maWxlclRpbWVySWZSdW5uaW5nQW5kUmVjb3JkRGVsdGEiLCJvdmVycmlkZUJhc2VUaW1lIiwiZWxhcHNlZFRpbWUiLCJhY3R1YWxEdXJhdGlvbiIsInNlbGZCYXNlRHVyYXRpb24iLCJyZWNvcmRMYXlvdXRFZmZlY3REdXJhdGlvbiIsInBhcmVudEZpYmVyIiwiZWZmZWN0RHVyYXRpb24iLCJwYXJlbnRTdGF0ZU5vZGUiLCJyZWNvcmRQYXNzaXZlRWZmZWN0RHVyYXRpb24iLCJwYXNzaXZlRWZmZWN0RHVyYXRpb24iLCJzdGFydExheW91dEVmZmVjdFRpbWVyIiwic3RhcnRQYXNzaXZlRWZmZWN0VGltZXIiLCJ0cmFuc2ZlckFjdHVhbER1cmF0aW9uIiwiZmFrZUludGVybmFsSW5zdGFuY2UiLCJkaWRXYXJuQWJvdXRTdGF0ZUFzc2lnbm1lbnRGb3JDb21wb25lbnQiLCJkaWRXYXJuQWJvdXRVbmluaXRpYWxpemVkU3RhdGUiLCJkaWRXYXJuQWJvdXRHZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZVdpdGhvdXREaWRVcGRhdGUiLCJkaWRXYXJuQWJvdXRMZWdhY3lMaWZlY3ljbGVzQW5kRGVyaXZlZFN0YXRlIiwiZGlkV2FybkFib3V0VW5kZWZpbmVkRGVyaXZlZFN0YXRlIiwiZGlkV2FybkFib3V0RGlyZWN0bHlBc3NpZ25pbmdQcm9wc1RvU3RhdGUiLCJkaWRXYXJuQWJvdXRJbnZhbGlkYXRlQ29udGV4dFR5cGUiLCJkaWRXYXJuT25JbnZhbGlkQ2FsbGJhY2siLCJ3YXJuT25JbnZhbGlkQ2FsbGJhY2siLCJ3YXJuT25VbmRlZmluZWREZXJpdmVkU3RhdGUiLCJhcHBseURlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsImdldERlcml2ZWRTdGF0ZUZyb21Qcm9wcyIsImNsYXNzQ29tcG9uZW50VXBkYXRlciIsImVucXVldWVTZXRTdGF0ZSIsImVucXVldWVSZXBsYWNlU3RhdGUiLCJlbnF1ZXVlRm9yY2VVcGRhdGUiLCJjaGVja1Nob3VsZENvbXBvbmVudFVwZGF0ZSIsIm9sZFByb3BzIiwibmV3UHJvcHMiLCJzaG91bGRDb21wb25lbnRVcGRhdGUiLCJzaG91bGRVcGRhdGUiLCJpc1B1cmVSZWFjdENvbXBvbmVudCIsImNoZWNrQ2xhc3NJbnN0YW5jZSIsInJlbmRlclByZXNlbnQiLCJnZXRJbml0aWFsU3RhdGUiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsImdldERlZmF1bHRQcm9wcyIsInByb3BUeXBlcyIsImNvbnRleHRUeXBlIiwiY29tcG9uZW50U2hvdWxkVXBkYXRlIiwiY29tcG9uZW50RGlkVW5tb3VudCIsImNvbXBvbmVudERpZFJlY2VpdmVQcm9wcyIsImNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJVTlNBRkVfY29tcG9uZW50V2lsbFJlY2lldmVQcm9wcyIsImhhc011dGF0ZWRQcm9wcyIsImRlZmF1bHRQcm9wcyIsImdldFNuYXBzaG90QmVmb3JlVXBkYXRlIiwiY29tcG9uZW50RGlkVXBkYXRlIiwiZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yIiwiY29uc3RydWN0Q2xhc3NJbnN0YW5jZSIsImlzVmFsaWQiLCJhZGRlbmR1bSIsInVwZGF0ZXIiLCJfcmVhY3RJbnRlcm5hbEluc3RhbmNlIiwiZm91bmRXaWxsTW91bnROYW1lIiwiZm91bmRXaWxsUmVjZWl2ZVByb3BzTmFtZSIsImZvdW5kV2lsbFVwZGF0ZU5hbWUiLCJfY29tcG9uZW50TmFtZSIsIm5ld0FwaU5hbWUiLCJjYWxsQ29tcG9uZW50V2lsbE1vdW50IiwiY2FsbENvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMiLCJtb3VudENsYXNzSW5zdGFuY2UiLCJyZWZzIiwiY29tcG9uZW50RGlkTW91bnQiLCJyZXN1bWVNb3VudENsYXNzSW5zdGFuY2UiLCJ1bnJlc29sdmVkT2xkUHJvcHMiLCJyZXNvbHZlQ2xhc3NDb21wb25lbnRQcm9wcyIsIm9sZENvbnRleHQiLCJoYXNOZXdMaWZlY3ljbGVzIiwidW5yZXNvbHZlZE5ld1Byb3BzIiwiZGlkUmVjZWl2ZU5ld1Byb3BzIiwidXBkYXRlQ2xhc3NJbnN0YW5jZSIsImJhc2VQcm9wcyIsImFscmVhZHlSZXNvbHZlZERlZmF1bHRQcm9wcyIsInJlcG9ydEdsb2JhbEVycm9yIiwicmVwb3J0RXJyb3IiLCJ3aW5kb3ciLCJFcnJvckV2ZW50IiwiZXZlbnQiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsInNob3VsZExvZyIsImRpc3BhdGNoRXZlbnQiLCJlbWl0IiwiZXJyb3JCb3VuZGFyeU5hbWUiLCJkZWZhdWx0T25VbmNhdWdodEVycm9yIiwiZXJyb3JJbmZvIiwiY29tcG9uZW50TmFtZU1lc3NhZ2UiLCJlcnJvckJvdW5kYXJ5TWVzc2FnZSIsImNvbXBvbmVudFN0YWNrIiwiZGVmYXVsdE9uQ2F1Z2h0RXJyb3IiLCJlcnJvciQxIiwicmVjcmVhdGVNZXNzYWdlIiwiZGVmYXVsdE9uUmVjb3ZlcmFibGVFcnJvciIsImxvZ1VuY2F1Z2h0RXJyb3IiLCJ0aHJvd25FcnJvcnMiLCJvblVuY2F1Z2h0RXJyb3IiLCJlIiwic2V0VGltZW91dCIsImxvZ0NhdWdodEVycm9yIiwiYm91bmRhcnkiLCJvbkNhdWdodEVycm9yIiwiZXJyb3JCb3VuZGFyeSIsImNyZWF0ZVJvb3RFcnJvclVwZGF0ZSIsInByZXZGaWJlciIsImNyZWF0ZUNsYXNzRXJyb3JVcGRhdGUiLCJpbml0aWFsaXplQ2xhc3NFcnJvclVwZGF0ZSIsIm1hcmtGYWlsZWRFcnJvckJvdW5kYXJ5Rm9ySG90UmVsb2FkaW5nIiwiY29tcG9uZW50RGlkQ2F0Y2giLCJtYXJrTGVnYWN5RXJyb3JCb3VuZGFyeUFzRmFpbGVkIiwibWFya1N1c3BlbnNlQm91bmRhcnlTaG91bGRDYXB0dXJlIiwic3VzcGVuc2VCb3VuZGFyeSIsInRocm93RXhjZXB0aW9uIiwicmVzdG9yZVBlbmRpbmdVcGRhdGVycyIsInJlbmRlckRpZFN1c3BlbmREZWxheUlmUG9zc2libGUiLCJyZW5kZXJEaWRTdXNwZW5kIiwiaXNTdXNwZW5zZXlSZXNvdXJjZSIsInJldHJ5UXVldWUiLCJhdHRhY2hQaW5nTGlzdGVuZXIiLCJfaXNTdXNwZW5zZXlSZXNvdXJjZSIsIm9mZnNjcmVlblF1ZXVlIiwibmV3T2Zmc2NyZWVuUXVldWUiLCJ0cmFuc2l0aW9ucyIsIm1hcmtlckluc3RhbmNlcyIsIl9yZXRyeVF1ZXVlIiwiX3N1c3BlbnNlQm91bmRhcnkiLCJfd3JhcHBlckVycm9yIiwiY2F1c2UiLCJfd3JhcHBlckVycm9yMiIsIl93b3JrSW5Qcm9ncmVzcyIsInJvb3RFcnJvckluZm8iLCJyZW5kZXJEaWRFcnJvciIsIndyYXBwZXJFcnJvciIsInF1ZXVlQ29uY3VycmVudEVycm9yIiwiX2xhbmUiLCJfdXBkYXRlIiwiaXNBbHJlYWR5RmFpbGVkTGVnYWN5RXJyb3JCb3VuZGFyeSIsIl9sYW5lMiIsIl91cGRhdGUyIiwiU2VsZWN0aXZlSHlkcmF0aW9uRXhjZXB0aW9uIiwiZGlkUmVjZWl2ZVVwZGF0ZSIsImRpZFdhcm5BYm91dEJhZENsYXNzIiwiZGlkV2FybkFib3V0Q29udGV4dFR5cGVPbkZ1bmN0aW9uQ29tcG9uZW50IiwiZGlkV2FybkFib3V0R2V0RGVyaXZlZFN0YXRlT25GdW5jdGlvbkNvbXBvbmVudCIsImRpZFdhcm5BYm91dFJlYXNzaWduaW5nUHJvcHMiLCJkaWRXYXJuQWJvdXRSZXZlYWxPcmRlciIsImRpZFdhcm5BYm91dFRhaWxPcHRpb25zIiwicmVjb25jaWxlQ2hpbGRyZW4iLCJuZXh0Q2hpbGRyZW4iLCJmb3JjZVVubW91bnRDdXJyZW50QW5kUmVjb25jaWxlIiwidXBkYXRlRm9yd2FyZFJlZiIsInByb3BzV2l0aG91dFJlZiIsImhhc0lkIiwicHJlcGFyZVRvUmVhZENvbnRleHQiLCJiYWlsb3V0T25BbHJlYWR5RmluaXNoZWRXb3JrIiwidXBkYXRlTWVtb0NvbXBvbmVudCIsImlzU2ltcGxlRnVuY3Rpb25Db21wb25lbnQiLCJjb21wYXJlIiwicmVzb2x2ZWRUeXBlIiwicmVzb2x2ZUZ1bmN0aW9uRm9ySG90UmVsb2FkaW5nIiwidmFsaWRhdGVGdW5jdGlvbkNvbXBvbmVudEluRGV2IiwidXBkYXRlU2ltcGxlTWVtb0NvbXBvbmVudCIsImNyZWF0ZUZpYmVyRnJvbVR5cGVBbmRQcm9wcyIsImhhc1NjaGVkdWxlZFVwZGF0ZU9yQ29udGV4dCIsImNoZWNrU2NoZWR1bGVkVXBkYXRlT3JDb250ZXh0IiwicHJldlByb3BzIiwidXBkYXRlRnVuY3Rpb25Db21wb25lbnQiLCJ1cGRhdGVPZmZzY3JlZW5Db21wb25lbnQiLCJuZXh0SXNEZXRhY2hlZCIsIl9wZW5kaW5nVmlzaWJpbGl0eSIsIm1hcmtSZWYiLCJuZXh0QmFzZUxhbmVzIiwiY3VycmVudENoaWxkTGFuZXMiLCJsYW5lc1dlSnVzdEF0dGVtcHRlZCIsInJlbWFpbmluZ0NoaWxkTGFuZXMiLCJkZWZlckhpZGRlbk9mZnNjcmVlbkNvbXBvbmVudCIsIl9uZXh0QmFzZUxhbmVzIiwiX25leHRTdGF0ZSIsImNhY2hlUG9vbCIsInByZXZDYWNoZVBvb2wiLCJwdXNoVHJhbnNpdGlvbiIsIl9wcmV2Q2FjaGVQb29sIiwiZ2V0T2Zmc2NyZWVuRGVmZXJyZWRDYWNoZSIsInVwZGF0ZUNhY2hlQ29tcG9uZW50IiwicGFyZW50Q2FjaGUiLCJDYWNoZUNvbnRleHQiLCJmcmVzaENhY2hlIiwicmVxdWVzdENhY2hlRnJvbVBvb2wiLCJwdXNoQ2FjaGVQcm92aWRlciIsImRlcml2ZWRTdGF0ZSIsIm5leHRDYWNoZSIsInByb3BhZ2F0ZUNvbnRleHRDaGFuZ2UiLCJ1cGRhdGVNb2RlIiwidXBkYXRlUHJvZmlsZXIiLCJyZXBsYXlGdW5jdGlvbkNvbXBvbmVudCIsInVwZGF0ZUNsYXNzQ29tcG9uZW50Iiwic2hvdWxkRXJyb3IiLCJfaW5zdGFuY2UiLCJ0ZW1wSW5zdGFuY2UiLCJoYXNDb250ZXh0IiwibmV4dFVuaXRPZldvcmsiLCJmaW5pc2hDbGFzc0NvbXBvbmVudCIsImRpZENhcHR1cmVFcnJvciIsInB1c2hIb3N0Um9vdENvbnRleHQiLCJ1cGRhdGVIb3N0Um9vdCIsInByZXZDaGlsZHJlbiIsIm92ZXJyaWRlU3RhdGUiLCJtb3VudEhvc3RSb290V2l0aG91dEh5ZHJhdGluZyIsInJlY292ZXJhYmxlRXJyb3IiLCJ1cGRhdGVIb3N0Q29tcG9uZW50JDEiLCJpc0RpcmVjdFRleHRDaGlsZCIsIm9sZFN0YXRlSG9vayIsInVwZGF0ZUhvc3RIb2lzdGFibGUiLCJjdXJyZW50UHJvcHMiLCJyZXNvdXJjZSIsInVwZGF0ZUhvc3RTaW5nbGV0b24iLCJ1cGRhdGVIb3N0VGV4dCQxIiwibW91bnRMYXp5Q29tcG9uZW50IiwiX2N1cnJlbnQiLCJpc0Z1bmN0aW9uQ2xhc3NDb21wb25lbnQiLCJyZXNvbHZlZFByb3BzIiwicmVzb2x2ZUNsYXNzRm9ySG90UmVsb2FkaW5nIiwiX3Jlc29sdmVkUHJvcHMiLCJfcmVzb2x2ZWRQcm9wczIiLCJyZXNvbHZlRm9yd2FyZFJlZkZvckhvdFJlbG9hZGluZyIsIl9yZXNvbHZlZFByb3BzMyIsImhpbnQiLCJfY29tcG9uZW50TmFtZTIiLCJfY29tcG9uZW50TmFtZTMiLCJTVVNQRU5ERURfTUFSS0VSIiwibW91bnRTdXNwZW5zZU9mZnNjcmVlblN0YXRlIiwiZ2V0U3VzcGVuZGVkQ2FjaGUiLCJ1cGRhdGVTdXNwZW5zZU9mZnNjcmVlblN0YXRlIiwicHJldk9mZnNjcmVlblN0YXRlIiwicG9vbCIsInNob3VsZFJlbWFpbk9uRmFsbGJhY2siLCJzdXNwZW5zZUNvbnRleHQiLCJnZXRSZW1haW5pbmdXb3JrSW5QcmltYXJ5VHJlZSIsInByaW1hcnlUcmVlRGlkRGVmZXIiLCJwZWVrRGVmZXJyZWRMYW5lIiwidXBkYXRlU3VzcGVuc2VDb21wb25lbnQiLCJzaG91bGRTdXNwZW5kIiwic2hvd0ZhbGxiYWNrIiwiZGlkUHJpbWFyeUNoaWxkcmVuRGVmZXIiLCJtb3VudERlaHlkcmF0ZWRTdXNwZW5zZUNvbXBvbmVudCIsIm5leHRQcmltYXJ5Q2hpbGRyZW4iLCJuZXh0RmFsbGJhY2tDaGlsZHJlbiIsImZhbGxiYWNrIiwiZmFsbGJhY2tGcmFnbWVudCIsIm1vdW50U3VzcGVuc2VGYWxsYmFja0NoaWxkcmVuIiwicHJpbWFyeUNoaWxkRnJhZ21lbnQiLCJtb3VudFN1c3BlbnNlUHJpbWFyeUNoaWxkcmVuIiwiX2RlaHlkcmF0ZWQiLCJ1cGRhdGVEZWh5ZHJhdGVkU3VzcGVuc2VDb21wb25lbnQiLCJfbmV4dEZhbGxiYWNrQ2hpbGRyZW4iLCJfbmV4dFByaW1hcnlDaGlsZHJlbiIsImZhbGxiYWNrQ2hpbGRGcmFnbWVudCIsInVwZGF0ZVN1c3BlbnNlRmFsbGJhY2tDaGlsZHJlbiIsIl9wcmltYXJ5Q2hpbGRGcmFnbWVudDIiLCJfbmV4dFByaW1hcnlDaGlsZHJlbjIiLCJfcHJpbWFyeUNoaWxkRnJhZ21lbnQzIiwidXBkYXRlU3VzcGVuc2VQcmltYXJ5Q2hpbGRyZW4iLCJwcmltYXJ5Q2hpbGRyZW4iLCJwcmltYXJ5Q2hpbGRQcm9wcyIsIm1vdW50V29ya0luUHJvZ3Jlc3NPZmZzY3JlZW5GaWJlciIsImZhbGxiYWNrQ2hpbGRyZW4iLCJvZmZzY3JlZW5Qcm9wcyIsImNyZWF0ZUZpYmVyRnJvbU9mZnNjcmVlbiIsInVwZGF0ZVdvcmtJblByb2dyZXNzT2Zmc2NyZWVuRmliZXIiLCJjdXJyZW50UHJpbWFyeUNoaWxkRnJhZ21lbnQiLCJjdXJyZW50RmFsbGJhY2tDaGlsZEZyYWdtZW50Iiwic3VidHJlZUZsYWdzIiwicmV0cnlTdXNwZW5zZUNvbXBvbmVudFdpdGhvdXRIeWRyYXRpbmciLCJtb3VudFN1c3BlbnNlRmFsbGJhY2tBZnRlclJldHJ5V2l0aG91dEh5ZHJhdGluZyIsImZpYmVyTW9kZSIsImRpZ2VzdCIsIl9nZXRTdXNwZW5zZUluc3RhbmNlRiIsImNhcHR1cmVkVmFsdWUiLCJhdHRlbXB0SHlkcmF0aW9uQXRMYW5lIiwicmV0cnkiLCJyZXRyeURlaHlkcmF0ZWRTdXNwZW5zZUJvdW5kYXJ5IiwiX3ByaW1hcnlDaGlsZEZyYWdtZW50NCIsInNjaGVkdWxlU3VzcGVuc2VXb3JrT25GaWJlciIsInByb3BhZ2F0aW9uUm9vdCIsInNjaGVkdWxlQ29udGV4dFdvcmtPblBhcmVudFBhdGgiLCJwcm9wYWdhdGVTdXNwZW5zZUNvbnRleHRDaGFuZ2UiLCJmaXJzdENoaWxkIiwiZmluZExhc3RDb250ZW50Um93IiwibGFzdENvbnRlbnRSb3ciLCJjdXJyZW50Um93IiwidmFsaWRhdGVSZXZlYWxPcmRlciIsInZhbGlkYXRlVGFpbE9wdGlvbnMiLCJ0YWlsTW9kZSIsInZhbGlkYXRlU3VzcGVuc2VMaXN0TmVzdGVkQ2hpbGQiLCJjaGlsZFNsb3QiLCJpc0FuQXJyYXkiLCJpc0l0ZXJhYmxlIiwidmFsaWRhdGVTdXNwZW5zZUxpc3RDaGlsZHJlbiIsImNoaWxkcmVuSXRlcmF0b3IiLCJpbml0U3VzcGVuc2VMaXN0UmVuZGVyU3RhdGUiLCJpc0JhY2t3YXJkcyIsInRhaWwiLCJyZW5kZXJTdGF0ZSIsInJlbmRlcmluZ1N0YXJ0VGltZSIsInVwZGF0ZVN1c3BlbnNlTGlzdENvbXBvbmVudCIsInNob3VsZEZvcmNlRmFsbGJhY2siLCJkaWRTdXNwZW5kQmVmb3JlIiwiX3RhaWwiLCJuZXh0Um93IiwidXBkYXRlUG9ydGFsQ29tcG9uZW50IiwiaGFzV2FybmVkQWJvdXRVc2luZ05vVmFsdWVQcm9wT25Db250ZXh0UHJvdmlkZXIiLCJ1cGRhdGVDb250ZXh0UHJvdmlkZXIiLCJuZXdWYWx1ZSIsInB1c2hQcm92aWRlciIsIm9sZFZhbHVlIiwidXBkYXRlQ29udGV4dENvbnN1bWVyIiwiY29uc3VtZXJUeXBlIiwiZGVwZW5kZW5jaWVzIiwicmVtb3VudEZpYmVyIiwib2xkV29ya0luUHJvZ3Jlc3MiLCJuZXdXb3JrSW5Qcm9ncmVzcyIsInByZXZTaWJsaW5nIiwidXBkYXRlTGFuZXMiLCJhdHRlbXB0RWFybHlCYWlsb3V0SWZOb1NjaGVkdWxlZFVwZGF0ZSIsImhhc0NoaWxkV29yayIsInByaW1hcnlDaGlsZExhbmVzIiwiX2hhc0NoaWxkV29yayIsIl9jYWNoZSIsImJlZ2luV29yayIsIl9kZWJ1Z05lZWRzUmVtb3VudCIsInVucmVzb2x2ZWRQcm9wcyIsIl9Db21wb25lbnQiLCJfdW5yZXNvbHZlZFByb3BzIiwiX3Jlc29sdmVkUHJvcHM0IiwiX3VucmVzb2x2ZWRQcm9wczIiLCJfcmVzb2x2ZWRQcm9wczUiLCJfdHlwZSIsIl91bnJlc29sdmVkUHJvcHMzIiwiX3Jlc29sdmVkUHJvcHM2IiwidmFsdWVDdXJzb3IiLCJyZW5kZXJlckN1cnNvckRFViIsInJlbmRlcmVyMkN1cnNvckRFViIsInJlbmRlcmVyU2lnaWwiLCJjdXJyZW50bHlSZW5kZXJpbmdGaWJlciIsImxhc3RDb250ZXh0RGVwZW5kZW5jeSIsImxhc3RGdWxseU9ic2VydmVkQ29udGV4dCIsImlzRGlzYWxsb3dlZENvbnRleHRSZWFkSW5ERVYiLCJyZXNldENvbnRleHREZXBlbmRlbmNpZXMiLCJwcm92aWRlckZpYmVyIiwiX2N1cnJlbnRSZW5kZXJlciIsIl9jdXJyZW50UmVuZGVyZXIyIiwicG9wUHJvdmlkZXIiLCJjdXJyZW50VmFsdWUiLCJjdXJyZW50UmVuZGVyZXIiLCJjdXJyZW50UmVuZGVyZXIyIiwicHJvcGFnYXRlQ29udGV4dENoYW5nZV9lYWdlciIsIm5leHRGaWJlciIsImxpc3QiLCJkZXBlbmRlbmN5IiwiZmlyc3RDb250ZXh0IiwicGFyZW50U3VzcGVuc2UiLCJfYWx0ZXJuYXRlIiwicmVhZENvbnRleHRGb3JDb25zdW1lciIsImNvbnRleHRJdGVtIiwibWVtb2l6ZWRWYWx1ZSIsIkFib3J0Q29udHJvbGxlckxvY2FsIiwiQWJvcnRDb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyU2hpbSIsInNpZ25hbCIsImFib3J0ZWQiLCJhZGRFdmVudExpc3RlbmVyIiwiYWJvcnQiLCJzY2hlZHVsZUNhbGxiYWNrJDEiLCJOb3JtYWxQcmlvcml0eSIsImNvbnRyb2xsZXIiLCJyZWZDb3VudCIsInJldGFpbkNhY2hlIiwicmVsZWFzZUNhY2hlIiwicG9wQ2FjaGVQcm92aWRlciIsInByZXZPblN0YXJ0VHJhbnNpdGlvbkZpbmlzaCIsIm9uU3RhcnRUcmFuc2l0aW9uRmluaXNoRm9yUmVjb25jaWxlciIsInJlc3VtZWRDYWNoZSIsInBlZWtDYWNoZUZyb21Qb29sIiwiY2FjaGVSZXN1bWVkRnJvbVByZXZpb3VzUmVuZGVyIiwiY2FjaGVGcm9tUm9vdENhY2hlUG9vbCIsInBvb2xlZENhY2hlIiwiY2FjaGVGcm9tUG9vbCIsInBvb2xlZENhY2hlTGFuZXMiLCJvZmZzY3JlZW5Xb3JrSW5Qcm9ncmVzcyIsIm5ld1RyYW5zaXRpb25zIiwicG9wVHJhbnNpdGlvbiIsIm1hcmtVcGRhdGUiLCJkb2VzUmVxdWlyZUNsb25lIiwiY29tcGxldGVkV29yayIsImRpZEJhaWxvdXQiLCJhcHBlbmRBbGxDaGlsZHJlbiIsIm5lZWRzVmlzaWJpbGl0eVRvZ2dsZSIsIl9ub2RlIiwiYXBwZW5kQWxsQ2hpbGRyZW5Ub0NvbnRhaW5lciIsImNvbnRhaW5lckNoaWxkU2V0IiwiX2luc3RhbmNlMiIsIl9uZWVkc1Zpc2liaWxpdHlUb2dnbGUiLCJ1cGRhdGVIb3N0Q29udGFpbmVyIiwicG9ydGFsT3JSb290IiwiY29udGFpbmVyIiwibmV3Q2hpbGRTZXQiLCJwZW5kaW5nQ2hpbGRyZW4iLCJ1cGRhdGVIb3N0Q29tcG9uZW50IiwiY3VycmVudEluc3RhbmNlIiwiX29sZFByb3BzIiwicmVxdWlyZXNDbG9uZSIsIm5ld0luc3RhbmNlIiwicHJlbG9hZEluc3RhbmNlQW5kU3VzcGVuZElmTmVlZGVkIiwiaXNSZWFkeSIsInNob3VsZFJlbWFpbk9uUHJldmlvdXNTY3JlZW4iLCJwcmVsb2FkUmVzb3VyY2VBbmRTdXNwZW5kSWZOZWVkZWQiLCJzY2hlZHVsZVJldHJ5RWZmZWN0Iiwid2FrZWFibGVzIiwidXBkYXRlSG9zdFRleHQiLCJvbGRUZXh0IiwibmV3VGV4dCIsInJvb3RDb250YWluZXJJbnN0YW5jZSIsImN1dE9mZlRhaWxJZk5lZWRlZCIsImhhc1JlbmRlcmVkQVRhaWxGYWxsYmFjayIsImxhc3RUYWlsTm9kZSIsIl90YWlsTm9kZSIsIl9sYXN0VGFpbE5vZGUiLCJidWJibGVQcm9wZXJ0aWVzIiwibmV3Q2hpbGRMYW5lcyIsInRyZWVCYXNlRHVyYXRpb24iLCJfdHJlZUJhc2VEdXJhdGlvbiIsIl9jaGlsZDIiLCJfY2hpbGQzIiwiY29tcGxldGVEZWh5ZHJhdGVkU3VzcGVuc2VCb3VuZGFyeSIsIndhc0h5ZHJhdGVkIiwiaXNUaW1lZE91dFN1c3BlbnNlIiwiX2lzVGltZWRPdXRTdXNwZW5zZSIsIl9wcmltYXJ5Q2hpbGRGcmFnbWVudCIsImNvbXBsZXRlV29yayIsImZpYmVyUm9vdCIsInByZXZpb3VzQ2FjaGUiLCJwZW5kaW5nQ29udGV4dCIsIm5leHRSZXNvdXJjZSIsImN1cnJlbnRSZXNvdXJjZSIsIl9vbGRQcm9wczIiLCJfd2FzSHlkcmF0ZWQiLCJfdHlwZTIiLCJfY3VycmVudEhvc3RDb250ZXh0IiwiX3dhc0h5ZHJhdGVkMiIsIl9yb290Q29udGFpbmVySW5zdGFuY2UiLCJfaW5zdGFuY2UzIiwiX3Jvb3RDb250YWluZXJJbnN0YW5jZTIiLCJfY3VycmVudEhvc3RDb250ZXh0MiIsIl93YXNIeWRyYXRlZDMiLCJmYWxsdGhyb3VnaFRvTm9ybWFsU3VzcGVuc2VQYXRoIiwibmV4dERpZFRpbWVvdXQiLCJwcmV2RGlkVGltZW91dCIsIl9wcmV2aW91c0NhY2hlIiwiX29mZnNjcmVlbkZpYmVyMiIsImRpZFN1c3BlbmRBbHJlYWR5IiwicmVuZGVyZWRUYWlsIiwiY2Fubm90QmVTdXNwZW5kZWQiLCJyZW5kZXJIYXNOb3RTdXNwZW5kZWRZZXQiLCJzdXNwZW5kZWQiLCJnZXRSZW5kZXJUYXJnZXRUaW1lIiwiX3N1c3BlbmRlZCIsIl9yZXRyeVF1ZXVlMiIsInByZXZpb3VzU2libGluZyIsIm5leHRJc0hpZGRlbiIsIl9wcmV2U3RhdGUiLCJwcmV2SXNIaWRkZW4iLCJfcmV0cnlRdWV1ZTMiLCJfcHJldmlvdXNDYWNoZTIiLCJfY2FjaGUyIiwiX3ByZXZpb3VzQ2FjaGUzIiwiX2NhY2hlMyIsInVud2luZFdvcmsiLCJfZmxhZ3MiLCJfZmxhZ3MyIiwiX2ZsYWdzMyIsInVud2luZEludGVycnVwdGVkV29yayIsImludGVycnVwdGVkV29yayIsImRpZFdhcm5BYm91dFVuZGVmaW5lZFNuYXBzaG90QmVmb3JlVXBkYXRlIiwib2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuIiwib2Zmc2NyZWVuU3VidHJlZVdhc0hpZGRlbiIsIm5lZWRzRm9ybVJlc2V0IiwiUG9zc2libHlXZWFrU2V0IiwiV2Vha1NldCIsIm5leHRFZmZlY3QiLCJpblByb2dyZXNzTGFuZXMiLCJpblByb2dyZXNzUm9vdCIsInNob3VsZFByb2ZpbGUiLCJjYWxsQ29tcG9uZW50V2lsbFVubW91bnRXaXRoVGltZXIiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInNhZmVseUNhbGxDb21wb25lbnRXaWxsVW5tb3VudCIsIm5lYXJlc3RNb3VudGVkQW5jZXN0b3IiLCJjYXB0dXJlQ29tbWl0UGhhc2VFcnJvciIsInNhZmVseUF0dGFjaFJlZiIsImNvbW1pdEF0dGFjaFJlZiIsInNhZmVseURldGFjaFJlZiIsImZpbmlzaGVkV29yayIsInNhZmVseUNhbGxEZXN0cm95Iiwic2hvdWxkRmlyZUFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyIiwiY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzIiwiY29tbWl0QmVmb3JlTXV0YXRpb25FZmZlY3RzX2JlZ2luIiwic2hvdWxkRmlyZSIsImNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c19jb21wbGV0ZSIsImNvbW1pdEJlZm9yZU11dGF0aW9uRWZmZWN0c09uRmliZXIiLCJzbmFwc2hvdCIsImRpZFdhcm5TZXQiLCJfX3JlYWN0SW50ZXJuYWxTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsImNvbW1pdEhvb2tFZmZlY3RMaXN0VW5tb3VudCIsInNldElzUnVubmluZ0luc2VydGlvbkVmZmVjdCIsImNvbW1pdEhvb2tFZmZlY3RMaXN0TW91bnQiLCJjb21taXRQYXNzaXZlRWZmZWN0RHVyYXRpb25zIiwiZmluaXNoZWRSb290IiwiX2ZpbmlzaGVkV29yayRtZW1vaXplIiwib25Qb3N0Q29tbWl0IiwicGhhc2UiLCJjb21taXRIb29rTGF5b3V0RWZmZWN0cyIsImNvbW1pdENsYXNzTGF5b3V0TGlmZWN5Y2xlcyIsImNvbW1pdENsYXNzQ2FsbGJhY2tzIiwiY29tbWl0SG9zdENvbXBvbmVudE1vdW50IiwiY29tbWl0UHJvZmlsZXJVcGRhdGUiLCJfZmluaXNoZWRXb3JrJG1lbW9pemUyIiwib25Db21taXQiLCJvblJlbmRlciIsImVucXVldWVQZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0IiwiY29tbWl0TGF5b3V0RWZmZWN0T25GaWJlciIsImNvbW1pdHRlZExhbmVzIiwicmVjdXJzaXZlbHlUcmF2ZXJzZUxheW91dEVmZmVjdHMiLCJjb21taXRTdXNwZW5zZUh5ZHJhdGlvbkNhbGxiYWNrcyIsImlzTW9kZXJuUm9vdCIsIm5ld09mZnNjcmVlblN1YnRyZWVJc0hpZGRlbiIsIndhc0hpZGRlbiIsIm5ld09mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4iLCJwcmV2T2Zmc2NyZWVuU3VidHJlZUlzSGlkZGVuIiwicHJldk9mZnNjcmVlblN1YnRyZWVXYXNIaWRkZW4iLCJpbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzIiwicmVjdXJzaXZlbHlUcmF2ZXJzZVJlYXBwZWFyTGF5b3V0RWZmZWN0cyIsImhpZGVPclVuaGlkZUFsbENoaWxkcmVuIiwiaG9zdFN1YnRyZWVSb290IiwiaW5zdGFuY2VUb1VzZSIsImRldGFjaEZpYmVyTXV0YXRpb24iLCJkZXRhY2hGaWJlckFmdGVyRWZmZWN0cyIsImhvc3RJbnN0YW5jZSIsImVtcHR5UG9ydGFsQ29udGFpbmVyIiwiZW1wdHlDaGlsZFNldCIsImdldEhvc3RQYXJlbnRGaWJlciIsImlzSG9zdFBhcmVudCIsImdldEhvc3RTaWJsaW5nIiwiY29tbWl0UGxhY2VtZW50IiwiYmVmb3JlIiwiaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlIiwiX3BhcmVudCIsIl9iZWZvcmUiLCJfcGFyZW50MiIsIl9iZWZvcmUyIiwiaW5zZXJ0T3JBcHBlbmRQbGFjZW1lbnROb2RlSW50b0NvbnRhaW5lciIsImlzSG9zdCIsImhvc3RQYXJlbnQiLCJob3N0UGFyZW50SXNDb250YWluZXIiLCJjb21taXREZWxldGlvbkVmZmVjdHMiLCJkZWxldGVkRmliZXIiLCJmaW5kUGFyZW50IiwiY29tbWl0RGVsZXRpb25FZmZlY3RzT25GaWJlciIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VEZWxldGlvbkVmZmVjdHMiLCJwcmV2SG9zdFBhcmVudCIsInByZXZIb3N0UGFyZW50SXNDb250YWluZXIiLCJfcHJldkhvc3RQYXJlbnQiLCJfcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lciIsIl9wcmV2SG9zdFBhcmVudDIiLCJfcHJldkhvc3RQYXJlbnRJc0NvbnRhaW5lcjIiLCJjb21taXRTdXNwZW5zZUNhbGxiYWNrIiwiaHlkcmF0aW9uQ2FsbGJhY2tzIiwib25IeWRyYXRlZCIsImdldFJldHJ5Q2FjaGUiLCJyZXRyeUNhY2hlIiwiX3JldHJ5Q2FjaGUiLCJkZXRhY2hPZmZzY3JlZW5JbnN0YW5jZSIsImF0dGFjaE9mZnNjcmVlbkluc3RhbmNlIiwiYXR0YWNoU3VzcGVuc2VSZXRyeUxpc3RlbmVycyIsInJlc29sdmVSZXRyeVdha2VhYmxlIiwiY29tbWl0TXV0YXRpb25FZmZlY3RzIiwiY29tbWl0TXV0YXRpb25FZmZlY3RzT25GaWJlciIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VNdXRhdGlvbkVmZmVjdHMiLCJjdXJyZW50SG9pc3RhYmxlUm9vdCIsImNvbW1pdFJlY29uY2lsaWF0aW9uRWZmZWN0cyIsImhvaXN0YWJsZVJvb3QiLCJuZXdSZXNvdXJjZSIsInByZXZpb3VzV29yayIsInNpbmdsZXRvbiIsInByZXZpb3VzSG9pc3RhYmxlUm9vdCIsInByZXZSb290U3RhdGUiLCJyZWN1cnNpdmVseVJlc2V0Rm9ybXMiLCJfcHJldmlvdXNIb2lzdGFibGVSb290IiwiX2NvbnRhaW5lckluZm8iLCJfcGVuZGluZ0NoaWxkcmVuIiwiaXNTaG93aW5nRmFsbGJhY2siLCJ3YXNTaG93aW5nRmFsbGJhY2siLCJtYXJrQ29tbWl0VGltZU9mRmFsbGJhY2siLCJpc1VwZGF0ZSIsIndhc0hpZGRlbkJ5QW5jZXN0b3JPZmZzY3JlZW4iLCJyZWN1cnNpdmVseVRyYXZlcnNlRGlzYXBwZWFyTGF5b3V0RWZmZWN0cyIsInJlc2V0Rm9ybU9uRmliZXIiLCJmb3JtSW5zdGFuY2UiLCJjb21taXRMYXlvdXRFZmZlY3RzIiwiZGlzYXBwZWFyTGF5b3V0RWZmZWN0cyIsInJlYXBwZWFyTGF5b3V0RWZmZWN0cyIsIm9mZnNjcmVlblN0YXRlIiwiY2hpbGRTaG91bGRJbmNsdWRlV29ya0luUHJvZ3Jlc3NFZmZlY3RzIiwiY29tbWl0SG9va1Bhc3NpdmVNb3VudEVmZmVjdHMiLCJjb21taXRPZmZzY3JlZW5QYXNzaXZlTW91bnRFZmZlY3RzIiwiY29tbWl0Q2FjaGVQYXNzaXZlTW91bnRFZmZlY3QiLCJjb21taXRQYXNzaXZlTW91bnRFZmZlY3RzIiwiY29tbWl0dGVkVHJhbnNpdGlvbnMiLCJjb21taXRQYXNzaXZlTW91bnRPbkZpYmVyIiwicmVjdXJzaXZlbHlUcmF2ZXJzZVBhc3NpdmVNb3VudEVmZmVjdHMiLCJyZWN1cnNpdmVseVRyYXZlcnNlQXRvbWljUGFzc2l2ZUVmZmVjdHMiLCJyZWN1cnNpdmVseVRyYXZlcnNlUmVjb25uZWN0UGFzc2l2ZUVmZmVjdHMiLCJfY3VycmVudDIiLCJyZWNvbm5lY3RQYXNzaXZlRWZmZWN0cyIsIl9pbnN0YW5jZTQiLCJfY3VycmVudDMiLCJfY3VycmVudDQiLCJjb21taXRBdG9taWNQYXNzaXZlRWZmZWN0cyIsIl9jdXJyZW50NSIsImNvbW1pdFBhc3NpdmVVbm1vdW50RWZmZWN0cyIsImNvbW1pdFBhc3NpdmVVbm1vdW50T25GaWJlciIsInN1c3BlbnNleUNvbW1pdEZsYWciLCJhY2N1bXVsYXRlU3VzcGVuc2V5Q29tbWl0IiwiYWNjdW11bGF0ZVN1c3BlbnNleUNvbW1pdE9uRmliZXIiLCJyZWN1cnNpdmVseUFjY3VtdWxhdGVTdXNwZW5zZXlDb21taXQiLCJfcHJvcHMiLCJwcmV2RmxhZ3MiLCJkZXRhY2hBbHRlcm5hdGVTaWJsaW5ncyIsInByZXZpb3VzRmliZXIiLCJkZXRhY2hlZENoaWxkIiwiZGV0YWNoZWRTaWJsaW5nIiwiY29tbWl0SG9va1Bhc3NpdmVVbm1vdW50RWZmZWN0cyIsInJlY3Vyc2l2ZWx5VHJhdmVyc2VQYXNzaXZlVW5tb3VudEVmZmVjdHMiLCJjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2JlZ2luIiwicmVjdXJzaXZlbHlUcmF2ZXJzZURpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0cyIsImRpc2Nvbm5lY3RQYXNzaXZlRWZmZWN0IiwiZGVsZXRlZFN1YnRyZWVSb290IiwiY29tbWl0UGFzc2l2ZVVubW91bnRJbnNpZGVEZWxldGVkVHJlZU9uRmliZXIiLCJjb21taXRQYXNzaXZlVW5tb3VudEVmZmVjdHNJbnNpZGVPZkRlbGV0ZWRUcmVlX2NvbXBsZXRlIiwiZ2V0Q2FjaGVGb3JUeXBlIiwicmVzb3VyY2VUeXBlIiwiY2FjaGVGb3JUeXBlIiwiRGVmYXVsdEFzeW5jRGlzcGF0Y2hlciIsImdldE93bmVyIiwiQ09NUE9ORU5UX1RZUEUiLCJIQVNfUFNFVURPX0NMQVNTX1RZUEUiLCJST0xFX1RZUEUiLCJURVNUX05BTUVfVFlQRSIsIlRFWFRfVFlQRSIsInN5bWJvbEZvciIsImNyZWF0ZUNvbXBvbmVudFNlbGVjdG9yIiwiY3JlYXRlSGFzUHNldWRvQ2xhc3NTZWxlY3RvciIsInNlbGVjdG9ycyIsImNyZWF0ZVJvbGVTZWxlY3RvciIsInJvbGUiLCJjcmVhdGVUZXh0U2VsZWN0b3IiLCJjcmVhdGVUZXN0TmFtZVNlbGVjdG9yIiwiZmluZEZpYmVyUm9vdEZvckhvc3RSb290IiwiaG9zdFJvb3QiLCJtYXliZUZpYmVyIiwibWF0Y2hTZWxlY3RvciIsInNlbGVjdG9yIiwiaGFzTWF0Y2hpbmdQYXRocyIsImRhdGFUZXN0SUQiLCJzZWxlY3RvclRvU3RyaW5nIiwiZmluZFBhdGhzIiwibWF0Y2hpbmdGaWJlcnMiLCJzZWxlY3RvckluZGV4IiwiZmluZEFsbE5vZGVzIiwiaW5zdGFuY2VSb290cyIsImZyb20iLCJnZXRGaW5kQWxsTm9kZXNGYWlsdXJlRGVzY3JpcHRpb24iLCJtYXhTZWxlY3RvckluZGV4IiwibWF0Y2hlZE5hbWVzIiwidW5tYXRjaGVkTmFtZXMiLCJmaW5kQm91bmRpbmdSZWN0cyIsImJvdW5kaW5nUmVjdHMiLCJ0YXJnZXRSZWN0IiwidGFyZ2V0TGVmdCIsInRhcmdldFJpZ2h0Iiwid2lkdGgiLCJ0YXJnZXRUb3AiLCJ0YXJnZXRCb3R0b20iLCJoZWlnaHQiLCJqIiwib3RoZXJSZWN0Iiwib3RoZXJMZWZ0Iiwib3RoZXJSaWdodCIsIm90aGVyVG9wIiwib3RoZXJCb3R0b20iLCJzcGxpY2UiLCJmb2N1c1dpdGhpbiIsImNvbW1pdEhvb2tzIiwib25Db21taXRSb290IiwiY29tbWl0SG9vayIsIm9ic2VydmVWaXNpYmxlUmVjdHMiLCJfc2V0dXBJbnRlcnNlY3Rpb25PYnMiLCJkaXNjb25uZWN0Iiwib2JzZXJ2ZSIsInVub2JzZXJ2ZSIsIm5leHRJbnN0YW5jZVJvb3RzIiwidGFyZ2V0IiwiaXNDb25jdXJyZW50QWN0RW52aXJvbm1lbnQiLCJpc1JlYWN0QWN0RW52aXJvbm1lbnRHbG9iYWwiLCJJU19SRUFDVF9BQ1RfRU5WSVJPTk1FTlQiLCJQb3NzaWJseVdlYWtNYXAiLCJCYXRjaGVkQ29udGV4dCIsIlJvb3RJblByb2dyZXNzIiwiUm9vdEZhdGFsRXJyb3JlZCIsIlJvb3RFcnJvcmVkIiwiUm9vdFN1c3BlbmRlZCIsIlJvb3RTdXNwZW5kZWRXaXRoRGVsYXkiLCJSb290Q29tcGxldGVkIiwiUm9vdERpZE5vdENvbXBsZXRlIiwiTm90U3VzcGVuZGVkIiwiU3VzcGVuZGVkT25FcnJvciIsIlN1c3BlbmRlZE9uRGF0YSIsIlN1c3BlbmRlZE9uSW1tZWRpYXRlIiwiU3VzcGVuZGVkT25JbnN0YW5jZSIsIlN1c3BlbmRlZE9uSW5zdGFuY2VBbmRSZWFkeVRvQ29udGludWUiLCJTdXNwZW5kZWRPbkRlcHJlY2F0ZWRUaHJvd1Byb21pc2UiLCJTdXNwZW5kZWRBbmRSZWFkeVRvQ29udGludWUiLCJTdXNwZW5kZWRPbkh5ZHJhdGlvbiIsIndvcmtJblByb2dyZXNzU3VzcGVuZGVkUmVhc29uIiwid29ya0luUHJvZ3Jlc3NUaHJvd25WYWx1ZSIsIndvcmtJblByb2dyZXNzUm9vdERpZEF0dGFjaFBpbmdMaXN0ZW5lciIsImVudGFuZ2xlZFJlbmRlckxhbmVzIiwid29ya0luUHJvZ3Jlc3NSb290RXhpdFN0YXR1cyIsIndvcmtJblByb2dyZXNzUm9vdFNraXBwZWRMYW5lcyIsIndvcmtJblByb2dyZXNzUm9vdEludGVybGVhdmVkVXBkYXRlZExhbmVzIiwid29ya0luUHJvZ3Jlc3NSb290UGluZ2VkTGFuZXMiLCJ3b3JrSW5Qcm9ncmVzc0RlZmVycmVkTGFuZSIsIndvcmtJblByb2dyZXNzUm9vdENvbmN1cnJlbnRFcnJvcnMiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RSZWNvdmVyYWJsZUVycm9ycyIsIndvcmtJblByb2dyZXNzUm9vdERpZEluY2x1ZGVSZWN1cnNpdmVSZW5kZXJVcGRhdGUiLCJkaWRJbmNsdWRlQ29tbWl0UGhhc2VVcGRhdGUiLCJnbG9iYWxNb3N0UmVjZW50RmFsbGJhY2tUaW1lIiwiRkFMTEJBQ0tfVEhST1RUTEVfTVMiLCJ3b3JrSW5Qcm9ncmVzc1Jvb3RSZW5kZXJUYXJnZXRUaW1lIiwiSW5maW5pdHkiLCJSRU5ERVJfVElNRU9VVF9NUyIsIndvcmtJblByb2dyZXNzVHJhbnNpdGlvbnMiLCJyZXNldFJlbmRlclRpbWVyIiwibGVnYWN5RXJyb3JCb3VuZGFyaWVzVGhhdEFscmVhZHlGYWlsZWQiLCJyb290RG9lc0hhdmVQYXNzaXZlRWZmZWN0cyIsInJvb3RXaXRoUGVuZGluZ1Bhc3NpdmVFZmZlY3RzIiwicGVuZGluZ1Bhc3NpdmVFZmZlY3RzTGFuZXMiLCJwZW5kaW5nUGFzc2l2ZVByb2ZpbGVyRWZmZWN0cyIsInBlbmRpbmdQYXNzaXZlRWZmZWN0c1JlbWFpbmluZ0xhbmVzIiwicGVuZGluZ1Bhc3NpdmVUcmFuc2l0aW9ucyIsIk5FU1RFRF9VUERBVEVfTElNSVQiLCJuZXN0ZWRVcGRhdGVDb3VudCIsInJvb3RXaXRoTmVzdGVkVXBkYXRlcyIsImlzRmx1c2hpbmdQYXNzaXZlRWZmZWN0cyIsImRpZFNjaGVkdWxlVXBkYXRlRHVyaW5nUGFzc2l2ZUVmZmVjdHMiLCJORVNURURfUEFTU0lWRV9VUERBVEVfTElNSVQiLCJuZXN0ZWRQYXNzaXZlVXBkYXRlQ291bnQiLCJyb290V2l0aFBhc3NpdmVOZXN0ZWRVcGRhdGVzIiwiaXNSdW5uaW5nSW5zZXJ0aW9uRWZmZWN0IiwiYWN0aW9uU2NvcGVMYW5lIiwicmVxdWVzdFJldHJ5TGFuZSIsImlzUHJlcmVuZGVyaW5nIiwic3VzcGVuc2VIYW5kbGVyIiwicHJlcGFyZUZyZXNoU3RhY2siLCJtYXJrUm9vdFN1c3BlbmRlZCIsIm1hcmtSb290VXBkYXRlZCIsIndhcm5BYm91dFJlbmRlclBoYXNlVXBkYXRlc0luREVWIiwid2FybklmVXBkYXRlc05vdFdyYXBwZWRXaXRoQWN0REVWIiwiaXNCYXRjaGluZ0xlZ2FjeSIsInNjaGVkdWxlSW5pdGlhbEh5ZHJhdGlvbk9uUm9vdCIsImRpZFRpbWVvdXQiLCJkaWRGbHVzaFBhc3NpdmVFZmZlY3RzIiwiZmx1c2hQYXNzaXZlRWZmZWN0cyIsInNob3VsZFRpbWVTbGljZSIsImV4aXRTdGF0dXMiLCJyZW5kZXJSb290Q29uY3VycmVudCIsInJlbmRlclJvb3RTeW5jIiwicmVuZGVyV2FzQ29uY3VycmVudCIsImlzUmVuZGVyQ29uc2lzdGVudFdpdGhFeHRlcm5hbFN0b3JlcyIsImxhbmVzVGhhdEp1c3RFcnJvcmVkIiwiZXJyb3JSZXRyeUxhbmVzIiwicmVjb3ZlckZyb21Db25jdXJyZW50RXJyb3IiLCJmaW5pc2hlZExhbmVzIiwiZmluaXNoQ29uY3VycmVudFJlbmRlciIsImVycm9yc0Zyb21GaXJzdEF0dGVtcHQiLCJ3YXNSb290RGVoeWRyYXRlZCIsInJvb3RXb3JrSW5Qcm9ncmVzcyIsImVycm9yc0Zyb21TZWNvbmRBdHRlbXB0IiwiZXJyb3JzIiwic2hvdWxkRm9yY2VGbHVzaEZhbGxiYWNrc0luREVWIiwiY29tbWl0Um9vdCIsIm1zVW50aWxUaW1lb3V0IiwidGltZW91dEhhbmRsZSIsImNvbW1pdFJvb3RXaGVuUmVhZHkiLCJyZWNvdmVyYWJsZUVycm9ycyIsImRpZEluY2x1ZGVSZW5kZXJQaGFzZVVwZGF0ZSIsIkJvdGhWaXNpYmlsaXR5QW5kTWF5U3VzcGVuZENvbW1pdCIsInNjaGVkdWxlUGVuZGluZ0NvbW1pdCIsImNoZWNrcyIsInJlbmRlcmVkVmFsdWUiLCJ1cGRhdGVkTGFuZXMiLCJtYXJrUm9vdFBpbmdlZCIsImZsdXNoUm9vdCIsImRlZmVycmVkVXBkYXRlcyIsImJhdGNoZWRVcGRhdGVzIiwiZGlzY3JldGVVcGRhdGVzIiwiZCIsImZsdXNoU3luY0Zyb21SZWNvbmNpbGVyIiwicHJldkV4ZWN1dGlvbkNvbnRleHQiLCJmbHVzaFN5bmNXb3JrIiwiaXNBbHJlYWR5UmVuZGVyaW5nIiwibmV3RW50YW5nbGVkUmVuZGVyTGFuZXMiLCJyZXNldFdvcmtJblByb2dyZXNzU3RhY2siLCJyZXNldFN1c3BlbmRlZFdvcmtMb29wT25VbndpbmQiLCJoYW5kbGVUaHJvdyIsImlzV2FrZWFibGUiLCJlcnJvcmVkV29yayIsInB1c2hEaXNwYXRjaGVyIiwicG9wRGlzcGF0Y2hlciIsInB1c2hBc3luY0Rpc3BhdGNoZXIiLCJwcmV2QXN5bmNEaXNwYXRjaGVyIiwiQSIsInBvcEFzeW5jRGlzcGF0Y2hlciIsImRpZFN1c3BlbmRJblNoZWxsIiwidW5pdE9mV29yayIsInRocm93QW5kVW53aW5kV29ya0xvb3AiLCJ3b3JrTG9vcFN5bmMiLCJwZXJmb3JtVW5pdE9mV29yayIsInJlc3VtZU9yVW53aW5kIiwicmVwbGF5U3VzcGVuZGVkVW5pdE9mV29yayIsIm9uUmVzb2x1dGlvbiIsIl90aGVuYWJsZSIsImhvc3RGaWJlciIsImNvbXBsZXRlVW5pdE9mV29yayIsIndvcmtMb29wQ29uY3VycmVudCIsImlzUHJvZmlsaW5nTW9kZSIsImRpZEZhdGFsIiwicGFuaWNPblJvb3RFcnJvciIsInVud2luZFVuaXRPZldvcmsiLCJzaWJsaW5nRmliZXIiLCJpbmNvbXBsZXRlV29yayIsInByZXZpb3VzVXBkYXRlTGFuZVByaW9yaXR5IiwiY29tbWl0Um9vdEltcGwiLCJyZW5kZXJQcmlvcml0eUxldmVsIiwiZmx1c2hSZW5kZXJQaGFzZVN0cmljdE1vZGVXYXJuaW5nc0luREVWIiwic2NoZWR1bGVDYWxsYmFjayIsInN1YnRyZWVIYXNFZmZlY3RzIiwicm9vdEhhc0VmZmVjdCIsInJvb3REaWRIYXZlUGFzc2l2ZUVmZmVjdHMiLCJyZWxlYXNlUm9vdFBvb2xlZENhY2hlIiwiY29tbWl0RG91YmxlSW52b2tlRWZmZWN0c0luREVWIiwib25SZWNvdmVyYWJsZUVycm9yIiwibWFrZUVycm9ySW5mbyIsInJlbmRlclByaW9yaXR5IiwicHJpb3JpdHkiLCJmbHVzaFBhc3NpdmVFZmZlY3RzSW1wbCIsInByb2ZpbGVyRWZmZWN0cyIsImNhcHR1cmVDb21taXRQaGFzZUVycm9yT25Sb290Iiwicm9vdEZpYmVyIiwicGluZ0NhY2hlIiwidGhyZWFkSURzIiwicGluZyIsInBpbmdTdXNwZW5kZWRSb290Iiwid2FybklmU3VzcGVuc2VSZXNvbHV0aW9uTm90V3JhcHBlZFdpdGhBY3RERVYiLCJyZXRyeVRpbWVkT3V0Qm91bmRhcnkiLCJib3VuZGFyeUZpYmVyIiwicmVjdXJzaXZlbHlUcmF2ZXJzZUFuZERvdWJsZUludm9rZUVmZmVjdHNJbkRFViIsImlzSW5TdHJpY3RNb2RlIiwiZG91YmxlSW52b2tlRWZmZWN0c0luREVWSWZOZWNlc3NhcnkiLCJkb3VibGVJbnZva2VFZmZlY3RzT25GaWJlciIsInNob3VsZERvdWJsZUludm9rZVBhc3NpdmVFZmZlY3RzIiwicGFyZW50SXNJblN0cmljdE1vZGUiLCJpc1N0cmljdE1vZGVGaWJlciIsImhhc1Bhc3NpdmVFZmZlY3RzIiwiZG91YmxlSW52b2tlRWZmZWN0cyIsImRpZFdhcm5TdGF0ZVVwZGF0ZUZvck5vdFlldE1vdW50ZWRDb21wb25lbnQiLCJkaWRXYXJuQWJvdXRVcGRhdGVJblJlbmRlciIsImRpZFdhcm5BYm91dFVwZGF0ZUluUmVuZGVyRm9yQW5vdGhlckNvbXBvbmVudCIsInJlbmRlcmluZ0NvbXBvbmVudE5hbWUiLCJkZWR1cGVLZXkiLCJzZXRTdGF0ZUNvbXBvbmVudE5hbWUiLCJzY2hlZHVsaW5nRmliZXIiLCJmYWtlQWN0Q2FsbGJhY2tOb2RlIiwiaXNSdW5uaW5nIiwicmVzb2x2ZUZhbWlseSIsImZhaWxlZEJvdW5kYXJpZXMiLCJzZXRSZWZyZXNoSGFuZGxlciIsImZhbWlseSIsImN1cnJlbnRSZW5kZXIiLCJzeW50aGV0aWNUeXBlIiwicHJldlR5cGUiLCJuZXh0VHlwZSIsIm5lZWRzQ29tcGFyZUZhbWlsaWVzIiwiJCR0eXBlb2ZOZXh0VHlwZSIsInByZXZGYW1pbHkiLCJzY2hlZHVsZVJlZnJlc2giLCJzdGFsZUZhbWlsaWVzIiwidXBkYXRlZEZhbWlsaWVzIiwic2NoZWR1bGVGaWJlcnNXaXRoRmFtaWxpZXNSZWN1cnNpdmVseSIsInNjaGVkdWxlUm9vdCIsInVwZGF0ZUNvbnRhaW5lclN5bmMiLCJjYW5kaWRhdGVUeXBlIiwibmVlZHNSZW5kZXIiLCJuZWVkc1JlbW91bnQiLCJmaW5kSG9zdEluc3RhbmNlc0ZvclJlZnJlc2giLCJmYW1pbGllcyIsImhvc3RJbnN0YW5jZXMiLCJ0eXBlcyIsImZpbmRIb3N0SW5zdGFuY2VzRm9yTWF0Y2hpbmdGaWJlcnNSZWN1cnNpdmVseSIsImRpZE1hdGNoIiwiZmluZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseSIsImZvdW5kSG9zdEluc3RhbmNlcyIsImZpbmRDaGlsZEhvc3RJbnN0YW5jZXNGb3JGaWJlclNoYWxsb3dseSIsImhhc0JhZE1hcFBvbHlmaWxsIiwibm9uRXh0ZW5zaWJsZU9iamVjdCIsInByZXZlbnRFeHRlbnNpb25zIiwiRmliZXJOb2RlIiwiTnVtYmVyIiwiTmFOIiwiY3JlYXRlRmliZXIiLCJzaG91bGRDb25zdHJ1Y3QiLCJpc1JlYWN0Q29tcG9uZW50IiwiY3VycmVudERlcGVuZGVuY2llcyIsImNyZWF0ZUhvc3RSb290RmliZXIiLCJpc1N0cmljdE1vZGUiLCJjb25jdXJyZW50VXBkYXRlc0J5RGVmYXVsdE92ZXJyaWRlIiwiZmliZXJUYWciLCJfaG9zdENvbnRleHQiLCJnZXRUYWciLCJjcmVhdGVGaWJlckZyb21Qcm9maWxlciIsImNyZWF0ZUZpYmVyRnJvbVN1c3BlbnNlIiwiY3JlYXRlRmliZXJGcm9tU3VzcGVuc2VMaXN0IiwidHlwZVN0cmluZyIsImVsZW1lbnRzIiwicHJpbWFyeUNoaWxkSW5zdGFuY2UiLCJfcGVuZGluZ01hcmtlcnMiLCJfdHJhbnNpdGlvbnMiLCJkZXRhY2giLCJhdHRhY2giLCJkZWh5ZHJhdGVkTm9kZSIsIkZpYmVyUm9vdE5vZGUiLCJoeWRyYXRlIiwiaW5jb21wbGV0ZVRyYW5zaXRpb25zIiwiX2RlYnVnUm9vdFR5cGUiLCJjcmVhdGVGaWJlclJvb3QiLCJpbml0aWFsQ2hpbGRyZW4iLCJ0cmFuc2l0aW9uQ2FsbGJhY2tzIiwidW5pbml0aWFsaXplZEZpYmVyIiwiaW5pdGlhbENhY2hlIiwiUmVhY3RWZXJzaW9uIiwidHlwZU5hbWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiY29uc3RydWN0b3IiLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImNoZWNrS2V5U3RyaW5nQ29lcmNpb24iLCJjcmVhdGVQb3J0YWwiLCJkaWRXYXJuQWJvdXROZXN0ZWRVcGRhdGVzIiwiZGlkV2FybkFib3V0RmluZE5vZGVJblN0cmljdE1vZGUiLCJnZXRDb250ZXh0Rm9yU3VidHJlZSIsInBhcmVudENvbXBvbmVudCIsImZpbmRIb3N0SW5zdGFuY2UiLCJmaW5kSG9zdEluc3RhbmNlV2l0aFdhcm5pbmciLCJtZXRob2ROYW1lIiwiY3JlYXRlQ29udGFpbmVyIiwiY3JlYXRlSHlkcmF0aW9uQ29udGFpbmVyIiwidXBkYXRlQ29udGFpbmVyIiwidXBkYXRlQ29udGFpbmVySW1wbCIsImdldFB1YmxpY1Jvb3RJbnN0YW5jZSIsImNvbnRhaW5lckZpYmVyIiwiYXR0ZW1wdFN5bmNocm9ub3VzSHlkcmF0aW9uIiwiX3Jvb3QiLCJtYXJrUmV0cnlMYW5lSWZOb3RIeWRyYXRlZCIsIm1hcmtSZXRyeUxhbmVJbXBsIiwiYXR0ZW1wdENvbnRpbnVvdXNIeWRyYXRpb24iLCJhdHRlbXB0SHlkcmF0aW9uQXRDdXJyZW50UHJpb3JpdHkiLCJmaW5kSG9zdEluc3RhbmNlV2l0aE5vUG9ydGFscyIsInNob3VsZEVycm9ySW1wbCIsInNob3VsZFN1c3BlbmRJbXBsIiwib3ZlcnJpZGVIb29rU3RhdGUiLCJvdmVycmlkZUhvb2tTdGF0ZURlbGV0ZVBhdGgiLCJvdmVycmlkZUhvb2tTdGF0ZVJlbmFtZVBhdGgiLCJvdmVycmlkZVByb3BzIiwib3ZlcnJpZGVQcm9wc0RlbGV0ZVBhdGgiLCJvdmVycmlkZVByb3BzUmVuYW1lUGF0aCIsInNjaGVkdWxlVXBkYXRlIiwic2V0RXJyb3JIYW5kbGVyIiwic2V0U3VzcGVuc2VIYW5kbGVyIiwiY29weVdpdGhEZWxldGVJbXBsIiwib2JqIiwicGF0aCIsImNvcHlXaXRoRGVsZXRlIiwiY29weVdpdGhSZW5hbWVJbXBsIiwib2xkUGF0aCIsIm5ld1BhdGgiLCJvbGRLZXkiLCJuZXdLZXkiLCJjb3B5V2l0aFJlbmFtZSIsImNvcHlXaXRoU2V0SW1wbCIsImNvcHlXaXRoU2V0IiwiZmluZEhvb2siLCJuZXdTaG91bGRFcnJvckltcGwiLCJuZXdTaG91bGRTdXNwZW5kSW1wbCIsImZpbmRIb3N0SW5zdGFuY2VCeUZpYmVyIiwiZW1wdHlGaW5kRmliZXJCeUhvc3RJbnN0YW5jZSIsImdldEN1cnJlbnRGaWJlckZvckRldlRvb2xzIiwiaW5qZWN0SW50b0RldlRvb2xzIiwiZGV2VG9vbHNDb25maWciLCJmaW5kRmliZXJCeUhvc3RJbnN0YW5jZSIsImJ1bmRsZVR5cGUiLCJ2ZXJzaW9uIiwicmVuZGVyZXJQYWNrYWdlTmFtZSIsInJlbmRlcmVyQ29uZmlnIiwiY3VycmVudERpc3BhdGNoZXJSZWYiLCJyZWNvbmNpbGVyVmVyc2lvbiIsImRlZmF1bHQiXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0/node_modules/react-reconciler/cjs/react-reconciler.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0/node_modules/react-reconciler/constants.js":
/*!***********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0/node_modules/react-reconciler/constants.js ***!
  \***********************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-reconciler-constants.development.js */ \"(ssr)/./node_modules/.pnpm/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0/node_modules/react-reconciler/cjs/react-reconciler-constants.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtcmVjb25jaWxlckAwLjMxLjAtcmMtOTM1MTgwYzdlMC0yMDI0MDUyNF9yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL3JlYWN0LXJlY29uY2lsZXIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSxpUUFBMkU7QUFDN0UiLCJzb3VyY2VzIjpbIi9Vc2Vycy9taG1kL0RvY3VtZW50cy9HaXRIdWIvQVdNLWRhdGF0aG9uL25vZGVfbW9kdWxlcy8ucG5wbS9yZWFjdC1yZWNvbmNpbGVyQDAuMzEuMC1yYy05MzUxODBjN2UwLTIwMjQwNTI0X3JlYWN0QDE5LjAuMC9ub2RlX21vZHVsZXMvcmVhY3QtcmVjb25jaWxlci9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3JlYWN0LXJlY29uY2lsZXItY29uc3RhbnRzLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtcmVjb25jaWxlci1jb25zdGFudHMuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0/node_modules/react-reconciler/constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0/node_modules/react-reconciler/index.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0/node_modules/react-reconciler/index.js ***!
  \*******************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-reconciler.development.js */ \"(ssr)/./node_modules/.pnpm/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0/node_modules/react-reconciler/cjs/react-reconciler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcmVhY3QtcmVjb25jaWxlckAwLjMxLjAtcmMtOTM1MTgwYzdlMC0yMDI0MDUyNF9yZWFjdEAxOS4wLjAvbm9kZV9tb2R1bGVzL3JlYWN0LXJlY29uY2lsZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLDZPQUFpRTtBQUNuRSIsInNvdXJjZXMiOlsiL1VzZXJzL21obWQvRG9jdW1lbnRzL0dpdEh1Yi9BV00tZGF0YXRob24vbm9kZV9tb2R1bGVzLy5wbnBtL3JlYWN0LXJlY29uY2lsZXJAMC4zMS4wLXJjLTkzNTE4MGM3ZTAtMjAyNDA1MjRfcmVhY3RAMTkuMC4wL25vZGVfbW9kdWxlcy9yZWFjdC1yZWNvbmNpbGVyL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1yZWNvbmNpbGVyLnByb2R1Y3Rpb24uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtcmVjb25jaWxlci5kZXZlbG9wbWVudC5qcycpO1xufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/react-reconciler@0.31.0-rc-935180c7e0-20240524_react@19.0.0/node_modules/react-reconciler/index.js\n");

/***/ })

};
;